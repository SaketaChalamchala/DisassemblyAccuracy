.bss:00000000 ;
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.bss:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.bss:00000000 ; |                      License info: 48-3677-7074-51                      |
.bss:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ;
.bss:00000000 ; Input MD5   : 0B9FC93608F666B8506195095B60254C
.bss:00000000 ; Input CRC32 : F8C747E6
.bss:00000000
.bss:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\LoadCodecs.obj
.bss:00000000 ; Format      : COFF (X386MAGIC)
.bss:00000000 ; includelib "uuid.lib"
.bss:00000000 ; includelib "MSVCRTD"
.bss:00000000 ; includelib "OLDNAMES"
.bss:00000000
.bss:00000000                 .686p
.bss:00000000                 .mmx
.bss:00000000                 .model flat
.bss:00000000
.bss:00000000 ; ===========================================================================
.bss:00000000
.bss:00000000 ; Segment type: Uninitialized
.bss:00000000 ; Segment permissions: Read/Write
.bss:00000000 ; Segment alignment 'qword' can not be represented in assembly
.bss:00000000 _bss            segment para public 'BSS' use32
.bss:00000000                 assume cs:_bss
.bss:00000000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00000000 _g_Arcs         dd ?                    ; DATA XREF: RegisterArc(CArcInfo const *)+14w
.bss:00000000                                         ; CCodecs::Load(void)+6Cr
.bss:00000004                 db    ? ;
.bss:00000005                 db    ? ;
.bss:00000006                 db    ? ;
.bss:00000007                 db    ? ;
.bss:00000008                 db    ? ;
.bss:00000009                 db    ? ;
.bss:0000000A                 db    ? ;
.bss:0000000B                 db    ? ;
.bss:0000000C                 db    ? ;
.bss:0000000D                 db    ? ;
.bss:0000000E                 db    ? ;
.bss:0000000F                 db    ? ;
.bss:00000010                 db    ? ;
.bss:00000011                 db    ? ;
.bss:00000012                 db    ? ;
.bss:00000013                 db    ? ;
.bss:00000014                 db    ? ;
.bss:00000015                 db    ? ;
.bss:00000016                 db    ? ;
.bss:00000017                 db    ? ;
.bss:00000018                 db    ? ;
.bss:00000019                 db    ? ;
.bss:0000001A                 db    ? ;
.bss:0000001B                 db    ? ;
.bss:0000001C                 db    ? ;
.bss:0000001D                 db    ? ;
.bss:0000001E                 db    ? ;
.bss:0000001F                 db    ? ;
.bss:00000020                 db    ? ;
.bss:00000021                 db    ? ;
.bss:00000022                 db    ? ;
.bss:00000023                 db    ? ;
.bss:00000024                 db    ? ;
.bss:00000025                 db    ? ;
.bss:00000026                 db    ? ;
.bss:00000027                 db    ? ;
.bss:00000028                 db    ? ;
.bss:00000029                 db    ? ;
.bss:0000002A unk_2A          db    ? ;               ; DATA XREF: .rdata:$SG69184o
.bss:0000002A                                         ; .rdata:$SG69396o
.bss:0000002B                 db    ? ;
.bss:0000002C                 db    ? ;
.bss:0000002D                 db    ? ;
.bss:0000002E                 db    ? ;
.bss:0000002F                 db    ? ;
.bss:00000030                 db    ? ;
.bss:00000031                 db    ? ;
.bss:00000032                 db    ? ;
.bss:00000033                 db    ? ;
.bss:00000034                 db    ? ;
.bss:00000035                 db    ? ;
.bss:00000036                 db    ? ;
.bss:00000037                 db    ? ;
.bss:00000038                 db    ? ;
.bss:00000039                 db    ? ;
.bss:0000003A                 db    ? ;
.bss:0000003B                 db    ? ;
.bss:0000003C                 db    ? ;
.bss:0000003D                 db    ? ;
.bss:0000003E                 db    ? ;
.bss:0000003F                 db    ? ;
.bss:00000040                 db    ? ;
.bss:00000041                 db    ? ;
.bss:00000042                 db    ? ;
.bss:00000043                 db    ? ;
.bss:00000044                 db    ? ;
.bss:00000045                 db    ? ;
.bss:00000046                 db    ? ;
.bss:00000047                 db    ? ;
.bss:00000048                 db    ? ;
.bss:00000049                 db    ? ;
.bss:0000004A                 db    ? ;
.bss:0000004B                 db    ? ;
.bss:0000004C                 db    ? ;
.bss:0000004D                 db    ? ;
.bss:0000004E                 db    ? ;
.bss:0000004F                 db    ? ;
.bss:00000050                 db    ? ;
.bss:00000051                 db    ? ;
.bss:00000052                 db    ? ;
.bss:00000053                 db    ? ;
.bss:00000054                 db    ? ;
.bss:00000055                 db    ? ;
.bss:00000056                 db    ? ;
.bss:00000057                 db    ? ;
.bss:00000058                 db    ? ;
.bss:00000059                 db    ? ;
.bss:0000005A                 db    ? ;
.bss:0000005B                 db    ? ;
.bss:0000005C                 db    ? ;
.bss:0000005D                 db    ? ;
.bss:0000005E                 db    ? ;
.bss:0000005F                 db    ? ;
.bss:00000060                 db    ? ;
.bss:00000061                 db    ? ;
.bss:00000062                 db    ? ;
.bss:00000063                 db    ? ;
.bss:00000064                 db    ? ;
.bss:00000065                 db    ? ;
.bss:00000066                 db    ? ;
.bss:00000067                 db    ? ;
.bss:00000068                 db    ? ;
.bss:00000069                 db    ? ;
.bss:0000006A                 db    ? ;
.bss:0000006B                 db    ? ;
.bss:0000006C                 db    ? ;
.bss:0000006D                 db    ? ;
.bss:0000006E                 db    ? ;
.bss:0000006F                 db    ? ;
.bss:00000070                 db    ? ;
.bss:00000071                 db    ? ;
.bss:00000072                 db    ? ;
.bss:00000073                 db    ? ;
.bss:00000074                 db    ? ;
.bss:00000075                 db    ? ;
.bss:00000076                 db    ? ;
.bss:00000077                 db    ? ;
.bss:00000078                 db    ? ;
.bss:00000079                 db    ? ;
.bss:0000007A                 db    ? ;
.bss:0000007B                 db    ? ;
.bss:0000007C                 db    ? ;
.bss:0000007D                 db    ? ;
.bss:0000007E                 db    ? ;
.bss:0000007F                 db    ? ;
.bss:00000080                 db    ? ;
.bss:00000081                 db    ? ;
.bss:00000082                 db    ? ;
.bss:00000083                 db    ? ;
.bss:00000084                 db    ? ;
.bss:00000085                 db    ? ;
.bss:00000086                 db    ? ;
.bss:00000087                 db    ? ;
.bss:00000088                 db    ? ;
.bss:00000089                 db    ? ;
.bss:0000008A                 db    ? ;
.bss:0000008B                 db    ? ;
.bss:0000008C                 db    ? ;
.bss:0000008D                 db    ? ;
.bss:0000008E                 db    ? ;
.bss:0000008F                 db    ? ;
.bss:00000090                 db    ? ;
.bss:00000091                 db    ? ;
.bss:00000092                 db    ? ;
.bss:00000093                 db    ? ;
.bss:00000094                 db    ? ;
.bss:00000095                 db    ? ;
.bss:00000096                 db    ? ;
.bss:00000097                 db    ? ;
.bss:00000098                 db    ? ;
.bss:00000099                 db    ? ;
.bss:0000009A                 db    ? ;
.bss:0000009B                 db    ? ;
.bss:0000009C                 db    ? ;
.bss:0000009D                 db    ? ;
.bss:0000009E                 db    ? ;
.bss:0000009F                 db    ? ;
.bss:000000A0                 db    ? ;
.bss:000000A1                 db    ? ;
.bss:000000A2                 db    ? ;
.bss:000000A3                 db    ? ;
.bss:000000A4                 db    ? ;
.bss:000000A5                 db    ? ;
.bss:000000A6                 db    ? ;
.bss:000000A7                 db    ? ;
.bss:000000A8                 db    ? ;
.bss:000000A9                 db    ? ;
.bss:000000AA                 db    ? ;
.bss:000000AB                 db    ? ;
.bss:000000AC                 db    ? ;
.bss:000000AD                 db    ? ;
.bss:000000AE                 db    ? ;
.bss:000000AF                 db    ? ;
.bss:000000B0                 db    ? ;
.bss:000000B1                 db    ? ;
.bss:000000B2                 db    ? ;
.bss:000000B3                 db    ? ;
.bss:000000B4                 db    ? ;
.bss:000000B5                 db    ? ;
.bss:000000B6                 db    ? ;
.bss:000000B7                 db    ? ;
.bss:000000B8                 db    ? ;
.bss:000000B9                 db    ? ;
.bss:000000BA                 db    ? ;
.bss:000000BB                 db    ? ;
.bss:000000BC                 db    ? ;
.bss:000000BD                 db    ? ;
.bss:000000BE                 db    ? ;
.bss:000000BF                 db    ? ;
.bss:000000C0                 db    ? ;
.bss:000000C1                 db    ? ;
.bss:000000C2                 db    ? ;
.bss:000000C3                 db    ? ;
.bss:000000C4                 db    ? ;
.bss:000000C5                 db    ? ;
.bss:000000C6                 db    ? ;
.bss:000000C7                 db    ? ;
.bss:000000C8                 db    ? ;
.bss:000000C9                 db    ? ;
.bss:000000CA                 db    ? ;
.bss:000000CB                 db    ? ;
.bss:000000CC                 db    ? ;
.bss:000000CD                 db    ? ;
.bss:000000CE                 db    ? ;
.bss:000000CF                 db    ? ;
.bss:000000D0                 db    ? ;
.bss:000000D1                 db    ? ;
.bss:000000D2                 db    ? ;
.bss:000000D3                 db    ? ;
.bss:000000D4                 db    ? ;
.bss:000000D5                 db    ? ;
.bss:000000D6                 db    ? ;
.bss:000000D7                 db    ? ;
.bss:000000D8                 db    ? ;
.bss:000000D9                 db    ? ;
.bss:000000DA                 db    ? ;
.bss:000000DB                 db    ? ;
.bss:000000DC                 db    ? ;
.bss:000000DD                 db    ? ;
.bss:000000DE                 db    ? ;
.bss:000000DF                 db    ? ;
.bss:000000E0                 db    ? ;
.bss:000000E1                 db    ? ;
.bss:000000E2                 db    ? ;
.bss:000000E3                 db    ? ;
.bss:000000E4                 db    ? ;
.bss:000000E5                 db    ? ;
.bss:000000E6                 db    ? ;
.bss:000000E7                 db    ? ;
.bss:000000E8                 db    ? ;
.bss:000000E9                 db    ? ;
.bss:000000EA                 db    ? ;
.bss:000000EB                 db    ? ;
.bss:000000EC                 db    ? ;
.bss:000000ED                 db    ? ;
.bss:000000EE                 db    ? ;
.bss:000000EF                 db    ? ;
.bss:000000F0                 db    ? ;
.bss:000000F1                 db    ? ;
.bss:000000F2                 db    ? ;
.bss:000000F3                 db    ? ;
.bss:000000F4                 db    ? ;
.bss:000000F5                 db    ? ;
.bss:000000F6                 db    ? ;
.bss:000000F7                 db    ? ;
.bss:000000F8                 db    ? ;
.bss:000000F9                 db    ? ;
.bss:000000FA                 db    ? ;
.bss:000000FB                 db    ? ;
.bss:000000FC                 db    ? ;
.bss:000000FD                 db    ? ;
.bss:000000FE                 db    ? ;
.bss:000000FF                 db    ? ;
.bss:00000100 _g_NumArcs      dd ?                    ; DATA XREF: RegisterArc(CArcInfo const *)+3r
.bss:00000100                                         ; RegisterArc(CArcInfo const *)+Cr ...
.bss:00000100 _bss            ends
.bss:00000100
.rdata:00000104 ; ===========================================================================
.rdata:00000104
.rdata:00000104 ; Segment type: Pure data
.rdata:00000104 ; Segment permissions: Read
.rdata:00000104 _rdata          segment dword public 'DATA' use32
.rdata:00000104                 assume cs:_rdata
.rdata:00000104                 ;org 104h
.rdata:00000104 ; wchar_t _SG69184
.rdata:00000104 $SG69184        dd offset unk_2A        ; DATA XREF: CArcInfoEx::AddExts(UString const &,UString const &)+D5o
.rdata:00000108 ; char _SG69255[4]
.rdata:00000108 $SG69255        db 'exe',0              ; DATA XREF: CCodecs::FindFormatForArchiveName(UString const &):loc_806o
.rdata:0000010C ; wchar_t _SG69396
.rdata:0000010C $SG69396        dd offset unk_2A        ; DATA XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+D6o
.rdata:0000010C _rdata          ends
.rdata:0000010C
.text:00000110 ; ===========================================================================
.text:00000110
.text:00000110 ; Segment type: Pure code
.text:00000110 ; Segment permissions: Read/Execute
.text:00000110 _text           segment para public 'CODE' use32
.text:00000110                 assume cs:_text
.text:00000110                 ;org 110h
.text:00000110                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000110
.text:00000110 ; =============== S U B R O U T I N E =======================================
.text:00000110
.text:00000110 ; Attributes: bp-based frame
.text:00000110
.text:00000110 ; void __stdcall RegisterArc(const struct CArcInfo *)
.text:00000110                 public ?RegisterArc@@YGXPBUCArcInfo@@@Z
.text:00000110 ?RegisterArc@@YGXPBUCArcInfo@@@Z proc near
.text:00000110
.text:00000110 arg_0           = dword ptr  8
.text:00000110
.text:00000110                 push    ebp
.text:00000111                 mov     ebp, esp
.text:00000113                 cmp     ds:_g_NumArcs, 40h ; '@'
.text:0000011A                 jnb     short loc_13A
.text:0000011C                 mov     eax, ds:_g_NumArcs
.text:00000121                 mov     ecx, [ebp+arg_0]
.text:00000124                 mov     ds:_g_Arcs[eax*4], ecx
.text:0000012B                 mov     edx, ds:_g_NumArcs
.text:00000131                 add     edx, 1
.text:00000134                 mov     ds:_g_NumArcs, edx
.text:0000013A
.text:0000013A loc_13A:                                ; CODE XREF: RegisterArc(CArcInfo const *)+Aj
.text:0000013A                 pop     ebp
.text:0000013B                 retn    4
.text:0000013B ?RegisterArc@@YGXPBUCArcInfo@@@Z endp
.text:0000013B
.text:0000013B ; ---------------------------------------------------------------------------
.text:0000013E                 align 10h
.text:00000140
.text:00000140 ; =============== S U B R O U T I N E =======================================
.text:00000140
.text:00000140 ; Attributes: bp-based frame
.text:00000140
.text:00000140 ; int __thiscall CArcInfoEx::FindExtension(CArcInfoEx *this, const struct UString *)
.text:00000140                 public ?FindExtension@CArcInfoEx@@QBEHABVUString@@@Z
.text:00000140 ?FindExtension@CArcInfoEx@@QBEHABVUString@@@Z proc near
.text:00000140                                         ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+110p
.text:00000140                                         ; CCodecs::FindFormatForExtension(UString const &)+62p
.text:00000140
.text:00000140 var_8           = dword ptr -8
.text:00000140 var_4           = dword ptr -4
.text:00000140 arg_0           = dword ptr  8
.text:00000140
.text:00000140                 push    ebp
.text:00000141                 mov     ebp, esp
.text:00000143                 sub     esp, 8
.text:00000146                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000014D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000154                 mov     [ebp+var_4], ecx
.text:00000157                 mov     [ebp+var_8], 0
.text:0000015E                 jmp     short loc_169
.text:00000160 ; ---------------------------------------------------------------------------
.text:00000160
.text:00000160 loc_160:                                ; CODE XREF: CArcInfoEx::FindExtension(UString const &):loc_1A4j
.text:00000160                 mov     eax, [ebp+var_8]
.text:00000163                 add     eax, 1
.text:00000166                 mov     [ebp+var_8], eax
.text:00000169
.text:00000169 loc_169:                                ; CODE XREF: CArcInfoEx::FindExtension(UString const &)+1Ej
.text:00000169                 mov     ecx, [ebp+var_4]
.text:0000016C                 add     ecx, 18h
.text:0000016F                 call    ?Size@?$CObjectVector@UCArcExtInfo@@@@QBEIXZ ; CObjectVector<CArcExtInfo>::Size(void)
.text:00000174                 cmp     [ebp+var_8], eax
.text:00000177                 jnb     short loc_1A6
.text:00000179                 mov     ecx, [ebp+var_8]
.text:0000017C                 push    ecx
.text:0000017D                 mov     ecx, [ebp+var_4]
.text:00000180                 add     ecx, 18h
.text:00000183                 call    ??A?$CObjectVector@UCArcExtInfo@@@@QBEABUCArcExtInfo@@I@Z ; CObjectVector<CArcExtInfo>::operator[](uint)
.text:00000188                 mov     ecx, eax
.text:0000018A                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000018F                 push    eax             ; wchar_t *
.text:00000190                 mov     ecx, [ebp+arg_0] ; this
.text:00000193                 call    ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z ; UString::IsEqualTo_NoCase(wchar_t const *)
.text:00000198                 movzx   edx, al
.text:0000019B                 test    edx, edx
.text:0000019D                 jz      short loc_1A4
.text:0000019F                 mov     eax, [ebp+var_8]
.text:000001A2                 jmp     short loc_1A9
.text:000001A4 ; ---------------------------------------------------------------------------
.text:000001A4
.text:000001A4 loc_1A4:                                ; CODE XREF: CArcInfoEx::FindExtension(UString const &)+5Dj
.text:000001A4                 jmp     short loc_160
.text:000001A6 ; ---------------------------------------------------------------------------
.text:000001A6
.text:000001A6 loc_1A6:                                ; CODE XREF: CArcInfoEx::FindExtension(UString const &)+37j
.text:000001A6                 or      eax, 0FFFFFFFFh
.text:000001A9
.text:000001A9 loc_1A9:                                ; CODE XREF: CArcInfoEx::FindExtension(UString const &)+62j
.text:000001A9                 add     esp, 8
.text:000001AC                 cmp     ebp, esp
.text:000001AE                 call    __RTC_CheckEsp
.text:000001B3                 mov     esp, ebp
.text:000001B5                 pop     ebp
.text:000001B6                 retn    4
.text:000001B6 ?FindExtension@CArcInfoEx@@QBEHABVUString@@@Z endp
.text:000001B6
.text:000001B6 ; ---------------------------------------------------------------------------
.text:000001B9                 align 10h
.text:000001C0
.text:000001C0 ; =============== S U B R O U T I N E =======================================
.text:000001C0
.text:000001C0 ; Attributes: bp-based frame
.text:000001C0
.text:000001C0 ; void __thiscall CArcInfoEx::AddExts(CArcInfoEx *this, const struct UString *, const struct UString *)
.text:000001C0                 public ?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z
.text:000001C0 ?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z proc near
.text:000001C0                                         ; CODE XREF: CCodecs::Load(void)+102p
.text:000001C0
.text:000001C0 var_5C          = byte ptr -5Ch
.text:000001C0 var_58          = byte ptr -58h
.text:000001C0 var_4C          = dword ptr -4Ch
.text:000001C0 var_3C          = dword ptr -3Ch
.text:000001C0 var_34          = dword ptr -34h
.text:000001C0 var_20          = dword ptr -20h
.text:000001C0 var_10          = dword ptr -10h
.text:000001C0 var_C           = dword ptr -0Ch
.text:000001C0 var_4           = dword ptr -4
.text:000001C0 arg_0           = dword ptr  8
.text:000001C0 arg_4           = dword ptr  0Ch
.text:000001C0
.text:000001C0                 push    ebp
.text:000001C1                 mov     ebp, esp
.text:000001C3                 push    0FFFFFFFFh
.text:000001C5                 push    offset __ehhandler$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z
.text:000001CA                 mov     eax, large fs:0
.text:000001D0                 push    eax
.text:000001D1                 sub     esp, 50h
.text:000001D4                 push    edi
.text:000001D5                 push    ecx
.text:000001D6                 lea     edi, [ebp+var_5C]
.text:000001D9                 mov     ecx, 14h
.text:000001DE                 mov     eax, 0CCCCCCCCh
.text:000001E3                 rep stosd
.text:000001E5                 pop     ecx
.text:000001E6                 mov     eax, dword ptr ds:___security_cookie
.text:000001EB                 xor     eax, ebp
.text:000001ED                 push    eax
.text:000001EE                 lea     eax, [ebp+var_C]
.text:000001F1                 mov     large fs:0, eax
.text:000001F7                 mov     [ebp+var_10], ecx
.text:000001FA                 lea     ecx, [ebp+var_20]
.text:000001FD                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00000202                 mov     [ebp+var_4], 0
.text:00000209                 lea     ecx, [ebp+var_34]
.text:0000020C                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00000211                 mov     byte ptr [ebp+var_4], 1
.text:00000215                 lea     eax, [ebp+var_20]
.text:00000218                 push    eax             ; int
.text:00000219                 mov     ecx, [ebp+arg_0]
.text:0000021C                 push    ecx             ; UString *
.text:0000021D                 call    ?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z ; SplitString(UString const &,CObjectVector<UString> &)
.text:00000222                 lea     edx, [ebp+var_34]
.text:00000225                 push    edx             ; int
.text:00000226                 mov     eax, [ebp+arg_4]
.text:00000229                 push    eax             ; UString *
.text:0000022A                 call    ?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z ; SplitString(UString const &,CObjectVector<UString> &)
.text:0000022F                 mov     [ebp+var_3C], 0
.text:00000236                 jmp     short loc_241
.text:00000238 ; ---------------------------------------------------------------------------
.text:00000238
.text:00000238 loc_238:                                ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+10Dj
.text:00000238                 mov     ecx, [ebp+var_3C]
.text:0000023B                 add     ecx, 1
.text:0000023E                 mov     [ebp+var_3C], ecx
.text:00000241
.text:00000241 loc_241:                                ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+76j
.text:00000241                 lea     ecx, [ebp+var_20]
.text:00000244                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000249                 cmp     [ebp+var_3C], eax
.text:0000024C                 jnb     loc_2D2
.text:00000252                 lea     ecx, [ebp+var_58] ; this
.text:00000255                 call    ??0CArcExtInfo@@QAE@XZ ; CArcExtInfo::CArcExtInfo(void)
.text:0000025A                 mov     byte ptr [ebp+var_4], 2
.text:0000025E                 mov     edx, [ebp+var_3C]
.text:00000261                 push    edx
.text:00000262                 lea     ecx, [ebp+var_20]
.text:00000265                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000026A                 push    eax
.text:0000026B                 lea     ecx, [ebp+var_58]
.text:0000026E                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00000273                 lea     ecx, [ebp+var_34]
.text:00000276                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000027B                 cmp     [ebp+var_3C], eax
.text:0000027E                 jnb     short loc_2B2
.text:00000280                 mov     eax, [ebp+var_3C]
.text:00000283                 push    eax
.text:00000284                 lea     ecx, [ebp+var_34]
.text:00000287                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000028C                 push    eax
.text:0000028D                 lea     ecx, [ebp+var_4C]
.text:00000290                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00000295                 push    offset $SG69184 ; Str2
.text:0000029A                 lea     ecx, [ebp+var_4C]
.text:0000029D                 push    ecx             ; int
.text:0000029E                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:000002A3                 movzx   edx, al
.text:000002A6                 test    edx, edx
.text:000002A8                 jz      short loc_2B2
.text:000002AA                 lea     ecx, [ebp+var_4C] ; this
.text:000002AD                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:000002B2
.text:000002B2 loc_2B2:                                ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+BEj
.text:000002B2                                         ; CArcInfoEx::AddExts(UString const &,UString const &)+E8j
.text:000002B2                 lea     eax, [ebp+var_58]
.text:000002B5                 push    eax
.text:000002B6                 mov     ecx, [ebp+var_10]
.text:000002B9                 add     ecx, 18h
.text:000002BC                 call    ?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z ; CObjectVector<CArcExtInfo>::Add(CArcExtInfo const &)
.text:000002C1                 mov     byte ptr [ebp+var_4], 1
.text:000002C5                 lea     ecx, [ebp+var_58] ; this
.text:000002C8                 call    ??1CArcExtInfo@@QAE@XZ ; CArcExtInfo::~CArcExtInfo(void)
.text:000002CD                 jmp     loc_238
.text:000002D2 ; ---------------------------------------------------------------------------
.text:000002D2
.text:000002D2 loc_2D2:                                ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+8Cj
.text:000002D2                 mov     byte ptr [ebp+var_4], 0
.text:000002D6                 lea     ecx, [ebp+var_34]
.text:000002D9                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000002DE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000002E5                 lea     ecx, [ebp+var_20]
.text:000002E8                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000002ED                 push    edx
.text:000002EE                 mov     ecx, ebp
.text:000002F0                 push    eax
.text:000002F1                 lea     edx, $LN16
.text:000002F7                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000002FC                 pop     eax
.text:000002FD                 pop     edx
.text:000002FE                 mov     ecx, [ebp+var_C]
.text:00000301                 mov     large fs:0, ecx
.text:00000308                 pop     ecx
.text:00000309                 pop     edi
.text:0000030A                 add     esp, 5Ch
.text:0000030D                 cmp     ebp, esp
.text:0000030F                 call    __RTC_CheckEsp
.text:00000314                 mov     esp, ebp
.text:00000316                 pop     ebp
.text:00000317                 retn    8
.text:00000317 ?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z endp
.text:00000317
.text:00000317 ; ---------------------------------------------------------------------------
.text:0000031A                 align 4
.text:0000031C $LN16           dd 3                    ; DATA XREF: CArcInfoEx::AddExts(UString const &,UString const &)+131o
.text:00000320                 dd offset $LN15
.text:00000324 $LN15           dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:00000320o
.text:0000032C                 dd offset $LN11         ; "exts"
.text:00000330                 db 0CCh
.text:00000331                 db 3 dup(0FFh)
.text:00000334                 dd 0Ch
.text:00000338                 dd offset $LN12         ; "addExts"
.text:0000033C                 dd 0FFFFFFA8h, 18h
.text:00000344                 dd offset $LN13         ; "extInfo"
.text:00000348 $LN13           db 'extInfo',0          ; DATA XREF: .text:00000344o
.text:00000350 $LN12           db 'addExts',0          ; DATA XREF: .text:00000338o
.text:00000358 $LN11           db 'exts',0             ; DATA XREF: .text:0000032Co
.text:0000035D                 align 10h
.text:00000360
.text:00000360 ; =============== S U B R O U T I N E =======================================
.text:00000360
.text:00000360 ; Attributes: bp-based frame
.text:00000360
.text:00000360 ; int __stdcall SplitString(UString *, int)
.text:00000360 ?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z proc near
.text:00000360                                         ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+5Dp
.text:00000360                                         ; CArcInfoEx::AddExts(UString const &,UString const &)+6Ap
.text:00000360
.text:00000360 var_2C          = dword ptr -2Ch
.text:00000360 var_28          = dword ptr -28h
.text:00000360 var_24          = dword ptr -24h
.text:00000360 var_20          = dword ptr -20h
.text:00000360 var_1C          = dword ptr -1Ch
.text:00000360 var_18          = dword ptr -18h
.text:00000360 var_14          = dword ptr -14h
.text:00000360 var_10          = dword ptr -10h
.text:00000360 var_C           = dword ptr -0Ch
.text:00000360 var_4           = dword ptr -4
.text:00000360 arg_0           = dword ptr  8
.text:00000360 arg_4           = dword ptr  0Ch
.text:00000360
.text:00000360                 push    ebp
.text:00000361                 mov     ebp, esp
.text:00000363                 push    0FFFFFFFFh
.text:00000365                 push    offset __ehhandler$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z
.text:0000036A                 mov     eax, large fs:0
.text:00000370                 push    eax
.text:00000371                 sub     esp, 20h
.text:00000374                 mov     eax, 0CCCCCCCCh
.text:00000379                 mov     [ebp+var_2C], eax
.text:0000037C                 mov     [ebp+var_28], eax
.text:0000037F                 mov     [ebp+var_24], eax
.text:00000382                 mov     [ebp+var_20], eax
.text:00000385                 mov     [ebp+var_1C], eax
.text:00000388                 mov     [ebp+var_18], eax
.text:0000038B                 mov     [ebp+var_14], eax
.text:0000038E                 mov     [ebp+var_10], eax
.text:00000391                 mov     eax, dword ptr ds:___security_cookie
.text:00000396                 xor     eax, ebp
.text:00000398                 push    eax
.text:00000399                 lea     eax, [ebp+var_C]
.text:0000039C                 mov     large fs:0, eax
.text:000003A2                 mov     ecx, [ebp+arg_4]
.text:000003A5                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:000003AA                 lea     ecx, [ebp+var_1C]
.text:000003AD                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000003B2                 mov     [ebp+var_4], 0
.text:000003B9                 mov     ecx, [ebp+arg_0] ; this
.text:000003BC                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000003C1                 mov     [ebp+var_24], eax
.text:000003C4                 cmp     [ebp+var_24], 0
.text:000003C8                 jnz     short loc_3DE
.text:000003CA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000003D1                 lea     ecx, [ebp+var_1C] ; this
.text:000003D4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000003D9                 jmp     loc_472
.text:000003DE ; ---------------------------------------------------------------------------
.text:000003DE
.text:000003DE loc_3DE:                                ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+68j
.text:000003DE                 mov     [ebp+var_28], 0
.text:000003E5                 jmp     short loc_3F0
.text:000003E7 ; ---------------------------------------------------------------------------
.text:000003E7
.text:000003E7 loc_3E7:                                ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &):loc_446j
.text:000003E7                 mov     eax, [ebp+var_28]
.text:000003EA                 add     eax, 1
.text:000003ED                 mov     [ebp+var_28], eax
.text:000003F0
.text:000003F0 loc_3F0:                                ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+85j
.text:000003F0                 mov     ecx, [ebp+var_28]
.text:000003F3                 cmp     ecx, [ebp+var_24]
.text:000003F6                 jnb     short loc_448
.text:000003F8                 mov     ecx, [ebp+arg_0]
.text:000003FB                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000400                 mov     edx, [ebp+var_28]
.text:00000403                 mov     ax, [eax+edx*2]
.text:00000407                 mov     word ptr [ebp+var_2C], ax
.text:0000040B                 movzx   ecx, word ptr [ebp+var_2C]
.text:0000040F                 cmp     ecx, 20h ; ' '
.text:00000412                 jnz     short loc_439
.text:00000414                 lea     ecx, [ebp+var_1C] ; this
.text:00000417                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000041C                 movzx   edx, al
.text:0000041F                 test    edx, edx
.text:00000421                 jnz     short loc_437
.text:00000423                 lea     eax, [ebp+var_1C]
.text:00000426                 push    eax
.text:00000427                 mov     ecx, [ebp+arg_4]
.text:0000042A                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:0000042F                 lea     ecx, [ebp+var_1C] ; this
.text:00000432                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:00000437
.text:00000437 loc_437:                                ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+C1j
.text:00000437                 jmp     short loc_446
.text:00000439 ; ---------------------------------------------------------------------------
.text:00000439
.text:00000439 loc_439:                                ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+B2j
.text:00000439                 movzx   ecx, word ptr [ebp+var_2C]
.text:0000043D                 push    ecx
.text:0000043E                 lea     ecx, [ebp+var_1C]
.text:00000441                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:00000446
.text:00000446 loc_446:                                ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &):loc_437j
.text:00000446                 jmp     short loc_3E7
.text:00000448 ; ---------------------------------------------------------------------------
.text:00000448
.text:00000448 loc_448:                                ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+96j
.text:00000448                 lea     ecx, [ebp+var_1C] ; this
.text:0000044B                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00000450                 movzx   edx, al
.text:00000453                 test    edx, edx
.text:00000455                 jnz     short loc_463
.text:00000457                 lea     eax, [ebp+var_1C]
.text:0000045A                 push    eax
.text:0000045B                 mov     ecx, [ebp+arg_4]
.text:0000045E                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:00000463
.text:00000463 loc_463:                                ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+F5j
.text:00000463                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000046A                 lea     ecx, [ebp+var_1C] ; this
.text:0000046D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000472
.text:00000472 loc_472:                                ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+79j
.text:00000472                 push    edx
.text:00000473                 mov     ecx, ebp
.text:00000475                 push    eax
.text:00000476                 lea     edx, $LN15_0
.text:0000047C                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000481                 pop     eax
.text:00000482                 pop     edx
.text:00000483                 mov     ecx, [ebp+var_C]
.text:00000486                 mov     large fs:0, ecx
.text:0000048D                 pop     ecx
.text:0000048E                 add     esp, 2Ch
.text:00000491                 cmp     ebp, esp
.text:00000493                 call    __RTC_CheckEsp
.text:00000498                 mov     esp, ebp
.text:0000049A                 pop     ebp
.text:0000049B                 retn    8
.text:0000049B ?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z endp
.text:0000049B
.text:0000049B ; ---------------------------------------------------------------------------
.text:0000049E                 align 10h
.text:000004A0 $LN15_0         dd 1                    ; DATA XREF: SplitString(UString const &,CObjectVector<UString> &)+116o
.text:000004A4                 dd offset $LN14
.text:000004A8 $LN14           dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:000004A4o
.text:000004B0                 dd offset $LN12_0
.text:000004B4 $LN12_0         dd 0CCCC0073h, 2 dup(0CCCCCCCCh) ; DATA XREF: .text:000004B0o
.text:000004C0
.text:000004C0 ; =============== S U B R O U T I N E =======================================
.text:000004C0
.text:000004C0 ; Attributes: bp-based frame
.text:000004C0
.text:000004C0 ; __int32 __thiscall CCodecs::Load(CCodecs *__hidden this)
.text:000004C0                 public ?Load@CCodecs@@QAEJXZ
.text:000004C0 ?Load@CCodecs@@QAEJXZ proc near
.text:000004C0
.text:000004C0 var_84          = byte ptr -84h
.text:000004C0 var_80          = byte ptr -80h
.text:000004C0 var_6C          = byte ptr -6Ch
.text:000004C0 var_58          = dword ptr -58h
.text:000004C0 var_54          = dword ptr -54h
.text:000004C0 var_50          = dword ptr -50h
.text:000004C0 var_4C          = byte ptr -4Ch
.text:000004C0 var_34          = dword ptr -34h
.text:000004C0 var_30          = byte ptr -30h
.text:000004C0 var_2F          = byte ptr -2Fh
.text:000004C0 var_2C          = dword ptr -2Ch
.text:000004C0 var_28          = dword ptr -28h
.text:000004C0 var_18          = dword ptr -18h
.text:000004C0 var_14          = dword ptr -14h
.text:000004C0 var_10          = dword ptr -10h
.text:000004C0 var_C           = dword ptr -0Ch
.text:000004C0 var_4           = dword ptr -4
.text:000004C0
.text:000004C0                 push    ebp
.text:000004C1                 mov     ebp, esp
.text:000004C3                 push    0FFFFFFFFh
.text:000004C5                 push    offset __ehhandler$?Load@CCodecs@@QAEJXZ
.text:000004CA                 mov     eax, large fs:0
.text:000004D0                 push    eax
.text:000004D1                 sub     esp, 78h
.text:000004D4                 push    edi
.text:000004D5                 push    ecx
.text:000004D6                 lea     edi, [ebp+var_84]
.text:000004DC                 mov     ecx, 1Eh
.text:000004E1                 mov     eax, 0CCCCCCCCh
.text:000004E6                 rep stosd
.text:000004E8                 pop     ecx
.text:000004E9                 mov     eax, dword ptr ds:___security_cookie
.text:000004EE                 xor     eax, ebp
.text:000004F0                 push    eax
.text:000004F1                 lea     eax, [ebp+var_C]
.text:000004F4                 mov     large fs:0, eax
.text:000004FA                 mov     [ebp+var_10], ecx
.text:000004FD                 mov     ecx, [ebp+var_10]
.text:00000500                 add     ecx, 8
.text:00000503                 call    ?Clear@?$CObjectVector@UCArcInfoEx@@@@QAEXXZ ; CObjectVector<CArcInfoEx>::Clear(void)
.text:00000508                 mov     [ebp+var_14], 0
.text:0000050F                 jmp     short loc_51A
.text:00000511 ; ---------------------------------------------------------------------------
.text:00000511
.text:00000511 loc_511:                                ; CODE XREF: CCodecs::Load(void)+1AAj
.text:00000511                 mov     eax, [ebp+var_14]
.text:00000514                 add     eax, 1
.text:00000517                 mov     [ebp+var_14], eax
.text:0000051A
.text:0000051A loc_51A:                                ; CODE XREF: CCodecs::Load(void)+4Fj
.text:0000051A                 mov     ecx, [ebp+var_14]
.text:0000051D                 cmp     ecx, ds:_g_NumArcs
.text:00000523                 jnb     loc_66F
.text:00000529                 mov     edx, [ebp+var_14]
.text:0000052C                 mov     eax, ds:_g_Arcs[edx*4]
.text:00000533                 mov     [ebp+var_18], eax
.text:00000536                 lea     ecx, [ebp+var_58]
.text:00000539                 call    ??0CArcInfoEx@@QAE@XZ ; CArcInfoEx::CArcInfoEx(void)
.text:0000053E                 mov     [ebp+var_4], 0
.text:00000545                 mov     ecx, [ebp+var_18]
.text:00000548                 mov     edx, [ecx+0Ch]
.text:0000054B                 push    edx             ; char *
.text:0000054C                 lea     ecx, [ebp+var_4C] ; this
.text:0000054F                 call    ?SetFromAscii@UString@@QAEXPBD@Z ; UString::SetFromAscii(char const *)
.text:00000554                 mov     eax, [ebp+var_18]
.text:00000557                 mov     ecx, [eax+18h]
.text:0000055A                 mov     [ebp+var_54], ecx
.text:0000055D                 mov     edx, [ebp+var_18]
.text:00000560                 mov     eax, [edx+20h]
.text:00000563                 mov     [ebp+var_50], eax
.text:00000566                 mov     ecx, [ebp+var_18]
.text:00000569                 movzx   edx, word ptr [ecx]
.text:0000056C                 mov     [ebp+var_58], edx
.text:0000056F                 lea     ecx, [ebp+var_6C]
.text:00000572                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000577                 mov     byte ptr [ebp+var_4], 1
.text:0000057B                 lea     ecx, [ebp+var_80]
.text:0000057E                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000583                 mov     byte ptr [ebp+var_4], 2
.text:00000587                 mov     eax, [ebp+var_18]
.text:0000058A                 cmp     dword ptr [eax+10h], 0
.text:0000058E                 jz      short loc_59F
.text:00000590                 mov     ecx, [ebp+var_18]
.text:00000593                 mov     edx, [ecx+10h]
.text:00000596                 push    edx             ; char *
.text:00000597                 lea     ecx, [ebp+var_6C] ; this
.text:0000059A                 call    ?SetFromAscii@UString@@QAEXPBD@Z ; UString::SetFromAscii(char const *)
.text:0000059F
.text:0000059F loc_59F:                                ; CODE XREF: CCodecs::Load(void)+CEj
.text:0000059F                 mov     eax, [ebp+var_18]
.text:000005A2                 cmp     dword ptr [eax+14h], 0
.text:000005A6                 jz      short loc_5B7
.text:000005A8                 mov     ecx, [ebp+var_18]
.text:000005AB                 mov     edx, [ecx+14h]
.text:000005AE                 push    edx             ; char *
.text:000005AF                 lea     ecx, [ebp+var_80] ; this
.text:000005B2                 call    ?SetFromAscii@UString@@QAEXPBD@Z ; UString::SetFromAscii(char const *)
.text:000005B7
.text:000005B7 loc_5B7:                                ; CODE XREF: CCodecs::Load(void)+E6j
.text:000005B7                 lea     eax, [ebp+var_80]
.text:000005BA                 push    eax             ; struct UString *
.text:000005BB                 lea     ecx, [ebp+var_6C]
.text:000005BE                 push    ecx             ; struct UString *
.text:000005BF                 lea     ecx, [ebp+var_58] ; this
.text:000005C2                 call    ?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z ; CArcInfoEx::AddExts(UString const &,UString const &)
.text:000005C7                 mov     byte ptr [ebp+var_4], 1
.text:000005CB                 lea     ecx, [ebp+var_80] ; this
.text:000005CE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000005D3                 mov     byte ptr [ebp+var_4], 0
.text:000005D7                 lea     ecx, [ebp+var_6C] ; this
.text:000005DA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000005DF                 mov     edx, [ebp+var_18]
.text:000005E2                 mov     eax, [edx+1Ch]
.text:000005E5                 mov     [ebp+var_34], eax
.text:000005E8                 mov     ecx, [ebp+var_18]
.text:000005EB                 xor     edx, edx
.text:000005ED                 cmp     dword ptr [ecx+1Ch], 0
.text:000005F1                 setnz   dl
.text:000005F4                 mov     [ebp+var_30], dl
.text:000005F7                 mov     eax, [ebp+var_18]
.text:000005FA                 movzx   ecx, word ptr [eax+4]
.text:000005FE                 mov     [ebp+var_2C], ecx
.text:00000601                 mov     [ebp+var_2F], 1
.text:00000605                 mov     ecx, [ebp+var_18] ; this
.text:00000608                 call    ?IsMultiSignature@CArcInfo@@QBE_NXZ ; CArcInfo::IsMultiSignature(void)
.text:0000060D                 movzx   edx, al
.text:00000610                 test    edx, edx
.text:00000612                 jz      short loc_62E
.text:00000614                 lea     eax, [ebp+var_28]
.text:00000617                 push    eax             ; int
.text:00000618                 mov     ecx, [ebp+var_18]
.text:0000061B                 movzx   edx, byte ptr [ecx+3]
.text:0000061F                 push    edx             ; int
.text:00000620                 mov     eax, [ebp+var_18]
.text:00000623                 mov     ecx, [eax+8]
.text:00000626                 push    ecx             ; Src
.text:00000627                 call    ?ParseSignatures@@YG_NPBEIAAV?$CObjectVector@V?$CBuffer@E@@@@@Z ; ParseSignatures(uchar const *,uint,CObjectVector<CBuffer<uchar>> &)
.text:0000062C                 jmp     short loc_64C
.text:0000062E ; ---------------------------------------------------------------------------
.text:0000062E
.text:0000062E loc_62E:                                ; CODE XREF: CCodecs::Load(void)+152j
.text:0000062E                 mov     edx, [ebp+var_18]
.text:00000631                 movzx   eax, byte ptr [edx+3]
.text:00000635                 push    eax             ; Size
.text:00000636                 mov     ecx, [ebp+var_18]
.text:00000639                 mov     edx, [ecx+8]
.text:0000063C                 push    edx             ; Src
.text:0000063D                 lea     ecx, [ebp+var_28]
.text:00000640                 call    ?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ ; CObjectVector<CBuffer<uchar>>::AddNew(void)
.text:00000645                 mov     ecx, eax
.text:00000647                 call    ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z ; CBuffer<uchar>::CopyFrom(uchar const *,uint)
.text:0000064C
.text:0000064C loc_64C:                                ; CODE XREF: CCodecs::Load(void)+16Cj
.text:0000064C                 lea     eax, [ebp+var_58]
.text:0000064F                 push    eax
.text:00000650                 mov     ecx, [ebp+var_10]
.text:00000653                 add     ecx, 8
.text:00000656                 call    ?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z ; CObjectVector<CArcInfoEx>::Add(CArcInfoEx const &)
.text:0000065B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000662                 lea     ecx, [ebp+var_58] ; this
.text:00000665                 call    ??1CArcInfoEx@@QAE@XZ ; CArcInfoEx::~CArcInfoEx(void)
.text:0000066A                 jmp     loc_511
.text:0000066F ; ---------------------------------------------------------------------------
.text:0000066F
.text:0000066F loc_66F:                                ; CODE XREF: CCodecs::Load(void)+63j
.text:0000066F                 xor     eax, eax
.text:00000671                 push    edx
.text:00000672                 mov     ecx, ebp
.text:00000674                 push    eax
.text:00000675                 lea     edx, $LN18
.text:0000067B                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000680                 pop     eax
.text:00000681                 pop     edx
.text:00000682                 mov     ecx, [ebp+var_C]
.text:00000685                 mov     large fs:0, ecx
.text:0000068C                 pop     ecx
.text:0000068D                 pop     edi
.text:0000068E                 add     esp, 84h
.text:00000694                 cmp     ebp, esp
.text:00000696                 call    __RTC_CheckEsp
.text:0000069B                 mov     esp, ebp
.text:0000069D                 pop     ebp
.text:0000069E                 retn
.text:0000069E ?Load@CCodecs@@QAEJXZ endp
.text:0000069E
.text:0000069E ; ---------------------------------------------------------------------------
.text:0000069F                 align 10h
.text:000006A0 $LN18           dd 3                    ; DATA XREF: CCodecs::Load(void)+1B5o
.text:000006A4                 dd offset $LN17
.text:000006A8 $LN17           dd 0FFFFFFA8h, 3Ch      ; DATA XREF: .text:000006A4o
.text:000006B0                 dd offset $LN13_0       ; "item"
.text:000006B4                 dd 0FFFFFF94h, 0Ch
.text:000006BC                 dd offset $LN14_0
.text:000006C0                 dd 0FFFFFF80h, 0Ch
.text:000006C8                 dd offset $LN15_1
.text:000006CC $LN15_1         db 61h, 65h, 0          ; DATA XREF: .text:000006C8o
.text:000006CF $LN14_0         db 65h                  ; DATA XREF: .text:000006BCo
.text:000006D0                 db 0
.text:000006D1 $LN13_0         db 'item',0             ; DATA XREF: .text:000006B0o
.text:000006D6                 align 10h
.text:000006E0
.text:000006E0 ; =============== S U B R O U T I N E =======================================
.text:000006E0
.text:000006E0 ; Attributes: bp-based frame
.text:000006E0
.text:000006E0 ; int __stdcall ParseSignatures(void *Src, int, int)
.text:000006E0 ?ParseSignatures@@YG_NPBEIAAV?$CObjectVector@V?$CBuffer@E@@@@@Z proc near
.text:000006E0                                         ; CODE XREF: CCodecs::Load(void)+167p
.text:000006E0
.text:000006E0 Size            = dword ptr -4
.text:000006E0 Src             = dword ptr  8
.text:000006E0 arg_4           = dword ptr  0Ch
.text:000006E0 arg_8           = dword ptr  10h
.text:000006E0
.text:000006E0                 push    ebp
.text:000006E1                 mov     ebp, esp
.text:000006E3                 push    ecx
.text:000006E4                 mov     [ebp+Size], 0CCCCCCCCh
.text:000006EB                 mov     ecx, [ebp+arg_8]
.text:000006EE                 call    ?Clear@?$CObjectVector@V?$CBuffer@E@@@@QAEXXZ ; CObjectVector<CBuffer<uchar>>::Clear(void)
.text:000006F3
.text:000006F3 loc_6F3:                                ; CODE XREF: ParseSignatures(uchar const *,uint,CObjectVector<CBuffer<uchar>> &)+69j
.text:000006F3                 cmp     [ebp+arg_4], 0
.text:000006F7                 jbe     short loc_74B
.text:000006F9                 mov     eax, [ebp+Src]
.text:000006FC                 movzx   ecx, byte ptr [eax]
.text:000006FF                 mov     [ebp+Size], ecx
.text:00000702                 mov     edx, [ebp+Src]
.text:00000705                 add     edx, 1
.text:00000708                 mov     [ebp+Src], edx
.text:0000070B                 mov     eax, [ebp+arg_4]
.text:0000070E                 sub     eax, 1
.text:00000711                 mov     [ebp+arg_4], eax
.text:00000714                 mov     ecx, [ebp+Size]
.text:00000717                 cmp     ecx, [ebp+arg_4]
.text:0000071A                 jbe     short loc_720
.text:0000071C                 xor     al, al
.text:0000071E                 jmp     short loc_74D
.text:00000720 ; ---------------------------------------------------------------------------
.text:00000720
.text:00000720 loc_720:                                ; CODE XREF: ParseSignatures(uchar const *,uint,CObjectVector<CBuffer<uchar>> &)+3Aj
.text:00000720                 mov     edx, [ebp+Size]
.text:00000723                 push    edx             ; Size
.text:00000724                 mov     eax, [ebp+Src]
.text:00000727                 push    eax             ; Src
.text:00000728                 mov     ecx, [ebp+arg_8]
.text:0000072B                 call    ?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ ; CObjectVector<CBuffer<uchar>>::AddNew(void)
.text:00000730                 mov     ecx, eax
.text:00000732                 call    ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z ; CBuffer<uchar>::CopyFrom(uchar const *,uint)
.text:00000737                 mov     ecx, [ebp+Src]
.text:0000073A                 add     ecx, [ebp+Size]
.text:0000073D                 mov     [ebp+Src], ecx
.text:00000740                 mov     edx, [ebp+arg_4]
.text:00000743                 sub     edx, [ebp+Size]
.text:00000746                 mov     [ebp+arg_4], edx
.text:00000749                 jmp     short loc_6F3
.text:0000074B ; ---------------------------------------------------------------------------
.text:0000074B
.text:0000074B loc_74B:                                ; CODE XREF: ParseSignatures(uchar const *,uint,CObjectVector<CBuffer<uchar>> &)+17j
.text:0000074B                 mov     al, 1
.text:0000074D
.text:0000074D loc_74D:                                ; CODE XREF: ParseSignatures(uchar const *,uint,CObjectVector<CBuffer<uchar>> &)+3Ej
.text:0000074D                 add     esp, 4
.text:00000750                 cmp     ebp, esp
.text:00000752                 call    __RTC_CheckEsp
.text:00000757                 mov     esp, ebp
.text:00000759                 pop     ebp
.text:0000075A                 retn    0Ch
.text:0000075A ?ParseSignatures@@YG_NPBEIAAV?$CObjectVector@V?$CBuffer@E@@@@@Z endp
.text:0000075A
.text:0000075A ; ---------------------------------------------------------------------------
.text:0000075D                 align 10h
.text:00000760
.text:00000760 ; =============== S U B R O U T I N E =======================================
.text:00000760
.text:00000760 ; Attributes: bp-based frame
.text:00000760
.text:00000760 ; int __thiscall CCodecs::FindFormatForArchiveName(CCodecs *this, const struct UString *)
.text:00000760                 public ?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z
.text:00000760 ?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z proc near
.text:00000760
.text:00000760 var_40          = dword ptr -40h
.text:00000760 var_3C          = dword ptr -3Ch
.text:00000760 var_38          = dword ptr -38h
.text:00000760 var_34          = dword ptr -34h
.text:00000760 var_30          = dword ptr -30h
.text:00000760 var_2C          = dword ptr -2Ch
.text:00000760 var_24          = byte ptr -24h
.text:00000760 var_14          = dword ptr -14h
.text:00000760 var_10          = dword ptr -10h
.text:00000760 var_C           = dword ptr -0Ch
.text:00000760 var_4           = dword ptr -4
.text:00000760 arg_0           = dword ptr  8
.text:00000760
.text:00000760                 push    ebp
.text:00000761                 mov     ebp, esp
.text:00000763                 push    0FFFFFFFFh
.text:00000765                 push    offset __ehhandler$?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z
.text:0000076A                 mov     eax, large fs:0
.text:00000770                 push    eax
.text:00000771                 sub     esp, 34h
.text:00000774                 push    edi
.text:00000775                 push    ecx
.text:00000776                 lea     edi, [ebp+var_40]
.text:00000779                 mov     ecx, 0Dh
.text:0000077E                 mov     eax, 0CCCCCCCCh
.text:00000783                 rep stosd
.text:00000785                 pop     ecx
.text:00000786                 mov     eax, dword ptr ds:___security_cookie
.text:0000078B                 xor     eax, ebp
.text:0000078D                 push    eax
.text:0000078E                 lea     eax, [ebp+var_C]
.text:00000791                 mov     large fs:0, eax
.text:00000797                 mov     [ebp+var_10], ecx
.text:0000079A                 mov     ecx, [ebp+arg_0] ; this
.text:0000079D                 call    ?ReverseFind_Dot@UString@@QBEHXZ ; UString::ReverseFind_Dot(void)
.text:000007A2                 mov     [ebp+var_14], eax
.text:000007A5                 mov     ecx, [ebp+arg_0] ; this
.text:000007A8                 call    ?ReverseFind_PathSepar@UString@@QBEHXZ ; UString::ReverseFind_PathSepar(void)
.text:000007AD                 cmp     [ebp+var_14], eax
.text:000007B0                 jg      short loc_7BA
.text:000007B2                 or      eax, 0FFFFFFFFh
.text:000007B5                 jmp     loc_8AE
.text:000007BA ; ---------------------------------------------------------------------------
.text:000007BA
.text:000007BA loc_7BA:                                ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+50j
.text:000007BA                 mov     eax, [ebp+var_14]
.text:000007BD                 add     eax, 1
.text:000007C0                 push    eax             ; unsigned int
.text:000007C1                 mov     ecx, [ebp+arg_0] ; this
.text:000007C4                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:000007C9                 push    eax
.text:000007CA                 lea     ecx, [ebp+var_24]
.text:000007CD                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:000007D2                 mov     [ebp+var_4], 0
.text:000007D9                 lea     ecx, [ebp+var_24] ; this
.text:000007DC                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000007E1                 movzx   ecx, al
.text:000007E4                 test    ecx, ecx
.text:000007E6                 jz      short loc_806
.text:000007E8                 mov     [ebp+var_34], 0FFFFFFFFh
.text:000007EF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000007F6                 lea     ecx, [ebp+var_24] ; this
.text:000007F9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000007FE                 mov     eax, [ebp+var_34]
.text:00000801                 jmp     loc_8AE
.text:00000806 ; ---------------------------------------------------------------------------
.text:00000806
.text:00000806 loc_806:                                ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+86j
.text:00000806                 push    offset $SG69255 ; "exe"
.text:0000080B                 lea     ecx, [ebp+var_24] ; this
.text:0000080E                 call    ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z ; UString::IsEqualTo_Ascii_NoCase(char const *)
.text:00000813                 movzx   edx, al
.text:00000816                 test    edx, edx
.text:00000818                 jz      short loc_835
.text:0000081A                 mov     [ebp+var_38], 0FFFFFFFFh
.text:00000821                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000828                 lea     ecx, [ebp+var_24] ; this
.text:0000082B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000830                 mov     eax, [ebp+var_38]
.text:00000833                 jmp     short loc_8AE
.text:00000835 ; ---------------------------------------------------------------------------
.text:00000835
.text:00000835 loc_835:                                ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+B8j
.text:00000835                 mov     [ebp+var_2C], 0
.text:0000083C                 jmp     short loc_847
.text:0000083E ; ---------------------------------------------------------------------------
.text:0000083E
.text:0000083E loc_83E:                                ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &):loc_893j
.text:0000083E                 mov     eax, [ebp+var_2C]
.text:00000841                 add     eax, 1
.text:00000844                 mov     [ebp+var_2C], eax
.text:00000847
.text:00000847 loc_847:                                ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+DCj
.text:00000847                 mov     ecx, [ebp+var_10]
.text:0000084A                 add     ecx, 8
.text:0000084D                 call    ?Size@?$CObjectVector@UCArcInfoEx@@@@QBEIXZ ; CObjectVector<CArcInfoEx>::Size(void)
.text:00000852                 cmp     [ebp+var_2C], eax
.text:00000855                 jnb     short loc_895
.text:00000857                 mov     ecx, [ebp+var_2C]
.text:0000085A                 push    ecx
.text:0000085B                 mov     ecx, [ebp+var_10]
.text:0000085E                 add     ecx, 8
.text:00000861                 call    ??A?$CObjectVector@UCArcInfoEx@@@@QBEABUCArcInfoEx@@I@Z ; CObjectVector<CArcInfoEx>::operator[](uint)
.text:00000866                 mov     [ebp+var_30], eax
.text:00000869                 lea     edx, [ebp+var_24]
.text:0000086C                 push    edx             ; struct UString *
.text:0000086D                 mov     ecx, [ebp+var_30] ; this
.text:00000870                 call    ?FindExtension@CArcInfoEx@@QBEHABVUString@@@Z ; CArcInfoEx::FindExtension(UString const &)
.text:00000875                 test    eax, eax
.text:00000877                 jl      short loc_893
.text:00000879                 mov     eax, [ebp+var_2C]
.text:0000087C                 mov     [ebp+var_3C], eax
.text:0000087F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000886                 lea     ecx, [ebp+var_24] ; this
.text:00000889                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000088E                 mov     eax, [ebp+var_3C]
.text:00000891                 jmp     short loc_8AE
.text:00000893 ; ---------------------------------------------------------------------------
.text:00000893
.text:00000893 loc_893:                                ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+117j
.text:00000893                 jmp     short loc_83E
.text:00000895 ; ---------------------------------------------------------------------------
.text:00000895
.text:00000895 loc_895:                                ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+F5j
.text:00000895                 mov     [ebp+var_40], 0FFFFFFFFh
.text:0000089C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000008A3                 lea     ecx, [ebp+var_24] ; this
.text:000008A6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000008AB                 mov     eax, [ebp+var_40]
.text:000008AE
.text:000008AE loc_8AE:                                ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+55j
.text:000008AE                                         ; CCodecs::FindFormatForArchiveName(UString const &)+A1j ...
.text:000008AE                 push    edx
.text:000008AF                 mov     ecx, ebp
.text:000008B1                 push    eax
.text:000008B2                 lea     edx, $LN14_1
.text:000008B8                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000008BD                 pop     eax
.text:000008BE                 pop     edx
.text:000008BF                 mov     ecx, [ebp+var_C]
.text:000008C2                 mov     large fs:0, ecx
.text:000008C9                 pop     ecx
.text:000008CA                 pop     edi
.text:000008CB                 add     esp, 40h
.text:000008CE                 cmp     ebp, esp
.text:000008D0                 call    __RTC_CheckEsp
.text:000008D5                 mov     esp, ebp
.text:000008D7                 pop     ebp
.text:000008D8                 retn    4
.text:000008D8 ?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z endp
.text:000008D8
.text:000008D8 ; ---------------------------------------------------------------------------
.text:000008DB                 align 4
.text:000008DC $LN14_1         dd 1                    ; DATA XREF: CCodecs::FindFormatForArchiveName(UString const &)+152o
.text:000008E0                 dd offset $LN13_1
.text:000008E4 $LN13_1         dd 0FFFFFFDCh, 0Ch      ; DATA XREF: .text:000008E0o
.text:000008EC                 dd offset $LN11_0
.text:000008F0 $LN11_0         dd 747865h, 3 dup(0CCCCCCCCh) ; DATA XREF: .text:000008ECo
.text:00000900
.text:00000900 ; =============== S U B R O U T I N E =======================================
.text:00000900
.text:00000900 ; Attributes: bp-based frame
.text:00000900
.text:00000900 ; int __thiscall CCodecs::FindFormatForExtension(CCodecs *this, const struct UString *)
.text:00000900                 public ?FindFormatForExtension@CCodecs@@QBEHABVUString@@@Z
.text:00000900 ?FindFormatForExtension@CCodecs@@QBEHABVUString@@@Z proc near
.text:00000900
.text:00000900 var_8           = dword ptr -8
.text:00000900 var_4           = dword ptr -4
.text:00000900 arg_0           = dword ptr  8
.text:00000900
.text:00000900                 push    ebp
.text:00000901                 mov     ebp, esp
.text:00000903                 sub     esp, 8
.text:00000906                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000090D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000914                 mov     [ebp+var_4], ecx
.text:00000917                 mov     ecx, [ebp+arg_0] ; this
.text:0000091A                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000091F                 movzx   eax, al
.text:00000922                 test    eax, eax
.text:00000924                 jz      short loc_92B
.text:00000926                 or      eax, 0FFFFFFFFh
.text:00000929                 jmp     short loc_975
.text:0000092B ; ---------------------------------------------------------------------------
.text:0000092B
.text:0000092B loc_92B:                                ; CODE XREF: CCodecs::FindFormatForExtension(UString const &)+24j
.text:0000092B                 mov     [ebp+var_8], 0
.text:00000932                 jmp     short loc_93D
.text:00000934 ; ---------------------------------------------------------------------------
.text:00000934
.text:00000934 loc_934:                                ; CODE XREF: CCodecs::FindFormatForExtension(UString const &):loc_970j
.text:00000934                 mov     ecx, [ebp+var_8]
.text:00000937                 add     ecx, 1
.text:0000093A                 mov     [ebp+var_8], ecx
.text:0000093D
.text:0000093D loc_93D:                                ; CODE XREF: CCodecs::FindFormatForExtension(UString const &)+32j
.text:0000093D                 mov     ecx, [ebp+var_4]
.text:00000940                 add     ecx, 8
.text:00000943                 call    ?Size@?$CObjectVector@UCArcInfoEx@@@@QBEIXZ ; CObjectVector<CArcInfoEx>::Size(void)
.text:00000948                 cmp     [ebp+var_8], eax
.text:0000094B                 jnb     short loc_972
.text:0000094D                 mov     edx, [ebp+arg_0]
.text:00000950                 push    edx             ; struct UString *
.text:00000951                 mov     eax, [ebp+var_8]
.text:00000954                 push    eax
.text:00000955                 mov     ecx, [ebp+var_4]
.text:00000958                 add     ecx, 8
.text:0000095B                 call    ??A?$CObjectVector@UCArcInfoEx@@@@QBEABUCArcInfoEx@@I@Z ; CObjectVector<CArcInfoEx>::operator[](uint)
.text:00000960                 mov     ecx, eax        ; this
.text:00000962                 call    ?FindExtension@CArcInfoEx@@QBEHABVUString@@@Z ; CArcInfoEx::FindExtension(UString const &)
.text:00000967                 test    eax, eax
.text:00000969                 jl      short loc_970
.text:0000096B                 mov     eax, [ebp+var_8]
.text:0000096E                 jmp     short loc_975
.text:00000970 ; ---------------------------------------------------------------------------
.text:00000970
.text:00000970 loc_970:                                ; CODE XREF: CCodecs::FindFormatForExtension(UString const &)+69j
.text:00000970                 jmp     short loc_934
.text:00000972 ; ---------------------------------------------------------------------------
.text:00000972
.text:00000972 loc_972:                                ; CODE XREF: CCodecs::FindFormatForExtension(UString const &)+4Bj
.text:00000972                 or      eax, 0FFFFFFFFh
.text:00000975
.text:00000975 loc_975:                                ; CODE XREF: CCodecs::FindFormatForExtension(UString const &)+29j
.text:00000975                                         ; CCodecs::FindFormatForExtension(UString const &)+6Ej
.text:00000975                 add     esp, 8
.text:00000978                 cmp     ebp, esp
.text:0000097A                 call    __RTC_CheckEsp
.text:0000097F                 mov     esp, ebp
.text:00000981                 pop     ebp
.text:00000982                 retn    4
.text:00000982 ?FindFormatForExtension@CCodecs@@QBEHABVUString@@@Z endp
.text:00000982
.text:00000982 ; ---------------------------------------------------------------------------
.text:00000985                 align 10h
.text:00000990
.text:00000990 ; =============== S U B R O U T I N E =======================================
.text:00000990
.text:00000990 ; Attributes: bp-based frame
.text:00000990
.text:00000990 ; int __thiscall CCodecs::FindFormatForArchiveType(CCodecs *this, const struct UString *)
.text:00000990                 public ?FindFormatForArchiveType@CCodecs@@QBEHABVUString@@@Z
.text:00000990 ?FindFormatForArchiveType@CCodecs@@QBEHABVUString@@@Z proc near
.text:00000990                                         ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+C8p
.text:00000990
.text:00000990 var_8           = dword ptr -8
.text:00000990 var_4           = dword ptr -4
.text:00000990 arg_0           = dword ptr  8
.text:00000990
.text:00000990                 push    ebp
.text:00000991                 mov     ebp, esp
.text:00000993                 sub     esp, 8
.text:00000996                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000099D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000009A4                 mov     [ebp+var_4], ecx
.text:000009A7                 mov     [ebp+var_8], 0
.text:000009AE                 jmp     short loc_9B9
.text:000009B0 ; ---------------------------------------------------------------------------
.text:000009B0
.text:000009B0 loc_9B0:                                ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &):loc_9F7j
.text:000009B0                 mov     eax, [ebp+var_8]
.text:000009B3                 add     eax, 1
.text:000009B6                 mov     [ebp+var_8], eax
.text:000009B9
.text:000009B9 loc_9B9:                                ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &)+1Ej
.text:000009B9                 mov     ecx, [ebp+var_4]
.text:000009BC                 add     ecx, 8
.text:000009BF                 call    ?Size@?$CObjectVector@UCArcInfoEx@@@@QBEIXZ ; CObjectVector<CArcInfoEx>::Size(void)
.text:000009C4                 cmp     [ebp+var_8], eax
.text:000009C7                 jnb     short loc_9F9
.text:000009C9                 mov     ecx, [ebp+arg_0]
.text:000009CC                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000009D1                 push    eax             ; wchar_t *
.text:000009D2                 mov     ecx, [ebp+var_8]
.text:000009D5                 push    ecx
.text:000009D6                 mov     ecx, [ebp+var_4]
.text:000009D9                 add     ecx, 8
.text:000009DC                 call    ??A?$CObjectVector@UCArcInfoEx@@@@QBEABUCArcInfoEx@@I@Z ; CObjectVector<CArcInfoEx>::operator[](uint)
.text:000009E1                 add     eax, 0Ch
.text:000009E4                 mov     ecx, eax        ; this
.text:000009E6                 call    ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z ; UString::IsEqualTo_NoCase(wchar_t const *)
.text:000009EB                 movzx   edx, al
.text:000009EE                 test    edx, edx
.text:000009F0                 jz      short loc_9F7
.text:000009F2                 mov     eax, [ebp+var_8]
.text:000009F5                 jmp     short loc_9FC
.text:000009F7 ; ---------------------------------------------------------------------------
.text:000009F7
.text:000009F7 loc_9F7:                                ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &)+60j
.text:000009F7                 jmp     short loc_9B0
.text:000009F9 ; ---------------------------------------------------------------------------
.text:000009F9
.text:000009F9 loc_9F9:                                ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &)+37j
.text:000009F9                 or      eax, 0FFFFFFFFh
.text:000009FC
.text:000009FC loc_9FC:                                ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &)+65j
.text:000009FC                 add     esp, 8
.text:000009FF                 cmp     ebp, esp
.text:00000A01                 call    __RTC_CheckEsp
.text:00000A06                 mov     esp, ebp
.text:00000A08                 pop     ebp
.text:00000A09                 retn    4
.text:00000A09 ?FindFormatForArchiveType@CCodecs@@QBEHABVUString@@@Z endp
.text:00000A09
.text:00000A09 ; ---------------------------------------------------------------------------
.text:00000A0C                 align 10h
.text:00000A10
.text:00000A10 ; =============== S U B R O U T I N E =======================================
.text:00000A10
.text:00000A10 ; Attributes: bp-based frame
.text:00000A10
.text:00000A10 ; int __stdcall CCodecs::FindFormatForArchiveType(UString *, int)
.text:00000A10                 public ?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z
.text:00000A10 ?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z proc near
.text:00000A10
.text:00000A10 var_34          = byte ptr -34h
.text:00000A10 var_32          = byte ptr -32h
.text:00000A10 var_31          = byte ptr -31h
.text:00000A10 var_30          = dword ptr -30h
.text:00000A10 var_28          = dword ptr -28h
.text:00000A10 var_18          = dword ptr -18h
.text:00000A10 var_14          = dword ptr -14h
.text:00000A10 var_10          = dword ptr -10h
.text:00000A10 var_C           = dword ptr -0Ch
.text:00000A10 var_4           = dword ptr -4
.text:00000A10 arg_0           = dword ptr  8
.text:00000A10 arg_4           = dword ptr  0Ch
.text:00000A10
.text:00000A10                 push    ebp
.text:00000A11                 mov     ebp, esp
.text:00000A13                 push    0FFFFFFFFh
.text:00000A15                 push    offset __ehhandler$?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z
.text:00000A1A                 mov     eax, large fs:0
.text:00000A20                 push    eax
.text:00000A21                 sub     esp, 28h
.text:00000A24                 push    edi
.text:00000A25                 push    ecx
.text:00000A26                 lea     edi, [ebp+var_34]
.text:00000A29                 mov     ecx, 0Ah
.text:00000A2E                 mov     eax, 0CCCCCCCCh
.text:00000A33                 rep stosd
.text:00000A35                 pop     ecx
.text:00000A36                 mov     eax, dword ptr ds:___security_cookie
.text:00000A3B                 xor     eax, ebp
.text:00000A3D                 push    eax
.text:00000A3E                 lea     eax, [ebp+var_C]
.text:00000A41                 mov     large fs:0, eax
.text:00000A47                 mov     [ebp+var_10], ecx
.text:00000A4A                 mov     ecx, [ebp+arg_4]
.text:00000A4D                 call    ?Clear@?$CRecordVector@H@@QAEXXZ ; CRecordVector<int>::Clear(void)
.text:00000A52                 mov     [ebp+var_14], 0
.text:00000A59
.text:00000A59 loc_A59:                                ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+12Fj
.text:00000A59                 mov     ecx, [ebp+arg_0] ; this
.text:00000A5C                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00000A61                 cmp     [ebp+var_14], eax
.text:00000A64                 jnb     loc_B44
.text:00000A6A                 mov     eax, [ebp+var_14]
.text:00000A6D                 push    eax             ; unsigned int
.text:00000A6E                 push    2Eh ; '.'       ; wchar_t
.text:00000A70                 mov     ecx, [ebp+arg_0] ; this
.text:00000A73                 call    ?Find@UString@@QBEH_WI@Z ; UString::Find(wchar_t,uint)
.text:00000A78                 mov     [ebp+var_18], eax
.text:00000A7B                 cmp     [ebp+var_18], 0
.text:00000A7F                 jge     short loc_A8C
.text:00000A81                 mov     ecx, [ebp+arg_0] ; this
.text:00000A84                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00000A89                 mov     [ebp+var_18], eax
.text:00000A8C
.text:00000A8C loc_A8C:                                ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+6Fj
.text:00000A8C                 mov     ecx, [ebp+var_18]
.text:00000A8F                 sub     ecx, [ebp+var_14]
.text:00000A92                 push    ecx
.text:00000A93                 mov     edx, [ebp+var_14]
.text:00000A96                 push    edx
.text:00000A97                 lea     eax, [ebp+var_28]
.text:00000A9A                 push    eax
.text:00000A9B                 mov     ecx, [ebp+arg_0]
.text:00000A9E                 call    ?Mid@UString@@QBE?AV1@II@Z ; UString::Mid(uint,uint)
.text:00000AA3                 mov     [ebp+var_4], 0
.text:00000AAA                 lea     ecx, [ebp+var_28] ; this
.text:00000AAD                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00000AB2                 movzx   ecx, al
.text:00000AB5                 test    ecx, ecx
.text:00000AB7                 jz      short loc_AD1
.text:00000AB9                 mov     [ebp+var_31], 0
.text:00000ABD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000AC4                 lea     ecx, [ebp+var_28] ; this
.text:00000AC7                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000ACC                 mov     al, [ebp+var_31]
.text:00000ACF                 jmp     short loc_B46
.text:00000AD1 ; ---------------------------------------------------------------------------
.text:00000AD1
.text:00000AD1 loc_AD1:                                ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+A7j
.text:00000AD1                 lea     edx, [ebp+var_28]
.text:00000AD4                 push    edx             ; struct UString *
.text:00000AD5                 mov     ecx, [ebp+var_10] ; this
.text:00000AD8                 call    ?FindFormatForArchiveType@CCodecs@@QBEHABVUString@@@Z ; CCodecs::FindFormatForArchiveType(UString const &)
.text:00000ADD                 mov     [ebp+var_30], eax
.text:00000AE0                 cmp     [ebp+var_30], 0
.text:00000AE4                 jge     short loc_B1B
.text:00000AE6                 push    offset $SG69396 ; Str2
.text:00000AEB                 lea     eax, [ebp+var_28]
.text:00000AEE                 push    eax             ; int
.text:00000AEF                 call    ??9@YG_NABVUString@@PB_W@Z ; operator!=(UString const &,wchar_t const *)
.text:00000AF4                 movzx   ecx, al
.text:00000AF7                 test    ecx, ecx
.text:00000AF9                 jz      short loc_B1B
.text:00000AFB                 mov     ecx, [ebp+arg_4]
.text:00000AFE                 call    ?Clear@?$CRecordVector@H@@QAEXXZ ; CRecordVector<int>::Clear(void)
.text:00000B03                 mov     [ebp+var_32], 0
.text:00000B07                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000B0E                 lea     ecx, [ebp+var_28] ; this
.text:00000B11                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000B16                 mov     al, [ebp+var_32]
.text:00000B19                 jmp     short loc_B46
.text:00000B1B ; ---------------------------------------------------------------------------
.text:00000B1B
.text:00000B1B loc_B1B:                                ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+D4j
.text:00000B1B                                         ; CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+E9j
.text:00000B1B                 mov     edx, [ebp+var_30]
.text:00000B1E                 push    edx
.text:00000B1F                 mov     ecx, [ebp+arg_4]
.text:00000B22                 call    ?Add@?$CRecordVector@H@@QAEIH@Z ; CRecordVector<int>::Add(int)
.text:00000B27                 mov     eax, [ebp+var_18]
.text:00000B2A                 add     eax, 1
.text:00000B2D                 mov     [ebp+var_14], eax
.text:00000B30                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000B37                 lea     ecx, [ebp+var_28] ; this
.text:00000B3A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000B3F                 jmp     loc_A59
.text:00000B44 ; ---------------------------------------------------------------------------
.text:00000B44
.text:00000B44 loc_B44:                                ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+54j
.text:00000B44                 mov     al, 1
.text:00000B46
.text:00000B46 loc_B46:                                ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+BFj
.text:00000B46                                         ; CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+109j
.text:00000B46                 push    edx
.text:00000B47                 mov     ecx, ebp
.text:00000B49                 push    eax
.text:00000B4A                 lea     edx, $LN12_1
.text:00000B50                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000B55                 pop     eax
.text:00000B56                 pop     edx
.text:00000B57                 mov     ecx, [ebp+var_C]
.text:00000B5A                 mov     large fs:0, ecx
.text:00000B61                 pop     ecx
.text:00000B62                 pop     edi
.text:00000B63                 add     esp, 34h
.text:00000B66                 cmp     ebp, esp
.text:00000B68                 call    __RTC_CheckEsp
.text:00000B6D                 mov     esp, ebp
.text:00000B6F                 pop     ebp
.text:00000B70                 retn    8
.text:00000B70 ?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z endp
.text:00000B70
.text:00000B70 ; ---------------------------------------------------------------------------
.text:00000B73                 align 4
.text:00000B74 $LN12_1         dd 1                    ; DATA XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+13Ao
.text:00000B78                 dd offset $LN11_1
.text:00000B7C $LN11_1         dd 0FFFFFFD8h, 0Ch      ; DATA XREF: .text:00000B78o
.text:00000B84                 dd offset $LN9          ; "name"
.text:00000B88 $LN9            db 'name',0             ; DATA XREF: .text:00000B84o
.text:00000B8D                 align 10h
.text:00000B8D _text           ends
.text:00000B8D
.rtc$TMZ:00000B90 ; ===========================================================================
.rtc$TMZ:00000B90
.rtc$TMZ:00000B90 ; Segment type: Pure data
.rtc$TMZ:00000B90 ; Segment permissions: Read
.rtc$TMZ:00000B90 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000B90                 assume cs:_rtc$TMZ
.rtc$TMZ:00000B90                 ;org 0B90h
.rtc$TMZ:00000B90 ; COMDAT (pick any)
.rtc$TMZ:00000B90 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000B90 _rtc$TMZ        ends
.rtc$TMZ:00000B90
.rtc$IMZ:00000B94 ; ===========================================================================
.rtc$IMZ:00000B94
.rtc$IMZ:00000B94 ; Segment type: Pure data
.rtc$IMZ:00000B94 ; Segment permissions: Read
.rtc$IMZ:00000B94 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00000B94                 assume cs:_rtc$IMZ
.rtc$IMZ:00000B94                 ;org 0B94h
.rtc$IMZ:00000B94 ; COMDAT (pick any)
.rtc$IMZ:00000B94 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00000B94 _rtc$IMZ        ends
.rtc$IMZ:00000B94
.text:00000B98 ; ===========================================================================
.text:00000B98
.text:00000B98 ; Segment type: Pure code
.text:00000B98 ; Segment permissions: Read/Execute
.text:00000B98 _text           segment para public 'CODE' use32
.text:00000B98                 assume cs:_text
.text:00000B98                 ;org 0B98h
.text:00000B98 ; COMDAT (pick any)
.text:00000B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000B98
.text:00000B98 ; =============== S U B R O U T I N E =======================================
.text:00000B98
.text:00000B98 ; Attributes: bp-based frame
.text:00000B98
.text:00000B98 ; public: __thiscall UString::operator wchar_t const *(void)const
.text:00000B98                 public ??BUString@@QBEPB_WXZ
.text:00000B98 ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: CArcInfoEx::FindExtension(UString const &)+4Ap
.text:00000B98                                         ; SplitString(UString const &,CObjectVector<UString> &)+9Bp ...
.text:00000B98
.text:00000B98 var_4           = dword ptr -4
.text:00000B98
.text:00000B98                 push    ebp
.text:00000B99                 mov     ebp, esp
.text:00000B9B                 push    ecx
.text:00000B9C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000BA3                 mov     [ebp+var_4], ecx
.text:00000BA6                 mov     eax, [ebp+var_4]
.text:00000BA9                 mov     eax, [eax]
.text:00000BAB                 mov     esp, ebp
.text:00000BAD                 pop     ebp
.text:00000BAE                 retn
.text:00000BAE ??BUString@@QBEPB_WXZ endp
.text:00000BAE
.text:00000BAE ; ---------------------------------------------------------------------------
.text:00000BAF                 align 10h
.text:00000BAF _text           ends
.text:00000BAF
.text:00000BB0 ; ===========================================================================
.text:00000BB0
.text:00000BB0 ; Segment type: Pure code
.text:00000BB0 ; Segment permissions: Read/Execute
.text:00000BB0 _text           segment para public 'CODE' use32
.text:00000BB0                 assume cs:_text
.text:00000BB0                 ;org 0BB0h
.text:00000BB0 ; COMDAT (pick any)
.text:00000BB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000BB0
.text:00000BB0 ; =============== S U B R O U T I N E =======================================
.text:00000BB0
.text:00000BB0 ; Attributes: bp-based frame
.text:00000BB0
.text:00000BB0 ; bool __thiscall UString::IsEqualTo_NoCase(UString *this, const wchar_t *)
.text:00000BB0                 public ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z
.text:00000BB0 ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z proc near
.text:00000BB0                                         ; CODE XREF: CArcInfoEx::FindExtension(UString const &)+53p
.text:00000BB0                                         ; CCodecs::FindFormatForArchiveType(UString const &)+56p
.text:00000BB0
.text:00000BB0 var_4           = dword ptr -4
.text:00000BB0 arg_0           = dword ptr  8
.text:00000BB0
.text:00000BB0                 push    ebp
.text:00000BB1                 mov     ebp, esp
.text:00000BB3                 push    ecx
.text:00000BB4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000BBB                 mov     [ebp+var_4], ecx
.text:00000BBE                 mov     eax, [ebp+arg_0]
.text:00000BC1                 push    eax             ; wchar_t *
.text:00000BC2                 mov     ecx, [ebp+var_4]
.text:00000BC5                 mov     edx, [ecx]
.text:00000BC7                 push    edx             ; wchar_t *
.text:00000BC8                 call    ?StringsAreEqualNoCase@@YG_NPB_W0@Z ; StringsAreEqualNoCase(wchar_t const *,wchar_t const *)
.text:00000BCD                 add     esp, 4
.text:00000BD0                 cmp     ebp, esp
.text:00000BD2                 call    __RTC_CheckEsp
.text:00000BD7                 mov     esp, ebp
.text:00000BD9                 pop     ebp
.text:00000BDA                 retn    4
.text:00000BDA ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z endp
.text:00000BDA
.text:00000BDA ; ---------------------------------------------------------------------------
.text:00000BDD                 align 10h
.text:00000BDD _text           ends
.text:00000BDD
.text$x:00000BE0 ; ===========================================================================
.text$x:00000BE0
.text$x:00000BE0 ; Segment type: Pure code
.text$x:00000BE0 ; Segment permissions: Read/Execute
.text$x:00000BE0 _text$x         segment para public 'CODE' use32
.text$x:00000BE0                 assume cs:_text$x
.text$x:00000BE0                 ;org 0BE0h
.text$x:00000BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000BE0
.text$x:00000BE0 ; =============== S U B R O U T I N E =======================================
.text$x:00000BE0
.text$x:00000BE0
.text$x:00000BE0 __unwindfunclet$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z$0 proc near
.text$x:00000BE0                                         ; DATA XREF: .xdata$x:00000CB4o
.text$x:00000BE0                 lea     ecx, [ebp-20h]
.text$x:00000BE3                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00000BE3 __unwindfunclet$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z$0 endp
.text$x:00000BE3
.text$x:00000BE8
.text$x:00000BE8 ; =============== S U B R O U T I N E =======================================
.text$x:00000BE8
.text$x:00000BE8
.text$x:00000BE8 __unwindfunclet$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z$1 proc near
.text$x:00000BE8                                         ; DATA XREF: .xdata$x:00000CBCo
.text$x:00000BE8                 lea     ecx, [ebp-34h]
.text$x:00000BEB                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00000BEB __unwindfunclet$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z$1 endp
.text$x:00000BEB
.text$x:00000BF0
.text$x:00000BF0 ; =============== S U B R O U T I N E =======================================
.text$x:00000BF0
.text$x:00000BF0
.text$x:00000BF0 __unwindfunclet$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z$2 proc near
.text$x:00000BF0                                         ; DATA XREF: .xdata$x:00000CC4o
.text$x:00000BF0                 lea     ecx, [ebp-58h]  ; this
.text$x:00000BF3                 jmp     ??1CArcExtInfo@@QAE@XZ ; CArcExtInfo::~CArcExtInfo(void)
.text$x:00000BF3 __unwindfunclet$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z$2 endp
.text$x:00000BF3
.text$x:00000BF8
.text$x:00000BF8 ; =============== S U B R O U T I N E =======================================
.text$x:00000BF8
.text$x:00000BF8
.text$x:00000BF8 __ehhandler$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z proc near
.text$x:00000BF8                                         ; DATA XREF: CArcInfoEx::AddExts(UString const &,UString const &)+5o
.text$x:00000BF8
.text$x:00000BF8 arg_4           = dword ptr  8
.text$x:00000BF8
.text$x:00000BF8                 mov     edx, [esp+arg_4]
.text$x:00000BFC                 lea     eax, [edx+0Ch]
.text$x:00000BFF                 mov     ecx, [edx-58h]
.text$x:00000C02                 xor     ecx, eax
.text$x:00000C04                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C09                 mov     eax, offset __ehfuncinfo$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z
.text$x:00000C0E                 jmp     ___CxxFrameHandler3
.text$x:00000C0E __ehhandler$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z endp
.text$x:00000C0E
.text$x:00000C13
.text$x:00000C13 ; =============== S U B R O U T I N E =======================================
.text$x:00000C13
.text$x:00000C13
.text$x:00000C13 __unwindfunclet$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$0 proc near
.text$x:00000C13                                         ; DATA XREF: .xdata$x:00000CF0o
.text$x:00000C13                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00000C16                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000C16 __unwindfunclet$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$0 endp
.text$x:00000C16
.text$x:00000C1B
.text$x:00000C1B ; =============== S U B R O U T I N E =======================================
.text$x:00000C1B
.text$x:00000C1B
.text$x:00000C1B __ehhandler$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z proc near
.text$x:00000C1B                                         ; DATA XREF: SplitString(UString const &,CObjectVector<UString> &)+5o
.text$x:00000C1B
.text$x:00000C1B arg_4           = dword ptr  8
.text$x:00000C1B
.text$x:00000C1B                 mov     edx, [esp+arg_4]
.text$x:00000C1F                 lea     eax, [edx+0Ch]
.text$x:00000C22                 mov     ecx, [edx-24h]
.text$x:00000C25                 xor     ecx, eax
.text$x:00000C27                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C2C                 mov     eax, offset __ehfuncinfo$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z
.text$x:00000C31                 jmp     ___CxxFrameHandler3
.text$x:00000C31 __ehhandler$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z endp
.text$x:00000C31
.text$x:00000C36
.text$x:00000C36 ; =============== S U B R O U T I N E =======================================
.text$x:00000C36
.text$x:00000C36
.text$x:00000C36 __unwindfunclet$?Load@CCodecs@@QAEJXZ$0 proc near
.text$x:00000C36                                         ; DATA XREF: .xdata$x:00000D1Co
.text$x:00000C36                 lea     ecx, [ebp-58h]  ; this
.text$x:00000C39                 jmp     ??1CArcInfoEx@@QAE@XZ ; CArcInfoEx::~CArcInfoEx(void)
.text$x:00000C39 __unwindfunclet$?Load@CCodecs@@QAEJXZ$0 endp
.text$x:00000C39
.text$x:00000C3E
.text$x:00000C3E ; =============== S U B R O U T I N E =======================================
.text$x:00000C3E
.text$x:00000C3E
.text$x:00000C3E __unwindfunclet$?Load@CCodecs@@QAEJXZ$1 proc near
.text$x:00000C3E                                         ; DATA XREF: .xdata$x:00000D24o
.text$x:00000C3E                 lea     ecx, [ebp-6Ch]  ; this
.text$x:00000C41                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000C41 __unwindfunclet$?Load@CCodecs@@QAEJXZ$1 endp
.text$x:00000C41
.text$x:00000C46
.text$x:00000C46 ; =============== S U B R O U T I N E =======================================
.text$x:00000C46
.text$x:00000C46
.text$x:00000C46 __unwindfunclet$?Load@CCodecs@@QAEJXZ$2 proc near
.text$x:00000C46                                         ; DATA XREF: .xdata$x:00000D2Co
.text$x:00000C46                 lea     ecx, [ebp-80h]  ; this
.text$x:00000C49                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000C49 __unwindfunclet$?Load@CCodecs@@QAEJXZ$2 endp
.text$x:00000C49
.text$x:00000C4E
.text$x:00000C4E ; =============== S U B R O U T I N E =======================================
.text$x:00000C4E
.text$x:00000C4E
.text$x:00000C4E __ehhandler$?Load@CCodecs@@QAEJXZ proc near
.text$x:00000C4E                                         ; DATA XREF: CCodecs::Load(void)+5o
.text$x:00000C4E
.text$x:00000C4E arg_4           = dword ptr  8
.text$x:00000C4E
.text$x:00000C4E                 mov     edx, [esp+arg_4]
.text$x:00000C52                 lea     eax, [edx+0Ch]
.text$x:00000C55                 mov     ecx, [edx-80h]
.text$x:00000C58                 xor     ecx, eax
.text$x:00000C5A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C5F                 mov     eax, offset __ehfuncinfo$?Load@CCodecs@@QAEJXZ
.text$x:00000C64                 jmp     ___CxxFrameHandler3
.text$x:00000C64 __ehhandler$?Load@CCodecs@@QAEJXZ endp
.text$x:00000C64
.text$x:00000C69
.text$x:00000C69 ; =============== S U B R O U T I N E =======================================
.text$x:00000C69
.text$x:00000C69
.text$x:00000C69 __unwindfunclet$?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z$0 proc near
.text$x:00000C69                                         ; DATA XREF: .xdata$x:00000D58o
.text$x:00000C69                 lea     ecx, [ebp-24h]  ; this
.text$x:00000C6C                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000C6C __unwindfunclet$?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z$0 endp
.text$x:00000C6C
.text$x:00000C71
.text$x:00000C71 ; =============== S U B R O U T I N E =======================================
.text$x:00000C71
.text$x:00000C71
.text$x:00000C71 __ehhandler$?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z proc near
.text$x:00000C71                                         ; DATA XREF: CCodecs::FindFormatForArchiveName(UString const &)+5o
.text$x:00000C71
.text$x:00000C71 arg_4           = dword ptr  8
.text$x:00000C71
.text$x:00000C71                 mov     edx, [esp+arg_4]
.text$x:00000C75                 lea     eax, [edx+0Ch]
.text$x:00000C78                 mov     ecx, [edx-3Ch]
.text$x:00000C7B                 xor     ecx, eax
.text$x:00000C7D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C82                 mov     eax, offset __ehfuncinfo$?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z
.text$x:00000C87                 jmp     ___CxxFrameHandler3
.text$x:00000C87 __ehhandler$?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z endp
.text$x:00000C87
.text$x:00000C8C
.text$x:00000C8C ; =============== S U B R O U T I N E =======================================
.text$x:00000C8C
.text$x:00000C8C
.text$x:00000C8C __unwindfunclet$?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z$0 proc near
.text$x:00000C8C                                         ; DATA XREF: .xdata$x:00000D84o
.text$x:00000C8C                 lea     ecx, [ebp-28h]  ; this
.text$x:00000C8F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000C8F __unwindfunclet$?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z$0 endp
.text$x:00000C8F
.text$x:00000C94
.text$x:00000C94 ; =============== S U B R O U T I N E =======================================
.text$x:00000C94
.text$x:00000C94
.text$x:00000C94 __ehhandler$?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z proc near
.text$x:00000C94                                         ; DATA XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+5o
.text$x:00000C94
.text$x:00000C94 arg_4           = dword ptr  8
.text$x:00000C94
.text$x:00000C94                 mov     edx, [esp+arg_4]
.text$x:00000C98                 lea     eax, [edx+0Ch]
.text$x:00000C9B                 mov     ecx, [edx-30h]
.text$x:00000C9E                 xor     ecx, eax
.text$x:00000CA0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CA5                 mov     eax, offset __ehfuncinfo$?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z
.text$x:00000CAA                 jmp     ___CxxFrameHandler3
.text$x:00000CAA __ehhandler$?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z endp
.text$x:00000CAA
.text$x:00000CAA ; ---------------------------------------------------------------------------
.text$x:00000CAF                 align 10h
.text$x:00000CAF _text$x         ends
.text$x:00000CAF
.xdata$x:00000CB0 ; ===========================================================================
.xdata$x:00000CB0
.xdata$x:00000CB0 ; Segment type: Pure data
.xdata$x:00000CB0 ; Segment permissions: Read
.xdata$x:00000CB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000CB0                 assume cs:_xdata$x
.xdata$x:00000CB0                 ;org 0CB0h
.xdata$x:00000CB0 __unwindtable$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z db 0FFh
.xdata$x:00000CB0                                         ; DATA XREF: .xdata$x:00000CD0o
.xdata$x:00000CB1                 db 0FFh
.xdata$x:00000CB2                 db 0FFh
.xdata$x:00000CB3                 db 0FFh
.xdata$x:00000CB4                 dd offset __unwindfunclet$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z$0
.xdata$x:00000CB8                 db    0
.xdata$x:00000CB9                 db    0
.xdata$x:00000CBA                 db    0
.xdata$x:00000CBB                 db    0
.xdata$x:00000CBC                 dd offset __unwindfunclet$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z$1
.xdata$x:00000CC0                 db    1
.xdata$x:00000CC1                 db    0
.xdata$x:00000CC2                 db    0
.xdata$x:00000CC3                 db    0
.xdata$x:00000CC4                 dd offset __unwindfunclet$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z$2
.xdata$x:00000CC8 __ehfuncinfo$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z db  22h ; "
.xdata$x:00000CC8                                         ; DATA XREF: __ehhandler$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z+11o
.xdata$x:00000CC9                 db    5
.xdata$x:00000CCA                 db  93h ; ô
.xdata$x:00000CCB                 db  19h
.xdata$x:00000CCC                 db    3
.xdata$x:00000CCD                 db    0
.xdata$x:00000CCE                 db    0
.xdata$x:00000CCF                 db    0
.xdata$x:00000CD0                 dd offset __unwindtable$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z
.xdata$x:00000CD4                 db    0
.xdata$x:00000CD5                 db    0
.xdata$x:00000CD6                 db    0
.xdata$x:00000CD7                 db    0
.xdata$x:00000CD8                 db    0
.xdata$x:00000CD9                 db    0
.xdata$x:00000CDA                 db    0
.xdata$x:00000CDB                 db    0
.xdata$x:00000CDC                 db    0
.xdata$x:00000CDD                 db    0
.xdata$x:00000CDE                 db    0
.xdata$x:00000CDF                 db    0
.xdata$x:00000CE0                 db    0
.xdata$x:00000CE1                 db    0
.xdata$x:00000CE2                 db    0
.xdata$x:00000CE3                 db    0
.xdata$x:00000CE4                 db    0
.xdata$x:00000CE5                 db    0
.xdata$x:00000CE6                 db    0
.xdata$x:00000CE7                 db    0
.xdata$x:00000CE8                 db    1
.xdata$x:00000CE9                 db    0
.xdata$x:00000CEA                 db    0
.xdata$x:00000CEB                 db    0
.xdata$x:00000CEC __unwindtable$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z db 0FFh
.xdata$x:00000CEC                                         ; DATA XREF: .xdata$x:00000CFCo
.xdata$x:00000CED                 db 0FFh
.xdata$x:00000CEE                 db 0FFh
.xdata$x:00000CEF                 db 0FFh
.xdata$x:00000CF0                 dd offset __unwindfunclet$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$0
.xdata$x:00000CF4 __ehfuncinfo$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z db  22h ; "
.xdata$x:00000CF4                                         ; DATA XREF: __ehhandler$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z+11o
.xdata$x:00000CF5                 db    5
.xdata$x:00000CF6                 db  93h ; ô
.xdata$x:00000CF7                 db  19h
.xdata$x:00000CF8                 db    1
.xdata$x:00000CF9                 db    0
.xdata$x:00000CFA                 db    0
.xdata$x:00000CFB                 db    0
.xdata$x:00000CFC                 dd offset __unwindtable$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z
.xdata$x:00000D00                 db    0
.xdata$x:00000D01                 db    0
.xdata$x:00000D02                 db    0
.xdata$x:00000D03                 db    0
.xdata$x:00000D04                 db    0
.xdata$x:00000D05                 db    0
.xdata$x:00000D06                 db    0
.xdata$x:00000D07                 db    0
.xdata$x:00000D08                 db    0
.xdata$x:00000D09                 db    0
.xdata$x:00000D0A                 db    0
.xdata$x:00000D0B                 db    0
.xdata$x:00000D0C                 db    0
.xdata$x:00000D0D                 db    0
.xdata$x:00000D0E                 db    0
.xdata$x:00000D0F                 db    0
.xdata$x:00000D10                 db    0
.xdata$x:00000D11                 db    0
.xdata$x:00000D12                 db    0
.xdata$x:00000D13                 db    0
.xdata$x:00000D14                 db    1
.xdata$x:00000D15                 db    0
.xdata$x:00000D16                 db    0
.xdata$x:00000D17                 db    0
.xdata$x:00000D18 __unwindtable$?Load@CCodecs@@QAEJXZ db 0FFh
.xdata$x:00000D18                                         ; DATA XREF: .xdata$x:00000D38o
.xdata$x:00000D19                 db 0FFh
.xdata$x:00000D1A                 db 0FFh
.xdata$x:00000D1B                 db 0FFh
.xdata$x:00000D1C                 dd offset __unwindfunclet$?Load@CCodecs@@QAEJXZ$0
.xdata$x:00000D20                 db    0
.xdata$x:00000D21                 db    0
.xdata$x:00000D22                 db    0
.xdata$x:00000D23                 db    0
.xdata$x:00000D24                 dd offset __unwindfunclet$?Load@CCodecs@@QAEJXZ$1
.xdata$x:00000D28                 db    1
.xdata$x:00000D29                 db    0
.xdata$x:00000D2A                 db    0
.xdata$x:00000D2B                 db    0
.xdata$x:00000D2C                 dd offset __unwindfunclet$?Load@CCodecs@@QAEJXZ$2
.xdata$x:00000D30 __ehfuncinfo$?Load@CCodecs@@QAEJXZ db  22h ; "
.xdata$x:00000D30                                         ; DATA XREF: __ehhandler$?Load@CCodecs@@QAEJXZ+11o
.xdata$x:00000D31                 db    5
.xdata$x:00000D32                 db  93h ; ô
.xdata$x:00000D33                 db  19h
.xdata$x:00000D34                 db    3
.xdata$x:00000D35                 db    0
.xdata$x:00000D36                 db    0
.xdata$x:00000D37                 db    0
.xdata$x:00000D38                 dd offset __unwindtable$?Load@CCodecs@@QAEJXZ
.xdata$x:00000D3C                 db    0
.xdata$x:00000D3D                 db    0
.xdata$x:00000D3E                 db    0
.xdata$x:00000D3F                 db    0
.xdata$x:00000D40                 db    0
.xdata$x:00000D41                 db    0
.xdata$x:00000D42                 db    0
.xdata$x:00000D43                 db    0
.xdata$x:00000D44                 db    0
.xdata$x:00000D45                 db    0
.xdata$x:00000D46                 db    0
.xdata$x:00000D47                 db    0
.xdata$x:00000D48                 db    0
.xdata$x:00000D49                 db    0
.xdata$x:00000D4A                 db    0
.xdata$x:00000D4B                 db    0
.xdata$x:00000D4C                 db    0
.xdata$x:00000D4D                 db    0
.xdata$x:00000D4E                 db    0
.xdata$x:00000D4F                 db    0
.xdata$x:00000D50                 db    1
.xdata$x:00000D51                 db    0
.xdata$x:00000D52                 db    0
.xdata$x:00000D53                 db    0
.xdata$x:00000D54 __unwindtable$?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z db 0FFh
.xdata$x:00000D54                                         ; DATA XREF: .xdata$x:00000D64o
.xdata$x:00000D55                 db 0FFh
.xdata$x:00000D56                 db 0FFh
.xdata$x:00000D57                 db 0FFh
.xdata$x:00000D58                 dd offset __unwindfunclet$?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z$0
.xdata$x:00000D5C __ehfuncinfo$?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z db  22h ; "
.xdata$x:00000D5C                                         ; DATA XREF: __ehhandler$?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z+11o
.xdata$x:00000D5D                 db    5
.xdata$x:00000D5E                 db  93h ; ô
.xdata$x:00000D5F                 db  19h
.xdata$x:00000D60                 db    1
.xdata$x:00000D61                 db    0
.xdata$x:00000D62                 db    0
.xdata$x:00000D63                 db    0
.xdata$x:00000D64                 dd offset __unwindtable$?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z
.xdata$x:00000D68                 db    0
.xdata$x:00000D69                 db    0
.xdata$x:00000D6A                 db    0
.xdata$x:00000D6B                 db    0
.xdata$x:00000D6C                 db    0
.xdata$x:00000D6D                 db    0
.xdata$x:00000D6E                 db    0
.xdata$x:00000D6F                 db    0
.xdata$x:00000D70                 db    0
.xdata$x:00000D71                 db    0
.xdata$x:00000D72                 db    0
.xdata$x:00000D73                 db    0
.xdata$x:00000D74                 db    0
.xdata$x:00000D75                 db    0
.xdata$x:00000D76                 db    0
.xdata$x:00000D77                 db    0
.xdata$x:00000D78                 db    0
.xdata$x:00000D79                 db    0
.xdata$x:00000D7A                 db    0
.xdata$x:00000D7B                 db    0
.xdata$x:00000D7C                 db    1
.xdata$x:00000D7D                 db    0
.xdata$x:00000D7E                 db    0
.xdata$x:00000D7F                 db    0
.xdata$x:00000D80 __unwindtable$?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z db 0FFh
.xdata$x:00000D80                                         ; DATA XREF: .xdata$x:00000D90o
.xdata$x:00000D81                 db 0FFh
.xdata$x:00000D82                 db 0FFh
.xdata$x:00000D83                 db 0FFh
.xdata$x:00000D84                 dd offset __unwindfunclet$?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z$0
.xdata$x:00000D88 __ehfuncinfo$?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z db  22h ; "
.xdata$x:00000D88                                         ; DATA XREF: __ehhandler$?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z+11o
.xdata$x:00000D89                 db    5
.xdata$x:00000D8A                 db  93h ; ô
.xdata$x:00000D8B                 db  19h
.xdata$x:00000D8C                 db    1
.xdata$x:00000D8D                 db    0
.xdata$x:00000D8E                 db    0
.xdata$x:00000D8F                 db    0
.xdata$x:00000D90                 dd offset __unwindtable$?FindFormatForArchiveType@CCodecs@@QBE_NABVUString@@AAV?$CRecordVector@H@@@Z
.xdata$x:00000D94                 db    0
.xdata$x:00000D95                 db    0
.xdata$x:00000D96                 db    0
.xdata$x:00000D97                 db    0
.xdata$x:00000D98                 db    0
.xdata$x:00000D99                 db    0
.xdata$x:00000D9A                 db    0
.xdata$x:00000D9B                 db    0
.xdata$x:00000D9C                 db    0
.xdata$x:00000D9D                 db    0
.xdata$x:00000D9E                 db    0
.xdata$x:00000D9F                 db    0
.xdata$x:00000DA0                 db    0
.xdata$x:00000DA1                 db    0
.xdata$x:00000DA2                 db    0
.xdata$x:00000DA3                 db    0
.xdata$x:00000DA4                 db    0
.xdata$x:00000DA5                 db    0
.xdata$x:00000DA6                 db    0
.xdata$x:00000DA7                 db    0
.xdata$x:00000DA8                 db    1
.xdata$x:00000DA9                 db    0
.xdata$x:00000DAA                 db    0
.xdata$x:00000DAB                 db    0
.xdata$x:00000DAB _xdata$x        ends
.xdata$x:00000DAB
.text:00000DAC ; ===========================================================================
.text:00000DAC
.text:00000DAC ; Segment type: Pure code
.text:00000DAC ; Segment permissions: Read/Execute
.text:00000DAC _text           segment para public 'CODE' use32
.text:00000DAC                 assume cs:_text
.text:00000DAC                 ;org 0DACh
.text:00000DAC ; COMDAT (pick any)
.text:00000DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000DAC
.text:00000DAC ; =============== S U B R O U T I N E =======================================
.text:00000DAC
.text:00000DAC ; Attributes: bp-based frame
.text:00000DAC
.text:00000DAC ; void __thiscall UString::Empty(UString *__hidden this)
.text:00000DAC                 public ?Empty@UString@@QAEXXZ
.text:00000DAC ?Empty@UString@@QAEXXZ proc near        ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+EDp
.text:00000DAC                                         ; SplitString(UString const &,CObjectVector<UString> &)+D2p
.text:00000DAC
.text:00000DAC var_4           = dword ptr -4
.text:00000DAC
.text:00000DAC                 push    ebp
.text:00000DAD                 mov     ebp, esp
.text:00000DAF                 push    ecx
.text:00000DB0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000DB7                 mov     [ebp+var_4], ecx
.text:00000DBA                 mov     eax, [ebp+var_4]
.text:00000DBD                 mov     dword ptr [eax+4], 0
.text:00000DC4                 mov     ecx, [ebp+var_4]
.text:00000DC7                 mov     edx, [ecx]
.text:00000DC9                 xor     eax, eax
.text:00000DCB                 mov     [edx], ax
.text:00000DCE                 mov     esp, ebp
.text:00000DD0                 pop     ebp
.text:00000DD1                 retn
.text:00000DD1 ?Empty@UString@@QAEXXZ endp
.text:00000DD1
.text:00000DD1 ; ---------------------------------------------------------------------------
.text:00000DD2                 align 4
.text:00000DD2 _text           ends
.text:00000DD2
.text:00000DD4 ; ===========================================================================
.text:00000DD4
.text:00000DD4 ; Segment type: Pure code
.text:00000DD4 ; Segment permissions: Read/Execute
.text:00000DD4 _text           segment para public 'CODE' use32
.text:00000DD4                 assume cs:_text
.text:00000DD4                 ;org 0DD4h
.text:00000DD4 ; COMDAT (pick any)
.text:00000DD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000DD4
.text:00000DD4 ; =============== S U B R O U T I N E =======================================
.text:00000DD4
.text:00000DD4 ; Attributes: bp-based frame
.text:00000DD4
.text:00000DD4 ; int __stdcall operator==(int, wchar_t *Str2)
.text:00000DD4                 public ??8@YG_NABVUString@@PB_W@Z
.text:00000DD4 ??8@YG_NABVUString@@PB_W@Z proc near    ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+DEp
.text:00000DD4
.text:00000DD4 arg_0           = dword ptr  8
.text:00000DD4 Str2            = dword ptr  0Ch
.text:00000DD4
.text:00000DD4                 push    ebp
.text:00000DD5                 mov     ebp, esp
.text:00000DD7                 push    esi
.text:00000DD8                 mov     esi, esp
.text:00000DDA                 mov     eax, [ebp+Str2]
.text:00000DDD                 push    eax             ; Str2
.text:00000DDE                 mov     ecx, [ebp+arg_0]
.text:00000DE1                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000DE6                 push    eax             ; Str1
.text:00000DE7                 call    dword ptr ds:__imp__wcscmp
.text:00000DED                 add     esp, 8
.text:00000DF0                 cmp     esi, esp
.text:00000DF2                 call    __RTC_CheckEsp
.text:00000DF7                 neg     eax
.text:00000DF9                 sbb     eax, eax
.text:00000DFB                 add     eax, 1
.text:00000DFE                 pop     esi
.text:00000DFF                 cmp     ebp, esp
.text:00000E01                 call    __RTC_CheckEsp
.text:00000E06                 pop     ebp
.text:00000E07                 retn    8
.text:00000E07 ??8@YG_NABVUString@@PB_W@Z endp
.text:00000E07
.text:00000E07 ; ---------------------------------------------------------------------------
.text:00000E0A                 align 4
.text:00000E0A _text           ends
.text:00000E0A
.text:00000E0C ; ===========================================================================
.text:00000E0C
.text:00000E0C ; Segment type: Pure code
.text:00000E0C ; Segment permissions: Read/Execute
.text:00000E0C _text           segment para public 'CODE' use32
.text:00000E0C                 assume cs:_text
.text:00000E0C                 ;org 0E0Ch
.text:00000E0C ; COMDAT (pick any)
.text:00000E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000E0C
.text:00000E0C ; =============== S U B R O U T I N E =======================================
.text:00000E0C
.text:00000E0C ; Attributes: bp-based frame
.text:00000E0C
.text:00000E0C ; _DWORD __thiscall CArcExtInfo::CArcExtInfo(CArcExtInfo *__hidden this)
.text:00000E0C                 public ??0CArcExtInfo@@QAE@XZ
.text:00000E0C ??0CArcExtInfo@@QAE@XZ proc near        ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+95p
.text:00000E0C
.text:00000E0C var_10          = dword ptr -10h
.text:00000E0C var_C           = dword ptr -0Ch
.text:00000E0C var_4           = dword ptr -4
.text:00000E0C
.text:00000E0C                 push    ebp
.text:00000E0D                 mov     ebp, esp
.text:00000E0F                 push    0FFFFFFFFh
.text:00000E11                 push    offset __ehhandler$??0CArcExtInfo@@QAE@XZ
.text:00000E16                 mov     eax, large fs:0
.text:00000E1C                 push    eax
.text:00000E1D                 push    ecx
.text:00000E1E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00000E25                 mov     eax, dword ptr ds:___security_cookie
.text:00000E2A                 xor     eax, ebp
.text:00000E2C                 push    eax
.text:00000E2D                 lea     eax, [ebp+var_C]
.text:00000E30                 mov     large fs:0, eax
.text:00000E36                 mov     [ebp+var_10], ecx
.text:00000E39                 mov     ecx, [ebp+var_10]
.text:00000E3C                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000E41                 mov     [ebp+var_4], 0
.text:00000E48                 mov     ecx, [ebp+var_10]
.text:00000E4B                 add     ecx, 0Ch
.text:00000E4E                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000E53                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000E5A                 mov     eax, [ebp+var_10]
.text:00000E5D                 mov     ecx, [ebp+var_C]
.text:00000E60                 mov     large fs:0, ecx
.text:00000E67                 pop     ecx
.text:00000E68                 add     esp, 10h
.text:00000E6B                 cmp     ebp, esp
.text:00000E6D                 call    __RTC_CheckEsp
.text:00000E72                 mov     esp, ebp
.text:00000E74                 pop     ebp
.text:00000E75                 retn
.text:00000E75 ??0CArcExtInfo@@QAE@XZ endp
.text:00000E75
.text:00000E75 ; ---------------------------------------------------------------------------
.text:00000E76                 align 4
.text:00000E76 _text           ends
.text:00000E76
.text$x:00000E78 ; ===========================================================================
.text$x:00000E78
.text$x:00000E78 ; Segment type: Pure code
.text$x:00000E78 ; Segment permissions: Read/Execute
.text$x:00000E78 _text$x         segment para public 'CODE' use32
.text$x:00000E78                 assume cs:_text$x
.text$x:00000E78                 ;org 0E78h
.text$x:00000E78 ; COMDAT (pick associative to section at E0C)
.text$x:00000E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E78
.text$x:00000E78 ; =============== S U B R O U T I N E =======================================
.text$x:00000E78
.text$x:00000E78
.text$x:00000E78 __unwindfunclet$??0CArcExtInfo@@QAE@XZ$0 proc near
.text$x:00000E78                                         ; DATA XREF: .xdata$x:00000EA0o
.text$x:00000E78                 mov     ecx, [ebp-10h]  ; this
.text$x:00000E7B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000E7B __unwindfunclet$??0CArcExtInfo@@QAE@XZ$0 endp
.text$x:00000E7B
.text$x:00000E80
.text$x:00000E80 ; =============== S U B R O U T I N E =======================================
.text$x:00000E80
.text$x:00000E80
.text$x:00000E80 __ehhandler$??0CArcExtInfo@@QAE@XZ proc near
.text$x:00000E80                                         ; DATA XREF: CArcExtInfo::CArcExtInfo(void)+5o
.text$x:00000E80
.text$x:00000E80 arg_4           = dword ptr  8
.text$x:00000E80
.text$x:00000E80                 mov     edx, [esp+arg_4]
.text$x:00000E84                 lea     eax, [edx+0Ch]
.text$x:00000E87                 mov     ecx, [edx-8]
.text$x:00000E8A                 xor     ecx, eax
.text$x:00000E8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E91                 mov     eax, offset __ehfuncinfo$??0CArcExtInfo@@QAE@XZ
.text$x:00000E96                 jmp     ___CxxFrameHandler3
.text$x:00000E96 __ehhandler$??0CArcExtInfo@@QAE@XZ endp
.text$x:00000E96
.text$x:00000E96 ; ---------------------------------------------------------------------------
.text$x:00000E9B                 align 4
.text$x:00000E9B _text$x         ends
.text$x:00000E9B
.xdata$x:00000E9C ; ===========================================================================
.xdata$x:00000E9C
.xdata$x:00000E9C ; Segment type: Pure data
.xdata$x:00000E9C ; Segment permissions: Read
.xdata$x:00000E9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000E9C                 assume cs:_xdata$x
.xdata$x:00000E9C                 ;org 0E9Ch
.xdata$x:00000E9C ; COMDAT (pick associative to section at E0C)
.xdata$x:00000E9C __unwindtable$??0CArcExtInfo@@QAE@XZ db 0FFh
.xdata$x:00000E9C                                         ; DATA XREF: .xdata$x:00000EACo
.xdata$x:00000E9D                 db 0FFh
.xdata$x:00000E9E                 db 0FFh
.xdata$x:00000E9F                 db 0FFh
.xdata$x:00000EA0                 dd offset __unwindfunclet$??0CArcExtInfo@@QAE@XZ$0
.xdata$x:00000EA4 __ehfuncinfo$??0CArcExtInfo@@QAE@XZ db  22h ; "
.xdata$x:00000EA4                                         ; DATA XREF: __ehhandler$??0CArcExtInfo@@QAE@XZ+11o
.xdata$x:00000EA5                 db    5
.xdata$x:00000EA6                 db  93h ; ô
.xdata$x:00000EA7                 db  19h
.xdata$x:00000EA8                 db    1
.xdata$x:00000EA9                 db    0
.xdata$x:00000EAA                 db    0
.xdata$x:00000EAB                 db    0
.xdata$x:00000EAC                 dd offset __unwindtable$??0CArcExtInfo@@QAE@XZ
.xdata$x:00000EB0                 db    0
.xdata$x:00000EB1                 db    0
.xdata$x:00000EB2                 db    0
.xdata$x:00000EB3                 db    0
.xdata$x:00000EB4                 db    0
.xdata$x:00000EB5                 db    0
.xdata$x:00000EB6                 db    0
.xdata$x:00000EB7                 db    0
.xdata$x:00000EB8                 db    0
.xdata$x:00000EB9                 db    0
.xdata$x:00000EBA                 db    0
.xdata$x:00000EBB                 db    0
.xdata$x:00000EBC                 db    0
.xdata$x:00000EBD                 db    0
.xdata$x:00000EBE                 db    0
.xdata$x:00000EBF                 db    0
.xdata$x:00000EC0                 db    0
.xdata$x:00000EC1                 db    0
.xdata$x:00000EC2                 db    0
.xdata$x:00000EC3                 db    0
.xdata$x:00000EC4                 db    1
.xdata$x:00000EC5                 db    0
.xdata$x:00000EC6                 db    0
.xdata$x:00000EC7                 db    0
.xdata$x:00000EC7 _xdata$x        ends
.xdata$x:00000EC7
.text:00000EC8 ; ===========================================================================
.text:00000EC8
.text:00000EC8 ; Segment type: Pure code
.text:00000EC8 ; Segment permissions: Read/Execute
.text:00000EC8 _text           segment para public 'CODE' use32
.text:00000EC8                 assume cs:_text
.text:00000EC8                 ;org 0EC8h
.text:00000EC8 ; COMDAT (pick any)
.text:00000EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000EC8
.text:00000EC8 ; =============== S U B R O U T I N E =======================================
.text:00000EC8
.text:00000EC8 ; Attributes: bp-based frame
.text:00000EC8
.text:00000EC8 ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:00000EC8                 public ??1UString@@QAE@XZ
.text:00000EC8 ??1UString@@QAE@XZ proc near            ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+74p
.text:00000EC8                                         ; SplitString(UString const &,CObjectVector<UString> &)+10Dp ...
.text:00000EC8
.text:00000EC8 var_8           = dword ptr -8
.text:00000EC8 var_4           = dword ptr -4
.text:00000EC8
.text:00000EC8                 push    ebp
.text:00000EC9                 mov     ebp, esp
.text:00000ECB                 sub     esp, 8
.text:00000ECE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000ED5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000EDC                 mov     [ebp+var_4], ecx
.text:00000EDF                 mov     eax, [ebp+var_4]
.text:00000EE2                 mov     ecx, [eax]
.text:00000EE4                 mov     [ebp+var_8], ecx
.text:00000EE7                 mov     edx, [ebp+var_8]
.text:00000EEA                 push    edx             ; void *
.text:00000EEB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000EF0                 add     esp, 4
.text:00000EF3                 add     esp, 8
.text:00000EF6                 cmp     ebp, esp
.text:00000EF8                 call    __RTC_CheckEsp
.text:00000EFD                 mov     esp, ebp
.text:00000EFF                 pop     ebp
.text:00000F00                 retn
.text:00000F00 ??1UString@@QAE@XZ endp
.text:00000F00
.text:00000F00 ; ---------------------------------------------------------------------------
.text:00000F01                 align 4
.text:00000F01 _text           ends
.text:00000F01
.text:00000F04 ; ===========================================================================
.text:00000F04
.text:00000F04 ; Segment type: Pure code
.text:00000F04 ; Segment permissions: Read/Execute
.text:00000F04 _text           segment para public 'CODE' use32
.text:00000F04                 assume cs:_text
.text:00000F04                 ;org 0F04h
.text:00000F04 ; COMDAT (pick any)
.text:00000F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000F04
.text:00000F04 ; =============== S U B R O U T I N E =======================================
.text:00000F04
.text:00000F04 ; Attributes: bp-based frame
.text:00000F04
.text:00000F04 ; unsigned int __thiscall UString::Len(UString *__hidden this)
.text:00000F04                 public ?Len@UString@@QBEIXZ
.text:00000F04 ?Len@UString@@QBEIXZ proc near          ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+5Cp
.text:00000F04                                         ; CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+4Cp ...
.text:00000F04
.text:00000F04 var_4           = dword ptr -4
.text:00000F04
.text:00000F04                 push    ebp
.text:00000F05                 mov     ebp, esp
.text:00000F07                 push    ecx
.text:00000F08                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F0F                 mov     [ebp+var_4], ecx
.text:00000F12                 mov     eax, [ebp+var_4]
.text:00000F15                 mov     eax, [eax+4]
.text:00000F18                 mov     esp, ebp
.text:00000F1A                 pop     ebp
.text:00000F1B                 retn
.text:00000F1B ?Len@UString@@QBEIXZ endp
.text:00000F1B
.text:00000F1B _text           ends
.text:00000F1B
.text:00000F1C ; ===========================================================================
.text:00000F1C
.text:00000F1C ; Segment type: Pure code
.text:00000F1C ; Segment permissions: Read/Execute
.text:00000F1C _text           segment para public 'CODE' use32
.text:00000F1C                 assume cs:_text
.text:00000F1C                 ;org 0F1Ch
.text:00000F1C ; COMDAT (pick any)
.text:00000F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000F1C
.text:00000F1C ; =============== S U B R O U T I N E =======================================
.text:00000F1C
.text:00000F1C ; Attributes: bp-based frame
.text:00000F1C
.text:00000F1C ; bool __thiscall UString::IsEmpty(UString *__hidden this)
.text:00000F1C                 public ?IsEmpty@UString@@QBE_NXZ
.text:00000F1C ?IsEmpty@UString@@QBE_NXZ proc near     ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+B7p
.text:00000F1C                                         ; SplitString(UString const &,CObjectVector<UString> &)+EBp ...
.text:00000F1C
.text:00000F1C var_4           = dword ptr -4
.text:00000F1C
.text:00000F1C                 push    ebp
.text:00000F1D                 mov     ebp, esp
.text:00000F1F                 push    ecx
.text:00000F20                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F27                 mov     [ebp+var_4], ecx
.text:00000F2A                 mov     eax, [ebp+var_4]
.text:00000F2D                 xor     ecx, ecx
.text:00000F2F                 cmp     dword ptr [eax+4], 0
.text:00000F33                 setz    cl
.text:00000F36                 mov     al, cl
.text:00000F38                 mov     esp, ebp
.text:00000F3A                 pop     ebp
.text:00000F3B                 retn
.text:00000F3B ?IsEmpty@UString@@QBE_NXZ endp
.text:00000F3B
.text:00000F3B _text           ends
.text:00000F3B
.text:00000F3C ; ===========================================================================
.text:00000F3C
.text:00000F3C ; Segment type: Pure code
.text:00000F3C ; Segment permissions: Read/Execute
.text:00000F3C _text           segment para public 'CODE' use32
.text:00000F3C                 assume cs:_text
.text:00000F3C                 ;org 0F3Ch
.text:00000F3C ; COMDAT (pick any)
.text:00000F3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000F3C
.text:00000F3C ; =============== S U B R O U T I N E =======================================
.text:00000F3C
.text:00000F3C ; Attributes: bp-based frame
.text:00000F3C
.text:00000F3C ; public: class UString & __thiscall UString::operator+=(wchar_t)
.text:00000F3C                 public ??YUString@@QAEAAV0@_W@Z
.text:00000F3C ??YUString@@QAEAAV0@_W@Z proc near      ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+E1p
.text:00000F3C
.text:00000F3C var_C           = dword ptr -0Ch
.text:00000F3C var_8           = dword ptr -8
.text:00000F3C var_4           = dword ptr -4
.text:00000F3C arg_0           = word ptr  8
.text:00000F3C
.text:00000F3C                 push    ebp
.text:00000F3D                 mov     ebp, esp
.text:00000F3F                 sub     esp, 0Ch
.text:00000F42                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000F49                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000F50                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F57                 mov     [ebp+var_4], ecx
.text:00000F5A                 mov     eax, [ebp+var_4]
.text:00000F5D                 mov     ecx, [ebp+var_4]
.text:00000F60                 mov     edx, [eax+8]
.text:00000F63                 cmp     edx, [ecx+4]
.text:00000F66                 jnz     short loc_F70
.text:00000F68                 mov     ecx, [ebp+var_4] ; this
.text:00000F6B                 call    ?Grow_1@UString@@AAEXXZ ; UString::Grow_1(void)
.text:00000F70
.text:00000F70 loc_F70:                                ; CODE XREF: UString::operator+=(wchar_t)+2Aj
.text:00000F70                 mov     eax, [ebp+var_4]
.text:00000F73                 mov     ecx, [eax+4]
.text:00000F76                 mov     [ebp+var_8], ecx
.text:00000F79                 mov     edx, [ebp+var_4]
.text:00000F7C                 mov     eax, [edx]
.text:00000F7E                 mov     [ebp+var_C], eax
.text:00000F81                 mov     ecx, [ebp+var_8]
.text:00000F84                 mov     edx, [ebp+var_C]
.text:00000F87                 mov     ax, [ebp+arg_0]
.text:00000F8B                 mov     [edx+ecx*2], ax
.text:00000F8F                 mov     ecx, [ebp+var_8]
.text:00000F92                 add     ecx, 1
.text:00000F95                 mov     [ebp+var_8], ecx
.text:00000F98                 xor     edx, edx
.text:00000F9A                 mov     eax, [ebp+var_8]
.text:00000F9D                 mov     ecx, [ebp+var_C]
.text:00000FA0                 mov     [ecx+eax*2], dx
.text:00000FA4                 mov     edx, [ebp+var_4]
.text:00000FA7                 mov     eax, [ebp+var_8]
.text:00000FAA                 mov     [edx+4], eax
.text:00000FAD                 mov     eax, [ebp+var_4]
.text:00000FB0                 add     esp, 0Ch
.text:00000FB3                 cmp     ebp, esp
.text:00000FB5                 call    __RTC_CheckEsp
.text:00000FBA                 mov     esp, ebp
.text:00000FBC                 pop     ebp
.text:00000FBD                 retn    4
.text:00000FBD ??YUString@@QAEAAV0@_W@Z endp
.text:00000FBD
.text:00000FBD _text           ends
.text:00000FBD
.text:00000FC0 ; ===========================================================================
.text:00000FC0
.text:00000FC0 ; Segment type: Pure code
.text:00000FC0 ; Segment permissions: Read/Execute
.text:00000FC0 _text           segment para public 'CODE' use32
.text:00000FC0                 assume cs:_text
.text:00000FC0                 ;org 0FC0h
.text:00000FC0 ; COMDAT (pick any)
.text:00000FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000FC0
.text:00000FC0 ; =============== S U B R O U T I N E =======================================
.text:00000FC0
.text:00000FC0 ; Attributes: bp-based frame
.text:00000FC0
.text:00000FC0 ; _DWORD __thiscall CArcExtInfo::~CArcExtInfo(CArcExtInfo *__hidden this)
.text:00000FC0                 public ??1CArcExtInfo@@QAE@XZ
.text:00000FC0 ??1CArcExtInfo@@QAE@XZ proc near        ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+108p
.text:00000FC0                                         ; __unwindfunclet$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z$2+3j ...
.text:00000FC0
.text:00000FC0 var_10          = dword ptr -10h
.text:00000FC0 var_C           = dword ptr -0Ch
.text:00000FC0 var_4           = dword ptr -4
.text:00000FC0
.text:00000FC0                 push    ebp
.text:00000FC1                 mov     ebp, esp
.text:00000FC3                 push    0FFFFFFFFh
.text:00000FC5                 push    offset __ehhandler$??1CArcExtInfo@@QAE@XZ
.text:00000FCA                 mov     eax, large fs:0
.text:00000FD0                 push    eax
.text:00000FD1                 push    ecx
.text:00000FD2                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00000FD9                 mov     eax, dword ptr ds:___security_cookie
.text:00000FDE                 xor     eax, ebp
.text:00000FE0                 push    eax
.text:00000FE1                 lea     eax, [ebp+var_C]
.text:00000FE4                 mov     large fs:0, eax
.text:00000FEA                 mov     [ebp+var_10], ecx
.text:00000FED                 mov     [ebp+var_4], 0
.text:00000FF4                 mov     ecx, [ebp+var_10]
.text:00000FF7                 add     ecx, 0Ch        ; this
.text:00000FFA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000FFF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001006                 mov     ecx, [ebp+var_10] ; this
.text:00001009                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000100E                 mov     ecx, [ebp+var_C]
.text:00001011                 mov     large fs:0, ecx
.text:00001018                 pop     ecx
.text:00001019                 add     esp, 10h
.text:0000101C                 cmp     ebp, esp
.text:0000101E                 call    __RTC_CheckEsp
.text:00001023                 mov     esp, ebp
.text:00001025                 pop     ebp
.text:00001026                 retn
.text:00001026 ??1CArcExtInfo@@QAE@XZ endp
.text:00001026
.text:00001026 ; ---------------------------------------------------------------------------
.text:00001027                 align 4
.text:00001027 _text           ends
.text:00001027
.text$x:00001028 ; ===========================================================================
.text$x:00001028
.text$x:00001028 ; Segment type: Pure code
.text$x:00001028 ; Segment permissions: Read/Execute
.text$x:00001028 _text$x         segment para public 'CODE' use32
.text$x:00001028                 assume cs:_text$x
.text$x:00001028                 ;org 1028h
.text$x:00001028 ; COMDAT (pick associative to section at FC0)
.text$x:00001028                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001028
.text$x:00001028 ; =============== S U B R O U T I N E =======================================
.text$x:00001028
.text$x:00001028
.text$x:00001028 __unwindfunclet$??1CArcExtInfo@@QAE@XZ$0 proc near
.text$x:00001028                                         ; DATA XREF: .xdata$x:00001050o
.text$x:00001028                 mov     ecx, [ebp-10h]  ; this
.text$x:0000102B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000102B __unwindfunclet$??1CArcExtInfo@@QAE@XZ$0 endp
.text$x:0000102B
.text$x:00001030
.text$x:00001030 ; =============== S U B R O U T I N E =======================================
.text$x:00001030
.text$x:00001030
.text$x:00001030 __ehhandler$??1CArcExtInfo@@QAE@XZ proc near
.text$x:00001030                                         ; DATA XREF: CArcExtInfo::~CArcExtInfo(void)+5o
.text$x:00001030
.text$x:00001030 arg_4           = dword ptr  8
.text$x:00001030
.text$x:00001030                 mov     edx, [esp+arg_4]
.text$x:00001034                 lea     eax, [edx+0Ch]
.text$x:00001037                 mov     ecx, [edx-8]
.text$x:0000103A                 xor     ecx, eax
.text$x:0000103C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001041                 mov     eax, offset __ehfuncinfo$??1CArcExtInfo@@QAE@XZ
.text$x:00001046                 jmp     ___CxxFrameHandler3
.text$x:00001046 __ehhandler$??1CArcExtInfo@@QAE@XZ endp
.text$x:00001046
.text$x:00001046 ; ---------------------------------------------------------------------------
.text$x:0000104B                 align 4
.text$x:0000104B _text$x         ends
.text$x:0000104B
.xdata$x:0000104C ; ===========================================================================
.xdata$x:0000104C
.xdata$x:0000104C ; Segment type: Pure data
.xdata$x:0000104C ; Segment permissions: Read
.xdata$x:0000104C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000104C                 assume cs:_xdata$x
.xdata$x:0000104C                 ;org 104Ch
.xdata$x:0000104C ; COMDAT (pick associative to section at FC0)
.xdata$x:0000104C __unwindtable$??1CArcExtInfo@@QAE@XZ db 0FFh
.xdata$x:0000104C                                         ; DATA XREF: .xdata$x:0000105Co
.xdata$x:0000104D                 db 0FFh
.xdata$x:0000104E                 db 0FFh
.xdata$x:0000104F                 db 0FFh
.xdata$x:00001050                 dd offset __unwindfunclet$??1CArcExtInfo@@QAE@XZ$0
.xdata$x:00001054 __ehfuncinfo$??1CArcExtInfo@@QAE@XZ db  22h ; "
.xdata$x:00001054                                         ; DATA XREF: __ehhandler$??1CArcExtInfo@@QAE@XZ+11o
.xdata$x:00001055                 db    5
.xdata$x:00001056                 db  93h ; ô
.xdata$x:00001057                 db  19h
.xdata$x:00001058                 db    1
.xdata$x:00001059                 db    0
.xdata$x:0000105A                 db    0
.xdata$x:0000105B                 db    0
.xdata$x:0000105C                 dd offset __unwindtable$??1CArcExtInfo@@QAE@XZ
.xdata$x:00001060                 db    0
.xdata$x:00001061                 db    0
.xdata$x:00001062                 db    0
.xdata$x:00001063                 db    0
.xdata$x:00001064                 db    0
.xdata$x:00001065                 db    0
.xdata$x:00001066                 db    0
.xdata$x:00001067                 db    0
.xdata$x:00001068                 db    0
.xdata$x:00001069                 db    0
.xdata$x:0000106A                 db    0
.xdata$x:0000106B                 db    0
.xdata$x:0000106C                 db    0
.xdata$x:0000106D                 db    0
.xdata$x:0000106E                 db    0
.xdata$x:0000106F                 db    0
.xdata$x:00001070                 db    0
.xdata$x:00001071                 db    0
.xdata$x:00001072                 db    0
.xdata$x:00001073                 db    0
.xdata$x:00001074                 db    1
.xdata$x:00001075                 db    0
.xdata$x:00001076                 db    0
.xdata$x:00001077                 db    0
.xdata$x:00001077 _xdata$x        ends
.xdata$x:00001077
.text:00001078 ; ===========================================================================
.text:00001078
.text:00001078 ; Segment type: Pure code
.text:00001078 ; Segment permissions: Read/Execute
.text:00001078 _text           segment para public 'CODE' use32
.text:00001078                 assume cs:_text
.text:00001078                 ;org 1078h
.text:00001078 ; COMDAT (pick any)
.text:00001078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001078
.text:00001078 ; =============== S U B R O U T I N E =======================================
.text:00001078
.text:00001078 ; Attributes: bp-based frame
.text:00001078
.text:00001078 ; public: __thiscall CArcInfoEx::CArcInfoEx(void)
.text:00001078                 public ??0CArcInfoEx@@QAE@XZ
.text:00001078 ??0CArcInfoEx@@QAE@XZ proc near         ; CODE XREF: CCodecs::Load(void)+79p
.text:00001078
.text:00001078 var_10          = dword ptr -10h
.text:00001078 var_C           = dword ptr -0Ch
.text:00001078 var_4           = dword ptr -4
.text:00001078
.text:00001078                 push    ebp
.text:00001079                 mov     ebp, esp
.text:0000107B                 push    0FFFFFFFFh
.text:0000107D                 push    offset __ehhandler$??0CArcInfoEx@@QAE@XZ
.text:00001082                 mov     eax, large fs:0
.text:00001088                 push    eax
.text:00001089                 push    ecx
.text:0000108A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00001091                 mov     eax, dword ptr ds:___security_cookie
.text:00001096                 xor     eax, ebp
.text:00001098                 push    eax
.text:00001099                 lea     eax, [ebp+var_C]
.text:0000109C                 mov     large fs:0, eax
.text:000010A2                 mov     [ebp+var_10], ecx
.text:000010A5                 mov     eax, [ebp+var_10]
.text:000010A8                 mov     dword ptr [eax], 0
.text:000010AE                 mov     ecx, [ebp+var_10]
.text:000010B1                 mov     dword ptr [ecx+4], 0
.text:000010B8                 mov     edx, [ebp+var_10]
.text:000010BB                 mov     dword ptr [edx+8], 0
.text:000010C2                 mov     ecx, [ebp+var_10]
.text:000010C5                 add     ecx, 0Ch
.text:000010C8                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000010CD                 mov     [ebp+var_4], 0
.text:000010D4                 mov     ecx, [ebp+var_10]
.text:000010D7                 add     ecx, 18h
.text:000010DA                 call    ??0?$CObjectVector@UCArcExtInfo@@@@QAE@XZ ; CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(void)
.text:000010DF                 mov     byte ptr [ebp+var_4], 1
.text:000010E3                 mov     eax, [ebp+var_10]
.text:000010E6                 mov     dword ptr [eax+24h], 0
.text:000010ED                 mov     ecx, [ebp+var_10]
.text:000010F0                 mov     byte ptr [ecx+28h], 0
.text:000010F4                 mov     edx, [ebp+var_10]
.text:000010F7                 mov     byte ptr [edx+29h], 0
.text:000010FB                 mov     eax, [ebp+var_10]
.text:000010FE                 mov     dword ptr [eax+2Ch], 0
.text:00001105                 mov     ecx, [ebp+var_10]
.text:00001108                 add     ecx, 30h ; '0'
.text:0000110B                 call    ??0?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ ; CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(void)
.text:00001110                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001117                 mov     eax, [ebp+var_10]
.text:0000111A                 mov     ecx, [ebp+var_C]
.text:0000111D                 mov     large fs:0, ecx
.text:00001124                 pop     ecx
.text:00001125                 add     esp, 10h
.text:00001128                 cmp     ebp, esp
.text:0000112A                 call    __RTC_CheckEsp
.text:0000112F                 mov     esp, ebp
.text:00001131                 pop     ebp
.text:00001132                 retn
.text:00001132 ??0CArcInfoEx@@QAE@XZ endp
.text:00001132
.text:00001132 ; ---------------------------------------------------------------------------
.text:00001133                 align 4
.text:00001133 _text           ends
.text:00001133
.text$x:00001134 ; ===========================================================================
.text$x:00001134
.text$x:00001134 ; Segment type: Pure code
.text$x:00001134 ; Segment permissions: Read/Execute
.text$x:00001134 _text$x         segment para public 'CODE' use32
.text$x:00001134                 assume cs:_text$x
.text$x:00001134                 ;org 1134h
.text$x:00001134 ; COMDAT (pick associative to section at 1078)
.text$x:00001134                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001134
.text$x:00001134 ; =============== S U B R O U T I N E =======================================
.text$x:00001134
.text$x:00001134
.text$x:00001134 __unwindfunclet$??0CArcInfoEx@@QAE@XZ$0 proc near
.text$x:00001134                                         ; DATA XREF: .xdata$x:0000116Co
.text$x:00001134                 mov     ecx, [ebp-10h]
.text$x:00001137                 add     ecx, 0Ch        ; this
.text$x:0000113A                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000113A __unwindfunclet$??0CArcInfoEx@@QAE@XZ$0 endp
.text$x:0000113A
.text$x:0000113F
.text$x:0000113F ; =============== S U B R O U T I N E =======================================
.text$x:0000113F
.text$x:0000113F
.text$x:0000113F __unwindfunclet$??0CArcInfoEx@@QAE@XZ$1 proc near
.text$x:0000113F                                         ; DATA XREF: .xdata$x:00001174o
.text$x:0000113F                 mov     ecx, [ebp-10h]
.text$x:00001142                 add     ecx, 18h
.text$x:00001145                 jmp     ??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ ; CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)
.text$x:00001145 __unwindfunclet$??0CArcInfoEx@@QAE@XZ$1 endp
.text$x:00001145
.text$x:0000114A
.text$x:0000114A ; =============== S U B R O U T I N E =======================================
.text$x:0000114A
.text$x:0000114A
.text$x:0000114A __ehhandler$??0CArcInfoEx@@QAE@XZ proc near
.text$x:0000114A                                         ; DATA XREF: CArcInfoEx::CArcInfoEx(void)+5o
.text$x:0000114A
.text$x:0000114A arg_4           = dword ptr  8
.text$x:0000114A
.text$x:0000114A                 mov     edx, [esp+arg_4]
.text$x:0000114E                 lea     eax, [edx+0Ch]
.text$x:00001151                 mov     ecx, [edx-8]
.text$x:00001154                 xor     ecx, eax
.text$x:00001156                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000115B                 mov     eax, offset __ehfuncinfo$??0CArcInfoEx@@QAE@XZ
.text$x:00001160                 jmp     ___CxxFrameHandler3
.text$x:00001160 __ehhandler$??0CArcInfoEx@@QAE@XZ endp
.text$x:00001160
.text$x:00001160 ; ---------------------------------------------------------------------------
.text$x:00001165                 align 4
.text$x:00001165 _text$x         ends
.text$x:00001165
.xdata$x:00001168 ; ===========================================================================
.xdata$x:00001168
.xdata$x:00001168 ; Segment type: Pure data
.xdata$x:00001168 ; Segment permissions: Read
.xdata$x:00001168 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001168                 assume cs:_xdata$x
.xdata$x:00001168                 ;org 1168h
.xdata$x:00001168 ; COMDAT (pick associative to section at 1078)
.xdata$x:00001168 __unwindtable$??0CArcInfoEx@@QAE@XZ db 0FFh
.xdata$x:00001168                                         ; DATA XREF: .xdata$x:00001180o
.xdata$x:00001169                 db 0FFh
.xdata$x:0000116A                 db 0FFh
.xdata$x:0000116B                 db 0FFh
.xdata$x:0000116C                 dd offset __unwindfunclet$??0CArcInfoEx@@QAE@XZ$0
.xdata$x:00001170                 db    0
.xdata$x:00001171                 db    0
.xdata$x:00001172                 db    0
.xdata$x:00001173                 db    0
.xdata$x:00001174                 dd offset __unwindfunclet$??0CArcInfoEx@@QAE@XZ$1
.xdata$x:00001178 __ehfuncinfo$??0CArcInfoEx@@QAE@XZ db  22h ; "
.xdata$x:00001178                                         ; DATA XREF: __ehhandler$??0CArcInfoEx@@QAE@XZ+11o
.xdata$x:00001179                 db    5
.xdata$x:0000117A                 db  93h ; ô
.xdata$x:0000117B                 db  19h
.xdata$x:0000117C                 db    2
.xdata$x:0000117D                 db    0
.xdata$x:0000117E                 db    0
.xdata$x:0000117F                 db    0
.xdata$x:00001180                 dd offset __unwindtable$??0CArcInfoEx@@QAE@XZ
.xdata$x:00001184                 db    0
.xdata$x:00001185                 db    0
.xdata$x:00001186                 db    0
.xdata$x:00001187                 db    0
.xdata$x:00001188                 db    0
.xdata$x:00001189                 db    0
.xdata$x:0000118A                 db    0
.xdata$x:0000118B                 db    0
.xdata$x:0000118C                 db    0
.xdata$x:0000118D                 db    0
.xdata$x:0000118E                 db    0
.xdata$x:0000118F                 db    0
.xdata$x:00001190                 db    0
.xdata$x:00001191                 db    0
.xdata$x:00001192                 db    0
.xdata$x:00001193                 db    0
.xdata$x:00001194                 db    0
.xdata$x:00001195                 db    0
.xdata$x:00001196                 db    0
.xdata$x:00001197                 db    0
.xdata$x:00001198                 db    1
.xdata$x:00001199                 db    0
.xdata$x:0000119A                 db    0
.xdata$x:0000119B                 db    0
.xdata$x:0000119B _xdata$x        ends
.xdata$x:0000119B
.text:0000119C ; ===========================================================================
.text:0000119C
.text:0000119C ; Segment type: Pure code
.text:0000119C ; Segment permissions: Read/Execute
.text:0000119C _text           segment para public 'CODE' use32
.text:0000119C                 assume cs:_text
.text:0000119C                 ;org 119Ch
.text:0000119C ; COMDAT (pick any)
.text:0000119C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000119C
.text:0000119C ; =============== S U B R O U T I N E =======================================
.text:0000119C
.text:0000119C ; Attributes: bp-based frame
.text:0000119C
.text:0000119C ; bool __thiscall CArcInfo::IsMultiSignature(CArcInfo *__hidden this)
.text:0000119C                 public ?IsMultiSignature@CArcInfo@@QBE_NXZ
.text:0000119C ?IsMultiSignature@CArcInfo@@QBE_NXZ proc near
.text:0000119C                                         ; CODE XREF: CCodecs::Load(void)+148p
.text:0000119C
.text:0000119C var_4           = dword ptr -4
.text:0000119C
.text:0000119C                 push    ebp
.text:0000119D                 mov     ebp, esp
.text:0000119F                 push    ecx
.text:000011A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000011A7                 mov     [ebp+var_4], ecx
.text:000011AA                 mov     eax, [ebp+var_4]
.text:000011AD                 movzx   eax, word ptr [eax]
.text:000011B0                 and     eax, 10h
.text:000011B3                 neg     eax
.text:000011B5                 sbb     eax, eax
.text:000011B7                 neg     eax
.text:000011B9                 mov     esp, ebp
.text:000011BB                 pop     ebp
.text:000011BC                 retn
.text:000011BC ?IsMultiSignature@CArcInfo@@QBE_NXZ endp
.text:000011BC
.text:000011BC ; ---------------------------------------------------------------------------
.text:000011BD                 align 10h
.text:000011BD _text           ends
.text:000011BD
.text:000011C0 ; ===========================================================================
.text:000011C0
.text:000011C0 ; Segment type: Pure code
.text:000011C0 ; Segment permissions: Read/Execute
.text:000011C0 _text           segment para public 'CODE' use32
.text:000011C0                 assume cs:_text
.text:000011C0                 ;org 11C0h
.text:000011C0 ; COMDAT (pick any)
.text:000011C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000011C0
.text:000011C0 ; =============== S U B R O U T I N E =======================================
.text:000011C0
.text:000011C0 ; Attributes: bp-based frame
.text:000011C0
.text:000011C0 ; _DWORD __thiscall CArcInfoEx::~CArcInfoEx(CArcInfoEx *__hidden this)
.text:000011C0                 public ??1CArcInfoEx@@QAE@XZ
.text:000011C0 ??1CArcInfoEx@@QAE@XZ proc near         ; CODE XREF: CCodecs::Load(void)+1A5p
.text:000011C0                                         ; __unwindfunclet$?Load@CCodecs@@QAEJXZ$0+3j ...
.text:000011C0
.text:000011C0 var_10          = dword ptr -10h
.text:000011C0 var_C           = dword ptr -0Ch
.text:000011C0 var_4           = dword ptr -4
.text:000011C0
.text:000011C0                 push    ebp
.text:000011C1                 mov     ebp, esp
.text:000011C3                 push    0FFFFFFFFh
.text:000011C5                 push    offset __ehhandler$??1CArcInfoEx@@QAE@XZ
.text:000011CA                 mov     eax, large fs:0
.text:000011D0                 push    eax
.text:000011D1                 push    ecx
.text:000011D2                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000011D9                 mov     eax, dword ptr ds:___security_cookie
.text:000011DE                 xor     eax, ebp
.text:000011E0                 push    eax
.text:000011E1                 lea     eax, [ebp+var_C]
.text:000011E4                 mov     large fs:0, eax
.text:000011EA                 mov     [ebp+var_10], ecx
.text:000011ED                 mov     [ebp+var_4], 1
.text:000011F4                 mov     ecx, [ebp+var_10]
.text:000011F7                 add     ecx, 30h ; '0'
.text:000011FA                 call    ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ ; CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)
.text:000011FF                 mov     byte ptr [ebp+var_4], 0
.text:00001203                 mov     ecx, [ebp+var_10]
.text:00001206                 add     ecx, 18h
.text:00001209                 call    ??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ ; CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)
.text:0000120E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001215                 mov     ecx, [ebp+var_10]
.text:00001218                 add     ecx, 0Ch        ; this
.text:0000121B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001220                 mov     ecx, [ebp+var_C]
.text:00001223                 mov     large fs:0, ecx
.text:0000122A                 pop     ecx
.text:0000122B                 add     esp, 10h
.text:0000122E                 cmp     ebp, esp
.text:00001230                 call    __RTC_CheckEsp
.text:00001235                 mov     esp, ebp
.text:00001237                 pop     ebp
.text:00001238                 retn
.text:00001238 ??1CArcInfoEx@@QAE@XZ endp
.text:00001238
.text:00001238 ; ---------------------------------------------------------------------------
.text:00001239                 align 4
.text:00001239 _text           ends
.text:00001239
.text$x:0000123C ; ===========================================================================
.text$x:0000123C
.text$x:0000123C ; Segment type: Pure code
.text$x:0000123C ; Segment permissions: Read/Execute
.text$x:0000123C _text$x         segment para public 'CODE' use32
.text$x:0000123C                 assume cs:_text$x
.text$x:0000123C                 ;org 123Ch
.text$x:0000123C ; COMDAT (pick associative to section at 11C0)
.text$x:0000123C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000123C
.text$x:0000123C ; =============== S U B R O U T I N E =======================================
.text$x:0000123C
.text$x:0000123C
.text$x:0000123C __unwindfunclet$??1CArcInfoEx@@QAE@XZ$0 proc near
.text$x:0000123C                                         ; DATA XREF: .xdata$x:00001274o
.text$x:0000123C                 mov     ecx, [ebp-10h]
.text$x:0000123F                 add     ecx, 0Ch        ; this
.text$x:00001242                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001242 __unwindfunclet$??1CArcInfoEx@@QAE@XZ$0 endp
.text$x:00001242
.text$x:00001247
.text$x:00001247 ; =============== S U B R O U T I N E =======================================
.text$x:00001247
.text$x:00001247
.text$x:00001247 __unwindfunclet$??1CArcInfoEx@@QAE@XZ$1 proc near
.text$x:00001247                                         ; DATA XREF: .xdata$x:0000127Co
.text$x:00001247                 mov     ecx, [ebp-10h]
.text$x:0000124A                 add     ecx, 18h
.text$x:0000124D                 jmp     ??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ ; CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)
.text$x:0000124D __unwindfunclet$??1CArcInfoEx@@QAE@XZ$1 endp
.text$x:0000124D
.text$x:00001252
.text$x:00001252 ; =============== S U B R O U T I N E =======================================
.text$x:00001252
.text$x:00001252
.text$x:00001252 __ehhandler$??1CArcInfoEx@@QAE@XZ proc near
.text$x:00001252                                         ; DATA XREF: CArcInfoEx::~CArcInfoEx(void)+5o
.text$x:00001252
.text$x:00001252 arg_4           = dword ptr  8
.text$x:00001252
.text$x:00001252                 mov     edx, [esp+arg_4]
.text$x:00001256                 lea     eax, [edx+0Ch]
.text$x:00001259                 mov     ecx, [edx-8]
.text$x:0000125C                 xor     ecx, eax
.text$x:0000125E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001263                 mov     eax, offset __ehfuncinfo$??1CArcInfoEx@@QAE@XZ
.text$x:00001268                 jmp     ___CxxFrameHandler3
.text$x:00001268 __ehhandler$??1CArcInfoEx@@QAE@XZ endp
.text$x:00001268
.text$x:00001268 ; ---------------------------------------------------------------------------
.text$x:0000126D                 align 10h
.text$x:0000126D _text$x         ends
.text$x:0000126D
.xdata$x:00001270 ; ===========================================================================
.xdata$x:00001270
.xdata$x:00001270 ; Segment type: Pure data
.xdata$x:00001270 ; Segment permissions: Read
.xdata$x:00001270 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001270                 assume cs:_xdata$x
.xdata$x:00001270                 ;org 1270h
.xdata$x:00001270 ; COMDAT (pick associative to section at 11C0)
.xdata$x:00001270 __unwindtable$??1CArcInfoEx@@QAE@XZ db 0FFh
.xdata$x:00001270                                         ; DATA XREF: .xdata$x:00001288o
.xdata$x:00001271                 db 0FFh
.xdata$x:00001272                 db 0FFh
.xdata$x:00001273                 db 0FFh
.xdata$x:00001274                 dd offset __unwindfunclet$??1CArcInfoEx@@QAE@XZ$0
.xdata$x:00001278                 db    0
.xdata$x:00001279                 db    0
.xdata$x:0000127A                 db    0
.xdata$x:0000127B                 db    0
.xdata$x:0000127C                 dd offset __unwindfunclet$??1CArcInfoEx@@QAE@XZ$1
.xdata$x:00001280 __ehfuncinfo$??1CArcInfoEx@@QAE@XZ db  22h ; "
.xdata$x:00001280                                         ; DATA XREF: __ehhandler$??1CArcInfoEx@@QAE@XZ+11o
.xdata$x:00001281                 db    5
.xdata$x:00001282                 db  93h ; ô
.xdata$x:00001283                 db  19h
.xdata$x:00001284                 db    2
.xdata$x:00001285                 db    0
.xdata$x:00001286                 db    0
.xdata$x:00001287                 db    0
.xdata$x:00001288                 dd offset __unwindtable$??1CArcInfoEx@@QAE@XZ
.xdata$x:0000128C                 align 20h
.xdata$x:000012A0                 db    1
.xdata$x:000012A1                 db    0
.xdata$x:000012A2                 db    0
.xdata$x:000012A3                 db    0
.xdata$x:000012A3 _xdata$x        ends
.xdata$x:000012A3
.text:000012A4 ; ===========================================================================
.text:000012A4
.text:000012A4 ; Segment type: Pure code
.text:000012A4 ; Segment permissions: Read/Execute
.text:000012A4 _text           segment para public 'CODE' use32
.text:000012A4                 assume cs:_text
.text:000012A4                 ;org 12A4h
.text:000012A4 ; COMDAT (pick any)
.text:000012A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000012A4
.text:000012A4 ; =============== S U B R O U T I N E =======================================
.text:000012A4
.text:000012A4 ; Attributes: bp-based frame
.text:000012A4
.text:000012A4 ; const wchar_t *__thiscall UString::Ptr(UString *this, unsigned int)
.text:000012A4                 public ?Ptr@UString@@QBEPB_WI@Z
.text:000012A4 ?Ptr@UString@@QBEPB_WI@Z proc near      ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+64p
.text:000012A4
.text:000012A4 var_4           = dword ptr -4
.text:000012A4 arg_0           = dword ptr  8
.text:000012A4
.text:000012A4                 push    ebp
.text:000012A5                 mov     ebp, esp
.text:000012A7                 push    ecx
.text:000012A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000012AF                 mov     [ebp+var_4], ecx
.text:000012B2                 mov     eax, [ebp+var_4]
.text:000012B5                 mov     ecx, [eax]
.text:000012B7                 mov     edx, [ebp+arg_0]
.text:000012BA                 lea     eax, [ecx+edx*2]
.text:000012BD                 mov     esp, ebp
.text:000012BF                 pop     ebp
.text:000012C0                 retn    4
.text:000012C0 ?Ptr@UString@@QBEPB_WI@Z endp
.text:000012C0
.text:000012C0 ; ---------------------------------------------------------------------------
.text:000012C3                 align 4
.text:000012C3 _text           ends
.text:000012C3
.text:000012C4 ; ===========================================================================
.text:000012C4
.text:000012C4 ; Segment type: Pure code
.text:000012C4 ; Segment permissions: Read/Execute
.text:000012C4 _text           segment para public 'CODE' use32
.text:000012C4                 assume cs:_text
.text:000012C4                 ;org 12C4h
.text:000012C4 ; COMDAT (pick any)
.text:000012C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000012C4
.text:000012C4 ; =============== S U B R O U T I N E =======================================
.text:000012C4
.text:000012C4 ; Attributes: bp-based frame
.text:000012C4
.text:000012C4 ; bool __thiscall UString::IsEqualTo_Ascii_NoCase(UString *this, const char *)
.text:000012C4                 public ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z
.text:000012C4 ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z proc near
.text:000012C4                                         ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+AEp
.text:000012C4
.text:000012C4 var_4           = dword ptr -4
.text:000012C4 arg_0           = dword ptr  8
.text:000012C4
.text:000012C4                 push    ebp
.text:000012C5                 mov     ebp, esp
.text:000012C7                 push    ecx
.text:000012C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000012CF                 mov     [ebp+var_4], ecx
.text:000012D2                 mov     eax, [ebp+arg_0]
.text:000012D5                 push    eax             ; char *
.text:000012D6                 mov     ecx, [ebp+var_4]
.text:000012D9                 mov     edx, [ecx]
.text:000012DB                 push    edx             ; wchar_t *
.text:000012DC                 call    ?StringsAreEqualNoCase_Ascii@@YG_NPB_WPBD@Z ; StringsAreEqualNoCase_Ascii(wchar_t const *,char const *)
.text:000012E1                 add     esp, 4
.text:000012E4                 cmp     ebp, esp
.text:000012E6                 call    __RTC_CheckEsp
.text:000012EB                 mov     esp, ebp
.text:000012ED                 pop     ebp
.text:000012EE                 retn    4
.text:000012EE ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z endp
.text:000012EE
.text:000012EE ; ---------------------------------------------------------------------------
.text:000012F1                 align 4
.text:000012F1 _text           ends
.text:000012F1
.text:000012F4 ; ===========================================================================
.text:000012F4
.text:000012F4 ; Segment type: Pure code
.text:000012F4 ; Segment permissions: Read/Execute
.text:000012F4 _text           segment para public 'CODE' use32
.text:000012F4                 assume cs:_text
.text:000012F4                 ;org 12F4h
.text:000012F4 ; COMDAT (pick any)
.text:000012F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000012F4
.text:000012F4 ; =============== S U B R O U T I N E =======================================
.text:000012F4
.text:000012F4 ; Attributes: bp-based frame
.text:000012F4
.text:000012F4 ; int __thiscall UString::ReverseFind_Dot(UString *__hidden this)
.text:000012F4                 public ?ReverseFind_Dot@UString@@QBEHXZ
.text:000012F4 ?ReverseFind_Dot@UString@@QBEHXZ proc near
.text:000012F4                                         ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+3Dp
.text:000012F4
.text:000012F4 var_4           = dword ptr -4
.text:000012F4
.text:000012F4                 push    ebp
.text:000012F5                 mov     ebp, esp
.text:000012F7                 push    ecx
.text:000012F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000012FF                 mov     [ebp+var_4], ecx
.text:00001302                 push    2Eh ; '.'       ; wchar_t
.text:00001304                 mov     ecx, [ebp+var_4] ; this
.text:00001307                 call    ?ReverseFind@UString@@QBEH_W@Z ; UString::ReverseFind(wchar_t)
.text:0000130C                 add     esp, 4
.text:0000130F                 cmp     ebp, esp
.text:00001311                 call    __RTC_CheckEsp
.text:00001316                 mov     esp, ebp
.text:00001318                 pop     ebp
.text:00001319                 retn
.text:00001319 ?ReverseFind_Dot@UString@@QBEHXZ endp
.text:00001319
.text:00001319 ; ---------------------------------------------------------------------------
.text:0000131A                 align 4
.text:0000131A _text           ends
.text:0000131A
.text:0000131C ; ===========================================================================
.text:0000131C
.text:0000131C ; Segment type: Pure code
.text:0000131C ; Segment permissions: Read/Execute
.text:0000131C _text           segment para public 'CODE' use32
.text:0000131C                 assume cs:_text
.text:0000131C                 ;org 131Ch
.text:0000131C ; COMDAT (pick any)
.text:0000131C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000131C
.text:0000131C ; =============== S U B R O U T I N E =======================================
.text:0000131C
.text:0000131C ; Attributes: bp-based frame
.text:0000131C
.text:0000131C ; public: class UString __thiscall UString::Mid(unsigned int, unsigned int)const
.text:0000131C                 public ?Mid@UString@@QBE?AV1@II@Z
.text:0000131C ?Mid@UString@@QBE?AV1@II@Z proc near    ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+8Ep
.text:0000131C
.text:0000131C var_8           = dword ptr -8
.text:0000131C var_4           = dword ptr -4
.text:0000131C arg_0           = dword ptr  8
.text:0000131C arg_4           = dword ptr  0Ch
.text:0000131C arg_8           = dword ptr  10h
.text:0000131C
.text:0000131C                 push    ebp
.text:0000131D                 mov     ebp, esp
.text:0000131F                 sub     esp, 8
.text:00001322                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001329                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001330                 mov     [ebp+var_4], ecx
.text:00001333                 mov     [ebp+var_8], 0
.text:0000133A                 mov     eax, [ebp+var_4]
.text:0000133D                 mov     ecx, [eax]
.text:0000133F                 mov     edx, [ebp+arg_4]
.text:00001342                 lea     eax, [ecx+edx*2]
.text:00001345                 push    eax
.text:00001346                 mov     ecx, [ebp+arg_8]
.text:00001349                 push    ecx
.text:0000134A                 mov     ecx, [ebp+arg_0]
.text:0000134D                 call    ??0UString@@AAE@IPB_W@Z ; UString::UString(uint,wchar_t const *)
.text:00001352                 mov     edx, [ebp+var_8]
.text:00001355                 or      edx, 1
.text:00001358                 mov     [ebp+var_8], edx
.text:0000135B                 mov     eax, [ebp+arg_0]
.text:0000135E                 add     esp, 8
.text:00001361                 cmp     ebp, esp
.text:00001363                 call    __RTC_CheckEsp
.text:00001368                 mov     esp, ebp
.text:0000136A                 pop     ebp
.text:0000136B                 retn    0Ch
.text:0000136B ?Mid@UString@@QBE?AV1@II@Z endp
.text:0000136B
.text:0000136B ; ---------------------------------------------------------------------------
.text:0000136E                 align 10h
.text:0000136E _text           ends
.text:0000136E
.text:00001370 ; ===========================================================================
.text:00001370
.text:00001370 ; Segment type: Pure code
.text:00001370 ; Segment permissions: Read/Execute
.text:00001370 _text           segment para public 'CODE' use32
.text:00001370                 assume cs:_text
.text:00001370                 ;org 1370h
.text:00001370 ; COMDAT (pick any)
.text:00001370                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001370
.text:00001370 ; =============== S U B R O U T I N E =======================================
.text:00001370
.text:00001370 ; Attributes: bp-based frame
.text:00001370
.text:00001370 ; int __thiscall UString::Find(UString *this, wchar_t, unsigned int)
.text:00001370                 public ?Find@UString@@QBEH_WI@Z
.text:00001370 ?Find@UString@@QBEH_WI@Z proc near      ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+63p
.text:00001370
.text:00001370 var_C           = dword ptr -0Ch
.text:00001370 var_8           = dword ptr -8
.text:00001370 var_4           = dword ptr -4
.text:00001370 arg_0           = word ptr  8
.text:00001370 arg_4           = dword ptr  0Ch
.text:00001370
.text:00001370                 push    ebp
.text:00001371                 mov     ebp, esp
.text:00001373                 sub     esp, 0Ch
.text:00001376                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000137D                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001384                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000138B                 mov     [ebp+var_4], ecx
.text:0000138E                 movzx   eax, [ebp+arg_0]
.text:00001392                 push    eax             ; wchar_t
.text:00001393                 mov     ecx, [ebp+var_4]
.text:00001396                 mov     edx, [ecx]
.text:00001398                 mov     eax, [ebp+arg_4]
.text:0000139B                 lea     ecx, [edx+eax*2]
.text:0000139E                 push    ecx             ; wchar_t *
.text:0000139F                 call    ?FindCharPosInString@@YGHPB_W_W@Z ; FindCharPosInString(wchar_t const *,wchar_t)
.text:000013A4                 mov     [ebp+var_8], eax
.text:000013A7                 cmp     [ebp+var_8], 0
.text:000013AB                 jge     short loc_13B6
.text:000013AD                 mov     [ebp+var_C], 0FFFFFFFFh
.text:000013B4                 jmp     short loc_13BF
.text:000013B6 ; ---------------------------------------------------------------------------
.text:000013B6
.text:000013B6 loc_13B6:                               ; CODE XREF: UString::Find(wchar_t,uint)+3Bj
.text:000013B6                 mov     edx, [ebp+arg_4]
.text:000013B9                 add     edx, [ebp+var_8]
.text:000013BC                 mov     [ebp+var_C], edx
.text:000013BF
.text:000013BF loc_13BF:                               ; CODE XREF: UString::Find(wchar_t,uint)+44j
.text:000013BF                 mov     eax, [ebp+var_C]
.text:000013C2                 add     esp, 0Ch
.text:000013C5                 cmp     ebp, esp
.text:000013C7                 call    __RTC_CheckEsp
.text:000013CC                 mov     esp, ebp
.text:000013CE                 pop     ebp
.text:000013CF                 retn    8
.text:000013CF ?Find@UString@@QBEH_WI@Z endp
.text:000013CF
.text:000013CF ; ---------------------------------------------------------------------------
.text:000013D2                 align 4
.text:000013D2 _text           ends
.text:000013D2
.text:000013D4 ; ===========================================================================
.text:000013D4
.text:000013D4 ; Segment type: Pure code
.text:000013D4 ; Segment permissions: Read/Execute
.text:000013D4 _text           segment para public 'CODE' use32
.text:000013D4                 assume cs:_text
.text:000013D4                 ;org 13D4h
.text:000013D4 ; COMDAT (pick any)
.text:000013D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000013D4
.text:000013D4 ; =============== S U B R O U T I N E =======================================
.text:000013D4
.text:000013D4 ; Attributes: bp-based frame
.text:000013D4
.text:000013D4 ; int __stdcall operator!=(int, wchar_t *Str2)
.text:000013D4                 public ??9@YG_NABVUString@@PB_W@Z
.text:000013D4 ??9@YG_NABVUString@@PB_W@Z proc near    ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+DFp
.text:000013D4
.text:000013D4 arg_0           = dword ptr  8
.text:000013D4 Str2            = dword ptr  0Ch
.text:000013D4
.text:000013D4                 push    ebp
.text:000013D5                 mov     ebp, esp
.text:000013D7                 push    esi
.text:000013D8                 mov     esi, esp
.text:000013DA                 mov     eax, [ebp+Str2]
.text:000013DD                 push    eax             ; Str2
.text:000013DE                 mov     ecx, [ebp+arg_0]
.text:000013E1                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000013E6                 push    eax             ; Str1
.text:000013E7                 call    dword ptr ds:__imp__wcscmp
.text:000013ED                 add     esp, 8
.text:000013F0                 cmp     esi, esp
.text:000013F2                 call    __RTC_CheckEsp
.text:000013F7                 neg     eax
.text:000013F9                 sbb     eax, eax
.text:000013FB                 neg     eax
.text:000013FD                 pop     esi
.text:000013FE                 cmp     ebp, esp
.text:00001400                 call    __RTC_CheckEsp
.text:00001405                 pop     ebp
.text:00001406                 retn    8
.text:00001406 ??9@YG_NABVUString@@PB_W@Z endp
.text:00001406
.text:00001406 ; ---------------------------------------------------------------------------
.text:00001409                 align 4
.text:00001409 _text           ends
.text:00001409
.text:0000140C ; ===========================================================================
.text:0000140C
.text:0000140C ; Segment type: Pure code
.text:0000140C ; Segment permissions: Read/Execute
.text:0000140C _text           segment para public 'CODE' use32
.text:0000140C                 assume cs:_text
.text:0000140C                 ;org 140Ch
.text:0000140C ; COMDAT (pick any)
.text:0000140C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000140C
.text:0000140C ; =============== S U B R O U T I N E =======================================
.text:0000140C
.text:0000140C ; Attributes: bp-based frame
.text:0000140C
.text:0000140C ; public: unsigned int __thiscall CObjectVector<struct CArcExtInfo>::Size(void)const
.text:0000140C                 public ?Size@?$CObjectVector@UCArcExtInfo@@@@QBEIXZ
.text:0000140C ?Size@?$CObjectVector@UCArcExtInfo@@@@QBEIXZ proc near
.text:0000140C                                         ; CODE XREF: CArcInfoEx::FindExtension(UString const &)+2Fp
.text:0000140C                                         ; CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)+51p
.text:0000140C
.text:0000140C var_4           = dword ptr -4
.text:0000140C
.text:0000140C                 push    ebp
.text:0000140D                 mov     ebp, esp
.text:0000140F                 push    ecx
.text:00001410                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001417                 mov     [ebp+var_4], ecx
.text:0000141A                 mov     ecx, [ebp+var_4]
.text:0000141D                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00001422                 add     esp, 4
.text:00001425                 cmp     ebp, esp
.text:00001427                 call    __RTC_CheckEsp
.text:0000142C                 mov     esp, ebp
.text:0000142E                 pop     ebp
.text:0000142F                 retn
.text:0000142F ?Size@?$CObjectVector@UCArcExtInfo@@@@QBEIXZ endp
.text:0000142F
.text:0000142F _text           ends
.text:0000142F
.text:00001430 ; ===========================================================================
.text:00001430
.text:00001430 ; Segment type: Pure code
.text:00001430 ; Segment permissions: Read/Execute
.text:00001430 _text           segment para public 'CODE' use32
.text:00001430                 assume cs:_text
.text:00001430                 ;org 1430h
.text:00001430 ; COMDAT (pick any)
.text:00001430                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001430
.text:00001430 ; =============== S U B R O U T I N E =======================================
.text:00001430
.text:00001430 ; Attributes: bp-based frame
.text:00001430
.text:00001430 ; public: __thiscall CObjectVector<struct CArcExtInfo>::CObjectVector<struct CArcExtInfo>(void)
.text:00001430                 public ??0?$CObjectVector@UCArcExtInfo@@@@QAE@XZ
.text:00001430 ??0?$CObjectVector@UCArcExtInfo@@@@QAE@XZ proc near
.text:00001430                                         ; CODE XREF: CArcInfoEx::CArcInfoEx(void)+62p
.text:00001430
.text:00001430 var_4           = dword ptr -4
.text:00001430
.text:00001430                 push    ebp
.text:00001431                 mov     ebp, esp
.text:00001433                 push    ecx
.text:00001434                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000143B                 mov     [ebp+var_4], ecx
.text:0000143E                 mov     ecx, [ebp+var_4]
.text:00001441                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00001446                 mov     eax, [ebp+var_4]
.text:00001449                 add     esp, 4
.text:0000144C                 cmp     ebp, esp
.text:0000144E                 call    __RTC_CheckEsp
.text:00001453                 mov     esp, ebp
.text:00001455                 pop     ebp
.text:00001456                 retn
.text:00001456 ??0?$CObjectVector@UCArcExtInfo@@@@QAE@XZ endp
.text:00001456
.text:00001456 ; ---------------------------------------------------------------------------
.text:00001457                 align 4
.text:00001457 _text           ends
.text:00001457
.text:00001458 ; ===========================================================================
.text:00001458
.text:00001458 ; Segment type: Pure code
.text:00001458 ; Segment permissions: Read/Execute
.text:00001458 _text           segment para public 'CODE' use32
.text:00001458                 assume cs:_text
.text:00001458                 ;org 1458h
.text:00001458 ; COMDAT (pick any)
.text:00001458                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001458
.text:00001458 ; =============== S U B R O U T I N E =======================================
.text:00001458
.text:00001458 ; Attributes: bp-based frame
.text:00001458
.text:00001458 ; public: struct CArcExtInfo const & __thiscall CObjectVector<struct CArcExtInfo>::operator[](unsigned int)const
.text:00001458                 public ??A?$CObjectVector@UCArcExtInfo@@@@QBEABUCArcExtInfo@@I@Z
.text:00001458 ??A?$CObjectVector@UCArcExtInfo@@@@QBEABUCArcExtInfo@@I@Z proc near
.text:00001458                                         ; CODE XREF: CArcInfoEx::FindExtension(UString const &)+43p
.text:00001458                                         ; CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)+9Dp
.text:00001458
.text:00001458 var_4           = dword ptr -4
.text:00001458 arg_0           = dword ptr  8
.text:00001458
.text:00001458                 push    ebp
.text:00001459                 mov     ebp, esp
.text:0000145B                 push    ecx
.text:0000145C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001463                 mov     [ebp+var_4], ecx
.text:00001466                 mov     eax, [ebp+arg_0]
.text:00001469                 push    eax
.text:0000146A                 mov     ecx, [ebp+var_4]
.text:0000146D                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00001472                 mov     eax, [eax]
.text:00001474                 add     esp, 4
.text:00001477                 cmp     ebp, esp
.text:00001479                 call    __RTC_CheckEsp
.text:0000147E                 mov     esp, ebp
.text:00001480                 pop     ebp
.text:00001481                 retn    4
.text:00001481 ??A?$CObjectVector@UCArcExtInfo@@@@QBEABUCArcExtInfo@@I@Z endp
.text:00001481
.text:00001481 _text           ends
.text:00001481
.text:00001484 ; ===========================================================================
.text:00001484
.text:00001484 ; Segment type: Pure code
.text:00001484 ; Segment permissions: Read/Execute
.text:00001484 _text           segment para public 'CODE' use32
.text:00001484                 assume cs:_text
.text:00001484                 ;org 1484h
.text:00001484 ; COMDAT (pick any)
.text:00001484                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001484
.text:00001484 ; =============== S U B R O U T I N E =======================================
.text:00001484
.text:00001484 ; Attributes: bp-based frame
.text:00001484
.text:00001484 ; public: unsigned int __thiscall CObjectVector<struct CArcExtInfo>::Add(struct CArcExtInfo const &)
.text:00001484                 public ?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z
.text:00001484 ?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z proc near
.text:00001484                                         ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+FCp
.text:00001484
.text:00001484 var_1C          = dword ptr -1Ch
.text:00001484 var_18          = dword ptr -18h
.text:00001484 var_14          = dword ptr -14h
.text:00001484 var_10          = dword ptr -10h
.text:00001484 var_C           = dword ptr -0Ch
.text:00001484 var_4           = dword ptr -4
.text:00001484 arg_0           = dword ptr  8
.text:00001484
.text:00001484                 push    ebp
.text:00001485                 mov     ebp, esp
.text:00001487                 push    0FFFFFFFFh
.text:00001489                 push    offset __ehhandler$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z
.text:0000148E                 mov     eax, large fs:0
.text:00001494                 push    eax
.text:00001495                 sub     esp, 10h
.text:00001498                 mov     eax, 0CCCCCCCCh
.text:0000149D                 mov     [ebp+var_1C], eax
.text:000014A0                 mov     [ebp+var_18], eax
.text:000014A3                 mov     [ebp+var_14], eax
.text:000014A6                 mov     [ebp+var_10], eax
.text:000014A9                 mov     eax, dword ptr ds:___security_cookie
.text:000014AE                 xor     eax, ebp
.text:000014B0                 push    eax
.text:000014B1                 lea     eax, [ebp+var_C]
.text:000014B4                 mov     large fs:0, eax
.text:000014BA                 mov     [ebp+var_10], ecx
.text:000014BD                 push    18h             ; unsigned int
.text:000014BF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000014C4                 add     esp, 4
.text:000014C7                 mov     [ebp+var_18], eax
.text:000014CA                 mov     [ebp+var_4], 0
.text:000014D1                 cmp     [ebp+var_18], 0
.text:000014D5                 jz      short loc_14E8
.text:000014D7                 mov     eax, [ebp+arg_0]
.text:000014DA                 push    eax
.text:000014DB                 mov     ecx, [ebp+var_18]
.text:000014DE                 call    ??0CArcExtInfo@@QAE@ABU0@@Z ; CArcExtInfo::CArcExtInfo(CArcExtInfo const &)
.text:000014E3                 mov     [ebp+var_1C], eax
.text:000014E6                 jmp     short loc_14EF
.text:000014E8 ; ---------------------------------------------------------------------------
.text:000014E8
.text:000014E8 loc_14E8:                               ; CODE XREF: CObjectVector<CArcExtInfo>::Add(CArcExtInfo const &)+51j
.text:000014E8                 mov     [ebp+var_1C], 0
.text:000014EF
.text:000014EF loc_14EF:                               ; CODE XREF: CObjectVector<CArcExtInfo>::Add(CArcExtInfo const &)+62j
.text:000014EF                 mov     ecx, [ebp+var_1C]
.text:000014F2                 mov     [ebp+var_14], ecx
.text:000014F5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000014FC                 mov     edx, [ebp+var_14]
.text:000014FF                 push    edx
.text:00001500                 mov     ecx, [ebp+var_10]
.text:00001503                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00001508                 mov     ecx, [ebp+var_C]
.text:0000150B                 mov     large fs:0, ecx
.text:00001512                 pop     ecx
.text:00001513                 add     esp, 1Ch
.text:00001516                 cmp     ebp, esp
.text:00001518                 call    __RTC_CheckEsp
.text:0000151D                 mov     esp, ebp
.text:0000151F                 pop     ebp
.text:00001520                 retn    4
.text:00001520 ?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z endp
.text:00001520
.text:00001520 ; ---------------------------------------------------------------------------
.text:00001523                 align 4
.text:00001523 _text           ends
.text:00001523
.text$x:00001524 ; ===========================================================================
.text$x:00001524
.text$x:00001524 ; Segment type: Pure code
.text$x:00001524 ; Segment permissions: Read/Execute
.text$x:00001524 _text$x         segment para public 'CODE' use32
.text$x:00001524                 assume cs:_text$x
.text$x:00001524                 ;org 1524h
.text$x:00001524 ; COMDAT (pick associative to section at 1484)
.text$x:00001524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001524
.text$x:00001524 ; =============== S U B R O U T I N E =======================================
.text$x:00001524
.text$x:00001524
.text$x:00001524 __unwindfunclet$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z$0 proc near
.text$x:00001524                                         ; DATA XREF: .xdata$x:00001550o
.text$x:00001524                 mov     eax, [ebp-18h]
.text$x:00001527                 push    eax             ; void *
.text$x:00001528                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000152D                 pop     ecx
.text$x:0000152E                 retn
.text$x:0000152E __unwindfunclet$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z$0 endp
.text$x:0000152E
.text$x:0000152F
.text$x:0000152F ; =============== S U B R O U T I N E =======================================
.text$x:0000152F
.text$x:0000152F
.text$x:0000152F __ehhandler$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z proc near
.text$x:0000152F                                         ; DATA XREF: CObjectVector<CArcExtInfo>::Add(CArcExtInfo const &)+5o
.text$x:0000152F
.text$x:0000152F arg_4           = dword ptr  8
.text$x:0000152F
.text$x:0000152F                 mov     edx, [esp+arg_4]
.text$x:00001533                 lea     eax, [edx+0Ch]
.text$x:00001536                 mov     ecx, [edx-14h]
.text$x:00001539                 xor     ecx, eax
.text$x:0000153B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001540                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z
.text$x:00001545                 jmp     ___CxxFrameHandler3
.text$x:00001545 __ehhandler$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z endp
.text$x:00001545
.text$x:00001545 ; ---------------------------------------------------------------------------
.text$x:0000154A                 align 4
.text$x:0000154A _text$x         ends
.text$x:0000154A
.xdata$x:0000154C ; ===========================================================================
.xdata$x:0000154C
.xdata$x:0000154C ; Segment type: Pure data
.xdata$x:0000154C ; Segment permissions: Read
.xdata$x:0000154C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000154C                 assume cs:_xdata$x
.xdata$x:0000154C                 ;org 154Ch
.xdata$x:0000154C ; COMDAT (pick associative to section at 1484)
.xdata$x:0000154C __unwindtable$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z db 0FFh
.xdata$x:0000154C                                         ; DATA XREF: .xdata$x:0000155Co
.xdata$x:0000154D                 db 0FFh
.xdata$x:0000154E                 db 0FFh
.xdata$x:0000154F                 db 0FFh
.xdata$x:00001550                 dd offset __unwindfunclet$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z$0
.xdata$x:00001554 __ehfuncinfo$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z db  22h ; "
.xdata$x:00001554                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z+11o
.xdata$x:00001555                 db    5
.xdata$x:00001556                 db  93h ; ô
.xdata$x:00001557                 db  19h
.xdata$x:00001558                 db    1
.xdata$x:00001559                 db    0
.xdata$x:0000155A                 db    0
.xdata$x:0000155B                 db    0
.xdata$x:0000155C                 dd offset __unwindtable$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z
.xdata$x:00001560                 db    0
.xdata$x:00001561                 db    0
.xdata$x:00001562                 db    0
.xdata$x:00001563                 db    0
.xdata$x:00001564                 db    0
.xdata$x:00001565                 db    0
.xdata$x:00001566                 db    0
.xdata$x:00001567                 db    0
.xdata$x:00001568                 db    0
.xdata$x:00001569                 db    0
.xdata$x:0000156A                 db    0
.xdata$x:0000156B                 db    0
.xdata$x:0000156C                 db    0
.xdata$x:0000156D                 db    0
.xdata$x:0000156E                 db    0
.xdata$x:0000156F                 db    0
.xdata$x:00001570                 db    0
.xdata$x:00001571                 db    0
.xdata$x:00001572                 db    0
.xdata$x:00001573                 db    0
.xdata$x:00001574                 db    1
.xdata$x:00001575                 db    0
.xdata$x:00001576                 db    0
.xdata$x:00001577                 db    0
.xdata$x:00001577 _xdata$x        ends
.xdata$x:00001577
.text:00001578 ; ===========================================================================
.text:00001578
.text:00001578 ; Segment type: Pure code
.text:00001578 ; Segment permissions: Read/Execute
.text:00001578 _text           segment para public 'CODE' use32
.text:00001578                 assume cs:_text
.text:00001578                 ;org 1578h
.text:00001578 ; COMDAT (pick any)
.text:00001578                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001578
.text:00001578 ; =============== S U B R O U T I N E =======================================
.text:00001578
.text:00001578 ; Attributes: bp-based frame
.text:00001578
.text:00001578 ; public: __thiscall CObjectVector<struct CArcExtInfo>::~CObjectVector<struct CArcExtInfo>(void)
.text:00001578                 public ??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ
.text:00001578 ??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ proc near
.text:00001578                                         ; CODE XREF: __unwindfunclet$??0CArcInfoEx@@QAE@XZ$1+6j
.text:00001578                                         ; CArcInfoEx::~CArcInfoEx(void)+49p ...
.text:00001578
.text:00001578 var_20          = dword ptr -20h
.text:00001578 var_1C          = dword ptr -1Ch
.text:00001578 var_18          = dword ptr -18h
.text:00001578 var_14          = dword ptr -14h
.text:00001578 var_10          = dword ptr -10h
.text:00001578 var_C           = dword ptr -0Ch
.text:00001578 var_4           = dword ptr -4
.text:00001578
.text:00001578                 push    ebp
.text:00001579                 mov     ebp, esp
.text:0000157B                 push    0FFFFFFFFh
.text:0000157D                 push    offset __ehhandler$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ
.text:00001582                 mov     eax, large fs:0
.text:00001588                 push    eax
.text:00001589                 sub     esp, 14h
.text:0000158C                 mov     eax, 0CCCCCCCCh
.text:00001591                 mov     [ebp+var_20], eax
.text:00001594                 mov     [ebp+var_1C], eax
.text:00001597                 mov     [ebp+var_18], eax
.text:0000159A                 mov     [ebp+var_14], eax
.text:0000159D                 mov     [ebp+var_10], eax
.text:000015A0                 mov     eax, dword ptr ds:___security_cookie
.text:000015A5                 xor     eax, ebp
.text:000015A7                 push    eax
.text:000015A8                 lea     eax, [ebp+var_C]
.text:000015AB                 mov     large fs:0, eax
.text:000015B1                 mov     [ebp+var_10], ecx
.text:000015B4                 mov     [ebp+var_4], 0
.text:000015BB                 mov     ecx, [ebp+var_10]
.text:000015BE                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000015C3                 mov     [ebp+var_14], eax
.text:000015C6
.text:000015C6 loc_15C6:                               ; CODE XREF: CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void):loc_1608j
.text:000015C6                 cmp     [ebp+var_14], 0
.text:000015CA                 jz      short loc_160A
.text:000015CC                 mov     eax, [ebp+var_14]
.text:000015CF                 sub     eax, 1
.text:000015D2                 mov     [ebp+var_14], eax
.text:000015D5                 mov     ecx, [ebp+var_14]
.text:000015D8                 push    ecx
.text:000015D9                 mov     ecx, [ebp+var_10]
.text:000015DC                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000015E1                 mov     edx, [eax]
.text:000015E3                 mov     [ebp+var_1C], edx
.text:000015E6                 mov     eax, [ebp+var_1C]
.text:000015E9                 mov     [ebp+var_18], eax
.text:000015EC                 cmp     [ebp+var_18], 0
.text:000015F0                 jz      short loc_1601
.text:000015F2                 push    1
.text:000015F4                 mov     ecx, [ebp+var_18]
.text:000015F7                 call    ??_GCArcExtInfo@@QAEPAXI@Z ; CArcExtInfo::`scalar deleting destructor'(uint)
.text:000015FC                 mov     [ebp+var_20], eax
.text:000015FF                 jmp     short loc_1608
.text:00001601 ; ---------------------------------------------------------------------------
.text:00001601
.text:00001601 loc_1601:                               ; CODE XREF: CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)+78j
.text:00001601                 mov     [ebp+var_20], 0
.text:00001608
.text:00001608 loc_1608:                               ; CODE XREF: CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)+87j
.text:00001608                 jmp     short loc_15C6
.text:0000160A ; ---------------------------------------------------------------------------
.text:0000160A
.text:0000160A loc_160A:                               ; CODE XREF: CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)+52j
.text:0000160A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001611                 mov     ecx, [ebp+var_10]
.text:00001614                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00001619                 mov     ecx, [ebp+var_C]
.text:0000161C                 mov     large fs:0, ecx
.text:00001623                 pop     ecx
.text:00001624                 add     esp, 20h
.text:00001627                 cmp     ebp, esp
.text:00001629                 call    __RTC_CheckEsp
.text:0000162E                 mov     esp, ebp
.text:00001630                 pop     ebp
.text:00001631                 retn
.text:00001631 ??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ endp
.text:00001631
.text:00001631 ; ---------------------------------------------------------------------------
.text:00001632                 align 4
.text:00001632 _text           ends
.text:00001632
.text$x:00001634 ; ===========================================================================
.text$x:00001634
.text$x:00001634 ; Segment type: Pure code
.text$x:00001634 ; Segment permissions: Read/Execute
.text$x:00001634 _text$x         segment para public 'CODE' use32
.text$x:00001634                 assume cs:_text$x
.text$x:00001634                 ;org 1634h
.text$x:00001634 ; COMDAT (pick associative to section at 1578)
.text$x:00001634                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001634
.text$x:00001634 ; =============== S U B R O U T I N E =======================================
.text$x:00001634
.text$x:00001634
.text$x:00001634 __unwindfunclet$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ$0 proc near
.text$x:00001634                                         ; DATA XREF: .xdata$x:0000165Co
.text$x:00001634                 mov     ecx, [ebp-10h]
.text$x:00001637                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00001637 __unwindfunclet$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ$0 endp
.text$x:00001637
.text$x:0000163C
.text$x:0000163C ; =============== S U B R O U T I N E =======================================
.text$x:0000163C
.text$x:0000163C
.text$x:0000163C __ehhandler$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ proc near
.text$x:0000163C                                         ; DATA XREF: CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)+5o
.text$x:0000163C
.text$x:0000163C arg_4           = dword ptr  8
.text$x:0000163C
.text$x:0000163C                 mov     edx, [esp+arg_4]
.text$x:00001640                 lea     eax, [edx+0Ch]
.text$x:00001643                 mov     ecx, [edx-18h]
.text$x:00001646                 xor     ecx, eax
.text$x:00001648                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000164D                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ
.text$x:00001652                 jmp     ___CxxFrameHandler3
.text$x:00001652 __ehhandler$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ endp
.text$x:00001652
.text$x:00001652 ; ---------------------------------------------------------------------------
.text$x:00001657                 align 4
.text$x:00001657 _text$x         ends
.text$x:00001657
.xdata$x:00001658 ; ===========================================================================
.xdata$x:00001658
.xdata$x:00001658 ; Segment type: Pure data
.xdata$x:00001658 ; Segment permissions: Read
.xdata$x:00001658 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001658                 assume cs:_xdata$x
.xdata$x:00001658                 ;org 1658h
.xdata$x:00001658 ; COMDAT (pick associative to section at 1578)
.xdata$x:00001658 __unwindtable$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ db 0FFh
.xdata$x:00001658                                         ; DATA XREF: .xdata$x:00001668o
.xdata$x:00001659                 db 0FFh
.xdata$x:0000165A                 db 0FFh
.xdata$x:0000165B                 db 0FFh
.xdata$x:0000165C                 dd offset __unwindfunclet$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ$0
.xdata$x:00001660 __ehfuncinfo$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ db  22h ; "
.xdata$x:00001660                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ+11o
.xdata$x:00001661                 db    5
.xdata$x:00001662                 db  93h ; ô
.xdata$x:00001663                 db  19h
.xdata$x:00001664                 db    1
.xdata$x:00001665                 db    0
.xdata$x:00001666                 db    0
.xdata$x:00001667                 db    0
.xdata$x:00001668                 dd offset __unwindtable$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ
.xdata$x:0000166C                 align 20h
.xdata$x:00001680                 db    1
.xdata$x:00001681                 db    0
.xdata$x:00001682                 db    0
.xdata$x:00001683                 db    0
.xdata$x:00001683 _xdata$x        ends
.xdata$x:00001683
.text:00001684 ; ===========================================================================
.text:00001684
.text:00001684 ; Segment type: Pure code
.text:00001684 ; Segment permissions: Read/Execute
.text:00001684 _text           segment para public 'CODE' use32
.text:00001684                 assume cs:_text
.text:00001684                 ;org 1684h
.text:00001684 ; COMDAT (pick any)
.text:00001684                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001684
.text:00001684 ; =============== S U B R O U T I N E =======================================
.text:00001684
.text:00001684 ; Attributes: bp-based frame
.text:00001684
.text:00001684 ; public: __thiscall CObjectVector<class CBuffer<unsigned char>>::CObjectVector<class CBuffer<unsigned char>>(void)
.text:00001684                 public ??0?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text:00001684 ??0?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ proc near
.text:00001684                                         ; CODE XREF: CArcInfoEx::CArcInfoEx(void)+93p
.text:00001684
.text:00001684 var_4           = dword ptr -4
.text:00001684
.text:00001684                 push    ebp
.text:00001685                 mov     ebp, esp
.text:00001687                 push    ecx
.text:00001688                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000168F                 mov     [ebp+var_4], ecx
.text:00001692                 mov     ecx, [ebp+var_4]
.text:00001695                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000169A                 mov     eax, [ebp+var_4]
.text:0000169D                 add     esp, 4
.text:000016A0                 cmp     ebp, esp
.text:000016A2                 call    __RTC_CheckEsp
.text:000016A7                 mov     esp, ebp
.text:000016A9                 pop     ebp
.text:000016AA                 retn
.text:000016AA ??0?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ endp
.text:000016AA
.text:000016AA ; ---------------------------------------------------------------------------
.text:000016AB                 align 4
.text:000016AB _text           ends
.text:000016AB
.text:000016AC ; ===========================================================================
.text:000016AC
.text:000016AC ; Segment type: Pure code
.text:000016AC ; Segment permissions: Read/Execute
.text:000016AC _text           segment para public 'CODE' use32
.text:000016AC                 assume cs:_text
.text:000016AC                 ;org 16ACh
.text:000016AC ; COMDAT (pick any)
.text:000016AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000016AC
.text:000016AC ; =============== S U B R O U T I N E =======================================
.text:000016AC
.text:000016AC ; Attributes: bp-based frame
.text:000016AC
.text:000016AC ; public: class CBuffer<unsigned char> & __thiscall CObjectVector<class CBuffer<unsigned char>>::AddNew(void)
.text:000016AC                 public ?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ
.text:000016AC ?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ proc near
.text:000016AC                                         ; CODE XREF: CCodecs::Load(void)+180p
.text:000016AC                                         ; ParseSignatures(uchar const *,uint,CObjectVector<CBuffer<uchar>> &)+4Bp
.text:000016AC
.text:000016AC var_20          = dword ptr -20h
.text:000016AC var_1C          = dword ptr -1Ch
.text:000016AC var_18          = dword ptr -18h
.text:000016AC var_14          = dword ptr -14h
.text:000016AC var_10          = dword ptr -10h
.text:000016AC var_C           = dword ptr -0Ch
.text:000016AC var_4           = dword ptr -4
.text:000016AC
.text:000016AC                 push    ebp
.text:000016AD                 mov     ebp, esp
.text:000016AF                 push    0FFFFFFFFh
.text:000016B1                 push    offset __ehhandler$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ
.text:000016B6                 mov     eax, large fs:0
.text:000016BC                 push    eax
.text:000016BD                 sub     esp, 14h
.text:000016C0                 mov     eax, 0CCCCCCCCh
.text:000016C5                 mov     [ebp+var_20], eax
.text:000016C8                 mov     [ebp+var_1C], eax
.text:000016CB                 mov     [ebp+var_18], eax
.text:000016CE                 mov     [ebp+var_14], eax
.text:000016D1                 mov     [ebp+var_10], eax
.text:000016D4                 mov     eax, dword ptr ds:___security_cookie
.text:000016D9                 xor     eax, ebp
.text:000016DB                 push    eax
.text:000016DC                 lea     eax, [ebp+var_C]
.text:000016DF                 mov     large fs:0, eax
.text:000016E5                 mov     [ebp+var_10], ecx
.text:000016E8                 push    8               ; unsigned int
.text:000016EA                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000016EF                 add     esp, 4
.text:000016F2                 mov     [ebp+var_1C], eax
.text:000016F5                 mov     [ebp+var_4], 0
.text:000016FC                 cmp     [ebp+var_1C], 0
.text:00001700                 jz      short loc_170F
.text:00001702                 mov     ecx, [ebp+var_1C]
.text:00001705                 call    ??0?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::CBuffer<uchar>(void)
.text:0000170A                 mov     [ebp+var_20], eax
.text:0000170D                 jmp     short loc_1716
.text:0000170F ; ---------------------------------------------------------------------------
.text:0000170F
.text:0000170F loc_170F:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::AddNew(void)+54j
.text:0000170F                 mov     [ebp+var_20], 0
.text:00001716
.text:00001716 loc_1716:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::AddNew(void)+61j
.text:00001716                 mov     eax, [ebp+var_20]
.text:00001719                 mov     [ebp+var_18], eax
.text:0000171C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001723                 mov     ecx, [ebp+var_18]
.text:00001726                 mov     [ebp+var_14], ecx
.text:00001729                 mov     edx, [ebp+var_14]
.text:0000172C                 push    edx
.text:0000172D                 mov     ecx, [ebp+var_10]
.text:00001730                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00001735                 mov     eax, [ebp+var_14]
.text:00001738                 mov     ecx, [ebp+var_C]
.text:0000173B                 mov     large fs:0, ecx
.text:00001742                 pop     ecx
.text:00001743                 add     esp, 20h
.text:00001746                 cmp     ebp, esp
.text:00001748                 call    __RTC_CheckEsp
.text:0000174D                 mov     esp, ebp
.text:0000174F                 pop     ebp
.text:00001750                 retn
.text:00001750 ?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ endp
.text:00001750
.text:00001750 ; ---------------------------------------------------------------------------
.text:00001751                 align 4
.text:00001751 _text           ends
.text:00001751
.text$x:00001754 ; ===========================================================================
.text$x:00001754
.text$x:00001754 ; Segment type: Pure code
.text$x:00001754 ; Segment permissions: Read/Execute
.text$x:00001754 _text$x         segment para public 'CODE' use32
.text$x:00001754                 assume cs:_text$x
.text$x:00001754                 ;org 1754h
.text$x:00001754 ; COMDAT (pick associative to section at 16AC)
.text$x:00001754                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001754
.text$x:00001754 ; =============== S U B R O U T I N E =======================================
.text$x:00001754
.text$x:00001754
.text$x:00001754 __unwindfunclet$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ$0 proc near
.text$x:00001754                                         ; DATA XREF: .xdata$x:00001780o
.text$x:00001754                 mov     eax, [ebp-1Ch]
.text$x:00001757                 push    eax             ; void *
.text$x:00001758                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000175D                 pop     ecx
.text$x:0000175E                 retn
.text$x:0000175E __unwindfunclet$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ$0 endp
.text$x:0000175E
.text$x:0000175F
.text$x:0000175F ; =============== S U B R O U T I N E =======================================
.text$x:0000175F
.text$x:0000175F
.text$x:0000175F __ehhandler$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ proc near
.text$x:0000175F                                         ; DATA XREF: CObjectVector<CBuffer<uchar>>::AddNew(void)+5o
.text$x:0000175F
.text$x:0000175F arg_4           = dword ptr  8
.text$x:0000175F
.text$x:0000175F                 mov     edx, [esp+arg_4]
.text$x:00001763                 lea     eax, [edx+0Ch]
.text$x:00001766                 mov     ecx, [edx-18h]
.text$x:00001769                 xor     ecx, eax
.text$x:0000176B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001770                 mov     eax, offset __ehfuncinfo$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ
.text$x:00001775                 jmp     ___CxxFrameHandler3
.text$x:00001775 __ehhandler$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ endp
.text$x:00001775
.text$x:00001775 ; ---------------------------------------------------------------------------
.text$x:0000177A                 align 4
.text$x:0000177A _text$x         ends
.text$x:0000177A
.xdata$x:0000177C ; ===========================================================================
.xdata$x:0000177C
.xdata$x:0000177C ; Segment type: Pure data
.xdata$x:0000177C ; Segment permissions: Read
.xdata$x:0000177C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000177C                 assume cs:_xdata$x
.xdata$x:0000177C                 ;org 177Ch
.xdata$x:0000177C ; COMDAT (pick associative to section at 16AC)
.xdata$x:0000177C __unwindtable$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ db 0FFh
.xdata$x:0000177C                                         ; DATA XREF: .xdata$x:0000178Co
.xdata$x:0000177D                 db 0FFh
.xdata$x:0000177E                 db 0FFh
.xdata$x:0000177F                 db 0FFh
.xdata$x:00001780                 dd offset __unwindfunclet$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ$0
.xdata$x:00001784 __ehfuncinfo$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ db  22h ; "
.xdata$x:00001784                                         ; DATA XREF: __ehhandler$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ+11o
.xdata$x:00001785                 db    5
.xdata$x:00001786                 db  93h ; ô
.xdata$x:00001787                 db  19h
.xdata$x:00001788                 db    1
.xdata$x:00001789                 db    0
.xdata$x:0000178A                 db    0
.xdata$x:0000178B                 db    0
.xdata$x:0000178C                 dd offset __unwindtable$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ
.xdata$x:00001790                 db    0
.xdata$x:00001791                 db    0
.xdata$x:00001792                 db    0
.xdata$x:00001793                 db    0
.xdata$x:00001794                 db    0
.xdata$x:00001795                 db    0
.xdata$x:00001796                 db    0
.xdata$x:00001797                 db    0
.xdata$x:00001798                 db    0
.xdata$x:00001799                 db    0
.xdata$x:0000179A                 db    0
.xdata$x:0000179B                 db    0
.xdata$x:0000179C                 db    0
.xdata$x:0000179D                 db    0
.xdata$x:0000179E                 db    0
.xdata$x:0000179F                 db    0
.xdata$x:000017A0                 db    0
.xdata$x:000017A1                 db    0
.xdata$x:000017A2                 db    0
.xdata$x:000017A3                 db    0
.xdata$x:000017A4                 db    1
.xdata$x:000017A5                 db    0
.xdata$x:000017A6                 db    0
.xdata$x:000017A7                 db    0
.xdata$x:000017A7 _xdata$x        ends
.xdata$x:000017A7
.text:000017A8 ; ===========================================================================
.text:000017A8
.text:000017A8 ; Segment type: Pure code
.text:000017A8 ; Segment permissions: Read/Execute
.text:000017A8 _text           segment para public 'CODE' use32
.text:000017A8                 assume cs:_text
.text:000017A8                 ;org 17A8h
.text:000017A8 ; COMDAT (pick any)
.text:000017A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000017A8
.text:000017A8 ; =============== S U B R O U T I N E =======================================
.text:000017A8
.text:000017A8 ; Attributes: bp-based frame
.text:000017A8
.text:000017A8 ; public: __thiscall CObjectVector<class CBuffer<unsigned char>>::~CObjectVector<class CBuffer<unsigned char>>(void)
.text:000017A8                 public ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text:000017A8 ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ proc near
.text:000017A8                                         ; CODE XREF: CArcInfoEx::~CArcInfoEx(void)+3Ap
.text:000017A8
.text:000017A8 var_20          = dword ptr -20h
.text:000017A8 var_1C          = dword ptr -1Ch
.text:000017A8 var_18          = dword ptr -18h
.text:000017A8 var_14          = dword ptr -14h
.text:000017A8 var_10          = dword ptr -10h
.text:000017A8 var_C           = dword ptr -0Ch
.text:000017A8 var_4           = dword ptr -4
.text:000017A8
.text:000017A8                 push    ebp
.text:000017A9                 mov     ebp, esp
.text:000017AB                 push    0FFFFFFFFh
.text:000017AD                 push    offset __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text:000017B2                 mov     eax, large fs:0
.text:000017B8                 push    eax
.text:000017B9                 sub     esp, 14h
.text:000017BC                 mov     eax, 0CCCCCCCCh
.text:000017C1                 mov     [ebp+var_20], eax
.text:000017C4                 mov     [ebp+var_1C], eax
.text:000017C7                 mov     [ebp+var_18], eax
.text:000017CA                 mov     [ebp+var_14], eax
.text:000017CD                 mov     [ebp+var_10], eax
.text:000017D0                 mov     eax, dword ptr ds:___security_cookie
.text:000017D5                 xor     eax, ebp
.text:000017D7                 push    eax
.text:000017D8                 lea     eax, [ebp+var_C]
.text:000017DB                 mov     large fs:0, eax
.text:000017E1                 mov     [ebp+var_10], ecx
.text:000017E4                 mov     [ebp+var_4], 0
.text:000017EB                 mov     ecx, [ebp+var_10]
.text:000017EE                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000017F3                 mov     [ebp+var_14], eax
.text:000017F6
.text:000017F6 loc_17F6:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void):loc_1838j
.text:000017F6                 cmp     [ebp+var_14], 0
.text:000017FA                 jz      short loc_183A
.text:000017FC                 mov     eax, [ebp+var_14]
.text:000017FF                 sub     eax, 1
.text:00001802                 mov     [ebp+var_14], eax
.text:00001805                 mov     ecx, [ebp+var_14]
.text:00001808                 push    ecx
.text:00001809                 mov     ecx, [ebp+var_10]
.text:0000180C                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00001811                 mov     edx, [eax]
.text:00001813                 mov     [ebp+var_1C], edx
.text:00001816                 mov     eax, [ebp+var_1C]
.text:00001819                 mov     [ebp+var_18], eax
.text:0000181C                 cmp     [ebp+var_18], 0
.text:00001820                 jz      short loc_1831
.text:00001822                 push    1
.text:00001824                 mov     ecx, [ebp+var_18]
.text:00001827                 call    ??_G?$CBuffer@E@@QAEPAXI@Z ; CBuffer<uchar>::`scalar deleting destructor'(uint)
.text:0000182C                 mov     [ebp+var_20], eax
.text:0000182F                 jmp     short loc_1838
.text:00001831 ; ---------------------------------------------------------------------------
.text:00001831
.text:00001831 loc_1831:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+78j
.text:00001831                 mov     [ebp+var_20], 0
.text:00001838
.text:00001838 loc_1838:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+87j
.text:00001838                 jmp     short loc_17F6
.text:0000183A ; ---------------------------------------------------------------------------
.text:0000183A
.text:0000183A loc_183A:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+52j
.text:0000183A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001841                 mov     ecx, [ebp+var_10]
.text:00001844                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00001849                 mov     ecx, [ebp+var_C]
.text:0000184C                 mov     large fs:0, ecx
.text:00001853                 pop     ecx
.text:00001854                 add     esp, 20h
.text:00001857                 cmp     ebp, esp
.text:00001859                 call    __RTC_CheckEsp
.text:0000185E                 mov     esp, ebp
.text:00001860                 pop     ebp
.text:00001861                 retn
.text:00001861 ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ endp
.text:00001861
.text:00001861 ; ---------------------------------------------------------------------------
.text:00001862                 align 4
.text:00001862 _text           ends
.text:00001862
.text$x:00001864 ; ===========================================================================
.text$x:00001864
.text$x:00001864 ; Segment type: Pure code
.text$x:00001864 ; Segment permissions: Read/Execute
.text$x:00001864 _text$x         segment para public 'CODE' use32
.text$x:00001864                 assume cs:_text$x
.text$x:00001864                 ;org 1864h
.text$x:00001864 ; COMDAT (pick associative to section at 17A8)
.text$x:00001864                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001864
.text$x:00001864 ; =============== S U B R O U T I N E =======================================
.text$x:00001864
.text$x:00001864
.text$x:00001864 __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0 proc near
.text$x:00001864                                         ; DATA XREF: .xdata$x:0000188Co
.text$x:00001864                 mov     ecx, [ebp-10h]
.text$x:00001867                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00001867 __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0 endp
.text$x:00001867
.text$x:0000186C
.text$x:0000186C ; =============== S U B R O U T I N E =======================================
.text$x:0000186C
.text$x:0000186C
.text$x:0000186C __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ proc near
.text$x:0000186C                                         ; DATA XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+5o
.text$x:0000186C
.text$x:0000186C arg_4           = dword ptr  8
.text$x:0000186C
.text$x:0000186C                 mov     edx, [esp+arg_4]
.text$x:00001870                 lea     eax, [edx+0Ch]
.text$x:00001873                 mov     ecx, [edx-18h]
.text$x:00001876                 xor     ecx, eax
.text$x:00001878                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000187D                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text$x:00001882                 jmp     ___CxxFrameHandler3
.text$x:00001882 __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ endp
.text$x:00001882
.text$x:00001882 ; ---------------------------------------------------------------------------
.text$x:00001887                 align 4
.text$x:00001887 _text$x         ends
.text$x:00001887
.xdata$x:00001888 ; ===========================================================================
.xdata$x:00001888
.xdata$x:00001888 ; Segment type: Pure data
.xdata$x:00001888 ; Segment permissions: Read
.xdata$x:00001888 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001888                 assume cs:_xdata$x
.xdata$x:00001888                 ;org 1888h
.xdata$x:00001888 ; COMDAT (pick associative to section at 17A8)
.xdata$x:00001888 __unwindtable$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ db 0FFh
.xdata$x:00001888                                         ; DATA XREF: .xdata$x:00001898o
.xdata$x:00001889                 db 0FFh
.xdata$x:0000188A                 db 0FFh
.xdata$x:0000188B                 db 0FFh
.xdata$x:0000188C                 dd offset __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0
.xdata$x:00001890 __ehfuncinfo$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ db  22h ; "
.xdata$x:00001890                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ+11o
.xdata$x:00001891                 db    5
.xdata$x:00001892                 db  93h ; ô
.xdata$x:00001893                 db  19h
.xdata$x:00001894                 db    1
.xdata$x:00001895                 db    0
.xdata$x:00001896                 db    0
.xdata$x:00001897                 db    0
.xdata$x:00001898                 dd offset __unwindtable$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.xdata$x:0000189C                 db    0
.xdata$x:0000189D                 db    0
.xdata$x:0000189E                 db    0
.xdata$x:0000189F                 db    0
.xdata$x:000018A0                 db    0
.xdata$x:000018A1                 db    0
.xdata$x:000018A2                 db    0
.xdata$x:000018A3                 db    0
.xdata$x:000018A4                 db    0
.xdata$x:000018A5                 db    0
.xdata$x:000018A6                 db    0
.xdata$x:000018A7                 db    0
.xdata$x:000018A8                 db    0
.xdata$x:000018A9                 db    0
.xdata$x:000018AA                 db    0
.xdata$x:000018AB                 db    0
.xdata$x:000018AC                 db    0
.xdata$x:000018AD                 db    0
.xdata$x:000018AE                 db    0
.xdata$x:000018AF                 db    0
.xdata$x:000018B0                 db    1
.xdata$x:000018B1                 db    0
.xdata$x:000018B2                 db    0
.xdata$x:000018B3                 db    0
.xdata$x:000018B3 _xdata$x        ends
.xdata$x:000018B3
.text:000018B4 ; ===========================================================================
.text:000018B4
.text:000018B4 ; Segment type: Pure code
.text:000018B4 ; Segment permissions: Read/Execute
.text:000018B4 _text           segment para public 'CODE' use32
.text:000018B4                 assume cs:_text
.text:000018B4                 ;org 18B4h
.text:000018B4 ; COMDAT (pick any)
.text:000018B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000018B4
.text:000018B4 ; =============== S U B R O U T I N E =======================================
.text:000018B4
.text:000018B4 ; Attributes: bp-based frame
.text:000018B4
.text:000018B4 ; public: void __thiscall CObjectVector<class CBuffer<unsigned char>>::Clear(void)
.text:000018B4                 public ?Clear@?$CObjectVector@V?$CBuffer@E@@@@QAEXXZ
.text:000018B4 ?Clear@?$CObjectVector@V?$CBuffer@E@@@@QAEXXZ proc near
.text:000018B4                                         ; CODE XREF: ParseSignatures(uchar const *,uint,CObjectVector<CBuffer<uchar>> &)+Ep
.text:000018B4
.text:000018B4 var_14          = dword ptr -14h
.text:000018B4 var_10          = dword ptr -10h
.text:000018B4 var_C           = dword ptr -0Ch
.text:000018B4 var_8           = dword ptr -8
.text:000018B4 var_4           = dword ptr -4
.text:000018B4
.text:000018B4                 push    ebp
.text:000018B5                 mov     ebp, esp
.text:000018B7                 sub     esp, 14h
.text:000018BA                 mov     eax, 0CCCCCCCCh
.text:000018BF                 mov     [ebp+var_14], eax
.text:000018C2                 mov     [ebp+var_10], eax
.text:000018C5                 mov     [ebp+var_C], eax
.text:000018C8                 mov     [ebp+var_8], eax
.text:000018CB                 mov     [ebp+var_4], eax
.text:000018CE                 mov     [ebp+var_4], ecx
.text:000018D1                 mov     ecx, [ebp+var_4]
.text:000018D4                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000018D9                 mov     [ebp+var_8], eax
.text:000018DC
.text:000018DC loc_18DC:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::Clear(void):loc_191Ej
.text:000018DC                 cmp     [ebp+var_8], 0
.text:000018E0                 jz      short loc_1920
.text:000018E2                 mov     eax, [ebp+var_8]
.text:000018E5                 sub     eax, 1
.text:000018E8                 mov     [ebp+var_8], eax
.text:000018EB                 mov     ecx, [ebp+var_8]
.text:000018EE                 push    ecx
.text:000018EF                 mov     ecx, [ebp+var_4]
.text:000018F2                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000018F7                 mov     edx, [eax]
.text:000018F9                 mov     [ebp+var_10], edx
.text:000018FC                 mov     eax, [ebp+var_10]
.text:000018FF                 mov     [ebp+var_C], eax
.text:00001902                 cmp     [ebp+var_C], 0
.text:00001906                 jz      short loc_1917
.text:00001908                 push    1
.text:0000190A                 mov     ecx, [ebp+var_C]
.text:0000190D                 call    ??_G?$CBuffer@E@@QAEPAXI@Z ; CBuffer<uchar>::`scalar deleting destructor'(uint)
.text:00001912                 mov     [ebp+var_14], eax
.text:00001915                 jmp     short loc_191E
.text:00001917 ; ---------------------------------------------------------------------------
.text:00001917
.text:00001917 loc_1917:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::Clear(void)+52j
.text:00001917                 mov     [ebp+var_14], 0
.text:0000191E
.text:0000191E loc_191E:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::Clear(void)+61j
.text:0000191E                 jmp     short loc_18DC
.text:00001920 ; ---------------------------------------------------------------------------
.text:00001920
.text:00001920 loc_1920:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::Clear(void)+2Cj
.text:00001920                 mov     ecx, [ebp+var_4]
.text:00001923                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00001928                 add     esp, 14h
.text:0000192B                 cmp     ebp, esp
.text:0000192D                 call    __RTC_CheckEsp
.text:00001932                 mov     esp, ebp
.text:00001934                 pop     ebp
.text:00001935                 retn
.text:00001935 ?Clear@?$CObjectVector@V?$CBuffer@E@@@@QAEXXZ endp
.text:00001935
.text:00001935 ; ---------------------------------------------------------------------------
.text:00001936                 align 4
.text:00001936 _text           ends
.text:00001936
.text:00001938 ; ===========================================================================
.text:00001938
.text:00001938 ; Segment type: Pure code
.text:00001938 ; Segment permissions: Read/Execute
.text:00001938 _text           segment para public 'CODE' use32
.text:00001938                 assume cs:_text
.text:00001938                 ;org 1938h
.text:00001938 ; COMDAT (pick any)
.text:00001938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001938
.text:00001938 ; =============== S U B R O U T I N E =======================================
.text:00001938
.text:00001938 ; Attributes: bp-based frame
.text:00001938
.text:00001938 ; public: unsigned int __thiscall CObjectVector<struct CArcInfoEx>::Size(void)const
.text:00001938                 public ?Size@?$CObjectVector@UCArcInfoEx@@@@QBEIXZ
.text:00001938 ?Size@?$CObjectVector@UCArcInfoEx@@@@QBEIXZ proc near
.text:00001938                                         ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+EDp
.text:00001938                                         ; CCodecs::FindFormatForExtension(UString const &)+43p ...
.text:00001938
.text:00001938 var_4           = dword ptr -4
.text:00001938
.text:00001938                 push    ebp
.text:00001939                 mov     ebp, esp
.text:0000193B                 push    ecx
.text:0000193C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001943                 mov     [ebp+var_4], ecx
.text:00001946                 mov     ecx, [ebp+var_4]
.text:00001949                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000194E                 add     esp, 4
.text:00001951                 cmp     ebp, esp
.text:00001953                 call    __RTC_CheckEsp
.text:00001958                 mov     esp, ebp
.text:0000195A                 pop     ebp
.text:0000195B                 retn
.text:0000195B ?Size@?$CObjectVector@UCArcInfoEx@@@@QBEIXZ endp
.text:0000195B
.text:0000195B _text           ends
.text:0000195B
.text:0000195C ; ===========================================================================
.text:0000195C
.text:0000195C ; Segment type: Pure code
.text:0000195C ; Segment permissions: Read/Execute
.text:0000195C _text           segment para public 'CODE' use32
.text:0000195C                 assume cs:_text
.text:0000195C                 ;org 195Ch
.text:0000195C ; COMDAT (pick any)
.text:0000195C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000195C
.text:0000195C ; =============== S U B R O U T I N E =======================================
.text:0000195C
.text:0000195C ; Attributes: bp-based frame
.text:0000195C
.text:0000195C ; public: struct CArcInfoEx const & __thiscall CObjectVector<struct CArcInfoEx>::operator[](unsigned int)const
.text:0000195C                 public ??A?$CObjectVector@UCArcInfoEx@@@@QBEABUCArcInfoEx@@I@Z
.text:0000195C ??A?$CObjectVector@UCArcInfoEx@@@@QBEABUCArcInfoEx@@I@Z proc near
.text:0000195C                                         ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+101p
.text:0000195C                                         ; CCodecs::FindFormatForExtension(UString const &)+5Bp ...
.text:0000195C
.text:0000195C var_4           = dword ptr -4
.text:0000195C arg_0           = dword ptr  8
.text:0000195C
.text:0000195C                 push    ebp
.text:0000195D                 mov     ebp, esp
.text:0000195F                 push    ecx
.text:00001960                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001967                 mov     [ebp+var_4], ecx
.text:0000196A                 mov     eax, [ebp+arg_0]
.text:0000196D                 push    eax
.text:0000196E                 mov     ecx, [ebp+var_4]
.text:00001971                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00001976                 mov     eax, [eax]
.text:00001978                 add     esp, 4
.text:0000197B                 cmp     ebp, esp
.text:0000197D                 call    __RTC_CheckEsp
.text:00001982                 mov     esp, ebp
.text:00001984                 pop     ebp
.text:00001985                 retn    4
.text:00001985 ??A?$CObjectVector@UCArcInfoEx@@@@QBEABUCArcInfoEx@@I@Z endp
.text:00001985
.text:00001985 _text           ends
.text:00001985
.text:00001988 ; ===========================================================================
.text:00001988
.text:00001988 ; Segment type: Pure code
.text:00001988 ; Segment permissions: Read/Execute
.text:00001988 _text           segment para public 'CODE' use32
.text:00001988                 assume cs:_text
.text:00001988                 ;org 1988h
.text:00001988 ; COMDAT (pick any)
.text:00001988                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001988
.text:00001988 ; =============== S U B R O U T I N E =======================================
.text:00001988
.text:00001988 ; Attributes: bp-based frame
.text:00001988
.text:00001988 ; public: unsigned int __thiscall CObjectVector<struct CArcInfoEx>::Add(struct CArcInfoEx const &)
.text:00001988                 public ?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z
.text:00001988 ?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z proc near
.text:00001988                                         ; CODE XREF: CCodecs::Load(void)+196p
.text:00001988
.text:00001988 var_1C          = dword ptr -1Ch
.text:00001988 var_18          = dword ptr -18h
.text:00001988 var_14          = dword ptr -14h
.text:00001988 var_10          = dword ptr -10h
.text:00001988 var_C           = dword ptr -0Ch
.text:00001988 var_4           = dword ptr -4
.text:00001988 arg_0           = dword ptr  8
.text:00001988
.text:00001988                 push    ebp
.text:00001989                 mov     ebp, esp
.text:0000198B                 push    0FFFFFFFFh
.text:0000198D                 push    offset __ehhandler$?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z
.text:00001992                 mov     eax, large fs:0
.text:00001998                 push    eax
.text:00001999                 sub     esp, 10h
.text:0000199C                 mov     eax, 0CCCCCCCCh
.text:000019A1                 mov     [ebp+var_1C], eax
.text:000019A4                 mov     [ebp+var_18], eax
.text:000019A7                 mov     [ebp+var_14], eax
.text:000019AA                 mov     [ebp+var_10], eax
.text:000019AD                 mov     eax, dword ptr ds:___security_cookie
.text:000019B2                 xor     eax, ebp
.text:000019B4                 push    eax
.text:000019B5                 lea     eax, [ebp+var_C]
.text:000019B8                 mov     large fs:0, eax
.text:000019BE                 mov     [ebp+var_10], ecx
.text:000019C1                 push    3Ch ; '<'       ; unsigned int
.text:000019C3                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000019C8                 add     esp, 4
.text:000019CB                 mov     [ebp+var_18], eax
.text:000019CE                 mov     [ebp+var_4], 0
.text:000019D5                 cmp     [ebp+var_18], 0
.text:000019D9                 jz      short loc_19EC
.text:000019DB                 mov     eax, [ebp+arg_0]
.text:000019DE                 push    eax
.text:000019DF                 mov     ecx, [ebp+var_18]
.text:000019E2                 call    ??0CArcInfoEx@@QAE@ABU0@@Z ; CArcInfoEx::CArcInfoEx(CArcInfoEx const &)
.text:000019E7                 mov     [ebp+var_1C], eax
.text:000019EA                 jmp     short loc_19F3
.text:000019EC ; ---------------------------------------------------------------------------
.text:000019EC
.text:000019EC loc_19EC:                               ; CODE XREF: CObjectVector<CArcInfoEx>::Add(CArcInfoEx const &)+51j
.text:000019EC                 mov     [ebp+var_1C], 0
.text:000019F3
.text:000019F3 loc_19F3:                               ; CODE XREF: CObjectVector<CArcInfoEx>::Add(CArcInfoEx const &)+62j
.text:000019F3                 mov     ecx, [ebp+var_1C]
.text:000019F6                 mov     [ebp+var_14], ecx
.text:000019F9                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001A00                 mov     edx, [ebp+var_14]
.text:00001A03                 push    edx
.text:00001A04                 mov     ecx, [ebp+var_10]
.text:00001A07                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00001A0C                 mov     ecx, [ebp+var_C]
.text:00001A0F                 mov     large fs:0, ecx
.text:00001A16                 pop     ecx
.text:00001A17                 add     esp, 1Ch
.text:00001A1A                 cmp     ebp, esp
.text:00001A1C                 call    __RTC_CheckEsp
.text:00001A21                 mov     esp, ebp
.text:00001A23                 pop     ebp
.text:00001A24                 retn    4
.text:00001A24 ?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z endp
.text:00001A24
.text:00001A24 ; ---------------------------------------------------------------------------
.text:00001A27                 align 4
.text:00001A27 _text           ends
.text:00001A27
.text$x:00001A28 ; ===========================================================================
.text$x:00001A28
.text$x:00001A28 ; Segment type: Pure code
.text$x:00001A28 ; Segment permissions: Read/Execute
.text$x:00001A28 _text$x         segment para public 'CODE' use32
.text$x:00001A28                 assume cs:_text$x
.text$x:00001A28                 ;org 1A28h
.text$x:00001A28 ; COMDAT (pick associative to section at 1988)
.text$x:00001A28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A28
.text$x:00001A28 ; =============== S U B R O U T I N E =======================================
.text$x:00001A28
.text$x:00001A28
.text$x:00001A28 __unwindfunclet$?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z$0 proc near
.text$x:00001A28                                         ; DATA XREF: .xdata$x:00001A54o
.text$x:00001A28                 mov     eax, [ebp-18h]
.text$x:00001A2B                 push    eax             ; void *
.text$x:00001A2C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001A31                 pop     ecx
.text$x:00001A32                 retn
.text$x:00001A32 __unwindfunclet$?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z$0 endp
.text$x:00001A32
.text$x:00001A33
.text$x:00001A33 ; =============== S U B R O U T I N E =======================================
.text$x:00001A33
.text$x:00001A33
.text$x:00001A33 __ehhandler$?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z proc near
.text$x:00001A33                                         ; DATA XREF: CObjectVector<CArcInfoEx>::Add(CArcInfoEx const &)+5o
.text$x:00001A33
.text$x:00001A33 arg_4           = dword ptr  8
.text$x:00001A33
.text$x:00001A33                 mov     edx, [esp+arg_4]
.text$x:00001A37                 lea     eax, [edx+0Ch]
.text$x:00001A3A                 mov     ecx, [edx-14h]
.text$x:00001A3D                 xor     ecx, eax
.text$x:00001A3F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A44                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z
.text$x:00001A49                 jmp     ___CxxFrameHandler3
.text$x:00001A49 __ehhandler$?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z endp
.text$x:00001A49
.text$x:00001A49 ; ---------------------------------------------------------------------------
.text$x:00001A4E                 align 10h
.text$x:00001A4E _text$x         ends
.text$x:00001A4E
.xdata$x:00001A50 ; ===========================================================================
.xdata$x:00001A50
.xdata$x:00001A50 ; Segment type: Pure data
.xdata$x:00001A50 ; Segment permissions: Read
.xdata$x:00001A50 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001A50                 assume cs:_xdata$x
.xdata$x:00001A50                 ;org 1A50h
.xdata$x:00001A50 ; COMDAT (pick associative to section at 1988)
.xdata$x:00001A50 __unwindtable$?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z db 0FFh
.xdata$x:00001A50                                         ; DATA XREF: .xdata$x:00001A60o
.xdata$x:00001A51                 db 0FFh
.xdata$x:00001A52                 db 0FFh
.xdata$x:00001A53                 db 0FFh
.xdata$x:00001A54                 dd offset __unwindfunclet$?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z$0
.xdata$x:00001A58 __ehfuncinfo$?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z db  22h ; "
.xdata$x:00001A58                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z+11o
.xdata$x:00001A59                 db    5
.xdata$x:00001A5A                 db  93h ; ô
.xdata$x:00001A5B                 db  19h
.xdata$x:00001A5C                 db    1
.xdata$x:00001A5D                 db    0
.xdata$x:00001A5E                 db    0
.xdata$x:00001A5F                 db    0
.xdata$x:00001A60                 dd offset __unwindtable$?Add@?$CObjectVector@UCArcInfoEx@@@@QAEIABUCArcInfoEx@@@Z
.xdata$x:00001A64                 db    0
.xdata$x:00001A65                 db    0
.xdata$x:00001A66                 db    0
.xdata$x:00001A67                 db    0
.xdata$x:00001A68                 db    0
.xdata$x:00001A69                 db    0
.xdata$x:00001A6A                 db    0
.xdata$x:00001A6B                 db    0
.xdata$x:00001A6C                 db    0
.xdata$x:00001A6D                 db    0
.xdata$x:00001A6E                 db    0
.xdata$x:00001A6F                 db    0
.xdata$x:00001A70                 db    0
.xdata$x:00001A71                 db    0
.xdata$x:00001A72                 db    0
.xdata$x:00001A73                 db    0
.xdata$x:00001A74                 db    0
.xdata$x:00001A75                 db    0
.xdata$x:00001A76                 db    0
.xdata$x:00001A77                 db    0
.xdata$x:00001A78                 db    1
.xdata$x:00001A79                 db    0
.xdata$x:00001A7A                 db    0
.xdata$x:00001A7B                 db    0
.xdata$x:00001A7B _xdata$x        ends
.xdata$x:00001A7B
.text:00001A7C ; ===========================================================================
.text:00001A7C
.text:00001A7C ; Segment type: Pure code
.text:00001A7C ; Segment permissions: Read/Execute
.text:00001A7C _text           segment para public 'CODE' use32
.text:00001A7C                 assume cs:_text
.text:00001A7C                 ;org 1A7Ch
.text:00001A7C ; COMDAT (pick any)
.text:00001A7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001A7C
.text:00001A7C ; =============== S U B R O U T I N E =======================================
.text:00001A7C
.text:00001A7C ; Attributes: bp-based frame
.text:00001A7C
.text:00001A7C ; public: void __thiscall CObjectVector<struct CArcInfoEx>::Clear(void)
.text:00001A7C                 public ?Clear@?$CObjectVector@UCArcInfoEx@@@@QAEXXZ
.text:00001A7C ?Clear@?$CObjectVector@UCArcInfoEx@@@@QAEXXZ proc near
.text:00001A7C                                         ; CODE XREF: CCodecs::Load(void)+43p
.text:00001A7C
.text:00001A7C var_14          = dword ptr -14h
.text:00001A7C var_10          = dword ptr -10h
.text:00001A7C var_C           = dword ptr -0Ch
.text:00001A7C var_8           = dword ptr -8
.text:00001A7C var_4           = dword ptr -4
.text:00001A7C
.text:00001A7C                 push    ebp
.text:00001A7D                 mov     ebp, esp
.text:00001A7F                 sub     esp, 14h
.text:00001A82                 mov     eax, 0CCCCCCCCh
.text:00001A87                 mov     [ebp+var_14], eax
.text:00001A8A                 mov     [ebp+var_10], eax
.text:00001A8D                 mov     [ebp+var_C], eax
.text:00001A90                 mov     [ebp+var_8], eax
.text:00001A93                 mov     [ebp+var_4], eax
.text:00001A96                 mov     [ebp+var_4], ecx
.text:00001A99                 mov     ecx, [ebp+var_4]
.text:00001A9C                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00001AA1                 mov     [ebp+var_8], eax
.text:00001AA4
.text:00001AA4 loc_1AA4:                               ; CODE XREF: CObjectVector<CArcInfoEx>::Clear(void):loc_1AE6j
.text:00001AA4                 cmp     [ebp+var_8], 0
.text:00001AA8                 jz      short loc_1AE8
.text:00001AAA                 mov     eax, [ebp+var_8]
.text:00001AAD                 sub     eax, 1
.text:00001AB0                 mov     [ebp+var_8], eax
.text:00001AB3                 mov     ecx, [ebp+var_8]
.text:00001AB6                 push    ecx
.text:00001AB7                 mov     ecx, [ebp+var_4]
.text:00001ABA                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00001ABF                 mov     edx, [eax]
.text:00001AC1                 mov     [ebp+var_10], edx
.text:00001AC4                 mov     eax, [ebp+var_10]
.text:00001AC7                 mov     [ebp+var_C], eax
.text:00001ACA                 cmp     [ebp+var_C], 0
.text:00001ACE                 jz      short loc_1ADF
.text:00001AD0                 push    1
.text:00001AD2                 mov     ecx, [ebp+var_C]
.text:00001AD5                 call    ??_GCArcInfoEx@@QAEPAXI@Z ; CArcInfoEx::`scalar deleting destructor'(uint)
.text:00001ADA                 mov     [ebp+var_14], eax
.text:00001ADD                 jmp     short loc_1AE6
.text:00001ADF ; ---------------------------------------------------------------------------
.text:00001ADF
.text:00001ADF loc_1ADF:                               ; CODE XREF: CObjectVector<CArcInfoEx>::Clear(void)+52j
.text:00001ADF                 mov     [ebp+var_14], 0
.text:00001AE6
.text:00001AE6 loc_1AE6:                               ; CODE XREF: CObjectVector<CArcInfoEx>::Clear(void)+61j
.text:00001AE6                 jmp     short loc_1AA4
.text:00001AE8 ; ---------------------------------------------------------------------------
.text:00001AE8
.text:00001AE8 loc_1AE8:                               ; CODE XREF: CObjectVector<CArcInfoEx>::Clear(void)+2Cj
.text:00001AE8                 mov     ecx, [ebp+var_4]
.text:00001AEB                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00001AF0                 add     esp, 14h
.text:00001AF3                 cmp     ebp, esp
.text:00001AF5                 call    __RTC_CheckEsp
.text:00001AFA                 mov     esp, ebp
.text:00001AFC                 pop     ebp
.text:00001AFD                 retn
.text:00001AFD ?Clear@?$CObjectVector@UCArcInfoEx@@@@QAEXXZ endp
.text:00001AFD
.text:00001AFD ; ---------------------------------------------------------------------------
.text:00001AFE                 align 10h
.text:00001AFE _text           ends
.text:00001AFE
.text:00001B00 ; ===========================================================================
.text:00001B00
.text:00001B00 ; Segment type: Pure code
.text:00001B00 ; Segment permissions: Read/Execute
.text:00001B00 _text           segment para public 'CODE' use32
.text:00001B00                 assume cs:_text
.text:00001B00                 ;org 1B00h
.text:00001B00 ; COMDAT (pick any)
.text:00001B00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001B00
.text:00001B00 ; =============== S U B R O U T I N E =======================================
.text:00001B00
.text:00001B00 ; Attributes: bp-based frame
.text:00001B00
.text:00001B00 ; public: unsigned int __thiscall CObjectVector<class UString>::Size(void)const
.text:00001B00                 public ?Size@?$CObjectVector@VUString@@@@QBEIXZ
.text:00001B00 ?Size@?$CObjectVector@VUString@@@@QBEIXZ proc near
.text:00001B00                                         ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+84p
.text:00001B00                                         ; CArcInfoEx::AddExts(UString const &,UString const &)+B6p
.text:00001B00
.text:00001B00 var_4           = dword ptr -4
.text:00001B00
.text:00001B00                 push    ebp
.text:00001B01                 mov     ebp, esp
.text:00001B03                 push    ecx
.text:00001B04                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001B0B                 mov     [ebp+var_4], ecx
.text:00001B0E                 mov     ecx, [ebp+var_4]
.text:00001B11                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00001B16                 add     esp, 4
.text:00001B19                 cmp     ebp, esp
.text:00001B1B                 call    __RTC_CheckEsp
.text:00001B20                 mov     esp, ebp
.text:00001B22                 pop     ebp
.text:00001B23                 retn
.text:00001B23 ?Size@?$CObjectVector@VUString@@@@QBEIXZ endp
.text:00001B23
.text:00001B23 _text           ends
.text:00001B23
.text:00001B24 ; ===========================================================================
.text:00001B24
.text:00001B24 ; Segment type: Pure code
.text:00001B24 ; Segment permissions: Read/Execute
.text:00001B24 _text           segment para public 'CODE' use32
.text:00001B24                 assume cs:_text
.text:00001B24                 ;org 1B24h
.text:00001B24 ; COMDAT (pick any)
.text:00001B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001B24
.text:00001B24 ; =============== S U B R O U T I N E =======================================
.text:00001B24
.text:00001B24 ; Attributes: bp-based frame
.text:00001B24
.text:00001B24 ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(void)
.text:00001B24                 public ??0?$CObjectVector@VUString@@@@QAE@XZ
.text:00001B24 ??0?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00001B24                                         ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+3Dp
.text:00001B24                                         ; CArcInfoEx::AddExts(UString const &,UString const &)+4Cp
.text:00001B24
.text:00001B24 var_4           = dword ptr -4
.text:00001B24
.text:00001B24                 push    ebp
.text:00001B25                 mov     ebp, esp
.text:00001B27                 push    ecx
.text:00001B28                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001B2F                 mov     [ebp+var_4], ecx
.text:00001B32                 mov     ecx, [ebp+var_4]
.text:00001B35                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00001B3A                 mov     eax, [ebp+var_4]
.text:00001B3D                 add     esp, 4
.text:00001B40                 cmp     ebp, esp
.text:00001B42                 call    __RTC_CheckEsp
.text:00001B47                 mov     esp, ebp
.text:00001B49                 pop     ebp
.text:00001B4A                 retn
.text:00001B4A ??0?$CObjectVector@VUString@@@@QAE@XZ endp
.text:00001B4A
.text:00001B4A ; ---------------------------------------------------------------------------
.text:00001B4B                 align 4
.text:00001B4B _text           ends
.text:00001B4B
.text:00001B4C ; ===========================================================================
.text:00001B4C
.text:00001B4C ; Segment type: Pure code
.text:00001B4C ; Segment permissions: Read/Execute
.text:00001B4C _text           segment para public 'CODE' use32
.text:00001B4C                 assume cs:_text
.text:00001B4C                 ;org 1B4Ch
.text:00001B4C ; COMDAT (pick any)
.text:00001B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001B4C
.text:00001B4C ; =============== S U B R O U T I N E =======================================
.text:00001B4C
.text:00001B4C ; Attributes: bp-based frame
.text:00001B4C
.text:00001B4C ; public: class UString & __thiscall CObjectVector<class UString>::operator[](unsigned int)
.text:00001B4C                 public ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z
.text:00001B4C ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z proc near
.text:00001B4C                                         ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+A5p
.text:00001B4C                                         ; CArcInfoEx::AddExts(UString const &,UString const &)+C7p
.text:00001B4C
.text:00001B4C var_4           = dword ptr -4
.text:00001B4C arg_0           = dword ptr  8
.text:00001B4C
.text:00001B4C                 push    ebp
.text:00001B4D                 mov     ebp, esp
.text:00001B4F                 push    ecx
.text:00001B50                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001B57                 mov     [ebp+var_4], ecx
.text:00001B5A                 mov     eax, [ebp+arg_0]
.text:00001B5D                 push    eax
.text:00001B5E                 mov     ecx, [ebp+var_4]
.text:00001B61                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00001B66                 mov     eax, [eax]
.text:00001B68                 add     esp, 4
.text:00001B6B                 cmp     ebp, esp
.text:00001B6D                 call    __RTC_CheckEsp
.text:00001B72                 mov     esp, ebp
.text:00001B74                 pop     ebp
.text:00001B75                 retn    4
.text:00001B75 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z endp
.text:00001B75
.text:00001B75 _text           ends
.text:00001B75
.text:00001B78 ; ===========================================================================
.text:00001B78
.text:00001B78 ; Segment type: Pure code
.text:00001B78 ; Segment permissions: Read/Execute
.text:00001B78 _text           segment para public 'CODE' use32
.text:00001B78                 assume cs:_text
.text:00001B78                 ;org 1B78h
.text:00001B78 ; COMDAT (pick any)
.text:00001B78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001B78
.text:00001B78 ; =============== S U B R O U T I N E =======================================
.text:00001B78
.text:00001B78 ; Attributes: bp-based frame
.text:00001B78
.text:00001B78 ; public: unsigned int __thiscall CObjectVector<class UString>::Add(class UString const &)
.text:00001B78                 public ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00001B78 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text:00001B78                                         ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+CAp
.text:00001B78                                         ; SplitString(UString const &,CObjectVector<UString> &)+FEp
.text:00001B78
.text:00001B78 var_1C          = dword ptr -1Ch
.text:00001B78 var_18          = dword ptr -18h
.text:00001B78 var_14          = dword ptr -14h
.text:00001B78 var_10          = dword ptr -10h
.text:00001B78 var_C           = dword ptr -0Ch
.text:00001B78 var_4           = dword ptr -4
.text:00001B78 arg_0           = dword ptr  8
.text:00001B78
.text:00001B78                 push    ebp
.text:00001B79                 mov     ebp, esp
.text:00001B7B                 push    0FFFFFFFFh
.text:00001B7D                 push    offset __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00001B82                 mov     eax, large fs:0
.text:00001B88                 push    eax
.text:00001B89                 sub     esp, 10h
.text:00001B8C                 mov     eax, 0CCCCCCCCh
.text:00001B91                 mov     [ebp+var_1C], eax
.text:00001B94                 mov     [ebp+var_18], eax
.text:00001B97                 mov     [ebp+var_14], eax
.text:00001B9A                 mov     [ebp+var_10], eax
.text:00001B9D                 mov     eax, dword ptr ds:___security_cookie
.text:00001BA2                 xor     eax, ebp
.text:00001BA4                 push    eax
.text:00001BA5                 lea     eax, [ebp+var_C]
.text:00001BA8                 mov     large fs:0, eax
.text:00001BAE                 mov     [ebp+var_10], ecx
.text:00001BB1                 push    0Ch             ; unsigned int
.text:00001BB3                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001BB8                 add     esp, 4
.text:00001BBB                 mov     [ebp+var_18], eax
.text:00001BBE                 mov     [ebp+var_4], 0
.text:00001BC5                 cmp     [ebp+var_18], 0
.text:00001BC9                 jz      short loc_1BDC
.text:00001BCB                 mov     eax, [ebp+arg_0]
.text:00001BCE                 push    eax
.text:00001BCF                 mov     ecx, [ebp+var_18]
.text:00001BD2                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00001BD7                 mov     [ebp+var_1C], eax
.text:00001BDA                 jmp     short loc_1BE3
.text:00001BDC ; ---------------------------------------------------------------------------
.text:00001BDC
.text:00001BDC loc_1BDC:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+51j
.text:00001BDC                 mov     [ebp+var_1C], 0
.text:00001BE3
.text:00001BE3 loc_1BE3:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+62j
.text:00001BE3                 mov     ecx, [ebp+var_1C]
.text:00001BE6                 mov     [ebp+var_14], ecx
.text:00001BE9                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001BF0                 mov     edx, [ebp+var_14]
.text:00001BF3                 push    edx
.text:00001BF4                 mov     ecx, [ebp+var_10]
.text:00001BF7                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00001BFC                 mov     ecx, [ebp+var_C]
.text:00001BFF                 mov     large fs:0, ecx
.text:00001C06                 pop     ecx
.text:00001C07                 add     esp, 1Ch
.text:00001C0A                 cmp     ebp, esp
.text:00001C0C                 call    __RTC_CheckEsp
.text:00001C11                 mov     esp, ebp
.text:00001C13                 pop     ebp
.text:00001C14                 retn    4
.text:00001C14 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text:00001C14
.text:00001C14 ; ---------------------------------------------------------------------------
.text:00001C17                 align 4
.text:00001C17 _text           ends
.text:00001C17
.text$x:00001C18 ; ===========================================================================
.text$x:00001C18
.text$x:00001C18 ; Segment type: Pure code
.text$x:00001C18 ; Segment permissions: Read/Execute
.text$x:00001C18 _text$x         segment para public 'CODE' use32
.text$x:00001C18                 assume cs:_text$x
.text$x:00001C18                 ;org 1C18h
.text$x:00001C18 ; COMDAT (pick associative to section at 1B78)
.text$x:00001C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001C18
.text$x:00001C18 ; =============== S U B R O U T I N E =======================================
.text$x:00001C18
.text$x:00001C18
.text$x:00001C18 __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 proc near
.text$x:00001C18                                         ; DATA XREF: .xdata$x:00001C44o
.text$x:00001C18                 mov     eax, [ebp-18h]
.text$x:00001C1B                 push    eax             ; void *
.text$x:00001C1C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001C21                 pop     ecx
.text$x:00001C22                 retn
.text$x:00001C22 __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 endp
.text$x:00001C22
.text$x:00001C23
.text$x:00001C23 ; =============== S U B R O U T I N E =======================================
.text$x:00001C23
.text$x:00001C23
.text$x:00001C23 __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text$x:00001C23                                         ; DATA XREF: CObjectVector<UString>::Add(UString const &)+5o
.text$x:00001C23
.text$x:00001C23 arg_4           = dword ptr  8
.text$x:00001C23
.text$x:00001C23                 mov     edx, [esp+arg_4]
.text$x:00001C27                 lea     eax, [edx+0Ch]
.text$x:00001C2A                 mov     ecx, [edx-14h]
.text$x:00001C2D                 xor     ecx, eax
.text$x:00001C2F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C34                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text$x:00001C39                 jmp     ___CxxFrameHandler3
.text$x:00001C39 __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text$x:00001C39
.text$x:00001C39 ; ---------------------------------------------------------------------------
.text$x:00001C3E                 align 10h
.text$x:00001C3E _text$x         ends
.text$x:00001C3E
.xdata$x:00001C40 ; ===========================================================================
.xdata$x:00001C40
.xdata$x:00001C40 ; Segment type: Pure data
.xdata$x:00001C40 ; Segment permissions: Read
.xdata$x:00001C40 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C40                 assume cs:_xdata$x
.xdata$x:00001C40                 ;org 1C40h
.xdata$x:00001C40 ; COMDAT (pick associative to section at 1B78)
.xdata$x:00001C40 __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db 0FFh
.xdata$x:00001C40                                         ; DATA XREF: .xdata$x:00001C50o
.xdata$x:00001C41                 db 0FFh
.xdata$x:00001C42                 db 0FFh
.xdata$x:00001C43                 db 0FFh
.xdata$x:00001C44                 dd offset __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0
.xdata$x:00001C48 __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db  22h ; "
.xdata$x:00001C48                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z+11o
.xdata$x:00001C49                 db    5
.xdata$x:00001C4A                 db  93h ; ô
.xdata$x:00001C4B                 db  19h
.xdata$x:00001C4C                 db    1
.xdata$x:00001C4D                 db    0
.xdata$x:00001C4E                 db    0
.xdata$x:00001C4F                 db    0
.xdata$x:00001C50                 dd offset __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.xdata$x:00001C54                 db    0
.xdata$x:00001C55                 db    0
.xdata$x:00001C56                 db    0
.xdata$x:00001C57                 db    0
.xdata$x:00001C58                 db    0
.xdata$x:00001C59                 db    0
.xdata$x:00001C5A                 db    0
.xdata$x:00001C5B                 db    0
.xdata$x:00001C5C                 db    0
.xdata$x:00001C5D                 db    0
.xdata$x:00001C5E                 db    0
.xdata$x:00001C5F                 db    0
.xdata$x:00001C60                 db    0
.xdata$x:00001C61                 db    0
.xdata$x:00001C62                 db    0
.xdata$x:00001C63                 db    0
.xdata$x:00001C64                 db    0
.xdata$x:00001C65                 db    0
.xdata$x:00001C66                 db    0
.xdata$x:00001C67                 db    0
.xdata$x:00001C68                 db    1
.xdata$x:00001C69                 db    0
.xdata$x:00001C6A                 db    0
.xdata$x:00001C6B                 db    0
.xdata$x:00001C6B _xdata$x        ends
.xdata$x:00001C6B
.text:00001C6C ; ===========================================================================
.text:00001C6C
.text:00001C6C ; Segment type: Pure code
.text:00001C6C ; Segment permissions: Read/Execute
.text:00001C6C _text           segment para public 'CODE' use32
.text:00001C6C                 assume cs:_text
.text:00001C6C                 ;org 1C6Ch
.text:00001C6C ; COMDAT (pick any)
.text:00001C6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001C6C
.text:00001C6C ; =============== S U B R O U T I N E =======================================
.text:00001C6C
.text:00001C6C ; Attributes: bp-based frame
.text:00001C6C
.text:00001C6C ; public: __thiscall CObjectVector<class UString>::~CObjectVector<class UString>(void)
.text:00001C6C                 public ??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00001C6C ??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00001C6C                                         ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+119p
.text:00001C6C                                         ; CArcInfoEx::AddExts(UString const &,UString const &)+128p ...
.text:00001C6C
.text:00001C6C var_20          = dword ptr -20h
.text:00001C6C var_1C          = dword ptr -1Ch
.text:00001C6C var_18          = dword ptr -18h
.text:00001C6C var_14          = dword ptr -14h
.text:00001C6C var_10          = dword ptr -10h
.text:00001C6C var_C           = dword ptr -0Ch
.text:00001C6C var_4           = dword ptr -4
.text:00001C6C
.text:00001C6C                 push    ebp
.text:00001C6D                 mov     ebp, esp
.text:00001C6F                 push    0FFFFFFFFh
.text:00001C71                 push    offset __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00001C76                 mov     eax, large fs:0
.text:00001C7C                 push    eax
.text:00001C7D                 sub     esp, 14h
.text:00001C80                 mov     eax, 0CCCCCCCCh
.text:00001C85                 mov     [ebp+var_20], eax
.text:00001C88                 mov     [ebp+var_1C], eax
.text:00001C8B                 mov     [ebp+var_18], eax
.text:00001C8E                 mov     [ebp+var_14], eax
.text:00001C91                 mov     [ebp+var_10], eax
.text:00001C94                 mov     eax, dword ptr ds:___security_cookie
.text:00001C99                 xor     eax, ebp
.text:00001C9B                 push    eax
.text:00001C9C                 lea     eax, [ebp+var_C]
.text:00001C9F                 mov     large fs:0, eax
.text:00001CA5                 mov     [ebp+var_10], ecx
.text:00001CA8                 mov     [ebp+var_4], 0
.text:00001CAF                 mov     ecx, [ebp+var_10]
.text:00001CB2                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00001CB7                 mov     [ebp+var_14], eax
.text:00001CBA
.text:00001CBA loc_1CBA:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void):loc_1CFCj
.text:00001CBA                 cmp     [ebp+var_14], 0
.text:00001CBE                 jz      short loc_1CFE
.text:00001CC0                 mov     eax, [ebp+var_14]
.text:00001CC3                 sub     eax, 1
.text:00001CC6                 mov     [ebp+var_14], eax
.text:00001CC9                 mov     ecx, [ebp+var_14]
.text:00001CCC                 push    ecx
.text:00001CCD                 mov     ecx, [ebp+var_10]
.text:00001CD0                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00001CD5                 mov     edx, [eax]
.text:00001CD7                 mov     [ebp+var_1C], edx
.text:00001CDA                 mov     eax, [ebp+var_1C]
.text:00001CDD                 mov     [ebp+var_18], eax
.text:00001CE0                 cmp     [ebp+var_18], 0
.text:00001CE4                 jz      short loc_1CF5
.text:00001CE6                 push    1
.text:00001CE8                 mov     ecx, [ebp+var_18]
.text:00001CEB                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00001CF0                 mov     [ebp+var_20], eax
.text:00001CF3                 jmp     short loc_1CFC
.text:00001CF5 ; ---------------------------------------------------------------------------
.text:00001CF5
.text:00001CF5 loc_1CF5:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+78j
.text:00001CF5                 mov     [ebp+var_20], 0
.text:00001CFC
.text:00001CFC loc_1CFC:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+87j
.text:00001CFC                 jmp     short loc_1CBA
.text:00001CFE ; ---------------------------------------------------------------------------
.text:00001CFE
.text:00001CFE loc_1CFE:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+52j
.text:00001CFE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001D05                 mov     ecx, [ebp+var_10]
.text:00001D08                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00001D0D                 mov     ecx, [ebp+var_C]
.text:00001D10                 mov     large fs:0, ecx
.text:00001D17                 pop     ecx
.text:00001D18                 add     esp, 20h
.text:00001D1B                 cmp     ebp, esp
.text:00001D1D                 call    __RTC_CheckEsp
.text:00001D22                 mov     esp, ebp
.text:00001D24                 pop     ebp
.text:00001D25                 retn
.text:00001D25 ??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text:00001D25
.text:00001D25 ; ---------------------------------------------------------------------------
.text:00001D26                 align 4
.text:00001D26 _text           ends
.text:00001D26
.text$x:00001D28 ; ===========================================================================
.text$x:00001D28
.text$x:00001D28 ; Segment type: Pure code
.text$x:00001D28 ; Segment permissions: Read/Execute
.text$x:00001D28 _text$x         segment para public 'CODE' use32
.text$x:00001D28                 assume cs:_text$x
.text$x:00001D28                 ;org 1D28h
.text$x:00001D28 ; COMDAT (pick associative to section at 1C6C)
.text$x:00001D28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001D28
.text$x:00001D28 ; =============== S U B R O U T I N E =======================================
.text$x:00001D28
.text$x:00001D28
.text$x:00001D28 __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 proc near
.text$x:00001D28                                         ; DATA XREF: .xdata$x:00001D50o
.text$x:00001D28                 mov     ecx, [ebp-10h]
.text$x:00001D2B                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00001D2B __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 endp
.text$x:00001D2B
.text$x:00001D30
.text$x:00001D30 ; =============== S U B R O U T I N E =======================================
.text$x:00001D30
.text$x:00001D30
.text$x:00001D30 __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text$x:00001D30                                         ; DATA XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+5o
.text$x:00001D30
.text$x:00001D30 arg_4           = dword ptr  8
.text$x:00001D30
.text$x:00001D30                 mov     edx, [esp+arg_4]
.text$x:00001D34                 lea     eax, [edx+0Ch]
.text$x:00001D37                 mov     ecx, [edx-18h]
.text$x:00001D3A                 xor     ecx, eax
.text$x:00001D3C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D41                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ
.text$x:00001D46                 jmp     ___CxxFrameHandler3
.text$x:00001D46 __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text$x:00001D46
.text$x:00001D46 ; ---------------------------------------------------------------------------
.text$x:00001D4B                 align 4
.text$x:00001D4B _text$x         ends
.text$x:00001D4B
.xdata$x:00001D4C ; ===========================================================================
.xdata$x:00001D4C
.xdata$x:00001D4C ; Segment type: Pure data
.xdata$x:00001D4C ; Segment permissions: Read
.xdata$x:00001D4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D4C                 assume cs:_xdata$x
.xdata$x:00001D4C                 ;org 1D4Ch
.xdata$x:00001D4C ; COMDAT (pick associative to section at 1C6C)
.xdata$x:00001D4C __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ db 0FFh
.xdata$x:00001D4C                                         ; DATA XREF: .xdata$x:00001D5Co
.xdata$x:00001D4D                 db 0FFh
.xdata$x:00001D4E                 db 0FFh
.xdata$x:00001D4F                 db 0FFh
.xdata$x:00001D50                 dd offset __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0
.xdata$x:00001D54 __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ db  22h ; "
.xdata$x:00001D54                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ+11o
.xdata$x:00001D55                 db    5
.xdata$x:00001D56                 db  93h ; ô
.xdata$x:00001D57                 db  19h
.xdata$x:00001D58                 db    1
.xdata$x:00001D59                 db    0
.xdata$x:00001D5A                 db    0
.xdata$x:00001D5B                 db    0
.xdata$x:00001D5C                 dd offset __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ
.xdata$x:00001D60                 db    0
.xdata$x:00001D61                 db    0
.xdata$x:00001D62                 db    0
.xdata$x:00001D63                 db    0
.xdata$x:00001D64                 db    0
.xdata$x:00001D65                 db    0
.xdata$x:00001D66                 db    0
.xdata$x:00001D67                 db    0
.xdata$x:00001D68                 db    0
.xdata$x:00001D69                 db    0
.xdata$x:00001D6A                 db    0
.xdata$x:00001D6B                 db    0
.xdata$x:00001D6C                 db    0
.xdata$x:00001D6D                 db    0
.xdata$x:00001D6E                 db    0
.xdata$x:00001D6F                 db    0
.xdata$x:00001D70                 db    0
.xdata$x:00001D71                 db    0
.xdata$x:00001D72                 db    0
.xdata$x:00001D73                 db    0
.xdata$x:00001D74                 db    1
.xdata$x:00001D75                 db    0
.xdata$x:00001D76                 db    0
.xdata$x:00001D77                 db    0
.xdata$x:00001D77 _xdata$x        ends
.xdata$x:00001D77
.text:00001D78 ; ===========================================================================
.text:00001D78
.text:00001D78 ; Segment type: Pure code
.text:00001D78 ; Segment permissions: Read/Execute
.text:00001D78 _text           segment para public 'CODE' use32
.text:00001D78                 assume cs:_text
.text:00001D78                 ;org 1D78h
.text:00001D78 ; COMDAT (pick any)
.text:00001D78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001D78
.text:00001D78 ; =============== S U B R O U T I N E =======================================
.text:00001D78
.text:00001D78 ; Attributes: bp-based frame
.text:00001D78
.text:00001D78 ; public: void __thiscall CObjectVector<class UString>::Clear(void)
.text:00001D78                 public ?Clear@?$CObjectVector@VUString@@@@QAEXXZ
.text:00001D78 ?Clear@?$CObjectVector@VUString@@@@QAEXXZ proc near
.text:00001D78                                         ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+45p
.text:00001D78
.text:00001D78 var_14          = dword ptr -14h
.text:00001D78 var_10          = dword ptr -10h
.text:00001D78 var_C           = dword ptr -0Ch
.text:00001D78 var_8           = dword ptr -8
.text:00001D78 var_4           = dword ptr -4
.text:00001D78
.text:00001D78                 push    ebp
.text:00001D79                 mov     ebp, esp
.text:00001D7B                 sub     esp, 14h
.text:00001D7E                 mov     eax, 0CCCCCCCCh
.text:00001D83                 mov     [ebp+var_14], eax
.text:00001D86                 mov     [ebp+var_10], eax
.text:00001D89                 mov     [ebp+var_C], eax
.text:00001D8C                 mov     [ebp+var_8], eax
.text:00001D8F                 mov     [ebp+var_4], eax
.text:00001D92                 mov     [ebp+var_4], ecx
.text:00001D95                 mov     ecx, [ebp+var_4]
.text:00001D98                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00001D9D                 mov     [ebp+var_8], eax
.text:00001DA0
.text:00001DA0 loc_1DA0:                               ; CODE XREF: CObjectVector<UString>::Clear(void):loc_1DE2j
.text:00001DA0                 cmp     [ebp+var_8], 0
.text:00001DA4                 jz      short loc_1DE4
.text:00001DA6                 mov     eax, [ebp+var_8]
.text:00001DA9                 sub     eax, 1
.text:00001DAC                 mov     [ebp+var_8], eax
.text:00001DAF                 mov     ecx, [ebp+var_8]
.text:00001DB2                 push    ecx
.text:00001DB3                 mov     ecx, [ebp+var_4]
.text:00001DB6                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00001DBB                 mov     edx, [eax]
.text:00001DBD                 mov     [ebp+var_10], edx
.text:00001DC0                 mov     eax, [ebp+var_10]
.text:00001DC3                 mov     [ebp+var_C], eax
.text:00001DC6                 cmp     [ebp+var_C], 0
.text:00001DCA                 jz      short loc_1DDB
.text:00001DCC                 push    1
.text:00001DCE                 mov     ecx, [ebp+var_C]
.text:00001DD1                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00001DD6                 mov     [ebp+var_14], eax
.text:00001DD9                 jmp     short loc_1DE2
.text:00001DDB ; ---------------------------------------------------------------------------
.text:00001DDB
.text:00001DDB loc_1DDB:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+52j
.text:00001DDB                 mov     [ebp+var_14], 0
.text:00001DE2
.text:00001DE2 loc_1DE2:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+61j
.text:00001DE2                 jmp     short loc_1DA0
.text:00001DE4 ; ---------------------------------------------------------------------------
.text:00001DE4
.text:00001DE4 loc_1DE4:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+2Cj
.text:00001DE4                 mov     ecx, [ebp+var_4]
.text:00001DE7                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00001DEC                 add     esp, 14h
.text:00001DEF                 cmp     ebp, esp
.text:00001DF1                 call    __RTC_CheckEsp
.text:00001DF6                 mov     esp, ebp
.text:00001DF8                 pop     ebp
.text:00001DF9                 retn
.text:00001DF9 ?Clear@?$CObjectVector@VUString@@@@QAEXXZ endp
.text:00001DF9
.text:00001DF9 ; ---------------------------------------------------------------------------
.text:00001DFA                 align 4
.text:00001DFA _text           ends
.text:00001DFA
.text:00001DFC ; ===========================================================================
.text:00001DFC
.text:00001DFC ; Segment type: Pure code
.text:00001DFC ; Segment permissions: Read/Execute
.text:00001DFC _text           segment para public 'CODE' use32
.text:00001DFC                 assume cs:_text
.text:00001DFC                 ;org 1DFCh
.text:00001DFC ; COMDAT (pick any)
.text:00001DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001DFC
.text:00001DFC ; =============== S U B R O U T I N E =======================================
.text:00001DFC
.text:00001DFC ; Attributes: bp-based frame
.text:00001DFC
.text:00001DFC ; int __stdcall CBuffer<unsigned char>::CopyFrom(void *Src, size_t Size)
.text:00001DFC                 public ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z
.text:00001DFC ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z proc near
.text:00001DFC                                         ; CODE XREF: CCodecs::Load(void)+187p
.text:00001DFC                                         ; ParseSignatures(uchar const *,uint,CObjectVector<CBuffer<uchar>> &)+52p
.text:00001DFC
.text:00001DFC var_4           = dword ptr -4
.text:00001DFC Src             = dword ptr  8
.text:00001DFC Size            = dword ptr  0Ch
.text:00001DFC
.text:00001DFC                 push    ebp
.text:00001DFD                 mov     ebp, esp
.text:00001DFF                 push    ecx
.text:00001E00                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001E07                 mov     [ebp+var_4], ecx
.text:00001E0A                 mov     eax, [ebp+Size]
.text:00001E0D                 push    eax
.text:00001E0E                 mov     ecx, [ebp+var_4]
.text:00001E11                 call    ?Alloc@?$CBuffer@E@@QAEXI@Z ; CBuffer<uchar>::Alloc(uint)
.text:00001E16                 cmp     [ebp+Size], 0
.text:00001E1A                 jz      short loc_1E32
.text:00001E1C                 mov     ecx, [ebp+Size]
.text:00001E1F                 push    ecx             ; Size
.text:00001E20                 mov     edx, [ebp+Src]
.text:00001E23                 push    edx             ; Src
.text:00001E24                 mov     eax, [ebp+var_4]
.text:00001E27                 mov     ecx, [eax]
.text:00001E29                 push    ecx             ; Dst
.text:00001E2A                 call    _memcpy
.text:00001E2F                 add     esp, 0Ch
.text:00001E32
.text:00001E32 loc_1E32:                               ; CODE XREF: CBuffer<uchar>::CopyFrom(uchar const *,uint)+1Ej
.text:00001E32                 add     esp, 4
.text:00001E35                 cmp     ebp, esp
.text:00001E37                 call    __RTC_CheckEsp
.text:00001E3C                 mov     esp, ebp
.text:00001E3E                 pop     ebp
.text:00001E3F                 retn    8
.text:00001E3F ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z endp
.text:00001E3F
.text:00001E3F ; ---------------------------------------------------------------------------
.text:00001E42                 align 4
.text:00001E42 _text           ends
.text:00001E42
.text:00001E44 ; ===========================================================================
.text:00001E44
.text:00001E44 ; Segment type: Pure code
.text:00001E44 ; Segment permissions: Read/Execute
.text:00001E44 _text           segment para public 'CODE' use32
.text:00001E44                 assume cs:_text
.text:00001E44                 ;org 1E44h
.text:00001E44 ; COMDAT (pick any)
.text:00001E44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001E44
.text:00001E44 ; =============== S U B R O U T I N E =======================================
.text:00001E44
.text:00001E44 ; Attributes: bp-based frame
.text:00001E44
.text:00001E44 ; public: void __thiscall CRecordVector<int>::Clear(void)
.text:00001E44                 public ?Clear@?$CRecordVector@H@@QAEXXZ
.text:00001E44 ?Clear@?$CRecordVector@H@@QAEXXZ proc near
.text:00001E44                                         ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+3Dp
.text:00001E44                                         ; CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+EEp
.text:00001E44
.text:00001E44 var_4           = dword ptr -4
.text:00001E44
.text:00001E44                 push    ebp
.text:00001E45                 mov     ebp, esp
.text:00001E47                 push    ecx
.text:00001E48                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001E4F                 mov     [ebp+var_4], ecx
.text:00001E52                 mov     eax, [ebp+var_4]
.text:00001E55                 mov     dword ptr [eax+4], 0
.text:00001E5C                 mov     esp, ebp
.text:00001E5E                 pop     ebp
.text:00001E5F                 retn
.text:00001E5F ?Clear@?$CRecordVector@H@@QAEXXZ endp
.text:00001E5F
.text:00001E5F _text           ends
.text:00001E5F
.text:00001E60 ; ===========================================================================
.text:00001E60
.text:00001E60 ; Segment type: Pure code
.text:00001E60 ; Segment permissions: Read/Execute
.text:00001E60 _text           segment para public 'CODE' use32
.text:00001E60                 assume cs:_text
.text:00001E60                 ;org 1E60h
.text:00001E60 ; COMDAT (pick any)
.text:00001E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001E60
.text:00001E60 ; =============== S U B R O U T I N E =======================================
.text:00001E60
.text:00001E60 ; Attributes: bp-based frame
.text:00001E60
.text:00001E60 ; public: unsigned int __thiscall CRecordVector<int>::Add(int)
.text:00001E60                 public ?Add@?$CRecordVector@H@@QAEIH@Z
.text:00001E60 ?Add@?$CRecordVector@H@@QAEIH@Z proc near
.text:00001E60                                         ; CODE XREF: CCodecs::FindFormatForArchiveType(UString const &,CRecordVector<int> &)+112p
.text:00001E60
.text:00001E60 var_8           = dword ptr -8
.text:00001E60 var_4           = dword ptr -4
.text:00001E60 arg_0           = dword ptr  8
.text:00001E60
.text:00001E60                 push    ebp
.text:00001E61                 mov     ebp, esp
.text:00001E63                 sub     esp, 8
.text:00001E66                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001E6D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001E74                 mov     [ebp+var_4], ecx
.text:00001E77                 mov     ecx, [ebp+var_4]
.text:00001E7A                 call    ?ReserveOnePosition@?$CRecordVector@H@@AAEXXZ ; CRecordVector<int>::ReserveOnePosition(void)
.text:00001E7F                 mov     eax, [ebp+var_4]
.text:00001E82                 mov     ecx, [eax+4]
.text:00001E85                 mov     edx, [ebp+var_4]
.text:00001E88                 mov     eax, [edx]
.text:00001E8A                 mov     edx, [ebp+arg_0]
.text:00001E8D                 mov     [eax+ecx*4], edx
.text:00001E90                 mov     eax, [ebp+var_4]
.text:00001E93                 mov     ecx, [eax+4]
.text:00001E96                 mov     [ebp+var_8], ecx
.text:00001E99                 mov     edx, [ebp+var_4]
.text:00001E9C                 mov     eax, [edx+4]
.text:00001E9F                 add     eax, 1
.text:00001EA2                 mov     ecx, [ebp+var_4]
.text:00001EA5                 mov     [ecx+4], eax
.text:00001EA8                 mov     eax, [ebp+var_8]
.text:00001EAB                 add     esp, 8
.text:00001EAE                 cmp     ebp, esp
.text:00001EB0                 call    __RTC_CheckEsp
.text:00001EB5                 mov     esp, ebp
.text:00001EB7                 pop     ebp
.text:00001EB8                 retn    4
.text:00001EB8 ?Add@?$CRecordVector@H@@QAEIH@Z endp
.text:00001EB8
.text:00001EB8 ; ---------------------------------------------------------------------------
.text:00001EBB                 align 4
.text:00001EBB _text           ends
.text:00001EBB
.text:00001EBC ; ===========================================================================
.text:00001EBC
.text:00001EBC ; Segment type: Pure code
.text:00001EBC ; Segment permissions: Read/Execute
.text:00001EBC _text           segment para public 'CODE' use32
.text:00001EBC                 assume cs:_text
.text:00001EBC                 ;org 1EBCh
.text:00001EBC ; COMDAT (pick any)
.text:00001EBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001EBC
.text:00001EBC ; =============== S U B R O U T I N E =======================================
.text:00001EBC
.text:00001EBC ; Attributes: bp-based frame
.text:00001EBC
.text:00001EBC ; public: __thiscall CArcExtInfo::CArcExtInfo(struct CArcExtInfo const &)
.text:00001EBC                 public ??0CArcExtInfo@@QAE@ABU0@@Z
.text:00001EBC ??0CArcExtInfo@@QAE@ABU0@@Z proc near   ; CODE XREF: CObjectVector<CArcExtInfo>::Add(CArcExtInfo const &)+5Ap
.text:00001EBC                                         ; CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)+A6p
.text:00001EBC
.text:00001EBC var_10          = dword ptr -10h
.text:00001EBC var_C           = dword ptr -0Ch
.text:00001EBC var_4           = dword ptr -4
.text:00001EBC arg_0           = dword ptr  8
.text:00001EBC
.text:00001EBC                 push    ebp
.text:00001EBD                 mov     ebp, esp
.text:00001EBF                 push    0FFFFFFFFh
.text:00001EC1                 push    offset __ehhandler$??0CArcExtInfo@@QAE@ABU0@@Z
.text:00001EC6                 mov     eax, large fs:0
.text:00001ECC                 push    eax
.text:00001ECD                 push    ecx
.text:00001ECE                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00001ED5                 mov     eax, dword ptr ds:___security_cookie
.text:00001EDA                 xor     eax, ebp
.text:00001EDC                 push    eax
.text:00001EDD                 lea     eax, [ebp+var_C]
.text:00001EE0                 mov     large fs:0, eax
.text:00001EE6                 mov     [ebp+var_10], ecx
.text:00001EE9                 mov     eax, [ebp+arg_0]
.text:00001EEC                 push    eax
.text:00001EED                 mov     ecx, [ebp+var_10]
.text:00001EF0                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00001EF5                 mov     [ebp+var_4], 0
.text:00001EFC                 mov     ecx, [ebp+arg_0]
.text:00001EFF                 add     ecx, 0Ch
.text:00001F02                 push    ecx
.text:00001F03                 mov     ecx, [ebp+var_10]
.text:00001F06                 add     ecx, 0Ch
.text:00001F09                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00001F0E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001F15                 mov     eax, [ebp+var_10]
.text:00001F18                 mov     ecx, [ebp+var_C]
.text:00001F1B                 mov     large fs:0, ecx
.text:00001F22                 pop     ecx
.text:00001F23                 add     esp, 10h
.text:00001F26                 cmp     ebp, esp
.text:00001F28                 call    __RTC_CheckEsp
.text:00001F2D                 mov     esp, ebp
.text:00001F2F                 pop     ebp
.text:00001F30                 retn    4
.text:00001F30 ??0CArcExtInfo@@QAE@ABU0@@Z endp
.text:00001F30
.text:00001F30 ; ---------------------------------------------------------------------------
.text:00001F33                 align 4
.text:00001F33 _text           ends
.text:00001F33
.text$x:00001F34 ; ===========================================================================
.text$x:00001F34
.text$x:00001F34 ; Segment type: Pure code
.text$x:00001F34 ; Segment permissions: Read/Execute
.text$x:00001F34 _text$x         segment para public 'CODE' use32
.text$x:00001F34                 assume cs:_text$x
.text$x:00001F34                 ;org 1F34h
.text$x:00001F34 ; COMDAT (pick associative to section at 1EBC)
.text$x:00001F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001F34
.text$x:00001F34 ; =============== S U B R O U T I N E =======================================
.text$x:00001F34
.text$x:00001F34
.text$x:00001F34 __unwindfunclet$??0CArcExtInfo@@QAE@ABU0@@Z$0 proc near
.text$x:00001F34                                         ; DATA XREF: .xdata$x:00001F5Co
.text$x:00001F34                 mov     ecx, [ebp-10h]  ; this
.text$x:00001F37                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001F37 __unwindfunclet$??0CArcExtInfo@@QAE@ABU0@@Z$0 endp
.text$x:00001F37
.text$x:00001F3C
.text$x:00001F3C ; =============== S U B R O U T I N E =======================================
.text$x:00001F3C
.text$x:00001F3C
.text$x:00001F3C __ehhandler$??0CArcExtInfo@@QAE@ABU0@@Z proc near
.text$x:00001F3C                                         ; DATA XREF: CArcExtInfo::CArcExtInfo(CArcExtInfo const &)+5o
.text$x:00001F3C
.text$x:00001F3C arg_4           = dword ptr  8
.text$x:00001F3C
.text$x:00001F3C                 mov     edx, [esp+arg_4]
.text$x:00001F40                 lea     eax, [edx+0Ch]
.text$x:00001F43                 mov     ecx, [edx-8]
.text$x:00001F46                 xor     ecx, eax
.text$x:00001F48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001F4D                 mov     eax, offset __ehfuncinfo$??0CArcExtInfo@@QAE@ABU0@@Z
.text$x:00001F52                 jmp     ___CxxFrameHandler3
.text$x:00001F52 __ehhandler$??0CArcExtInfo@@QAE@ABU0@@Z endp
.text$x:00001F52
.text$x:00001F52 ; ---------------------------------------------------------------------------
.text$x:00001F57                 align 4
.text$x:00001F57 _text$x         ends
.text$x:00001F57
.xdata$x:00001F58 ; ===========================================================================
.xdata$x:00001F58
.xdata$x:00001F58 ; Segment type: Pure data
.xdata$x:00001F58 ; Segment permissions: Read
.xdata$x:00001F58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F58                 assume cs:_xdata$x
.xdata$x:00001F58                 ;org 1F58h
.xdata$x:00001F58 ; COMDAT (pick associative to section at 1EBC)
.xdata$x:00001F58 __unwindtable$??0CArcExtInfo@@QAE@ABU0@@Z db 0FFh
.xdata$x:00001F58                                         ; DATA XREF: .xdata$x:00001F68o
.xdata$x:00001F59                 db 0FFh
.xdata$x:00001F5A                 db 0FFh
.xdata$x:00001F5B                 db 0FFh
.xdata$x:00001F5C                 dd offset __unwindfunclet$??0CArcExtInfo@@QAE@ABU0@@Z$0
.xdata$x:00001F60 __ehfuncinfo$??0CArcExtInfo@@QAE@ABU0@@Z db  22h ; "
.xdata$x:00001F60                                         ; DATA XREF: __ehhandler$??0CArcExtInfo@@QAE@ABU0@@Z+11o
.xdata$x:00001F61                 db    5
.xdata$x:00001F62                 db  93h ; ô
.xdata$x:00001F63                 db  19h
.xdata$x:00001F64                 db    1
.xdata$x:00001F65                 db    0
.xdata$x:00001F66                 db    0
.xdata$x:00001F67                 db    0
.xdata$x:00001F68                 dd offset __unwindtable$??0CArcExtInfo@@QAE@ABU0@@Z
.xdata$x:00001F6C                 align 20h
.xdata$x:00001F80                 db    1
.xdata$x:00001F81                 db    0
.xdata$x:00001F82                 db    0
.xdata$x:00001F83                 db    0
.xdata$x:00001F83 _xdata$x        ends
.xdata$x:00001F83
.text:00001F84 ; ===========================================================================
.text:00001F84
.text:00001F84 ; Segment type: Pure code
.text:00001F84 ; Segment permissions: Read/Execute
.text:00001F84 _text           segment para public 'CODE' use32
.text:00001F84                 assume cs:_text
.text:00001F84                 ;org 1F84h
.text:00001F84 ; COMDAT (pick any)
.text:00001F84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001F84
.text:00001F84 ; =============== S U B R O U T I N E =======================================
.text:00001F84
.text:00001F84 ; Attributes: bp-based frame
.text:00001F84
.text:00001F84 ; public: void * __thiscall CArcExtInfo::`scalar deleting destructor'(unsigned int)
.text:00001F84                 public ??_GCArcExtInfo@@QAEPAXI@Z
.text:00001F84 ??_GCArcExtInfo@@QAEPAXI@Z proc near    ; CODE XREF: CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)+7Fp
.text:00001F84
.text:00001F84 var_4           = dword ptr -4
.text:00001F84 arg_0           = dword ptr  8
.text:00001F84
.text:00001F84                 push    ebp
.text:00001F85                 mov     ebp, esp
.text:00001F87                 push    ecx
.text:00001F88                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001F8F                 mov     [ebp+var_4], ecx
.text:00001F92                 mov     ecx, [ebp+var_4] ; this
.text:00001F95                 call    ??1CArcExtInfo@@QAE@XZ ; CArcExtInfo::~CArcExtInfo(void)
.text:00001F9A                 mov     eax, [ebp+arg_0]
.text:00001F9D                 and     eax, 1
.text:00001FA0                 jz      short loc_1FAE
.text:00001FA2                 mov     ecx, [ebp+var_4]
.text:00001FA5                 push    ecx             ; void *
.text:00001FA6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001FAB                 add     esp, 4
.text:00001FAE
.text:00001FAE loc_1FAE:                               ; CODE XREF: CArcExtInfo::`scalar deleting destructor'(uint)+1Cj
.text:00001FAE                 mov     eax, [ebp+var_4]
.text:00001FB1                 add     esp, 4
.text:00001FB4                 cmp     ebp, esp
.text:00001FB6                 call    __RTC_CheckEsp
.text:00001FBB                 mov     esp, ebp
.text:00001FBD                 pop     ebp
.text:00001FBE                 retn    4
.text:00001FBE ??_GCArcExtInfo@@QAEPAXI@Z endp
.text:00001FBE
.text:00001FBE ; ---------------------------------------------------------------------------
.text:00001FC1                 align 4
.text:00001FC1 _text           ends
.text:00001FC1
.text:00001FC4 ; ===========================================================================
.text:00001FC4
.text:00001FC4 ; Segment type: Pure code
.text:00001FC4 ; Segment permissions: Read/Execute
.text:00001FC4 _text           segment para public 'CODE' use32
.text:00001FC4                 assume cs:_text
.text:00001FC4                 ;org 1FC4h
.text:00001FC4 ; COMDAT (pick any)
.text:00001FC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001FC4
.text:00001FC4 ; =============== S U B R O U T I N E =======================================
.text:00001FC4
.text:00001FC4 ; Attributes: bp-based frame
.text:00001FC4
.text:00001FC4 ; public: void * __thiscall CBuffer<unsigned char>::`scalar deleting destructor'(unsigned int)
.text:00001FC4                 public ??_G?$CBuffer@E@@QAEPAXI@Z
.text:00001FC4 ??_G?$CBuffer@E@@QAEPAXI@Z proc near    ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+7Fp
.text:00001FC4                                         ; CObjectVector<CBuffer<uchar>>::Clear(void)+59p
.text:00001FC4
.text:00001FC4 var_4           = dword ptr -4
.text:00001FC4 arg_0           = dword ptr  8
.text:00001FC4
.text:00001FC4                 push    ebp
.text:00001FC5                 mov     ebp, esp
.text:00001FC7                 push    ecx
.text:00001FC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001FCF                 mov     [ebp+var_4], ecx
.text:00001FD2                 mov     ecx, [ebp+var_4]
.text:00001FD5                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00001FDA                 mov     eax, [ebp+arg_0]
.text:00001FDD                 and     eax, 1
.text:00001FE0                 jz      short loc_1FEE
.text:00001FE2                 mov     ecx, [ebp+var_4]
.text:00001FE5                 push    ecx             ; void *
.text:00001FE6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001FEB                 add     esp, 4
.text:00001FEE
.text:00001FEE loc_1FEE:                               ; CODE XREF: CBuffer<uchar>::`scalar deleting destructor'(uint)+1Cj
.text:00001FEE                 mov     eax, [ebp+var_4]
.text:00001FF1                 add     esp, 4
.text:00001FF4                 cmp     ebp, esp
.text:00001FF6                 call    __RTC_CheckEsp
.text:00001FFB                 mov     esp, ebp
.text:00001FFD                 pop     ebp
.text:00001FFE                 retn    4
.text:00001FFE ??_G?$CBuffer@E@@QAEPAXI@Z endp
.text:00001FFE
.text:00001FFE ; ---------------------------------------------------------------------------
.text:00002001                 align 4
.text:00002001 _text           ends
.text:00002001
.text:00002004 ; ===========================================================================
.text:00002004
.text:00002004 ; Segment type: Pure code
.text:00002004 ; Segment permissions: Read/Execute
.text:00002004 _text           segment para public 'CODE' use32
.text:00002004                 assume cs:_text
.text:00002004                 ;org 2004h
.text:00002004 ; COMDAT (pick any)
.text:00002004                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002004
.text:00002004 ; =============== S U B R O U T I N E =======================================
.text:00002004
.text:00002004 ; Attributes: bp-based frame
.text:00002004
.text:00002004 ; public: __thiscall CArcInfoEx::CArcInfoEx(struct CArcInfoEx const &)
.text:00002004                 public ??0CArcInfoEx@@QAE@ABU0@@Z
.text:00002004 ??0CArcInfoEx@@QAE@ABU0@@Z proc near    ; CODE XREF: CObjectVector<CArcInfoEx>::Add(CArcInfoEx const &)+5Ap
.text:00002004
.text:00002004 var_10          = dword ptr -10h
.text:00002004 var_C           = dword ptr -0Ch
.text:00002004 var_4           = dword ptr -4
.text:00002004 arg_0           = dword ptr  8
.text:00002004
.text:00002004                 push    ebp
.text:00002005                 mov     ebp, esp
.text:00002007                 push    0FFFFFFFFh
.text:00002009                 push    offset __ehhandler$??0CArcInfoEx@@QAE@ABU0@@Z
.text:0000200E                 mov     eax, large fs:0
.text:00002014                 push    eax
.text:00002015                 push    ecx
.text:00002016                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000201D                 mov     eax, dword ptr ds:___security_cookie
.text:00002022                 xor     eax, ebp
.text:00002024                 push    eax
.text:00002025                 lea     eax, [ebp+var_C]
.text:00002028                 mov     large fs:0, eax
.text:0000202E                 mov     [ebp+var_10], ecx
.text:00002031                 mov     eax, [ebp+var_10]
.text:00002034                 mov     ecx, [ebp+arg_0]
.text:00002037                 mov     edx, [ecx]
.text:00002039                 mov     [eax], edx
.text:0000203B                 mov     eax, [ebp+var_10]
.text:0000203E                 mov     ecx, [ebp+arg_0]
.text:00002041                 mov     edx, [ecx+4]
.text:00002044                 mov     [eax+4], edx
.text:00002047                 mov     eax, [ebp+var_10]
.text:0000204A                 mov     ecx, [ebp+arg_0]
.text:0000204D                 mov     edx, [ecx+8]
.text:00002050                 mov     [eax+8], edx
.text:00002053                 mov     eax, [ebp+arg_0]
.text:00002056                 add     eax, 0Ch
.text:00002059                 push    eax
.text:0000205A                 mov     ecx, [ebp+var_10]
.text:0000205D                 add     ecx, 0Ch
.text:00002060                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00002065                 mov     [ebp+var_4], 0
.text:0000206C                 mov     ecx, [ebp+arg_0]
.text:0000206F                 add     ecx, 18h
.text:00002072                 push    ecx
.text:00002073                 mov     ecx, [ebp+var_10]
.text:00002076                 add     ecx, 18h
.text:00002079                 call    ??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z ; CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)
.text:0000207E                 mov     byte ptr [ebp+var_4], 1
.text:00002082                 mov     edx, [ebp+var_10]
.text:00002085                 mov     eax, [ebp+arg_0]
.text:00002088                 mov     ecx, [eax+24h]
.text:0000208B                 mov     [edx+24h], ecx
.text:0000208E                 mov     edx, [ebp+var_10]
.text:00002091                 mov     eax, [ebp+arg_0]
.text:00002094                 mov     cl, [eax+28h]
.text:00002097                 mov     [edx+28h], cl
.text:0000209A                 mov     edx, [ebp+var_10]
.text:0000209D                 mov     eax, [ebp+arg_0]
.text:000020A0                 mov     cl, [eax+29h]
.text:000020A3                 mov     [edx+29h], cl
.text:000020A6                 mov     edx, [ebp+var_10]
.text:000020A9                 mov     eax, [ebp+arg_0]
.text:000020AC                 mov     ecx, [eax+2Ch]
.text:000020AF                 mov     [edx+2Ch], ecx
.text:000020B2                 mov     edx, [ebp+arg_0]
.text:000020B5                 add     edx, 30h ; '0'
.text:000020B8                 push    edx
.text:000020B9                 mov     ecx, [ebp+var_10]
.text:000020BC                 add     ecx, 30h ; '0'
.text:000020BF                 call    ??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z ; CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)
.text:000020C4                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000020CB                 mov     eax, [ebp+var_10]
.text:000020CE                 mov     ecx, [ebp+var_C]
.text:000020D1                 mov     large fs:0, ecx
.text:000020D8                 pop     ecx
.text:000020D9                 add     esp, 10h
.text:000020DC                 cmp     ebp, esp
.text:000020DE                 call    __RTC_CheckEsp
.text:000020E3                 mov     esp, ebp
.text:000020E5                 pop     ebp
.text:000020E6                 retn    4
.text:000020E6 ??0CArcInfoEx@@QAE@ABU0@@Z endp
.text:000020E6
.text:000020E6 ; ---------------------------------------------------------------------------
.text:000020E9                 align 4
.text:000020E9 _text           ends
.text:000020E9
.text$x:000020EC ; ===========================================================================
.text$x:000020EC
.text$x:000020EC ; Segment type: Pure code
.text$x:000020EC ; Segment permissions: Read/Execute
.text$x:000020EC _text$x         segment para public 'CODE' use32
.text$x:000020EC                 assume cs:_text$x
.text$x:000020EC                 ;org 20ECh
.text$x:000020EC ; COMDAT (pick associative to section at 2004)
.text$x:000020EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000020EC
.text$x:000020EC ; =============== S U B R O U T I N E =======================================
.text$x:000020EC
.text$x:000020EC
.text$x:000020EC __unwindfunclet$??0CArcInfoEx@@QAE@ABU0@@Z$0 proc near
.text$x:000020EC                                         ; DATA XREF: .xdata$x:00002124o
.text$x:000020EC                 mov     ecx, [ebp-10h]
.text$x:000020EF                 add     ecx, 0Ch        ; this
.text$x:000020F2                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000020F2 __unwindfunclet$??0CArcInfoEx@@QAE@ABU0@@Z$0 endp
.text$x:000020F2
.text$x:000020F7
.text$x:000020F7 ; =============== S U B R O U T I N E =======================================
.text$x:000020F7
.text$x:000020F7
.text$x:000020F7 __unwindfunclet$??0CArcInfoEx@@QAE@ABU0@@Z$1 proc near
.text$x:000020F7                                         ; DATA XREF: .xdata$x:0000212Co
.text$x:000020F7                 mov     ecx, [ebp-10h]
.text$x:000020FA                 add     ecx, 18h
.text$x:000020FD                 jmp     ??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ ; CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)
.text$x:000020FD __unwindfunclet$??0CArcInfoEx@@QAE@ABU0@@Z$1 endp
.text$x:000020FD
.text$x:00002102
.text$x:00002102 ; =============== S U B R O U T I N E =======================================
.text$x:00002102
.text$x:00002102
.text$x:00002102 __ehhandler$??0CArcInfoEx@@QAE@ABU0@@Z proc near
.text$x:00002102                                         ; DATA XREF: CArcInfoEx::CArcInfoEx(CArcInfoEx const &)+5o
.text$x:00002102
.text$x:00002102 arg_4           = dword ptr  8
.text$x:00002102
.text$x:00002102                 mov     edx, [esp+arg_4]
.text$x:00002106                 lea     eax, [edx+0Ch]
.text$x:00002109                 mov     ecx, [edx-8]
.text$x:0000210C                 xor     ecx, eax
.text$x:0000210E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002113                 mov     eax, offset __ehfuncinfo$??0CArcInfoEx@@QAE@ABU0@@Z
.text$x:00002118                 jmp     ___CxxFrameHandler3
.text$x:00002118 __ehhandler$??0CArcInfoEx@@QAE@ABU0@@Z endp
.text$x:00002118
.text$x:00002118 ; ---------------------------------------------------------------------------
.text$x:0000211D                 align 10h
.text$x:0000211D _text$x         ends
.text$x:0000211D
.xdata$x:00002120 ; ===========================================================================
.xdata$x:00002120
.xdata$x:00002120 ; Segment type: Pure data
.xdata$x:00002120 ; Segment permissions: Read
.xdata$x:00002120 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002120                 assume cs:_xdata$x
.xdata$x:00002120                 ;org 2120h
.xdata$x:00002120 ; COMDAT (pick associative to section at 2004)
.xdata$x:00002120 __unwindtable$??0CArcInfoEx@@QAE@ABU0@@Z db 0FFh
.xdata$x:00002120                                         ; DATA XREF: .xdata$x:00002138o
.xdata$x:00002121                 db 0FFh
.xdata$x:00002122                 db 0FFh
.xdata$x:00002123                 db 0FFh
.xdata$x:00002124                 dd offset __unwindfunclet$??0CArcInfoEx@@QAE@ABU0@@Z$0
.xdata$x:00002128                 db    0
.xdata$x:00002129                 db    0
.xdata$x:0000212A                 db    0
.xdata$x:0000212B                 db    0
.xdata$x:0000212C                 dd offset __unwindfunclet$??0CArcInfoEx@@QAE@ABU0@@Z$1
.xdata$x:00002130 __ehfuncinfo$??0CArcInfoEx@@QAE@ABU0@@Z db  22h ; "
.xdata$x:00002130                                         ; DATA XREF: __ehhandler$??0CArcInfoEx@@QAE@ABU0@@Z+11o
.xdata$x:00002131                 db    5
.xdata$x:00002132                 db  93h ; ô
.xdata$x:00002133                 db  19h
.xdata$x:00002134                 db    2
.xdata$x:00002135                 db    0
.xdata$x:00002136                 db    0
.xdata$x:00002137                 db    0
.xdata$x:00002138                 dd offset __unwindtable$??0CArcInfoEx@@QAE@ABU0@@Z
.xdata$x:0000213C                 db    0
.xdata$x:0000213D                 db    0
.xdata$x:0000213E                 db    0
.xdata$x:0000213F                 db    0
.xdata$x:00002140                 db    0
.xdata$x:00002141                 db    0
.xdata$x:00002142                 db    0
.xdata$x:00002143                 db    0
.xdata$x:00002144                 db    0
.xdata$x:00002145                 db    0
.xdata$x:00002146                 db    0
.xdata$x:00002147                 db    0
.xdata$x:00002148                 db    0
.xdata$x:00002149                 db    0
.xdata$x:0000214A                 db    0
.xdata$x:0000214B                 db    0
.xdata$x:0000214C                 db    0
.xdata$x:0000214D                 db    0
.xdata$x:0000214E                 db    0
.xdata$x:0000214F                 db    0
.xdata$x:00002150                 db    1
.xdata$x:00002151                 db    0
.xdata$x:00002152                 db    0
.xdata$x:00002153                 db    0
.xdata$x:00002153 _xdata$x        ends
.xdata$x:00002153
.text:00002154 ; ===========================================================================
.text:00002154
.text:00002154 ; Segment type: Pure code
.text:00002154 ; Segment permissions: Read/Execute
.text:00002154 _text           segment para public 'CODE' use32
.text:00002154                 assume cs:_text
.text:00002154                 ;org 2154h
.text:00002154 ; COMDAT (pick any)
.text:00002154                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002154
.text:00002154 ; =============== S U B R O U T I N E =======================================
.text:00002154
.text:00002154 ; Attributes: bp-based frame
.text:00002154
.text:00002154 ; public: void * __thiscall CArcInfoEx::`scalar deleting destructor'(unsigned int)
.text:00002154                 public ??_GCArcInfoEx@@QAEPAXI@Z
.text:00002154 ??_GCArcInfoEx@@QAEPAXI@Z proc near     ; CODE XREF: CObjectVector<CArcInfoEx>::Clear(void)+59p
.text:00002154
.text:00002154 var_4           = dword ptr -4
.text:00002154 arg_0           = dword ptr  8
.text:00002154
.text:00002154                 push    ebp
.text:00002155                 mov     ebp, esp
.text:00002157                 push    ecx
.text:00002158                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000215F                 mov     [ebp+var_4], ecx
.text:00002162                 mov     ecx, [ebp+var_4] ; this
.text:00002165                 call    ??1CArcInfoEx@@QAE@XZ ; CArcInfoEx::~CArcInfoEx(void)
.text:0000216A                 mov     eax, [ebp+arg_0]
.text:0000216D                 and     eax, 1
.text:00002170                 jz      short loc_217E
.text:00002172                 mov     ecx, [ebp+var_4]
.text:00002175                 push    ecx             ; void *
.text:00002176                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000217B                 add     esp, 4
.text:0000217E
.text:0000217E loc_217E:                               ; CODE XREF: CArcInfoEx::`scalar deleting destructor'(uint)+1Cj
.text:0000217E                 mov     eax, [ebp+var_4]
.text:00002181                 add     esp, 4
.text:00002184                 cmp     ebp, esp
.text:00002186                 call    __RTC_CheckEsp
.text:0000218B                 mov     esp, ebp
.text:0000218D                 pop     ebp
.text:0000218E                 retn    4
.text:0000218E ??_GCArcInfoEx@@QAEPAXI@Z endp
.text:0000218E
.text:0000218E ; ---------------------------------------------------------------------------
.text:00002191                 align 4
.text:00002191 _text           ends
.text:00002191
.text:00002194 ; ===========================================================================
.text:00002194
.text:00002194 ; Segment type: Pure code
.text:00002194 ; Segment permissions: Read/Execute
.text:00002194 _text           segment para public 'CODE' use32
.text:00002194                 assume cs:_text
.text:00002194                 ;org 2194h
.text:00002194 ; COMDAT (pick any)
.text:00002194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002194
.text:00002194 ; =============== S U B R O U T I N E =======================================
.text:00002194
.text:00002194 ; Attributes: bp-based frame
.text:00002194
.text:00002194 ; public: void * __thiscall UString::`scalar deleting destructor'(unsigned int)
.text:00002194                 public ??_GUString@@QAEPAXI@Z
.text:00002194 ??_GUString@@QAEPAXI@Z proc near        ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+7Fp
.text:00002194                                         ; CObjectVector<UString>::Clear(void)+59p
.text:00002194
.text:00002194 var_4           = dword ptr -4
.text:00002194 arg_0           = dword ptr  8
.text:00002194
.text:00002194                 push    ebp
.text:00002195                 mov     ebp, esp
.text:00002197                 push    ecx
.text:00002198                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000219F                 mov     [ebp+var_4], ecx
.text:000021A2                 mov     ecx, [ebp+var_4] ; this
.text:000021A5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000021AA                 mov     eax, [ebp+arg_0]
.text:000021AD                 and     eax, 1
.text:000021B0                 jz      short loc_21BE
.text:000021B2                 mov     ecx, [ebp+var_4]
.text:000021B5                 push    ecx             ; void *
.text:000021B6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000021BB                 add     esp, 4
.text:000021BE
.text:000021BE loc_21BE:                               ; CODE XREF: UString::`scalar deleting destructor'(uint)+1Cj
.text:000021BE                 mov     eax, [ebp+var_4]
.text:000021C1                 add     esp, 4
.text:000021C4                 cmp     ebp, esp
.text:000021C6                 call    __RTC_CheckEsp
.text:000021CB                 mov     esp, ebp
.text:000021CD                 pop     ebp
.text:000021CE                 retn    4
.text:000021CE ??_GUString@@QAEPAXI@Z endp
.text:000021CE
.text:000021CE ; ---------------------------------------------------------------------------
.text:000021D1                 align 4
.text:000021D1 _text           ends
.text:000021D1
.text:000021D4 ; ===========================================================================
.text:000021D4
.text:000021D4 ; Segment type: Pure code
.text:000021D4 ; Segment permissions: Read/Execute
.text:000021D4 _text           segment para public 'CODE' use32
.text:000021D4                 assume cs:_text
.text:000021D4                 ;org 21D4h
.text:000021D4 ; COMDAT (pick any)
.text:000021D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000021D4
.text:000021D4 ; =============== S U B R O U T I N E =======================================
.text:000021D4
.text:000021D4 ; Attributes: bp-based frame
.text:000021D4
.text:000021D4 ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:000021D4                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:000021D4 ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:000021D4                                         ; CODE XREF: CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(void)+11p
.text:000021D4                                         ; CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(void)+11p ...
.text:000021D4
.text:000021D4 var_4           = dword ptr -4
.text:000021D4
.text:000021D4                 push    ebp
.text:000021D5                 mov     ebp, esp
.text:000021D7                 push    ecx
.text:000021D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000021DF                 mov     [ebp+var_4], ecx
.text:000021E2                 mov     eax, [ebp+var_4]
.text:000021E5                 mov     dword ptr [eax], 0
.text:000021EB                 mov     ecx, [ebp+var_4]
.text:000021EE                 mov     dword ptr [ecx+4], 0
.text:000021F5                 mov     edx, [ebp+var_4]
.text:000021F8                 mov     dword ptr [edx+8], 0
.text:000021FF                 mov     eax, [ebp+var_4]
.text:00002202                 mov     esp, ebp
.text:00002204                 pop     ebp
.text:00002205                 retn
.text:00002205 ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:00002205
.text:00002205 ; ---------------------------------------------------------------------------
.text:00002206                 align 4
.text:00002206 _text           ends
.text:00002206
.text:00002208 ; ===========================================================================
.text:00002208
.text:00002208 ; Segment type: Pure code
.text:00002208 ; Segment permissions: Read/Execute
.text:00002208 _text           segment para public 'CODE' use32
.text:00002208                 assume cs:_text
.text:00002208                 ;org 2208h
.text:00002208 ; COMDAT (pick any)
.text:00002208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002208
.text:00002208 ; =============== S U B R O U T I N E =======================================
.text:00002208
.text:00002208 ; Attributes: bp-based frame
.text:00002208
.text:00002208 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:00002208                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:00002208 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:00002208                                         ; CODE XREF: CObjectVector<CArcExtInfo>::Size(void)+11p
.text:00002208                                         ; CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)+46p ...
.text:00002208
.text:00002208 var_4           = dword ptr -4
.text:00002208
.text:00002208                 push    ebp
.text:00002209                 mov     ebp, esp
.text:0000220B                 push    ecx
.text:0000220C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002213                 mov     [ebp+var_4], ecx
.text:00002216                 mov     eax, [ebp+var_4]
.text:00002219                 mov     eax, [eax+4]
.text:0000221C                 mov     esp, ebp
.text:0000221E                 pop     ebp
.text:0000221F                 retn
.text:0000221F ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:0000221F
.text:0000221F _text           ends
.text:0000221F
.text:00002220 ; ===========================================================================
.text:00002220
.text:00002220 ; Segment type: Pure code
.text:00002220 ; Segment permissions: Read/Execute
.text:00002220 _text           segment para public 'CODE' use32
.text:00002220                 assume cs:_text
.text:00002220                 ;org 2220h
.text:00002220 ; COMDAT (pick any)
.text:00002220                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002220
.text:00002220 ; =============== S U B R O U T I N E =======================================
.text:00002220
.text:00002220 ; Attributes: bp-based frame
.text:00002220
.text:00002220 ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00002220                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:00002220 ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:00002220                                         ; CODE XREF: CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)+9Cp
.text:00002220                                         ; __unwindfunclet$??1?$CObjectVector@UCArcExtInfo@@@@QAE@XZ$0+3j ...
.text:00002220
.text:00002220 var_8           = dword ptr -8
.text:00002220 var_4           = dword ptr -4
.text:00002220
.text:00002220                 push    ebp
.text:00002221                 mov     ebp, esp
.text:00002223                 sub     esp, 8
.text:00002226                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000222D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002234                 mov     [ebp+var_4], ecx
.text:00002237                 mov     eax, [ebp+var_4]
.text:0000223A                 mov     ecx, [eax]
.text:0000223C                 mov     [ebp+var_8], ecx
.text:0000223F                 mov     edx, [ebp+var_8]
.text:00002242                 push    edx             ; void *
.text:00002243                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00002248                 add     esp, 4
.text:0000224B                 add     esp, 8
.text:0000224E                 cmp     ebp, esp
.text:00002250                 call    __RTC_CheckEsp
.text:00002255                 mov     esp, ebp
.text:00002257                 pop     ebp
.text:00002258                 retn
.text:00002258 ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:00002258
.text:00002258 ; ---------------------------------------------------------------------------
.text:00002259                 align 4
.text:00002259 _text           ends
.text:00002259
.text:0000225C ; ===========================================================================
.text:0000225C
.text:0000225C ; Segment type: Pure code
.text:0000225C ; Segment permissions: Read/Execute
.text:0000225C _text           segment para public 'CODE' use32
.text:0000225C                 assume cs:_text
.text:0000225C                 ;org 225Ch
.text:0000225C ; COMDAT (pick any)
.text:0000225C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000225C
.text:0000225C ; =============== S U B R O U T I N E =======================================
.text:0000225C
.text:0000225C ; Attributes: bp-based frame
.text:0000225C
.text:0000225C ; public: void __thiscall CRecordVector<void *>::Clear(void)
.text:0000225C                 public ?Clear@?$CRecordVector@PAX@@QAEXXZ
.text:0000225C ?Clear@?$CRecordVector@PAX@@QAEXXZ proc near
.text:0000225C                                         ; CODE XREF: CObjectVector<CBuffer<uchar>>::Clear(void)+6Fp
.text:0000225C                                         ; CObjectVector<CArcInfoEx>::Clear(void)+6Fp ...
.text:0000225C
.text:0000225C var_4           = dword ptr -4
.text:0000225C
.text:0000225C                 push    ebp
.text:0000225D                 mov     ebp, esp
.text:0000225F                 push    ecx
.text:00002260                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002267                 mov     [ebp+var_4], ecx
.text:0000226A                 mov     eax, [ebp+var_4]
.text:0000226D                 mov     dword ptr [eax+4], 0
.text:00002274                 mov     esp, ebp
.text:00002276                 pop     ebp
.text:00002277                 retn
.text:00002277 ?Clear@?$CRecordVector@PAX@@QAEXXZ endp
.text:00002277
.text:00002277 _text           ends
.text:00002277
.text:00002278 ; ===========================================================================
.text:00002278
.text:00002278 ; Segment type: Pure code
.text:00002278 ; Segment permissions: Read/Execute
.text:00002278 _text           segment para public 'CODE' use32
.text:00002278                 assume cs:_text
.text:00002278                 ;org 2278h
.text:00002278 ; COMDAT (pick any)
.text:00002278                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002278
.text:00002278 ; =============== S U B R O U T I N E =======================================
.text:00002278
.text:00002278 ; Attributes: bp-based frame
.text:00002278
.text:00002278 ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:00002278                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:00002278 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:00002278                                         ; CODE XREF: CObjectVector<CArcExtInfo>::Add(CArcExtInfo const &)+7Fp
.text:00002278                                         ; CObjectVector<CBuffer<uchar>>::AddNew(void)+84p ...
.text:00002278
.text:00002278 var_8           = dword ptr -8
.text:00002278 var_4           = dword ptr -4
.text:00002278 arg_0           = dword ptr  8
.text:00002278
.text:00002278                 push    ebp
.text:00002279                 mov     ebp, esp
.text:0000227B                 sub     esp, 8
.text:0000227E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002285                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000228C                 mov     [ebp+var_4], ecx
.text:0000228F                 mov     ecx, [ebp+var_4]
.text:00002292                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:00002297                 mov     eax, [ebp+var_4]
.text:0000229A                 mov     ecx, [eax+4]
.text:0000229D                 mov     edx, [ebp+var_4]
.text:000022A0                 mov     eax, [edx]
.text:000022A2                 mov     edx, [ebp+arg_0]
.text:000022A5                 mov     [eax+ecx*4], edx
.text:000022A8                 mov     eax, [ebp+var_4]
.text:000022AB                 mov     ecx, [eax+4]
.text:000022AE                 mov     [ebp+var_8], ecx
.text:000022B1                 mov     edx, [ebp+var_4]
.text:000022B4                 mov     eax, [edx+4]
.text:000022B7                 add     eax, 1
.text:000022BA                 mov     ecx, [ebp+var_4]
.text:000022BD                 mov     [ecx+4], eax
.text:000022C0                 mov     eax, [ebp+var_8]
.text:000022C3                 add     esp, 8
.text:000022C6                 cmp     ebp, esp
.text:000022C8                 call    __RTC_CheckEsp
.text:000022CD                 mov     esp, ebp
.text:000022CF                 pop     ebp
.text:000022D0                 retn    4
.text:000022D0 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:000022D0
.text:000022D0 ; ---------------------------------------------------------------------------
.text:000022D3                 align 4
.text:000022D3 _text           ends
.text:000022D3
.text:000022D4 ; ===========================================================================
.text:000022D4
.text:000022D4 ; Segment type: Pure code
.text:000022D4 ; Segment permissions: Read/Execute
.text:000022D4 _text           segment para public 'CODE' use32
.text:000022D4                 assume cs:_text
.text:000022D4                 ;org 22D4h
.text:000022D4 ; COMDAT (pick any)
.text:000022D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000022D4
.text:000022D4 ; =============== S U B R O U T I N E =======================================
.text:000022D4
.text:000022D4 ; Attributes: bp-based frame
.text:000022D4
.text:000022D4 ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:000022D4                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:000022D4 ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:000022D4                                         ; CODE XREF: CObjectVector<CArcExtInfo>::operator[](uint)+15p
.text:000022D4                                         ; CObjectVector<CArcInfoEx>::operator[](uint)+15p ...
.text:000022D4
.text:000022D4 var_4           = dword ptr -4
.text:000022D4 arg_0           = dword ptr  8
.text:000022D4
.text:000022D4                 push    ebp
.text:000022D5                 mov     ebp, esp
.text:000022D7                 push    ecx
.text:000022D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000022DF                 mov     [ebp+var_4], ecx
.text:000022E2                 mov     eax, [ebp+var_4]
.text:000022E5                 mov     ecx, [eax]
.text:000022E7                 mov     edx, [ebp+arg_0]
.text:000022EA                 lea     eax, [ecx+edx*4]
.text:000022ED                 mov     esp, ebp
.text:000022EF                 pop     ebp
.text:000022F0                 retn    4
.text:000022F0 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:000022F0
.text:000022F0 ; ---------------------------------------------------------------------------
.text:000022F3                 align 4
.text:000022F3 _text           ends
.text:000022F3
.text:000022F4 ; ===========================================================================
.text:000022F4
.text:000022F4 ; Segment type: Pure code
.text:000022F4 ; Segment permissions: Read/Execute
.text:000022F4 _text           segment para public 'CODE' use32
.text:000022F4                 assume cs:_text
.text:000022F4                 ;org 22F4h
.text:000022F4 ; COMDAT (pick any)
.text:000022F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000022F4
.text:000022F4 ; =============== S U B R O U T I N E =======================================
.text:000022F4
.text:000022F4 ; Attributes: bp-based frame
.text:000022F4
.text:000022F4 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:000022F4                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:000022F4 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:000022F4                                         ; CODE XREF: CObjectVector<CArcExtInfo>::~CObjectVector<CArcExtInfo>(void)+64p
.text:000022F4                                         ; CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+64p ...
.text:000022F4
.text:000022F4 var_4           = dword ptr -4
.text:000022F4 arg_0           = dword ptr  8
.text:000022F4
.text:000022F4                 push    ebp
.text:000022F5                 mov     ebp, esp
.text:000022F7                 push    ecx
.text:000022F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000022FF                 mov     [ebp+var_4], ecx
.text:00002302                 mov     eax, [ebp+var_4]
.text:00002305                 mov     ecx, [eax]
.text:00002307                 mov     edx, [ebp+arg_0]
.text:0000230A                 lea     eax, [ecx+edx*4]
.text:0000230D                 mov     esp, ebp
.text:0000230F                 pop     ebp
.text:00002310                 retn    4
.text:00002310 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:00002310
.text:00002310 ; ---------------------------------------------------------------------------
.text:00002313                 align 4
.text:00002313 _text           ends
.text:00002313
.text:00002314 ; ===========================================================================
.text:00002314
.text:00002314 ; Segment type: Pure code
.text:00002314 ; Segment permissions: Read/Execute
.text:00002314 _text           segment para public 'CODE' use32
.text:00002314                 assume cs:_text
.text:00002314                 ;org 2314h
.text:00002314 ; COMDAT (pick any)
.text:00002314                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002314
.text:00002314 ; =============== S U B R O U T I N E =======================================
.text:00002314
.text:00002314 ; Attributes: bp-based frame
.text:00002314
.text:00002314 ; public: __thiscall CObjectVector<struct CArcExtInfo>::CObjectVector<struct CArcExtInfo>(class CObjectVector<struct CArcExtInfo> const &)
.text:00002314                 public ??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z
.text:00002314 ??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z proc near
.text:00002314                                         ; CODE XREF: CArcInfoEx::CArcInfoEx(CArcInfoEx const &)+75p
.text:00002314
.text:00002314 var_24          = dword ptr -24h
.text:00002314 var_20          = dword ptr -20h
.text:00002314 var_1C          = dword ptr -1Ch
.text:00002314 var_18          = dword ptr -18h
.text:00002314 var_14          = dword ptr -14h
.text:00002314 var_10          = dword ptr -10h
.text:00002314 var_C           = dword ptr -0Ch
.text:00002314 var_4           = dword ptr -4
.text:00002314 arg_0           = dword ptr  8
.text:00002314
.text:00002314                 push    ebp
.text:00002315                 mov     ebp, esp
.text:00002317                 push    0FFFFFFFFh
.text:00002319                 push    offset __ehhandler$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z
.text:0000231E                 mov     eax, large fs:0
.text:00002324                 push    eax
.text:00002325                 sub     esp, 18h
.text:00002328                 mov     eax, 0CCCCCCCCh
.text:0000232D                 mov     [ebp+var_24], eax
.text:00002330                 mov     [ebp+var_20], eax
.text:00002333                 mov     [ebp+var_1C], eax
.text:00002336                 mov     [ebp+var_18], eax
.text:00002339                 mov     [ebp+var_14], eax
.text:0000233C                 mov     [ebp+var_10], eax
.text:0000233F                 mov     eax, dword ptr ds:___security_cookie
.text:00002344                 xor     eax, ebp
.text:00002346                 push    eax
.text:00002347                 lea     eax, [ebp+var_C]
.text:0000234A                 mov     large fs:0, eax
.text:00002350                 mov     [ebp+var_10], ecx
.text:00002353                 mov     ecx, [ebp+var_10]
.text:00002356                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000235B                 mov     [ebp+var_4], 0
.text:00002362                 mov     ecx, [ebp+arg_0]
.text:00002365                 call    ?Size@?$CObjectVector@UCArcExtInfo@@@@QBEIXZ ; CObjectVector<CArcExtInfo>::Size(void)
.text:0000236A                 mov     [ebp+var_14], eax
.text:0000236D                 mov     eax, [ebp+var_14]
.text:00002370                 push    eax
.text:00002371                 mov     ecx, [ebp+var_10]
.text:00002374                 call    ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ConstructReserve(uint)
.text:00002379                 mov     [ebp+var_18], 0
.text:00002380                 jmp     short loc_238B
.text:00002382 ; ---------------------------------------------------------------------------
.text:00002382
.text:00002382 loc_2382:                               ; CODE XREF: CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)+CDj
.text:00002382                 mov     ecx, [ebp+var_18]
.text:00002385                 add     ecx, 1
.text:00002388                 mov     [ebp+var_18], ecx
.text:0000238B
.text:0000238B loc_238B:                               ; CODE XREF: CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)+6Cj
.text:0000238B                 mov     edx, [ebp+var_18]
.text:0000238E                 cmp     edx, [ebp+var_14]
.text:00002391                 jnb     short loc_23E3
.text:00002393                 push    18h             ; unsigned int
.text:00002395                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000239A                 add     esp, 4
.text:0000239D                 mov     [ebp+var_20], eax
.text:000023A0                 mov     byte ptr [ebp+var_4], 1
.text:000023A4                 cmp     [ebp+var_20], 0
.text:000023A8                 jz      short loc_23C4
.text:000023AA                 mov     eax, [ebp+var_18]
.text:000023AD                 push    eax
.text:000023AE                 mov     ecx, [ebp+arg_0]
.text:000023B1                 call    ??A?$CObjectVector@UCArcExtInfo@@@@QBEABUCArcExtInfo@@I@Z ; CObjectVector<CArcExtInfo>::operator[](uint)
.text:000023B6                 push    eax
.text:000023B7                 mov     ecx, [ebp+var_20]
.text:000023BA                 call    ??0CArcExtInfo@@QAE@ABU0@@Z ; CArcExtInfo::CArcExtInfo(CArcExtInfo const &)
.text:000023BF                 mov     [ebp+var_24], eax
.text:000023C2                 jmp     short loc_23CB
.text:000023C4 ; ---------------------------------------------------------------------------
.text:000023C4
.text:000023C4 loc_23C4:                               ; CODE XREF: CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)+94j
.text:000023C4                 mov     [ebp+var_24], 0
.text:000023CB
.text:000023CB loc_23CB:                               ; CODE XREF: CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)+AEj
.text:000023CB                 mov     ecx, [ebp+var_24]
.text:000023CE                 mov     [ebp+var_1C], ecx
.text:000023D1                 mov     byte ptr [ebp+var_4], 0
.text:000023D5                 mov     edx, [ebp+var_1C]
.text:000023D8                 push    edx
.text:000023D9                 mov     ecx, [ebp+var_10]
.text:000023DC                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:000023E1                 jmp     short loc_2382
.text:000023E3 ; ---------------------------------------------------------------------------
.text:000023E3
.text:000023E3 loc_23E3:                               ; CODE XREF: CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)+7Dj
.text:000023E3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000023EA                 mov     eax, [ebp+var_10]
.text:000023ED                 mov     ecx, [ebp+var_C]
.text:000023F0                 mov     large fs:0, ecx
.text:000023F7                 pop     ecx
.text:000023F8                 add     esp, 24h
.text:000023FB                 cmp     ebp, esp
.text:000023FD                 call    __RTC_CheckEsp
.text:00002402                 mov     esp, ebp
.text:00002404                 pop     ebp
.text:00002405                 retn    4
.text:00002405 ??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z endp
.text:00002405
.text:00002405 _text           ends
.text:00002405
.text$x:00002408 ; ===========================================================================
.text$x:00002408
.text$x:00002408 ; Segment type: Pure code
.text$x:00002408 ; Segment permissions: Read/Execute
.text$x:00002408 _text$x         segment para public 'CODE' use32
.text$x:00002408                 assume cs:_text$x
.text$x:00002408                 ;org 2408h
.text$x:00002408 ; COMDAT (pick associative to section at 2314)
.text$x:00002408                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002408
.text$x:00002408 ; =============== S U B R O U T I N E =======================================
.text$x:00002408
.text$x:00002408
.text$x:00002408 __unwindfunclet$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z$0 proc near
.text$x:00002408                                         ; DATA XREF: .xdata$x:0000243Co
.text$x:00002408                 mov     ecx, [ebp-10h]
.text$x:0000240B                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000240B __unwindfunclet$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z$0 endp
.text$x:0000240B
.text$x:00002410
.text$x:00002410 ; =============== S U B R O U T I N E =======================================
.text$x:00002410
.text$x:00002410
.text$x:00002410 __unwindfunclet$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z$1 proc near
.text$x:00002410                                         ; DATA XREF: .xdata$x:00002444o
.text$x:00002410                 mov     eax, [ebp-20h]
.text$x:00002413                 push    eax             ; void *
.text$x:00002414                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002419                 pop     ecx
.text$x:0000241A                 retn
.text$x:0000241A __unwindfunclet$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z$1 endp
.text$x:0000241A
.text$x:0000241B
.text$x:0000241B ; =============== S U B R O U T I N E =======================================
.text$x:0000241B
.text$x:0000241B
.text$x:0000241B __ehhandler$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z proc near
.text$x:0000241B                                         ; DATA XREF: CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)+5o
.text$x:0000241B
.text$x:0000241B arg_4           = dword ptr  8
.text$x:0000241B
.text$x:0000241B                 mov     edx, [esp+arg_4]
.text$x:0000241F                 lea     eax, [edx+0Ch]
.text$x:00002422                 mov     ecx, [edx-1Ch]
.text$x:00002425                 xor     ecx, eax
.text$x:00002427                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000242C                 mov     eax, offset __ehfuncinfo$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z
.text$x:00002431                 jmp     ___CxxFrameHandler3
.text$x:00002431 __ehhandler$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z endp
.text$x:00002431
.text$x:00002431 ; ---------------------------------------------------------------------------
.text$x:00002436                 align 4
.text$x:00002436 _text$x         ends
.text$x:00002436
.xdata$x:00002438 ; ===========================================================================
.xdata$x:00002438
.xdata$x:00002438 ; Segment type: Pure data
.xdata$x:00002438 ; Segment permissions: Read
.xdata$x:00002438 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002438                 assume cs:_xdata$x
.xdata$x:00002438                 ;org 2438h
.xdata$x:00002438 ; COMDAT (pick associative to section at 2314)
.xdata$x:00002438 __unwindtable$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z db 0FFh
.xdata$x:00002438                                         ; DATA XREF: .xdata$x:00002450o
.xdata$x:00002439                 db 0FFh
.xdata$x:0000243A                 db 0FFh
.xdata$x:0000243B                 db 0FFh
.xdata$x:0000243C                 dd offset __unwindfunclet$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z$0
.xdata$x:00002440                 db    0
.xdata$x:00002441                 db    0
.xdata$x:00002442                 db    0
.xdata$x:00002443                 db    0
.xdata$x:00002444                 dd offset __unwindfunclet$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z$1
.xdata$x:00002448 __ehfuncinfo$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z db  22h ; "
.xdata$x:00002448                                         ; DATA XREF: __ehhandler$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z+11o
.xdata$x:00002449                 db    5
.xdata$x:0000244A                 db  93h ; ô
.xdata$x:0000244B                 db  19h
.xdata$x:0000244C                 db    2
.xdata$x:0000244D                 db    0
.xdata$x:0000244E                 db    0
.xdata$x:0000244F                 db    0
.xdata$x:00002450                 dd offset __unwindtable$??0?$CObjectVector@UCArcExtInfo@@@@QAE@ABV0@@Z
.xdata$x:00002454                 db    0
.xdata$x:00002455                 db    0
.xdata$x:00002456                 db    0
.xdata$x:00002457                 db    0
.xdata$x:00002458                 db    0
.xdata$x:00002459                 db    0
.xdata$x:0000245A                 db    0
.xdata$x:0000245B                 db    0
.xdata$x:0000245C                 db    0
.xdata$x:0000245D                 db    0
.xdata$x:0000245E                 db    0
.xdata$x:0000245F                 db    0
.xdata$x:00002460                 db    0
.xdata$x:00002461                 db    0
.xdata$x:00002462                 db    0
.xdata$x:00002463                 db    0
.xdata$x:00002464                 db    0
.xdata$x:00002465                 db    0
.xdata$x:00002466                 db    0
.xdata$x:00002467                 db    0
.xdata$x:00002468                 db    1
.xdata$x:00002469                 db    0
.xdata$x:0000246A                 db    0
.xdata$x:0000246B                 db    0
.xdata$x:0000246B _xdata$x        ends
.xdata$x:0000246B
.text:0000246C ; ===========================================================================
.text:0000246C
.text:0000246C ; Segment type: Pure code
.text:0000246C ; Segment permissions: Read/Execute
.text:0000246C _text           segment para public 'CODE' use32
.text:0000246C                 assume cs:_text
.text:0000246C                 ;org 246Ch
.text:0000246C ; COMDAT (pick any)
.text:0000246C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000246C
.text:0000246C ; =============== S U B R O U T I N E =======================================
.text:0000246C
.text:0000246C ; Attributes: bp-based frame
.text:0000246C
.text:0000246C ; public: __thiscall CObjectVector<class CBuffer<unsigned char>>::CObjectVector<class CBuffer<unsigned char>>(class CObjectVector<class CBuffer<unsigned char>> const &)
.text:0000246C                 public ??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z
.text:0000246C ??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z proc near
.text:0000246C                                         ; CODE XREF: CArcInfoEx::CArcInfoEx(CArcInfoEx const &)+BBp
.text:0000246C
.text:0000246C var_24          = dword ptr -24h
.text:0000246C var_20          = dword ptr -20h
.text:0000246C var_1C          = dword ptr -1Ch
.text:0000246C var_18          = dword ptr -18h
.text:0000246C var_14          = dword ptr -14h
.text:0000246C var_10          = dword ptr -10h
.text:0000246C var_C           = dword ptr -0Ch
.text:0000246C var_4           = dword ptr -4
.text:0000246C arg_0           = dword ptr  8
.text:0000246C
.text:0000246C                 push    ebp
.text:0000246D                 mov     ebp, esp
.text:0000246F                 push    0FFFFFFFFh
.text:00002471                 push    offset __ehhandler$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z
.text:00002476                 mov     eax, large fs:0
.text:0000247C                 push    eax
.text:0000247D                 sub     esp, 18h
.text:00002480                 mov     eax, 0CCCCCCCCh
.text:00002485                 mov     [ebp+var_24], eax
.text:00002488                 mov     [ebp+var_20], eax
.text:0000248B                 mov     [ebp+var_1C], eax
.text:0000248E                 mov     [ebp+var_18], eax
.text:00002491                 mov     [ebp+var_14], eax
.text:00002494                 mov     [ebp+var_10], eax
.text:00002497                 mov     eax, dword ptr ds:___security_cookie
.text:0000249C                 xor     eax, ebp
.text:0000249E                 push    eax
.text:0000249F                 lea     eax, [ebp+var_C]
.text:000024A2                 mov     large fs:0, eax
.text:000024A8                 mov     [ebp+var_10], ecx
.text:000024AB                 mov     ecx, [ebp+var_10]
.text:000024AE                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:000024B3                 mov     [ebp+var_4], 0
.text:000024BA                 mov     ecx, [ebp+arg_0]
.text:000024BD                 call    ?Size@?$CObjectVector@V?$CBuffer@E@@@@QBEIXZ ; CObjectVector<CBuffer<uchar>>::Size(void)
.text:000024C2                 mov     [ebp+var_14], eax
.text:000024C5                 mov     eax, [ebp+var_14]
.text:000024C8                 push    eax
.text:000024C9                 mov     ecx, [ebp+var_10]
.text:000024CC                 call    ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ConstructReserve(uint)
.text:000024D1                 mov     [ebp+var_18], 0
.text:000024D8                 jmp     short loc_24E3
.text:000024DA ; ---------------------------------------------------------------------------
.text:000024DA
.text:000024DA loc_24DA:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)+CDj
.text:000024DA                 mov     ecx, [ebp+var_18]
.text:000024DD                 add     ecx, 1
.text:000024E0                 mov     [ebp+var_18], ecx
.text:000024E3
.text:000024E3 loc_24E3:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)+6Cj
.text:000024E3                 mov     edx, [ebp+var_18]
.text:000024E6                 cmp     edx, [ebp+var_14]
.text:000024E9                 jnb     short loc_253B
.text:000024EB                 push    8               ; unsigned int
.text:000024ED                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000024F2                 add     esp, 4
.text:000024F5                 mov     [ebp+var_20], eax
.text:000024F8                 mov     byte ptr [ebp+var_4], 1
.text:000024FC                 cmp     [ebp+var_20], 0
.text:00002500                 jz      short loc_251C
.text:00002502                 mov     eax, [ebp+var_18]
.text:00002505                 push    eax
.text:00002506                 mov     ecx, [ebp+arg_0]
.text:00002509                 call    ??A?$CObjectVector@V?$CBuffer@E@@@@QBEABV?$CBuffer@E@@I@Z ; CObjectVector<CBuffer<uchar>>::operator[](uint)
.text:0000250E                 push    eax
.text:0000250F                 mov     ecx, [ebp+var_20]
.text:00002512                 call    ??0?$CBuffer@E@@QAE@ABV0@@Z ; CBuffer<uchar>::CBuffer<uchar>(CBuffer<uchar> const &)
.text:00002517                 mov     [ebp+var_24], eax
.text:0000251A                 jmp     short loc_2523
.text:0000251C ; ---------------------------------------------------------------------------
.text:0000251C
.text:0000251C loc_251C:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)+94j
.text:0000251C                 mov     [ebp+var_24], 0
.text:00002523
.text:00002523 loc_2523:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)+AEj
.text:00002523                 mov     ecx, [ebp+var_24]
.text:00002526                 mov     [ebp+var_1C], ecx
.text:00002529                 mov     byte ptr [ebp+var_4], 0
.text:0000252D                 mov     edx, [ebp+var_1C]
.text:00002530                 push    edx
.text:00002531                 mov     ecx, [ebp+var_10]
.text:00002534                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00002539                 jmp     short loc_24DA
.text:0000253B ; ---------------------------------------------------------------------------
.text:0000253B
.text:0000253B loc_253B:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)+7Dj
.text:0000253B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002542                 mov     eax, [ebp+var_10]
.text:00002545                 mov     ecx, [ebp+var_C]
.text:00002548                 mov     large fs:0, ecx
.text:0000254F                 pop     ecx
.text:00002550                 add     esp, 24h
.text:00002553                 cmp     ebp, esp
.text:00002555                 call    __RTC_CheckEsp
.text:0000255A                 mov     esp, ebp
.text:0000255C                 pop     ebp
.text:0000255D                 retn    4
.text:0000255D ??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z endp
.text:0000255D
.text:0000255D _text           ends
.text:0000255D
.text$x:00002560 ; ===========================================================================
.text$x:00002560
.text$x:00002560 ; Segment type: Pure code
.text$x:00002560 ; Segment permissions: Read/Execute
.text$x:00002560 _text$x         segment para public 'CODE' use32
.text$x:00002560                 assume cs:_text$x
.text$x:00002560                 ;org 2560h
.text$x:00002560 ; COMDAT (pick associative to section at 246C)
.text$x:00002560                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002560
.text$x:00002560 ; =============== S U B R O U T I N E =======================================
.text$x:00002560
.text$x:00002560
.text$x:00002560 __unwindfunclet$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z$0 proc near
.text$x:00002560                                         ; DATA XREF: .xdata$x:00002594o
.text$x:00002560                 mov     ecx, [ebp-10h]
.text$x:00002563                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00002563 __unwindfunclet$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z$0 endp
.text$x:00002563
.text$x:00002568
.text$x:00002568 ; =============== S U B R O U T I N E =======================================
.text$x:00002568
.text$x:00002568
.text$x:00002568 __unwindfunclet$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z$1 proc near
.text$x:00002568                                         ; DATA XREF: .xdata$x:0000259Co
.text$x:00002568                 mov     eax, [ebp-20h]
.text$x:0000256B                 push    eax             ; void *
.text$x:0000256C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002571                 pop     ecx
.text$x:00002572                 retn
.text$x:00002572 __unwindfunclet$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z$1 endp
.text$x:00002572
.text$x:00002573
.text$x:00002573 ; =============== S U B R O U T I N E =======================================
.text$x:00002573
.text$x:00002573
.text$x:00002573 __ehhandler$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z proc near
.text$x:00002573                                         ; DATA XREF: CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)+5o
.text$x:00002573
.text$x:00002573 arg_4           = dword ptr  8
.text$x:00002573
.text$x:00002573                 mov     edx, [esp+arg_4]
.text$x:00002577                 lea     eax, [edx+0Ch]
.text$x:0000257A                 mov     ecx, [edx-1Ch]
.text$x:0000257D                 xor     ecx, eax
.text$x:0000257F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002584                 mov     eax, offset __ehfuncinfo$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z
.text$x:00002589                 jmp     ___CxxFrameHandler3
.text$x:00002589 __ehhandler$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z endp
.text$x:00002589
.text$x:00002589 ; ---------------------------------------------------------------------------
.text$x:0000258E                 align 10h
.text$x:0000258E _text$x         ends
.text$x:0000258E
.xdata$x:00002590 ; ===========================================================================
.xdata$x:00002590
.xdata$x:00002590 ; Segment type: Pure data
.xdata$x:00002590 ; Segment permissions: Read
.xdata$x:00002590 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002590                 assume cs:_xdata$x
.xdata$x:00002590                 ;org 2590h
.xdata$x:00002590 ; COMDAT (pick associative to section at 246C)
.xdata$x:00002590 __unwindtable$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z db 0FFh
.xdata$x:00002590                                         ; DATA XREF: .xdata$x:000025A8o
.xdata$x:00002591                 db 0FFh
.xdata$x:00002592                 db 0FFh
.xdata$x:00002593                 db 0FFh
.xdata$x:00002594                 dd offset __unwindfunclet$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z$0
.xdata$x:00002598                 db    0
.xdata$x:00002599                 db    0
.xdata$x:0000259A                 db    0
.xdata$x:0000259B                 db    0
.xdata$x:0000259C                 dd offset __unwindfunclet$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z$1
.xdata$x:000025A0 __ehfuncinfo$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z db  22h ; "
.xdata$x:000025A0                                         ; DATA XREF: __ehhandler$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z+11o
.xdata$x:000025A1                 db    5
.xdata$x:000025A2                 db  93h ; ô
.xdata$x:000025A3                 db  19h
.xdata$x:000025A4                 db    2
.xdata$x:000025A5                 db    0
.xdata$x:000025A6                 db    0
.xdata$x:000025A7                 db    0
.xdata$x:000025A8                 dd offset __unwindtable$??0?$CObjectVector@V?$CBuffer@E@@@@QAE@ABV0@@Z
.xdata$x:000025AC                 align 20h
.xdata$x:000025C0                 db    1
.xdata$x:000025C1                 db    0
.xdata$x:000025C2                 db    0
.xdata$x:000025C3                 db    0
.xdata$x:000025C3 _xdata$x        ends
.xdata$x:000025C3
.text:000025C4 ; ===========================================================================
.text:000025C4
.text:000025C4 ; Segment type: Pure code
.text:000025C4 ; Segment permissions: Read/Execute
.text:000025C4 _text           segment para public 'CODE' use32
.text:000025C4                 assume cs:_text
.text:000025C4                 ;org 25C4h
.text:000025C4 ; COMDAT (pick any)
.text:000025C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000025C4
.text:000025C4 ; =============== S U B R O U T I N E =======================================
.text:000025C4
.text:000025C4 ; Attributes: bp-based frame
.text:000025C4
.text:000025C4 ; public: __thiscall CBuffer<unsigned char>::CBuffer<unsigned char>(void)
.text:000025C4                 public ??0?$CBuffer@E@@QAE@XZ
.text:000025C4 ??0?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: CObjectVector<CBuffer<uchar>>::AddNew(void)+59p
.text:000025C4
.text:000025C4 var_4           = dword ptr -4
.text:000025C4
.text:000025C4                 push    ebp
.text:000025C5                 mov     ebp, esp
.text:000025C7                 push    ecx
.text:000025C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000025CF                 mov     [ebp+var_4], ecx
.text:000025D2                 mov     eax, [ebp+var_4]
.text:000025D5                 mov     dword ptr [eax], 0
.text:000025DB                 mov     ecx, [ebp+var_4]
.text:000025DE                 mov     dword ptr [ecx+4], 0
.text:000025E5                 mov     eax, [ebp+var_4]
.text:000025E8                 mov     esp, ebp
.text:000025EA                 pop     ebp
.text:000025EB                 retn
.text:000025EB ??0?$CBuffer@E@@QAE@XZ endp
.text:000025EB
.text:000025EB _text           ends
.text:000025EB
.text:000025EC ; ===========================================================================
.text:000025EC
.text:000025EC ; Segment type: Pure code
.text:000025EC ; Segment permissions: Read/Execute
.text:000025EC _text           segment para public 'CODE' use32
.text:000025EC                 assume cs:_text
.text:000025EC                 ;org 25ECh
.text:000025EC ; COMDAT (pick any)
.text:000025EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000025EC
.text:000025EC ; =============== S U B R O U T I N E =======================================
.text:000025EC
.text:000025EC ; Attributes: bp-based frame
.text:000025EC
.text:000025EC ; public: __thiscall CBuffer<unsigned char>::~CBuffer<unsigned char>(void)
.text:000025EC                 public ??1?$CBuffer@E@@QAE@XZ
.text:000025EC ??1?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: CBuffer<uchar>::`scalar deleting destructor'(uint)+11p
.text:000025EC
.text:000025EC var_8           = dword ptr -8
.text:000025EC var_4           = dword ptr -4
.text:000025EC
.text:000025EC                 push    ebp
.text:000025ED                 mov     ebp, esp
.text:000025EF                 sub     esp, 8
.text:000025F2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000025F9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002600                 mov     [ebp+var_4], ecx
.text:00002603                 mov     eax, [ebp+var_4]
.text:00002606                 mov     ecx, [eax]
.text:00002608                 mov     [ebp+var_8], ecx
.text:0000260B                 mov     edx, [ebp+var_8]
.text:0000260E                 push    edx             ; void *
.text:0000260F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00002614                 add     esp, 4
.text:00002617                 add     esp, 8
.text:0000261A                 cmp     ebp, esp
.text:0000261C                 call    __RTC_CheckEsp
.text:00002621                 mov     esp, ebp
.text:00002623                 pop     ebp
.text:00002624                 retn
.text:00002624 ??1?$CBuffer@E@@QAE@XZ endp
.text:00002624
.text:00002624 ; ---------------------------------------------------------------------------
.text:00002625                 align 4
.text:00002625 _text           ends
.text:00002625
.text:00002628 ; ===========================================================================
.text:00002628
.text:00002628 ; Segment type: Pure code
.text:00002628 ; Segment permissions: Read/Execute
.text:00002628 _text           segment para public 'CODE' use32
.text:00002628                 assume cs:_text
.text:00002628                 ;org 2628h
.text:00002628 ; COMDAT (pick any)
.text:00002628                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002628
.text:00002628 ; =============== S U B R O U T I N E =======================================
.text:00002628
.text:00002628 ; Attributes: bp-based frame
.text:00002628
.text:00002628 ; public: void __thiscall CBuffer<unsigned char>::Alloc(unsigned int)
.text:00002628                 public ?Alloc@?$CBuffer@E@@QAEXI@Z
.text:00002628 ?Alloc@?$CBuffer@E@@QAEXI@Z proc near   ; CODE XREF: CBuffer<uchar>::CopyFrom(uchar const *,uint)+15p
.text:00002628
.text:00002628 var_8           = dword ptr -8
.text:00002628 var_4           = dword ptr -4
.text:00002628 arg_0           = dword ptr  8
.text:00002628
.text:00002628                 push    ebp
.text:00002629                 mov     ebp, esp
.text:0000262B                 sub     esp, 8
.text:0000262E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002635                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000263C                 mov     [ebp+var_4], ecx
.text:0000263F                 mov     eax, [ebp+var_4]
.text:00002642                 mov     ecx, [ebp+arg_0]
.text:00002645                 cmp     ecx, [eax+4]
.text:00002648                 jz      short loc_2678
.text:0000264A                 mov     ecx, [ebp+var_4]
.text:0000264D                 call    ?Free@?$CBuffer@E@@QAEXXZ ; CBuffer<uchar>::Free(void)
.text:00002652                 cmp     [ebp+arg_0], 0
.text:00002656                 jz      short loc_2678
.text:00002658                 mov     edx, [ebp+arg_0]
.text:0000265B                 push    edx             ; unsigned int
.text:0000265C                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002661                 add     esp, 4
.text:00002664                 mov     [ebp+var_8], eax
.text:00002667                 mov     eax, [ebp+var_4]
.text:0000266A                 mov     ecx, [ebp+var_8]
.text:0000266D                 mov     [eax], ecx
.text:0000266F                 mov     edx, [ebp+var_4]
.text:00002672                 mov     eax, [ebp+arg_0]
.text:00002675                 mov     [edx+4], eax
.text:00002678
.text:00002678 loc_2678:                               ; CODE XREF: CBuffer<uchar>::Alloc(uint)+20j
.text:00002678                                         ; CBuffer<uchar>::Alloc(uint)+2Ej
.text:00002678                 add     esp, 8
.text:0000267B                 cmp     ebp, esp
.text:0000267D                 call    __RTC_CheckEsp
.text:00002682                 mov     esp, ebp
.text:00002684                 pop     ebp
.text:00002685                 retn    4
.text:00002685 ?Alloc@?$CBuffer@E@@QAEXI@Z endp
.text:00002685
.text:00002685 _text           ends
.text:00002685
.text:00002688 ; ===========================================================================
.text:00002688
.text:00002688 ; Segment type: Pure code
.text:00002688 ; Segment permissions: Read/Execute
.text:00002688 _text           segment para public 'CODE' use32
.text:00002688                 assume cs:_text
.text:00002688                 ;org 2688h
.text:00002688 ; COMDAT (pick any)
.text:00002688                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002688
.text:00002688 ; =============== S U B R O U T I N E =======================================
.text:00002688
.text:00002688 ; Attributes: bp-based frame
.text:00002688
.text:00002688 ; private: void __thiscall CRecordVector<int>::ReserveOnePosition(void)
.text:00002688                 public ?ReserveOnePosition@?$CRecordVector@H@@AAEXXZ
.text:00002688 ?ReserveOnePosition@?$CRecordVector@H@@AAEXXZ proc near
.text:00002688                                         ; CODE XREF: CRecordVector<int>::Add(int)+1Ap
.text:00002688
.text:00002688 var_14          = dword ptr -14h
.text:00002688 var_10          = dword ptr -10h
.text:00002688 Dst             = dword ptr -0Ch
.text:00002688 var_8           = dword ptr -8
.text:00002688 var_4           = dword ptr -4
.text:00002688
.text:00002688                 push    ebp
.text:00002689                 mov     ebp, esp
.text:0000268B                 sub     esp, 14h
.text:0000268E                 mov     eax, 0CCCCCCCCh
.text:00002693                 mov     [ebp+var_14], eax
.text:00002696                 mov     [ebp+var_10], eax
.text:00002699                 mov     [ebp+Dst], eax
.text:0000269C                 mov     [ebp+var_8], eax
.text:0000269F                 mov     [ebp+var_4], eax
.text:000026A2                 mov     [ebp+var_4], ecx
.text:000026A5                 mov     eax, [ebp+var_4]
.text:000026A8                 mov     ecx, [ebp+var_4]
.text:000026AB                 mov     edx, [eax+4]
.text:000026AE                 cmp     edx, [ecx+8]
.text:000026B1                 jnz     loc_273C
.text:000026B7                 mov     eax, [ebp+var_4]
.text:000026BA                 mov     ecx, [eax+8]
.text:000026BD                 shr     ecx, 2
.text:000026C0                 mov     edx, [ebp+var_4]
.text:000026C3                 mov     eax, [edx+8]
.text:000026C6                 lea     ecx, [eax+ecx+1]
.text:000026CA                 mov     [ebp+var_8], ecx
.text:000026CD                 xor     ecx, ecx
.text:000026CF                 mov     eax, [ebp+var_8]
.text:000026D2                 mov     edx, 4
.text:000026D7                 mul     edx
.text:000026D9                 seto    cl
.text:000026DC                 neg     ecx
.text:000026DE                 or      ecx, eax
.text:000026E0                 push    ecx             ; unsigned int
.text:000026E1                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000026E6                 add     esp, 4
.text:000026E9                 mov     [ebp+var_10], eax
.text:000026EC                 mov     eax, [ebp+var_10]
.text:000026EF                 mov     [ebp+Dst], eax
.text:000026F2                 mov     ecx, [ebp+var_4]
.text:000026F5                 cmp     dword ptr [ecx+4], 0
.text:000026F9                 jz      short loc_2717
.text:000026FB                 mov     edx, [ebp+var_4]
.text:000026FE                 mov     eax, [edx+4]
.text:00002701                 shl     eax, 2
.text:00002704                 push    eax             ; Size
.text:00002705                 mov     ecx, [ebp+var_4]
.text:00002708                 mov     edx, [ecx]
.text:0000270A                 push    edx             ; Src
.text:0000270B                 mov     eax, [ebp+Dst]
.text:0000270E                 push    eax             ; Dst
.text:0000270F                 call    _memcpy
.text:00002714                 add     esp, 0Ch
.text:00002717
.text:00002717 loc_2717:                               ; CODE XREF: CRecordVector<int>::ReserveOnePosition(void)+71j
.text:00002717                 mov     ecx, [ebp+var_4]
.text:0000271A                 mov     edx, [ecx]
.text:0000271C                 mov     [ebp+var_14], edx
.text:0000271F                 mov     eax, [ebp+var_14]
.text:00002722                 push    eax             ; void *
.text:00002723                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00002728                 add     esp, 4
.text:0000272B                 mov     ecx, [ebp+var_4]
.text:0000272E                 mov     edx, [ebp+Dst]
.text:00002731                 mov     [ecx], edx
.text:00002733                 mov     eax, [ebp+var_4]
.text:00002736                 mov     ecx, [ebp+var_8]
.text:00002739                 mov     [eax+8], ecx
.text:0000273C
.text:0000273C loc_273C:                               ; CODE XREF: CRecordVector<int>::ReserveOnePosition(void)+29j
.text:0000273C                 add     esp, 14h
.text:0000273F                 cmp     ebp, esp
.text:00002741                 call    __RTC_CheckEsp
.text:00002746                 mov     esp, ebp
.text:00002748                 pop     ebp
.text:00002749                 retn
.text:00002749 ?ReserveOnePosition@?$CRecordVector@H@@AAEXXZ endp
.text:00002749
.text:00002749 ; ---------------------------------------------------------------------------
.text:0000274A                 align 4
.text:0000274A _text           ends
.text:0000274A
.text:0000274C ; ===========================================================================
.text:0000274C
.text:0000274C ; Segment type: Pure code
.text:0000274C ; Segment permissions: Read/Execute
.text:0000274C _text           segment para public 'CODE' use32
.text:0000274C                 assume cs:_text
.text:0000274C                 ;org 274Ch
.text:0000274C ; COMDAT (pick any)
.text:0000274C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000274C
.text:0000274C ; =============== S U B R O U T I N E =======================================
.text:0000274C
.text:0000274C ; Attributes: bp-based frame
.text:0000274C
.text:0000274C ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:0000274C                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:0000274C ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:0000274C                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:0000274C
.text:0000274C var_14          = dword ptr -14h
.text:0000274C var_10          = dword ptr -10h
.text:0000274C Dst             = dword ptr -0Ch
.text:0000274C var_8           = dword ptr -8
.text:0000274C var_4           = dword ptr -4
.text:0000274C
.text:0000274C                 push    ebp
.text:0000274D                 mov     ebp, esp
.text:0000274F                 sub     esp, 14h
.text:00002752                 mov     eax, 0CCCCCCCCh
.text:00002757                 mov     [ebp+var_14], eax
.text:0000275A                 mov     [ebp+var_10], eax
.text:0000275D                 mov     [ebp+Dst], eax
.text:00002760                 mov     [ebp+var_8], eax
.text:00002763                 mov     [ebp+var_4], eax
.text:00002766                 mov     [ebp+var_4], ecx
.text:00002769                 mov     eax, [ebp+var_4]
.text:0000276C                 mov     ecx, [ebp+var_4]
.text:0000276F                 mov     edx, [eax+4]
.text:00002772                 cmp     edx, [ecx+8]
.text:00002775                 jnz     loc_2800
.text:0000277B                 mov     eax, [ebp+var_4]
.text:0000277E                 mov     ecx, [eax+8]
.text:00002781                 shr     ecx, 2
.text:00002784                 mov     edx, [ebp+var_4]
.text:00002787                 mov     eax, [edx+8]
.text:0000278A                 lea     ecx, [eax+ecx+1]
.text:0000278E                 mov     [ebp+var_8], ecx
.text:00002791                 xor     ecx, ecx
.text:00002793                 mov     eax, [ebp+var_8]
.text:00002796                 mov     edx, 4
.text:0000279B                 mul     edx
.text:0000279D                 seto    cl
.text:000027A0                 neg     ecx
.text:000027A2                 or      ecx, eax
.text:000027A4                 push    ecx             ; unsigned int
.text:000027A5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000027AA                 add     esp, 4
.text:000027AD                 mov     [ebp+var_10], eax
.text:000027B0                 mov     eax, [ebp+var_10]
.text:000027B3                 mov     [ebp+Dst], eax
.text:000027B6                 mov     ecx, [ebp+var_4]
.text:000027B9                 cmp     dword ptr [ecx+4], 0
.text:000027BD                 jz      short loc_27DB
.text:000027BF                 mov     edx, [ebp+var_4]
.text:000027C2                 mov     eax, [edx+4]
.text:000027C5                 shl     eax, 2
.text:000027C8                 push    eax             ; Size
.text:000027C9                 mov     ecx, [ebp+var_4]
.text:000027CC                 mov     edx, [ecx]
.text:000027CE                 push    edx             ; Src
.text:000027CF                 mov     eax, [ebp+Dst]
.text:000027D2                 push    eax             ; Dst
.text:000027D3                 call    _memcpy
.text:000027D8                 add     esp, 0Ch
.text:000027DB
.text:000027DB loc_27DB:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:000027DB                 mov     ecx, [ebp+var_4]
.text:000027DE                 mov     edx, [ecx]
.text:000027E0                 mov     [ebp+var_14], edx
.text:000027E3                 mov     eax, [ebp+var_14]
.text:000027E6                 push    eax             ; void *
.text:000027E7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000027EC                 add     esp, 4
.text:000027EF                 mov     ecx, [ebp+var_4]
.text:000027F2                 mov     edx, [ebp+Dst]
.text:000027F5                 mov     [ecx], edx
.text:000027F7                 mov     eax, [ebp+var_4]
.text:000027FA                 mov     ecx, [ebp+var_8]
.text:000027FD                 mov     [eax+8], ecx
.text:00002800
.text:00002800 loc_2800:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:00002800                 add     esp, 14h
.text:00002803                 cmp     ebp, esp
.text:00002805                 call    __RTC_CheckEsp
.text:0000280A                 mov     esp, ebp
.text:0000280C                 pop     ebp
.text:0000280D                 retn
.text:0000280D ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:0000280D
.text:0000280D ; ---------------------------------------------------------------------------
.text:0000280E                 align 10h
.text:0000280E _text           ends
.text:0000280E
.text:00002810 ; ===========================================================================
.text:00002810
.text:00002810 ; Segment type: Pure code
.text:00002810 ; Segment permissions: Read/Execute
.text:00002810 _text           segment para public 'CODE' use32
.text:00002810                 assume cs:_text
.text:00002810                 ;org 2810h
.text:00002810 ; COMDAT (pick any)
.text:00002810                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002810
.text:00002810 ; =============== S U B R O U T I N E =======================================
.text:00002810
.text:00002810 ; Attributes: bp-based frame
.text:00002810
.text:00002810 ; public: void __thiscall CRecordVector<void *>::ConstructReserve(unsigned int)
.text:00002810                 public ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z
.text:00002810 ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:00002810                                         ; CODE XREF: CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)+60p
.text:00002810                                         ; CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)+60p
.text:00002810
.text:00002810 var_8           = dword ptr -8
.text:00002810 var_4           = dword ptr -4
.text:00002810 arg_0           = dword ptr  8
.text:00002810
.text:00002810                 push    ebp
.text:00002811                 mov     ebp, esp
.text:00002813                 sub     esp, 8
.text:00002816                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000281D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002824                 mov     [ebp+var_4], ecx
.text:00002827                 cmp     [ebp+arg_0], 0
.text:0000282B                 jz      short loc_285D
.text:0000282D                 xor     ecx, ecx
.text:0000282F                 mov     eax, [ebp+arg_0]
.text:00002832                 mov     edx, 4
.text:00002837                 mul     edx
.text:00002839                 seto    cl
.text:0000283C                 neg     ecx
.text:0000283E                 or      ecx, eax
.text:00002840                 push    ecx             ; unsigned int
.text:00002841                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002846                 add     esp, 4
.text:00002849                 mov     [ebp+var_8], eax
.text:0000284C                 mov     eax, [ebp+var_4]
.text:0000284F                 mov     ecx, [ebp+var_8]
.text:00002852                 mov     [eax], ecx
.text:00002854                 mov     edx, [ebp+var_4]
.text:00002857                 mov     eax, [ebp+arg_0]
.text:0000285A                 mov     [edx+8], eax
.text:0000285D
.text:0000285D loc_285D:                               ; CODE XREF: CRecordVector<void *>::ConstructReserve(uint)+1Bj
.text:0000285D                 add     esp, 8
.text:00002860                 cmp     ebp, esp
.text:00002862                 call    __RTC_CheckEsp
.text:00002867                 mov     esp, ebp
.text:00002869                 pop     ebp
.text:0000286A                 retn    4
.text:0000286A ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:0000286A
.text:0000286A ; ---------------------------------------------------------------------------
.text:0000286D                 align 10h
.text:0000286D _text           ends
.text:0000286D
.text:00002870 ; ===========================================================================
.text:00002870
.text:00002870 ; Segment type: Pure code
.text:00002870 ; Segment permissions: Read/Execute
.text:00002870 _text           segment para public 'CODE' use32
.text:00002870                 assume cs:_text
.text:00002870                 ;org 2870h
.text:00002870 ; COMDAT (pick any)
.text:00002870                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002870
.text:00002870 ; =============== S U B R O U T I N E =======================================
.text:00002870
.text:00002870 ; Attributes: bp-based frame
.text:00002870
.text:00002870 ; public: void __thiscall CRecordVector<void *>::AddInReserved(void * const)
.text:00002870                 public ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z
.text:00002870 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z proc near
.text:00002870                                         ; CODE XREF: CObjectVector<CArcExtInfo>::CObjectVector<CArcExtInfo>(CObjectVector<CArcExtInfo> const &)+C8p
.text:00002870                                         ; CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)+C8p
.text:00002870
.text:00002870 var_4           = dword ptr -4
.text:00002870 arg_0           = dword ptr  8
.text:00002870
.text:00002870                 push    ebp
.text:00002871                 mov     ebp, esp
.text:00002873                 push    ecx
.text:00002874                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000287B                 mov     [ebp+var_4], ecx
.text:0000287E                 mov     eax, [ebp+var_4]
.text:00002881                 mov     ecx, [eax+4]
.text:00002884                 mov     edx, [ebp+var_4]
.text:00002887                 mov     eax, [edx]
.text:00002889                 mov     edx, [ebp+arg_0]
.text:0000288C                 mov     [eax+ecx*4], edx
.text:0000288F                 mov     eax, [ebp+var_4]
.text:00002892                 mov     ecx, [eax+4]
.text:00002895                 add     ecx, 1
.text:00002898                 mov     edx, [ebp+var_4]
.text:0000289B                 mov     [edx+4], ecx
.text:0000289E                 mov     esp, ebp
.text:000028A0                 pop     ebp
.text:000028A1                 retn    4
.text:000028A1 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z endp
.text:000028A1
.text:000028A1 _text           ends
.text:000028A1
.text:000028A4 ; ===========================================================================
.text:000028A4
.text:000028A4 ; Segment type: Pure code
.text:000028A4 ; Segment permissions: Read/Execute
.text:000028A4 _text           segment para public 'CODE' use32
.text:000028A4                 assume cs:_text
.text:000028A4                 ;org 28A4h
.text:000028A4 ; COMDAT (pick any)
.text:000028A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000028A4
.text:000028A4 ; =============== S U B R O U T I N E =======================================
.text:000028A4
.text:000028A4 ; Attributes: bp-based frame
.text:000028A4
.text:000028A4 ; public: unsigned int __thiscall CObjectVector<class CBuffer<unsigned char>>::Size(void)const
.text:000028A4                 public ?Size@?$CObjectVector@V?$CBuffer@E@@@@QBEIXZ
.text:000028A4 ?Size@?$CObjectVector@V?$CBuffer@E@@@@QBEIXZ proc near
.text:000028A4                                         ; CODE XREF: CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)+51p
.text:000028A4
.text:000028A4 var_4           = dword ptr -4
.text:000028A4
.text:000028A4                 push    ebp
.text:000028A5                 mov     ebp, esp
.text:000028A7                 push    ecx
.text:000028A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000028AF                 mov     [ebp+var_4], ecx
.text:000028B2                 mov     ecx, [ebp+var_4]
.text:000028B5                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000028BA                 add     esp, 4
.text:000028BD                 cmp     ebp, esp
.text:000028BF                 call    __RTC_CheckEsp
.text:000028C4                 mov     esp, ebp
.text:000028C6                 pop     ebp
.text:000028C7                 retn
.text:000028C7 ?Size@?$CObjectVector@V?$CBuffer@E@@@@QBEIXZ endp
.text:000028C7
.text:000028C7 _text           ends
.text:000028C7
.text:000028C8 ; ===========================================================================
.text:000028C8
.text:000028C8 ; Segment type: Pure code
.text:000028C8 ; Segment permissions: Read/Execute
.text:000028C8 _text           segment para public 'CODE' use32
.text:000028C8                 assume cs:_text
.text:000028C8                 ;org 28C8h
.text:000028C8 ; COMDAT (pick any)
.text:000028C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000028C8
.text:000028C8 ; =============== S U B R O U T I N E =======================================
.text:000028C8
.text:000028C8 ; Attributes: bp-based frame
.text:000028C8
.text:000028C8 ; public: class CBuffer<unsigned char> const & __thiscall CObjectVector<class CBuffer<unsigned char>>::operator[](unsigned int)const
.text:000028C8                 public ??A?$CObjectVector@V?$CBuffer@E@@@@QBEABV?$CBuffer@E@@I@Z
.text:000028C8 ??A?$CObjectVector@V?$CBuffer@E@@@@QBEABV?$CBuffer@E@@I@Z proc near
.text:000028C8                                         ; CODE XREF: CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)+9Dp
.text:000028C8
.text:000028C8 var_4           = dword ptr -4
.text:000028C8 arg_0           = dword ptr  8
.text:000028C8
.text:000028C8                 push    ebp
.text:000028C9                 mov     ebp, esp
.text:000028CB                 push    ecx
.text:000028CC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000028D3                 mov     [ebp+var_4], ecx
.text:000028D6                 mov     eax, [ebp+arg_0]
.text:000028D9                 push    eax
.text:000028DA                 mov     ecx, [ebp+var_4]
.text:000028DD                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000028E2                 mov     eax, [eax]
.text:000028E4                 add     esp, 4
.text:000028E7                 cmp     ebp, esp
.text:000028E9                 call    __RTC_CheckEsp
.text:000028EE                 mov     esp, ebp
.text:000028F0                 pop     ebp
.text:000028F1                 retn    4
.text:000028F1 ??A?$CObjectVector@V?$CBuffer@E@@@@QBEABV?$CBuffer@E@@I@Z endp
.text:000028F1
.text:000028F1 _text           ends
.text:000028F1
.text:000028F4 ; ===========================================================================
.text:000028F4
.text:000028F4 ; Segment type: Pure code
.text:000028F4 ; Segment permissions: Read/Execute
.text:000028F4 _text           segment para public 'CODE' use32
.text:000028F4                 assume cs:_text
.text:000028F4                 ;org 28F4h
.text:000028F4 ; COMDAT (pick any)
.text:000028F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000028F4
.text:000028F4 ; =============== S U B R O U T I N E =======================================
.text:000028F4
.text:000028F4 ; Attributes: bp-based frame
.text:000028F4
.text:000028F4 ; public: void __thiscall CBuffer<unsigned char>::Free(void)
.text:000028F4                 public ?Free@?$CBuffer@E@@QAEXXZ
.text:000028F4 ?Free@?$CBuffer@E@@QAEXXZ proc near     ; CODE XREF: CBuffer<uchar>::Alloc(uint)+25p
.text:000028F4
.text:000028F4 var_8           = dword ptr -8
.text:000028F4 var_4           = dword ptr -4
.text:000028F4
.text:000028F4                 push    ebp
.text:000028F5                 mov     ebp, esp
.text:000028F7                 sub     esp, 8
.text:000028FA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002901                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002908                 mov     [ebp+var_4], ecx
.text:0000290B                 mov     eax, [ebp+var_4]
.text:0000290E                 cmp     dword ptr [eax], 0
.text:00002911                 jz      short loc_2930
.text:00002913                 mov     ecx, [ebp+var_4]
.text:00002916                 mov     edx, [ecx]
.text:00002918                 mov     [ebp+var_8], edx
.text:0000291B                 mov     eax, [ebp+var_8]
.text:0000291E                 push    eax             ; void *
.text:0000291F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00002924                 add     esp, 4
.text:00002927                 mov     ecx, [ebp+var_4]
.text:0000292A                 mov     dword ptr [ecx], 0
.text:00002930
.text:00002930 loc_2930:                               ; CODE XREF: CBuffer<uchar>::Free(void)+1Dj
.text:00002930                 mov     edx, [ebp+var_4]
.text:00002933                 mov     dword ptr [edx+4], 0
.text:0000293A                 add     esp, 8
.text:0000293D                 cmp     ebp, esp
.text:0000293F                 call    __RTC_CheckEsp
.text:00002944                 mov     esp, ebp
.text:00002946                 pop     ebp
.text:00002947                 retn
.text:00002947 ?Free@?$CBuffer@E@@QAEXXZ endp
.text:00002947
.text:00002947 _text           ends
.text:00002947
.text:00002948 ; ===========================================================================
.text:00002948
.text:00002948 ; Segment type: Pure code
.text:00002948 ; Segment permissions: Read/Execute
.text:00002948 _text           segment para public 'CODE' use32
.text:00002948                 assume cs:_text
.text:00002948                 ;org 2948h
.text:00002948 ; COMDAT (pick any)
.text:00002948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002948
.text:00002948 ; =============== S U B R O U T I N E =======================================
.text:00002948
.text:00002948 ; Attributes: bp-based frame
.text:00002948
.text:00002948 ; public: __thiscall CBuffer<unsigned char>::CBuffer<unsigned char>(class CBuffer<unsigned char> const &)
.text:00002948                 public ??0?$CBuffer@E@@QAE@ABV0@@Z
.text:00002948 ??0?$CBuffer@E@@QAE@ABV0@@Z proc near   ; CODE XREF: CObjectVector<CBuffer<uchar>>::CObjectVector<CBuffer<uchar>>(CObjectVector<CBuffer<uchar>> const &)+A6p
.text:00002948
.text:00002948 var_C           = dword ptr -0Ch
.text:00002948 Size            = dword ptr -8
.text:00002948 var_4           = dword ptr -4
.text:00002948 arg_0           = dword ptr  8
.text:00002948
.text:00002948                 push    ebp
.text:00002949                 mov     ebp, esp
.text:0000294B                 sub     esp, 0Ch
.text:0000294E                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00002955                 mov     [ebp+Size], 0CCCCCCCCh
.text:0000295C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002963                 mov     [ebp+var_4], ecx
.text:00002966                 mov     eax, [ebp+var_4]
.text:00002969                 mov     dword ptr [eax], 0
.text:0000296F                 mov     ecx, [ebp+var_4]
.text:00002972                 mov     dword ptr [ecx+4], 0
.text:00002979                 mov     edx, [ebp+arg_0]
.text:0000297C                 mov     eax, [edx+4]
.text:0000297F                 mov     [ebp+Size], eax
.text:00002982                 cmp     [ebp+Size], 0
.text:00002986                 jz      short loc_29C0
.text:00002988                 mov     ecx, [ebp+Size]
.text:0000298B                 push    ecx             ; unsigned int
.text:0000298C                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002991                 add     esp, 4
.text:00002994                 mov     [ebp+var_C], eax
.text:00002997                 mov     edx, [ebp+var_4]
.text:0000299A                 mov     eax, [ebp+var_C]
.text:0000299D                 mov     [edx], eax
.text:0000299F                 mov     ecx, [ebp+Size]
.text:000029A2                 push    ecx             ; Size
.text:000029A3                 mov     edx, [ebp+arg_0]
.text:000029A6                 mov     eax, [edx]
.text:000029A8                 push    eax             ; Src
.text:000029A9                 mov     ecx, [ebp+var_4]
.text:000029AC                 mov     edx, [ecx]
.text:000029AE                 push    edx             ; Dst
.text:000029AF                 call    _memcpy
.text:000029B4                 add     esp, 0Ch
.text:000029B7                 mov     eax, [ebp+var_4]
.text:000029BA                 mov     ecx, [ebp+Size]
.text:000029BD                 mov     [eax+4], ecx
.text:000029C0
.text:000029C0 loc_29C0:                               ; CODE XREF: CBuffer<uchar>::CBuffer<uchar>(CBuffer<uchar> const &)+3Ej
.text:000029C0                 mov     eax, [ebp+var_4]
.text:000029C3                 add     esp, 0Ch
.text:000029C6                 cmp     ebp, esp
.text:000029C8                 call    __RTC_CheckEsp
.text:000029CD                 mov     esp, ebp
.text:000029CF                 pop     ebp
.text:000029D0                 retn    4
.text:000029D0 ??0?$CBuffer@E@@QAE@ABV0@@Z endp
.text:000029D0
.text:000029D0 _text           ends
.text:000029D0
UNDEF:000029E0 ; ===========================================================================
UNDEF:000029E0
UNDEF:000029E0 ; Segment type: Externs
UNDEF:000029E0 ; UNDEF
UNDEF:000029E0                 extrn __RTC_Shutdown:near
UNDEF:000029E0                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:000029E4                 extrn __RTC_InitBase:near
UNDEF:000029E4                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:000029E8                 extrn __RTC_CheckEsp:near
UNDEF:000029E8                                         ; CODE XREF: CArcInfoEx::FindExtension(UString const &)+6Ep
UNDEF:000029E8                                         ; CArcInfoEx::AddExts(UString const &,UString const &)+14Fp ...
UNDEF:000029EC ; bool __stdcall StringsAreEqualNoCase(const wchar_t *, const wchar_t *)
UNDEF:000029EC                 extrn ?StringsAreEqualNoCase@@YG_NPB_W0@Z:near
UNDEF:000029EC                                         ; CODE XREF: UString::IsEqualTo_NoCase(wchar_t const *)+18p
UNDEF:000029F0 ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:000029F0                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:000029F0                                         ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+AEp
UNDEF:000029F0                                         ; CArcInfoEx::AddExts(UString const &,UString const &)+D0p
UNDEF:000029F4                 extrn ___security_cookie:near
UNDEF:000029F4                                         ; DATA XREF: CArcInfoEx::AddExts(UString const &,UString const &)+26r
UNDEF:000029F4                                         ; SplitString(UString const &,CObjectVector<UString> &)+31r ...
UNDEF:000029F8                 extrn ___CxxFrameHandler3:near
UNDEF:000029F8                                         ; CODE XREF: __ehhandler$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z+16j
UNDEF:000029F8                                         ; __ehhandler$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z+16j ...
UNDEF:000029FC ; __fastcall __security_check_cookie(x)
UNDEF:000029FC                 extrn @__security_check_cookie@4:near
UNDEF:000029FC                                         ; CODE XREF: __ehhandler$?AddExts@CArcInfoEx@@QAEXABVUString@@0@Z+Cp
UNDEF:000029FC                                         ; __ehhandler$?SplitString@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z+Cp ...
UNDEF:00002A00 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00002A00                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00002A00                                         ; CODE XREF: CArcInfoEx::AddExts(UString const &,UString const &)+137p
UNDEF:00002A00                                         ; SplitString(UString const &,CObjectVector<UString> &)+11Cp ...
UNDEF:00002A04 ; int __cdecl _wcscmp(const wchar_t *Str1, const wchar_t *Str2)
UNDEF:00002A04                 extrn __imp__wcscmp:near
UNDEF:00002A04                                         ; CODE XREF: operator==(UString const &,wchar_t const *)+13p
UNDEF:00002A04                                         ; operator!=(UString const &,wchar_t const *)+13p
UNDEF:00002A04                                         ; DATA XREF: ...
UNDEF:00002A08 ; public: __thiscall UString::UString(void)
UNDEF:00002A08                 extrn ??0UString@@QAE@XZ:near
UNDEF:00002A08                                         ; CODE XREF: SplitString(UString const &,CObjectVector<UString> &)+4Dp
UNDEF:00002A08                                         ; CCodecs::Load(void)+B2p ...
UNDEF:00002A0C ; void __cdecl operator delete(void *)
UNDEF:00002A0C                 extrn ??3@YAXPAX@Z:near ; CODE XREF: UString::~UString(void)+23p
UNDEF:00002A0C                                         ; __unwindfunclet$?Add@?$CObjectVector@UCArcExtInfo@@@@QAEIABUCArcExtInfo@@@Z$0+4p ...
UNDEF:00002A10 ; void __thiscall UString::Grow_1(UString *__hidden this)
UNDEF:00002A10                 extrn ?Grow_1@UString@@AAEXXZ:near
UNDEF:00002A10                                         ; CODE XREF: UString::operator+=(wchar_t)+2Fp
UNDEF:00002A14 ; void __thiscall UString::SetFromAscii(UString *__hidden this, const char *)
UNDEF:00002A14                 extrn ?SetFromAscii@UString@@QAEXPBD@Z:near
UNDEF:00002A14                                         ; CODE XREF: CCodecs::Load(void)+8Fp
UNDEF:00002A14                                         ; CCodecs::Load(void)+DAp ...
UNDEF:00002A18 ; public: __thiscall UString::UString(wchar_t const *)
UNDEF:00002A18                 extrn ??0UString@@QAE@PB_W@Z:near
UNDEF:00002A18                                         ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+6Dp
UNDEF:00002A1C ; int __thiscall UString::ReverseFind_PathSepar(UString *__hidden this)
UNDEF:00002A1C                 extrn ?ReverseFind_PathSepar@UString@@QBEHXZ:near
UNDEF:00002A1C                                         ; CODE XREF: CCodecs::FindFormatForArchiveName(UString const &)+48p
UNDEF:00002A20 ; bool __stdcall StringsAreEqualNoCase_Ascii(const wchar_t *, const char *)
UNDEF:00002A20                 extrn ?StringsAreEqualNoCase_Ascii@@YG_NPB_WPBD@Z:near
UNDEF:00002A20                                         ; CODE XREF: UString::IsEqualTo_Ascii_NoCase(char const *)+18p
UNDEF:00002A24 ; int __thiscall UString::ReverseFind(UString *__hidden this, wchar_t)
UNDEF:00002A24                 extrn ?ReverseFind@UString@@QBEH_W@Z:near
UNDEF:00002A24                                         ; CODE XREF: UString::ReverseFind_Dot(void)+13p
UNDEF:00002A28 ; private: __thiscall UString::UString(unsigned int, wchar_t const *)
UNDEF:00002A28                 extrn ??0UString@@AAE@IPB_W@Z:near
UNDEF:00002A28                                         ; CODE XREF: UString::Mid(uint,uint)+31p
UNDEF:00002A2C ; int __stdcall FindCharPosInString(const wchar_t *, wchar_t)
UNDEF:00002A2C                 extrn ?FindCharPosInString@@YGHPB_W_W@Z:near
UNDEF:00002A2C                                         ; CODE XREF: UString::Find(wchar_t,uint)+2Fp
UNDEF:00002A30 ; void *__cdecl operator new(unsigned int)
UNDEF:00002A30                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CObjectVector<CArcExtInfo>::Add(CArcExtInfo const &)+3Bp
UNDEF:00002A30                                         ; CObjectVector<CBuffer<uchar>>::AddNew(void)+3Ep ...
UNDEF:00002A34 ; public: __thiscall UString::UString(class UString const &)
UNDEF:00002A34                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:00002A34                                         ; CODE XREF: CObjectVector<UString>::Add(UString const &)+5Ap
UNDEF:00002A34                                         ; CArcExtInfo::CArcExtInfo(CArcExtInfo const &)+34p ...
UNDEF:00002A38 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00002A38                 extrn _memcpy:near      ; CODE XREF: CBuffer<uchar>::CopyFrom(uchar const *,uint)+2Ep
UNDEF:00002A38                                         ; CRecordVector<int>::ReserveOnePosition(void)+87p ...
UNDEF:00002A38
UNDEF:00002A38
UNDEF:00002A38                 end