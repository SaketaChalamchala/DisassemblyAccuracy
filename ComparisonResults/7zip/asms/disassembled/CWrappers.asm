.text:00000000 ;
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text:00000000 ; |                      License info: 48-3677-7074-51                      |
.text:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ;
.text:00000000 ; Input MD5   : DCC12D67442CB0D6F2260D06AA2AA9A2
.text:00000000 ; Input CRC32 : 8A4E0440
.text:00000000
.text:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\CWrappers.obj
.text:00000000 ; Format      : COFF (X386MAGIC)
.text:00000000 ; includelib "uuid.lib"
.text:00000000 ; includelib "MSVCRTD"
.text:00000000 ; includelib "OLDNAMES"
.text:00000000
.text:00000000                 .686p
.text:00000000                 .mmx
.text:00000000                 .model flat
.text:00000000
.text:00000000 ; ===========================================================================
.text:00000000
.text:00000000 ; Segment type: Pure code
.text:00000000 ; Segment permissions: Read/Execute
.text:00000000 _text           segment para public 'CODE' use32
.text:00000000                 assume cs:_text
.text:00000000                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000000
.text:00000000 ; =============== S U B R O U T I N E =======================================
.text:00000000
.text:00000000 ; Attributes: bp-based frame
.text:00000000
.text:00000000 ; _DWORD __thiscall CCompressProgressWrap::CCompressProgressWrap(CCompressProgressWrap *this, struct ICompressProgressInfo *)
.text:00000000                 public ??0CCompressProgressWrap@@QAE@PAUICompressProgressInfo@@@Z
.text:00000000 ??0CCompressProgressWrap@@QAE@PAUICompressProgressInfo@@@Z proc near
.text:00000000
.text:00000000 var_4           = dword ptr -4
.text:00000000 arg_0           = dword ptr  8
.text:00000000
.text:00000000                 push    ebp
.text:00000001                 mov     ebp, esp
.text:00000003                 push    ecx
.text:00000004                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000000B                 mov     [ebp+var_4], ecx
.text:0000000E                 mov     eax, [ebp+var_4]
.text:00000011                 mov     dword ptr [eax], offset ?CompressProgress@@YGHPAX_K1@Z ; CompressProgress(void *,unsigned __int64,unsigned __int64)
.text:00000017                 mov     ecx, [ebp+var_4]
.text:0000001A                 mov     edx, [ebp+arg_0]
.text:0000001D                 mov     [ecx+4], edx
.text:00000020                 mov     eax, [ebp+var_4]
.text:00000023                 mov     dword ptr [eax+8], 0
.text:0000002A                 mov     eax, [ebp+var_4]
.text:0000002D                 mov     esp, ebp
.text:0000002F                 pop     ebp
.text:00000030                 retn    4
.text:00000030 ??0CCompressProgressWrap@@QAE@PAUICompressProgressInfo@@@Z endp
.text:00000030
.text:00000030 ; ---------------------------------------------------------------------------
.text:00000033                 align 10h
.text:00000040
.text:00000040 ; =============== S U B R O U T I N E =======================================
.text:00000040
.text:00000040 ; Attributes: bp-based frame
.text:00000040
.text:00000040 ; int __stdcall CompressProgress(void *, unsigned __int64, unsigned __int64)
.text:00000040 ?CompressProgress@@YGHPAX_K1@Z proc near
.text:00000040                                         ; DATA XREF: CCompressProgressWrap::CCompressProgressWrap(ICompressProgressInfo *)+11o
.text:00000040
.text:00000040 var_C           = dword ptr -0Ch
.text:00000040 var_8           = dword ptr -8
.text:00000040 var_4           = dword ptr -4
.text:00000040 arg_0           = dword ptr  8
.text:00000040 arg_4           = dword ptr  0Ch
.text:00000040 arg_8           = dword ptr  10h
.text:00000040 arg_C           = dword ptr  14h
.text:00000040 arg_10          = dword ptr  18h
.text:00000040
.text:00000040                 push    ebp
.text:00000041                 mov     ebp, esp
.text:00000043                 sub     esp, 0Ch
.text:00000046                 push    esi
.text:00000047                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000004E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000055                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000005C                 mov     eax, [ebp+arg_0]
.text:0000005F                 mov     [ebp+var_4], eax
.text:00000062                 mov     ecx, [ebp+arg_C]
.text:00000065                 and     ecx, [ebp+arg_10]
.text:00000068                 cmp     ecx, 0FFFFFFFFh
.text:0000006B                 jnz     short loc_76
.text:0000006D                 mov     [ebp+var_8], 0
.text:00000074                 jmp     short loc_7C
.text:00000076 ; ---------------------------------------------------------------------------
.text:00000076
.text:00000076 loc_76:                                 ; CODE XREF: CompressProgress(void *,unsigned __int64,unsigned __int64)+2Bj
.text:00000076                 lea     edx, [ebp+arg_C]
.text:00000079                 mov     [ebp+var_8], edx
.text:0000007C
.text:0000007C loc_7C:                                 ; CODE XREF: CompressProgress(void *,unsigned __int64,unsigned __int64)+34j
.text:0000007C                 mov     eax, [ebp+arg_4]
.text:0000007F                 and     eax, [ebp+arg_8]
.text:00000082                 cmp     eax, 0FFFFFFFFh
.text:00000085                 jnz     short loc_90
.text:00000087                 mov     [ebp+var_C], 0
.text:0000008E                 jmp     short loc_96
.text:00000090 ; ---------------------------------------------------------------------------
.text:00000090
.text:00000090 loc_90:                                 ; CODE XREF: CompressProgress(void *,unsigned __int64,unsigned __int64)+45j
.text:00000090                 lea     ecx, [ebp+arg_4]
.text:00000093                 mov     [ebp+var_C], ecx
.text:00000096
.text:00000096 loc_96:                                 ; CODE XREF: CompressProgress(void *,unsigned __int64,unsigned __int64)+4Ej
.text:00000096                 mov     esi, esp
.text:00000098                 mov     edx, [ebp+var_8]
.text:0000009B                 push    edx
.text:0000009C                 mov     eax, [ebp+var_C]
.text:0000009F                 push    eax
.text:000000A0                 mov     ecx, [ebp+var_4]
.text:000000A3                 mov     edx, [ecx+4]
.text:000000A6                 mov     eax, [ebp+var_4]
.text:000000A9                 mov     ecx, [eax+4]
.text:000000AC                 mov     edx, [edx]
.text:000000AE                 push    ecx
.text:000000AF                 mov     eax, [edx+0Ch]
.text:000000B2                 call    eax
.text:000000B4                 cmp     esi, esp
.text:000000B6                 call    __RTC_CheckEsp
.text:000000BB                 mov     ecx, [ebp+var_4]
.text:000000BE                 mov     [ecx+8], eax
.text:000000C1                 mov     edx, [ebp+var_4]
.text:000000C4                 mov     eax, [edx+8]
.text:000000C7                 pop     esi
.text:000000C8                 add     esp, 0Ch
.text:000000CB                 cmp     ebp, esp
.text:000000CD                 call    __RTC_CheckEsp
.text:000000D2                 mov     esp, ebp
.text:000000D4                 pop     ebp
.text:000000D5                 retn    14h
.text:000000D5 ?CompressProgress@@YGHPAX_K1@Z endp
.text:000000D5
.text:000000D5 ; ---------------------------------------------------------------------------
.text:000000D8                 align 10h
.text:000000E0
.text:000000E0 ; =============== S U B R O U T I N E =======================================
.text:000000E0
.text:000000E0 ; Attributes: bp-based frame
.text:000000E0
.text:000000E0 ; int __stdcall HRESULT_To_SRes(__int32, int)
.text:000000E0                 public ?HRESULT_To_SRes@@YGHJH@Z
.text:000000E0 ?HRESULT_To_SRes@@YGHJH@Z proc near     ; CODE XREF: MyRead(void *,void *,uint *)+A7p
.text:000000E0
.text:000000E0 var_4           = dword ptr -4
.text:000000E0 arg_0           = dword ptr  8
.text:000000E0 arg_4           = dword ptr  0Ch
.text:000000E0
.text:000000E0                 push    ebp
.text:000000E1                 mov     ebp, esp
.text:000000E3                 push    ecx
.text:000000E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000000EB                 mov     eax, [ebp+arg_0]
.text:000000EE                 mov     [ebp+var_4], eax
.text:000000F1                 cmp     [ebp+var_4], 80070057h
.text:000000F8                 jg      short loc_120
.text:000000FA                 cmp     [ebp+var_4], 80070057h
.text:00000101                 jz      short loc_139
.text:00000103                 cmp     [ebp+var_4], 80004001h
.text:0000010A                 jz      short loc_14E
.text:0000010C                 cmp     [ebp+var_4], 80004004h
.text:00000113                 jz      short loc_140
.text:00000115                 cmp     [ebp+var_4], 8007000Eh
.text:0000011C                 jz      short loc_132
.text:0000011E                 jmp     short loc_155
.text:00000120 ; ---------------------------------------------------------------------------
.text:00000120
.text:00000120 loc_120:                                ; CODE XREF: HRESULT_To_SRes(long,int)+18j
.text:00000120                 cmp     [ebp+var_4], 0
.text:00000124                 jz      short loc_12E
.text:00000126                 cmp     [ebp+var_4], 1
.text:0000012A                 jz      short loc_147
.text:0000012C                 jmp     short loc_155
.text:0000012E ; ---------------------------------------------------------------------------
.text:0000012E
.text:0000012E loc_12E:                                ; CODE XREF: HRESULT_To_SRes(long,int)+44j
.text:0000012E                 xor     eax, eax
.text:00000130                 jmp     short loc_158
.text:00000132 ; ---------------------------------------------------------------------------
.text:00000132
.text:00000132 loc_132:                                ; CODE XREF: HRESULT_To_SRes(long,int)+3Cj
.text:00000132                 mov     eax, 2
.text:00000137                 jmp     short loc_158
.text:00000139 ; ---------------------------------------------------------------------------
.text:00000139
.text:00000139 loc_139:                                ; CODE XREF: HRESULT_To_SRes(long,int)+21j
.text:00000139                 mov     eax, 5
.text:0000013E                 jmp     short loc_158
.text:00000140 ; ---------------------------------------------------------------------------
.text:00000140
.text:00000140 loc_140:                                ; CODE XREF: HRESULT_To_SRes(long,int)+33j
.text:00000140                 mov     eax, 0Ah
.text:00000145                 jmp     short loc_158
.text:00000147 ; ---------------------------------------------------------------------------
.text:00000147
.text:00000147 loc_147:                                ; CODE XREF: HRESULT_To_SRes(long,int)+4Aj
.text:00000147                 mov     eax, 1
.text:0000014C                 jmp     short loc_158
.text:0000014E ; ---------------------------------------------------------------------------
.text:0000014E
.text:0000014E loc_14E:                                ; CODE XREF: HRESULT_To_SRes(long,int)+2Aj
.text:0000014E                 mov     eax, 4
.text:00000153                 jmp     short loc_158
.text:00000155 ; ---------------------------------------------------------------------------
.text:00000155
.text:00000155 loc_155:                                ; CODE XREF: HRESULT_To_SRes(long,int)+3Ej
.text:00000155                                         ; HRESULT_To_SRes(long,int)+4Cj
.text:00000155                 mov     eax, [ebp+arg_4]
.text:00000158
.text:00000158 loc_158:                                ; CODE XREF: HRESULT_To_SRes(long,int)+50j
.text:00000158                                         ; HRESULT_To_SRes(long,int)+57j ...
.text:00000158                 mov     esp, ebp
.text:0000015A                 pop     ebp
.text:0000015B                 retn    8
.text:0000015B ?HRESULT_To_SRes@@YGHJH@Z endp
.text:0000015B
.text:0000015B ; ---------------------------------------------------------------------------
.text:0000015E                 align 10h
.text:00000160
.text:00000160 ; =============== S U B R O U T I N E =======================================
.text:00000160
.text:00000160 ; Attributes: bp-based frame
.text:00000160
.text:00000160 ; _DWORD __thiscall CSeqInStreamWrap::CSeqInStreamWrap(CSeqInStreamWrap *this, struct ISequentialInStream *)
.text:00000160                 public ??0CSeqInStreamWrap@@QAE@PAUISequentialInStream@@@Z
.text:00000160 ??0CSeqInStreamWrap@@QAE@PAUISequentialInStream@@@Z proc near
.text:00000160
.text:00000160 var_4           = dword ptr -4
.text:00000160 arg_0           = dword ptr  8
.text:00000160
.text:00000160                 push    ebp
.text:00000161                 mov     ebp, esp
.text:00000163                 push    ecx
.text:00000164                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000016B                 mov     [ebp+var_4], ecx
.text:0000016E                 mov     eax, [ebp+var_4]
.text:00000171                 mov     dword ptr [eax], offset ?MyRead@@YGHPAX0PAI@Z ; MyRead(void *,void *,uint *)
.text:00000177                 mov     ecx, [ebp+var_4]
.text:0000017A                 mov     edx, [ebp+arg_0]
.text:0000017D                 mov     [ecx+4], edx
.text:00000180                 mov     eax, [ebp+var_4]
.text:00000183                 mov     dword ptr [eax+10h], 0
.text:0000018A                 mov     dword ptr [eax+14h], 0
.text:00000191                 mov     eax, [ebp+var_4]
.text:00000194                 mov     esp, ebp
.text:00000196                 pop     ebp
.text:00000197                 retn    4
.text:00000197 ??0CSeqInStreamWrap@@QAE@PAUISequentialInStream@@@Z endp
.text:00000197
.text:00000197 ; ---------------------------------------------------------------------------
.text:0000019A                 align 10h
.text:000001A0
.text:000001A0 ; =============== S U B R O U T I N E =======================================
.text:000001A0
.text:000001A0 ; Attributes: bp-based frame
.text:000001A0
.text:000001A0 ; int __stdcall MyRead(void *, void *, unsigned int *)
.text:000001A0 ?MyRead@@YGHPAX0PAI@Z proc near         ; DATA XREF: CSeqInStreamWrap::CSeqInStreamWrap(ISequentialInStream *)+11o
.text:000001A0
.text:000001A0 var_14          = dword ptr -14h
.text:000001A0 var_10          = dword ptr -10h
.text:000001A0 var_C           = dword ptr -0Ch
.text:000001A0 var_8           = dword ptr -8
.text:000001A0 var_4           = dword ptr -4
.text:000001A0 arg_0           = dword ptr  8
.text:000001A0 arg_4           = dword ptr  0Ch
.text:000001A0 arg_8           = dword ptr  10h
.text:000001A0
.text:000001A0                 push    ebp
.text:000001A1                 mov     ebp, esp
.text:000001A3                 sub     esp, 14h
.text:000001A6                 push    esi
.text:000001A7                 mov     eax, 0CCCCCCCCh
.text:000001AC                 mov     [ebp+var_14], eax
.text:000001AF                 mov     [ebp+var_10], eax
.text:000001B2                 mov     [ebp+var_C], eax
.text:000001B5                 mov     [ebp+var_8], eax
.text:000001B8                 mov     [ebp+var_4], eax
.text:000001BB                 mov     eax, [ebp+arg_0]
.text:000001BE                 mov     [ebp+var_4], eax
.text:000001C1                 mov     ecx, [ebp+arg_8]
.text:000001C4                 cmp     dword ptr [ecx], 80000000h
.text:000001CA                 jnb     short loc_1D6
.text:000001CC                 mov     edx, [ebp+arg_8]
.text:000001CF                 mov     eax, [edx]
.text:000001D1                 mov     [ebp+var_14], eax
.text:000001D4                 jmp     short loc_1DD
.text:000001D6 ; ---------------------------------------------------------------------------
.text:000001D6
.text:000001D6 loc_1D6:                                ; CODE XREF: MyRead(void *,void *,uint *)+2Aj
.text:000001D6                 mov     [ebp+var_14], 80000000h
.text:000001DD
.text:000001DD loc_1DD:                                ; CODE XREF: MyRead(void *,void *,uint *)+34j
.text:000001DD                 mov     ecx, [ebp+var_14]
.text:000001E0                 mov     [ebp+var_C], ecx
.text:000001E3                 mov     esi, esp
.text:000001E5                 lea     edx, [ebp+var_C]
.text:000001E8                 push    edx
.text:000001E9                 mov     eax, [ebp+var_C]
.text:000001EC                 push    eax
.text:000001ED                 mov     ecx, [ebp+arg_4]
.text:000001F0                 push    ecx
.text:000001F1                 mov     edx, [ebp+var_4]
.text:000001F4                 mov     eax, [edx+4]
.text:000001F7                 mov     ecx, [ebp+var_4]
.text:000001FA                 mov     edx, [ecx+4]
.text:000001FD                 mov     eax, [eax]
.text:000001FF                 push    edx
.text:00000200                 mov     ecx, [eax+0Ch]
.text:00000203                 call    ecx
.text:00000205                 cmp     esi, esp
.text:00000207                 call    __RTC_CheckEsp
.text:0000020C                 mov     edx, [ebp+var_4]
.text:0000020F                 mov     [edx+8], eax
.text:00000212                 mov     eax, [ebp+arg_8]
.text:00000215                 mov     ecx, [ebp+var_C]
.text:00000218                 mov     [eax], ecx
.text:0000021A                 mov     edx, [ebp+var_C]
.text:0000021D                 xor     eax, eax
.text:0000021F                 mov     ecx, [ebp+var_4]
.text:00000222                 add     edx, [ecx+10h]
.text:00000225                 adc     eax, [ecx+14h]
.text:00000228                 mov     ecx, [ebp+var_4]
.text:0000022B                 mov     [ecx+10h], edx
.text:0000022E                 mov     [ecx+14h], eax
.text:00000231                 mov     edx, [ebp+var_4]
.text:00000234                 cmp     dword ptr [edx+8], 0
.text:00000238                 jnz     short loc_23E
.text:0000023A                 xor     eax, eax
.text:0000023C                 jmp     short loc_24C
.text:0000023E ; ---------------------------------------------------------------------------
.text:0000023E
.text:0000023E loc_23E:                                ; CODE XREF: MyRead(void *,void *,uint *)+98j
.text:0000023E                 push    8               ; int
.text:00000240                 mov     eax, [ebp+var_4]
.text:00000243                 mov     ecx, [eax+8]
.text:00000246                 push    ecx             ; __int32
.text:00000247                 call    ?HRESULT_To_SRes@@YGHJH@Z ; HRESULT_To_SRes(long,int)
.text:0000024C
.text:0000024C loc_24C:                                ; CODE XREF: MyRead(void *,void *,uint *)+9Cj
.text:0000024C                 push    edx
.text:0000024D                 mov     ecx, ebp
.text:0000024F                 push    eax
.text:00000250                 lea     edx, $LN8
.text:00000256                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000025B                 pop     eax
.text:0000025C                 pop     edx
.text:0000025D                 pop     esi
.text:0000025E                 add     esp, 14h
.text:00000261                 cmp     ebp, esp
.text:00000263                 call    __RTC_CheckEsp
.text:00000268                 mov     esp, ebp
.text:0000026A                 pop     ebp
.text:0000026B                 retn    0Ch
.text:0000026B ?MyRead@@YGHPAX0PAI@Z endp
.text:0000026B
.text:0000026B ; ---------------------------------------------------------------------------
.text:0000026E                 align 10h
.text:00000270 $LN8            dd 1                    ; DATA XREF: MyRead(void *,void *,uint *)+B0o
.text:00000274                 dd offset $LN7
.text:00000278 $LN7            dd 0FFFFFFF4h, 4        ; DATA XREF: .text:00000274o
.text:00000280                 dd offset $LN6          ; "curSize"
.text:00000284 $LN6            db 'curSize',0          ; DATA XREF: .text:00000280o
.text:0000028C                 align 10h
.text:00000290
.text:00000290 ; =============== S U B R O U T I N E =======================================
.text:00000290
.text:00000290 ; Attributes: bp-based frame
.text:00000290
.text:00000290 ; _DWORD __thiscall CSeqOutStreamWrap::CSeqOutStreamWrap(CSeqOutStreamWrap *this, struct ISequentialOutStream *)
.text:00000290                 public ??0CSeqOutStreamWrap@@QAE@PAUISequentialOutStream@@@Z
.text:00000290 ??0CSeqOutStreamWrap@@QAE@PAUISequentialOutStream@@@Z proc near
.text:00000290
.text:00000290 var_4           = dword ptr -4
.text:00000290 arg_0           = dword ptr  8
.text:00000290
.text:00000290                 push    ebp
.text:00000291                 mov     ebp, esp
.text:00000293                 push    ecx
.text:00000294                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000029B                 mov     [ebp+var_4], ecx
.text:0000029E                 mov     eax, [ebp+var_4]
.text:000002A1                 mov     dword ptr [eax], offset ?MyWrite@@YGIPAXPBXI@Z ; MyWrite(void *,void const *,uint)
.text:000002A7                 mov     ecx, [ebp+var_4]
.text:000002AA                 mov     edx, [ebp+arg_0]
.text:000002AD                 mov     [ecx+4], edx
.text:000002B0                 mov     eax, [ebp+var_4]
.text:000002B3                 mov     dword ptr [eax+8], 0
.text:000002BA                 mov     ecx, [ebp+var_4]
.text:000002BD                 mov     dword ptr [ecx+10h], 0
.text:000002C4                 mov     dword ptr [ecx+14h], 0
.text:000002CB                 mov     eax, [ebp+var_4]
.text:000002CE                 mov     esp, ebp
.text:000002D0                 pop     ebp
.text:000002D1                 retn    4
.text:000002D1 ??0CSeqOutStreamWrap@@QAE@PAUISequentialOutStream@@@Z endp
.text:000002D1
.text:000002D1 ; ---------------------------------------------------------------------------
.text:000002D4                 align 10h
.text:000002E0
.text:000002E0 ; =============== S U B R O U T I N E =======================================
.text:000002E0
.text:000002E0 ; Attributes: bp-based frame
.text:000002E0
.text:000002E0 ; int __stdcall MyWrite(int, void *, unsigned int)
.text:000002E0 ?MyWrite@@YGIPAXPBXI@Z proc near        ; DATA XREF: CSeqOutStreamWrap::CSeqOutStreamWrap(ISequentialOutStream *)+11o
.text:000002E0
.text:000002E0 var_4           = dword ptr -4
.text:000002E0 arg_0           = dword ptr  8
.text:000002E0 arg_4           = dword ptr  0Ch
.text:000002E0 arg_8           = dword ptr  10h
.text:000002E0
.text:000002E0                 push    ebp
.text:000002E1                 mov     ebp, esp
.text:000002E3                 push    ecx
.text:000002E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000002EB                 mov     eax, [ebp+arg_0]
.text:000002EE                 mov     [ebp+var_4], eax
.text:000002F1                 mov     ecx, [ebp+var_4]
.text:000002F4                 cmp     dword ptr [ecx+4], 0
.text:000002F8                 jz      short loc_323
.text:000002FA                 mov     edx, [ebp+arg_8]
.text:000002FD                 push    edx             ; unsigned int
.text:000002FE                 mov     eax, [ebp+arg_4]
.text:00000301                 push    eax             ; void *
.text:00000302                 mov     ecx, [ebp+var_4]
.text:00000305                 mov     edx, [ecx+4]
.text:00000308                 push    edx             ; struct ISequentialOutStream *
.text:00000309                 call    ?WriteStream@@YGJPAUISequentialOutStream@@PBXI@Z ; WriteStream(ISequentialOutStream *,void const *,uint)
.text:0000030E                 mov     ecx, [ebp+var_4]
.text:00000311                 mov     [ecx+8], eax
.text:00000314                 mov     edx, [ebp+var_4]
.text:00000317                 cmp     dword ptr [edx+8], 0
.text:0000031B                 jz      short loc_321
.text:0000031D                 xor     eax, eax
.text:0000031F                 jmp     short loc_347
.text:00000321 ; ---------------------------------------------------------------------------
.text:00000321
.text:00000321 loc_321:                                ; CODE XREF: MyWrite(void *,void const *,uint)+3Bj
.text:00000321                 jmp     short loc_32D
.text:00000323 ; ---------------------------------------------------------------------------
.text:00000323
.text:00000323 loc_323:                                ; CODE XREF: MyWrite(void *,void const *,uint)+18j
.text:00000323                 mov     eax, [ebp+var_4]
.text:00000326                 mov     dword ptr [eax+8], 0
.text:0000032D
.text:0000032D loc_32D:                                ; CODE XREF: MyWrite(void *,void const *,uint):loc_321j
.text:0000032D                 mov     ecx, [ebp+arg_8]
.text:00000330                 xor     edx, edx
.text:00000332                 mov     eax, [ebp+var_4]
.text:00000335                 add     ecx, [eax+10h]
.text:00000338                 adc     edx, [eax+14h]
.text:0000033B                 mov     eax, [ebp+var_4]
.text:0000033E                 mov     [eax+10h], ecx
.text:00000341                 mov     [eax+14h], edx
.text:00000344                 mov     eax, [ebp+arg_8]
.text:00000347
.text:00000347 loc_347:                                ; CODE XREF: MyWrite(void *,void const *,uint)+3Fj
.text:00000347                 add     esp, 4
.text:0000034A                 cmp     ebp, esp
.text:0000034C                 call    __RTC_CheckEsp
.text:00000351                 mov     esp, ebp
.text:00000353                 pop     ebp
.text:00000354                 retn    0Ch
.text:00000354 ?MyWrite@@YGIPAXPBXI@Z endp
.text:00000354
.text:00000354 ; ---------------------------------------------------------------------------
.text:00000357                 align 10h
.text:00000360
.text:00000360 ; =============== S U B R O U T I N E =======================================
.text:00000360
.text:00000360 ; Attributes: bp-based frame
.text:00000360
.text:00000360 ; __int32 __stdcall SResToHRESULT(int)
.text:00000360                 public ?SResToHRESULT@@YGJH@Z
.text:00000360 ?SResToHRESULT@@YGJH@Z proc near
.text:00000360
.text:00000360 var_4           = dword ptr -4
.text:00000360 arg_0           = dword ptr  8
.text:00000360
.text:00000360                 push    ebp
.text:00000361                 mov     ebp, esp
.text:00000363                 push    ecx
.text:00000364                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000036B                 mov     eax, [ebp+arg_0]
.text:0000036E                 mov     [ebp+var_4], eax
.text:00000371                 cmp     [ebp+var_4], 0Ah ; switch 11 cases
.text:00000375                 ja      short $LN7_0    ; jumptable 0000037A default case
.text:00000377                 mov     ecx, [ebp+var_4]
.text:0000037A                 jmp     ds:$LN11[ecx*4] ; switch jump
.text:00000381 ; ---------------------------------------------------------------------------
.text:00000381
.text:00000381 $LN6_0:                                 ; CODE XREF: SResToHRESULT(int)+1Aj
.text:00000381                                         ; DATA XREF: .text:$LN11o
.text:00000381                 xor     eax, eax        ; jumptable 0000037A case 0
.text:00000383                 jmp     short loc_3AD
.text:00000385 ; ---------------------------------------------------------------------------
.text:00000385
.text:00000385 $LN5:                                   ; CODE XREF: SResToHRESULT(int)+1Aj
.text:00000385                                         ; DATA XREF: .text:$LN11o
.text:00000385                 mov     eax, 8007000Eh  ; jumptable 0000037A case 2
.text:0000038A                 jmp     short loc_3AD
.text:0000038C ; ---------------------------------------------------------------------------
.text:0000038C
.text:0000038C $LN4:                                   ; CODE XREF: SResToHRESULT(int)+1Aj
.text:0000038C                                         ; DATA XREF: .text:$LN11o
.text:0000038C                 mov     eax, 80070057h  ; jumptable 0000037A case 5
.text:00000391                 jmp     short loc_3AD
.text:00000393 ; ---------------------------------------------------------------------------
.text:00000393
.text:00000393 $LN3:                                   ; CODE XREF: SResToHRESULT(int)+1Aj
.text:00000393                                         ; DATA XREF: .text:$LN11o
.text:00000393                 mov     eax, 80004004h  ; jumptable 0000037A case 10
.text:00000398                 jmp     short loc_3AD
.text:0000039A ; ---------------------------------------------------------------------------
.text:0000039A
.text:0000039A $LN2:                                   ; CODE XREF: SResToHRESULT(int)+1Aj
.text:0000039A                                         ; DATA XREF: .text:$LN11o
.text:0000039A                 mov     eax, 1          ; jumptable 0000037A case 1
.text:0000039F                 jmp     short loc_3AD
.text:000003A1 ; ---------------------------------------------------------------------------
.text:000003A1
.text:000003A1 $LN1:                                   ; CODE XREF: SResToHRESULT(int)+1Aj
.text:000003A1                                         ; DATA XREF: .text:$LN11o
.text:000003A1                 mov     eax, 80004001h  ; jumptable 0000037A case 4
.text:000003A6                 jmp     short loc_3AD
.text:000003A8 ; ---------------------------------------------------------------------------
.text:000003A8
.text:000003A8 $LN7_0:                                 ; CODE XREF: SResToHRESULT(int)+15j
.text:000003A8                                         ; SResToHRESULT(int)+1Aj
.text:000003A8                                         ; DATA XREF: ...
.text:000003A8                 mov     eax, 80004005h  ; jumptable 0000037A default case
.text:000003AD
.text:000003AD loc_3AD:                                ; CODE XREF: SResToHRESULT(int)+23j
.text:000003AD                                         ; SResToHRESULT(int)+2Aj ...
.text:000003AD                 mov     esp, ebp
.text:000003AF                 pop     ebp
.text:000003B0                 retn    4
.text:000003B0 ?SResToHRESULT@@YGJH@Z endp
.text:000003B0
.text:000003B0 ; ---------------------------------------------------------------------------
.text:000003B3                 align 4
.text:000003B4 $LN11           dd offset $LN6_0        ; DATA XREF: SResToHRESULT(int)+1Ar
.text:000003B4                 dd offset $LN2          ; jump table for switch statement
.text:000003B4                 dd offset $LN5
.text:000003B4                 dd offset $LN7_0
.text:000003B4                 dd offset $LN1
.text:000003B4                 dd offset $LN4
.text:000003B4                 dd offset $LN7_0
.text:000003B4                 dd offset $LN7_0
.text:000003B4                 dd offset $LN7_0
.text:000003B4                 dd offset $LN7_0
.text:000003B4                 dd offset $LN3
.text:000003E0
.text:000003E0 ; =============== S U B R O U T I N E =======================================
.text:000003E0
.text:000003E0 ; Attributes: bp-based frame
.text:000003E0
.text:000003E0 ; _DWORD __thiscall CSeekInStreamWrap::CSeekInStreamWrap(CSeekInStreamWrap *this, struct IInStream *)
.text:000003E0                 public ??0CSeekInStreamWrap@@QAE@PAUIInStream@@@Z
.text:000003E0 ??0CSeekInStreamWrap@@QAE@PAUIInStream@@@Z proc near
.text:000003E0
.text:000003E0 var_4           = dword ptr -4
.text:000003E0 arg_0           = dword ptr  8
.text:000003E0
.text:000003E0                 push    ebp
.text:000003E1                 mov     ebp, esp
.text:000003E3                 push    ecx
.text:000003E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000003EB                 mov     [ebp+var_4], ecx
.text:000003EE                 mov     eax, [ebp+var_4]
.text:000003F1                 mov     ecx, [ebp+arg_0]
.text:000003F4                 mov     [eax+8], ecx
.text:000003F7                 mov     edx, [ebp+var_4]
.text:000003FA                 mov     dword ptr [edx], offset ?InStreamWrap_Read@@YGHPAX0PAI@Z ; InStreamWrap_Read(void *,void *,uint *)
.text:00000400                 mov     eax, [ebp+var_4]
.text:00000403                 mov     dword ptr [eax+4], offset ?InStreamWrap_Seek@@YGHPAXPA_JW4ESzSeek@@@Z ; InStreamWrap_Seek(void *,__int64 *,ESzSeek)
.text:0000040A                 mov     ecx, [ebp+var_4]
.text:0000040D                 mov     dword ptr [ecx+0Ch], 0
.text:00000414                 mov     eax, [ebp+var_4]
.text:00000417                 mov     esp, ebp
.text:00000419                 pop     ebp
.text:0000041A                 retn    4
.text:0000041A ??0CSeekInStreamWrap@@QAE@PAUIInStream@@@Z endp
.text:0000041A
.text:0000041A ; ---------------------------------------------------------------------------
.text:0000041D                 align 10h
.text:00000420
.text:00000420 ; =============== S U B R O U T I N E =======================================
.text:00000420
.text:00000420 ; Attributes: bp-based frame
.text:00000420
.text:00000420 ; int __stdcall InStreamWrap_Read(void *, void *, unsigned int *)
.text:00000420 ?InStreamWrap_Read@@YGHPAX0PAI@Z proc near
.text:00000420                                         ; DATA XREF: CSeekInStreamWrap::CSeekInStreamWrap(IInStream *)+1Ao
.text:00000420
.text:00000420 var_14          = dword ptr -14h
.text:00000420 var_10          = dword ptr -10h
.text:00000420 var_C           = dword ptr -0Ch
.text:00000420 var_8           = dword ptr -8
.text:00000420 var_4           = dword ptr -4
.text:00000420 arg_0           = dword ptr  8
.text:00000420 arg_4           = dword ptr  0Ch
.text:00000420 arg_8           = dword ptr  10h
.text:00000420
.text:00000420                 push    ebp
.text:00000421                 mov     ebp, esp
.text:00000423                 sub     esp, 14h
.text:00000426                 push    esi
.text:00000427                 mov     eax, 0CCCCCCCCh
.text:0000042C                 mov     [ebp+var_14], eax
.text:0000042F                 mov     [ebp+var_10], eax
.text:00000432                 mov     [ebp+var_C], eax
.text:00000435                 mov     [ebp+var_8], eax
.text:00000438                 mov     [ebp+var_4], eax
.text:0000043B                 mov     eax, [ebp+arg_0]
.text:0000043E                 mov     [ebp+var_4], eax
.text:00000441                 mov     ecx, [ebp+arg_8]
.text:00000444                 cmp     dword ptr [ecx], 80000000h
.text:0000044A                 jnb     short loc_456
.text:0000044C                 mov     edx, [ebp+arg_8]
.text:0000044F                 mov     eax, [edx]
.text:00000451                 mov     [ebp+var_14], eax
.text:00000454                 jmp     short loc_45D
.text:00000456 ; ---------------------------------------------------------------------------
.text:00000456
.text:00000456 loc_456:                                ; CODE XREF: InStreamWrap_Read(void *,void *,uint *)+2Aj
.text:00000456                 mov     [ebp+var_14], 80000000h
.text:0000045D
.text:0000045D loc_45D:                                ; CODE XREF: InStreamWrap_Read(void *,void *,uint *)+34j
.text:0000045D                 mov     ecx, [ebp+var_14]
.text:00000460                 mov     [ebp+var_C], ecx
.text:00000463                 mov     esi, esp
.text:00000465                 lea     edx, [ebp+var_C]
.text:00000468                 push    edx
.text:00000469                 mov     eax, [ebp+var_C]
.text:0000046C                 push    eax
.text:0000046D                 mov     ecx, [ebp+arg_4]
.text:00000470                 push    ecx
.text:00000471                 mov     edx, [ebp+var_4]
.text:00000474                 mov     eax, [edx+8]
.text:00000477                 mov     ecx, [ebp+var_4]
.text:0000047A                 mov     edx, [ecx+8]
.text:0000047D                 mov     eax, [eax]
.text:0000047F                 push    edx
.text:00000480                 mov     ecx, [eax+0Ch]
.text:00000483                 call    ecx
.text:00000485                 cmp     esi, esp
.text:00000487                 call    __RTC_CheckEsp
.text:0000048C                 mov     edx, [ebp+var_4]
.text:0000048F                 mov     [edx+0Ch], eax
.text:00000492                 mov     eax, [ebp+arg_8]
.text:00000495                 mov     ecx, [ebp+var_C]
.text:00000498                 mov     [eax], ecx
.text:0000049A                 mov     edx, [ebp+var_4]
.text:0000049D                 mov     eax, [edx+0Ch]
.text:000004A0                 neg     eax
.text:000004A2                 sbb     eax, eax
.text:000004A4                 and     eax, 8
.text:000004A7                 push    edx
.text:000004A8                 mov     ecx, ebp
.text:000004AA                 push    eax
.text:000004AB                 lea     edx, $LN7_1
.text:000004B1                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000004B6                 pop     eax
.text:000004B7                 pop     edx
.text:000004B8                 pop     esi
.text:000004B9                 add     esp, 14h
.text:000004BC                 cmp     ebp, esp
.text:000004BE                 call    __RTC_CheckEsp
.text:000004C3                 mov     esp, ebp
.text:000004C5                 pop     ebp
.text:000004C6                 retn    0Ch
.text:000004C6 ?InStreamWrap_Read@@YGHPAX0PAI@Z endp
.text:000004C6
.text:000004C6 ; ---------------------------------------------------------------------------
.text:000004C9                 align 4
.text:000004CC $LN7_1          dd 1                    ; DATA XREF: InStreamWrap_Read(void *,void *,uint *)+8Bo
.text:000004D0                 dd offset $LN6_1
.text:000004D4 $LN6_1          dd 0FFFFFFF4h, 4        ; DATA XREF: .text:000004D0o
.text:000004DC                 dd offset $LN5_0        ; "curSize"
.text:000004E0 $LN5_0          db 'curSize',0          ; DATA XREF: .text:000004DCo
.text:000004E8                 align 10h
.text:000004F0
.text:000004F0 ; =============== S U B R O U T I N E =======================================
.text:000004F0
.text:000004F0 ; Attributes: bp-based frame
.text:000004F0
.text:000004F0 ; int __stdcall InStreamWrap_Seek(void *, __int64 *, enum  ESzSeek)
.text:000004F0 ?InStreamWrap_Seek@@YGHPAXPA_JW4ESzSeek@@@Z proc near
.text:000004F0                                         ; DATA XREF: CSeekInStreamWrap::CSeekInStreamWrap(IInStream *)+23o
.text:000004F0
.text:000004F0 var_1C          = dword ptr -1Ch
.text:000004F0 var_18          = dword ptr -18h
.text:000004F0 var_14          = dword ptr -14h
.text:000004F0 var_10          = dword ptr -10h
.text:000004F0 var_C           = dword ptr -0Ch
.text:000004F0 var_8           = dword ptr -8
.text:000004F0 var_4           = dword ptr -4
.text:000004F0 arg_0           = dword ptr  8
.text:000004F0 arg_4           = dword ptr  0Ch
.text:000004F0 arg_8           = dword ptr  10h
.text:000004F0
.text:000004F0                 push    ebp
.text:000004F1                 mov     ebp, esp
.text:000004F3                 sub     esp, 1Ch
.text:000004F6                 push    esi
.text:000004F7                 mov     eax, 0CCCCCCCCh
.text:000004FC                 mov     [ebp+var_1C], eax
.text:000004FF                 mov     [ebp+var_18], eax
.text:00000502                 mov     [ebp+var_14], eax
.text:00000505                 mov     [ebp+var_10], eax
.text:00000508                 mov     [ebp+var_C], eax
.text:0000050B                 mov     [ebp+var_8], eax
.text:0000050E                 mov     [ebp+var_4], eax
.text:00000511                 mov     eax, [ebp+arg_0]
.text:00000514                 mov     [ebp+var_4], eax
.text:00000517                 mov     ecx, [ebp+arg_8]
.text:0000051A                 mov     [ebp+var_1C], ecx
.text:0000051D                 cmp     [ebp+var_1C], 0
.text:00000521                 jz      short loc_531
.text:00000523                 cmp     [ebp+var_1C], 1
.text:00000527                 jz      short loc_53A
.text:00000529                 cmp     [ebp+var_1C], 2
.text:0000052D                 jz      short loc_543
.text:0000052F                 jmp     short loc_54C
.text:00000531 ; ---------------------------------------------------------------------------
.text:00000531
.text:00000531 loc_531:                                ; CODE XREF: InStreamWrap_Seek(void *,__int64 *,ESzSeek)+31j
.text:00000531                 mov     [ebp+var_8], 0
.text:00000538                 jmp     short loc_553
.text:0000053A ; ---------------------------------------------------------------------------
.text:0000053A
.text:0000053A loc_53A:                                ; CODE XREF: InStreamWrap_Seek(void *,__int64 *,ESzSeek)+37j
.text:0000053A                 mov     [ebp+var_8], 1
.text:00000541                 jmp     short loc_553
.text:00000543 ; ---------------------------------------------------------------------------
.text:00000543
.text:00000543 loc_543:                                ; CODE XREF: InStreamWrap_Seek(void *,__int64 *,ESzSeek)+3Dj
.text:00000543                 mov     [ebp+var_8], 2
.text:0000054A                 jmp     short loc_553
.text:0000054C ; ---------------------------------------------------------------------------
.text:0000054C
.text:0000054C loc_54C:                                ; CODE XREF: InStreamWrap_Seek(void *,__int64 *,ESzSeek)+3Fj
.text:0000054C                 mov     eax, 5
.text:00000551                 jmp     short loc_5A3
.text:00000553 ; ---------------------------------------------------------------------------
.text:00000553
.text:00000553 loc_553:                                ; CODE XREF: InStreamWrap_Seek(void *,__int64 *,ESzSeek)+48j
.text:00000553                                         ; InStreamWrap_Seek(void *,__int64 *,ESzSeek)+51j ...
.text:00000553                 mov     esi, esp
.text:00000555                 lea     edx, [ebp+var_14]
.text:00000558                 push    edx
.text:00000559                 mov     eax, [ebp+var_8]
.text:0000055C                 push    eax
.text:0000055D                 mov     ecx, [ebp+arg_4]
.text:00000560                 mov     edx, [ecx+4]
.text:00000563                 push    edx
.text:00000564                 mov     eax, [ecx]
.text:00000566                 push    eax
.text:00000567                 mov     ecx, [ebp+var_4]
.text:0000056A                 mov     edx, [ecx+8]
.text:0000056D                 mov     eax, [ebp+var_4]
.text:00000570                 mov     ecx, [eax+8]
.text:00000573                 mov     edx, [edx]
.text:00000575                 push    ecx
.text:00000576                 mov     eax, [edx+10h]
.text:00000579                 call    eax
.text:0000057B                 cmp     esi, esp
.text:0000057D                 call    __RTC_CheckEsp
.text:00000582                 mov     ecx, [ebp+var_4]
.text:00000585                 mov     [ecx+0Ch], eax
.text:00000588                 mov     edx, [ebp+arg_4]
.text:0000058B                 mov     eax, [ebp+var_14]
.text:0000058E                 mov     [edx], eax
.text:00000590                 mov     ecx, [ebp+var_10]
.text:00000593                 mov     [edx+4], ecx
.text:00000596                 mov     edx, [ebp+var_4]
.text:00000599                 mov     eax, [edx+0Ch]
.text:0000059C                 neg     eax
.text:0000059E                 sbb     eax, eax
.text:000005A0                 and     eax, 8
.text:000005A3
.text:000005A3 loc_5A3:                                ; CODE XREF: InStreamWrap_Seek(void *,__int64 *,ESzSeek)+61j
.text:000005A3                 push    edx
.text:000005A4                 mov     ecx, ebp
.text:000005A6                 push    eax
.text:000005A7                 lea     edx, $LN11_0
.text:000005AD                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000005B2                 pop     eax
.text:000005B3                 pop     edx
.text:000005B4                 pop     esi
.text:000005B5                 add     esp, 1Ch
.text:000005B8                 cmp     ebp, esp
.text:000005BA                 call    __RTC_CheckEsp
.text:000005BF                 mov     esp, ebp
.text:000005C1                 pop     ebp
.text:000005C2                 retn    0Ch
.text:000005C2 ?InStreamWrap_Seek@@YGHPAXPA_JW4ESzSeek@@@Z endp
.text:000005C2
.text:000005C2 ; ---------------------------------------------------------------------------
.text:000005C5                 align 4
.text:000005C8 $LN11_0         dd 1                    ; DATA XREF: InStreamWrap_Seek(void *,__int64 *,ESzSeek)+B7o
.text:000005CC                 dd offset $LN10
.text:000005D0 $LN10           dd 0FFFFFFECh, 8        ; DATA XREF: .text:000005CCo
.text:000005D8                 dd offset $LN9          ; "newPosition"
.text:000005DC $LN9            db 'newPosition',0      ; DATA XREF: .text:000005D8o
.text:000005E8                 align 10h
.text:000005F0
.text:000005F0 ; =============== S U B R O U T I N E =======================================
.text:000005F0
.text:000005F0 ; Attributes: bp-based frame
.text:000005F0
.text:000005F0 ; void __thiscall CByteInBufWrap::Free(CByteInBufWrap *__hidden this)
.text:000005F0                 public ?Free@CByteInBufWrap@@QAEXXZ
.text:000005F0 ?Free@CByteInBufWrap@@QAEXXZ proc near  ; CODE XREF: CByteInBufWrap::Alloc(uint)+2Ep
.text:000005F0
.text:000005F0 var_4           = dword ptr -4
.text:000005F0
.text:000005F0                 push    ebp
.text:000005F1                 mov     ebp, esp
.text:000005F3                 push    ecx
.text:000005F4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000005FB                 mov     [ebp+var_4], ecx
.text:000005FE                 mov     eax, [ebp+var_4]
.text:00000601                 mov     ecx, [eax+0Ch]
.text:00000604                 push    ecx
.text:00000605                 call    _MidFree@4      ; MidFree(x)
.text:0000060A                 mov     edx, [ebp+var_4]
.text:0000060D                 mov     dword ptr [edx+0Ch], 0
.text:00000614                 add     esp, 4
.text:00000617                 cmp     ebp, esp
.text:00000619                 call    __RTC_CheckEsp
.text:0000061E                 mov     esp, ebp
.text:00000620                 pop     ebp
.text:00000621                 retn
.text:00000621 ?Free@CByteInBufWrap@@QAEXXZ endp
.text:00000621
.text:00000621 ; ---------------------------------------------------------------------------
.text:00000622                 align 10h
.text:00000630
.text:00000630 ; =============== S U B R O U T I N E =======================================
.text:00000630
.text:00000630 ; Attributes: bp-based frame
.text:00000630
.text:00000630 ; bool __thiscall CByteInBufWrap::Alloc(CByteInBufWrap *this, unsigned int)
.text:00000630                 public ?Alloc@CByteInBufWrap@@QAE_NI@Z
.text:00000630 ?Alloc@CByteInBufWrap@@QAE_NI@Z proc near
.text:00000630
.text:00000630 var_8           = dword ptr -8
.text:00000630 var_4           = dword ptr -4
.text:00000630 arg_0           = dword ptr  8
.text:00000630
.text:00000630                 push    ebp
.text:00000631                 mov     ebp, esp
.text:00000633                 sub     esp, 8
.text:00000636                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000063D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000644                 mov     [ebp+var_4], ecx
.text:00000647                 mov     eax, [ebp+var_4]
.text:0000064A                 cmp     dword ptr [eax+0Ch], 0
.text:0000064E                 jz      short loc_65B
.text:00000650                 mov     ecx, [ebp+var_4]
.text:00000653                 mov     edx, [ebp+arg_0]
.text:00000656                 cmp     edx, [ecx+10h]
.text:00000659                 jz      short loc_693
.text:0000065B
.text:0000065B loc_65B:                                ; CODE XREF: CByteInBufWrap::Alloc(uint)+1Ej
.text:0000065B                 mov     ecx, [ebp+var_4] ; this
.text:0000065E                 call    ?Free@CByteInBufWrap@@QAEXXZ ; CByteInBufWrap::Free(void)
.text:00000663                 mov     eax, [ebp+arg_0]
.text:00000666                 push    eax
.text:00000667                 call    _MidAlloc@4     ; MidAlloc(x)
.text:0000066C                 mov     [ebp+var_8], eax
.text:0000066F                 mov     ecx, [ebp+var_4]
.text:00000672                 mov     edx, [ebp+var_8]
.text:00000675                 mov     [ecx+0Ch], edx
.text:00000678                 mov     eax, [ebp+var_4]
.text:0000067B                 mov     ecx, [ebp+var_8]
.text:0000067E                 mov     [eax+4], ecx
.text:00000681                 mov     edx, [ebp+var_4]
.text:00000684                 mov     eax, [ebp+var_8]
.text:00000687                 mov     [edx+8], eax
.text:0000068A                 mov     ecx, [ebp+var_4]
.text:0000068D                 mov     edx, [ebp+arg_0]
.text:00000690                 mov     [ecx+10h], edx
.text:00000693
.text:00000693 loc_693:                                ; CODE XREF: CByteInBufWrap::Alloc(uint)+29j
.text:00000693                 mov     eax, [ebp+var_4]
.text:00000696                 xor     ecx, ecx
.text:00000698                 cmp     dword ptr [eax+0Ch], 0
.text:0000069C                 setnz   cl
.text:0000069F                 mov     al, cl
.text:000006A1                 add     esp, 8
.text:000006A4                 cmp     ebp, esp
.text:000006A6                 call    __RTC_CheckEsp
.text:000006AB                 mov     esp, ebp
.text:000006AD                 pop     ebp
.text:000006AE                 retn    4
.text:000006AE ?Alloc@CByteInBufWrap@@QAE_NI@Z endp
.text:000006AE
.text:000006AE ; ---------------------------------------------------------------------------
.text:000006B1                 align 10h
.text:000006C0
.text:000006C0 ; =============== S U B R O U T I N E =======================================
.text:000006C0
.text:000006C0 ; Attributes: bp-based frame
.text:000006C0
.text:000006C0 ; unsigned __int8 __thiscall CByteInBufWrap::ReadByteFromNewBlock(CByteInBufWrap *__hidden this)
.text:000006C0                 public ?ReadByteFromNewBlock@CByteInBufWrap@@QAEEXZ
.text:000006C0 ?ReadByteFromNewBlock@CByteInBufWrap@@QAEEXZ proc near
.text:000006C0                                         ; CODE XREF: Wrap_ReadByte(void *)+4Ap
.text:000006C0
.text:000006C0 var_14          = dword ptr -14h
.text:000006C0 var_10          = dword ptr -10h
.text:000006C0 var_C           = dword ptr -0Ch
.text:000006C0 var_8           = dword ptr -8
.text:000006C0 var_4           = dword ptr -4
.text:000006C0
.text:000006C0                 push    ebp
.text:000006C1                 mov     ebp, esp
.text:000006C3                 sub     esp, 14h
.text:000006C6                 push    esi
.text:000006C7                 mov     eax, 0CCCCCCCCh
.text:000006CC                 mov     [ebp+var_14], eax
.text:000006CF                 mov     [ebp+var_10], eax
.text:000006D2                 mov     [ebp+var_C], eax
.text:000006D5                 mov     [ebp+var_8], eax
.text:000006D8                 mov     [ebp+var_4], eax
.text:000006DB                 mov     [ebp+var_4], ecx
.text:000006DE                 mov     eax, [ebp+var_4]
.text:000006E1                 cmp     dword ptr [eax+24h], 0
.text:000006E5                 jnz     loc_77F
.text:000006EB                 mov     ecx, [ebp+var_4]
.text:000006EE                 mov     edx, [ebp+var_4]
.text:000006F1                 mov     eax, [ecx+4]
.text:000006F4                 sub     eax, [edx+0Ch]
.text:000006F7                 cdq
.text:000006F8                 mov     ecx, [ebp+var_4]
.text:000006FB                 add     eax, [ecx+18h]
.text:000006FE                 adc     edx, [ecx+1Ch]
.text:00000701                 mov     ecx, [ebp+var_4]
.text:00000704                 mov     [ecx+18h], eax
.text:00000707                 mov     [ecx+1Ch], edx
.text:0000070A                 mov     esi, esp
.text:0000070C                 lea     edx, [ebp+var_C]
.text:0000070F                 push    edx
.text:00000710                 mov     eax, [ebp+var_4]
.text:00000713                 mov     ecx, [eax+10h]
.text:00000716                 push    ecx
.text:00000717                 mov     edx, [ebp+var_4]
.text:0000071A                 mov     eax, [edx+0Ch]
.text:0000071D                 push    eax
.text:0000071E                 mov     ecx, [ebp+var_4]
.text:00000721                 mov     edx, [ecx+14h]
.text:00000724                 mov     eax, [ebp+var_4]
.text:00000727                 mov     ecx, [eax+14h]
.text:0000072A                 mov     edx, [edx]
.text:0000072C                 push    ecx
.text:0000072D                 mov     eax, [edx+0Ch]
.text:00000730                 call    eax
.text:00000732                 cmp     esi, esp
.text:00000734                 call    __RTC_CheckEsp
.text:00000739                 mov     ecx, [ebp+var_4]
.text:0000073C                 mov     [ecx+24h], eax
.text:0000073F                 mov     edx, [ebp+var_4]
.text:00000742                 mov     eax, [ebp+var_4]
.text:00000745                 mov     ecx, [eax+0Ch]
.text:00000748                 mov     [edx+4], ecx
.text:0000074B                 mov     edx, [ebp+var_4]
.text:0000074E                 mov     eax, [edx+0Ch]
.text:00000751                 add     eax, [ebp+var_C]
.text:00000754                 mov     ecx, [ebp+var_4]
.text:00000757                 mov     [ecx+8], eax
.text:0000075A                 cmp     [ebp+var_C], 0
.text:0000075E                 jz      short loc_77F
.text:00000760                 mov     edx, [ebp+var_4]
.text:00000763                 mov     eax, [edx+4]
.text:00000766                 mov     cl, [eax]
.text:00000768                 mov     byte ptr [ebp+var_14+3], cl
.text:0000076B                 mov     edx, [ebp+var_4]
.text:0000076E                 mov     eax, [edx+4]
.text:00000771                 add     eax, 1
.text:00000774                 mov     ecx, [ebp+var_4]
.text:00000777                 mov     [ecx+4], eax
.text:0000077A                 mov     al, byte ptr [ebp+var_14+3]
.text:0000077D                 jmp     short loc_788
.text:0000077F ; ---------------------------------------------------------------------------
.text:0000077F
.text:0000077F loc_77F:                                ; CODE XREF: CByteInBufWrap::ReadByteFromNewBlock(void)+25j
.text:0000077F                                         ; CByteInBufWrap::ReadByteFromNewBlock(void)+9Ej
.text:0000077F                 mov     edx, [ebp+var_4]
.text:00000782                 mov     byte ptr [edx+20h], 1
.text:00000786                 xor     al, al
.text:00000788
.text:00000788 loc_788:                                ; CODE XREF: CByteInBufWrap::ReadByteFromNewBlock(void)+BDj
.text:00000788                 push    edx
.text:00000789                 mov     ecx, ebp
.text:0000078B                 push    eax
.text:0000078C                 lea     edx, $LN7_2
.text:00000792                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000797                 pop     eax
.text:00000798                 pop     edx
.text:00000799                 pop     esi
.text:0000079A                 add     esp, 14h
.text:0000079D                 cmp     ebp, esp
.text:0000079F                 call    __RTC_CheckEsp
.text:000007A4                 mov     esp, ebp
.text:000007A6                 pop     ebp
.text:000007A7                 retn
.text:000007A7 ?ReadByteFromNewBlock@CByteInBufWrap@@QAEEXZ endp
.text:000007A7
.text:000007A7 ; ---------------------------------------------------------------------------
.text:000007A8 $LN7_2          dd 1                    ; DATA XREF: CByteInBufWrap::ReadByteFromNewBlock(void)+CCo
.text:000007AC                 dd offset $LN6_2
.text:000007B0 $LN6_2          dd 0FFFFFFF4h, 4        ; DATA XREF: .text:000007ACo
.text:000007B8                 dd offset $LN5_1        ; "avail"
.text:000007BC $LN5_1          db 'avail',0            ; DATA XREF: .text:000007B8o
.text:000007C2                 align 10h
.text:000007D0
.text:000007D0 ; =============== S U B R O U T I N E =======================================
.text:000007D0
.text:000007D0 ; Attributes: bp-based frame
.text:000007D0
.text:000007D0 ; _DWORD __thiscall CByteInBufWrap::CByteInBufWrap(CByteInBufWrap *__hidden this)
.text:000007D0                 public ??0CByteInBufWrap@@QAE@XZ
.text:000007D0 ??0CByteInBufWrap@@QAE@XZ proc near
.text:000007D0
.text:000007D0 var_4           = dword ptr -4
.text:000007D0
.text:000007D0                 push    ebp
.text:000007D1                 mov     ebp, esp
.text:000007D3                 push    ecx
.text:000007D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000007DB                 mov     [ebp+var_4], ecx
.text:000007DE                 mov     eax, [ebp+var_4]
.text:000007E1                 mov     dword ptr [eax+0Ch], 0
.text:000007E8                 mov     ecx, [ebp+var_4]
.text:000007EB                 mov     dword ptr [ecx], offset ?Wrap_ReadByte@@YGEPAX@Z ; Wrap_ReadByte(void *)
.text:000007F1                 mov     eax, [ebp+var_4]
.text:000007F4                 mov     esp, ebp
.text:000007F6                 pop     ebp
.text:000007F7                 retn
.text:000007F7 ??0CByteInBufWrap@@QAE@XZ endp
.text:000007F7
.text:000007F7 ; ---------------------------------------------------------------------------
.text:000007F8                 align 10h
.text:00000800
.text:00000800 ; =============== S U B R O U T I N E =======================================
.text:00000800
.text:00000800 ; Attributes: bp-based frame
.text:00000800
.text:00000800 ; unsigned char __stdcall Wrap_ReadByte(void *)
.text:00000800 ?Wrap_ReadByte@@YGEPAX@Z proc near      ; DATA XREF: CByteInBufWrap::CByteInBufWrap(void)+1Bo
.text:00000800
.text:00000800 var_8           = dword ptr -8
.text:00000800 var_4           = dword ptr -4
.text:00000800 arg_0           = dword ptr  8
.text:00000800
.text:00000800                 push    ebp
.text:00000801                 mov     ebp, esp
.text:00000803                 sub     esp, 8
.text:00000806                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000080D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000814                 mov     eax, [ebp+arg_0]
.text:00000817                 mov     [ebp+var_4], eax
.text:0000081A                 mov     ecx, [ebp+var_4]
.text:0000081D                 mov     edx, [ebp+var_4]
.text:00000820                 mov     eax, [ecx+4]
.text:00000823                 cmp     eax, [edx+8]
.text:00000826                 jz      short loc_847
.text:00000828                 mov     ecx, [ebp+var_4]
.text:0000082B                 mov     edx, [ecx+4]
.text:0000082E                 mov     al, [edx]
.text:00000830                 mov     byte ptr [ebp+var_8+3], al
.text:00000833                 mov     ecx, [ebp+var_4]
.text:00000836                 mov     edx, [ecx+4]
.text:00000839                 add     edx, 1
.text:0000083C                 mov     eax, [ebp+var_4]
.text:0000083F                 mov     [eax+4], edx
.text:00000842                 mov     al, byte ptr [ebp+var_8+3]
.text:00000845                 jmp     short loc_84F
.text:00000847 ; ---------------------------------------------------------------------------
.text:00000847
.text:00000847 loc_847:                                ; CODE XREF: Wrap_ReadByte(void *)+26j
.text:00000847                 mov     ecx, [ebp+var_4] ; this
.text:0000084A                 call    ?ReadByteFromNewBlock@CByteInBufWrap@@QAEEXZ ; CByteInBufWrap::ReadByteFromNewBlock(void)
.text:0000084F
.text:0000084F loc_84F:                                ; CODE XREF: Wrap_ReadByte(void *)+45j
.text:0000084F                 add     esp, 8
.text:00000852                 cmp     ebp, esp
.text:00000854                 call    __RTC_CheckEsp
.text:00000859                 mov     esp, ebp
.text:0000085B                 pop     ebp
.text:0000085C                 retn    4
.text:0000085C ?Wrap_ReadByte@@YGEPAX@Z endp
.text:0000085C
.text:0000085C ; ---------------------------------------------------------------------------
.text:0000085F                 align 10h
.text:00000860
.text:00000860 ; =============== S U B R O U T I N E =======================================
.text:00000860
.text:00000860 ; Attributes: bp-based frame
.text:00000860
.text:00000860 ; void __thiscall CByteOutBufWrap::Free(CByteOutBufWrap *__hidden this)
.text:00000860                 public ?Free@CByteOutBufWrap@@QAEXXZ
.text:00000860 ?Free@CByteOutBufWrap@@QAEXXZ proc near ; CODE XREF: CByteOutBufWrap::Alloc(uint)+25p
.text:00000860
.text:00000860 var_4           = dword ptr -4
.text:00000860
.text:00000860                 push    ebp
.text:00000861                 mov     ebp, esp
.text:00000863                 push    ecx
.text:00000864                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000086B                 mov     [ebp+var_4], ecx
.text:0000086E                 mov     eax, [ebp+var_4]
.text:00000871                 mov     ecx, [eax+0Ch]
.text:00000874                 push    ecx
.text:00000875                 call    _MidFree@4      ; MidFree(x)
.text:0000087A                 mov     edx, [ebp+var_4]
.text:0000087D                 mov     dword ptr [edx+0Ch], 0
.text:00000884                 add     esp, 4
.text:00000887                 cmp     ebp, esp
.text:00000889                 call    __RTC_CheckEsp
.text:0000088E                 mov     esp, ebp
.text:00000890                 pop     ebp
.text:00000891                 retn
.text:00000891 ?Free@CByteOutBufWrap@@QAEXXZ endp
.text:00000891
.text:00000891 ; ---------------------------------------------------------------------------
.text:00000892                 align 10h
.text:000008A0
.text:000008A0 ; =============== S U B R O U T I N E =======================================
.text:000008A0
.text:000008A0 ; Attributes: bp-based frame
.text:000008A0
.text:000008A0 ; bool __thiscall CByteOutBufWrap::Alloc(CByteOutBufWrap *this, unsigned int)
.text:000008A0                 public ?Alloc@CByteOutBufWrap@@QAE_NI@Z
.text:000008A0 ?Alloc@CByteOutBufWrap@@QAE_NI@Z proc near
.text:000008A0
.text:000008A0 var_4           = dword ptr -4
.text:000008A0 arg_0           = dword ptr  8
.text:000008A0
.text:000008A0                 push    ebp
.text:000008A1                 mov     ebp, esp
.text:000008A3                 push    ecx
.text:000008A4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000008AB                 mov     [ebp+var_4], ecx
.text:000008AE                 mov     eax, [ebp+var_4]
.text:000008B1                 cmp     dword ptr [eax+0Ch], 0
.text:000008B5                 jz      short loc_8C2
.text:000008B7                 mov     ecx, [ebp+var_4]
.text:000008BA                 mov     edx, [ebp+arg_0]
.text:000008BD                 cmp     edx, [ecx+10h]
.text:000008C0                 jz      short loc_8E2
.text:000008C2
.text:000008C2 loc_8C2:                                ; CODE XREF: CByteOutBufWrap::Alloc(uint)+15j
.text:000008C2                 mov     ecx, [ebp+var_4] ; this
.text:000008C5                 call    ?Free@CByteOutBufWrap@@QAEXXZ ; CByteOutBufWrap::Free(void)
.text:000008CA                 mov     eax, [ebp+arg_0]
.text:000008CD                 push    eax
.text:000008CE                 call    _MidAlloc@4     ; MidAlloc(x)
.text:000008D3                 mov     ecx, [ebp+var_4]
.text:000008D6                 mov     [ecx+0Ch], eax
.text:000008D9                 mov     edx, [ebp+var_4]
.text:000008DC                 mov     eax, [ebp+arg_0]
.text:000008DF                 mov     [edx+10h], eax
.text:000008E2
.text:000008E2 loc_8E2:                                ; CODE XREF: CByteOutBufWrap::Alloc(uint)+20j
.text:000008E2                 mov     ecx, [ebp+var_4]
.text:000008E5                 xor     eax, eax
.text:000008E7                 cmp     dword ptr [ecx+0Ch], 0
.text:000008EB                 setnz   al
.text:000008EE                 add     esp, 4
.text:000008F1                 cmp     ebp, esp
.text:000008F3                 call    __RTC_CheckEsp
.text:000008F8                 mov     esp, ebp
.text:000008FA                 pop     ebp
.text:000008FB                 retn    4
.text:000008FB ?Alloc@CByteOutBufWrap@@QAE_NI@Z endp
.text:000008FB
.text:000008FB ; ---------------------------------------------------------------------------
.text:000008FE                 align 10h
.text:00000900
.text:00000900 ; =============== S U B R O U T I N E =======================================
.text:00000900
.text:00000900 ; Attributes: bp-based frame
.text:00000900
.text:00000900 ; __int32 __thiscall CByteOutBufWrap::Flush(CByteOutBufWrap *__hidden this)
.text:00000900                 public ?Flush@CByteOutBufWrap@@QAEJXZ
.text:00000900 ?Flush@CByteOutBufWrap@@QAEJXZ proc near
.text:00000900                                         ; CODE XREF: Wrap_WriteByte(void *,uchar)+4Bp
.text:00000900
.text:00000900 var_8           = dword ptr -8
.text:00000900 var_4           = dword ptr -4
.text:00000900
.text:00000900                 push    ebp
.text:00000901                 mov     ebp, esp
.text:00000903                 sub     esp, 8
.text:00000906                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000090D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000914                 mov     [ebp+var_4], ecx
.text:00000917                 mov     eax, [ebp+var_4]
.text:0000091A                 cmp     dword ptr [eax+20h], 0
.text:0000091E                 jnz     short loc_978
.text:00000920                 mov     ecx, [ebp+var_4]
.text:00000923                 mov     edx, [ebp+var_4]
.text:00000926                 mov     eax, [ecx+4]
.text:00000929                 sub     eax, [edx+0Ch]
.text:0000092C                 mov     [ebp+var_8], eax
.text:0000092F                 mov     ecx, [ebp+var_8]
.text:00000932                 push    ecx             ; unsigned int
.text:00000933                 mov     edx, [ebp+var_4]
.text:00000936                 mov     eax, [edx+0Ch]
.text:00000939                 push    eax             ; void *
.text:0000093A                 mov     ecx, [ebp+var_4]
.text:0000093D                 mov     edx, [ecx+14h]
.text:00000940                 push    edx             ; struct ISequentialOutStream *
.text:00000941                 call    ?WriteStream@@YGJPAUISequentialOutStream@@PBXI@Z ; WriteStream(ISequentialOutStream *,void const *,uint)
.text:00000946                 mov     ecx, [ebp+var_4]
.text:00000949                 mov     [ecx+20h], eax
.text:0000094C                 mov     edx, [ebp+var_4]
.text:0000094F                 cmp     dword ptr [edx+20h], 0
.text:00000953                 jnz     short loc_96C
.text:00000955                 mov     eax, [ebp+var_8]
.text:00000958                 xor     ecx, ecx
.text:0000095A                 mov     edx, [ebp+var_4]
.text:0000095D                 add     eax, [edx+18h]
.text:00000960                 adc     ecx, [edx+1Ch]
.text:00000963                 mov     edx, [ebp+var_4]
.text:00000966                 mov     [edx+18h], eax
.text:00000969                 mov     [edx+1Ch], ecx
.text:0000096C
.text:0000096C loc_96C:                                ; CODE XREF: CByteOutBufWrap::Flush(void)+53j
.text:0000096C                 mov     eax, [ebp+var_4]
.text:0000096F                 mov     ecx, [ebp+var_4]
.text:00000972                 mov     edx, [ecx+0Ch]
.text:00000975                 mov     [eax+4], edx
.text:00000978
.text:00000978 loc_978:                                ; CODE XREF: CByteOutBufWrap::Flush(void)+1Ej
.text:00000978                 mov     eax, [ebp+var_4]
.text:0000097B                 mov     eax, [eax+20h]
.text:0000097E                 add     esp, 8
.text:00000981                 cmp     ebp, esp
.text:00000983                 call    __RTC_CheckEsp
.text:00000988                 mov     esp, ebp
.text:0000098A                 pop     ebp
.text:0000098B                 retn
.text:0000098B ?Flush@CByteOutBufWrap@@QAEJXZ endp
.text:0000098B
.text:0000098B ; ---------------------------------------------------------------------------
.text:0000098C                 align 10h
.text:00000990
.text:00000990 ; =============== S U B R O U T I N E =======================================
.text:00000990
.text:00000990 ; Attributes: bp-based frame
.text:00000990
.text:00000990 ; _DWORD __thiscall CByteOutBufWrap::CByteOutBufWrap(CByteOutBufWrap *__hidden this)
.text:00000990                 public ??0CByteOutBufWrap@@QAE@XZ
.text:00000990 ??0CByteOutBufWrap@@QAE@XZ proc near
.text:00000990
.text:00000990 var_4           = dword ptr -4
.text:00000990
.text:00000990                 push    ebp
.text:00000991                 mov     ebp, esp
.text:00000993                 push    ecx
.text:00000994                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000099B                 mov     [ebp+var_4], ecx
.text:0000099E                 mov     eax, [ebp+var_4]
.text:000009A1                 mov     dword ptr [eax+0Ch], 0
.text:000009A8                 mov     ecx, [ebp+var_4]
.text:000009AB                 mov     dword ptr [ecx], offset ?Wrap_WriteByte@@YGXPAXE@Z ; Wrap_WriteByte(void *,uchar)
.text:000009B1                 mov     eax, [ebp+var_4]
.text:000009B4                 mov     esp, ebp
.text:000009B6                 pop     ebp
.text:000009B7                 retn
.text:000009B7 ??0CByteOutBufWrap@@QAE@XZ endp
.text:000009B7
.text:000009B7 ; ---------------------------------------------------------------------------
.text:000009B8                 align 10h
.text:000009C0
.text:000009C0 ; =============== S U B R O U T I N E =======================================
.text:000009C0
.text:000009C0 ; Attributes: bp-based frame
.text:000009C0
.text:000009C0 ; void __stdcall Wrap_WriteByte(void *, unsigned char)
.text:000009C0 ?Wrap_WriteByte@@YGXPAXE@Z proc near    ; DATA XREF: CByteOutBufWrap::CByteOutBufWrap(void)+1Bo
.text:000009C0
.text:000009C0 var_8           = dword ptr -8
.text:000009C0 var_4           = dword ptr -4
.text:000009C0 arg_0           = dword ptr  8
.text:000009C0 arg_4           = byte ptr  0Ch
.text:000009C0
.text:000009C0                 push    ebp
.text:000009C1                 mov     ebp, esp
.text:000009C3                 sub     esp, 8
.text:000009C6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000009CD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000009D4                 mov     eax, [ebp+arg_0]
.text:000009D7                 mov     [ebp+var_4], eax
.text:000009DA                 mov     ecx, [ebp+var_4]
.text:000009DD                 mov     edx, [ecx+4]
.text:000009E0                 mov     [ebp+var_8], edx
.text:000009E3                 mov     eax, [ebp+var_8]
.text:000009E6                 mov     cl, [ebp+arg_4]
.text:000009E9                 mov     [eax], cl
.text:000009EB                 mov     edx, [ebp+var_8]
.text:000009EE                 add     edx, 1
.text:000009F1                 mov     [ebp+var_8], edx
.text:000009F4                 mov     eax, [ebp+var_4]
.text:000009F7                 mov     ecx, [ebp+var_8]
.text:000009FA                 mov     [eax+4], ecx
.text:000009FD                 mov     edx, [ebp+var_4]
.text:00000A00                 mov     eax, [ebp+var_8]
.text:00000A03                 cmp     eax, [edx+8]
.text:00000A06                 jnz     short loc_A10
.text:00000A08                 mov     ecx, [ebp+var_4] ; this
.text:00000A0B                 call    ?Flush@CByteOutBufWrap@@QAEJXZ ; CByteOutBufWrap::Flush(void)
.text:00000A10
.text:00000A10 loc_A10:                                ; CODE XREF: Wrap_WriteByte(void *,uchar)+46j
.text:00000A10                 add     esp, 8
.text:00000A13                 cmp     ebp, esp
.text:00000A15                 call    __RTC_CheckEsp
.text:00000A1A                 mov     esp, ebp
.text:00000A1C                 pop     ebp
.text:00000A1D                 retn    8
.text:00000A1D ?Wrap_WriteByte@@YGXPAXE@Z endp
.text:00000A1D
.text:00000A1D _text           ends
.text:00000A1D
.rtc$TMZ:00000A20 ; ===========================================================================
.rtc$TMZ:00000A20
.rtc$TMZ:00000A20 ; Segment type: Pure data
.rtc$TMZ:00000A20 ; Segment permissions: Read
.rtc$TMZ:00000A20 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000A20                 assume cs:_rtc$TMZ
.rtc$TMZ:00000A20                 ;org 0A20h
.rtc$TMZ:00000A20 ; COMDAT (pick any)
.rtc$TMZ:00000A20 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000A20 _rtc$TMZ        ends
.rtc$TMZ:00000A20
.rtc$IMZ:00000A24 ; ===========================================================================
.rtc$IMZ:00000A24
.rtc$IMZ:00000A24 ; Segment type: Pure data
.rtc$IMZ:00000A24 ; Segment permissions: Read
.rtc$IMZ:00000A24 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00000A24                 assume cs:_rtc$IMZ
.rtc$IMZ:00000A24                 ;org 0A24h
.rtc$IMZ:00000A24 ; COMDAT (pick any)
.rtc$IMZ:00000A24 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00000A24 _rtc$IMZ        ends
.rtc$IMZ:00000A24
UNDEF:00000A30 ; ===========================================================================
UNDEF:00000A30
UNDEF:00000A30 ; Segment type: Externs
UNDEF:00000A30 ; UNDEF
UNDEF:00000A30                 extrn __RTC_Shutdown:near
UNDEF:00000A30                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00000A34                 extrn __RTC_InitBase:near
UNDEF:00000A34                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00000A38                 extrn __RTC_CheckEsp:near
UNDEF:00000A38                                         ; CODE XREF: CompressProgress(void *,unsigned __int64,unsigned __int64)+76p
UNDEF:00000A38                                         ; CompressProgress(void *,unsigned __int64,unsigned __int64)+8Dp ...
UNDEF:00000A3C ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00000A3C                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00000A3C                                         ; CODE XREF: MyRead(void *,void *,uint *)+B6p
UNDEF:00000A3C                                         ; InStreamWrap_Read(void *,void *,uint *)+91p ...
UNDEF:00000A40 ; __int32 __stdcall WriteStream(struct ISequentialOutStream *, const void *, unsigned int)
UNDEF:00000A40                 extrn ?WriteStream@@YGJPAUISequentialOutStream@@PBXI@Z:near
UNDEF:00000A40                                         ; CODE XREF: MyWrite(void *,void const *,uint)+29p
UNDEF:00000A40                                         ; CByteOutBufWrap::Flush(void)+41p
UNDEF:00000A44 ; __stdcall MidFree(x)
UNDEF:00000A44                 extrn _MidFree@4:near   ; CODE XREF: CByteInBufWrap::Free(void)+15p
UNDEF:00000A44                                         ; CByteOutBufWrap::Free(void)+15p
UNDEF:00000A48 ; __stdcall MidAlloc(x)
UNDEF:00000A48                 extrn _MidAlloc@4:near  ; CODE XREF: CByteInBufWrap::Alloc(uint)+37p
UNDEF:00000A48                                         ; CByteOutBufWrap::Alloc(uint)+2Ep
UNDEF:00000A48
UNDEF:00000A48
UNDEF:00000A48                 end