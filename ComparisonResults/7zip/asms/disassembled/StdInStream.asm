.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 323DD68C8ADDD6F8626D0E969CDA3BE8
.rdata:00000000 ; Input CRC32 : 8E673D83
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\StdInStream.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG69812        db 'Unexpected end of input stream',0
.rdata:00000000                                         ; DATA XREF: .data:_kEOFMessageo
.rdata:0000001F                 align 10h
.rdata:00000020 $SG69814        db 'Error reading input stream',0
.rdata:00000020                                         ; DATA XREF: .data:_kReadErrorMessageo
.rdata:0000003B                 align 4
.rdata:0000003C $SG69816        db 'Illegal character in input stream',0
.rdata:0000003C                                         ; DATA XREF: .data:_kIllegalCharMessageo
.rdata:0000005E                 align 10h
.rdata:00000060 $SG69818        db 'r',0                ; DATA XREF: .data:_kFileOpenModeo
.rdata:00000062                 align 4
.rdata:00000062 _rdata          ends
.rdata:00000062
.data:00000064 ; ===========================================================================
.data:00000064
.data:00000064 ; Segment type: Pure data
.data:00000064 ; Segment permissions: Read/Write
.data:00000064 _data           segment dword public 'DATA' use32
.data:00000064                 assume cs:_data
.data:00000064                 ;org 64h
.data:00000064 _kEOFMessage    dd offset $SG69812      ; DATA XREF: CStdInStream::ScanStringUntilNewLine(bool):loc_19Fr
.data:00000064                                         ; "Unexpected end of input stream"
.data:00000068 _kReadErrorMessage dd offset $SG69814   ; DATA XREF: CStdInStream::GetChar(void)+4Fr
.data:00000068                                         ; "Error reading input stream"
.data:0000006C _kIllegalCharMessage dd offset $SG69816 ; DATA XREF: CStdInStream::ScanStringUntilNewLine(bool)+90r
.data:0000006C                                         ; "Illegal character in input stream"
.data:00000070 ; char *kFileOpenMode
.data:00000070 _kFileOpenMode  dd offset $SG69818      ; DATA XREF: CStdInStream::Open(char const *)+19r
.data:00000070 _data           ends                    ; "r"
.data:00000070
.text:00000074 ; ===========================================================================
.text:00000074
.text:00000074 ; Segment type: Pure code
.text:00000074 ; Segment permissions: Read/Execute
.text:00000074 _text           segment para public 'CODE' use32
.text:00000074                 assume cs:_text
.text:00000074                 ;org 74h
.text:00000074                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000074
.text:00000074 ; =============== S U B R O U T I N E =======================================
.text:00000074
.text:00000074 ; Attributes: bp-based frame
.text:00000074
.text:00000074 ; bool __thiscall CStdInStream::Open(CStdInStream *this, const char *)
.text:00000074                 public ?Open@CStdInStream@@QAE_NPBD@Z
.text:00000074 ?Open@CStdInStream@@QAE_NPBD@Z proc near
.text:00000074
.text:00000074 var_4           = dword ptr -4
.text:00000074 Filename        = dword ptr  8
.text:00000074
.text:00000074                 push    ebp
.text:00000075                 mov     ebp, esp
.text:00000077                 push    ecx
.text:00000078                 push    esi
.text:00000079                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000080                 mov     [ebp+var_4], ecx
.text:00000083                 mov     ecx, [ebp+var_4] ; this
.text:00000086                 call    ?Close@CStdInStream@@QAE_NXZ ; CStdInStream::Close(void)
.text:0000008B                 mov     esi, esp
.text:0000008D                 mov     eax, ds:_kFileOpenMode
.text:00000092                 push    eax             ; Mode
.text:00000093                 mov     ecx, [ebp+Filename]
.text:00000096                 push    ecx             ; Filename
.text:00000097                 call    dword ptr ds:__imp__fopen
.text:0000009D                 add     esp, 8
.text:000000A0                 cmp     esi, esp
.text:000000A2                 call    __RTC_CheckEsp
.text:000000A7                 mov     edx, [ebp+var_4]
.text:000000AA                 mov     [edx], eax
.text:000000AC                 mov     eax, [ebp+var_4]
.text:000000AF                 xor     ecx, ecx
.text:000000B1                 cmp     dword ptr [eax], 0
.text:000000B4                 setnz   cl
.text:000000B7                 mov     edx, [ebp+var_4]
.text:000000BA                 mov     [edx+4], cl
.text:000000BD                 mov     eax, [ebp+var_4]
.text:000000C0                 mov     al, [eax+4]
.text:000000C3                 pop     esi
.text:000000C4                 add     esp, 4
.text:000000C7                 cmp     ebp, esp
.text:000000C9                 call    __RTC_CheckEsp
.text:000000CE                 mov     esp, ebp
.text:000000D0                 pop     ebp
.text:000000D1                 retn    4
.text:000000D1 ?Open@CStdInStream@@QAE_NPBD@Z endp
.text:000000D1
.text:000000D4
.text:000000D4 ; =============== S U B R O U T I N E =======================================
.text:000000D4
.text:000000D4 ; Attributes: bp-based frame
.text:000000D4
.text:000000D4 ; bool __thiscall CStdInStream::Close(CStdInStream *__hidden this)
.text:000000D4                 public ?Close@CStdInStream@@QAE_NXZ
.text:000000D4 ?Close@CStdInStream@@QAE_NXZ proc near  ; CODE XREF: CStdInStream::Open(char const *)+12p
.text:000000D4                                         ; CStdInStream::~CStdInStream(void)+11p
.text:000000D4
.text:000000D4 var_4           = dword ptr -4
.text:000000D4
.text:000000D4                 push    ebp
.text:000000D5                 mov     ebp, esp
.text:000000D7                 push    ecx
.text:000000D8                 push    esi
.text:000000D9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000000E0                 mov     [ebp+var_4], ecx
.text:000000E3                 mov     eax, [ebp+var_4]
.text:000000E6                 movzx   ecx, byte ptr [eax+4]
.text:000000EA                 test    ecx, ecx
.text:000000EC                 jnz     short loc_F2
.text:000000EE                 mov     al, 1
.text:000000F0                 jmp     short loc_124
.text:000000F2 ; ---------------------------------------------------------------------------
.text:000000F2
.text:000000F2 loc_F2:                                 ; CODE XREF: CStdInStream::Close(void)+18j
.text:000000F2                 mov     esi, esp
.text:000000F4                 mov     edx, [ebp+var_4]
.text:000000F7                 mov     eax, [edx]
.text:000000F9                 push    eax             ; File
.text:000000FA                 call    dword ptr ds:__imp__fclose
.text:00000100                 add     esp, 4
.text:00000103                 cmp     esi, esp
.text:00000105                 call    __RTC_CheckEsp
.text:0000010A                 neg     eax
.text:0000010C                 sbb     eax, eax
.text:0000010E                 neg     eax
.text:00000110                 mov     ecx, [ebp+var_4]
.text:00000113                 mov     [ecx+4], al
.text:00000116                 mov     edx, [ebp+var_4]
.text:00000119                 movzx   eax, byte ptr [edx+4]
.text:0000011D                 neg     eax
.text:0000011F                 sbb     eax, eax
.text:00000121                 add     eax, 1
.text:00000124
.text:00000124 loc_124:                                ; CODE XREF: CStdInStream::Close(void)+1Cj
.text:00000124                 pop     esi
.text:00000125                 add     esp, 4
.text:00000128                 cmp     ebp, esp
.text:0000012A                 call    __RTC_CheckEsp
.text:0000012F                 mov     esp, ebp
.text:00000131                 pop     ebp
.text:00000132                 retn
.text:00000132 ?Close@CStdInStream@@QAE_NXZ endp
.text:00000132
.text:00000132 ; ---------------------------------------------------------------------------
.text:00000133                 align 4
.text:00000134
.text:00000134 ; =============== S U B R O U T I N E =======================================
.text:00000134
.text:00000134 ; Attributes: bp-based frame
.text:00000134
.text:00000134 ; public: class AString __thiscall CStdInStream::ScanStringUntilNewLine(bool)
.text:00000134                 public ?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z
.text:00000134 ?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z proc near
.text:00000134                                         ; CODE XREF: CStdInStream::ScanUStringUntilNewLine(void)+4Ap
.text:00000134
.text:00000134 var_38          = dword ptr -38h
.text:00000134 var_34          = dword ptr -34h
.text:00000134 var_30          = dword ptr -30h
.text:00000134 var_29          = byte ptr -29h
.text:00000134 var_28          = dword ptr -28h
.text:00000134 var_20          = byte ptr -20h
.text:00000134 var_10          = dword ptr -10h
.text:00000134 var_C           = dword ptr -0Ch
.text:00000134 var_4           = dword ptr -4
.text:00000134 arg_0           = dword ptr  8
.text:00000134 arg_4           = byte ptr  0Ch
.text:00000134
.text:00000134                 push    ebp
.text:00000135                 mov     ebp, esp
.text:00000137                 push    0FFFFFFFFh
.text:00000139                 push    offset __ehhandler$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z
.text:0000013E                 mov     eax, large fs:0
.text:00000144                 push    eax
.text:00000145                 sub     esp, 2Ch
.text:00000148                 push    edi
.text:00000149                 push    ecx
.text:0000014A                 lea     edi, [ebp+var_38]
.text:0000014D                 mov     ecx, 0Bh
.text:00000152                 mov     eax, 0CCCCCCCCh
.text:00000157                 rep stosd
.text:00000159                 pop     ecx
.text:0000015A                 mov     eax, dword ptr ds:___security_cookie
.text:0000015F                 xor     eax, ebp
.text:00000161                 push    eax
.text:00000162                 lea     eax, [ebp+var_C]
.text:00000165                 mov     large fs:0, eax
.text:0000016B                 mov     [ebp+var_10], ecx
.text:0000016E                 mov     [ebp+var_38], 0
.text:00000175                 lea     ecx, [ebp+var_20]
.text:00000178                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:0000017D                 mov     [ebp+var_4], 1
.text:00000184
.text:00000184 loc_184:                                ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+BFj
.text:00000184                 mov     ecx, [ebp+var_10] ; this
.text:00000187                 call    ?GetChar@CStdInStream@@QAEHXZ ; CStdInStream::GetChar(void)
.text:0000018C                 mov     [ebp+var_28], eax
.text:0000018F                 cmp     [ebp+var_28], 0FFFFFFFFh
.text:00000193                 jnz     short loc_1B6
.text:00000195                 movzx   eax, [ebp+arg_4]
.text:00000199                 test    eax, eax
.text:0000019B                 jz      short loc_19F
.text:0000019D                 jmp     short loc_1F5
.text:0000019F ; ---------------------------------------------------------------------------
.text:0000019F
.text:0000019F loc_19F:                                ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+67j
.text:0000019F                 mov     ecx, ds:_kEOFMessage
.text:000001A5                 mov     [ebp+var_30], ecx
.text:000001A8                 push    offset __TI2CPAD
.text:000001AD                 lea     edx, [ebp+var_30]
.text:000001B0                 push    edx
.text:000001B1                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000001B6 ; ---------------------------------------------------------------------------
.text:000001B6
.text:000001B6 loc_1B6:                                ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+5Fj
.text:000001B6                 mov     al, byte ptr [ebp+var_28]
.text:000001B9                 mov     [ebp+var_29], al
.text:000001BC                 movsx   ecx, [ebp+var_29]
.text:000001C0                 test    ecx, ecx
.text:000001C2                 jnz     short loc_1DB
.text:000001C4                 mov     edx, ds:_kIllegalCharMessage
.text:000001CA                 mov     [ebp+var_34], edx
.text:000001CD                 push    offset __TI2CPAD
.text:000001D2                 lea     eax, [ebp+var_34]
.text:000001D5                 push    eax
.text:000001D6                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000001DB ; ---------------------------------------------------------------------------
.text:000001DB
.text:000001DB loc_1DB:                                ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+8Ej
.text:000001DB                 movsx   ecx, [ebp+var_29]
.text:000001DF                 cmp     ecx, 0Ah
.text:000001E2                 jnz     short loc_1E6
.text:000001E4                 jmp     short loc_1F5
.text:000001E6 ; ---------------------------------------------------------------------------
.text:000001E6
.text:000001E6 loc_1E6:                                ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+AEj
.text:000001E6                 movzx   edx, [ebp+var_29]
.text:000001EA                 push    edx
.text:000001EB                 lea     ecx, [ebp+var_20]
.text:000001EE                 call    ??YAString@@QAEAAV0@D@Z ; AString::operator+=(char)
.text:000001F3                 jmp     short loc_184
.text:000001F5 ; ---------------------------------------------------------------------------
.text:000001F5
.text:000001F5 loc_1F5:                                ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+69j
.text:000001F5                                         ; CStdInStream::ScanStringUntilNewLine(bool)+B0j
.text:000001F5                 lea     eax, [ebp+var_20]
.text:000001F8                 push    eax
.text:000001F9                 mov     ecx, [ebp+arg_0]
.text:000001FC                 call    ??0AString@@QAE@ABV0@@Z ; AString::AString(AString const &)
.text:00000201                 mov     ecx, [ebp+var_38]
.text:00000204                 or      ecx, 1
.text:00000207                 mov     [ebp+var_38], ecx
.text:0000020A                 mov     byte ptr [ebp+var_4], 0
.text:0000020E                 lea     ecx, [ebp+var_20] ; this
.text:00000211                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000216                 mov     eax, [ebp+arg_0]
.text:00000219                 push    edx
.text:0000021A                 mov     ecx, ebp
.text:0000021C                 push    eax
.text:0000021D                 lea     edx, $LN15
.text:00000223                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000228                 pop     eax
.text:00000229                 pop     edx
.text:0000022A                 mov     ecx, [ebp+var_C]
.text:0000022D                 mov     large fs:0, ecx
.text:00000234                 pop     ecx
.text:00000235                 pop     edi
.text:00000236                 add     esp, 38h
.text:00000239                 cmp     ebp, esp
.text:0000023B                 call    __RTC_CheckEsp
.text:00000240                 mov     esp, ebp
.text:00000242                 pop     ebp
.text:00000243                 retn    8
.text:00000243 ?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z endp
.text:00000243
.text:00000243 ; ---------------------------------------------------------------------------
.text:00000246                 align 4
.text:00000248 $LN15           dd 1                    ; DATA XREF: CStdInStream::ScanStringUntilNewLine(bool)+E9o
.text:0000024C                 dd offset $LN14
.text:00000250 $LN14           dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:0000024Co
.text:00000258                 dd offset $LN12
.text:0000025C $LN12           dd 0CCCC0073h, 0CCCCCCCCh ; DATA XREF: .text:00000258o
.text:00000264
.text:00000264 ; =============== S U B R O U T I N E =======================================
.text:00000264
.text:00000264 ; Attributes: bp-based frame
.text:00000264
.text:00000264 ; public: class UString __thiscall CStdInStream::ScanUStringUntilNewLine(void)
.text:00000264                 public ?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ
.text:00000264 ?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ proc near
.text:00000264
.text:00000264 var_54          = dword ptr -54h
.text:00000264 var_50          = dword ptr -50h
.text:00000264 var_4C          = dword ptr -4Ch
.text:00000264 var_48          = byte ptr -48h
.text:00000264 var_38          = byte ptr -38h
.text:00000264 var_28          = dword ptr -28h
.text:00000264 var_20          = byte ptr -20h
.text:00000264 var_10          = dword ptr -10h
.text:00000264 var_C           = dword ptr -0Ch
.text:00000264 var_4           = dword ptr -4
.text:00000264 arg_0           = dword ptr  8
.text:00000264
.text:00000264                 push    ebp
.text:00000265                 mov     ebp, esp
.text:00000267                 push    0FFFFFFFFh
.text:00000269                 push    offset __ehhandler$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ
.text:0000026E                 mov     eax, large fs:0
.text:00000274                 push    eax
.text:00000275                 sub     esp, 48h
.text:00000278                 push    edi
.text:00000279                 push    ecx
.text:0000027A                 lea     edi, [ebp+var_54]
.text:0000027D                 mov     ecx, 12h
.text:00000282                 mov     eax, 0CCCCCCCCh
.text:00000287                 rep stosd
.text:00000289                 pop     ecx
.text:0000028A                 mov     eax, dword ptr ds:___security_cookie
.text:0000028F                 xor     eax, ebp
.text:00000291                 push    eax
.text:00000292                 lea     eax, [ebp+var_C]
.text:00000295                 mov     large fs:0, eax
.text:0000029B                 mov     [ebp+var_10], ecx
.text:0000029E                 mov     [ebp+var_4C], 0
.text:000002A5                 push    1
.text:000002A7                 lea     eax, [ebp+var_20]
.text:000002AA                 push    eax
.text:000002AB                 mov     ecx, [ebp+var_10]
.text:000002AE                 call    ?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z ; CStdInStream::ScanStringUntilNewLine(bool)
.text:000002B3                 mov     [ebp+var_4], 1
.text:000002BA                 mov     ecx, dword ptr ds:?g_CodePage@@3HA ; int g_CodePage
.text:000002C0                 mov     [ebp+var_28], ecx
.text:000002C3                 cmp     [ebp+var_28], 0FFFFFFFFh
.text:000002C7                 jnz     short loc_2D0
.text:000002C9                 mov     [ebp+var_28], 1
.text:000002D0
.text:000002D0 loc_2D0:                                ; CODE XREF: CStdInStream::ScanUStringUntilNewLine(void)+63j
.text:000002D0                 lea     ecx, [ebp+var_38]
.text:000002D3                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000002D8                 mov     byte ptr [ebp+var_4], 2
.text:000002DC                 cmp     [ebp+var_28], 0FDE9h
.text:000002E3                 jnz     short loc_2F4
.text:000002E5                 lea     edx, [ebp+var_38]
.text:000002E8                 push    edx             ; struct UString *
.text:000002E9                 lea     eax, [ebp+var_20]
.text:000002EC                 push    eax             ; struct AString *
.text:000002ED                 call    ?ConvertUTF8ToUnicode@@YG_NABVAString@@AAVUString@@@Z ; ConvertUTF8ToUnicode(AString const &,UString &)
.text:000002F2                 jmp     short loc_32A
.text:000002F4 ; ---------------------------------------------------------------------------
.text:000002F4
.text:000002F4 loc_2F4:                                ; CODE XREF: CStdInStream::ScanUStringUntilNewLine(void)+7Fj
.text:000002F4                 mov     ecx, [ebp+var_28]
.text:000002F7                 push    ecx
.text:000002F8                 lea     edx, [ebp+var_20]
.text:000002FB                 push    edx
.text:000002FC                 lea     eax, [ebp+var_48]
.text:000002FF                 push    eax
.text:00000300                 call    ?MultiByteToUnicodeString@@YG?AVUString@@ABVAString@@I@Z ; MultiByteToUnicodeString(AString const &,uint)
.text:00000305                 mov     [ebp+var_50], eax
.text:00000308                 mov     ecx, [ebp+var_50]
.text:0000030B                 mov     [ebp+var_54], ecx
.text:0000030E                 mov     byte ptr [ebp+var_4], 3
.text:00000312                 mov     edx, [ebp+var_54]
.text:00000315                 push    edx
.text:00000316                 lea     ecx, [ebp+var_38]
.text:00000319                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:0000031E                 mov     byte ptr [ebp+var_4], 2
.text:00000322                 lea     ecx, [ebp+var_48] ; this
.text:00000325                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000032A
.text:0000032A loc_32A:                                ; CODE XREF: CStdInStream::ScanUStringUntilNewLine(void)+8Ej
.text:0000032A                 lea     eax, [ebp+var_38]
.text:0000032D                 push    eax             ; struct UString *
.text:0000032E                 mov     ecx, [ebp+arg_0] ; this
.text:00000331                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00000336                 mov     ecx, [ebp+var_4C]
.text:00000339                 or      ecx, 1
.text:0000033C                 mov     [ebp+var_4C], ecx
.text:0000033F                 mov     byte ptr [ebp+var_4], 1
.text:00000343                 lea     ecx, [ebp+var_38] ; this
.text:00000346                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000034B                 mov     byte ptr [ebp+var_4], 0
.text:0000034F                 lea     ecx, [ebp+var_20] ; this
.text:00000352                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000357                 mov     eax, [ebp+arg_0]
.text:0000035A                 push    edx
.text:0000035B                 mov     ecx, ebp
.text:0000035D                 push    eax
.text:0000035E                 lea     edx, $LN15_0
.text:00000364                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000369                 pop     eax
.text:0000036A                 pop     edx
.text:0000036B                 mov     ecx, [ebp+var_C]
.text:0000036E                 mov     large fs:0, ecx
.text:00000375                 pop     ecx
.text:00000376                 pop     edi
.text:00000377                 add     esp, 54h
.text:0000037A                 cmp     ebp, esp
.text:0000037C                 call    __RTC_CheckEsp
.text:00000381                 mov     esp, ebp
.text:00000383                 pop     ebp
.text:00000384                 retn    4
.text:00000384 ?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ endp
.text:00000384
.text:00000384 ; ---------------------------------------------------------------------------
.text:00000387                 align 4
.text:00000388 $LN15_0         dd 2                    ; DATA XREF: CStdInStream::ScanUStringUntilNewLine(void)+FAo
.text:0000038C                 dd offset $LN14_0
.text:00000390 $LN14_0         dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:0000038Co
.text:00000398                 dd offset $LN11         ; "s"
.text:0000039C                 dd 0FFFFFFC8h, 0Ch
.text:000003A4                 dd offset $LN12_0       ; "dest"
.text:000003A8 $LN12_0         db 'dest',0             ; DATA XREF: .text:000003A4o
.text:000003AD $LN11           db 's',0                ; DATA XREF: .text:00000398o
.text:000003AF                 db 5 dup(0CCh)
.text:000003B4
.text:000003B4 ; =============== S U B R O U T I N E =======================================
.text:000003B4
.text:000003B4 ; Attributes: bp-based frame
.text:000003B4
.text:000003B4 ; void __thiscall CStdInStream::ReadToString(CStdInStream *this, struct AString *)
.text:000003B4                 public ?ReadToString@CStdInStream@@QAEXAAVAString@@@Z
.text:000003B4 ?ReadToString@CStdInStream@@QAEXAAVAString@@@Z proc near
.text:000003B4
.text:000003B4 var_8           = dword ptr -8
.text:000003B4 var_4           = dword ptr -4
.text:000003B4 arg_0           = dword ptr  8
.text:000003B4
.text:000003B4                 push    ebp
.text:000003B5                 mov     ebp, esp
.text:000003B7                 sub     esp, 8
.text:000003BA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000003C1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000003C8                 mov     [ebp+var_4], ecx
.text:000003CB                 mov     ecx, [ebp+arg_0] ; this
.text:000003CE                 call    ?Empty@AString@@QAEXXZ ; AString::Empty(void)
.text:000003D3
.text:000003D3 loc_3D3:                                ; CODE XREF: CStdInStream::ReadToString(AString &)+3Dj
.text:000003D3                 mov     ecx, [ebp+var_4] ; this
.text:000003D6                 call    ?GetChar@CStdInStream@@QAEHXZ ; CStdInStream::GetChar(void)
.text:000003DB                 mov     [ebp+var_8], eax
.text:000003DE                 cmp     [ebp+var_8], 0FFFFFFFFh
.text:000003E2                 jz      short loc_3F3
.text:000003E4                 movzx   eax, byte ptr [ebp+var_8]
.text:000003E8                 push    eax
.text:000003E9                 mov     ecx, [ebp+arg_0]
.text:000003EC                 call    ??YAString@@QAEAAV0@D@Z ; AString::operator+=(char)
.text:000003F1                 jmp     short loc_3D3
.text:000003F3 ; ---------------------------------------------------------------------------
.text:000003F3
.text:000003F3 loc_3F3:                                ; CODE XREF: CStdInStream::ReadToString(AString &)+2Ej
.text:000003F3                 add     esp, 8
.text:000003F6                 cmp     ebp, esp
.text:000003F8                 call    __RTC_CheckEsp
.text:000003FD                 mov     esp, ebp
.text:000003FF                 pop     ebp
.text:00000400                 retn    4
.text:00000400 ?ReadToString@CStdInStream@@QAEXAAVAString@@@Z endp
.text:00000400
.text:00000400 ; ---------------------------------------------------------------------------
.text:00000403                 align 4
.text:00000404
.text:00000404 ; =============== S U B R O U T I N E =======================================
.text:00000404
.text:00000404 ; Attributes: bp-based frame
.text:00000404
.text:00000404 ; bool __thiscall CStdInStream::Eof(CStdInStream *__hidden this)
.text:00000404                 public ?Eof@CStdInStream@@QAE_NXZ
.text:00000404 ?Eof@CStdInStream@@QAE_NXZ proc near    ; CODE XREF: CStdInStream::GetChar(void)+43p
.text:00000404
.text:00000404 var_4           = dword ptr -4
.text:00000404
.text:00000404                 push    ebp
.text:00000405                 mov     ebp, esp
.text:00000407                 push    ecx
.text:00000408                 push    esi
.text:00000409                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000410                 mov     [ebp+var_4], ecx
.text:00000413                 mov     esi, esp
.text:00000415                 mov     eax, [ebp+var_4]
.text:00000418                 mov     ecx, [eax]
.text:0000041A                 push    ecx             ; File
.text:0000041B                 call    dword ptr ds:__imp__feof
.text:00000421                 add     esp, 4
.text:00000424                 cmp     esi, esp
.text:00000426                 call    __RTC_CheckEsp
.text:0000042B                 neg     eax
.text:0000042D                 sbb     eax, eax
.text:0000042F                 neg     eax
.text:00000431                 pop     esi
.text:00000432                 add     esp, 4
.text:00000435                 cmp     ebp, esp
.text:00000437                 call    __RTC_CheckEsp
.text:0000043C                 mov     esp, ebp
.text:0000043E                 pop     ebp
.text:0000043F                 retn
.text:0000043F ?Eof@CStdInStream@@QAE_NXZ endp
.text:0000043F
.text:0000043F ; ---------------------------------------------------------------------------
.text:00000440                 db 4 dup(0CCh)
.text:00000444
.text:00000444 ; =============== S U B R O U T I N E =======================================
.text:00000444
.text:00000444 ; Attributes: bp-based frame
.text:00000444
.text:00000444 ; int __thiscall CStdInStream::GetChar(CStdInStream *__hidden this)
.text:00000444                 public ?GetChar@CStdInStream@@QAEHXZ
.text:00000444 ?GetChar@CStdInStream@@QAEHXZ proc near ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+53p
.text:00000444                                         ; CStdInStream::ReadToString(AString &)+22p
.text:00000444
.text:00000444 var_C           = dword ptr -0Ch
.text:00000444 var_8           = dword ptr -8
.text:00000444 var_4           = dword ptr -4
.text:00000444
.text:00000444                 push    ebp
.text:00000445                 mov     ebp, esp
.text:00000447                 sub     esp, 0Ch
.text:0000044A                 push    esi
.text:0000044B                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000452                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000459                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000460                 mov     [ebp+var_4], ecx
.text:00000463                 mov     esi, esp
.text:00000465                 mov     eax, [ebp+var_4]
.text:00000468                 mov     ecx, [eax]
.text:0000046A                 push    ecx             ; File
.text:0000046B                 call    dword ptr ds:__imp__fgetc
.text:00000471                 add     esp, 4
.text:00000474                 cmp     esi, esp
.text:00000476                 call    __RTC_CheckEsp
.text:0000047B                 mov     [ebp+var_8], eax
.text:0000047E                 cmp     [ebp+var_8], 0FFFFFFFFh
.text:00000482                 jnz     short loc_4A9
.text:00000484                 mov     ecx, [ebp+var_4] ; this
.text:00000487                 call    ?Eof@CStdInStream@@QAE_NXZ ; CStdInStream::Eof(void)
.text:0000048C                 movzx   edx, al
.text:0000048F                 test    edx, edx
.text:00000491                 jnz     short loc_4A9
.text:00000493                 mov     eax, ds:_kReadErrorMessage
.text:00000498                 mov     [ebp+var_C], eax
.text:0000049B                 push    offset __TI2CPAD
.text:000004A0                 lea     ecx, [ebp+var_C]
.text:000004A3                 push    ecx
.text:000004A4                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000004A9 ; ---------------------------------------------------------------------------
.text:000004A9
.text:000004A9 loc_4A9:                                ; CODE XREF: CStdInStream::GetChar(void)+3Ej
.text:000004A9                                         ; CStdInStream::GetChar(void)+4Dj
.text:000004A9                 mov     eax, [ebp+var_8]
.text:000004AC                 pop     esi
.text:000004AD                 add     esp, 0Ch
.text:000004B0                 cmp     ebp, esp
.text:000004B2                 call    __RTC_CheckEsp
.text:000004B7                 mov     esp, ebp
.text:000004B9                 pop     ebp
.text:000004BA                 retn
.text:000004BA ?GetChar@CStdInStream@@QAEHXZ endp
.text:000004BA
.text:000004BA ; ---------------------------------------------------------------------------
.text:000004BB                 align 4
.text:000004BB _text           ends
.text:000004BB
.rtc$TMZ:000004BC ; ===========================================================================
.rtc$TMZ:000004BC
.rtc$TMZ:000004BC ; Segment type: Pure data
.rtc$TMZ:000004BC ; Segment permissions: Read
.rtc$TMZ:000004BC _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:000004BC                 assume cs:_rtc$TMZ
.rtc$TMZ:000004BC                 ;org 4BCh
.rtc$TMZ:000004BC ; COMDAT (pick any)
.rtc$TMZ:000004BC __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:000004BC _rtc$TMZ        ends
.rtc$TMZ:000004BC
.rtc$IMZ:000004C0 ; ===========================================================================
.rtc$IMZ:000004C0
.rtc$IMZ:000004C0 ; Segment type: Pure data
.rtc$IMZ:000004C0 ; Segment permissions: Read
.rtc$IMZ:000004C0 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:000004C0                 assume cs:_rtc$IMZ
.rtc$IMZ:000004C0                 ;org 4C0h
.rtc$IMZ:000004C0 ; COMDAT (pick any)
.rtc$IMZ:000004C0 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:000004C0 _rtc$IMZ        ends
.rtc$IMZ:000004C0
.text$x:000004C4 ; ===========================================================================
.text$x:000004C4
.text$x:000004C4 ; Segment type: Pure code
.text$x:000004C4 ; Segment permissions: Read/Execute
.text$x:000004C4 _text$x         segment para public 'CODE' use32
.text$x:000004C4                 assume cs:_text$x
.text$x:000004C4                 ;org 4C4h
.text$x:000004C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000004C4
.text$x:000004C4 ; =============== S U B R O U T I N E =======================================
.text$x:000004C4
.text$x:000004C4
.text$x:000004C4 __unwindfunclet$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z$0 proc near
.text$x:000004C4                                         ; DATA XREF: .xdata$x:00000568o
.text$x:000004C4                 lea     ecx, [ebp-20h]  ; this
.text$x:000004C7                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:000004C7 __unwindfunclet$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z$0 endp
.text$x:000004C7
.text$x:000004CC
.text$x:000004CC ; =============== S U B R O U T I N E =======================================
.text$x:000004CC
.text$x:000004CC
.text$x:000004CC __unwindfunclet$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z$1 proc near
.text$x:000004CC                                         ; DATA XREF: .xdata$x:00000560o
.text$x:000004CC                 mov     eax, [ebp-38h]
.text$x:000004CF                 and     eax, 1
.text$x:000004D2                 jz      locret_4E4
.text$x:000004D8                 and     dword ptr [ebp-38h], 0FFFFFFFEh
.text$x:000004DC                 mov     ecx, [ebp+8]    ; this
.text$x:000004DF                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:000004E4 ; ---------------------------------------------------------------------------
.text$x:000004E4
.text$x:000004E4 locret_4E4:                             ; CODE XREF: __unwindfunclet$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z$1+6j
.text$x:000004E4                 retn
.text$x:000004E4 __unwindfunclet$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z$1 endp
.text$x:000004E4
.text$x:000004E5
.text$x:000004E5 ; =============== S U B R O U T I N E =======================================
.text$x:000004E5
.text$x:000004E5
.text$x:000004E5 __ehhandler$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z proc near
.text$x:000004E5                                         ; DATA XREF: CStdInStream::ScanStringUntilNewLine(bool)+5o
.text$x:000004E5
.text$x:000004E5 arg_4           = dword ptr  8
.text$x:000004E5
.text$x:000004E5                 mov     edx, [esp+arg_4]
.text$x:000004E9                 lea     eax, [edx+0Ch]
.text$x:000004EC                 mov     ecx, [edx-34h]
.text$x:000004EF                 xor     ecx, eax
.text$x:000004F1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000004F6                 mov     eax, offset __ehfuncinfo$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z
.text$x:000004FB                 jmp     ___CxxFrameHandler3
.text$x:000004FB __ehhandler$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z endp
.text$x:000004FB
.text$x:00000500
.text$x:00000500 ; =============== S U B R O U T I N E =======================================
.text$x:00000500
.text$x:00000500
.text$x:00000500 __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$0 proc near
.text$x:00000500                                         ; DATA XREF: .xdata$x:0000059Co
.text$x:00000500                 lea     ecx, [ebp-20h]  ; this
.text$x:00000503                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00000503 __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$0 endp
.text$x:00000503
.text$x:00000508
.text$x:00000508 ; =============== S U B R O U T I N E =======================================
.text$x:00000508
.text$x:00000508
.text$x:00000508 __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$1 proc near
.text$x:00000508                                         ; DATA XREF: .xdata$x:000005A4o
.text$x:00000508                 lea     ecx, [ebp-38h]  ; this
.text$x:0000050B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000050B __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$1 endp
.text$x:0000050B
.text$x:00000510
.text$x:00000510 ; =============== S U B R O U T I N E =======================================
.text$x:00000510
.text$x:00000510
.text$x:00000510 __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$2 proc near
.text$x:00000510                                         ; DATA XREF: .xdata$x:000005ACo
.text$x:00000510                 lea     ecx, [ebp-48h]  ; this
.text$x:00000513                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000513 __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$2 endp
.text$x:00000513
.text$x:00000518
.text$x:00000518 ; =============== S U B R O U T I N E =======================================
.text$x:00000518
.text$x:00000518
.text$x:00000518 __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$3 proc near
.text$x:00000518                                         ; DATA XREF: .xdata$x:00000594o
.text$x:00000518                 mov     eax, [ebp-4Ch]
.text$x:0000051B                 and     eax, 1
.text$x:0000051E                 jz      locret_530
.text$x:00000524                 and     dword ptr [ebp-4Ch], 0FFFFFFFEh
.text$x:00000528                 mov     ecx, [ebp+8]    ; this
.text$x:0000052B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000530 ; ---------------------------------------------------------------------------
.text$x:00000530
.text$x:00000530 locret_530:                             ; CODE XREF: __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$3+6j
.text$x:00000530                 retn
.text$x:00000530 __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$3 endp
.text$x:00000530
.text$x:00000531
.text$x:00000531 ; =============== S U B R O U T I N E =======================================
.text$x:00000531
.text$x:00000531
.text$x:00000531 __ehhandler$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ proc near
.text$x:00000531                                         ; DATA XREF: CStdInStream::ScanUStringUntilNewLine(void)+5o
.text$x:00000531
.text$x:00000531 arg_4           = dword ptr  8
.text$x:00000531
.text$x:00000531                 mov     edx, [esp+arg_4]
.text$x:00000535                 lea     eax, [edx+0Ch]
.text$x:00000538                 mov     ecx, [edx-50h]
.text$x:0000053B                 xor     ecx, eax
.text$x:0000053D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000542                 mov     eax, offset __ehfuncinfo$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ
.text$x:00000547                 jmp     ___CxxFrameHandler3
.text$x:00000547 __ehhandler$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ endp
.text$x:00000547
.text$x:00000547 _text$x         ends
.text$x:00000547
.xdata$x:0000054C ; ===========================================================================
.xdata$x:0000054C
.xdata$x:0000054C ; Segment type: Pure data
.xdata$x:0000054C ; Segment permissions: Read
.xdata$x:0000054C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000054C                 assume cs:_xdata$x
.xdata$x:0000054C                 ;org 54Ch
.xdata$x:0000054C ; COMDAT (pick any)
.xdata$x:0000054C                 public __TI2CPAD
.xdata$x:0000054C __TI2CPAD       db    1                 ; DATA XREF: CStdInStream::ScanStringUntilNewLine(bool)+74o
.xdata$x:0000054C                                         ; CStdInStream::ScanStringUntilNewLine(bool)+99o ...
.xdata$x:0000054D                 db    0
.xdata$x:0000054E                 db    0
.xdata$x:0000054F                 db    0
.xdata$x:00000550                 db    0
.xdata$x:00000551                 db    0
.xdata$x:00000552                 db    0
.xdata$x:00000553                 db    0
.xdata$x:00000554                 db    0
.xdata$x:00000555                 db    0
.xdata$x:00000556                 db    0
.xdata$x:00000557                 db    0
.xdata$x:00000558                 dd offset __CTA2PAD
.xdata$x:00000558 _xdata$x        ends
.xdata$x:00000558
.xdata$x:0000055C ; ===========================================================================
.xdata$x:0000055C
.xdata$x:0000055C ; Segment type: Pure data
.xdata$x:0000055C ; Segment permissions: Read
.xdata$x:0000055C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000055C                 assume cs:_xdata$x
.xdata$x:0000055C                 ;org 55Ch
.xdata$x:0000055C __unwindtable$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z db 0FFh
.xdata$x:0000055C                                         ; DATA XREF: .xdata$x:00000574o
.xdata$x:0000055D                 db 0FFh
.xdata$x:0000055E                 db 0FFh
.xdata$x:0000055F                 db 0FFh
.xdata$x:00000560                 dd offset __unwindfunclet$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z$1
.xdata$x:00000564                 align 8
.xdata$x:00000568                 dd offset __unwindfunclet$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z$0
.xdata$x:0000056C __ehfuncinfo$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z db  22h ; "
.xdata$x:0000056C                                         ; DATA XREF: __ehhandler$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z+11o
.xdata$x:0000056D                 db    5
.xdata$x:0000056E                 db  93h ; ô
.xdata$x:0000056F                 db  19h
.xdata$x:00000570                 db    2
.xdata$x:00000571                 db    0
.xdata$x:00000572                 db    0
.xdata$x:00000573                 db    0
.xdata$x:00000574                 dd offset __unwindtable$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z
.xdata$x:00000578                 db    0
.xdata$x:00000579                 db    0
.xdata$x:0000057A                 db    0
.xdata$x:0000057B                 db    0
.xdata$x:0000057C                 db    0
.xdata$x:0000057D                 db    0
.xdata$x:0000057E                 db    0
.xdata$x:0000057F                 db    0
.xdata$x:00000580                 db    0
.xdata$x:00000581                 db    0
.xdata$x:00000582                 db    0
.xdata$x:00000583                 db    0
.xdata$x:00000584                 db    0
.xdata$x:00000585                 db    0
.xdata$x:00000586                 db    0
.xdata$x:00000587                 db    0
.xdata$x:00000588                 db    0
.xdata$x:00000589                 db    0
.xdata$x:0000058A                 db    0
.xdata$x:0000058B                 db    0
.xdata$x:0000058C                 db    1
.xdata$x:0000058D                 db    0
.xdata$x:0000058E                 db    0
.xdata$x:0000058F                 db    0
.xdata$x:00000590 __unwindtable$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ db 0FFh
.xdata$x:00000590                                         ; DATA XREF: .xdata$x:000005B8o
.xdata$x:00000591                 db 0FFh
.xdata$x:00000592                 db 0FFh
.xdata$x:00000593                 db 0FFh
.xdata$x:00000594                 dd offset __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$3
.xdata$x:00000598                 db    0
.xdata$x:00000599                 db    0
.xdata$x:0000059A                 db    0
.xdata$x:0000059B                 db    0
.xdata$x:0000059C                 dd offset __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$0
.xdata$x:000005A0                 db    1
.xdata$x:000005A1                 db    0
.xdata$x:000005A2                 db    0
.xdata$x:000005A3                 db    0
.xdata$x:000005A4                 dd offset __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$1
.xdata$x:000005A8                 db    2
.xdata$x:000005A9                 db    0
.xdata$x:000005AA                 db    0
.xdata$x:000005AB                 db    0
.xdata$x:000005AC                 dd offset __unwindfunclet$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ$2
.xdata$x:000005B0 __ehfuncinfo$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ db  22h ; "
.xdata$x:000005B0                                         ; DATA XREF: __ehhandler$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ+11o
.xdata$x:000005B1                 db    5
.xdata$x:000005B2                 db  93h ; ô
.xdata$x:000005B3                 db  19h
.xdata$x:000005B4                 db    4
.xdata$x:000005B5                 db    0
.xdata$x:000005B6                 db    0
.xdata$x:000005B7                 db    0
.xdata$x:000005B8                 dd offset __unwindtable$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ
.xdata$x:000005BC                 db    0
.xdata$x:000005BD                 db    0
.xdata$x:000005BE                 db    0
.xdata$x:000005BF                 db    0
.xdata$x:000005C0                 db    0
.xdata$x:000005C1                 db    0
.xdata$x:000005C2                 db    0
.xdata$x:000005C3                 db    0
.xdata$x:000005C4                 db    0
.xdata$x:000005C5                 db    0
.xdata$x:000005C6                 db    0
.xdata$x:000005C7                 db    0
.xdata$x:000005C8                 db    0
.xdata$x:000005C9                 db    0
.xdata$x:000005CA                 db    0
.xdata$x:000005CB                 db    0
.xdata$x:000005CC                 db    0
.xdata$x:000005CD                 db    0
.xdata$x:000005CE                 db    0
.xdata$x:000005CF                 db    0
.xdata$x:000005D0                 db    1
.xdata$x:000005D1                 db    0
.xdata$x:000005D2                 db    0
.xdata$x:000005D3                 db    0
.xdata$x:000005D3 _xdata$x        ends
.xdata$x:000005D3
.xdata$x:000005D4 ; ===========================================================================
.xdata$x:000005D4
.xdata$x:000005D4 ; Segment type: Pure data
.xdata$x:000005D4 ; Segment permissions: Read
.xdata$x:000005D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000005D4                 assume cs:_xdata$x
.xdata$x:000005D4                 ;org 5D4h
.xdata$x:000005D4 ; COMDAT (pick any)
.xdata$x:000005D4                 public __CTA2PAD
.xdata$x:000005D4 __CTA2PAD       db    2                 ; DATA XREF: .xdata$x:00000558o
.xdata$x:000005D5                 db    0
.xdata$x:000005D6                 db    0
.xdata$x:000005D7                 db    0
.xdata$x:000005D8                 dd offset __CT??_R0PAD@84
.xdata$x:000005DC                 dd offset __CT??_R0PAX@84
.xdata$x:000005DC _xdata$x        ends
.xdata$x:000005DC
.xdata$x:000005E0 ; ===========================================================================
.xdata$x:000005E0
.xdata$x:000005E0 ; Segment type: Pure data
.xdata$x:000005E0 ; Segment permissions: Read
.xdata$x:000005E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000005E0                 assume cs:_xdata$x
.xdata$x:000005E0                 ;org 5E0h
.xdata$x:000005E0 ; COMDAT (pick any)
.xdata$x:000005E0                 public __CT??_R0PAD@84
.xdata$x:000005E0 __CT??_R0PAD@84 db    1                 ; DATA XREF: .xdata$x:000005D8o
.xdata$x:000005E1                 db    0
.xdata$x:000005E2                 db    0
.xdata$x:000005E3                 db    0
.xdata$x:000005E4                 dd offset ??_R0PAD@8    ; char * `RTTI Type Descriptor'
.xdata$x:000005E8                 db    0
.xdata$x:000005E9                 db    0
.xdata$x:000005EA                 db    0
.xdata$x:000005EB                 db    0
.xdata$x:000005EC                 db 0FFh
.xdata$x:000005ED                 db 0FFh
.xdata$x:000005EE                 db 0FFh
.xdata$x:000005EF                 db 0FFh
.xdata$x:000005F0                 db    0
.xdata$x:000005F1                 db    0
.xdata$x:000005F2                 db    0
.xdata$x:000005F3                 db    0
.xdata$x:000005F4                 db    4
.xdata$x:000005F5                 db    0
.xdata$x:000005F6                 db    0
.xdata$x:000005F7                 db    0
.xdata$x:000005F8                 db    0
.xdata$x:000005F9                 db    0
.xdata$x:000005FA                 db    0
.xdata$x:000005FB                 db    0
.xdata$x:000005FB _xdata$x        ends
.xdata$x:000005FB
.data:000005FC ; ===========================================================================
.data:000005FC
.data:000005FC ; Segment type: Pure data
.data:000005FC ; Segment permissions: Read/Write
.data:000005FC _data           segment dword public 'DATA' use32
.data:000005FC                 assume cs:_data
.data:000005FC                 ;org 5FCh
.data:000005FC ; COMDAT (pick any)
.data:000005FC                 public ??_R0PAD@8
.data:000005FC ; char * `RTTI Type Descriptor'
.data:000005FC ??_R0PAD@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:000005E4o
.data:000005FC                                         ; const type_info::`vftable'
.data:00000600                 db    0
.data:00000601                 db    0
.data:00000602                 db    0
.data:00000603                 db    0
.data:00000604                 db  2Eh ; .
.data:00000605                 db  50h ; P
.data:00000606                 db  41h ; A
.data:00000607                 db  44h ; D
.data:00000608                 db    0
.data:00000609                 align 4
.data:00000609 _data           ends
.data:00000609
.xdata$x:0000060C ; ===========================================================================
.xdata$x:0000060C
.xdata$x:0000060C ; Segment type: Pure data
.xdata$x:0000060C ; Segment permissions: Read
.xdata$x:0000060C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000060C                 assume cs:_xdata$x
.xdata$x:0000060C                 ;org 60Ch
.xdata$x:0000060C ; COMDAT (pick any)
.xdata$x:0000060C                 public __CT??_R0PAX@84
.xdata$x:0000060C __CT??_R0PAX@84 db    1                 ; DATA XREF: .xdata$x:000005DCo
.xdata$x:0000060D                 db    0
.xdata$x:0000060E                 db    0
.xdata$x:0000060F                 db    0
.xdata$x:00000610                 dd offset ??_R0PAX@8    ; void * `RTTI Type Descriptor'
.xdata$x:00000614                 align 8
.xdata$x:00000618                 db 0FFh
.xdata$x:00000619                 db 0FFh
.xdata$x:0000061A                 db 0FFh
.xdata$x:0000061B                 db 0FFh
.xdata$x:0000061C                 db    0
.xdata$x:0000061D                 db    0
.xdata$x:0000061E                 db    0
.xdata$x:0000061F                 db    0
.xdata$x:00000620                 db    4
.xdata$x:00000621                 db    0
.xdata$x:00000622                 db    0
.xdata$x:00000623                 db    0
.xdata$x:00000624                 db    0
.xdata$x:00000625                 db    0
.xdata$x:00000626                 db    0
.xdata$x:00000627                 db    0
.xdata$x:00000627 _xdata$x        ends
.xdata$x:00000627
.data:00000628 ; ===========================================================================
.data:00000628
.data:00000628 ; Segment type: Pure data
.data:00000628 ; Segment permissions: Read/Write
.data:00000628 _data           segment dword public 'DATA' use32
.data:00000628                 assume cs:_data
.data:00000628                 ;org 628h
.data:00000628 ; COMDAT (pick any)
.data:00000628                 public ??_R0PAX@8
.data:00000628 ; void * `RTTI Type Descriptor'
.data:00000628 ??_R0PAX@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00000610o
.data:00000628                                         ; const type_info::`vftable'
.data:0000062C                 align 10h
.data:00000630 a_pax           db '.PAX',0
.data:00000635                 align 4
.data:00000635 _data           ends
.data:00000635
.text:00000638 ; ===========================================================================
.text:00000638
.text:00000638 ; Segment type: Pure code
.text:00000638 ; Segment permissions: Read/Execute
.text:00000638 _text           segment para public 'CODE' use32
.text:00000638                 assume cs:_text
.text:00000638                 ;org 638h
.text:00000638 ; COMDAT (pick any)
.text:00000638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000638
.text:00000638 ; =============== S U B R O U T I N E =======================================
.text:00000638
.text:00000638 ; Attributes: bp-based frame
.text:00000638
.text:00000638 ; _DWORD __thiscall AString::~AString(AString *__hidden this)
.text:00000638                 public ??1AString@@QAE@XZ
.text:00000638 ??1AString@@QAE@XZ proc near            ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+DDp
.text:00000638                                         ; CStdInStream::ScanUStringUntilNewLine(void)+EEp ...
.text:00000638
.text:00000638 var_8           = dword ptr -8
.text:00000638 var_4           = dword ptr -4
.text:00000638
.text:00000638                 push    ebp
.text:00000639                 mov     ebp, esp
.text:0000063B                 sub     esp, 8
.text:0000063E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000645                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000064C                 mov     [ebp+var_4], ecx
.text:0000064F                 mov     eax, [ebp+var_4]
.text:00000652                 mov     ecx, [eax]
.text:00000654                 mov     [ebp+var_8], ecx
.text:00000657                 mov     edx, [ebp+var_8]
.text:0000065A                 push    edx             ; void *
.text:0000065B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000660                 add     esp, 4
.text:00000663                 add     esp, 8
.text:00000666                 cmp     ebp, esp
.text:00000668                 call    __RTC_CheckEsp
.text:0000066D                 mov     esp, ebp
.text:0000066F                 pop     ebp
.text:00000670                 retn
.text:00000670 ??1AString@@QAE@XZ endp
.text:00000670
.text:00000670 ; ---------------------------------------------------------------------------
.text:00000671                 align 4
.text:00000671 _text           ends
.text:00000671
.text:00000674 ; ===========================================================================
.text:00000674
.text:00000674 ; Segment type: Pure code
.text:00000674 ; Segment permissions: Read/Execute
.text:00000674 _text           segment para public 'CODE' use32
.text:00000674                 assume cs:_text
.text:00000674                 ;org 674h
.text:00000674 ; COMDAT (pick any)
.text:00000674                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000674
.text:00000674 ; =============== S U B R O U T I N E =======================================
.text:00000674
.text:00000674 ; Attributes: bp-based frame
.text:00000674
.text:00000674 ; public: class AString & __thiscall AString::operator+=(char)
.text:00000674                 public ??YAString@@QAEAAV0@D@Z
.text:00000674 ??YAString@@QAEAAV0@D@Z proc near       ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+BAp
.text:00000674                                         ; CStdInStream::ReadToString(AString &)+38p
.text:00000674
.text:00000674 var_C           = dword ptr -0Ch
.text:00000674 var_8           = dword ptr -8
.text:00000674 var_4           = dword ptr -4
.text:00000674 arg_0           = byte ptr  8
.text:00000674
.text:00000674                 push    ebp
.text:00000675                 mov     ebp, esp
.text:00000677                 sub     esp, 0Ch
.text:0000067A                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000681                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000688                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000068F                 mov     [ebp+var_4], ecx
.text:00000692                 mov     eax, [ebp+var_4]
.text:00000695                 mov     ecx, [ebp+var_4]
.text:00000698                 mov     edx, [eax+8]
.text:0000069B                 cmp     edx, [ecx+4]
.text:0000069E                 jnz     short loc_6A8
.text:000006A0                 mov     ecx, [ebp+var_4] ; this
.text:000006A3                 call    ?Grow_1@AString@@AAEXXZ ; AString::Grow_1(void)
.text:000006A8
.text:000006A8 loc_6A8:                                ; CODE XREF: AString::operator+=(char)+2Aj
.text:000006A8                 mov     eax, [ebp+var_4]
.text:000006AB                 mov     ecx, [eax+4]
.text:000006AE                 mov     [ebp+var_8], ecx
.text:000006B1                 mov     edx, [ebp+var_4]
.text:000006B4                 mov     eax, [edx]
.text:000006B6                 mov     [ebp+var_C], eax
.text:000006B9                 mov     ecx, [ebp+var_C]
.text:000006BC                 add     ecx, [ebp+var_8]
.text:000006BF                 mov     dl, [ebp+arg_0]
.text:000006C2                 mov     [ecx], dl
.text:000006C4                 mov     eax, [ebp+var_8]
.text:000006C7                 add     eax, 1
.text:000006CA                 mov     [ebp+var_8], eax
.text:000006CD                 mov     ecx, [ebp+var_C]
.text:000006D0                 add     ecx, [ebp+var_8]
.text:000006D3                 mov     byte ptr [ecx], 0
.text:000006D6                 mov     edx, [ebp+var_4]
.text:000006D9                 mov     eax, [ebp+var_8]
.text:000006DC                 mov     [edx+4], eax
.text:000006DF                 mov     eax, [ebp+var_4]
.text:000006E2                 add     esp, 0Ch
.text:000006E5                 cmp     ebp, esp
.text:000006E7                 call    __RTC_CheckEsp
.text:000006EC                 mov     esp, ebp
.text:000006EE                 pop     ebp
.text:000006EF                 retn    4
.text:000006EF ??YAString@@QAEAAV0@D@Z endp
.text:000006EF
.text:000006EF ; ---------------------------------------------------------------------------
.text:000006F2                 align 4
.text:000006F2 _text           ends
.text:000006F2
.text:000006F4 ; ===========================================================================
.text:000006F4
.text:000006F4 ; Segment type: Pure code
.text:000006F4 ; Segment permissions: Read/Execute
.text:000006F4 _text           segment para public 'CODE' use32
.text:000006F4                 assume cs:_text
.text:000006F4                 ;org 6F4h
.text:000006F4 ; COMDAT (pick any)
.text:000006F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000006F4
.text:000006F4 ; =============== S U B R O U T I N E =======================================
.text:000006F4
.text:000006F4 ; Attributes: bp-based frame
.text:000006F4
.text:000006F4 ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:000006F4                 public ??1UString@@QAE@XZ
.text:000006F4 ??1UString@@QAE@XZ proc near            ; CODE XREF: CStdInStream::ScanUStringUntilNewLine(void)+C1p
.text:000006F4                                         ; CStdInStream::ScanUStringUntilNewLine(void)+E2p ...
.text:000006F4
.text:000006F4 var_8           = dword ptr -8
.text:000006F4 var_4           = dword ptr -4
.text:000006F4
.text:000006F4                 push    ebp
.text:000006F5                 mov     ebp, esp
.text:000006F7                 sub     esp, 8
.text:000006FA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000701                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000708                 mov     [ebp+var_4], ecx
.text:0000070B                 mov     eax, [ebp+var_4]
.text:0000070E                 mov     ecx, [eax]
.text:00000710                 mov     [ebp+var_8], ecx
.text:00000713                 mov     edx, [ebp+var_8]
.text:00000716                 push    edx             ; void *
.text:00000717                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000071C                 add     esp, 4
.text:0000071F                 add     esp, 8
.text:00000722                 cmp     ebp, esp
.text:00000724                 call    __RTC_CheckEsp
.text:00000729                 mov     esp, ebp
.text:0000072B                 pop     ebp
.text:0000072C                 retn
.text:0000072C ??1UString@@QAE@XZ endp
.text:0000072C
.text:0000072C ; ---------------------------------------------------------------------------
.text:0000072D                 align 10h
.text:0000072D _text           ends
.text:0000072D
.text:00000730 ; ===========================================================================
.text:00000730
.text:00000730 ; Segment type: Pure code
.text:00000730 ; Segment permissions: Read/Execute
.text:00000730 _text           segment para public 'CODE' use32
.text:00000730                 assume cs:_text
.text:00000730                 ;org 730h
.text:00000730 ; COMDAT (pick any)
.text:00000730                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000730
.text:00000730 ; =============== S U B R O U T I N E =======================================
.text:00000730
.text:00000730 ; Attributes: bp-based frame
.text:00000730
.text:00000730 ; void __thiscall AString::Empty(AString *__hidden this)
.text:00000730                 public ?Empty@AString@@QAEXXZ
.text:00000730 ?Empty@AString@@QAEXXZ proc near        ; CODE XREF: CStdInStream::ReadToString(AString &)+1Ap
.text:00000730
.text:00000730 var_4           = dword ptr -4
.text:00000730
.text:00000730                 push    ebp
.text:00000731                 mov     ebp, esp
.text:00000733                 push    ecx
.text:00000734                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000073B                 mov     [ebp+var_4], ecx
.text:0000073E                 mov     eax, [ebp+var_4]
.text:00000741                 mov     dword ptr [eax+4], 0
.text:00000748                 mov     ecx, [ebp+var_4]
.text:0000074B                 mov     edx, [ecx]
.text:0000074D                 mov     byte ptr [edx], 0
.text:00000750                 mov     esp, ebp
.text:00000752                 pop     ebp
.text:00000753                 retn
.text:00000753 ?Empty@AString@@QAEXXZ endp
.text:00000753
.text:00000753 _text           ends
.text:00000753
.text$yc:00000754 ; ===========================================================================
.text$yc:00000754
.text$yc:00000754 ; Segment type: Pure code
.text$yc:00000754 ; Segment permissions: Read/Execute
.text$yc:00000754 _text$yc        segment para public 'CODE' use32
.text$yc:00000754                 assume cs:_text$yc
.text$yc:00000754                 ;org 754h
.text$yc:00000754 ; COMDAT (pick any)
.text$yc:00000754                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yc:00000754
.text$yc:00000754 ; =============== S U B R O U T I N E =======================================
.text$yc:00000754
.text$yc:00000754 ; Attributes: bp-based frame
.text$yc:00000754
.text$yc:00000754 ; void __cdecl `dynamic initializer for 'g_StdIn''(void)
.text$yc:00000754 ??__Eg_StdIn@@YAXXZ proc near           ; DATA XREF: .CRT$XCU:_g_StdIn$initializer$o
.text$yc:00000754                 push    ebp
.text$yc:00000755                 mov     ebp, esp
.text$yc:00000757                 push    esi
.text$yc:00000758                 mov     esi, esp
.text$yc:0000075A                 call    dword ptr ds:__imp____iob_func
.text$yc:00000760                 cmp     esi, esp
.text$yc:00000762                 call    __RTC_CheckEsp
.text$yc:00000767                 push    eax             ; struct _iobuf *
.text$yc:00000768                 mov     ecx, offset ?g_StdIn@@3VCStdInStream@@A ; this
.text$yc:0000076D                 call    ??0CStdInStream@@QAE@PAU_iobuf@@@Z ; CStdInStream::CStdInStream(_iobuf *)
.text$yc:00000772                 push    offset ??__Fg_StdIn@@YAXXZ ; void (__cdecl *)()
.text$yc:00000777                 call    _atexit
.text$yc:0000077C                 add     esp, 4
.text$yc:0000077F                 pop     esi
.text$yc:00000780                 cmp     ebp, esp
.text$yc:00000782                 call    __RTC_CheckEsp
.text$yc:00000787                 pop     ebp
.text$yc:00000788                 retn
.text$yc:00000788 ??__Eg_StdIn@@YAXXZ endp
.text$yc:00000788
.text$yc:00000788 ; ---------------------------------------------------------------------------
.text$yc:00000789                 align 4
.text$yc:00000789 _text$yc        ends
.text$yc:00000789
.text:0000078C ; ===========================================================================
.text:0000078C
.text:0000078C ; Segment type: Pure code
.text:0000078C ; Segment permissions: Read/Execute
.text:0000078C _text           segment para public 'CODE' use32
.text:0000078C                 assume cs:_text
.text:0000078C                 ;org 78Ch
.text:0000078C ; COMDAT (pick any)
.text:0000078C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000078C
.text:0000078C ; =============== S U B R O U T I N E =======================================
.text:0000078C
.text:0000078C ; Attributes: bp-based frame
.text:0000078C
.text:0000078C ; _DWORD __thiscall CStdInStream::CStdInStream(CStdInStream *this, struct _iobuf *)
.text:0000078C                 public ??0CStdInStream@@QAE@PAU_iobuf@@@Z
.text:0000078C ??0CStdInStream@@QAE@PAU_iobuf@@@Z proc near
.text:0000078C                                         ; CODE XREF: `dynamic initializer for 'g_StdIn''(void)+19p
.text:0000078C
.text:0000078C var_4           = dword ptr -4
.text:0000078C arg_0           = dword ptr  8
.text:0000078C
.text:0000078C                 push    ebp
.text:0000078D                 mov     ebp, esp
.text:0000078F                 push    ecx
.text:00000790                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000797                 mov     [ebp+var_4], ecx
.text:0000079A                 mov     eax, [ebp+var_4]
.text:0000079D                 mov     ecx, [ebp+arg_0]
.text:000007A0                 mov     [eax], ecx
.text:000007A2                 mov     edx, [ebp+var_4]
.text:000007A5                 mov     byte ptr [edx+4], 0
.text:000007A9                 mov     eax, [ebp+var_4]
.text:000007AC                 mov     esp, ebp
.text:000007AE                 pop     ebp
.text:000007AF                 retn    4
.text:000007AF ??0CStdInStream@@QAE@PAU_iobuf@@@Z endp
.text:000007AF
.text:000007AF ; ---------------------------------------------------------------------------
.text:000007B2                 align 4
.text:000007B2 _text           ends
.text:000007B2
.text$yd:000007B4 ; ===========================================================================
.text$yd:000007B4
.text$yd:000007B4 ; Segment type: Pure code
.text$yd:000007B4 ; Segment permissions: Read/Execute
.text$yd:000007B4 _text$yd        segment para public 'CODE' use32
.text$yd:000007B4                 assume cs:_text$yd
.text$yd:000007B4                 ;org 7B4h
.text$yd:000007B4 ; COMDAT (pick any)
.text$yd:000007B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000007B4
.text$yd:000007B4 ; =============== S U B R O U T I N E =======================================
.text$yd:000007B4
.text$yd:000007B4 ; Attributes: bp-based frame
.text$yd:000007B4
.text$yd:000007B4 ; void __cdecl `dynamic atexit destructor for 'g_StdIn''()
.text$yd:000007B4 ??__Fg_StdIn@@YAXXZ proc near           ; DATA XREF: `dynamic initializer for 'g_StdIn''(void)+1Eo
.text$yd:000007B4                 push    ebp
.text$yd:000007B5                 mov     ebp, esp
.text$yd:000007B7                 mov     ecx, offset ?g_StdIn@@3VCStdInStream@@A ; this
.text$yd:000007BC                 call    ??1CStdInStream@@QAE@XZ ; CStdInStream::~CStdInStream(void)
.text$yd:000007C1                 cmp     ebp, esp
.text$yd:000007C3                 call    __RTC_CheckEsp
.text$yd:000007C8                 pop     ebp
.text$yd:000007C9                 retn
.text$yd:000007C9 ??__Fg_StdIn@@YAXXZ endp
.text$yd:000007C9
.text$yd:000007C9 ; ---------------------------------------------------------------------------
.text$yd:000007CA                 align 4
.text$yd:000007CA _text$yd        ends
.text$yd:000007CA
.text:000007CC ; ===========================================================================
.text:000007CC
.text:000007CC ; Segment type: Pure code
.text:000007CC ; Segment permissions: Read/Execute
.text:000007CC _text           segment para public 'CODE' use32
.text:000007CC                 assume cs:_text
.text:000007CC                 ;org 7CCh
.text:000007CC ; COMDAT (pick any)
.text:000007CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000007CC
.text:000007CC ; =============== S U B R O U T I N E =======================================
.text:000007CC
.text:000007CC ; Attributes: bp-based frame
.text:000007CC
.text:000007CC ; _DWORD __thiscall CStdInStream::~CStdInStream(CStdInStream *__hidden this)
.text:000007CC                 public ??1CStdInStream@@QAE@XZ
.text:000007CC ??1CStdInStream@@QAE@XZ proc near       ; CODE XREF: `dynamic atexit destructor for 'g_StdIn''(void)+8p
.text:000007CC
.text:000007CC var_4           = dword ptr -4
.text:000007CC
.text:000007CC                 push    ebp
.text:000007CD                 mov     ebp, esp
.text:000007CF                 push    ecx
.text:000007D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000007D7                 mov     [ebp+var_4], ecx
.text:000007DA                 mov     ecx, [ebp+var_4] ; this
.text:000007DD                 call    ?Close@CStdInStream@@QAE_NXZ ; CStdInStream::Close(void)
.text:000007E2                 add     esp, 4
.text:000007E5                 cmp     ebp, esp
.text:000007E7                 call    __RTC_CheckEsp
.text:000007EC                 mov     esp, ebp
.text:000007EE                 pop     ebp
.text:000007EF                 retn
.text:000007EF ??1CStdInStream@@QAE@XZ endp
.text:000007EF
.text:000007EF _text           ends
.text:000007EF
.bss:000007F0 ; ===========================================================================
.bss:000007F0
.bss:000007F0 ; Segment type: Uninitialized
.bss:000007F0 ; Segment permissions: Read/Write
.bss:000007F0 _bss            segment dword public 'BSS' use32
.bss:000007F0                 assume cs:_bss
.bss:000007F0                 ;org 7F0h
.bss:000007F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000007F0                 public ?g_StdIn@@3VCStdInStream@@A
.bss:000007F0 ; CStdInStream g_StdIn
.bss:000007F0 ?g_StdIn@@3VCStdInStream@@A db    ? ;   ; DATA XREF: `dynamic initializer for 'g_StdIn''(void)+14o
.bss:000007F0                                         ; `dynamic atexit destructor for 'g_StdIn''(void)+3o
.bss:000007F1                 db    ? ;
.bss:000007F2                 db    ? ;
.bss:000007F3                 db    ? ;
.bss:000007F4                 db    ? ;
.bss:000007F5                 db    ? ;
.bss:000007F6                 db    ? ;
.bss:000007F7                 db    ? ;
.bss:000007F7 _bss            ends
.bss:000007F7
.CRT$XCU:000007F8 ; ===========================================================================
.CRT$XCU:000007F8
.CRT$XCU:000007F8 ; Segment type: Pure data
.CRT$XCU:000007F8 ; Segment permissions: Read
.CRT$XCU:000007F8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000007F8                 assume cs:_CRT$XCU
.CRT$XCU:000007F8                 ;org 7F8h
.CRT$XCU:000007F8 _g_StdIn$initializer$ dd offset ??__Eg_StdIn@@YAXXZ ; `dynamic initializer for 'g_StdIn''(void)
.CRT$XCU:000007F8 _CRT$XCU        ends
.CRT$XCU:000007F8
UNDEF:00000800 ; ===========================================================================
UNDEF:00000800
UNDEF:00000800 ; Segment type: Externs
UNDEF:00000800 ; UNDEF
UNDEF:00000800 ; FILE *__cdecl _fopen(const char *Filename, const char *Mode)
UNDEF:00000800                 extrn __imp__fopen:near ; CODE XREF: CStdInStream::Open(char const *)+23p
UNDEF:00000800                                         ; DATA XREF: CStdInStream::Open(char const *)+23r
UNDEF:00000804                 extrn __RTC_CheckEsp:near
UNDEF:00000804                                         ; CODE XREF: CStdInStream::Open(char const *)+2Ep
UNDEF:00000804                                         ; CStdInStream::Open(char const *)+55p ...
UNDEF:00000808                 extrn __RTC_Shutdown:near
UNDEF:00000808                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:0000080C                 extrn __RTC_InitBase:near
UNDEF:0000080C                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00000810 ; int __cdecl _fclose(FILE *File)
UNDEF:00000810                 extrn __imp__fclose:near
UNDEF:00000810                                         ; CODE XREF: CStdInStream::Close(void)+26p
UNDEF:00000810                                         ; DATA XREF: CStdInStream::Close(void)+26r
UNDEF:00000814 ; public: __thiscall AString::AString(class AString const &)
UNDEF:00000814                 extrn ??0AString@@QAE@ABV0@@Z:near
UNDEF:00000814                                         ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+C8p
UNDEF:00000818 ; public: __thiscall AString::AString(void)
UNDEF:00000818                 extrn ??0AString@@QAE@XZ:near
UNDEF:00000818                                         ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+44p
UNDEF:0000081C                 extrn ___security_cookie:near
UNDEF:0000081C                                         ; DATA XREF: CStdInStream::ScanStringUntilNewLine(bool)+26r
UNDEF:0000081C                                         ; CStdInStream::ScanUStringUntilNewLine(void)+26r
UNDEF:00000820                 extrn ___CxxFrameHandler3:near
UNDEF:00000820                                         ; CODE XREF: __ehhandler$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z+16j
UNDEF:00000820                                         ; __ehhandler$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ+16j
UNDEF:00000824 ; __fastcall __security_check_cookie(x)
UNDEF:00000824                 extrn @__security_check_cookie@4:near
UNDEF:00000824                                         ; CODE XREF: __ehhandler$?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z+Cp
UNDEF:00000824                                         ; __ehhandler$?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ+Cp
UNDEF:00000828 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00000828                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00000828                                         ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+EFp
UNDEF:00000828                                         ; CStdInStream::ScanUStringUntilNewLine(void)+100p
UNDEF:0000082C ; __stdcall _CxxThrowException(x, x)
UNDEF:0000082C                 extrn __CxxThrowException@8:near
UNDEF:0000082C                                         ; CODE XREF: CStdInStream::ScanStringUntilNewLine(bool)+7Dp
UNDEF:0000082C                                         ; CStdInStream::ScanStringUntilNewLine(bool)+A2p ...
UNDEF:00000830 ; const type_info::`vftable'
UNDEF:00000830                 extrn ??_7type_info@@6B@:near
UNDEF:00000830                                         ; DATA XREF: .data:char * `RTTI Type Descriptor'o
UNDEF:00000830                                         ; .data:void * `RTTI Type Descriptor'o
UNDEF:00000834 ; void __cdecl operator delete(void *)
UNDEF:00000834                 extrn ??3@YAXPAX@Z:near ; CODE XREF: AString::~AString(void)+23p
UNDEF:00000834                                         ; UString::~UString(void)+23p
UNDEF:00000838 ; void __thiscall AString::Grow_1(AString *__hidden this)
UNDEF:00000838                 extrn ?Grow_1@AString@@AAEXXZ:near
UNDEF:00000838                                         ; CODE XREF: AString::operator+=(char)+2Fp
UNDEF:0000083C ; _DWORD __thiscall UString::UString(UString *__hidden this, const struct UString *)
UNDEF:0000083C                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:0000083C                                         ; CODE XREF: CStdInStream::ScanUStringUntilNewLine(void)+CDp
UNDEF:00000840 ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:00000840                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:00000840                                         ; CODE XREF: CStdInStream::ScanUStringUntilNewLine(void)+B5p
UNDEF:00000844 ; struct UString __stdcall __high MultiByteToUnicodeString(const struct AString *, unsigned int)
UNDEF:00000844                 extrn ?MultiByteToUnicodeString@@YG?AVUString@@ABVAString@@I@Z:near
UNDEF:00000844                                         ; CODE XREF: CStdInStream::ScanUStringUntilNewLine(void)+9Cp
UNDEF:00000848 ; bool __stdcall ConvertUTF8ToUnicode(const struct AString *, struct UString *)
UNDEF:00000848                 extrn ?ConvertUTF8ToUnicode@@YG_NABVAString@@AAVUString@@@Z:near
UNDEF:00000848                                         ; CODE XREF: CStdInStream::ScanUStringUntilNewLine(void)+89p
UNDEF:0000084C ; public: __thiscall UString::UString(void)
UNDEF:0000084C                 extrn ??0UString@@QAE@XZ:near
UNDEF:0000084C                                         ; CODE XREF: CStdInStream::ScanUStringUntilNewLine(void)+6Fp
UNDEF:00000850 ; int g_CodePage
UNDEF:00000850                 extrn ?g_CodePage@@3HA:near
UNDEF:00000850                                         ; DATA XREF: CStdInStream::ScanUStringUntilNewLine(void)+56r
UNDEF:00000854 ; int __cdecl _feof(FILE *File)
UNDEF:00000854                 extrn __imp__feof:near  ; CODE XREF: CStdInStream::Eof(void)+17p
UNDEF:00000854                                         ; DATA XREF: CStdInStream::Eof(void)+17r
UNDEF:00000858 ; int __cdecl _fgetc(FILE *File)
UNDEF:00000858                 extrn __imp__fgetc:near ; CODE XREF: CStdInStream::GetChar(void)+27p
UNDEF:00000858                                         ; DATA XREF: CStdInStream::GetChar(void)+27r
UNDEF:0000085C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000085C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'g_StdIn''(void)+23p
UNDEF:00000860 ; FILE *__cdecl ___iob_func()
UNDEF:00000860                 extrn __imp____iob_func:near
UNDEF:00000860                                         ; CODE XREF: `dynamic initializer for 'g_StdIn''(void)+6p
UNDEF:00000860                                         ; DATA XREF: `dynamic initializer for 'g_StdIn''(void)+6r
UNDEF:00000860
UNDEF:00000860
UNDEF:00000860                 end