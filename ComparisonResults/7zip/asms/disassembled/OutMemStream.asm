.text:00000000 ;
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text:00000000 ; |                      License info: 48-3677-7074-51                      |
.text:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ;
.text:00000000 ; Input MD5   : CA25958B2BA62649C8A5C9CA5006B254
.text:00000000 ; Input CRC32 : 79E2528E
.text:00000000
.text:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\OutMemStream.obj
.text:00000000 ; Format      : COFF (X386MAGIC)
.text:00000000 ; includelib "uuid.lib"
.text:00000000 ; includelib "MSVCRTD"
.text:00000000 ; includelib "OLDNAMES"
.text:00000000
.text:00000000                 .686p
.text:00000000                 .mmx
.text:00000000                 .model flat
.text:00000000
.text:00000000 ; ===========================================================================
.text:00000000
.text:00000000 ; Segment type: Pure code
.text:00000000 ; Segment permissions: Read/Execute
.text:00000000 _text           segment para public 'CODE' use32
.text:00000000                 assume cs:_text
.text:00000000                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000000
.text:00000000 ; =============== S U B R O U T I N E =======================================
.text:00000000
.text:00000000 ; Attributes: bp-based frame
.text:00000000
.text:00000000 ; void __thiscall COutMemStream::Free(COutMemStream *__hidden this)
.text:00000000                 public ?Free@COutMemStream@@QAEXXZ
.text:00000000 ?Free@COutMemStream@@QAEXXZ proc near   ; CODE XREF: COutMemStream::Init(void)+2Ap
.text:00000000                                         ; COutMemStream::DetachData(CMemLockBlocks &)+27p
.text:00000000
.text:00000000 var_4           = dword ptr -4
.text:00000000
.text:00000000                 push    ebp
.text:00000001                 mov     ebp, esp
.text:00000003                 push    ecx
.text:00000004                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000000B                 mov     [ebp+var_4], ecx
.text:0000000E                 mov     eax, [ebp+var_4]
.text:00000011                 mov     ecx, [eax+8]
.text:00000014                 push    ecx             ; struct CMemBlockManagerMt *
.text:00000015                 mov     ecx, [ebp+var_4]
.text:00000018                 add     ecx, 28h ; '('  ; this
.text:0000001B                 call    ?Free@CMemLockBlocks@@QAEXPAVCMemBlockManagerMt@@@Z ; CMemLockBlocks::Free(CMemBlockManagerMt *)
.text:00000020                 mov     edx, [ebp+var_4]
.text:00000023                 mov     byte ptr [edx+40h], 1
.text:00000027                 add     esp, 4
.text:0000002A                 cmp     ebp, esp
.text:0000002C                 call    __RTC_CheckEsp
.text:00000031                 mov     esp, ebp
.text:00000033                 pop     ebp
.text:00000034                 retn
.text:00000034 ?Free@COutMemStream@@QAEXXZ endp
.text:00000034
.text:00000034 ; ---------------------------------------------------------------------------
.text:00000035                 align 10h
.text:00000040
.text:00000040 ; =============== S U B R O U T I N E =======================================
.text:00000040
.text:00000040 ; Attributes: bp-based frame
.text:00000040
.text:00000040 ; void __thiscall COutMemStream::Init(COutMemStream *__hidden this)
.text:00000040                 public ?Init@COutMemStream@@QAEXXZ
.text:00000040 ?Init@COutMemStream@@QAEXXZ proc near
.text:00000040
.text:00000040 var_4           = dword ptr -4
.text:00000040
.text:00000040                 push    ebp
.text:00000041                 mov     ebp, esp
.text:00000043                 push    ecx
.text:00000044                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000004B                 mov     [ebp+var_4], ecx
.text:0000004E                 mov     ecx, [ebp+var_4]
.text:00000051                 add     ecx, 1Ch        ; this
.text:00000054                 call    ?Reset@CBaseEvent@NSynchronization@NWindows@@QAEIXZ ; NWindows::NSynchronization::CBaseEvent::Reset(void)
.text:00000059                 mov     eax, [ebp+var_4]
.text:0000005C                 mov     byte ptr [eax+15h], 0
.text:00000060                 mov     ecx, [ebp+var_4]
.text:00000063                 mov     byte ptr [ecx+14h], 0
.text:00000067                 mov     ecx, [ebp+var_4] ; this
.text:0000006A                 call    ?Free@COutMemStream@@QAEXXZ ; COutMemStream::Free(void)
.text:0000006F                 mov     edx, [ebp+var_4]
.text:00000072                 mov     dword ptr [edx+10h], 0
.text:00000079                 mov     eax, [ebp+var_4]
.text:0000007C                 mov     dword ptr [eax+0Ch], 0
.text:00000083                 add     esp, 4
.text:00000086                 cmp     ebp, esp
.text:00000088                 call    __RTC_CheckEsp
.text:0000008D                 mov     esp, ebp
.text:0000008F                 pop     ebp
.text:00000090                 retn
.text:00000090 ?Init@COutMemStream@@QAEXXZ endp
.text:00000090
.text:00000090 ; ---------------------------------------------------------------------------
.text:00000091                 align 10h
.text:000000A0
.text:000000A0 ; =============== S U B R O U T I N E =======================================
.text:000000A0
.text:000000A0 ; Attributes: bp-based frame
.text:000000A0
.text:000000A0 ; void __thiscall COutMemStream::DetachData(COutMemStream *this, struct CMemLockBlocks *)
.text:000000A0                 public ?DetachData@COutMemStream@@QAEXAAUCMemLockBlocks@@@Z
.text:000000A0 ?DetachData@COutMemStream@@QAEXAAUCMemLockBlocks@@@Z proc near
.text:000000A0
.text:000000A0 var_4           = dword ptr -4
.text:000000A0 arg_0           = dword ptr  8
.text:000000A0
.text:000000A0                 push    ebp
.text:000000A1                 mov     ebp, esp
.text:000000A3                 push    ecx
.text:000000A4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000000AB                 mov     [ebp+var_4], ecx
.text:000000AE                 mov     eax, [ebp+var_4]
.text:000000B1                 mov     ecx, [eax+8]
.text:000000B4                 push    ecx             ; struct CMemBlockManagerMt *
.text:000000B5                 mov     edx, [ebp+arg_0]
.text:000000B8                 push    edx             ; struct CMemLockBlocks *
.text:000000B9                 mov     ecx, [ebp+var_4]
.text:000000BC                 add     ecx, 28h ; '('  ; this
.text:000000BF                 call    ?Detach@CMemLockBlocks@@QAEXAAU1@PAVCMemBlockManagerMt@@@Z ; CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)
.text:000000C4                 mov     ecx, [ebp+var_4] ; this
.text:000000C7                 call    ?Free@COutMemStream@@QAEXXZ ; COutMemStream::Free(void)
.text:000000CC                 add     esp, 4
.text:000000CF                 cmp     ebp, esp
.text:000000D1                 call    __RTC_CheckEsp
.text:000000D6                 mov     esp, ebp
.text:000000D8                 pop     ebp
.text:000000D9                 retn    4
.text:000000D9 ?DetachData@COutMemStream@@QAEXAAUCMemLockBlocks@@@Z endp
.text:000000D9
.text:000000D9 ; ---------------------------------------------------------------------------
.text:000000DC                 align 10h
.text:000000E0
.text:000000E0 ; =============== S U B R O U T I N E =======================================
.text:000000E0
.text:000000E0 ; Attributes: bp-based frame
.text:000000E0
.text:000000E0 ; __int32 __thiscall COutMemStream::WriteToRealStream(COutMemStream *__hidden this)
.text:000000E0                 public ?WriteToRealStream@COutMemStream@@QAEJXZ
.text:000000E0 ?WriteToRealStream@COutMemStream@@QAEJXZ proc near
.text:000000E0                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+202p
.text:000000E0
.text:000000E0 var_8           = dword ptr -8
.text:000000E0 var_4           = dword ptr -4
.text:000000E0
.text:000000E0                 push    ebp
.text:000000E1                 mov     ebp, esp
.text:000000E3                 sub     esp, 8
.text:000000E6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000000ED                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000000F4                 mov     [ebp+var_4], ecx
.text:000000F7                 mov     ecx, [ebp+var_4]
.text:000000FA                 add     ecx, 48h ; 'H'
.text:000000FD                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00000102                 push    eax             ; struct ISequentialOutStream *
.text:00000103                 mov     eax, [ebp+var_4]
.text:00000106                 mov     ecx, [eax+8]    ; this
.text:00000109                 call    ?GetBlockSize@CMemBlockManager@@QBEIXZ ; CMemBlockManager::GetBlockSize(void)
.text:0000010E                 push    eax             ; unsigned int
.text:0000010F                 mov     ecx, [ebp+var_4]
.text:00000112                 add     ecx, 28h ; '('  ; this
.text:00000115                 call    ?WriteToStream@CMemBlocks@@QBEJIPAUISequentialOutStream@@@Z ; CMemBlocks::WriteToStream(uint,ISequentialOutStream *)
.text:0000011A                 mov     [ebp+var_8], eax
.text:0000011D                 cmp     [ebp+var_8], 0
.text:00000121                 jz      short loc_128
.text:00000123                 mov     eax, [ebp+var_8]
.text:00000126                 jmp     short loc_13C
.text:00000128 ; ---------------------------------------------------------------------------
.text:00000128
.text:00000128 loc_128:                                ; CODE XREF: COutMemStream::WriteToRealStream(void)+41j
.text:00000128                 mov     ecx, [ebp+var_4]
.text:0000012B                 mov     edx, [ecx+8]
.text:0000012E                 push    edx             ; struct CMemBlockManagerMt *
.text:0000012F                 mov     ecx, [ebp+var_4]
.text:00000132                 add     ecx, 28h ; '('  ; this
.text:00000135                 call    ?Free@CMemLockBlocks@@QAEXPAVCMemBlockManagerMt@@@Z ; CMemLockBlocks::Free(CMemBlockManagerMt *)
.text:0000013A                 xor     eax, eax
.text:0000013C
.text:0000013C loc_13C:                                ; CODE XREF: COutMemStream::WriteToRealStream(void)+46j
.text:0000013C                 add     esp, 8
.text:0000013F                 cmp     ebp, esp
.text:00000141                 call    __RTC_CheckEsp
.text:00000146                 mov     esp, ebp
.text:00000148                 pop     ebp
.text:00000149                 retn
.text:00000149 ?WriteToRealStream@COutMemStream@@QAEJXZ endp
.text:00000149
.text:00000149 ; ---------------------------------------------------------------------------
.text:0000014A                 align 10h
.text:00000150
.text:00000150 ; =============== S U B R O U T I N E =======================================
.text:00000150
.text:00000150 ; Attributes: bp-based frame
.text:00000150
.text:00000150 ; __int32 __stdcall COutMemStream::Write(COutMemStream *this, const void *Src, unsigned int, unsigned int *)
.text:00000150                 public ?Write@COutMemStream@@UAGJPBXIPAI@Z
.text:00000150 ?Write@COutMemStream@@UAGJPBXIPAI@Z proc near
.text:00000150
.text:00000150 var_4C          = dword ptr -4Ch
.text:00000150 var_48          = dword ptr -48h
.text:00000150 var_44          = dword ptr -44h
.text:00000150 var_40          = dword ptr -40h
.text:00000150 var_3C          = dword ptr -3Ch
.text:00000150 var_34          = dword ptr -34h
.text:00000150 var_2C          = dword ptr -2Ch
.text:00000150 var_28          = dword ptr -28h
.text:00000150 Handles         = dword ptr -20h
.text:00000150 var_1C          = dword ptr -1Ch
.text:00000150 var_18          = dword ptr -18h
.text:00000150 var_10          = dword ptr -10h
.text:00000150 var_C           = dword ptr -0Ch
.text:00000150 Size            = dword ptr -8
.text:00000150 Dst             = dword ptr -4
.text:00000150 this            = dword ptr  8
.text:00000150 Src             = dword ptr  0Ch
.text:00000150 arg_8           = dword ptr  10h
.text:00000150 arg_C           = dword ptr  14h
.text:00000150
.text:00000150                 push    ebp
.text:00000151                 mov     ebp, esp
.text:00000153                 sub     esp, 4Ch
.text:00000156                 push    esi
.text:00000157                 push    edi
.text:00000158                 lea     edi, [ebp+var_4C]
.text:0000015B                 mov     ecx, 13h
.text:00000160                 mov     eax, 0CCCCCCCCh
.text:00000165                 rep stosd
.text:00000167                 mov     eax, [ebp+this]
.text:0000016A                 movzx   ecx, byte ptr [eax+14h]
.text:0000016E                 test    ecx, ecx
.text:00000170                 jz      short loc_1A8
.text:00000172                 mov     ecx, [ebp+this]
.text:00000175                 add     ecx, 48h ; 'H'
.text:00000178                 call    ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator->(void)
.text:0000017D                 mov     [ebp+var_40], eax
.text:00000180                 mov     esi, esp
.text:00000182                 mov     edx, [ebp+arg_C]
.text:00000185                 push    edx
.text:00000186                 mov     eax, [ebp+arg_8]
.text:00000189                 push    eax
.text:0000018A                 mov     ecx, [ebp+Src]
.text:0000018D                 push    ecx
.text:0000018E                 mov     edx, [ebp+var_40]
.text:00000191                 push    edx
.text:00000192                 mov     eax, [ebp+var_40]
.text:00000195                 mov     ecx, [eax]
.text:00000197                 mov     edx, [ecx+0Ch]
.text:0000019A                 call    edx
.text:0000019C                 cmp     esi, esp
.text:0000019E                 call    __RTC_CheckEsp
.text:000001A3                 jmp     loc_3F2
.text:000001A8 ; ---------------------------------------------------------------------------
.text:000001A8
.text:000001A8 loc_1A8:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+20j
.text:000001A8                 cmp     [ebp+arg_C], 0
.text:000001AC                 jz      short loc_1B7
.text:000001AE                 mov     eax, [ebp+arg_C]
.text:000001B1                 mov     dword ptr [eax], 0
.text:000001B7
.text:000001B7 loc_1B7:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+5Cj
.text:000001B7                                         ; COutMemStream::Write(void const *,uint,uint *):loc_2C6j ...
.text:000001B7                 cmp     [ebp+arg_8], 0
.text:000001BB                 jz      loc_3F0
.text:000001C1                 mov     ecx, [ebp+this]
.text:000001C4                 add     ecx, 28h ; '('
.text:000001C7                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000001CC                 mov     ecx, [ebp+this]
.text:000001CF                 cmp     [ecx+0Ch], eax
.text:000001D2                 jnb     loc_2CB
.text:000001D8                 mov     edx, [ebp+this]
.text:000001DB                 mov     eax, [edx+0Ch]
.text:000001DE                 push    eax
.text:000001DF                 mov     ecx, [ebp+this]
.text:000001E2                 add     ecx, 28h ; '('
.text:000001E5                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000001EA                 mov     ecx, [eax]
.text:000001EC                 mov     edx, [ebp+this]
.text:000001EF                 add     ecx, [edx+10h]
.text:000001F2                 mov     [ebp+Dst], ecx
.text:000001F5                 mov     eax, [ebp+this]
.text:000001F8                 mov     ecx, [eax+8]    ; this
.text:000001FB                 call    ?GetBlockSize@CMemBlockManager@@QBEIXZ ; CMemBlockManager::GetBlockSize(void)
.text:00000200                 mov     ecx, [ebp+this]
.text:00000203                 sub     eax, [ecx+10h]
.text:00000206                 mov     [ebp+Size], eax
.text:00000209                 mov     edx, [ebp+arg_8]
.text:0000020C                 cmp     edx, [ebp+Size]
.text:0000020F                 jnb     short loc_217
.text:00000211                 mov     eax, [ebp+arg_8]
.text:00000214                 mov     [ebp+Size], eax
.text:00000217
.text:00000217 loc_217:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+BFj
.text:00000217                 mov     ecx, [ebp+Size]
.text:0000021A                 push    ecx             ; Size
.text:0000021B                 mov     edx, [ebp+Src]
.text:0000021E                 push    edx             ; Src
.text:0000021F                 mov     eax, [ebp+Dst]
.text:00000222                 push    eax             ; Dst
.text:00000223                 call    _memcpy
.text:00000228                 add     esp, 0Ch
.text:0000022B                 cmp     [ebp+arg_C], 0
.text:0000022F                 jz      short loc_23E
.text:00000231                 mov     ecx, [ebp+arg_C]
.text:00000234                 mov     edx, [ecx]
.text:00000236                 add     edx, [ebp+Size]
.text:00000239                 mov     eax, [ebp+arg_C]
.text:0000023C                 mov     [eax], edx
.text:0000023E
.text:0000023E loc_23E:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+DFj
.text:0000023E                 mov     ecx, [ebp+Src]
.text:00000241                 add     ecx, [ebp+Size]
.text:00000244                 mov     [ebp+Src], ecx
.text:00000247                 mov     edx, [ebp+arg_8]
.text:0000024A                 sub     edx, [ebp+Size]
.text:0000024D                 mov     [ebp+arg_8], edx
.text:00000250                 mov     eax, [ebp+this]
.text:00000253                 mov     ecx, [eax+10h]
.text:00000256                 add     ecx, [ebp+Size]
.text:00000259                 mov     edx, [ebp+this]
.text:0000025C                 mov     [edx+10h], ecx
.text:0000025F                 mov     ecx, [ebp+this] ; this
.text:00000262                 call    ?GetPos@COutMemStream@@ABE_KXZ ; COutMemStream::GetPos(void)
.text:00000267                 mov     [ebp+var_10], eax
.text:0000026A                 mov     [ebp+var_C], edx
.text:0000026D                 mov     eax, [ebp+this]
.text:00000270                 mov     [ebp+var_44], eax
.text:00000273                 mov     ecx, [ebp+var_44]
.text:00000276                 mov     edx, [ebp+var_C]
.text:00000279                 cmp     edx, [ecx+3Ch]
.text:0000027C                 jb      short loc_29A
.text:0000027E                 ja      short loc_28B
.text:00000280                 mov     eax, [ebp+var_44]
.text:00000283                 mov     ecx, [ebp+var_10]
.text:00000286                 cmp     ecx, [eax+38h]
.text:00000289                 jbe     short loc_29A
.text:0000028B
.text:0000028B loc_28B:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+12Ej
.text:0000028B                 mov     edx, [ebp+this]
.text:0000028E                 mov     eax, [ebp+var_10]
.text:00000291                 mov     [edx+38h], eax
.text:00000294                 mov     ecx, [ebp+var_C]
.text:00000297                 mov     [edx+3Ch], ecx
.text:0000029A
.text:0000029A loc_29A:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+12Cj
.text:0000029A                                         ; COutMemStream::Write(void const *,uint,uint *)+139j
.text:0000029A                 mov     edx, [ebp+this]
.text:0000029D                 mov     ecx, [edx+8]    ; this
.text:000002A0                 call    ?GetBlockSize@CMemBlockManager@@QBEIXZ ; CMemBlockManager::GetBlockSize(void)
.text:000002A5                 mov     ecx, [ebp+this]
.text:000002A8                 cmp     [ecx+10h], eax
.text:000002AB                 jnz     short loc_2C6
.text:000002AD                 mov     edx, [ebp+this]
.text:000002B0                 mov     eax, [edx+0Ch]
.text:000002B3                 add     eax, 1
.text:000002B6                 mov     ecx, [ebp+this]
.text:000002B9                 mov     [ecx+0Ch], eax
.text:000002BC                 mov     edx, [ebp+this]
.text:000002BF                 mov     dword ptr [edx+10h], 0
.text:000002C6
.text:000002C6 loc_2C6:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+15Bj
.text:000002C6                 jmp     loc_1B7
.text:000002CB ; ---------------------------------------------------------------------------
.text:000002CB
.text:000002CB loc_2CB:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+82j
.text:000002CB                 mov     ecx, [ebp+this]
.text:000002CE                 add     ecx, 18h
.text:000002D1                 call    ??BCBaseEvent@NSynchronization@NWindows@@QAEPAXXZ ; NWindows::NSynchronization::CBaseEvent::operator void *(void)
.text:000002D6                 mov     [ebp+Handles], eax
.text:000002D9                 mov     ecx, [ebp+this]
.text:000002DC                 add     ecx, 1Ch
.text:000002DF                 call    ??BCBaseEvent@NSynchronization@NWindows@@QAEPAXXZ ; NWindows::NSynchronization::CBaseEvent::operator void *(void)
.text:000002E4                 mov     [ebp+var_1C], eax
.text:000002E7                 mov     eax, [ebp+this]
.text:000002EA                 mov     ecx, [eax+8]
.text:000002ED                 add     ecx, 24h ; '$'
.text:000002F0                 call    ??BCSemaphore@NSynchronization@NWindows@@QAEPAXXZ ; NWindows::NSynchronization::CSemaphore::operator void *(void)
.text:000002F5                 mov     [ebp+var_18], eax
.text:000002F8                 mov     esi, esp
.text:000002FA                 push    0FFFFFFFFh      ; dwMilliseconds
.text:000002FC                 push    0               ; bWaitAll
.text:000002FE                 lea     ecx, [ebp+Handles]
.text:00000301                 push    ecx             ; lpHandles
.text:00000302                 mov     edx, [ebp+this]
.text:00000305                 movzx   eax, byte ptr [edx+40h]
.text:00000309                 neg     eax
.text:0000030B                 sbb     eax, eax
.text:0000030D                 neg     eax
.text:0000030F                 add     eax, 2
.text:00000312                 push    eax             ; nCount
.text:00000313                 call    dword ptr ds:__imp__WaitForMultipleObjects@16 ; WaitForMultipleObjects(x,x,x,x)
.text:00000319                 cmp     esi, esp
.text:0000031B                 call    __RTC_CheckEsp
.text:00000320                 mov     [ebp+var_28], eax
.text:00000323                 mov     ecx, [ebp+var_28]
.text:00000326                 mov     [ebp+var_48], ecx
.text:00000329                 cmp     [ebp+var_48], 0
.text:0000032D                 jz      short loc_33D
.text:0000032F                 cmp     [ebp+var_48], 1
.text:00000333                 jz      short loc_348
.text:00000335                 cmp     [ebp+var_48], 2
.text:00000339                 jz      short loc_3B4
.text:0000033B                 jmp     short loc_3B6
.text:0000033D ; ---------------------------------------------------------------------------
.text:0000033D
.text:0000033D loc_33D:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+1DDj
.text:0000033D                 mov     edx, [ebp+this]
.text:00000340                 mov     eax, [edx+20h]
.text:00000343                 jmp     loc_3F2
.text:00000348 ; ---------------------------------------------------------------------------
.text:00000348
.text:00000348 loc_348:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+1E3j
.text:00000348                 mov     eax, [ebp+this]
.text:0000034B                 mov     byte ptr [eax+14h], 1
.text:0000034F                 mov     ecx, [ebp+this] ; this
.text:00000352                 call    ?WriteToRealStream@COutMemStream@@QAEJXZ ; COutMemStream::WriteToRealStream(void)
.text:00000357                 mov     [ebp+var_2C], eax
.text:0000035A                 cmp     [ebp+var_2C], 0
.text:0000035E                 jz      short loc_368
.text:00000360                 mov     eax, [ebp+var_2C]
.text:00000363                 jmp     loc_3F2
.text:00000368 ; ---------------------------------------------------------------------------
.text:00000368
.text:00000368 loc_368:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+20Ej
.text:00000368                 mov     ecx, [ebp+this]
.text:0000036B                 add     ecx, 48h ; 'H'
.text:0000036E                 call    ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator->(void)
.text:00000373                 mov     [ebp+var_4C], eax
.text:00000376                 mov     esi, esp
.text:00000378                 lea     ecx, [ebp+var_34]
.text:0000037B                 push    ecx
.text:0000037C                 mov     edx, [ebp+arg_8]
.text:0000037F                 push    edx
.text:00000380                 mov     eax, [ebp+Src]
.text:00000383                 push    eax
.text:00000384                 mov     ecx, [ebp+var_4C]
.text:00000387                 push    ecx
.text:00000388                 mov     edx, [ebp+var_4C]
.text:0000038B                 mov     eax, [edx]
.text:0000038D                 mov     ecx, [eax+0Ch]
.text:00000390                 call    ecx
.text:00000392                 cmp     esi, esp
.text:00000394                 call    __RTC_CheckEsp
.text:00000399                 mov     [ebp+var_3C], eax
.text:0000039C                 cmp     [ebp+arg_C], 0
.text:000003A0                 jz      short loc_3AF
.text:000003A2                 mov     edx, [ebp+arg_C]
.text:000003A5                 mov     eax, [edx]
.text:000003A7                 add     eax, [ebp+var_34]
.text:000003AA                 mov     ecx, [ebp+arg_C]
.text:000003AD                 mov     [ecx], eax
.text:000003AF
.text:000003AF loc_3AF:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+250j
.text:000003AF                 mov     eax, [ebp+var_3C]
.text:000003B2                 jmp     short loc_3F2
.text:000003B4 ; ---------------------------------------------------------------------------
.text:000003B4
.text:000003B4 loc_3B4:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+1E9j
.text:000003B4                 jmp     short loc_3BD
.text:000003B6 ; ---------------------------------------------------------------------------
.text:000003B6
.text:000003B6 loc_3B6:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+1EBj
.text:000003B6                 mov     eax, 80004005h
.text:000003BB                 jmp     short loc_3F2
.text:000003BD ; ---------------------------------------------------------------------------
.text:000003BD
.text:000003BD loc_3BD:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *):loc_3B4j
.text:000003BD                 mov     edx, [ebp+this]
.text:000003C0                 mov     ecx, [edx+8]    ; this
.text:000003C3                 call    ?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ ; CMemBlockManagerMt::AllocateBlock(void)
.text:000003C8                 push    eax
.text:000003C9                 mov     ecx, [ebp+this]
.text:000003CC                 add     ecx, 28h ; '('
.text:000003CF                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:000003D4                 mov     ecx, [ebp+this]
.text:000003D7                 add     ecx, 28h ; '('
.text:000003DA                 call    ?Back@?$CRecordVector@PAX@@QAEAAPAXXZ ; CRecordVector<void *>::Back(void)
.text:000003DF                 cmp     dword ptr [eax], 0
.text:000003E2                 jnz     short loc_3EB
.text:000003E4                 mov     eax, 80004005h
.text:000003E9                 jmp     short loc_3F2
.text:000003EB ; ---------------------------------------------------------------------------
.text:000003EB
.text:000003EB loc_3EB:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+292j
.text:000003EB                 jmp     loc_1B7
.text:000003F0 ; ---------------------------------------------------------------------------
.text:000003F0
.text:000003F0 loc_3F0:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+6Bj
.text:000003F0                 xor     eax, eax
.text:000003F2
.text:000003F2 loc_3F2:                                ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+53j
.text:000003F2                                         ; COutMemStream::Write(void const *,uint,uint *)+1F3j ...
.text:000003F2                 push    edx
.text:000003F3                 mov     ecx, ebp
.text:000003F5                 push    eax
.text:000003F6                 lea     edx, $LN26
.text:000003FC                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000401                 pop     eax
.text:00000402                 pop     edx
.text:00000403                 pop     edi
.text:00000404                 pop     esi
.text:00000405                 add     esp, 4Ch
.text:00000408                 cmp     ebp, esp
.text:0000040A                 call    __RTC_CheckEsp
.text:0000040F                 mov     esp, ebp
.text:00000411                 pop     ebp
.text:00000412                 retn    10h
.text:00000412 ?Write@COutMemStream@@UAGJPBXIPAI@Z endp
.text:00000412
.text:00000412 ; ---------------------------------------------------------------------------
.text:00000415                 align 4
.text:00000418 $LN26           dd 2                    ; DATA XREF: COutMemStream::Write(void const *,uint,uint *)+2A6o
.text:0000041C                 dd offset $LN25
.text:00000420 $LN25           dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:0000041Co
.text:00000428                 dd offset $LN23         ; "events"
.text:0000042C                 db 0CCh
.text:0000042D                 db 3 dup(0FFh)
.text:00000430                 dd 4
.text:00000434                 dd offset $LN24         ; "processedSize2"
.text:00000438 $LN24           db 'processedSize2',0   ; DATA XREF: .text:00000434o
.text:00000447 $LN23           db 'events',0           ; DATA XREF: .text:00000428o
.text:0000044E                 align 10h
.text:00000450
.text:00000450 ; =============== S U B R O U T I N E =======================================
.text:00000450
.text:00000450 ; Attributes: bp-based frame
.text:00000450
.text:00000450 ; __int32 __stdcall COutMemStream::Seek(COutMemStream *this, __int64, unsigned int, unsigned __int64 *)
.text:00000450                 public ?Seek@COutMemStream@@UAGJ_JIPA_K@Z
.text:00000450 ?Seek@COutMemStream@@UAGJ_JIPA_K@Z proc near
.text:00000450
.text:00000450 var_4           = dword ptr -4
.text:00000450 this            = dword ptr  8
.text:00000450 arg_4           = qword ptr  0Ch
.text:00000450 arg_C           = dword ptr  14h
.text:00000450 arg_10          = dword ptr  18h
.text:00000450
.text:00000450                 push    ebp
.text:00000451                 mov     ebp, esp
.text:00000453                 push    ecx
.text:00000454                 push    esi
.text:00000455                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000045C                 mov     eax, [ebp+this]
.text:0000045F                 movzx   ecx, byte ptr [eax+14h]
.text:00000463                 test    ecx, ecx
.text:00000465                 jz      short loc_4BA
.text:00000467                 mov     ecx, [ebp+this]
.text:0000046A                 add     ecx, 4Ch ; 'L'
.text:0000046D                 call    ??7?$CMyComPtr@UIOutStream@@@@QBE_NXZ ; CMyComPtr<IOutStream>::operator!(void)
.text:00000472                 movzx   edx, al
.text:00000475                 test    edx, edx
.text:00000477                 jz      short loc_483
.text:00000479                 mov     eax, 80004005h
.text:0000047E                 jmp     loc_51B
.text:00000483 ; ---------------------------------------------------------------------------
.text:00000483
.text:00000483 loc_483:                                ; CODE XREF: COutMemStream::Seek(__int64,uint,unsigned __int64 *)+27j
.text:00000483                 mov     ecx, [ebp+this]
.text:00000486                 add     ecx, 4Ch ; 'L'
.text:00000489                 call    ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator->(void)
.text:0000048E                 mov     [ebp+var_4], eax
.text:00000491                 mov     esi, esp
.text:00000493                 mov     eax, [ebp+arg_10]
.text:00000496                 push    eax
.text:00000497                 mov     ecx, [ebp+arg_C]
.text:0000049A                 push    ecx
.text:0000049B                 mov     edx, dword ptr [ebp+arg_4+4]
.text:0000049E                 push    edx
.text:0000049F                 mov     eax, dword ptr [ebp+arg_4]
.text:000004A2                 push    eax
.text:000004A3                 mov     ecx, [ebp+var_4]
.text:000004A6                 push    ecx
.text:000004A7                 mov     edx, [ebp+var_4]
.text:000004AA                 mov     eax, [edx]
.text:000004AC                 mov     ecx, [eax+10h]
.text:000004AF                 call    ecx
.text:000004B1                 cmp     esi, esp
.text:000004B3                 call    __RTC_CheckEsp
.text:000004B8                 jmp     short loc_51B
.text:000004BA ; ---------------------------------------------------------------------------
.text:000004BA
.text:000004BA loc_4BA:                                ; CODE XREF: COutMemStream::Seek(__int64,uint,unsigned __int64 *)+15j
.text:000004BA                 cmp     [ebp+arg_C], 1
.text:000004BE                 jnz     short loc_4D1
.text:000004C0                 mov     edx, dword ptr [ebp+arg_4]
.text:000004C3                 or      edx, dword ptr [ebp+arg_4+4]
.text:000004C6                 jz      short loc_4CF
.text:000004C8                 mov     eax, 80004001h
.text:000004CD                 jmp     short loc_51B
.text:000004CF ; ---------------------------------------------------------------------------
.text:000004CF
.text:000004CF loc_4CF:                                ; CODE XREF: COutMemStream::Seek(__int64,uint,unsigned __int64 *)+76j
.text:000004CF                 jmp     short loc_503
.text:000004D1 ; ---------------------------------------------------------------------------
.text:000004D1
.text:000004D1 loc_4D1:                                ; CODE XREF: COutMemStream::Seek(__int64,uint,unsigned __int64 *)+6Ej
.text:000004D1                 cmp     [ebp+arg_C], 0
.text:000004D5                 jnz     short loc_4FC
.text:000004D7                 mov     eax, dword ptr [ebp+arg_4]
.text:000004DA                 or      eax, dword ptr [ebp+arg_4+4]
.text:000004DD                 jz      short loc_4E6
.text:000004DF                 mov     eax, 80004001h
.text:000004E4                 jmp     short loc_51B
.text:000004E6 ; ---------------------------------------------------------------------------
.text:000004E6
.text:000004E6 loc_4E6:                                ; CODE XREF: COutMemStream::Seek(__int64,uint,unsigned __int64 *)+8Dj
.text:000004E6                 mov     ecx, [ebp+this]
.text:000004E9                 mov     dword ptr [ecx+0Ch], 0
.text:000004F0                 mov     edx, [ebp+this]
.text:000004F3                 mov     dword ptr [edx+10h], 0
.text:000004FA                 jmp     short loc_503
.text:000004FC ; ---------------------------------------------------------------------------
.text:000004FC
.text:000004FC loc_4FC:                                ; CODE XREF: COutMemStream::Seek(__int64,uint,unsigned __int64 *)+85j
.text:000004FC                 mov     eax, 80004001h
.text:00000501                 jmp     short loc_51B
.text:00000503 ; ---------------------------------------------------------------------------
.text:00000503
.text:00000503 loc_503:                                ; CODE XREF: COutMemStream::Seek(__int64,uint,unsigned __int64 *):loc_4CFj
.text:00000503                                         ; COutMemStream::Seek(__int64,uint,unsigned __int64 *)+AAj
.text:00000503                 cmp     [ebp+arg_10], 0
.text:00000507                 jz      short loc_519
.text:00000509                 mov     ecx, [ebp+this] ; this
.text:0000050C                 call    ?GetPos@COutMemStream@@ABE_KXZ ; COutMemStream::GetPos(void)
.text:00000511                 mov     ecx, [ebp+arg_10]
.text:00000514                 mov     [ecx], eax
.text:00000516                 mov     [ecx+4], edx
.text:00000519
.text:00000519 loc_519:                                ; CODE XREF: COutMemStream::Seek(__int64,uint,unsigned __int64 *)+B7j
.text:00000519                 xor     eax, eax
.text:0000051B
.text:0000051B loc_51B:                                ; CODE XREF: COutMemStream::Seek(__int64,uint,unsigned __int64 *)+2Ej
.text:0000051B                                         ; COutMemStream::Seek(__int64,uint,unsigned __int64 *)+68j ...
.text:0000051B                 pop     esi
.text:0000051C                 add     esp, 4
.text:0000051F                 cmp     ebp, esp
.text:00000521                 call    __RTC_CheckEsp
.text:00000526                 mov     esp, ebp
.text:00000528                 pop     ebp
.text:00000529                 retn    14h
.text:00000529 ?Seek@COutMemStream@@UAGJ_JIPA_K@Z endp
.text:00000529
.text:00000529 ; ---------------------------------------------------------------------------
.text:0000052C                 align 10h
.text:00000530
.text:00000530 ; =============== S U B R O U T I N E =======================================
.text:00000530
.text:00000530 ; Attributes: bp-based frame
.text:00000530
.text:00000530 ; __int32 __stdcall COutMemStream::SetSize(COutMemStream *this, unsigned __int64)
.text:00000530                 public ?SetSize@COutMemStream@@UAGJ_K@Z
.text:00000530 ?SetSize@COutMemStream@@UAGJ_K@Z proc near
.text:00000530
.text:00000530 var_4           = dword ptr -4
.text:00000530 this            = dword ptr  8
.text:00000530 arg_4           = qword ptr  0Ch
.text:00000530
.text:00000530                 push    ebp
.text:00000531                 mov     ebp, esp
.text:00000533                 push    ecx
.text:00000534                 push    esi
.text:00000535                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000053C                 mov     eax, [ebp+this]
.text:0000053F                 movzx   ecx, byte ptr [eax+14h]
.text:00000543                 test    ecx, ecx
.text:00000545                 jz      short loc_58F
.text:00000547                 mov     ecx, [ebp+this]
.text:0000054A                 add     ecx, 4Ch ; 'L'
.text:0000054D                 call    ??7?$CMyComPtr@UIOutStream@@@@QBE_NXZ ; CMyComPtr<IOutStream>::operator!(void)
.text:00000552                 movzx   edx, al
.text:00000555                 test    edx, edx
.text:00000557                 jz      short loc_560
.text:00000559                 mov     eax, 80004005h
.text:0000055E                 jmp     short loc_5A0
.text:00000560 ; ---------------------------------------------------------------------------
.text:00000560
.text:00000560 loc_560:                                ; CODE XREF: COutMemStream::SetSize(unsigned __int64)+27j
.text:00000560                 mov     ecx, [ebp+this]
.text:00000563                 add     ecx, 4Ch ; 'L'
.text:00000566                 call    ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator->(void)
.text:0000056B                 mov     [ebp+var_4], eax
.text:0000056E                 mov     esi, esp
.text:00000570                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000573                 push    eax
.text:00000574                 mov     ecx, dword ptr [ebp+arg_4]
.text:00000577                 push    ecx
.text:00000578                 mov     edx, [ebp+var_4]
.text:0000057B                 push    edx
.text:0000057C                 mov     eax, [ebp+var_4]
.text:0000057F                 mov     ecx, [eax]
.text:00000581                 mov     edx, [ecx+14h]
.text:00000584                 call    edx
.text:00000586                 cmp     esi, esp
.text:00000588                 call    __RTC_CheckEsp
.text:0000058D                 jmp     short loc_5A0
.text:0000058F ; ---------------------------------------------------------------------------
.text:0000058F
.text:0000058F loc_58F:                                ; CODE XREF: COutMemStream::SetSize(unsigned __int64)+15j
.text:0000058F                 mov     eax, [ebp+this]
.text:00000592                 mov     ecx, dword ptr [ebp+arg_4]
.text:00000595                 mov     [eax+38h], ecx
.text:00000598                 mov     edx, dword ptr [ebp+arg_4+4]
.text:0000059B                 mov     [eax+3Ch], edx
.text:0000059E                 xor     eax, eax
.text:000005A0
.text:000005A0 loc_5A0:                                ; CODE XREF: COutMemStream::SetSize(unsigned __int64)+2Ej
.text:000005A0                                         ; COutMemStream::SetSize(unsigned __int64)+5Dj
.text:000005A0                 pop     esi
.text:000005A1                 add     esp, 4
.text:000005A4                 cmp     ebp, esp
.text:000005A6                 call    __RTC_CheckEsp
.text:000005AB                 mov     esp, ebp
.text:000005AD                 pop     ebp
.text:000005AE                 retn    0Ch
.text:000005AE ?SetSize@COutMemStream@@UAGJ_K@Z endp
.text:000005AE
.text:000005AE ; ---------------------------------------------------------------------------
.text:000005B1                 align 4
.text:000005B1 _text           ends
.text:000005B1
.rtc$TMZ:000005B4 ; ===========================================================================
.rtc$TMZ:000005B4
.rtc$TMZ:000005B4 ; Segment type: Pure data
.rtc$TMZ:000005B4 ; Segment permissions: Read
.rtc$TMZ:000005B4 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:000005B4                 assume cs:_rtc$TMZ
.rtc$TMZ:000005B4                 ;org 5B4h
.rtc$TMZ:000005B4 ; COMDAT (pick any)
.rtc$TMZ:000005B4 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:000005B4 _rtc$TMZ        ends
.rtc$TMZ:000005B4
.rtc$IMZ:000005B8 ; ===========================================================================
.rtc$IMZ:000005B8
.rtc$IMZ:000005B8 ; Segment type: Pure data
.rtc$IMZ:000005B8 ; Segment permissions: Read
.rtc$IMZ:000005B8 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:000005B8                 assume cs:_rtc$IMZ
.rtc$IMZ:000005B8                 ;org 5B8h
.rtc$IMZ:000005B8 ; COMDAT (pick any)
.rtc$IMZ:000005B8 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:000005B8 _rtc$IMZ        ends
.rtc$IMZ:000005B8
.text:000005BC ; ===========================================================================
.text:000005BC
.text:000005BC ; Segment type: Pure code
.text:000005BC ; Segment permissions: Read/Execute
.text:000005BC _text           segment para public 'CODE' use32
.text:000005BC                 assume cs:_text
.text:000005BC                 ;org 5BCh
.text:000005BC ; COMDAT (pick any)
.text:000005BC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000005BC
.text:000005BC ; =============== S U B R O U T I N E =======================================
.text:000005BC
.text:000005BC ; Attributes: bp-based frame
.text:000005BC
.text:000005BC ; unsigned int __thiscall NWindows::NSynchronization::CBaseEvent::Reset(NWindows::NSynchronization::CBaseEvent *__hidden this)
.text:000005BC                 public ?Reset@CBaseEvent@NSynchronization@NWindows@@QAEIXZ
.text:000005BC ?Reset@CBaseEvent@NSynchronization@NWindows@@QAEIXZ proc near
.text:000005BC                                         ; CODE XREF: COutMemStream::Init(void)+14p
.text:000005BC
.text:000005BC var_4           = dword ptr -4
.text:000005BC
.text:000005BC                 push    ebp
.text:000005BD                 mov     ebp, esp
.text:000005BF                 push    ecx
.text:000005C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000005C7                 mov     [ebp+var_4], ecx
.text:000005CA                 mov     eax, [ebp+var_4]
.text:000005CD                 push    eax
.text:000005CE                 call    _Event_Reset@4  ; Event_Reset(x)
.text:000005D3                 add     esp, 4
.text:000005D6                 cmp     ebp, esp
.text:000005D8                 call    __RTC_CheckEsp
.text:000005DD                 mov     esp, ebp
.text:000005DF                 pop     ebp
.text:000005E0                 retn
.text:000005E0 ?Reset@CBaseEvent@NSynchronization@NWindows@@QAEIXZ endp
.text:000005E0
.text:000005E0 ; ---------------------------------------------------------------------------
.text:000005E1                 align 4
.text:000005E1 _text           ends
.text:000005E1
.text:000005E4 ; ===========================================================================
.text:000005E4
.text:000005E4 ; Segment type: Pure code
.text:000005E4 ; Segment permissions: Read/Execute
.text:000005E4 _text           segment para public 'CODE' use32
.text:000005E4                 assume cs:_text
.text:000005E4                 ;org 5E4h
.text:000005E4 ; COMDAT (pick any)
.text:000005E4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000005E4
.text:000005E4 ; =============== S U B R O U T I N E =======================================
.text:000005E4
.text:000005E4 ; Attributes: bp-based frame
.text:000005E4
.text:000005E4 ; unsigned int __thiscall CMemBlockManager::GetBlockSize(CMemBlockManager *__hidden this)
.text:000005E4                 public ?GetBlockSize@CMemBlockManager@@QBEIXZ
.text:000005E4 ?GetBlockSize@CMemBlockManager@@QBEIXZ proc near
.text:000005E4                                         ; CODE XREF: COutMemStream::WriteToRealStream(void)+29p
.text:000005E4                                         ; COutMemStream::Write(void const *,uint,uint *)+ABp ...
.text:000005E4
.text:000005E4 var_4           = dword ptr -4
.text:000005E4
.text:000005E4                 push    ebp
.text:000005E5                 mov     ebp, esp
.text:000005E7                 push    ecx
.text:000005E8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000005EF                 mov     [ebp+var_4], ecx
.text:000005F2                 mov     eax, [ebp+var_4]
.text:000005F5                 mov     eax, [eax+4]
.text:000005F8                 mov     esp, ebp
.text:000005FA                 pop     ebp
.text:000005FB                 retn
.text:000005FB ?GetBlockSize@CMemBlockManager@@QBEIXZ endp
.text:000005FB
.text:000005FB _text           ends
.text:000005FB
.text:000005FC ; ===========================================================================
.text:000005FC
.text:000005FC ; Segment type: Pure code
.text:000005FC ; Segment permissions: Read/Execute
.text:000005FC _text           segment para public 'CODE' use32
.text:000005FC                 assume cs:_text
.text:000005FC                 ;org 5FCh
.text:000005FC ; COMDAT (pick any)
.text:000005FC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000005FC
.text:000005FC ; =============== S U B R O U T I N E =======================================
.text:000005FC
.text:000005FC ; Attributes: bp-based frame
.text:000005FC
.text:000005FC ; public: __thiscall NWindows::NSynchronization::CBaseEvent::operator void *(void)
.text:000005FC                 public ??BCBaseEvent@NSynchronization@NWindows@@QAEPAXXZ
.text:000005FC ??BCBaseEvent@NSynchronization@NWindows@@QAEPAXXZ proc near
.text:000005FC                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+181p
.text:000005FC                                         ; COutMemStream::Write(void const *,uint,uint *)+18Fp
.text:000005FC
.text:000005FC var_4           = dword ptr -4
.text:000005FC
.text:000005FC                 push    ebp
.text:000005FD                 mov     ebp, esp
.text:000005FF                 push    ecx
.text:00000600                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000607                 mov     [ebp+var_4], ecx
.text:0000060A                 mov     eax, [ebp+var_4]
.text:0000060D                 mov     eax, [eax]
.text:0000060F                 mov     esp, ebp
.text:00000611                 pop     ebp
.text:00000612                 retn
.text:00000612 ??BCBaseEvent@NSynchronization@NWindows@@QAEPAXXZ endp
.text:00000612
.text:00000612 ; ---------------------------------------------------------------------------
.text:00000613                 align 4
.text:00000613 _text           ends
.text:00000613
.text:00000614 ; ===========================================================================
.text:00000614
.text:00000614 ; Segment type: Pure code
.text:00000614 ; Segment permissions: Read/Execute
.text:00000614 _text           segment para public 'CODE' use32
.text:00000614                 assume cs:_text
.text:00000614                 ;org 614h
.text:00000614 ; COMDAT (pick any)
.text:00000614                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000614
.text:00000614 ; =============== S U B R O U T I N E =======================================
.text:00000614
.text:00000614 ; Attributes: bp-based frame
.text:00000614
.text:00000614 ; public: __thiscall NWindows::NSynchronization::CSemaphore::operator void *(void)
.text:00000614                 public ??BCSemaphore@NSynchronization@NWindows@@QAEPAXXZ
.text:00000614 ??BCSemaphore@NSynchronization@NWindows@@QAEPAXXZ proc near
.text:00000614                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+1A0p
.text:00000614
.text:00000614 var_4           = dword ptr -4
.text:00000614
.text:00000614                 push    ebp
.text:00000615                 mov     ebp, esp
.text:00000617                 push    ecx
.text:00000618                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000061F                 mov     [ebp+var_4], ecx
.text:00000622                 mov     eax, [ebp+var_4]
.text:00000625                 mov     eax, [eax]
.text:00000627                 mov     esp, ebp
.text:00000629                 pop     ebp
.text:0000062A                 retn
.text:0000062A ??BCSemaphore@NSynchronization@NWindows@@QAEPAXXZ endp
.text:0000062A
.text:0000062A ; ---------------------------------------------------------------------------
.text:0000062B                 align 4
.text:0000062B _text           ends
.text:0000062B
.text:0000062C ; ===========================================================================
.text:0000062C
.text:0000062C ; Segment type: Pure code
.text:0000062C ; Segment permissions: Read/Execute
.text:0000062C _text           segment para public 'CODE' use32
.text:0000062C                 assume cs:_text
.text:0000062C                 ;org 62Ch
.text:0000062C ; COMDAT (pick any)
.text:0000062C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000062C
.text:0000062C ; =============== S U B R O U T I N E =======================================
.text:0000062C
.text:0000062C ; Attributes: bp-based frame
.text:0000062C
.text:0000062C ; unsigned __int64 __thiscall COutMemStream::GetPos(COutMemStream *__hidden this)
.text:0000062C                 public ?GetPos@COutMemStream@@ABE_KXZ
.text:0000062C ?GetPos@COutMemStream@@ABE_KXZ proc near
.text:0000062C                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+112p
.text:0000062C                                         ; COutMemStream::Seek(__int64,uint,unsigned __int64 *)+BCp
.text:0000062C
.text:0000062C var_4           = dword ptr -4
.text:0000062C
.text:0000062C                 push    ebp
.text:0000062D                 mov     ebp, esp
.text:0000062F                 push    ecx
.text:00000630                 push    esi
.text:00000631                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000638                 mov     [ebp+var_4], ecx
.text:0000063B                 mov     eax, [ebp+var_4]
.text:0000063E                 mov     esi, [eax+0Ch]
.text:00000641                 mov     ecx, [ebp+var_4]
.text:00000644                 mov     ecx, [ecx+8]    ; this
.text:00000647                 call    ?GetBlockSize@CMemBlockManager@@QBEIXZ ; CMemBlockManager::GetBlockSize(void)
.text:0000064C                 mov     edx, eax
.text:0000064E                 mov     eax, esi
.text:00000650                 mul     edx
.text:00000652                 mov     ecx, [ebp+var_4]
.text:00000655                 mov     ecx, [ecx+10h]
.text:00000658                 xor     esi, esi
.text:0000065A                 add     eax, ecx
.text:0000065C                 adc     edx, esi
.text:0000065E                 pop     esi
.text:0000065F                 add     esp, 4
.text:00000662                 cmp     ebp, esp
.text:00000664                 call    __RTC_CheckEsp
.text:00000669                 mov     esp, ebp
.text:0000066B                 pop     ebp
.text:0000066C                 retn
.text:0000066C ?GetPos@COutMemStream@@ABE_KXZ endp
.text:0000066C
.text:0000066C ; ---------------------------------------------------------------------------
.text:0000066D                 align 10h
.text:0000066D _text           ends
.text:0000066D
.text:00000670 ; ===========================================================================
.text:00000670
.text:00000670 ; Segment type: Pure code
.text:00000670 ; Segment permissions: Read/Execute
.text:00000670 _text           segment para public 'CODE' use32
.text:00000670                 assume cs:_text
.text:00000670                 ;org 670h
.text:00000670 ; COMDAT (pick any)
.text:00000670                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000670
.text:00000670 ; =============== S U B R O U T I N E =======================================
.text:00000670
.text:00000670 ; Attributes: bp-based frame
.text:00000670
.text:00000670 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:00000670                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:00000670 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:00000670                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+77p
.text:00000670
.text:00000670 var_4           = dword ptr -4
.text:00000670
.text:00000670                 push    ebp
.text:00000671                 mov     ebp, esp
.text:00000673                 push    ecx
.text:00000674                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000067B                 mov     [ebp+var_4], ecx
.text:0000067E                 mov     eax, [ebp+var_4]
.text:00000681                 mov     eax, [eax+4]
.text:00000684                 mov     esp, ebp
.text:00000686                 pop     ebp
.text:00000687                 retn
.text:00000687 ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:00000687
.text:00000687 _text           ends
.text:00000687
.text:00000688 ; ===========================================================================
.text:00000688
.text:00000688 ; Segment type: Pure code
.text:00000688 ; Segment permissions: Read/Execute
.text:00000688 _text           segment para public 'CODE' use32
.text:00000688                 assume cs:_text
.text:00000688                 ;org 688h
.text:00000688 ; COMDAT (pick any)
.text:00000688                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000688
.text:00000688 ; =============== S U B R O U T I N E =======================================
.text:00000688
.text:00000688 ; Attributes: bp-based frame
.text:00000688
.text:00000688 ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:00000688                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:00000688 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:00000688                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+27Fp
.text:00000688
.text:00000688 var_8           = dword ptr -8
.text:00000688 var_4           = dword ptr -4
.text:00000688 arg_0           = dword ptr  8
.text:00000688
.text:00000688                 push    ebp
.text:00000689                 mov     ebp, esp
.text:0000068B                 sub     esp, 8
.text:0000068E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000695                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000069C                 mov     [ebp+var_4], ecx
.text:0000069F                 mov     ecx, [ebp+var_4]
.text:000006A2                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:000006A7                 mov     eax, [ebp+var_4]
.text:000006AA                 mov     ecx, [eax+4]
.text:000006AD                 mov     edx, [ebp+var_4]
.text:000006B0                 mov     eax, [edx]
.text:000006B2                 mov     edx, [ebp+arg_0]
.text:000006B5                 mov     [eax+ecx*4], edx
.text:000006B8                 mov     eax, [ebp+var_4]
.text:000006BB                 mov     ecx, [eax+4]
.text:000006BE                 mov     [ebp+var_8], ecx
.text:000006C1                 mov     edx, [ebp+var_4]
.text:000006C4                 mov     eax, [edx+4]
.text:000006C7                 add     eax, 1
.text:000006CA                 mov     ecx, [ebp+var_4]
.text:000006CD                 mov     [ecx+4], eax
.text:000006D0                 mov     eax, [ebp+var_8]
.text:000006D3                 add     esp, 8
.text:000006D6                 cmp     ebp, esp
.text:000006D8                 call    __RTC_CheckEsp
.text:000006DD                 mov     esp, ebp
.text:000006DF                 pop     ebp
.text:000006E0                 retn    4
.text:000006E0 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:000006E0
.text:000006E0 ; ---------------------------------------------------------------------------
.text:000006E3                 align 4
.text:000006E3 _text           ends
.text:000006E3
.text:000006E4 ; ===========================================================================
.text:000006E4
.text:000006E4 ; Segment type: Pure code
.text:000006E4 ; Segment permissions: Read/Execute
.text:000006E4 _text           segment para public 'CODE' use32
.text:000006E4                 assume cs:_text
.text:000006E4                 ;org 6E4h
.text:000006E4 ; COMDAT (pick any)
.text:000006E4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000006E4
.text:000006E4 ; =============== S U B R O U T I N E =======================================
.text:000006E4
.text:000006E4 ; Attributes: bp-based frame
.text:000006E4
.text:000006E4 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:000006E4                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:000006E4 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:000006E4                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+95p
.text:000006E4
.text:000006E4 var_4           = dword ptr -4
.text:000006E4 arg_0           = dword ptr  8
.text:000006E4
.text:000006E4                 push    ebp
.text:000006E5                 mov     ebp, esp
.text:000006E7                 push    ecx
.text:000006E8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000006EF                 mov     [ebp+var_4], ecx
.text:000006F2                 mov     eax, [ebp+var_4]
.text:000006F5                 mov     ecx, [eax]
.text:000006F7                 mov     edx, [ebp+arg_0]
.text:000006FA                 lea     eax, [ecx+edx*4]
.text:000006FD                 mov     esp, ebp
.text:000006FF                 pop     ebp
.text:00000700                 retn    4
.text:00000700 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:00000700
.text:00000700 ; ---------------------------------------------------------------------------
.text:00000703                 align 4
.text:00000703 _text           ends
.text:00000703
.text:00000704 ; ===========================================================================
.text:00000704
.text:00000704 ; Segment type: Pure code
.text:00000704 ; Segment permissions: Read/Execute
.text:00000704 _text           segment para public 'CODE' use32
.text:00000704                 assume cs:_text
.text:00000704                 ;org 704h
.text:00000704 ; COMDAT (pick any)
.text:00000704                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000704
.text:00000704 ; =============== S U B R O U T I N E =======================================
.text:00000704
.text:00000704 ; Attributes: bp-based frame
.text:00000704
.text:00000704 ; public: void * & __thiscall CRecordVector<void *>::Back(void)
.text:00000704                 public ?Back@?$CRecordVector@PAX@@QAEAAPAXXZ
.text:00000704 ?Back@?$CRecordVector@PAX@@QAEAAPAXXZ proc near
.text:00000704                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+28Ap
.text:00000704
.text:00000704 var_4           = dword ptr -4
.text:00000704
.text:00000704                 push    ebp
.text:00000705                 mov     ebp, esp
.text:00000707                 push    ecx
.text:00000708                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000070F                 mov     [ebp+var_4], ecx
.text:00000712                 mov     eax, [ebp+var_4]
.text:00000715                 mov     ecx, [eax+4]
.text:00000718                 mov     edx, [ebp+var_4]
.text:0000071B                 mov     eax, [edx]
.text:0000071D                 lea     eax, [eax+ecx*4-4]
.text:00000721                 mov     esp, ebp
.text:00000723                 pop     ebp
.text:00000724                 retn
.text:00000724 ?Back@?$CRecordVector@PAX@@QAEAAPAXXZ endp
.text:00000724
.text:00000724 ; ---------------------------------------------------------------------------
.text:00000725                 align 4
.text:00000725 _text           ends
.text:00000725
.text:00000728 ; ===========================================================================
.text:00000728
.text:00000728 ; Segment type: Pure code
.text:00000728 ; Segment permissions: Read/Execute
.text:00000728 _text           segment para public 'CODE' use32
.text:00000728                 assume cs:_text
.text:00000728                 ;org 728h
.text:00000728 ; COMDAT (pick any)
.text:00000728                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000728
.text:00000728 ; =============== S U B R O U T I N E =======================================
.text:00000728
.text:00000728 ; Attributes: bp-based frame
.text:00000728
.text:00000728 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::operator struct ISequentialOutStream *(void)const
.text:00000728                 public ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ
.text:00000728 ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ proc near
.text:00000728                                         ; CODE XREF: COutMemStream::WriteToRealStream(void)+1Dp
.text:00000728
.text:00000728 var_4           = dword ptr -4
.text:00000728
.text:00000728                 push    ebp
.text:00000729                 mov     ebp, esp
.text:0000072B                 push    ecx
.text:0000072C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000733                 mov     [ebp+var_4], ecx
.text:00000736                 mov     eax, [ebp+var_4]
.text:00000739                 mov     eax, [eax]
.text:0000073B                 mov     esp, ebp
.text:0000073D                 pop     ebp
.text:0000073E                 retn
.text:0000073E ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ endp
.text:0000073E
.text:0000073E ; ---------------------------------------------------------------------------
.text:0000073F                 align 10h
.text:0000073F _text           ends
.text:0000073F
.text:00000740 ; ===========================================================================
.text:00000740
.text:00000740 ; Segment type: Pure code
.text:00000740 ; Segment permissions: Read/Execute
.text:00000740 _text           segment para public 'CODE' use32
.text:00000740                 assume cs:_text
.text:00000740                 ;org 740h
.text:00000740 ; COMDAT (pick any)
.text:00000740                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000740
.text:00000740 ; =============== S U B R O U T I N E =======================================
.text:00000740
.text:00000740 ; Attributes: bp-based frame
.text:00000740
.text:00000740 ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::operator->(void)const
.text:00000740                 public ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ
.text:00000740 ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ proc near
.text:00000740                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+28p
.text:00000740                                         ; COutMemStream::Write(void const *,uint,uint *)+21Ep
.text:00000740
.text:00000740 var_4           = dword ptr -4
.text:00000740
.text:00000740                 push    ebp
.text:00000741                 mov     ebp, esp
.text:00000743                 push    ecx
.text:00000744                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000074B                 mov     [ebp+var_4], ecx
.text:0000074E                 mov     eax, [ebp+var_4]
.text:00000751                 mov     eax, [eax]
.text:00000753                 mov     esp, ebp
.text:00000755                 pop     ebp
.text:00000756                 retn
.text:00000756 ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ endp
.text:00000756
.text:00000756 ; ---------------------------------------------------------------------------
.text:00000757                 align 4
.text:00000757 _text           ends
.text:00000757
.text:00000758 ; ===========================================================================
.text:00000758
.text:00000758 ; Segment type: Pure code
.text:00000758 ; Segment permissions: Read/Execute
.text:00000758 _text           segment para public 'CODE' use32
.text:00000758                 assume cs:_text
.text:00000758                 ;org 758h
.text:00000758 ; COMDAT (pick any)
.text:00000758                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000758
.text:00000758 ; =============== S U B R O U T I N E =======================================
.text:00000758
.text:00000758 ; Attributes: bp-based frame
.text:00000758
.text:00000758 ; public: struct IOutStream * __thiscall CMyComPtr<struct IOutStream>::operator->(void)const
.text:00000758                 public ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ
.text:00000758 ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ proc near
.text:00000758                                         ; CODE XREF: COutMemStream::Seek(__int64,uint,unsigned __int64 *)+39p
.text:00000758                                         ; COutMemStream::SetSize(unsigned __int64)+36p
.text:00000758
.text:00000758 var_4           = dword ptr -4
.text:00000758
.text:00000758                 push    ebp
.text:00000759                 mov     ebp, esp
.text:0000075B                 push    ecx
.text:0000075C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000763                 mov     [ebp+var_4], ecx
.text:00000766                 mov     eax, [ebp+var_4]
.text:00000769                 mov     eax, [eax]
.text:0000076B                 mov     esp, ebp
.text:0000076D                 pop     ebp
.text:0000076E                 retn
.text:0000076E ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ endp
.text:0000076E
.text:0000076E ; ---------------------------------------------------------------------------
.text:0000076F                 align 10h
.text:0000076F _text           ends
.text:0000076F
.text:00000770 ; ===========================================================================
.text:00000770
.text:00000770 ; Segment type: Pure code
.text:00000770 ; Segment permissions: Read/Execute
.text:00000770 _text           segment para public 'CODE' use32
.text:00000770                 assume cs:_text
.text:00000770                 ;org 770h
.text:00000770 ; COMDAT (pick any)
.text:00000770                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000770
.text:00000770 ; =============== S U B R O U T I N E =======================================
.text:00000770
.text:00000770 ; Attributes: bp-based frame
.text:00000770
.text:00000770 ; public: bool __thiscall CMyComPtr<struct IOutStream>::operator!(void)const
.text:00000770                 public ??7?$CMyComPtr@UIOutStream@@@@QBE_NXZ
.text:00000770 ??7?$CMyComPtr@UIOutStream@@@@QBE_NXZ proc near
.text:00000770                                         ; CODE XREF: COutMemStream::Seek(__int64,uint,unsigned __int64 *)+1Dp
.text:00000770                                         ; COutMemStream::SetSize(unsigned __int64)+1Dp
.text:00000770
.text:00000770 var_4           = dword ptr -4
.text:00000770
.text:00000770                 push    ebp
.text:00000771                 mov     ebp, esp
.text:00000773                 push    ecx
.text:00000774                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000077B                 mov     [ebp+var_4], ecx
.text:0000077E                 mov     eax, [ebp+var_4]
.text:00000781                 xor     ecx, ecx
.text:00000783                 cmp     dword ptr [eax], 0
.text:00000786                 setz    cl
.text:00000789                 mov     al, cl
.text:0000078B                 mov     esp, ebp
.text:0000078D                 pop     ebp
.text:0000078E                 retn
.text:0000078E ??7?$CMyComPtr@UIOutStream@@@@QBE_NXZ endp
.text:0000078E
.text:0000078E ; ---------------------------------------------------------------------------
.text:0000078F                 align 10h
.text:0000078F _text           ends
.text:0000078F
.text:00000790 ; ===========================================================================
.text:00000790
.text:00000790 ; Segment type: Pure code
.text:00000790 ; Segment permissions: Read/Execute
.text:00000790 _text           segment para public 'CODE' use32
.text:00000790                 assume cs:_text
.text:00000790                 ;org 790h
.text:00000790 ; COMDAT (pick any)
.text:00000790                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000790
.text:00000790 ; =============== S U B R O U T I N E =======================================
.text:00000790
.text:00000790 ; Attributes: bp-based frame
.text:00000790
.text:00000790 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:00000790                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:00000790 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:00000790                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:00000790
.text:00000790 var_14          = dword ptr -14h
.text:00000790 var_10          = dword ptr -10h
.text:00000790 Dst             = dword ptr -0Ch
.text:00000790 var_8           = dword ptr -8
.text:00000790 var_4           = dword ptr -4
.text:00000790
.text:00000790                 push    ebp
.text:00000791                 mov     ebp, esp
.text:00000793                 sub     esp, 14h
.text:00000796                 mov     eax, 0CCCCCCCCh
.text:0000079B                 mov     [ebp+var_14], eax
.text:0000079E                 mov     [ebp+var_10], eax
.text:000007A1                 mov     [ebp+Dst], eax
.text:000007A4                 mov     [ebp+var_8], eax
.text:000007A7                 mov     [ebp+var_4], eax
.text:000007AA                 mov     [ebp+var_4], ecx
.text:000007AD                 mov     eax, [ebp+var_4]
.text:000007B0                 mov     ecx, [ebp+var_4]
.text:000007B3                 mov     edx, [eax+4]
.text:000007B6                 cmp     edx, [ecx+8]
.text:000007B9                 jnz     loc_844
.text:000007BF                 mov     eax, [ebp+var_4]
.text:000007C2                 mov     ecx, [eax+8]
.text:000007C5                 shr     ecx, 2
.text:000007C8                 mov     edx, [ebp+var_4]
.text:000007CB                 mov     eax, [edx+8]
.text:000007CE                 lea     ecx, [eax+ecx+1]
.text:000007D2                 mov     [ebp+var_8], ecx
.text:000007D5                 xor     ecx, ecx
.text:000007D7                 mov     eax, [ebp+var_8]
.text:000007DA                 mov     edx, 4
.text:000007DF                 mul     edx
.text:000007E1                 seto    cl
.text:000007E4                 neg     ecx
.text:000007E6                 or      ecx, eax
.text:000007E8                 push    ecx             ; unsigned int
.text:000007E9                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000007EE                 add     esp, 4
.text:000007F1                 mov     [ebp+var_10], eax
.text:000007F4                 mov     eax, [ebp+var_10]
.text:000007F7                 mov     [ebp+Dst], eax
.text:000007FA                 mov     ecx, [ebp+var_4]
.text:000007FD                 cmp     dword ptr [ecx+4], 0
.text:00000801                 jz      short loc_81F
.text:00000803                 mov     edx, [ebp+var_4]
.text:00000806                 mov     eax, [edx+4]
.text:00000809                 shl     eax, 2
.text:0000080C                 push    eax             ; Size
.text:0000080D                 mov     ecx, [ebp+var_4]
.text:00000810                 mov     edx, [ecx]
.text:00000812                 push    edx             ; Src
.text:00000813                 mov     eax, [ebp+Dst]
.text:00000816                 push    eax             ; Dst
.text:00000817                 call    _memcpy
.text:0000081C                 add     esp, 0Ch
.text:0000081F
.text:0000081F loc_81F:                                ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:0000081F                 mov     ecx, [ebp+var_4]
.text:00000822                 mov     edx, [ecx]
.text:00000824                 mov     [ebp+var_14], edx
.text:00000827                 mov     eax, [ebp+var_14]
.text:0000082A                 push    eax             ; void *
.text:0000082B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000830                 add     esp, 4
.text:00000833                 mov     ecx, [ebp+var_4]
.text:00000836                 mov     edx, [ebp+Dst]
.text:00000839                 mov     [ecx], edx
.text:0000083B                 mov     eax, [ebp+var_4]
.text:0000083E                 mov     ecx, [ebp+var_8]
.text:00000841                 mov     [eax+8], ecx
.text:00000844
.text:00000844 loc_844:                                ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:00000844                 add     esp, 14h
.text:00000847                 cmp     ebp, esp
.text:00000849                 call    __RTC_CheckEsp
.text:0000084E                 mov     esp, ebp
.text:00000850                 pop     ebp
.text:00000851                 retn
.text:00000851 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:00000851
.text:00000851 _text           ends
.text:00000851
UNDEF:00000860 ; ===========================================================================
UNDEF:00000860
UNDEF:00000860 ; Segment type: Externs
UNDEF:00000860 ; UNDEF
UNDEF:00000860 ; void __thiscall CMemLockBlocks::Free(CMemLockBlocks *__hidden this, struct CMemBlockManagerMt *)
UNDEF:00000860                 extrn ?Free@CMemLockBlocks@@QAEXPAVCMemBlockManagerMt@@@Z:near
UNDEF:00000860                                         ; CODE XREF: COutMemStream::Free(void)+1Bp
UNDEF:00000860                                         ; COutMemStream::WriteToRealStream(void)+55p
UNDEF:00000864                 extrn __RTC_CheckEsp:near
UNDEF:00000864                                         ; CODE XREF: COutMemStream::Free(void)+2Cp
UNDEF:00000864                                         ; COutMemStream::Init(void)+48p ...
UNDEF:00000868                 extrn __RTC_Shutdown:near
UNDEF:00000868                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:0000086C                 extrn __RTC_InitBase:near
UNDEF:0000086C                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00000870 ; __stdcall Event_Reset(x)
UNDEF:00000870                 extrn _Event_Reset@4:near
UNDEF:00000870                                         ; CODE XREF: NWindows::NSynchronization::CBaseEvent::Reset(void)+12p
UNDEF:00000874 ; void __thiscall CMemLockBlocks::Detach(CMemLockBlocks *__hidden this, struct CMemLockBlocks *, struct CMemBlockManagerMt *)
UNDEF:00000874                 extrn ?Detach@CMemLockBlocks@@QAEXAAU1@PAVCMemBlockManagerMt@@@Z:near
UNDEF:00000874                                         ; CODE XREF: COutMemStream::DetachData(CMemLockBlocks &)+1Fp
UNDEF:00000878 ; __int32 __thiscall CMemBlocks::WriteToStream(CMemBlocks *__hidden this, unsigned int, struct ISequentialOutStream *)
UNDEF:00000878                 extrn ?WriteToStream@CMemBlocks@@QBEJIPAUISequentialOutStream@@@Z:near
UNDEF:00000878                                         ; CODE XREF: COutMemStream::WriteToRealStream(void)+35p
UNDEF:0000087C ; void *__thiscall CMemBlockManagerMt::AllocateBlock(CMemBlockManagerMt *__hidden this)
UNDEF:0000087C                 extrn ?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ:near
UNDEF:0000087C                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+273p
UNDEF:00000880 ; DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
UNDEF:00000880                 extrn __imp__WaitForMultipleObjects@16:near
UNDEF:00000880                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+1C3p
UNDEF:00000880                                         ; DATA XREF: COutMemStream::Write(void const *,uint,uint *)+1C3r
UNDEF:00000884 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00000884                 extrn _memcpy:near      ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+D3p
UNDEF:00000884                                         ; CRecordVector<void *>::ReserveOnePosition(void)+87p
UNDEF:00000888 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00000888                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00000888                                         ; CODE XREF: COutMemStream::Write(void const *,uint,uint *)+2ACp
UNDEF:0000088C ; void __cdecl operator delete(void *)
UNDEF:0000088C                 extrn ??3@YAXPAX@Z:near ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+9Bp
UNDEF:00000890 ; void *__cdecl operator new(unsigned int)
UNDEF:00000890                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+59p
UNDEF:00000890
UNDEF:00000890
UNDEF:00000890                 end