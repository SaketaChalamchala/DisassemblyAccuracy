.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 40E7AA379FBF04FF1E2AFC67501C44AE
.rdata:00000000 ; Input CRC32 : 51778DE2
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\ArchiveExtractCallback.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG76080        db 'Can not create file with auto name',0
.rdata:00000000                                         ; DATA XREF: .data:_kCantAutoRenameo
.rdata:00000023 unk_23          db    0                 ; DATA XREF: .xdata$x:00006FC4o
.rdata:00000024 $SG76082        db  43h ; C             ; DATA XREF: .data:_kCantRenameFileo
.rdata:00000025                 db  61h ; a
.rdata:00000026                 db  6Eh ; n
.rdata:00000027                 db  20h
.rdata:00000028                 db  6Eh ; n
.rdata:00000029                 db  6Fh ; o
.rdata:0000002A                 db  74h ; t
.rdata:0000002B                 db  20h
.rdata:0000002C                 db  72h ; r
.rdata:0000002D                 db  65h ; e
.rdata:0000002E aNameExistingFi db 'name existing file',0 ; DATA XREF: .rdata:$SG76377o
.rdata:00000041                 align 4
.rdata:00000044 $SG76084        db 'Can not delete output file',0
.rdata:00000044                                         ; DATA XREF: .data:_kCantDeleteOutputFileo
.rdata:0000005F                 align 10h
.rdata:00000060 $SG76086        db 'Can not delete output folder',0
.rdata:00000060                                         ; DATA XREF: .data:_kCantDeleteOutputDiro
.rdata:0000007D                 align 10h
.rdata:00000080 ; CHAR _SG76105[]
.rdata:00000080 $SG76105        db 'SeSecurityPrivilege',0
.rdata:00000080                                         ; DATA XREF: InitLocalPrivileges(void)+98o
.rdata:00000094 ; char _SG76325[]
.rdata:00000094 $SG76325        db ' : ',0              ; DATA XREF: AddPathToMessage(UString &,UString const &)+3o
.rdata:00000098 ; char _SG76341[]
.rdata:00000098 $SG76341        db ' : ',0              ; DATA XREF: CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)+6Eo
.rdata:0000009C ; wchar_t _SG76377
.rdata:0000009C $SG76377        dd offset aNameExistingFi
.rdata:0000009C                                         ; DATA XREF: IsSafePath(UString const &):loc_547Fo
.rdata:0000009C                                         ; "name existing file"
.rdata:000000A0 ; wchar_t _SG76379
.rdata:000000A0 $SG76379:                               ; DATA XREF: IsSafePath(UString const &):loc_5496o
.rdata:000000A0                 unicode 0, <..>,0
.rdata:000000A6                 align 4
.rdata:000000A8 ; char _SG76721[]
.rdata:000000A8 $SG76721        db 'Dangerous link path was ignored',0
.rdata:000000A8                                         ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2659o
.rdata:000000C8 ; char _SG76730[]
.rdata:000000C8 $SG76730        db 'Incorrect path',0   ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2766o
.rdata:000000D7                 align 4
.rdata:000000D8 ; char _SG76738[]
.rdata:000000D8 $SG76738        db 'Can not create hard link',0
.rdata:000000D8                                         ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2891o
.rdata:000000F1                 align 4
.rdata:000000F4 ; char _SG76749[]
.rdata:000000F4 $SG76749        db 'Internal error for symbolic link file',0
.rdata:000000F4                                         ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2A02o
.rdata:0000011A                 align 4
.rdata:0000011C ; char _SG76756[]
.rdata:0000011C $SG76756        db 'Can not create symbolic link',0
.rdata:0000011C                                         ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2B33o
.rdata:00000139                 align 4
.rdata:0000013C ; char _SG76775[]
.rdata:0000013C $SG76775        db 'Can not create hard link',0
.rdata:0000013C                                         ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2DE3o
.rdata:00000155                 align 4
.rdata:00000158 ; char _SG76789[]
.rdata:00000158 $SG76789        db 'Can not open output file',0
.rdata:00000158                                         ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2FA0o
.rdata:00000171                 align 4
.rdata:00000171 _rdata          ends
.rdata:00000171
.data:00000174 ; ===========================================================================
.data:00000174
.data:00000174 ; Segment type: Pure data
.data:00000174 ; Segment permissions: Read/Write
.data:00000174 _data           segment dword public 'DATA' use32
.data:00000174                 assume cs:_data
.data:00000174                 ;org 174h
.data:00000174 ; char *kCantAutoRename
.data:00000174 _kCantAutoRename dd offset $SG76080     ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1DFAr
.data:00000174                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1F3Cr
.data:00000174                                         ; "Can not create file with auto name"
.data:00000178 ; char *kCantRenameFile
.data:00000178 _kCantRenameFile dd offset $SG76082     ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2098r
.data:0000017C ; char *kCantDeleteOutputFile
.data:0000017C _kCantDeleteOutputFile dd offset $SG76084
.data:0000017C                                         ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2343r
.data:0000017C                                         ; "Can not delete output file"
.data:00000180 ; char *kCantDeleteOutputDir
.data:00000180 _kCantDeleteOutputDir dd offset $SG76086
.data:00000180                                         ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2209r
.data:00000180 _data           ends                    ; "Can not delete output folder"
.data:00000180
.text:00000184 ; ===========================================================================
.text:00000184
.text:00000184 ; Segment type: Pure code
.text:00000184 ; Segment permissions: Read/Execute
.text:00000184 _text           segment para public 'CODE' use32
.text:00000184                 assume cs:_text
.text:00000184                 ;org 184h
.text:00000184                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000184
.text:00000184 ; =============== S U B R O U T I N E =======================================
.text:00000184
.text:00000184 ; Attributes: bp-based frame
.text:00000184
.text:00000184 ; __int32 __stdcall COutStreamWithHash::Write(COutStreamWithHash *this, const void *, unsigned int, unsigned int *)
.text:00000184                 public ?Write@COutStreamWithHash@@UAGJPBXIPAI@Z
.text:00000184 ?Write@COutStreamWithHash@@UAGJPBXIPAI@Z proc near
.text:00000184
.text:00000184 var_8           = dword ptr -8
.text:00000184 var_4           = dword ptr -4
.text:00000184 this            = dword ptr  8
.text:00000184 arg_4           = dword ptr  0Ch
.text:00000184 arg_8           = dword ptr  10h
.text:00000184 arg_C           = dword ptr  14h
.text:00000184
.text:00000184                 push    ebp
.text:00000185                 mov     ebp, esp
.text:00000187                 sub     esp, 8
.text:0000018A                 push    esi
.text:0000018B                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000192                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000199                 mov     [ebp+var_4], 0
.text:000001A0                 mov     ecx, [ebp+this]
.text:000001A3                 add     ecx, 8
.text:000001A6                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:000001AB                 test    eax, eax
.text:000001AD                 jz      short loc_1E3
.text:000001AF                 mov     ecx, [ebp+this]
.text:000001B2                 add     ecx, 8
.text:000001B5                 call    ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator->(void)
.text:000001BA                 mov     [ebp+var_8], eax
.text:000001BD                 mov     esi, esp
.text:000001BF                 lea     eax, [ebp+arg_8]
.text:000001C2                 push    eax
.text:000001C3                 mov     ecx, [ebp+arg_8]
.text:000001C6                 push    ecx
.text:000001C7                 mov     edx, [ebp+arg_4]
.text:000001CA                 push    edx
.text:000001CB                 mov     eax, [ebp+var_8]
.text:000001CE                 push    eax
.text:000001CF                 mov     ecx, [ebp+var_8]
.text:000001D2                 mov     edx, [ecx]
.text:000001D4                 mov     eax, [edx+0Ch]
.text:000001D7                 call    eax
.text:000001D9                 cmp     esi, esp
.text:000001DB                 call    __RTC_CheckEsp
.text:000001E0                 mov     [ebp+var_4], eax
.text:000001E3
.text:000001E3 loc_1E3:                                ; CODE XREF: COutStreamWithHash::Write(void const *,uint,uint *)+29j
.text:000001E3                 mov     ecx, [ebp+this]
.text:000001E6                 movzx   edx, byte ptr [ecx+18h]
.text:000001EA                 test    edx, edx
.text:000001EC                 jz      short loc_212
.text:000001EE                 mov     esi, esp
.text:000001F0                 mov     eax, [ebp+arg_8]
.text:000001F3                 push    eax
.text:000001F4                 mov     ecx, [ebp+arg_4]
.text:000001F7                 push    ecx
.text:000001F8                 mov     edx, [ebp+this]
.text:000001FB                 mov     eax, [edx+1Ch]
.text:000001FE                 mov     ecx, [ebp+this]
.text:00000201                 mov     ecx, [ecx+1Ch]
.text:00000204                 mov     edx, [eax]
.text:00000206                 mov     eax, [edx+4]
.text:00000209                 call    eax
.text:0000020B                 cmp     esi, esp
.text:0000020D                 call    __RTC_CheckEsp
.text:00000212
.text:00000212 loc_212:                                ; CODE XREF: COutStreamWithHash::Write(void const *,uint,uint *)+68j
.text:00000212                 mov     ecx, [ebp+arg_8]
.text:00000215                 xor     edx, edx
.text:00000217                 mov     eax, [ebp+this]
.text:0000021A                 add     ecx, [eax+10h]
.text:0000021D                 adc     edx, [eax+14h]
.text:00000220                 mov     eax, [ebp+this]
.text:00000223                 mov     [eax+10h], ecx
.text:00000226                 mov     [eax+14h], edx
.text:00000229                 cmp     [ebp+arg_C], 0
.text:0000022D                 jz      short loc_237
.text:0000022F                 mov     ecx, [ebp+arg_C]
.text:00000232                 mov     edx, [ebp+arg_8]
.text:00000235                 mov     [ecx], edx
.text:00000237
.text:00000237 loc_237:                                ; CODE XREF: COutStreamWithHash::Write(void const *,uint,uint *)+A9j
.text:00000237                 mov     eax, [ebp+var_4]
.text:0000023A                 pop     esi
.text:0000023B                 add     esp, 8
.text:0000023E                 cmp     ebp, esp
.text:00000240                 call    __RTC_CheckEsp
.text:00000245                 mov     esp, ebp
.text:00000247                 pop     ebp
.text:00000248                 retn    10h
.text:00000248 ?Write@COutStreamWithHash@@UAGJPBXIPAI@Z endp
.text:00000248
.text:00000248 ; ---------------------------------------------------------------------------
.text:0000024B                 db 9 dup(0CCh)
.text:00000254
.text:00000254 ; =============== S U B R O U T I N E =======================================
.text:00000254
.text:00000254 ; Attributes: bp-based frame
.text:00000254
.text:00000254 ; bool __stdcall InitLocalPrivileges()
.text:00000254                 public ?InitLocalPrivileges@@YG_NXZ
.text:00000254 ?InitLocalPrivileges@@YG_NXZ proc near  ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+25Bp
.text:00000254
.text:00000254 var_38          = byte ptr -38h
.text:00000254 var_37          = byte ptr -37h
.text:00000254 var_36          = byte ptr -36h
.text:00000254 var_35          = byte ptr -35h
.text:00000254 var_30          = _TOKEN_PRIVILEGES ptr -30h
.text:00000254 var_18          = byte ptr -18h
.text:00000254 var_10          = dword ptr -10h
.text:00000254 var_C           = dword ptr -0Ch
.text:00000254 var_4           = dword ptr -4
.text:00000254
.text:00000254                 push    ebp
.text:00000255                 mov     ebp, esp
.text:00000257                 push    0FFFFFFFFh
.text:00000259                 push    offset __ehhandler$?InitLocalPrivileges@@YG_NXZ
.text:0000025E                 mov     eax, large fs:0
.text:00000264                 push    eax
.text:00000265                 sub     esp, 2Ch
.text:00000268                 push    esi
.text:00000269                 push    edi
.text:0000026A                 lea     edi, [ebp+var_38]
.text:0000026D                 mov     ecx, 0Bh
.text:00000272                 mov     eax, 0CCCCCCCCh
.text:00000277                 rep stosd
.text:00000279                 mov     eax, dword ptr ds:___security_cookie
.text:0000027E                 xor     eax, ebp
.text:00000280                 mov     [ebp+var_10], eax
.text:00000283                 push    eax
.text:00000284                 lea     eax, [ebp+var_C]
.text:00000287                 mov     large fs:0, eax
.text:0000028D                 lea     ecx, [ebp+var_18] ; this
.text:00000290                 call    ??0CAccessToken@NSecurity@NWindows@@QAE@XZ ; NWindows::NSecurity::CAccessToken::CAccessToken(void)
.text:00000295                 mov     [ebp+var_4], 0
.text:0000029C                 push    28h ; '('       ; unsigned __int32
.text:0000029E                 mov     esi, esp
.text:000002A0                 call    dword ptr ds:__imp__GetCurrentProcess@0 ; GetCurrentProcess()
.text:000002A6                 cmp     esi, esp
.text:000002A8                 call    __RTC_CheckEsp
.text:000002AD                 push    eax             ; ProcessHandle
.text:000002AE                 lea     ecx, [ebp+var_18] ; this
.text:000002B1                 call    ?OpenProcessToken@CAccessToken@NSecurity@NWindows@@QAE_NPAXK@Z ; NWindows::NSecurity::CAccessToken::OpenProcessToken(void *,ulong)
.text:000002B6                 movzx   eax, al
.text:000002B9                 test    eax, eax
.text:000002BB                 jnz     short loc_2D8
.text:000002BD                 mov     [ebp+var_35], 0
.text:000002C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000002C8                 lea     ecx, [ebp+var_18] ; this
.text:000002CB                 call    ??1CAccessToken@NSecurity@NWindows@@QAE@XZ ; NWindows::NSecurity::CAccessToken::~CAccessToken(void)
.text:000002D0                 mov     al, [ebp+var_35]
.text:000002D3                 jmp     loc_372
.text:000002D8 ; ---------------------------------------------------------------------------
.text:000002D8
.text:000002D8 loc_2D8:                                ; CODE XREF: InitLocalPrivileges(void)+67j
.text:000002D8                 mov     [ebp+var_30.PrivilegeCount], 1
.text:000002DF                 mov     [ebp+var_30.Privileges.Attributes], 2
.text:000002E6                 mov     esi, esp
.text:000002E8                 lea     ecx, [ebp+var_30.Privileges]
.text:000002EB                 push    ecx             ; lpLuid
.text:000002EC                 push    offset $SG76105 ; "SeSecurityPrivilege"
.text:000002F1                 push    0               ; lpSystemName
.text:000002F3                 call    dword ptr ds:__imp__LookupPrivilegeValueA@12 ; LookupPrivilegeValueA(x,x,x)
.text:000002F9                 cmp     esi, esp
.text:000002FB                 call    __RTC_CheckEsp
.text:00000300                 test    eax, eax
.text:00000302                 jnz     short loc_31C
.text:00000304                 mov     [ebp+var_36], 0
.text:00000308                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000030F                 lea     ecx, [ebp+var_18] ; this
.text:00000312                 call    ??1CAccessToken@NSecurity@NWindows@@QAE@XZ ; NWindows::NSecurity::CAccessToken::~CAccessToken(void)
.text:00000317                 mov     al, [ebp+var_36]
.text:0000031A                 jmp     short loc_372
.text:0000031C ; ---------------------------------------------------------------------------
.text:0000031C
.text:0000031C loc_31C:                                ; CODE XREF: InitLocalPrivileges(void)+AEj
.text:0000031C                 lea     edx, [ebp+var_30]
.text:0000031F                 push    edx             ; struct _TOKEN_PRIVILEGES *
.text:00000320                 lea     ecx, [ebp+var_18] ; this
.text:00000323                 call    ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_NPAU_TOKEN_PRIVILEGES@@@Z ; NWindows::NSecurity::CAccessToken::AdjustPrivileges(_TOKEN_PRIVILEGES *)
.text:00000328                 movzx   eax, al
.text:0000032B                 test    eax, eax
.text:0000032D                 jnz     short loc_347
.text:0000032F                 mov     [ebp+var_37], 0
.text:00000333                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000033A                 lea     ecx, [ebp+var_18] ; this
.text:0000033D                 call    ??1CAccessToken@NSecurity@NWindows@@QAE@XZ ; NWindows::NSecurity::CAccessToken::~CAccessToken(void)
.text:00000342                 mov     al, [ebp+var_37]
.text:00000345                 jmp     short loc_372
.text:00000347 ; ---------------------------------------------------------------------------
.text:00000347
.text:00000347 loc_347:                                ; CODE XREF: InitLocalPrivileges(void)+D9j
.text:00000347                 mov     esi, esp
.text:00000349                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text:0000034F                 cmp     esi, esp
.text:00000351                 call    __RTC_CheckEsp
.text:00000356                 neg     eax
.text:00000358                 sbb     eax, eax
.text:0000035A                 add     eax, 1
.text:0000035D                 mov     [ebp+var_38], al
.text:00000360                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000367                 lea     ecx, [ebp+var_18] ; this
.text:0000036A                 call    ??1CAccessToken@NSecurity@NWindows@@QAE@XZ ; NWindows::NSecurity::CAccessToken::~CAccessToken(void)
.text:0000036F                 mov     al, [ebp+var_38]
.text:00000372
.text:00000372 loc_372:                                ; CODE XREF: InitLocalPrivileges(void)+7Fj
.text:00000372                                         ; InitLocalPrivileges(void)+C6j ...
.text:00000372                 push    edx
.text:00000373                 mov     ecx, ebp
.text:00000375                 push    eax
.text:00000376                 lea     edx, $LN11
.text:0000037C                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000381                 pop     eax
.text:00000382                 pop     edx
.text:00000383                 mov     ecx, [ebp+var_C]
.text:00000386                 mov     large fs:0, ecx
.text:0000038D                 pop     ecx
.text:0000038E                 pop     edi
.text:0000038F                 pop     esi
.text:00000390                 mov     ecx, [ebp+var_10]
.text:00000393                 xor     ecx, ebp
.text:00000395                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:0000039A                 add     esp, 38h
.text:0000039D                 cmp     ebp, esp
.text:0000039F                 call    __RTC_CheckEsp
.text:000003A4                 mov     esp, ebp
.text:000003A6                 pop     ebp
.text:000003A7                 retn
.text:000003A7 ?InitLocalPrivileges@@YG_NXZ endp
.text:000003A7
.text:000003A7 ; ---------------------------------------------------------------------------
.text:000003A8 $LN11           dd 2                    ; DATA XREF: InitLocalPrivileges(void)+122o
.text:000003AC                 dd offset $LN10
.text:000003B0 $LN10           dd 0FFFFFFE8h, 4        ; DATA XREF: .text:000003ACo
.text:000003B8                 dd offset $LN7          ; "token"
.text:000003BC                 dd 0FFFFFFD0h, 10h
.text:000003C4                 dd offset $LN8
.text:000003C8 $LN8            db 74h, 70h, 0          ; DATA XREF: .text:000003C4o
.text:000003CB $LN7            db 'token',0            ; DATA XREF: .text:000003B8o
.text:000003D1                 align 4
.text:000003D4
.text:000003D4 ; =============== S U B R O U T I N E =======================================
.text:000003D4
.text:000003D4 ; Attributes: bp-based frame
.text:000003D4
.text:000003D4 ; int __thiscall CHardLinkNode::Compare(CHardLinkNode *this, const struct CHardLinkNode *)
.text:000003D4                 public ?Compare@CHardLinkNode@@QBEHABU1@@Z
.text:000003D4 ?Compare@CHardLinkNode@@QBEHABU1@@Z proc near
.text:000003D4                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+1C4p
.text:000003D4                                         ; CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode const &,uint,uint)+43p ...
.text:000003D4
.text:000003D4 var_14          = dword ptr -14h
.text:000003D4 var_10          = dword ptr -10h
.text:000003D4 var_C           = dword ptr -0Ch
.text:000003D4 var_8           = dword ptr -8
.text:000003D4 var_4           = dword ptr -4
.text:000003D4 arg_0           = dword ptr  8
.text:000003D4
.text:000003D4                 push    ebp
.text:000003D5                 mov     ebp, esp
.text:000003D7                 sub     esp, 14h
.text:000003DA                 mov     eax, 0CCCCCCCCh
.text:000003DF                 mov     [ebp+var_14], eax
.text:000003E2                 mov     [ebp+var_10], eax
.text:000003E5                 mov     [ebp+var_C], eax
.text:000003E8                 mov     [ebp+var_8], eax
.text:000003EB                 mov     [ebp+var_4], eax
.text:000003EE                 mov     [ebp+var_4], ecx
.text:000003F1                 mov     eax, [ebp+var_4]
.text:000003F4                 mov     ecx, [ebp+arg_0]
.text:000003F7                 mov     [ebp+var_8], eax
.text:000003FA                 mov     [ebp+var_C], ecx
.text:000003FD                 mov     edx, [ebp+var_8]
.text:00000400                 mov     eax, [ebp+var_C]
.text:00000403                 mov     ecx, [edx+4]
.text:00000406                 cmp     ecx, [eax+4]
.text:00000409                 ja      short loc_41E
.text:0000040B                 jb      short loc_419
.text:0000040D                 mov     edx, [ebp+var_8]
.text:00000410                 mov     eax, [ebp+var_C]
.text:00000413                 mov     ecx, [edx]
.text:00000415                 cmp     ecx, [eax]
.text:00000417                 jnb     short loc_41E
.text:00000419
.text:00000419 loc_419:                                ; CODE XREF: CHardLinkNode::Compare(CHardLinkNode const &)+37j
.text:00000419                 or      eax, 0FFFFFFFFh
.text:0000041C                 jmp     short loc_468
.text:0000041E ; ---------------------------------------------------------------------------
.text:0000041E
.text:0000041E loc_41E:                                ; CODE XREF: CHardLinkNode::Compare(CHardLinkNode const &)+35j
.text:0000041E                                         ; CHardLinkNode::Compare(CHardLinkNode const &)+43j
.text:0000041E                 mov     edx, [ebp+var_4]
.text:00000421                 mov     eax, [ebp+arg_0]
.text:00000424                 mov     [ebp+var_10], edx
.text:00000427                 mov     [ebp+var_14], eax
.text:0000042A                 mov     ecx, [ebp+var_10]
.text:0000042D                 mov     edx, [ebp+var_14]
.text:00000430                 mov     eax, [ecx+4]
.text:00000433                 cmp     eax, [edx+4]
.text:00000436                 jb      short loc_44D
.text:00000438                 ja      short loc_446
.text:0000043A                 mov     ecx, [ebp+var_10]
.text:0000043D                 mov     edx, [ebp+var_14]
.text:00000440                 mov     eax, [ecx]
.text:00000442                 cmp     eax, [edx]
.text:00000444                 jbe     short loc_44D
.text:00000446
.text:00000446 loc_446:                                ; CODE XREF: CHardLinkNode::Compare(CHardLinkNode const &)+64j
.text:00000446                 mov     eax, 1
.text:0000044B                 jmp     short loc_468
.text:0000044D ; ---------------------------------------------------------------------------
.text:0000044D
.text:0000044D loc_44D:                                ; CODE XREF: CHardLinkNode::Compare(CHardLinkNode const &)+62j
.text:0000044D                                         ; CHardLinkNode::Compare(CHardLinkNode const &)+70j
.text:0000044D                 mov     ecx, [ebp+arg_0]
.text:00000450                 mov     edx, [ecx+0Ch]
.text:00000453                 push    edx
.text:00000454                 mov     eax, [ecx+8]
.text:00000457                 push    eax
.text:00000458                 mov     ecx, [ebp+var_4]
.text:0000045B                 mov     edx, [ecx+0Ch]
.text:0000045E                 push    edx
.text:0000045F                 mov     eax, [ecx+8]
.text:00000462                 push    eax
.text:00000463                 call    ??$MyCompare@_K@@YGH_K0@Z ; MyCompare<unsigned __int64>(unsigned __int64,unsigned __int64)
.text:00000468
.text:00000468 loc_468:                                ; CODE XREF: CHardLinkNode::Compare(CHardLinkNode const &)+48j
.text:00000468                                         ; CHardLinkNode::Compare(CHardLinkNode const &)+77j
.text:00000468                 add     esp, 14h
.text:0000046B                 cmp     ebp, esp
.text:0000046D                 call    __RTC_CheckEsp
.text:00000472                 mov     esp, ebp
.text:00000474                 pop     ebp
.text:00000475                 retn    4
.text:00000475 ?Compare@CHardLinkNode@@QBEHABU1@@Z endp
.text:00000475
.text:00000475 ; ---------------------------------------------------------------------------
.text:00000478                 db 0Ch dup(0CCh)
.text:00000484
.text:00000484 ; =============== S U B R O U T I N E =======================================
.text:00000484
.text:00000484 ; Attributes: bp-based frame
.text:00000484
.text:00000484 ; public: long __thiscall CArchiveExtractCallback::PrepareHardLinks(class CRecordVector<unsigned int> const *)
.text:00000484                 public ?PrepareHardLinks@CArchiveExtractCallback@@QAEJPBV?$CRecordVector@I@@@Z
.text:00000484 ?PrepareHardLinks@CArchiveExtractCallback@@QAEJPBV?$CRecordVector@I@@@Z proc near
.text:00000484
.text:00000484 var_70          = dword ptr -70h
.text:00000484 var_6C          = dword ptr -6Ch
.text:00000484 var_68          = dword ptr -68h
.text:00000484 var_64          = dword ptr -64h
.text:00000484 var_60          = dword ptr -60h
.text:00000484 var_55          = byte ptr -55h
.text:00000484 var_50          = dword ptr -50h
.text:00000484 var_4C          = dword ptr -4Ch
.text:00000484 var_41          = dword ptr -41h
.text:00000484 var_38          = qword ptr -38h
.text:00000484 var_30          = dword ptr -30h
.text:00000484 var_2C          = dword ptr -2Ch
.text:00000484 var_24          = dword ptr -24h
.text:00000484 var_20          = dword ptr -20h
.text:00000484 var_18          = dword ptr -18h
.text:00000484 var_10          = dword ptr -10h
.text:00000484 var_C           = dword ptr -0Ch
.text:00000484 var_8           = dword ptr -8
.text:00000484 var_4           = dword ptr -4
.text:00000484 arg_0           = dword ptr  8
.text:00000484
.text:00000484                 push    ebp
.text:00000485                 mov     ebp, esp
.text:00000487                 sub     esp, 70h
.text:0000048A                 push    esi
.text:0000048B                 push    edi
.text:0000048C                 push    ecx
.text:0000048D                 lea     edi, [ebp+var_70]
.text:00000490                 mov     ecx, 1Ch
.text:00000495                 mov     eax, 0CCCCCCCCh
.text:0000049A                 rep stosd
.text:0000049C                 pop     ecx
.text:0000049D                 mov     eax, dword ptr ds:___security_cookie
.text:000004A2                 xor     eax, ebp
.text:000004A4                 mov     [ebp+var_4], eax
.text:000004A7                 mov     [ebp+var_8], ecx
.text:000004AA                 mov     ecx, [ebp+var_8]
.text:000004AD                 add     ecx, 190h       ; this
.text:000004B3                 call    ?Clear@CHardLinks@@QAEXXZ ; CHardLinks::Clear(void)
.text:000004B8                 mov     eax, [ebp+var_8]
.text:000004BB                 mov     ecx, [eax+14h]
.text:000004BE                 movzx   edx, byte ptr [ecx+0DEh]
.text:000004C5                 test    edx, edx
.text:000004C7                 jnz     short loc_4D0
.text:000004C9                 xor     eax, eax
.text:000004CB                 jmp     loc_6D1
.text:000004D0 ; ---------------------------------------------------------------------------
.text:000004D0
.text:000004D0 loc_4D0:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+43j
.text:000004D0                 mov     eax, [ebp+var_8]
.text:000004D3                 mov     ecx, [eax+14h]
.text:000004D6                 call    ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ ; CMyComPtr<IInArchive>::operator IInArchive *(void)
.text:000004DB                 mov     [ebp+var_C], eax
.text:000004DE                 mov     ecx, [ebp+var_8]
.text:000004E1                 add     ecx, 190h
.text:000004E7                 mov     [ebp+var_10], ecx
.text:000004EA                 cmp     [ebp+arg_0], 0
.text:000004EE                 jz      short loc_4FD
.text:000004F0                 mov     ecx, [ebp+arg_0]
.text:000004F3                 call    ?Size@?$CRecordVector@I@@QBEIXZ ; CRecordVector<uint>::Size(void)
.text:000004F8                 mov     [ebp+var_18], eax
.text:000004FB                 jmp     short loc_529
.text:000004FD ; ---------------------------------------------------------------------------
.text:000004FD
.text:000004FD loc_4FD:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+6Aj
.text:000004FD                 mov     esi, esp
.text:000004FF                 lea     edx, [ebp+var_18]
.text:00000502                 push    edx
.text:00000503                 mov     eax, [ebp+var_C]
.text:00000506                 mov     ecx, [eax]
.text:00000508                 mov     edx, [ebp+var_C]
.text:0000050B                 push    edx
.text:0000050C                 mov     eax, [ecx+14h]
.text:0000050F                 call    eax
.text:00000511                 cmp     esi, esp
.text:00000513                 call    __RTC_CheckEsp
.text:00000518                 mov     [ebp+var_20], eax
.text:0000051B                 cmp     [ebp+var_20], 0
.text:0000051F                 jz      short loc_529
.text:00000521                 mov     eax, [ebp+var_20]
.text:00000524                 jmp     loc_6D1
.text:00000529 ; ---------------------------------------------------------------------------
.text:00000529
.text:00000529 loc_529:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+77j
.text:00000529                                         ; CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+9Bj
.text:00000529                 mov     [ebp+var_24], 0
.text:00000530                 jmp     short loc_53B
.text:00000532 ; ---------------------------------------------------------------------------
.text:00000532
.text:00000532 loc_532:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *):loc_5ECj
.text:00000532                 mov     ecx, [ebp+var_24]
.text:00000535                 add     ecx, 1
.text:00000538                 mov     [ebp+var_24], ecx
.text:0000053B
.text:0000053B loc_53B:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+ACj
.text:0000053B                 mov     edx, [ebp+var_24]
.text:0000053E                 cmp     edx, [ebp+var_18]
.text:00000541                 jnb     loc_5F1
.text:00000547                 cmp     [ebp+arg_0], 0
.text:0000054B                 jz      short loc_560
.text:0000054D                 mov     eax, [ebp+var_24]
.text:00000550                 push    eax
.text:00000551                 mov     ecx, [ebp+arg_0]
.text:00000554                 call    ??A?$CRecordVector@I@@QBEABII@Z ; CRecordVector<uint>::operator[](uint)
.text:00000559                 mov     ecx, [eax]
.text:0000055B                 mov     [ebp+var_70], ecx
.text:0000055E                 jmp     short loc_566
.text:00000560 ; ---------------------------------------------------------------------------
.text:00000560
.text:00000560 loc_560:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+C7j
.text:00000560                 mov     edx, [ebp+var_24]
.text:00000563                 mov     [ebp+var_70], edx
.text:00000566
.text:00000566 loc_566:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+DAj
.text:00000566                 mov     eax, [ebp+var_70]
.text:00000569                 mov     [ebp+var_4C], eax
.text:0000056C                 lea     ecx, [ebp+var_41]
.text:0000056F                 push    ecx             ; int
.text:00000570                 lea     edx, [ebp+var_38]
.text:00000573                 push    edx             ; unsigned __int64 *
.text:00000574                 mov     eax, [ebp+var_4C]
.text:00000577                 push    eax             ; int
.text:00000578                 mov     ecx, [ebp+var_C]
.text:0000057B                 push    ecx             ; int
.text:0000057C                 call    ?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z ; Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)
.text:00000581                 mov     [ebp+var_50], eax
.text:00000584                 cmp     [ebp+var_50], 0
.text:00000588                 jz      short loc_592
.text:0000058A                 mov     eax, [ebp+var_50]
.text:0000058D                 jmp     loc_6D1
.text:00000592 ; ---------------------------------------------------------------------------
.text:00000592
.text:00000592 loc_592:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+104j
.text:00000592                 movzx   edx, byte ptr [ebp+var_41]
.text:00000596                 test    edx, edx
.text:00000598                 jz      short loc_5EC
.text:0000059A                 mov     [ebp+var_55], 0
.text:0000059E                 lea     eax, [ebp+var_55]
.text:000005A1                 push    eax             ; bool *
.text:000005A2                 mov     ecx, [ebp+var_4C]
.text:000005A5                 push    ecx             ; unsigned int
.text:000005A6                 mov     edx, [ebp+var_C]
.text:000005A9                 push    edx             ; struct IInArchive *
.text:000005AA                 call    ?Archive_IsItem_AltStream@@YGJPAUIInArchive@@IAA_N@Z ; Archive_IsItem_AltStream(IInArchive *,uint,bool &)
.text:000005AF                 mov     [ebp+var_60], eax
.text:000005B2                 cmp     [ebp+var_60], 0
.text:000005B6                 jz      short loc_5C0
.text:000005B8                 mov     eax, [ebp+var_60]
.text:000005BB                 jmp     loc_6D1
.text:000005C0 ; ---------------------------------------------------------------------------
.text:000005C0
.text:000005C0 loc_5C0:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+132j
.text:000005C0                 movzx   eax, [ebp+var_55]
.text:000005C4                 test    eax, eax
.text:000005C6                 jnz     short loc_5EC
.text:000005C8                 sub     esp, 10h
.text:000005CB                 mov     ecx, esp
.text:000005CD                 mov     edx, dword ptr [ebp+var_38]
.text:000005D0                 mov     [ecx], edx
.text:000005D2                 mov     eax, dword ptr [ebp+var_38+4]
.text:000005D5                 mov     [ecx+4], eax
.text:000005D8                 mov     edx, [ebp+var_30]
.text:000005DB                 mov     [ecx+8], edx
.text:000005DE                 mov     eax, [ebp+var_2C]
.text:000005E1                 mov     [ecx+0Ch], eax
.text:000005E4                 mov     ecx, [ebp+var_10]
.text:000005E7                 call    ?Add@?$CRecordVector@UCHardLinkNode@@@@QAEIUCHardLinkNode@@@Z ; CRecordVector<CHardLinkNode>::Add(CHardLinkNode)
.text:000005EC
.text:000005EC loc_5EC:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+114j
.text:000005EC                                         ; CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+142j
.text:000005EC                 jmp     loc_532
.text:000005F1 ; ---------------------------------------------------------------------------
.text:000005F1
.text:000005F1 loc_5F1:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+BDj
.text:000005F1                 mov     ecx, [ebp+var_10]
.text:000005F4                 call    ?Sort2@?$CRecordVector@UCHardLinkNode@@@@QAEXXZ ; CRecordVector<CHardLinkNode>::Sort2(void)
.text:000005F9                 mov     [ebp+var_64], 0
.text:00000600                 mov     [ebp+var_68], 1
.text:00000607                 mov     [ebp+var_6C], 1
.text:0000060E                 jmp     short loc_619
.text:00000610 ; ---------------------------------------------------------------------------
.text:00000610
.text:00000610 loc_610:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *):loc_6B0j
.text:00000610                 mov     ecx, [ebp+var_6C]
.text:00000613                 add     ecx, 1
.text:00000616                 mov     [ebp+var_6C], ecx
.text:00000619
.text:00000619 loc_619:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+18Aj
.text:00000619                 mov     ecx, [ebp+var_10]
.text:0000061C                 call    ?Size@?$CRecordVector@UCHardLinkNode@@@@QBEIXZ ; CRecordVector<CHardLinkNode>::Size(void)
.text:00000621                 cmp     [ebp+var_6C], eax
.text:00000624                 jnb     loc_6B5
.text:0000062A                 mov     edx, [ebp+var_6C]
.text:0000062D                 sub     edx, 1
.text:00000630                 push    edx
.text:00000631                 mov     ecx, [ebp+var_10]
.text:00000634                 call    ??A?$CRecordVector@UCHardLinkNode@@@@QAEAAUCHardLinkNode@@I@Z ; CRecordVector<CHardLinkNode>::operator[](uint)
.text:00000639                 push    eax             ; struct CHardLinkNode *
.text:0000063A                 mov     eax, [ebp+var_6C]
.text:0000063D                 push    eax
.text:0000063E                 mov     ecx, [ebp+var_10]
.text:00000641                 call    ??A?$CRecordVector@UCHardLinkNode@@@@QAEAAUCHardLinkNode@@I@Z ; CRecordVector<CHardLinkNode>::operator[](uint)
.text:00000646                 mov     ecx, eax        ; this
.text:00000648                 call    ?Compare@CHardLinkNode@@QBEHABU1@@Z ; CHardLinkNode::Compare(CHardLinkNode const &)
.text:0000064D                 test    eax, eax
.text:0000064F                 jz      short loc_65A
.text:00000651                 mov     [ebp+var_68], 1
.text:00000658                 jmp     short loc_6B0
.text:0000065A ; ---------------------------------------------------------------------------
.text:0000065A
.text:0000065A loc_65A:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+1CBj
.text:0000065A                 mov     ecx, [ebp+var_68]
.text:0000065D                 add     ecx, 1
.text:00000660                 mov     [ebp+var_68], ecx
.text:00000663                 cmp     [ebp+var_68], 2
.text:00000667                 jnz     short loc_6B0
.text:00000669                 mov     edx, [ebp+var_6C]
.text:0000066C                 sub     edx, 1
.text:0000066F                 cmp     edx, [ebp+var_64]
.text:00000672                 jz      short loc_6A7
.text:00000674                 mov     eax, [ebp+var_6C]
.text:00000677                 sub     eax, 1
.text:0000067A                 push    eax
.text:0000067B                 mov     ecx, [ebp+var_10]
.text:0000067E                 call    ??A?$CRecordVector@UCHardLinkNode@@@@QAEAAUCHardLinkNode@@I@Z ; CRecordVector<CHardLinkNode>::operator[](uint)
.text:00000683                 mov     esi, eax
.text:00000685                 mov     ecx, [ebp+var_64]
.text:00000688                 push    ecx
.text:00000689                 mov     ecx, [ebp+var_10]
.text:0000068C                 call    ??A?$CRecordVector@UCHardLinkNode@@@@QAEAAUCHardLinkNode@@I@Z ; CRecordVector<CHardLinkNode>::operator[](uint)
.text:00000691                 mov     edx, [esi]
.text:00000693                 mov     [eax], edx
.text:00000695                 mov     ecx, [esi+4]
.text:00000698                 mov     [eax+4], ecx
.text:0000069B                 mov     edx, [esi+8]
.text:0000069E                 mov     [eax+8], edx
.text:000006A1                 mov     ecx, [esi+0Ch]
.text:000006A4                 mov     [eax+0Ch], ecx
.text:000006A7
.text:000006A7 loc_6A7:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+1EEj
.text:000006A7                 mov     edx, [ebp+var_64]
.text:000006AA                 add     edx, 1
.text:000006AD                 mov     [ebp+var_64], edx
.text:000006B0
.text:000006B0 loc_6B0:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+1D4j
.text:000006B0                                         ; CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+1E3j
.text:000006B0                 jmp     loc_610
.text:000006B5 ; ---------------------------------------------------------------------------
.text:000006B5
.text:000006B5 loc_6B5:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+1A0j
.text:000006B5                 mov     eax, [ebp+var_64]
.text:000006B8                 push    eax
.text:000006B9                 mov     ecx, [ebp+var_10]
.text:000006BC                 call    ?DeleteFrom@?$CRecordVector@UCHardLinkNode@@@@QAEXI@Z ; CRecordVector<CHardLinkNode>::DeleteFrom(uint)
.text:000006C1                 mov     ecx, [ebp+var_8]
.text:000006C4                 add     ecx, 190h       ; this
.text:000006CA                 call    ?PrepareLinks@CHardLinks@@QAEXXZ ; CHardLinks::PrepareLinks(void)
.text:000006CF                 xor     eax, eax
.text:000006D1
.text:000006D1 loc_6D1:                                ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+47j
.text:000006D1                                         ; CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+A0j ...
.text:000006D1                 push    edx
.text:000006D2                 mov     ecx, ebp
.text:000006D4                 push    eax
.text:000006D5                 lea     edx, $LN28
.text:000006DB                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000006E0                 pop     eax
.text:000006E1                 pop     edx
.text:000006E2                 pop     edi
.text:000006E3                 pop     esi
.text:000006E4                 mov     ecx, [ebp+var_4]
.text:000006E7                 xor     ecx, ebp
.text:000006E9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:000006EE                 add     esp, 70h
.text:000006F1                 cmp     ebp, esp
.text:000006F3                 call    __RTC_CheckEsp
.text:000006F8                 mov     esp, ebp
.text:000006FA                 pop     ebp
.text:000006FB                 retn    4
.text:000006FB ?PrepareHardLinks@CArchiveExtractCallback@@QAEJPBV?$CRecordVector@I@@@Z endp
.text:000006FB
.text:000006FB ; ---------------------------------------------------------------------------
.text:000006FE                 align 10h
.text:00000700 $LN28           dd 4                    ; DATA XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+251o
.text:00000704                 dd offset $LN27
.text:00000708 $LN27           dd 0FFFFFFE8h, 4        ; DATA XREF: .text:00000704o
.text:00000710                 dd offset $LN23         ; "numItems"
.text:00000714                 dd 0FFFFFFC8h, 10h
.text:0000071C                 dd offset $LN24         ; "h"
.text:00000720                 dd 0FFFFFFBFh, 1
.text:00000728                 dd offset $LN25         ; "defined"
.text:0000072C                 dd 0FFFFFFABh, 1
.text:00000734                 dd offset $LN26         ; "isAltStream"
.text:00000738 $LN26           db 'isAltStream',0      ; DATA XREF: .text:00000734o
.text:00000744 $LN25           db 'defined',0          ; DATA XREF: .text:00000728o
.text:0000074C $LN24           db 'h',0                ; DATA XREF: .text:0000071Co
.text:0000074E $LN23           db 'numItems',0         ; DATA XREF: .text:00000710o
.text:00000757                 db 0Dh dup(0CCh)
.text:00000764
.text:00000764 ; =============== S U B R O U T I N E =======================================
.text:00000764
.text:00000764 ; Attributes: bp-based frame
.text:00000764
.text:00000764 ; int __stdcall Archive_Get_HardLinkNode(int, int, unsigned __int64 *, int)
.text:00000764 ?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z proc near
.text:00000764                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+F8p
.text:00000764                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2C7Ep
.text:00000764
.text:00000764 var_50          = dword ptr -50h
.text:00000764 var_4C          = dword ptr -4Ch
.text:00000764 var_48          = dword ptr -48h
.text:00000764 var_44          = dword ptr -44h
.text:00000764 var_3C          = tagPROPVARIANT ptr -3Ch
.text:00000764 var_28          = dword ptr -28h
.text:00000764 var_20          = tagPROPVARIANT ptr -20h
.text:00000764 var_C           = dword ptr -0Ch
.text:00000764 var_4           = dword ptr -4
.text:00000764 arg_0           = dword ptr  8
.text:00000764 arg_4           = dword ptr  0Ch
.text:00000764 arg_8           = dword ptr  10h
.text:00000764 arg_C           = dword ptr  14h
.text:00000764
.text:00000764                 push    ebp
.text:00000765                 mov     ebp, esp
.text:00000767                 push    0FFFFFFFFh
.text:00000769                 push    offset __ehhandler$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z
.text:0000076E                 mov     eax, large fs:0
.text:00000774                 push    eax
.text:00000775                 sub     esp, 44h
.text:00000778                 push    esi
.text:00000779                 push    edi
.text:0000077A                 lea     edi, [ebp+var_50]
.text:0000077D                 mov     ecx, 11h
.text:00000782                 mov     eax, 0CCCCCCCCh
.text:00000787                 rep stosd
.text:00000789                 mov     eax, dword ptr ds:___security_cookie
.text:0000078E                 xor     eax, ebp
.text:00000790                 push    eax
.text:00000791                 lea     eax, [ebp+var_C]
.text:00000794                 mov     large fs:0, eax
.text:0000079A                 mov     eax, [ebp+arg_8]
.text:0000079D                 mov     dword ptr [eax+8], 0
.text:000007A4                 mov     dword ptr [eax+0Ch], 0
.text:000007AB                 mov     ecx, [ebp+arg_8]
.text:000007AE                 mov     dword ptr [ecx], 0FFFFFFFFh
.text:000007B4                 mov     dword ptr [ecx+4], 0FFFFFFFFh
.text:000007BB                 mov     edx, [ebp+arg_C]
.text:000007BE                 mov     byte ptr [edx], 0
.text:000007C1                 lea     ecx, [ebp+var_20] ; this
.text:000007C4                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:000007C9                 mov     [ebp+var_4], 0
.text:000007D0                 mov     esi, esp
.text:000007D2                 lea     eax, [ebp+var_20]
.text:000007D5                 push    eax
.text:000007D6                 push    5Bh ; '['
.text:000007D8                 mov     ecx, [ebp+arg_4]
.text:000007DB                 push    ecx
.text:000007DC                 mov     edx, [ebp+arg_0]
.text:000007DF                 mov     eax, [edx]
.text:000007E1                 mov     ecx, [ebp+arg_0]
.text:000007E4                 push    ecx
.text:000007E5                 mov     edx, [eax+18h]
.text:000007E8                 call    edx
.text:000007EA                 cmp     esi, esp
.text:000007EC                 call    __RTC_CheckEsp
.text:000007F1                 mov     [ebp+var_28], eax
.text:000007F4                 cmp     [ebp+var_28], 0
.text:000007F8                 jz      short loc_817
.text:000007FA                 mov     eax, [ebp+var_28]
.text:000007FD                 mov     [ebp+var_48], eax
.text:00000800                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000807                 lea     ecx, [ebp+var_20] ; this
.text:0000080A                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000080F                 mov     eax, [ebp+var_48]
.text:00000812                 jmp     loc_8D2
.text:00000817 ; ---------------------------------------------------------------------------
.text:00000817
.text:00000817 loc_817:                                ; CODE XREF: Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+94j
.text:00000817                 mov     ecx, [ebp+arg_8]
.text:0000081A                 add     ecx, 8
.text:0000081D                 push    ecx             ; unsigned __int64 *
.text:0000081E                 lea     edx, [ebp+var_20]
.text:00000821                 push    edx             ; struct tagPROPVARIANT *
.text:00000822                 call    ?ConvertPropVariantToUInt64@@YG_NABUtagPROPVARIANT@@AA_K@Z ; ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)
.text:00000827                 movzx   eax, al
.text:0000082A                 test    eax, eax
.text:0000082C                 jnz     short loc_84C
.text:0000082E                 mov     [ebp+var_4C], 0
.text:00000835                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000083C                 lea     ecx, [ebp+var_20] ; this
.text:0000083F                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000844                 mov     eax, [ebp+var_4C]
.text:00000847                 jmp     loc_8D2
.text:0000084C ; ---------------------------------------------------------------------------
.text:0000084C
.text:0000084C loc_84C:                                ; CODE XREF: Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+C8j
.text:0000084C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000853                 lea     ecx, [ebp+var_20] ; this
.text:00000856                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000085B                 lea     ecx, [ebp+var_3C] ; this
.text:0000085E                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00000863                 mov     [ebp+var_4], 1
.text:0000086A                 mov     esi, esp
.text:0000086C                 lea     ecx, [ebp+var_3C]
.text:0000086F                 push    ecx
.text:00000870                 push    5Ch ; '\'
.text:00000872                 mov     edx, [ebp+arg_4]
.text:00000875                 push    edx
.text:00000876                 mov     eax, [ebp+arg_0]
.text:00000879                 mov     ecx, [eax]
.text:0000087B                 mov     edx, [ebp+arg_0]
.text:0000087E                 push    edx
.text:0000087F                 mov     eax, [ecx+18h]
.text:00000882                 call    eax
.text:00000884                 cmp     esi, esp
.text:00000886                 call    __RTC_CheckEsp
.text:0000088B                 mov     [ebp+var_44], eax
.text:0000088E                 cmp     [ebp+var_44], 0
.text:00000892                 jz      short loc_8AE
.text:00000894                 mov     ecx, [ebp+var_44]
.text:00000897                 mov     [ebp+var_50], ecx
.text:0000089A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000008A1                 lea     ecx, [ebp+var_3C] ; this
.text:000008A4                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000008A9                 mov     eax, [ebp+var_50]
.text:000008AC                 jmp     short loc_8D2
.text:000008AE ; ---------------------------------------------------------------------------
.text:000008AE
.text:000008AE loc_8AE:                                ; CODE XREF: Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+12Ej
.text:000008AE                 mov     edx, [ebp+arg_8]
.text:000008B1                 push    edx             ; unsigned __int64 *
.text:000008B2                 lea     eax, [ebp+var_3C]
.text:000008B5                 push    eax             ; struct tagPROPVARIANT *
.text:000008B6                 call    ?ConvertPropVariantToUInt64@@YG_NABUtagPROPVARIANT@@AA_K@Z ; ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)
.text:000008BB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000008C2                 lea     ecx, [ebp+var_3C] ; this
.text:000008C5                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000008CA                 mov     ecx, [ebp+arg_C]
.text:000008CD                 mov     byte ptr [ecx], 1
.text:000008D0                 xor     eax, eax
.text:000008D2
.text:000008D2 loc_8D2:                                ; CODE XREF: Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+AEj
.text:000008D2                                         ; Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+E3j ...
.text:000008D2                 push    edx
.text:000008D3                 mov     ecx, ebp
.text:000008D5                 push    eax
.text:000008D6                 lea     edx, $LN12
.text:000008DC                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000008E1                 pop     eax
.text:000008E2                 pop     edx
.text:000008E3                 mov     ecx, [ebp+var_C]
.text:000008E6                 mov     large fs:0, ecx
.text:000008ED                 pop     ecx
.text:000008EE                 pop     edi
.text:000008EF                 pop     esi
.text:000008F0                 add     esp, 50h
.text:000008F3                 cmp     ebp, esp
.text:000008F5                 call    __RTC_CheckEsp
.text:000008FA                 mov     esp, ebp
.text:000008FC                 pop     ebp
.text:000008FD                 retn    10h
.text:000008FD ?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z endp
.text:000008FD
.text:000008FD ; ---------------------------------------------------------------------------
.text:00000900 $LN12           dd 2                    ; DATA XREF: Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+172o
.text:00000904                 dd offset $LN11_0
.text:00000908 $LN11_0         dd 0FFFFFFE0h, 10h      ; DATA XREF: .text:00000904o
.text:00000910                 dd offset $LN8_0        ; "prop"
.text:00000914                 dd 0FFFFFFC4h, 10h
.text:0000091C                 dd offset $LN9          ; "prop"
.text:00000920 $LN9            db 'prop',0             ; DATA XREF: .text:0000091Co
.text:00000925 $LN8_0          db 'prop',0             ; DATA XREF: .text:00000910o
.text:0000092A                 db 0Ah dup(0CCh)
.text:00000934
.text:00000934 ; =============== S U B R O U T I N E =======================================
.text:00000934
.text:00000934 ; Attributes: bp-based frame
.text:00000934
.text:00000934 ; public: __thiscall CArchiveExtractCallback::CArchiveExtractCallback(void)
.text:00000934                 public ??0CArchiveExtractCallback@@QAE@XZ
.text:00000934 ??0CArchiveExtractCallback@@QAE@XZ proc near
.text:00000934
.text:00000934 var_1C          = dword ptr -1Ch
.text:00000934 var_18          = dword ptr -18h
.text:00000934 var_14          = dword ptr -14h
.text:00000934 var_10          = dword ptr -10h
.text:00000934 var_C           = dword ptr -0Ch
.text:00000934 var_4           = dword ptr -4
.text:00000934
.text:00000934                 push    ebp
.text:00000935                 mov     ebp, esp
.text:00000937                 push    0FFFFFFFFh
.text:00000939                 push    offset __ehhandler$??0CArchiveExtractCallback@@QAE@XZ
.text:0000093E                 mov     eax, large fs:0
.text:00000944                 push    eax
.text:00000945                 sub     esp, 10h
.text:00000948                 mov     eax, 0CCCCCCCCh
.text:0000094D                 mov     [ebp+var_1C], eax
.text:00000950                 mov     [ebp+var_18], eax
.text:00000953                 mov     [ebp+var_14], eax
.text:00000956                 mov     [ebp+var_10], eax
.text:00000959                 mov     eax, dword ptr ds:___security_cookie
.text:0000095E                 xor     eax, ebp
.text:00000960                 push    eax
.text:00000961                 lea     eax, [ebp+var_C]
.text:00000964                 mov     large fs:0, eax
.text:0000096A                 mov     [ebp+var_10], ecx
.text:0000096D                 mov     ecx, [ebp+var_10] ; this
.text:00000970                 call    ??0IArchiveExtractCallback@@QAE@XZ ; IArchiveExtractCallback::IArchiveExtractCallback(void)
.text:00000975                 mov     ecx, [ebp+var_10]
.text:00000978                 add     ecx, 4          ; this
.text:0000097B                 call    ??0IArchiveExtractCallbackMessage@@QAE@XZ ; IArchiveExtractCallbackMessage::IArchiveExtractCallbackMessage(void)
.text:00000980                 mov     ecx, [ebp+var_10]
.text:00000983                 add     ecx, 8          ; this
.text:00000986                 call    ??0ICryptoGetTextPassword@@QAE@XZ ; ICryptoGetTextPassword::ICryptoGetTextPassword(void)
.text:0000098B                 mov     ecx, [ebp+var_10]
.text:0000098E                 add     ecx, 0Ch        ; this
.text:00000991                 call    ??0ICompressProgressInfo@@QAE@XZ ; ICompressProgressInfo::ICompressProgressInfo(void)
.text:00000996                 mov     ecx, [ebp+var_10]
.text:00000999                 add     ecx, 10h        ; this
.text:0000099C                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:000009A1                 mov     eax, [ebp+var_10]
.text:000009A4                 mov     dword ptr [eax], offset ??_7CArchiveExtractCallback@@6BIArchiveExtractCallback@@@ ; const CArchiveExtractCallback::`vftable'{for `IArchiveExtractCallback'}
.text:000009AA                 mov     ecx, [ebp+var_10]
.text:000009AD                 mov     dword ptr [ecx+4], offset ??_7CArchiveExtractCallback@@6BIArchiveExtractCallbackMessage@@@ ; const CArchiveExtractCallback::`vftable'{for `IArchiveExtractCallbackMessage'}
.text:000009B4                 mov     edx, [ebp+var_10]
.text:000009B7                 mov     dword ptr [edx+8], offset ??_7CArchiveExtractCallback@@6BICryptoGetTextPassword@@@ ; const CArchiveExtractCallback::`vftable'{for `ICryptoGetTextPassword'}
.text:000009BE                 mov     eax, [ebp+var_10]
.text:000009C1                 mov     dword ptr [eax+0Ch], offset ??_7CArchiveExtractCallback@@6BICompressProgressInfo@@@ ; const CArchiveExtractCallback::`vftable'{for `ICompressProgressInfo'}
.text:000009C8                 mov     ecx, [ebp+var_10]
.text:000009CB                 add     ecx, 18h        ; this
.text:000009CE                 call    ??0CExtractNtOptions@@QAE@XZ ; CExtractNtOptions::CExtractNtOptions(void)
.text:000009D3                 mov     ecx, [ebp+var_10]
.text:000009D6                 add     ecx, 28h ; '('
.text:000009D9                 call    ??0?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::CMyComPtr<IFolderArchiveExtractCallback>(void)
.text:000009DE                 mov     [ebp+var_4], 0
.text:000009E5                 mov     ecx, [ebp+var_10]
.text:000009E8                 add     ecx, 2Ch ; ','
.text:000009EB                 call    ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::CMyComPtr<ICompressProgressInfo>(void)
.text:000009F0                 mov     byte ptr [ebp+var_4], 1
.text:000009F4                 mov     ecx, [ebp+var_10]
.text:000009F7                 add     ecx, 30h ; '0'
.text:000009FA                 call    ??0?$CMyComPtr@UICryptoGetTextPassword@@@@QAE@XZ ; CMyComPtr<ICryptoGetTextPassword>::CMyComPtr<ICryptoGetTextPassword>(void)
.text:000009FF                 mov     byte ptr [ebp+var_4], 2
.text:00000A03                 mov     ecx, [ebp+var_10]
.text:00000A06                 add     ecx, 34h ; '4'
.text:00000A09                 call    ??0?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallbackMessage>::CMyComPtr<IArchiveExtractCallbackMessage>(void)
.text:00000A0E                 mov     byte ptr [ebp+var_4], 3
.text:00000A12                 mov     ecx, [ebp+var_10]
.text:00000A15                 add     ecx, 38h ; '8'
.text:00000A18                 call    ??0?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAE@XZ ; CMyComPtr<IFolderArchiveExtractCallback2>::CMyComPtr<IFolderArchiveExtractCallback2>(void)
.text:00000A1D                 mov     byte ptr [ebp+var_4], 4
.text:00000A21                 mov     ecx, [ebp+var_10]
.text:00000A24                 add     ecx, 3Ch ; '<'
.text:00000A27                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000A2C                 mov     byte ptr [ebp+var_4], 5
.text:00000A30                 mov     ecx, [ebp+var_10]
.text:00000A33                 add     ecx, 48h ; 'H'
.text:00000A36                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000A3B                 mov     byte ptr [ebp+var_4], 6
.text:00000A3F                 mov     ecx, [ebp+var_10]
.text:00000A42                 add     ecx, 5Ch ; '\'
.text:00000A45                 call    ??0?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAE@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::CMyComPtr<IFolderExtractToStreamCallback>(void)
.text:00000A4A                 mov     byte ptr [ebp+var_4], 7
.text:00000A4E                 mov     ecx, [ebp+var_10]
.text:00000A51                 add     ecx, 64h ; 'd'
.text:00000A54                 call    ??0?$CMyComPtr@UIGetProp@@@@QAE@XZ ; CMyComPtr<IGetProp>::CMyComPtr<IGetProp>(void)
.text:00000A59                 mov     byte ptr [ebp+var_4], 8
.text:00000A5D                 mov     ecx, [ebp+var_10]
.text:00000A60                 add     ecx, 68h ; 'h'  ; this
.text:00000A63                 call    ??0CReadArcItem@@QAE@XZ ; CReadArcItem::CReadArcItem(void)
.text:00000A68                 mov     byte ptr [ebp+var_4], 9
.text:00000A6C                 mov     ecx, [ebp+var_10]
.text:00000A6F                 add     ecx, 0A8h ; '¿'
.text:00000A75                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000A7A                 mov     byte ptr [ebp+var_4], 0Ah
.text:00000A7E                 mov     ecx, [ebp+var_10]
.text:00000A81                 mov     byte ptr [ecx+0C2h], 1
.text:00000A88                 mov     edx, [ebp+var_10]
.text:00000A8B                 mov     byte ptr [edx+0C3h], 1
.text:00000A92                 mov     eax, [ebp+var_10]
.text:00000A95                 mov     byte ptr [eax+0C4h], 1
.text:00000A9C                 mov     ecx, [ebp+var_10]
.text:00000A9F                 add     ecx, 100h
.text:00000AA5                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(void)
.text:00000AAA                 mov     byte ptr [ebp+var_4], 0Bh
.text:00000AAE                 mov     ecx, [ebp+var_10]
.text:00000AB1                 add     ecx, 108h
.text:00000AB7                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(void)
.text:00000ABC                 mov     byte ptr [ebp+var_4], 0Ch
.text:00000AC0                 mov     ecx, [ebp+var_10]
.text:00000AC3                 add     ecx, 110h
.text:00000AC9                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00000ACE                 mov     byte ptr [ebp+var_4], 0Dh
.text:00000AD2                 mov     ecx, [ebp+var_10]
.text:00000AD5                 mov     byte ptr [ecx+126h], 0
.text:00000ADC                 mov     ecx, [ebp+var_10]
.text:00000ADF                 add     ecx, 128h
.text:00000AE5                 call    ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::CMyComPtr<ICompressProgressInfo>(void)
.text:00000AEA                 mov     byte ptr [ebp+var_4], 0Eh
.text:00000AEE                 mov     ecx, [ebp+var_10]
.text:00000AF1                 add     ecx, 144h
.text:00000AF7                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00000AFC                 mov     byte ptr [ebp+var_4], 0Fh
.text:00000B00                 mov     ecx, [ebp+var_10]
.text:00000B03                 add     ecx, 150h
.text:00000B09                 call    ??0?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::CRecordVector<uint>(void)
.text:00000B0E                 mov     byte ptr [ebp+var_4], 10h
.text:00000B12                 mov     ecx, [ebp+var_10]
.text:00000B15                 add     ecx, 190h       ; this
.text:00000B1B                 call    ??0CHardLinks@@QAE@XZ ; CHardLinks::CHardLinks(void)
.text:00000B20                 mov     byte ptr [ebp+var_4], 11h
.text:00000B24                 mov     ecx, [ebp+var_10]
.text:00000B27                 add     ecx, 1A8h
.text:00000B2D                 call    ??0?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ ; CObjectVector<CIndexToPathPair>::CObjectVector<CIndexToPathPair>(void)
.text:00000B32                 mov     byte ptr [ebp+var_4], 12h
.text:00000B36                 push    38h ; '8'       ; unsigned int
.text:00000B38                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000B3D                 add     esp, 4
.text:00000B40                 mov     [ebp+var_18], eax
.text:00000B43                 mov     byte ptr [ebp+var_4], 13h
.text:00000B47                 cmp     [ebp+var_18], 0
.text:00000B4B                 jz      short loc_B5A
.text:00000B4D                 mov     ecx, [ebp+var_18] ; this
.text:00000B50                 call    ??0CLocalProgress@@QAE@XZ ; CLocalProgress::CLocalProgress(void)
.text:00000B55                 mov     [ebp+var_1C], eax
.text:00000B58                 jmp     short loc_B61
.text:00000B5A ; ---------------------------------------------------------------------------
.text:00000B5A
.text:00000B5A loc_B5A:                                ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+217j
.text:00000B5A                 mov     [ebp+var_1C], 0
.text:00000B61
.text:00000B61 loc_B61:                                ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+224j
.text:00000B61                 mov     edx, [ebp+var_1C]
.text:00000B64                 mov     [ebp+var_14], edx
.text:00000B67                 mov     byte ptr [ebp+var_4], 12h
.text:00000B6B                 mov     eax, [ebp+var_10]
.text:00000B6E                 mov     ecx, [ebp+var_14]
.text:00000B71                 mov     [eax+160h], ecx
.text:00000B77                 mov     edx, [ebp+var_10]
.text:00000B7A                 mov     eax, [edx+160h]
.text:00000B80                 push    eax
.text:00000B81                 mov     ecx, [ebp+var_10]
.text:00000B84                 add     ecx, 128h
.text:00000B8A                 call    ??4?$CMyComPtr@UICompressProgressInfo@@@@QAEPAUICompressProgressInfo@@PAU1@@Z ; CMyComPtr<ICompressProgressInfo>::operator=(ICompressProgressInfo *)
.text:00000B8F                 call    ?InitLocalPrivileges@@YG_NXZ ; InitLocalPrivileges(void)
.text:00000B94                 mov     ecx, [ebp+var_10]
.text:00000B97                 mov     [ecx+15Ch], al
.text:00000B9D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000BA4                 mov     eax, [ebp+var_10]
.text:00000BA7                 mov     ecx, [ebp+var_C]
.text:00000BAA                 mov     large fs:0, ecx
.text:00000BB1                 pop     ecx
.text:00000BB2                 add     esp, 1Ch
.text:00000BB5                 cmp     ebp, esp
.text:00000BB7                 call    __RTC_CheckEsp
.text:00000BBC                 mov     esp, ebp
.text:00000BBE                 pop     ebp
.text:00000BBF                 retn
.text:00000BBF ??0CArchiveExtractCallback@@QAE@XZ endp
.text:00000BBF
.text:00000BBF ; ---------------------------------------------------------------------------
.text:00000BC0                 db 4 dup(0CCh)
.text:00000BC4
.text:00000BC4 ; =============== S U B R O U T I N E =======================================
.text:00000BC4
.text:00000BC4 ; Attributes: bp-based frame
.text:00000BC4
.text:00000BC4 ; public: void __thiscall CArchiveExtractCallback::Init(struct CExtractNtOptions const &, class NWildcard::CCensorNode const *, class CArc const *, struct IFolderArchiveExtractCallback *, bool, bool, class UString const &, class CObjectVector<class UString> const &, bool, unsigned __int64)
.text:00000BC4                 public ?Init@CArchiveExtractCallback@@QAEXABUCExtractNtOptions@@PBVCCensorNode@NWildcard@@PBVCArc@@PAUIFolderArchiveExtractCallback@@_N4ABVUString@@ABV?$CObjectVector@VUString@@@@4_K@Z
.text:00000BC4 ?Init@CArchiveExtractCallback@@QAEXABUCExtractNtOptions@@PBVCCensorNode@NWildcard@@PBVCArc@@PAUIFolderArchiveExtractCallback@@_N4ABVUString@@ABV?$CObjectVector@VUString@@@@4_K@Z proc near
.text:00000BC4
.text:00000BC4 var_14          = dword ptr -14h
.text:00000BC4 var_10          = dword ptr -10h
.text:00000BC4 var_C           = dword ptr -0Ch
.text:00000BC4 var_8           = dword ptr -8
.text:00000BC4 var_4           = dword ptr -4
.text:00000BC4 arg_0           = dword ptr  8
.text:00000BC4 arg_4           = dword ptr  0Ch
.text:00000BC4 arg_8           = dword ptr  10h
.text:00000BC4 arg_C           = dword ptr  14h
.text:00000BC4 arg_10          = byte ptr  18h
.text:00000BC4 arg_14          = byte ptr  1Ch
.text:00000BC4 arg_18          = dword ptr  20h
.text:00000BC4 arg_1C          = dword ptr  24h
.text:00000BC4 arg_20          = byte ptr  28h
.text:00000BC4 arg_24          = dword ptr  2Ch
.text:00000BC4 arg_28          = dword ptr  30h
.text:00000BC4
.text:00000BC4                 push    ebp
.text:00000BC5                 mov     ebp, esp
.text:00000BC7                 sub     esp, 14h
.text:00000BCA                 push    esi             ; wchar_t *
.text:00000BCB                 mov     eax, 0CCCCCCCCh
.text:00000BD0                 mov     [ebp+var_14], eax
.text:00000BD3                 mov     [ebp+var_10], eax
.text:00000BD6                 mov     [ebp+var_C], eax
.text:00000BD9                 mov     [ebp+var_8], eax
.text:00000BDC                 mov     [ebp+var_4], eax
.text:00000BDF                 mov     [ebp+var_4], ecx
.text:00000BE2                 mov     ecx, [ebp+var_4]
.text:00000BE5                 add     ecx, 144h
.text:00000BEB                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:00000BF0                 mov     ecx, [ebp+var_4]
.text:00000BF3                 add     ecx, 150h
.text:00000BF9                 call    ?Clear@?$CRecordVector@I@@QAEXXZ ; CRecordVector<uint>::Clear(void)
.text:00000BFE                 mov     ecx, [ebp+var_4]
.text:00000C01                 add     ecx, 190h       ; this
.text:00000C07                 call    ?Clear@CHardLinks@@QAEXXZ ; CHardLinks::Clear(void)
.text:00000C0C                 mov     ecx, [ebp+var_4]
.text:00000C0F                 add     ecx, 1A8h
.text:00000C15                 call    ?Clear@?$CObjectVector@UCIndexToPathPair@@@@QAEXXZ ; CObjectVector<CIndexToPathPair>::Clear(void)
.text:00000C1A                 mov     eax, [ebp+arg_0]
.text:00000C1D                 mov     ecx, [ebp+var_4]
.text:00000C20                 add     ecx, 18h
.text:00000C23                 mov     edx, [eax]
.text:00000C25                 mov     [ecx], edx
.text:00000C27                 mov     edx, [eax+4]
.text:00000C2A                 mov     [ecx+4], edx
.text:00000C2D                 mov     ax, [eax+8]
.text:00000C31                 mov     [ecx+8], ax
.text:00000C35                 mov     ecx, [ebp+var_4]
.text:00000C38                 mov     edx, [ebp+arg_4]
.text:00000C3B                 mov     [ecx+24h], edx
.text:00000C3E                 mov     eax, [ebp+var_4]
.text:00000C41                 mov     cl, [ebp+arg_10]
.text:00000C44                 mov     [eax+124h], cl
.text:00000C4A                 mov     edx, [ebp+var_4]
.text:00000C4D                 mov     al, [ebp+arg_14]
.text:00000C50                 mov     [edx+125h], al
.text:00000C56                 mov     ecx, [ebp+var_4]
.text:00000C59                 mov     edx, [ebp+var_4]
.text:00000C5C                 mov     eax, [edx+130h]
.text:00000C62                 mov     [ecx+138h], eax
.text:00000C68                 mov     edx, [edx+134h]
.text:00000C6E                 mov     [ecx+13Ch], edx
.text:00000C74                 mov     eax, [ebp+var_4]
.text:00000C77                 mov     byte ptr [eax+140h], 1
.text:00000C7E                 mov     ecx, [ebp+var_4]
.text:00000C81                 mov     edx, [ebp+arg_24]
.text:00000C84                 mov     [ecx+130h], edx
.text:00000C8A                 mov     eax, [ebp+arg_28]
.text:00000C8D                 mov     [ecx+134h], eax
.text:00000C93                 mov     ecx, [ebp+arg_C]
.text:00000C96                 push    ecx
.text:00000C97                 mov     ecx, [ebp+var_4]
.text:00000C9A                 add     ecx, 28h ; '('
.text:00000C9D                 call    ??4?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAEPAUIFolderArchiveExtractCallback@@PAU1@@Z ; CMyComPtr<IFolderArchiveExtractCallback>::operator=(IFolderArchiveExtractCallback *)
.text:00000CA2                 mov     ecx, [ebp+var_4]
.text:00000CA5                 add     ecx, 2Ch ; ','
.text:00000CA8                 call    ?Release@?$CMyComPtr@UICompressProgressInfo@@@@QAEXXZ ; CMyComPtr<ICompressProgressInfo>::Release(void)
.text:00000CAD                 mov     ecx, [ebp+var_4]
.text:00000CB0                 add     ecx, 2Ch ; ','
.text:00000CB3                 call    ??I?$CMyComPtr@UICompressProgressInfo@@@@QAEPAPAUICompressProgressInfo@@XZ ; CMyComPtr<ICompressProgressInfo>::operator&(void)
.text:00000CB8                 push    eax
.text:00000CB9                 push    offset _IID_ICompressProgressInfo
.text:00000CBE                 mov     ecx, [ebp+var_4]
.text:00000CC1                 add     ecx, 28h ; '('
.text:00000CC4                 call    ??$QueryInterface@UICompressProgressInfo@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUICompressProgressInfo@@@Z ; CMyComPtr<IFolderArchiveExtractCallback>::QueryInterface<ICompressProgressInfo>(_GUID const &,ICompressProgressInfo * *)
.text:00000CC9                 mov     ecx, [ebp+var_4]
.text:00000CCC                 add     ecx, 34h ; '4'
.text:00000CCF                 call    ??I?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAEPAPAUIArchiveExtractCallbackMessage@@XZ ; CMyComPtr<IArchiveExtractCallbackMessage>::operator&(void)
.text:00000CD4                 push    eax
.text:00000CD5                 push    offset _IID_IArchiveExtractCallbackMessage
.text:00000CDA                 mov     ecx, [ebp+var_4]
.text:00000CDD                 add     ecx, 28h ; '('
.text:00000CE0                 call    ??$QueryInterface@UIArchiveExtractCallbackMessage@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIArchiveExtractCallbackMessage@@@Z ; CMyComPtr<IFolderArchiveExtractCallback>::QueryInterface<IArchiveExtractCallbackMessage>(_GUID const &,IArchiveExtractCallbackMessage * *)
.text:00000CE5                 mov     ecx, [ebp+var_4]
.text:00000CE8                 add     ecx, 38h ; '8'
.text:00000CEB                 call    ??I?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAEPAPAUIFolderArchiveExtractCallback2@@XZ ; CMyComPtr<IFolderArchiveExtractCallback2>::operator&(void)
.text:00000CF0                 push    eax
.text:00000CF1                 push    offset _IID_IFolderArchiveExtractCallback2
.text:00000CF6                 mov     ecx, [ebp+var_4]
.text:00000CF9                 add     ecx, 28h ; '('
.text:00000CFC                 call    ??$QueryInterface@UIFolderArchiveExtractCallback2@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIFolderArchiveExtractCallback2@@@Z ; CMyComPtr<IFolderArchiveExtractCallback>::QueryInterface<IFolderArchiveExtractCallback2>(_GUID const &,IFolderArchiveExtractCallback2 * *)
.text:00000D01                 mov     ecx, [ebp+var_4]
.text:00000D04                 add     ecx, 5Ch ; '\'
.text:00000D07                 call    ??I?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAEPAPAUIFolderExtractToStreamCallback@@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::operator&(void)
.text:00000D0C                 push    eax
.text:00000D0D                 push    offset _IID_IFolderExtractToStreamCallback
.text:00000D12                 mov     ecx, [ebp+var_4]
.text:00000D15                 add     ecx, 28h ; '('
.text:00000D18                 call    ??$QueryInterface@UIFolderExtractToStreamCallback@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIFolderExtractToStreamCallback@@@Z ; CMyComPtr<IFolderArchiveExtractCallback>::QueryInterface<IFolderExtractToStreamCallback>(_GUID const &,IFolderExtractToStreamCallback * *)
.text:00000D1D                 mov     ecx, [ebp+var_4]
.text:00000D20                 add     ecx, 5Ch ; '\'
.text:00000D23                 call    ??B?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::operator IFolderExtractToStreamCallback *(void)
.text:00000D28                 test    eax, eax
.text:00000D2A                 jz      short loc_D78
.text:00000D2C                 mov     [ebp+var_C], 0
.text:00000D33                 mov     ecx, [ebp+var_4]
.text:00000D36                 add     ecx, 5Ch ; '\'
.text:00000D39                 call    ??C?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::operator->(void)
.text:00000D3E                 mov     [ebp+var_14], eax
.text:00000D41                 mov     esi, esp
.text:00000D43                 lea     edx, [ebp+var_C]
.text:00000D46                 push    edx
.text:00000D47                 mov     eax, [ebp+var_14]
.text:00000D4A                 push    eax
.text:00000D4B                 mov     ecx, [ebp+var_14]
.text:00000D4E                 mov     edx, [ecx]
.text:00000D50                 mov     eax, [edx+0Ch]
.text:00000D53                 call    eax
.text:00000D55                 cmp     esi, esp
.text:00000D57                 call    __RTC_CheckEsp
.text:00000D5C                 test    eax, eax
.text:00000D5E                 jz      short loc_D67
.text:00000D60                 mov     [ebp+var_C], 0
.text:00000D67
.text:00000D67 loc_D67:                                ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+19Aj
.text:00000D67                 cmp     [ebp+var_C], 0
.text:00000D6B                 jnz     short loc_D78
.text:00000D6D                 mov     ecx, [ebp+var_4]
.text:00000D70                 add     ecx, 5Ch ; '\'
.text:00000D73                 call    ?Release@?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAEXXZ ; CMyComPtr<IFolderExtractToStreamCallback>::Release(void)
.text:00000D78
.text:00000D78 loc_D78:                                ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+166j
.text:00000D78                                         ; CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+1A7j
.text:00000D78                 push    1               ; bool
.text:00000D7A                 mov     ecx, [ebp+arg_C]
.text:00000D7D                 push    ecx             ; struct IProgress *
.text:00000D7E                 mov     edx, [ebp+var_4]
.text:00000D81                 mov     ecx, [edx+160h] ; this
.text:00000D87                 call    ?Init@CLocalProgress@@QAEXPAUIProgress@@_N@Z ; CLocalProgress::Init(IProgress *,bool)
.text:00000D8C                 mov     eax, [ebp+var_4]
.text:00000D8F                 mov     ecx, [eax+160h]
.text:00000D95                 mov     byte ptr [ecx+31h], 0
.text:00000D99                 mov     edx, [ebp+arg_1C]
.text:00000D9C                 push    edx
.text:00000D9D                 mov     ecx, [ebp+var_4]
.text:00000DA0                 add     ecx, 110h
.text:00000DA6                 call    ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z ; CObjectVector<UString>::operator=(CObjectVector<UString> const &)
.text:00000DAB                 mov     eax, [ebp+var_4]
.text:00000DAE                 mov     cl, [ebp+arg_20]
.text:00000DB1                 mov     [eax+10Dh], cl
.text:00000DB7                 mov     edx, [ebp+var_4]
.text:00000DBA                 mov     dword ptr [edx+120h], 0FFFFFFFFh
.text:00000DC4                 mov     eax, [ebp+var_4]
.text:00000DC7                 mov     byte ptr [eax+11Ch], 0
.text:00000DCE                 mov     ecx, [ebp+var_4]
.text:00000DD1                 mov     edx, [ebp+arg_8]
.text:00000DD4                 mov     [ecx+14h], edx
.text:00000DD7                 mov     eax, [ebp+arg_18]
.text:00000DDA                 push    eax
.text:00000DDB                 mov     ecx, [ebp+var_4]
.text:00000DDE                 add     ecx, 3Ch ; '<'
.text:00000DE1                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00000DE6                 mov     ecx, [ebp+arg_18]
.text:00000DE9                 push    ecx
.text:00000DEA                 mov     ecx, [ebp+var_4]
.text:00000DED                 add     ecx, 48h ; 'H'
.text:00000DF0                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00000DF5                 mov     ecx, [ebp+var_4]
.text:00000DF8                 add     ecx, 3Ch ; '<'
.text:00000DFB                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000E00                 push    eax             ; struct UString *
.text:00000E01                 call    ?IsAltPathPrefix@NName@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NName::IsAltPathPrefix(wchar_t const *)
.text:00000E06                 movzx   edx, al
.text:00000E09                 test    edx, edx
.text:00000E0B                 jnz     short loc_E3A
.text:00000E0D                 mov     eax, [ebp+var_4]
.text:00000E10                 add     eax, 3Ch ; '<'
.text:00000E13                 push    eax             ; struct UString *
.text:00000E14                 call    ?NormalizeDirPathPrefix@NName@NFile@NWindows@@YGXAAVUString@@@Z ; NWindows::NFile::NName::NormalizeDirPathPrefix(UString &)
.text:00000E19                 mov     ecx, [ebp+var_4]
.text:00000E1C                 add     ecx, 48h ; 'H'
.text:00000E1F                 push    ecx             ; wchar_t *
.text:00000E20                 mov     ecx, [ebp+arg_18]
.text:00000E23                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000E28                 push    eax             ; struct UString *
.text:00000E29                 call    ?MyGetFullPathName@NDir@NFile@NWindows@@YG_NPB_WAAVUString@@@Z ; NWindows::NFile::NDir::MyGetFullPathName(wchar_t const *,UString &)
.text:00000E2E                 mov     edx, [ebp+var_4]
.text:00000E31                 add     edx, 48h ; 'H'
.text:00000E34                 push    edx             ; this
.text:00000E35                 call    ?NormalizeDirPathPrefix@NName@NFile@NWindows@@YGXAAVUString@@@Z ; NWindows::NFile::NName::NormalizeDirPathPrefix(UString &)
.text:00000E3A
.text:00000E3A loc_E3A:                                ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+247j
.text:00000E3A                 push    edx
.text:00000E3B                 mov     ecx, ebp
.text:00000E3D                 push    eax
.text:00000E3E                 lea     edx, $LN9_0
.text:00000E44                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000E49                 pop     eax
.text:00000E4A                 pop     edx
.text:00000E4B                 pop     esi
.text:00000E4C                 add     esp, 14h
.text:00000E4F                 cmp     ebp, esp
.text:00000E51                 call    __RTC_CheckEsp
.text:00000E56                 mov     esp, ebp
.text:00000E58                 pop     ebp
.text:00000E59                 retn    2Ch
.text:00000E59 ?Init@CArchiveExtractCallback@@QAEXABUCExtractNtOptions@@PBVCCensorNode@NWildcard@@PBVCArc@@PAUIFolderArchiveExtractCallback@@_N4ABVUString@@ABV?$CObjectVector@VUString@@@@4_K@Z endp ; sp-analysis failed
.text:00000E59
.text:00000E59 ; ---------------------------------------------------------------------------
.text:00000E5C $LN9_0          dd 1                    ; DATA XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+27Ao
.text:00000E60                 dd offset $LN8_1
.text:00000E64 $LN8_1          dd 0FFFFFFF4h, 4        ; DATA XREF: .text:00000E60o
.text:00000E6C                 dd offset $LN7_0        ; "useStreams"
.text:00000E70 $LN7_0          db 'useStreams',0       ; DATA XREF: .text:00000E6Co
.text:00000E7B                 db 9 dup(0CCh)
.text:00000E84
.text:00000E84 ; =============== S U B R O U T I N E =======================================
.text:00000E84
.text:00000E84 ; Attributes: bp-based frame
.text:00000E84
.text:00000E84 ; __int32 __cdecl CArchiveExtractCallback::SetTotal(CArchiveExtractCallback *this, unsigned __int64)
.text:00000E84                 public ?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z
.text:00000E84 ?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z proc near
.text:00000E84                                         ; CODE XREF: [thunk]:CArchiveExtractCallback::SetTotal`adjustor{4}' (unsigned __int64)+5j
.text:00000E84                                         ; DATA XREF: .rdata:000075B0o
.text:00000E84
.text:00000E84 var_24          = dword ptr -24h
.text:00000E84 var_20          = dword ptr -20h
.text:00000E84 var_1C          = dword ptr -1Ch
.text:00000E84 var_18          = dword ptr -18h
.text:00000E84 var_14          = dword ptr -14h
.text:00000E84 var_10          = dword ptr -10h
.text:00000E84 var_C           = dword ptr -0Ch
.text:00000E84 var_4           = dword ptr -4
.text:00000E84 this            = dword ptr  8
.text:00000E84 arg_4           = qword ptr  0Ch
.text:00000E84
.text:00000E84 ; FUNCTION CHUNK AT .text:00000F71 SIZE 0000001E BYTES
.text:00000E84
.text:00000E84                 push    ebp
.text:00000E85                 mov     ebp, esp
.text:00000E87                 push    0FFFFFFFFh
.text:00000E89                 push    offset __ehhandler$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z
.text:00000E8E                 mov     eax, large fs:0
.text:00000E94                 push    eax
.text:00000E95                 push    ecx
.text:00000E96                 sub     esp, 14h
.text:00000E99                 push    ebx
.text:00000E9A                 push    esi
.text:00000E9B                 push    edi
.text:00000E9C                 mov     eax, 0CCCCCCCCh
.text:00000EA1                 mov     [ebp+var_24], eax
.text:00000EA4                 mov     [ebp+var_20], eax
.text:00000EA7                 mov     [ebp+var_1C], eax
.text:00000EAA                 mov     [ebp+var_18], eax
.text:00000EAD                 mov     [ebp+var_14], eax
.text:00000EB0                 mov     eax, dword ptr ds:___security_cookie
.text:00000EB5                 xor     eax, ebp
.text:00000EB7                 push    eax
.text:00000EB8                 lea     eax, [ebp+var_C]
.text:00000EBB                 mov     large fs:0, eax
.text:00000EC1                 mov     [ebp+var_10], esp
.text:00000EC4                 mov     [ebp+var_4], 0
.text:00000ECB                 mov     eax, [ebp+this]
.text:00000ECE                 mov     ecx, dword ptr [ebp+arg_4]
.text:00000ED1                 mov     [eax+138h], ecx
.text:00000ED7                 mov     edx, dword ptr [ebp+arg_4+4]
.text:00000EDA                 mov     [eax+13Ch], edx
.text:00000EE0                 mov     eax, [ebp+this]
.text:00000EE3                 mov     byte ptr [eax+140h], 1
.text:00000EEA                 mov     ecx, [ebp+this]
.text:00000EED                 movzx   edx, byte ptr [ecx+126h]
.text:00000EF4                 test    edx, edx
.text:00000EF6                 jnz     short loc_F47
.text:00000EF8                 mov     ecx, [ebp+this]
.text:00000EFB                 add     ecx, 28h ; '('
.text:00000EFE                 call    ??B?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::operator IFolderArchiveExtractCallback *(void)
.text:00000F03                 mov     [ebp+var_18], eax
.text:00000F06                 cmp     [ebp+var_18], 0
.text:00000F0A                 jz      short loc_F47
.text:00000F0C                 mov     ecx, [ebp+this]
.text:00000F0F                 add     ecx, 28h ; '('
.text:00000F12                 call    ??C?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::operator->(void)
.text:00000F17                 mov     [ebp+var_1C], eax
.text:00000F1A                 mov     eax, [ebp+var_1C]
.text:00000F1D                 mov     [ebp+var_20], eax
.text:00000F20                 mov     esi, esp
.text:00000F22                 mov     ecx, dword ptr [ebp+arg_4+4]
.text:00000F25                 push    ecx
.text:00000F26                 mov     edx, dword ptr [ebp+arg_4]
.text:00000F29                 push    edx
.text:00000F2A                 mov     eax, [ebp+var_20]
.text:00000F2D                 push    eax
.text:00000F2E                 mov     ecx, [ebp+var_20]
.text:00000F31                 mov     edx, [ecx]
.text:00000F33                 mov     eax, [edx+0Ch]
.text:00000F36                 call    eax
.text:00000F38                 cmp     esi, esp
.text:00000F3A                 call    __RTC_CheckEsp
.text:00000F3F                 mov     [ebp+var_24], eax
.text:00000F42                 mov     eax, [ebp+var_24]
.text:00000F45                 jmp     short loc_F71
.text:00000F47 ; ---------------------------------------------------------------------------
.text:00000F47
.text:00000F47 loc_F47:                                ; CODE XREF: CArchiveExtractCallback::SetTotal(unsigned __int64)+72j
.text:00000F47                                         ; CArchiveExtractCallback::SetTotal(unsigned __int64)+86j
.text:00000F47                 xor     eax, eax
.text:00000F49                 jmp     short loc_F71
.text:00000F49 ?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z endp
.text:00000F49
.text:00000F4B
.text:00000F4B ; =============== S U B R O U T I N E =======================================
.text:00000F4B
.text:00000F4B
.text:00000F4B __catch$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z$0 proc near
.text:00000F4B                                         ; DATA XREF: .xdata$x:00006C7Co
.text:00000F4B                 mov     dword ptr [ebp-14h], 8007000Eh
.text:00000F52                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00000F59                 mov     eax, offset $LN8_2
.text:00000F5E                 retn
.text:00000F5E __catch$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z$0 endp
.text:00000F5E
.text:00000F5F ; ---------------------------------------------------------------------------
.text:00000F5F                 mov     eax, offset __tryend$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z$1
.text:00000F64                 retn
.text:00000F65 ; ---------------------------------------------------------------------------
.text:00000F65
.text:00000F65 __tryend$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z$1:
.text:00000F65                                         ; DATA XREF: .text:00000F5Fo
.text:00000F65                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00000F6C                 jmp     short loc_F71
.text:00000F6E ; ---------------------------------------------------------------------------
.text:00000F6E
.text:00000F6E $LN8_2:                                 ; DATA XREF: __catch$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z$0+Eo
.text:00000F6E                 mov     eax, [ebp-14h]
.text:00000F71 ; START OF FUNCTION CHUNK FOR ?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z
.text:00000F71
.text:00000F71 loc_F71:                                ; CODE XREF: CArchiveExtractCallback::SetTotal(unsigned __int64)+C1j
.text:00000F71                                         ; CArchiveExtractCallback::SetTotal(unsigned __int64)+C5j ...
.text:00000F71                 mov     ecx, [ebp+var_C]
.text:00000F74                 mov     large fs:0, ecx
.text:00000F7B                 pop     ecx
.text:00000F7C                 pop     edi
.text:00000F7D                 pop     esi
.text:00000F7E                 pop     ebx
.text:00000F7F                 add     esp, 24h
.text:00000F82                 cmp     ebp, esp
.text:00000F84                 call    __RTC_CheckEsp
.text:00000F89                 mov     esp, ebp
.text:00000F8B                 pop     ebp
.text:00000F8C                 retn    0Ch
.text:00000F8C ; END OF FUNCTION CHUNK FOR ?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z
.text:00000F8C ; ---------------------------------------------------------------------------
.text:00000F8F                 db 5 dup(0CCh)
.text:00000F94
.text:00000F94 ; =============== S U B R O U T I N E =======================================
.text:00000F94
.text:00000F94 ; Attributes: bp-based frame
.text:00000F94
.text:00000F94 ; __int32 __cdecl CArchiveExtractCallback::SetCompleted(CArchiveExtractCallback *this, const unsigned __int64 *)
.text:00000F94                 public ?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z
.text:00000F94 ?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z proc near
.text:00000F94                                         ; CODE XREF: [thunk]:CArchiveExtractCallback::SetCompleted`adjustor{4}' (unsigned __int64 const *)+5j
.text:00000F94                                         ; DATA XREF: .rdata:000075B4o
.text:00000F94
.text:00000F94 var_3C          = dword ptr -3Ch
.text:00000F94 var_38          = dword ptr -38h
.text:00000F94 var_34          = dword ptr -34h
.text:00000F94 var_30          = dword ptr -30h
.text:00000F94 var_2C          = dword ptr -2Ch
.text:00000F94 var_25          = byte ptr -25h
.text:00000F94 var_1C          = dword ptr -1Ch
.text:00000F94 var_18          = dword ptr -18h
.text:00000F94 var_10          = dword ptr -10h
.text:00000F94 var_C           = dword ptr -0Ch
.text:00000F94 var_4           = dword ptr -4
.text:00000F94 this            = dword ptr  8
.text:00000F94 arg_4           = dword ptr  0Ch
.text:00000F94
.text:00000F94 ; FUNCTION CHUNK AT .text:000010D6 SIZE 0000002F BYTES
.text:00000F94
.text:00000F94                 push    ebp
.text:00000F95                 mov     ebp, esp
.text:00000F97                 push    0FFFFFFFFh
.text:00000F99                 push    offset __ehhandler$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z
.text:00000F9E                 mov     eax, large fs:0
.text:00000FA4                 push    eax
.text:00000FA5                 push    ecx
.text:00000FA6                 sub     esp, 2Ch
.text:00000FA9                 push    ebx
.text:00000FAA                 push    esi
.text:00000FAB                 push    edi
.text:00000FAC                 lea     edi, [ebp+var_3C]
.text:00000FAF                 mov     ecx, 0Bh
.text:00000FB4                 mov     eax, 0CCCCCCCCh
.text:00000FB9                 rep stosd
.text:00000FBB                 mov     eax, dword ptr ds:___security_cookie
.text:00000FC0                 xor     eax, ebp
.text:00000FC2                 push    eax
.text:00000FC3                 lea     eax, [ebp+var_C]
.text:00000FC6                 mov     large fs:0, eax
.text:00000FCC                 mov     [ebp+var_10], esp
.text:00000FCF                 mov     [ebp+var_4], 0
.text:00000FD6                 mov     ecx, [ebp+this]
.text:00000FD9                 add     ecx, 28h ; '('
.text:00000FDC                 call    ??7?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBE_NXZ ; CMyComPtr<IFolderArchiveExtractCallback>::operator!(void)
.text:00000FE1                 mov     [ebp+var_25], al
.text:00000FE4                 movzx   eax, [ebp+var_25]
.text:00000FE8                 test    eax, eax
.text:00000FEA                 jz      short loc_FF3
.text:00000FEC                 xor     eax, eax
.text:00000FEE                 jmp     loc_10D6
.text:00000FF3 ; ---------------------------------------------------------------------------
.text:00000FF3
.text:00000FF3 loc_FF3:                                ; CODE XREF: CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)+56j
.text:00000FF3                 mov     ecx, [ebp+this]
.text:00000FF6                 movzx   edx, byte ptr [ecx+126h]
.text:00000FFD                 test    edx, edx
.text:00000FFF                 jz      short loc_1079
.text:00001001                 mov     eax, [ebp+this]
.text:00001004                 mov     ecx, [eax+160h]
.text:0000100A                 mov     edx, [ecx+20h]
.text:0000100D                 mov     [ebp+var_1C], edx
.text:00001010                 mov     eax, [ecx+24h]
.text:00001013                 mov     [ebp+var_18], eax
.text:00001016                 cmp     [ebp+arg_4], 0
.text:0000101A                 jz      short loc_1073
.text:0000101C                 mov     ecx, [ebp+this]
.text:0000101F                 movzx   edx, byte ptr [ecx+140h]
.text:00001026                 test    edx, edx
.text:00001028                 jz      short loc_1073
.text:0000102A                 mov     eax, [ebp+this]
.text:0000102D                 mov     ecx, [eax+134h]
.text:00001033                 push    ecx
.text:00001034                 mov     edx, [eax+130h]
.text:0000103A                 push    edx
.text:0000103B                 mov     eax, [ebp+this]
.text:0000103E                 mov     ecx, [eax+13Ch]
.text:00001044                 push    ecx
.text:00001045                 mov     edx, [eax+138h]
.text:0000104B                 push    edx
.text:0000104C                 mov     eax, [ebp+arg_4]
.text:0000104F                 mov     ecx, [eax+4]
.text:00001052                 push    ecx
.text:00001053                 mov     edx, [eax]
.text:00001055                 push    edx
.text:00001056                 call    ?MyMultDiv64@@YG_K_K00@Z ; MyMultDiv64(unsigned __int64,unsigned __int64,unsigned __int64)
.text:0000105B                 mov     [ebp+var_30], eax
.text:0000105E                 mov     [ebp+var_2C], edx
.text:00001061                 mov     eax, [ebp+var_1C]
.text:00001064                 add     eax, [ebp+var_30]
.text:00001067                 mov     ecx, [ebp+var_18]
.text:0000106A                 adc     ecx, [ebp+var_2C]
.text:0000106D                 mov     [ebp+var_1C], eax
.text:00001070                 mov     [ebp+var_18], ecx
.text:00001073
.text:00001073 loc_1073:                               ; CODE XREF: CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)+86j
.text:00001073                                         ; CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)+94j
.text:00001073                 lea     edx, [ebp+var_1C]
.text:00001076                 mov     [ebp+arg_4], edx
.text:00001079
.text:00001079 loc_1079:                               ; CODE XREF: CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)+6Bj
.text:00001079                 mov     ecx, [ebp+this]
.text:0000107C                 add     ecx, 28h ; '('
.text:0000107F                 call    ??C?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::operator->(void)
.text:00001084                 mov     [ebp+var_34], eax
.text:00001087                 mov     eax, [ebp+var_34]
.text:0000108A                 mov     [ebp+var_38], eax
.text:0000108D                 mov     esi, esp
.text:0000108F                 mov     ecx, [ebp+arg_4]
.text:00001092                 push    ecx
.text:00001093                 mov     edx, [ebp+var_38]
.text:00001096                 push    edx
.text:00001097                 mov     eax, [ebp+var_38]
.text:0000109A                 mov     ecx, [eax]
.text:0000109C                 mov     edx, [ecx+10h]
.text:0000109F                 call    edx
.text:000010A1                 cmp     esi, esp
.text:000010A3                 call    __RTC_CheckEsp
.text:000010A8                 mov     [ebp+var_3C], eax
.text:000010AB                 mov     eax, [ebp+var_3C]
.text:000010AE                 jmp     short loc_10D6
.text:000010AE ?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z endp
.text:000010AE
.text:000010B0
.text:000010B0 ; =============== S U B R O U T I N E =======================================
.text:000010B0
.text:000010B0
.text:000010B0 __catch$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z$0 proc near
.text:000010B0                                         ; DATA XREF: .xdata$x:00006CD4o
.text:000010B0                 mov     dword ptr [ebp-24h], 8007000Eh
.text:000010B7                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:000010BE                 mov     eax, offset $LN10_0
.text:000010C3                 retn
.text:000010C3 __catch$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z$0 endp
.text:000010C3
.text:000010C4 ; ---------------------------------------------------------------------------
.text:000010C4                 mov     eax, offset __tryend$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z$1
.text:000010C9                 retn
.text:000010CA ; ---------------------------------------------------------------------------
.text:000010CA
.text:000010CA __tryend$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z$1:
.text:000010CA                                         ; DATA XREF: .text:000010C4o
.text:000010CA                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:000010D1                 jmp     short loc_10D6
.text:000010D3 ; ---------------------------------------------------------------------------
.text:000010D3
.text:000010D3 $LN10_0:                                ; DATA XREF: __catch$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z$0+Eo
.text:000010D3                 mov     eax, [ebp-24h]
.text:000010D6 ; START OF FUNCTION CHUNK FOR ?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z
.text:000010D6
.text:000010D6 loc_10D6:                               ; CODE XREF: CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)+5Aj
.text:000010D6                                         ; CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)+11Aj ...
.text:000010D6                 push    edx
.text:000010D7                 mov     ecx, ebp
.text:000010D9                 push    eax
.text:000010DA                 lea     edx, $LN15
.text:000010E0                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000010E5                 pop     eax
.text:000010E6                 pop     edx
.text:000010E7                 mov     ecx, [ebp+var_C]
.text:000010EA                 mov     large fs:0, ecx
.text:000010F1                 pop     ecx
.text:000010F2                 pop     edi
.text:000010F3                 pop     esi
.text:000010F4                 pop     ebx
.text:000010F5                 add     esp, 3Ch
.text:000010F8                 cmp     ebp, esp
.text:000010FA                 call    __RTC_CheckEsp
.text:000010FF                 mov     esp, ebp
.text:00001101                 pop     ebp
.text:00001102                 retn    8
.text:00001102 ; END OF FUNCTION CHUNK FOR ?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z
.text:00001102 ; ---------------------------------------------------------------------------
.text:00001105                 align 4
.text:00001108 $LN15           dd 1                    ; DATA XREF: CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)+146o
.text:0000110C                 dd offset $LN14
.text:00001110 $LN14           dd 0FFFFFFE4h, 8        ; DATA XREF: .text:0000110Co
.text:00001118                 dd offset $LN12_1       ; "packCur"
.text:0000111C $LN12_1         db 'packCur',0          ; DATA XREF: .text:00001118o
.text:00001124
.text:00001124 ; =============== S U B R O U T I N E =======================================
.text:00001124
.text:00001124 ; Attributes: bp-based frame
.text:00001124
.text:00001124 ; unsigned __int64 __stdcall MyMultDiv64(unsigned __int64, unsigned __int64, unsigned __int64)
.text:00001124 ?MyMultDiv64@@YG_K_K00@Z proc near      ; CODE XREF: CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)+C2p
.text:00001124
.text:00001124 arg_0           = dword ptr  8
.text:00001124 arg_4           = dword ptr  0Ch
.text:00001124 arg_8           = dword ptr  10h
.text:00001124 arg_C           = dword ptr  14h
.text:00001124 arg_10          = dword ptr  18h
.text:00001124 arg_14          = dword ptr  1Ch
.text:00001124
.text:00001124                 push    ebp
.text:00001125                 mov     ebp, esp
.text:00001127                 lea     eax, [ebp+arg_8]
.text:0000112A                 push    eax
.text:0000112B                 lea     ecx, [ebp+arg_10]
.text:0000112E                 push    ecx
.text:0000112F                 call    ?NormalizeVals@@YGXAA_K0@Z ; NormalizeVals(unsigned __int64 &,unsigned __int64 &)
.text:00001134                 lea     edx, [ebp+arg_8]
.text:00001137                 push    edx
.text:00001138                 lea     eax, [ebp+arg_0]
.text:0000113B                 push    eax
.text:0000113C                 call    ?NormalizeVals@@YGXAA_K0@Z ; NormalizeVals(unsigned __int64 &,unsigned __int64 &)
.text:00001141                 mov     ecx, [ebp+arg_8]
.text:00001144                 or      ecx, [ebp+arg_C]
.text:00001147                 jnz     short loc_1157
.text:00001149                 mov     [ebp+arg_8], 1
.text:00001150                 mov     [ebp+arg_C], 0
.text:00001157
.text:00001157 loc_1157:                               ; CODE XREF: MyMultDiv64(unsigned __int64,unsigned __int64,unsigned __int64)+23j
.text:00001157                 mov     edx, [ebp+arg_14]
.text:0000115A                 push    edx
.text:0000115B                 mov     eax, [ebp+arg_10]
.text:0000115E                 push    eax
.text:0000115F                 mov     ecx, [ebp+arg_4]
.text:00001162                 push    ecx
.text:00001163                 mov     edx, [ebp+arg_0]
.text:00001166                 push    edx
.text:00001167                 call    __allmul
.text:0000116C                 mov     ecx, [ebp+arg_C]
.text:0000116F                 push    ecx
.text:00001170                 mov     ecx, [ebp+arg_8]
.text:00001173                 push    ecx
.text:00001174                 push    edx
.text:00001175                 push    eax
.text:00001176                 call    __aulldiv
.text:0000117B                 cmp     ebp, esp
.text:0000117D                 call    __RTC_CheckEsp
.text:00001182                 pop     ebp
.text:00001183                 retn    18h
.text:00001183 ?MyMultDiv64@@YG_K_K00@Z endp
.text:00001183
.text:00001183 ; ---------------------------------------------------------------------------
.text:00001186                 db 0Eh dup(0CCh)
.text:00001194
.text:00001194 ; =============== S U B R O U T I N E =======================================
.text:00001194
.text:00001194 ; Attributes: bp-based frame
.text:00001194
.text:00001194 ; void __stdcall NormalizeVals(unsigned __int64 &, unsigned __int64 &)
.text:00001194 ?NormalizeVals@@YGXAA_K0@Z proc near    ; CODE XREF: MyMultDiv64(unsigned __int64,unsigned __int64,unsigned __int64)+Bp
.text:00001194                                         ; MyMultDiv64(unsigned __int64,unsigned __int64,unsigned __int64)+18p
.text:00001194
.text:00001194 var_C           = dword ptr -0Ch
.text:00001194 var_8           = dword ptr -8
.text:00001194 var_4           = dword ptr -4
.text:00001194 arg_0           = dword ptr  8
.text:00001194 arg_4           = dword ptr  0Ch
.text:00001194
.text:00001194                 push    ebp
.text:00001195                 mov     ebp, esp
.text:00001197                 sub     esp, 0Ch
.text:0000119A                 mov     [ebp+var_C], 0CCCCCCCCh
.text:000011A1                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000011A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000011AF                 mov     [ebp+var_8], 80000000h
.text:000011B6                 mov     [ebp+var_4], 0
.text:000011BD
.text:000011BD loc_11BD:                               ; CODE XREF: NormalizeVals(unsigned __int64 &,unsigned __int64 &)+71j
.text:000011BD                 mov     eax, [ebp+arg_0]
.text:000011C0                 mov     [ebp+var_C], eax
.text:000011C3                 mov     ecx, [ebp+var_C]
.text:000011C6                 cmp     dword ptr [ecx+4], 0
.text:000011CA                 ja      short loc_11D7
.text:000011CC                 mov     edx, [ebp+var_C]
.text:000011CF                 cmp     dword ptr [edx], 80000000h
.text:000011D5                 jbe     short loc_1207
.text:000011D7
.text:000011D7 loc_11D7:                               ; CODE XREF: NormalizeVals(unsigned __int64 &,unsigned __int64 &)+36j
.text:000011D7                 mov     ecx, [ebp+arg_0]
.text:000011DA                 mov     eax, [ecx]
.text:000011DC                 mov     edx, [ecx+4]
.text:000011DF                 mov     cl, 1
.text:000011E1                 call    __aullshr
.text:000011E6                 mov     ecx, [ebp+arg_0]
.text:000011E9                 mov     [ecx], eax
.text:000011EB                 mov     [ecx+4], edx
.text:000011EE                 mov     edx, [ebp+arg_4]
.text:000011F1                 mov     eax, [edx]
.text:000011F3                 mov     edx, [edx+4]
.text:000011F6                 mov     cl, 1
.text:000011F8                 call    __aullshr
.text:000011FD                 mov     ecx, [ebp+arg_4]
.text:00001200                 mov     [ecx], eax
.text:00001202                 mov     [ecx+4], edx
.text:00001205                 jmp     short loc_11BD
.text:00001207 ; ---------------------------------------------------------------------------
.text:00001207
.text:00001207 loc_1207:                               ; CODE XREF: NormalizeVals(unsigned __int64 &,unsigned __int64 &)+41j
.text:00001207                 add     esp, 0Ch
.text:0000120A                 cmp     ebp, esp
.text:0000120C                 call    __RTC_CheckEsp
.text:00001211                 mov     esp, ebp
.text:00001213                 pop     ebp
.text:00001214                 retn    8
.text:00001214 ?NormalizeVals@@YGXAA_K0@Z endp
.text:00001214
.text:00001214 ; ---------------------------------------------------------------------------
.text:00001217                 db 0Dh dup(0CCh)
.text:00001224
.text:00001224 ; =============== S U B R O U T I N E =======================================
.text:00001224
.text:00001224 ; Attributes: bp-based frame
.text:00001224
.text:00001224 ; __int32 __cdecl CArchiveExtractCallback::SetRatioInfo(CArchiveExtractCallback *this, const unsigned __int64 *, const unsigned __int64 *)
.text:00001224                 public ?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z
.text:00001224 ?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z proc near
.text:00001224                                         ; DATA XREF: .rdata:0000756Co
.text:00001224
.text:00001224 var_20          = dword ptr -20h
.text:00001224 var_1C          = dword ptr -1Ch
.text:00001224 var_18          = dword ptr -18h
.text:00001224 var_14          = dword ptr -14h
.text:00001224 var_10          = dword ptr -10h
.text:00001224 var_C           = dword ptr -0Ch
.text:00001224 var_4           = dword ptr -4
.text:00001224 this            = dword ptr  8
.text:00001224 arg_4           = dword ptr  0Ch
.text:00001224 arg_8           = dword ptr  10h
.text:00001224
.text:00001224 ; FUNCTION CHUNK AT .text:000012CC SIZE 0000001E BYTES
.text:00001224
.text:00001224                 push    ebp
.text:00001225                 mov     ebp, esp
.text:00001227                 push    0FFFFFFFFh
.text:00001229                 push    offset __ehhandler$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z
.text:0000122E                 mov     eax, large fs:0
.text:00001234                 push    eax
.text:00001235                 push    ecx
.text:00001236                 sub     esp, 10h
.text:00001239                 push    ebx
.text:0000123A                 push    esi
.text:0000123B                 push    edi
.text:0000123C                 mov     eax, 0CCCCCCCCh
.text:00001241                 mov     [ebp+var_20], eax
.text:00001244                 mov     [ebp+var_1C], eax
.text:00001247                 mov     [ebp+var_18], eax
.text:0000124A                 mov     [ebp+var_14], eax
.text:0000124D                 mov     eax, dword ptr ds:___security_cookie
.text:00001252                 xor     eax, ebp
.text:00001254                 push    eax
.text:00001255                 lea     eax, [ebp+var_C]
.text:00001258                 mov     large fs:0, eax
.text:0000125E                 mov     [ebp+var_10], esp
.text:00001261                 mov     [ebp+var_4], 0
.text:00001268                 mov     ecx, [ebp+this]
.text:0000126B                 add     ecx, 11Ch
.text:00001271                 call    ??C?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ ; CMyComPtr<ICompressProgressInfo>::operator->(void)
.text:00001276                 mov     [ebp+var_18], eax
.text:00001279                 mov     eax, [ebp+var_18]
.text:0000127C                 mov     [ebp+var_1C], eax
.text:0000127F                 mov     esi, esp
.text:00001281                 mov     ecx, [ebp+arg_8]
.text:00001284                 push    ecx
.text:00001285                 mov     edx, [ebp+arg_4]
.text:00001288                 push    edx
.text:00001289                 mov     eax, [ebp+var_1C]
.text:0000128C                 push    eax
.text:0000128D                 mov     ecx, [ebp+var_1C]
.text:00001290                 mov     edx, [ecx]
.text:00001292                 mov     eax, [edx+0Ch]
.text:00001295                 call    eax
.text:00001297                 cmp     esi, esp
.text:00001299                 call    __RTC_CheckEsp
.text:0000129E                 mov     [ebp+var_20], eax
.text:000012A1                 mov     eax, [ebp+var_20]
.text:000012A4                 jmp     short loc_12CC
.text:000012A4 ?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z endp
.text:000012A4
.text:000012A6
.text:000012A6 ; =============== S U B R O U T I N E =======================================
.text:000012A6
.text:000012A6
.text:000012A6 __catch$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z$0 proc near
.text:000012A6                                         ; DATA XREF: .xdata$x:00006D2Co
.text:000012A6                 mov     dword ptr [ebp-14h], 8007000Eh
.text:000012AD                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:000012B4                 mov     eax, offset $LN7_1
.text:000012B9                 retn
.text:000012B9 __catch$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z$0 endp
.text:000012B9
.text:000012BA ; ---------------------------------------------------------------------------
.text:000012BA                 mov     eax, offset __tryend$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z$1
.text:000012BF                 retn
.text:000012C0 ; ---------------------------------------------------------------------------
.text:000012C0
.text:000012C0 __tryend$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z$1:
.text:000012C0                                         ; DATA XREF: .text:000012BAo
.text:000012C0                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:000012C7                 jmp     short loc_12CC
.text:000012C9 ; ---------------------------------------------------------------------------
.text:000012C9
.text:000012C9 $LN7_1:                                 ; DATA XREF: __catch$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z$0+Eo
.text:000012C9                 mov     eax, [ebp-14h]
.text:000012CC ; START OF FUNCTION CHUNK FOR ?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z
.text:000012CC
.text:000012CC loc_12CC:                               ; CODE XREF: CArchiveExtractCallback::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+80j
.text:000012CC                                         ; .text:000012C7j
.text:000012CC                 mov     ecx, [ebp+var_C]
.text:000012CF                 mov     large fs:0, ecx
.text:000012D6                 pop     ecx
.text:000012D7                 pop     edi
.text:000012D8                 pop     esi
.text:000012D9                 pop     ebx
.text:000012DA                 add     esp, 20h
.text:000012DD                 cmp     ebp, esp
.text:000012DF                 call    __RTC_CheckEsp
.text:000012E4                 mov     esp, ebp
.text:000012E6                 pop     ebp
.text:000012E7                 retn    0Ch
.text:000012E7 ; END OF FUNCTION CHUNK FOR ?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z
.text:000012E7 ; ---------------------------------------------------------------------------
.text:000012EA                 db 0Ah dup(0CCh)
.text:000012F4
.text:000012F4 ; =============== S U B R O U T I N E =======================================
.text:000012F4
.text:000012F4 ; Attributes: bp-based frame
.text:000012F4
.text:000012F4 ; int __stdcall CArchiveExtractCallback::CreateComplexDirectory(int, UString *)
.text:000012F4                 public ?CreateComplexDirectory@CArchiveExtractCallback@@AAEXABV?$CObjectVector@VUString@@@@AAVUString@@@Z
.text:000012F4 ?CreateComplexDirectory@CArchiveExtractCallback@@AAEXABV?$CObjectVector@VUString@@@@AAVUString@@@Z proc near
.text:000012F4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1536p
.text:000012F4
.text:000012F4 var_14          = dword ptr -14h
.text:000012F4 var_10          = dword ptr -10h
.text:000012F4 var_C           = dword ptr -0Ch
.text:000012F4 var_8           = dword ptr -8
.text:000012F4 var_4           = dword ptr -4
.text:000012F4 arg_0           = dword ptr  8
.text:000012F4 arg_4           = dword ptr  0Ch
.text:000012F4
.text:000012F4                 push    ebp
.text:000012F5                 mov     ebp, esp
.text:000012F7                 sub     esp, 14h
.text:000012FA                 mov     eax, 0CCCCCCCCh
.text:000012FF                 mov     [ebp+var_14], eax
.text:00001302                 mov     [ebp+var_10], eax
.text:00001305                 mov     [ebp+var_C], eax
.text:00001308                 mov     [ebp+var_8], eax
.text:0000130B                 mov     [ebp+var_4], eax
.text:0000130E                 mov     [ebp+var_4], ecx
.text:00001311                 mov     byte ptr [ebp+var_8+3], 0
.text:00001315                 mov     ecx, [ebp+arg_0]
.text:00001318                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:0000131D                 movzx   eax, al
.text:00001320                 test    eax, eax
.text:00001322                 jnz     short loc_135F
.text:00001324                 push    0
.text:00001326                 mov     ecx, [ebp+arg_0]
.text:00001329                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000132E                 mov     [ebp+var_C], eax
.text:00001331                 mov     ecx, [ebp+var_C] ; this
.text:00001334                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00001339                 movzx   ecx, al
.text:0000133C                 test    ecx, ecx
.text:0000133E                 jz      short loc_1346
.text:00001340                 mov     byte ptr [ebp+var_8+3], 1
.text:00001344                 jmp     short loc_135F
.text:00001346 ; ---------------------------------------------------------------------------
.text:00001346
.text:00001346 loc_1346:                               ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+4Aj
.text:00001346                 mov     ecx, [ebp+var_C]
.text:00001349                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000134E                 push    eax             ; wchar_t *
.text:0000134F                 call    ?IsDrivePath2@NName@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NName::IsDrivePath2(wchar_t const *)
.text:00001354                 movzx   edx, al
.text:00001357                 test    edx, edx
.text:00001359                 jz      short loc_135F
.text:0000135B                 mov     byte ptr [ebp+var_8+3], 1
.text:0000135F
.text:0000135F loc_135F:                               ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+2Ej
.text:0000135F                                         ; CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+50j ...
.text:0000135F                 mov     eax, [ebp+var_4]
.text:00001362                 cmp     dword ptr [eax+54h], 3
.text:00001366                 jnz     short loc_137A
.text:00001368                 movzx   ecx, byte ptr [ebp+var_8+3]
.text:0000136C                 test    ecx, ecx
.text:0000136E                 jz      short loc_137A
.text:00001370                 mov     ecx, [ebp+arg_4] ; this
.text:00001373                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:00001378                 jmp     short loc_1389
.text:0000137A ; ---------------------------------------------------------------------------
.text:0000137A
.text:0000137A loc_137A:                               ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+72j
.text:0000137A                                         ; CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+7Aj
.text:0000137A                 mov     edx, [ebp+var_4]
.text:0000137D                 add     edx, 3Ch ; '<'
.text:00001380                 push    edx
.text:00001381                 mov     ecx, [ebp+arg_4]
.text:00001384                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00001389
.text:00001389 loc_1389:                               ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+84j
.text:00001389                 mov     [ebp+var_10], 0
.text:00001390                 jmp     short loc_139B
.text:00001392 ; ---------------------------------------------------------------------------
.text:00001392
.text:00001392 loc_1392:                               ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+10Ej
.text:00001392                                         ; CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+11Ej
.text:00001392                 mov     eax, [ebp+var_10]
.text:00001395                 add     eax, 1
.text:00001398                 mov     [ebp+var_10], eax
.text:0000139B
.text:0000139B loc_139B:                               ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+9Cj
.text:0000139B                 mov     ecx, [ebp+arg_0]
.text:0000139E                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000013A3                 cmp     [ebp+var_10], eax
.text:000013A6                 jnb     short loc_1417
.text:000013A8                 cmp     [ebp+var_10], 0
.text:000013AC                 jz      short loc_13B6
.text:000013AE                 mov     ecx, [ebp+arg_4] ; this
.text:000013B1                 call    ?Add_PathSepar@UString@@QAEXXZ ; UString::Add_PathSepar(void)
.text:000013B6
.text:000013B6 loc_13B6:                               ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+B8j
.text:000013B6                 mov     ecx, [ebp+var_10]
.text:000013B9                 push    ecx
.text:000013BA                 mov     ecx, [ebp+arg_0]
.text:000013BD                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000013C2                 mov     [ebp+var_14], eax
.text:000013C5                 mov     edx, [ebp+var_14]
.text:000013C8                 push    edx
.text:000013C9                 mov     ecx, [ebp+arg_4]
.text:000013CC                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:000013D1                 mov     eax, [ebp+var_4]
.text:000013D4                 cmp     dword ptr [eax+54h], 3
.text:000013D8                 jnz     short loc_1404
.text:000013DA                 cmp     [ebp+var_10], 0
.text:000013DE                 jnz     short loc_1404
.text:000013E0                 mov     ecx, [ebp+var_14] ; this
.text:000013E3                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000013E8                 cmp     eax, 2
.text:000013EB                 jnz     short loc_1404
.text:000013ED                 mov     ecx, [ebp+var_14]
.text:000013F0                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000013F5                 push    eax             ; this
.text:000013F6                 call    ?IsDrivePath2@NName@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NName::IsDrivePath2(wchar_t const *)
.text:000013FB                 movzx   ecx, al
.text:000013FE                 test    ecx, ecx
.text:00001400                 jz      short loc_1404
.text:00001402                 jmp     short loc_1392
.text:00001404 ; ---------------------------------------------------------------------------
.text:00001404
.text:00001404 loc_1404:                               ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+E4j
.text:00001404                                         ; CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+EAj ...
.text:00001404                 mov     ecx, [ebp+arg_4]
.text:00001407                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000140C                 push    eax             ; this
.text:0000140D                 call    ?CreateDir@NDir@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NDir::CreateDir(wchar_t const *)
.text:00001412                 jmp     loc_1392
.text:00001417 ; ---------------------------------------------------------------------------
.text:00001417
.text:00001417 loc_1417:                               ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+B2j
.text:00001417                 add     esp, 14h
.text:0000141A                 cmp     ebp, esp
.text:0000141C                 call    __RTC_CheckEsp
.text:00001421                 mov     esp, ebp
.text:00001423                 pop     ebp
.text:00001424                 retn    8
.text:00001424 ?CreateComplexDirectory@CArchiveExtractCallback@@AAEXABV?$CObjectVector@VUString@@@@AAVUString@@@Z endp ; sp-analysis failed
.text:00001424
.text:00001424 ; ---------------------------------------------------------------------------
.text:00001427                 db 0Dh dup(0CCh)
.text:00001434
.text:00001434 ; =============== S U B R O U T I N E =======================================
.text:00001434
.text:00001434 ; Attributes: bp-based frame
.text:00001434
.text:00001434 ; __int32 __thiscall CArchiveExtractCallback::GetTime(CArchiveExtractCallback *this, int, unsigned __int32, struct _FILETIME *, bool *)
.text:00001434                 public ?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z
.text:00001434 ?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z proc near
.text:00001434                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+116Ep
.text:00001434                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+11DDp ...
.text:00001434
.text:00001434 var_40          = dword ptr -40h
.text:00001434 var_3C          = dword ptr -3Ch
.text:00001434 var_38          = dword ptr -38h
.text:00001434 var_34          = dword ptr -34h
.text:00001434 var_30          = dword ptr -30h
.text:00001434 var_2C          = dword ptr -2Ch
.text:00001434 var_24          = word ptr -24h
.text:00001434 var_1C          = dword ptr -1Ch
.text:00001434 var_18          = dword ptr -18h
.text:00001434 var_10          = dword ptr -10h
.text:00001434 var_C           = dword ptr -0Ch
.text:00001434 var_4           = dword ptr -4
.text:00001434 arg_0           = dword ptr  8
.text:00001434 arg_4           = dword ptr  0Ch
.text:00001434 arg_8           = dword ptr  10h
.text:00001434 arg_C           = dword ptr  14h
.text:00001434
.text:00001434                 push    ebp
.text:00001435                 mov     ebp, esp
.text:00001437                 push    0FFFFFFFFh
.text:00001439                 push    offset __ehhandler$?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z
.text:0000143E                 mov     eax, large fs:0
.text:00001444                 push    eax
.text:00001445                 sub     esp, 34h
.text:00001448                 push    esi
.text:00001449                 push    edi
.text:0000144A                 push    ecx
.text:0000144B                 lea     edi, [ebp+var_40]
.text:0000144E                 mov     ecx, 0Dh
.text:00001453                 mov     eax, 0CCCCCCCCh
.text:00001458                 rep stosd
.text:0000145A                 pop     ecx
.text:0000145B                 mov     eax, dword ptr ds:___security_cookie
.text:00001460                 xor     eax, ebp
.text:00001462                 push    eax
.text:00001463                 lea     eax, [ebp+var_C]
.text:00001466                 mov     large fs:0, eax
.text:0000146C                 mov     [ebp+var_10], ecx
.text:0000146F                 mov     eax, [ebp+arg_C]
.text:00001472                 mov     byte ptr [eax], 0
.text:00001475                 lea     ecx, [ebp+var_24] ; this
.text:00001478                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:0000147D                 mov     [ebp+var_4], 0
.text:00001484                 mov     ecx, [ebp+var_10]
.text:00001487                 mov     ecx, [ecx+14h]
.text:0000148A                 call    ??C?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ ; CMyComPtr<IInArchive>::operator->(void)
.text:0000148F                 mov     [ebp+var_3C], eax
.text:00001492                 mov     esi, esp
.text:00001494                 lea     edx, [ebp+var_24]
.text:00001497                 push    edx
.text:00001498                 mov     eax, [ebp+arg_4]
.text:0000149B                 push    eax
.text:0000149C                 mov     ecx, [ebp+arg_0]
.text:0000149F                 push    ecx
.text:000014A0                 mov     edx, [ebp+var_3C]
.text:000014A3                 push    edx
.text:000014A4                 mov     eax, [ebp+var_3C]
.text:000014A7                 mov     ecx, [eax]
.text:000014A9                 mov     edx, [ecx+18h]
.text:000014AC                 call    edx
.text:000014AE                 cmp     esi, esp
.text:000014B0                 call    __RTC_CheckEsp
.text:000014B5                 mov     [ebp+var_2C], eax
.text:000014B8                 cmp     [ebp+var_2C], 0
.text:000014BC                 jz      short loc_14D8
.text:000014BE                 mov     eax, [ebp+var_2C]
.text:000014C1                 mov     [ebp+var_30], eax
.text:000014C4                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000014CB                 lea     ecx, [ebp+var_24] ; this
.text:000014CE                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000014D3                 mov     eax, [ebp+var_30]
.text:000014D6                 jmp     short loc_1556
.text:000014D8 ; ---------------------------------------------------------------------------
.text:000014D8
.text:000014D8 loc_14D8:                               ; CODE XREF: CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+88j
.text:000014D8                 movzx   ecx, [ebp+var_24]
.text:000014DC                 cmp     ecx, 40h ; '@'
.text:000014DF                 jnz     short loc_151A
.text:000014E1                 mov     edx, [ebp+arg_8]
.text:000014E4                 mov     eax, [ebp+var_1C]
.text:000014E7                 mov     [edx], eax
.text:000014E9                 mov     ecx, [ebp+var_18]
.text:000014EC                 mov     [edx+4], ecx
.text:000014EF                 mov     edx, [ebp+arg_8]
.text:000014F2                 cmp     dword ptr [edx+4], 0
.text:000014F6                 jnz     short loc_1509
.text:000014F8                 mov     eax, [ebp+arg_8]
.text:000014FB                 cmp     dword ptr [eax], 0
.text:000014FE                 jnz     short loc_1509
.text:00001500                 mov     [ebp+var_40], 0
.text:00001507                 jmp     short loc_1510
.text:00001509 ; ---------------------------------------------------------------------------
.text:00001509
.text:00001509 loc_1509:                               ; CODE XREF: CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+C2j
.text:00001509                                         ; CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+CAj
.text:00001509                 mov     [ebp+var_40], 1
.text:00001510
.text:00001510 loc_1510:                               ; CODE XREF: CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+D3j
.text:00001510                 mov     ecx, [ebp+arg_C]
.text:00001513                 mov     dl, byte ptr [ebp+var_40]
.text:00001516                 mov     [ecx], dl
.text:00001518                 jmp     short loc_153D
.text:0000151A ; ---------------------------------------------------------------------------
.text:0000151A
.text:0000151A loc_151A:                               ; CODE XREF: CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+ABj
.text:0000151A                 movzx   eax, [ebp+var_24]
.text:0000151E                 test    eax, eax
.text:00001520                 jz      short loc_153D
.text:00001522                 mov     [ebp+var_34], 80004005h
.text:00001529                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001530                 lea     ecx, [ebp+var_24] ; this
.text:00001533                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00001538                 mov     eax, [ebp+var_34]
.text:0000153B                 jmp     short loc_1556
.text:0000153D ; ---------------------------------------------------------------------------
.text:0000153D
.text:0000153D loc_153D:                               ; CODE XREF: CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+E4j
.text:0000153D                                         ; CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+ECj
.text:0000153D                 mov     [ebp+var_38], 0
.text:00001544                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000154B                 lea     ecx, [ebp+var_24] ; this
.text:0000154E                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00001553                 mov     eax, [ebp+var_38]
.text:00001556
.text:00001556 loc_1556:                               ; CODE XREF: CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+A2j
.text:00001556                                         ; CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+107j
.text:00001556                 push    edx
.text:00001557                 mov     ecx, ebp
.text:00001559                 push    eax
.text:0000155A                 lea     edx, $LN13
.text:00001560                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001565                 pop     eax
.text:00001566                 pop     edx
.text:00001567                 mov     ecx, [ebp+var_C]
.text:0000156A                 mov     large fs:0, ecx
.text:00001571                 pop     ecx
.text:00001572                 pop     edi
.text:00001573                 pop     esi
.text:00001574                 add     esp, 40h
.text:00001577                 cmp     ebp, esp
.text:00001579                 call    __RTC_CheckEsp
.text:0000157E                 mov     esp, ebp
.text:00001580                 pop     ebp
.text:00001581                 retn    10h
.text:00001581 ?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z endp
.text:00001581
.text:00001581 ; ---------------------------------------------------------------------------
.text:00001584 $LN13           dd 1                    ; DATA XREF: CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+126o
.text:00001588                 dd offset $LN12_2
.text:0000158C $LN12_2         dd 0FFFFFFDCh, 10h      ; DATA XREF: .text:00001588o
.text:00001594                 dd offset $LN10_1       ; "prop"
.text:00001598 $LN10_1         db 'prop',0             ; DATA XREF: .text:00001594o
.text:0000159D                 db 7 dup(0CCh)
.text:000015A4
.text:000015A4 ; =============== S U B R O U T I N E =======================================
.text:000015A4
.text:000015A4 ; Attributes: bp-based frame
.text:000015A4
.text:000015A4 ; __int32 __thiscall CArchiveExtractCallback::GetUnpackSize(CArchiveExtractCallback *__hidden this)
.text:000015A4                 public ?GetUnpackSize@CArchiveExtractCallback@@AAEJXZ
.text:000015A4 ?GetUnpackSize@CArchiveExtractCallback@@AAEJXZ proc near
.text:000015A4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+880p
.text:000015A4                                         ; CArchiveExtractCallback::SetOperationResult(int)+39Dp
.text:000015A4
.text:000015A4 var_4           = dword ptr -4
.text:000015A4
.text:000015A4                 push    ebp
.text:000015A5                 mov     ebp, esp
.text:000015A7                 push    ecx
.text:000015A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000015AF                 mov     [ebp+var_4], ecx
.text:000015B2                 mov     eax, [ebp+var_4]
.text:000015B5                 add     eax, 0F8h ; '°'
.text:000015BA                 push    eax             ; bool *
.text:000015BB                 mov     ecx, [ebp+var_4]
.text:000015BE                 add     ecx, 0F0h ; '='
.text:000015C4                 push    ecx             ; unsigned __int64 *
.text:000015C5                 mov     edx, [ebp+var_4]
.text:000015C8                 mov     eax, [edx+0E8h]
.text:000015CE                 push    eax             ; unsigned int
.text:000015CF                 mov     ecx, [ebp+var_4]
.text:000015D2                 mov     ecx, [ecx+14h]  ; this
.text:000015D5                 call    ?GetItemSize@CArc@@QBEJIAA_KAA_N@Z ; CArc::GetItemSize(uint,unsigned __int64 &,bool &)
.text:000015DA                 add     esp, 4
.text:000015DD                 cmp     ebp, esp
.text:000015DF                 call    __RTC_CheckEsp
.text:000015E4                 mov     esp, ebp
.text:000015E6                 pop     ebp
.text:000015E7                 retn
.text:000015E7 ?GetUnpackSize@CArchiveExtractCallback@@AAEJXZ endp
.text:000015E7
.text:000015E7 ; ---------------------------------------------------------------------------
.text:000015E8                 db 0Ch dup(0CCh)
.text:000015F4
.text:000015F4 ; =============== S U B R O U T I N E =======================================
.text:000015F4
.text:000015F4 ; Attributes: bp-based frame
.text:000015F4
.text:000015F4 ; __int32 __thiscall CArchiveExtractCallback::SendMessageError(CArchiveExtractCallback *this, const char *, const struct UString *)
.text:000015F4                 public ?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z
.text:000015F4 ?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z proc near
.text:000015F4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1E03p
.text:000015F4                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1F46p ...
.text:000015F4
.text:000015F4 var_2C          = dword ptr -2Ch
.text:000015F4 var_28          = dword ptr -28h
.text:000015F4 var_24          = dword ptr -24h
.text:000015F4 var_20          = dword ptr -20h
.text:000015F4 var_1C          = dword ptr -1Ch
.text:000015F4 var_18          = dword ptr -18h
.text:000015F4 var_14          = dword ptr -14h
.text:000015F4 var_10          = dword ptr -10h
.text:000015F4 var_C           = dword ptr -0Ch
.text:000015F4 var_4           = dword ptr -4
.text:000015F4 arg_0           = dword ptr  8
.text:000015F4 arg_4           = dword ptr  0Ch
.text:000015F4
.text:000015F4                 push    ebp
.text:000015F5                 mov     ebp, esp
.text:000015F7                 push    0FFFFFFFFh
.text:000015F9                 push    offset __ehhandler$?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z
.text:000015FE                 mov     eax, large fs:0
.text:00001604                 push    eax
.text:00001605                 sub     esp, 20h
.text:00001608                 push    esi
.text:00001609                 mov     eax, 0CCCCCCCCh
.text:0000160E                 mov     [ebp+var_2C], eax
.text:00001611                 mov     [ebp+var_28], eax
.text:00001614                 mov     [ebp+var_24], eax
.text:00001617                 mov     [ebp+var_20], eax
.text:0000161A                 mov     [ebp+var_1C], eax
.text:0000161D                 mov     [ebp+var_18], eax
.text:00001620                 mov     [ebp+var_14], eax
.text:00001623                 mov     [ebp+var_10], eax
.text:00001626                 mov     eax, dword ptr ds:___security_cookie
.text:0000162B                 xor     eax, ebp
.text:0000162D                 push    eax
.text:0000162E                 lea     eax, [ebp+var_C]
.text:00001631                 mov     large fs:0, eax
.text:00001637                 mov     [ebp+var_10], ecx
.text:0000163A                 lea     ecx, [ebp+var_20]
.text:0000163D                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00001642                 mov     [ebp+var_4], 0
.text:00001649                 mov     eax, [ebp+arg_0]
.text:0000164C                 push    eax             ; char *
.text:0000164D                 lea     ecx, [ebp+var_20] ; this
.text:00001650                 call    ?AddAscii@UString@@QAEXPBD@Z ; UString::AddAscii(char const *)
.text:00001655                 mov     ecx, [ebp+arg_4]
.text:00001658                 push    ecx             ; int
.text:00001659                 lea     edx, [ebp+var_20]
.text:0000165C                 push    edx             ; UString *
.text:0000165D                 call    ?AddPathToMessage@@YGXAAVUString@@ABV1@@Z ; AddPathToMessage(UString &,UString const &)
.text:00001662                 mov     ecx, [ebp+var_10]
.text:00001665                 add     ecx, 28h ; '('
.text:00001668                 call    ??C?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::operator->(void)
.text:0000166D                 mov     [ebp+var_2C], eax
.text:00001670                 lea     ecx, [ebp+var_20]
.text:00001673                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001678                 mov     esi, esp
.text:0000167A                 push    eax
.text:0000167B                 mov     eax, [ebp+var_2C]
.text:0000167E                 push    eax
.text:0000167F                 mov     ecx, [ebp+var_2C]
.text:00001682                 mov     edx, [ecx]
.text:00001684                 mov     eax, [edx+1Ch]
.text:00001687                 call    eax
.text:00001689                 cmp     esi, esp
.text:0000168B                 call    __RTC_CheckEsp
.text:00001690                 mov     [ebp+var_28], eax
.text:00001693                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000169A                 lea     ecx, [ebp+var_20] ; this
.text:0000169D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000016A2                 mov     eax, [ebp+var_28]
.text:000016A5                 push    edx
.text:000016A6                 mov     ecx, ebp
.text:000016A8                 push    eax
.text:000016A9                 lea     edx, $LN7_2
.text:000016AF                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000016B4                 pop     eax
.text:000016B5                 pop     edx
.text:000016B6                 mov     ecx, [ebp+var_C]
.text:000016B9                 mov     large fs:0, ecx
.text:000016C0                 pop     ecx
.text:000016C1                 pop     esi
.text:000016C2                 add     esp, 2Ch
.text:000016C5                 cmp     ebp, esp
.text:000016C7                 call    __RTC_CheckEsp
.text:000016CC                 mov     esp, ebp
.text:000016CE                 pop     ebp
.text:000016CF                 retn    8
.text:000016CF ?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z endp
.text:000016CF
.text:000016CF ; ---------------------------------------------------------------------------
.text:000016D2                 align 4
.text:000016D4 $LN7_2          dd 1                    ; DATA XREF: CArchiveExtractCallback::SendMessageError(char const *,UString const &)+B5o
.text:000016D8                 dd offset $LN6_0
.text:000016DC $LN6_0          dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:000016D8o
.text:000016E4                 dd offset $LN4_0
.text:000016E8 $LN4_0          dd 0CCCC0073h, 2 dup(0CCCCCCCCh) ; DATA XREF: .text:000016E4o
.text:000016F4
.text:000016F4 ; =============== S U B R O U T I N E =======================================
.text:000016F4
.text:000016F4 ; Attributes: bp-based frame
.text:000016F4
.text:000016F4 ; int __stdcall AddPathToMessage(UString *, int)
.text:000016F4 ?AddPathToMessage@@YGXAAVUString@@ABV1@@Z proc near
.text:000016F4                                         ; CODE XREF: CArchiveExtractCallback::SendMessageError(char const *,UString const &)+69p
.text:000016F4                                         ; CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)+B5p ...
.text:000016F4
.text:000016F4 arg_0           = dword ptr  8
.text:000016F4 arg_4           = dword ptr  0Ch
.text:000016F4
.text:000016F4                 push    ebp
.text:000016F5                 mov     ebp, esp
.text:000016F7                 push    offset $SG76325 ; " : "
.text:000016FC                 mov     ecx, [ebp+arg_0] ; this
.text:000016FF                 call    ?AddAscii@UString@@QAEXPBD@Z ; UString::AddAscii(char const *)
.text:00001704                 mov     eax, [ebp+arg_4]
.text:00001707                 push    eax
.text:00001708                 mov     ecx, [ebp+arg_0]
.text:0000170B                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00001710                 cmp     ebp, esp
.text:00001712                 call    __RTC_CheckEsp
.text:00001717                 pop     ebp
.text:00001718                 retn    8
.text:00001718 ?AddPathToMessage@@YGXAAVUString@@ABV1@@Z endp
.text:00001718
.text:00001718 ; ---------------------------------------------------------------------------
.text:0000171B                 db 9 dup(0CCh)
.text:00001724
.text:00001724 ; =============== S U B R O U T I N E =======================================
.text:00001724
.text:00001724 ; Attributes: bp-based frame
.text:00001724
.text:00001724 ; __int32 __thiscall CArchiveExtractCallback::SendMessageError_with_LastError(CArchiveExtractCallback *this, const char *, const struct UString *)
.text:00001724                 public ?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z
.text:00001724 ?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z proc near
.text:00001724                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2213p
.text:00001724                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+234Cp ...
.text:00001724
.text:00001724 var_44          = dword ptr -44h
.text:00001724 var_40          = dword ptr -40h
.text:00001724 var_3C          = dword ptr -3Ch
.text:00001724 var_38          = dword ptr -38h
.text:00001724 var_34          = byte ptr -34h
.text:00001724 var_24          = byte ptr -24h
.text:00001724 var_14          = dword ptr -14h
.text:00001724 var_10          = dword ptr -10h
.text:00001724 var_C           = dword ptr -0Ch
.text:00001724 var_4           = dword ptr -4
.text:00001724 arg_0           = dword ptr  8
.text:00001724 arg_4           = dword ptr  0Ch
.text:00001724
.text:00001724                 push    ebp
.text:00001725                 mov     ebp, esp
.text:00001727                 push    0FFFFFFFFh
.text:00001729                 push    offset __ehhandler$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z
.text:0000172E                 mov     eax, large fs:0
.text:00001734                 push    eax
.text:00001735                 sub     esp, 38h
.text:00001738                 push    esi
.text:00001739                 push    edi
.text:0000173A                 push    ecx
.text:0000173B                 lea     edi, [ebp+var_44]
.text:0000173E                 mov     ecx, 0Eh
.text:00001743                 mov     eax, 0CCCCCCCCh
.text:00001748                 rep stosd
.text:0000174A                 pop     ecx
.text:0000174B                 mov     eax, dword ptr ds:___security_cookie
.text:00001750                 xor     eax, ebp
.text:00001752                 push    eax
.text:00001753                 lea     eax, [ebp+var_C]
.text:00001756                 mov     large fs:0, eax
.text:0000175C                 mov     [ebp+var_10], ecx
.text:0000175F                 mov     esi, esp
.text:00001761                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text:00001767                 cmp     esi, esp
.text:00001769                 call    __RTC_CheckEsp
.text:0000176E                 mov     [ebp+var_14], eax
.text:00001771                 lea     ecx, [ebp+var_24]
.text:00001774                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00001779                 mov     [ebp+var_4], 0
.text:00001780                 mov     eax, [ebp+arg_0]
.text:00001783                 push    eax             ; char *
.text:00001784                 lea     ecx, [ebp+var_24] ; this
.text:00001787                 call    ?AddAscii@UString@@QAEXPBD@Z ; UString::AddAscii(char const *)
.text:0000178C                 cmp     [ebp+var_14], 0
.text:00001790                 jz      short loc_17D1
.text:00001792                 push    offset $SG76341 ; " : "
.text:00001797                 lea     ecx, [ebp+var_24] ; this
.text:0000179A                 call    ?AddAscii@UString@@QAEXPBD@Z ; UString::AddAscii(char const *)
.text:0000179F                 mov     ecx, [ebp+var_14]
.text:000017A2                 push    ecx
.text:000017A3                 lea     edx, [ebp+var_34]
.text:000017A6                 push    edx
.text:000017A7                 call    ?MyFormatMessage@NError@NWindows@@YG?AVUString@@K@Z ; NWindows::NError::MyFormatMessage(ulong)
.text:000017AC                 mov     [ebp+var_3C], eax
.text:000017AF                 mov     eax, [ebp+var_3C]
.text:000017B2                 mov     [ebp+var_40], eax
.text:000017B5                 mov     byte ptr [ebp+var_4], 1
.text:000017B9                 mov     ecx, [ebp+var_40]
.text:000017BC                 push    ecx
.text:000017BD                 lea     ecx, [ebp+var_24]
.text:000017C0                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:000017C5                 mov     byte ptr [ebp+var_4], 0
.text:000017C9                 lea     ecx, [ebp+var_34] ; this
.text:000017CC                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000017D1
.text:000017D1 loc_17D1:                               ; CODE XREF: CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)+6Cj
.text:000017D1                 mov     edx, [ebp+arg_4]
.text:000017D4                 push    edx             ; int
.text:000017D5                 lea     eax, [ebp+var_24]
.text:000017D8                 push    eax             ; UString *
.text:000017D9                 call    ?AddPathToMessage@@YGXAAVUString@@ABV1@@Z ; AddPathToMessage(UString &,UString const &)
.text:000017DE                 mov     ecx, [ebp+var_10]
.text:000017E1                 add     ecx, 28h ; '('
.text:000017E4                 call    ??C?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::operator->(void)
.text:000017E9                 mov     [ebp+var_44], eax
.text:000017EC                 lea     ecx, [ebp+var_24]
.text:000017EF                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000017F4                 mov     esi, esp
.text:000017F6                 push    eax
.text:000017F7                 mov     ecx, [ebp+var_44]
.text:000017FA                 push    ecx
.text:000017FB                 mov     edx, [ebp+var_44]
.text:000017FE                 mov     eax, [edx]
.text:00001800                 mov     ecx, [eax+1Ch]
.text:00001803                 call    ecx
.text:00001805                 cmp     esi, esp
.text:00001807                 call    __RTC_CheckEsp
.text:0000180C                 mov     [ebp+var_38], eax
.text:0000180F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001816                 lea     ecx, [ebp+var_24] ; this
.text:00001819                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000181E                 mov     eax, [ebp+var_38]
.text:00001821                 push    edx
.text:00001822                 mov     ecx, ebp
.text:00001824                 push    eax
.text:00001825                 lea     edx, $LN9_1
.text:0000182B                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001830                 pop     eax
.text:00001831                 pop     edx
.text:00001832                 mov     ecx, [ebp+var_C]
.text:00001835                 mov     large fs:0, ecx
.text:0000183C                 pop     ecx
.text:0000183D                 pop     edi
.text:0000183E                 pop     esi
.text:0000183F                 add     esp, 44h
.text:00001842                 cmp     ebp, esp
.text:00001844                 call    __RTC_CheckEsp
.text:00001849                 mov     esp, ebp
.text:0000184B                 pop     ebp
.text:0000184C                 retn    8
.text:0000184C ?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z endp
.text:0000184C
.text:0000184C ; ---------------------------------------------------------------------------
.text:0000184F                 align 10h
.text:00001850 $LN9_1          dd 1                    ; DATA XREF: CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)+101o
.text:00001854                 dd offset $LN8_3
.text:00001858 $LN8_3          dd 0FFFFFFDCh, 0Ch      ; DATA XREF: .text:00001854o
.text:00001860                 dd offset $LN6_1
.text:00001864 $LN6_1          dd 0CCCC0073h, 3 dup(0CCCCCCCCh) ; DATA XREF: .text:00001860o
.text:00001874
.text:00001874 ; =============== S U B R O U T I N E =======================================
.text:00001874
.text:00001874 ; Attributes: bp-based frame
.text:00001874
.text:00001874 ; __int32 __thiscall CArchiveExtractCallback::SendMessageError2(CArchiveExtractCallback *this, const char *, const struct UString *, const struct UString *)
.text:00001874                 public ?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z
.text:00001874 ?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z proc near
.text:00001874                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+20A2p
.text:00001874                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2899p ...
.text:00001874
.text:00001874 var_2C          = dword ptr -2Ch
.text:00001874 var_28          = dword ptr -28h
.text:00001874 var_24          = dword ptr -24h
.text:00001874 var_20          = dword ptr -20h
.text:00001874 var_1C          = dword ptr -1Ch
.text:00001874 var_18          = dword ptr -18h
.text:00001874 var_14          = dword ptr -14h
.text:00001874 var_10          = dword ptr -10h
.text:00001874 var_C           = dword ptr -0Ch
.text:00001874 var_4           = dword ptr -4
.text:00001874 arg_0           = dword ptr  8
.text:00001874 arg_4           = dword ptr  0Ch
.text:00001874 arg_8           = dword ptr  10h
.text:00001874
.text:00001874                 push    ebp
.text:00001875                 mov     ebp, esp
.text:00001877                 push    0FFFFFFFFh
.text:00001879                 push    offset __ehhandler$?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z
.text:0000187E                 mov     eax, large fs:0
.text:00001884                 push    eax
.text:00001885                 sub     esp, 20h
.text:00001888                 push    esi
.text:00001889                 mov     eax, 0CCCCCCCCh
.text:0000188E                 mov     [ebp+var_2C], eax
.text:00001891                 mov     [ebp+var_28], eax
.text:00001894                 mov     [ebp+var_24], eax
.text:00001897                 mov     [ebp+var_20], eax
.text:0000189A                 mov     [ebp+var_1C], eax
.text:0000189D                 mov     [ebp+var_18], eax
.text:000018A0                 mov     [ebp+var_14], eax
.text:000018A3                 mov     [ebp+var_10], eax
.text:000018A6                 mov     eax, dword ptr ds:___security_cookie
.text:000018AB                 xor     eax, ebp
.text:000018AD                 push    eax
.text:000018AE                 lea     eax, [ebp+var_C]
.text:000018B1                 mov     large fs:0, eax
.text:000018B7                 mov     [ebp+var_10], ecx
.text:000018BA                 lea     ecx, [ebp+var_20]
.text:000018BD                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000018C2                 mov     [ebp+var_4], 0
.text:000018C9                 mov     eax, [ebp+arg_0]
.text:000018CC                 push    eax             ; char *
.text:000018CD                 lea     ecx, [ebp+var_20] ; this
.text:000018D0                 call    ?AddAscii@UString@@QAEXPBD@Z ; UString::AddAscii(char const *)
.text:000018D5                 mov     ecx, [ebp+arg_4]
.text:000018D8                 push    ecx             ; int
.text:000018D9                 lea     edx, [ebp+var_20]
.text:000018DC                 push    edx             ; UString *
.text:000018DD                 call    ?AddPathToMessage@@YGXAAVUString@@ABV1@@Z ; AddPathToMessage(UString &,UString const &)
.text:000018E2                 mov     eax, [ebp+arg_8]
.text:000018E5                 push    eax             ; int
.text:000018E6                 lea     ecx, [ebp+var_20]
.text:000018E9                 push    ecx             ; UString *
.text:000018EA                 call    ?AddPathToMessage@@YGXAAVUString@@ABV1@@Z ; AddPathToMessage(UString &,UString const &)
.text:000018EF                 mov     ecx, [ebp+var_10]
.text:000018F2                 add     ecx, 28h ; '('
.text:000018F5                 call    ??C?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::operator->(void)
.text:000018FA                 mov     [ebp+var_2C], eax
.text:000018FD                 lea     ecx, [ebp+var_20]
.text:00001900                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001905                 mov     esi, esp
.text:00001907                 push    eax
.text:00001908                 mov     edx, [ebp+var_2C]
.text:0000190B                 push    edx
.text:0000190C                 mov     eax, [ebp+var_2C]
.text:0000190F                 mov     ecx, [eax]
.text:00001911                 mov     edx, [ecx+1Ch]
.text:00001914                 call    edx
.text:00001916                 cmp     esi, esp
.text:00001918                 call    __RTC_CheckEsp
.text:0000191D                 mov     [ebp+var_28], eax
.text:00001920                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001927                 lea     ecx, [ebp+var_20] ; this
.text:0000192A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000192F                 mov     eax, [ebp+var_28]
.text:00001932                 push    edx
.text:00001933                 mov     ecx, ebp
.text:00001935                 push    eax
.text:00001936                 lea     edx, $LN7_3
.text:0000193C                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001941                 pop     eax
.text:00001942                 pop     edx
.text:00001943                 mov     ecx, [ebp+var_C]
.text:00001946                 mov     large fs:0, ecx
.text:0000194D                 pop     ecx
.text:0000194E                 pop     esi
.text:0000194F                 add     esp, 2Ch
.text:00001952                 cmp     ebp, esp
.text:00001954                 call    __RTC_CheckEsp
.text:00001959                 mov     esp, ebp
.text:0000195B                 pop     ebp
.text:0000195C                 retn    0Ch
.text:0000195C ?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z endp
.text:0000195C
.text:0000195C ; ---------------------------------------------------------------------------
.text:0000195F                 align 10h
.text:00001960 $LN7_3          dd 1                    ; DATA XREF: CArchiveExtractCallback::SendMessageError2(char const *,UString const &,UString const &)+C2o
.text:00001964                 dd offset $LN6_2
.text:00001968 $LN6_2          dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:00001964o
.text:00001970                 dd offset $LN4_1
.text:00001974 $LN4_1          dd 0CCCC0073h, 3 dup(0CCCCCCCCh) ; DATA XREF: .text:00001970o
.text:00001984
.text:00001984 ; =============== S U B R O U T I N E =======================================
.text:00001984
.text:00001984 ; Attributes: bp-based frame
.text:00001984
.text:00001984 ; __int32 __stdcall CGetProp::GetPropA(CGetProp *this, unsigned __int32, struct tagPROPVARIANT *)
.text:00001984                 public ?GetPropA@CGetProp@@UAGJKPAUtagPROPVARIANT@@@Z
.text:00001984 ?GetPropA@CGetProp@@UAGJKPAUtagPROPVARIANT@@@Z proc near
.text:00001984                                         ; DATA XREF: .rdata:0000906Co
.text:00001984
.text:00001984 var_4           = dword ptr -4
.text:00001984 this            = dword ptr  8
.text:00001984 arg_4           = dword ptr  0Ch
.text:00001984 arg_8           = dword ptr  10h
.text:00001984
.text:00001984                 push    ebp
.text:00001985                 mov     ebp, esp
.text:00001987                 push    ecx
.text:00001988                 push    esi
.text:00001989                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001990                 mov     eax, [ebp+this]
.text:00001993                 mov     ecx, [eax+8]
.text:00001996                 call    ??C?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ ; CMyComPtr<IInArchive>::operator->(void)
.text:0000199B                 mov     [ebp+var_4], eax
.text:0000199E                 mov     esi, esp
.text:000019A0                 mov     ecx, [ebp+arg_8]
.text:000019A3                 push    ecx
.text:000019A4                 mov     edx, [ebp+arg_4]
.text:000019A7                 push    edx
.text:000019A8                 mov     eax, [ebp+this]
.text:000019AB                 mov     ecx, [eax+0Ch]
.text:000019AE                 push    ecx
.text:000019AF                 mov     edx, [ebp+var_4]
.text:000019B2                 push    edx
.text:000019B3                 mov     eax, [ebp+var_4]
.text:000019B6                 mov     ecx, [eax]
.text:000019B8                 mov     edx, [ecx+18h]
.text:000019BB                 call    edx
.text:000019BD                 cmp     esi, esp
.text:000019BF                 call    __RTC_CheckEsp
.text:000019C4                 pop     esi
.text:000019C5                 add     esp, 4
.text:000019C8                 cmp     ebp, esp
.text:000019CA                 call    __RTC_CheckEsp
.text:000019CF                 mov     esp, ebp
.text:000019D1                 pop     ebp
.text:000019D2                 retn    0Ch
.text:000019D2 ?GetPropA@CGetProp@@UAGJKPAUtagPROPVARIANT@@@Z endp
.text:000019D2
.text:000019D2 ; ---------------------------------------------------------------------------
.text:000019D5                 db 0Fh dup(0CCh)
.text:000019E4
.text:000019E4 ; =============== S U B R O U T I N E =======================================
.text:000019E4
.text:000019E4 ; Attributes: bp-based frame
.text:000019E4
.text:000019E4 ; bool __stdcall CensorNode_CheckPath2(const struct NWildcard::CCensorNode *, const struct CReadArcItem *, bool *)
.text:000019E4                 public ?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z
.text:000019E4 ?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z proc near
.text:000019E4                                         ; CODE XREF: CensorNode_CheckPath(NWildcard::CCensorNode const &,CReadArcItem const &)+27p
.text:000019E4
.text:000019E4 var_38          = byte ptr -38h
.text:000019E4 var_36          = byte ptr -36h
.text:000019E4 var_35          = byte ptr -35h
.text:000019E4 var_2D          = byte ptr -2Dh
.text:000019E4 var_28          = dword ptr -28h
.text:000019E4 var_20          = byte ptr -20h
.text:000019E4 var_D           = byte ptr -0Dh
.text:000019E4 var_C           = dword ptr -0Ch
.text:000019E4 var_4           = dword ptr -4
.text:000019E4 arg_0           = dword ptr  8
.text:000019E4 arg_4           = dword ptr  0Ch
.text:000019E4 arg_8           = dword ptr  10h
.text:000019E4
.text:000019E4                 push    ebp
.text:000019E5                 mov     ebp, esp
.text:000019E7                 push    0FFFFFFFFh
.text:000019E9                 push    offset __ehhandler$?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z
.text:000019EE                 mov     eax, large fs:0
.text:000019F4                 push    eax
.text:000019F5                 sub     esp, 2Ch
.text:000019F8                 push    edi
.text:000019F9                 lea     edi, [ebp+var_38]
.text:000019FC                 mov     ecx, 0Bh
.text:00001A01                 mov     eax, 0CCCCCCCCh
.text:00001A06                 rep stosd
.text:00001A08                 mov     eax, dword ptr ds:___security_cookie
.text:00001A0D                 xor     eax, ebp
.text:00001A0F                 push    eax
.text:00001A10                 lea     eax, [ebp+var_C]
.text:00001A13                 mov     large fs:0, eax
.text:00001A19                 mov     [ebp+var_D], 0
.text:00001A1D                 mov     eax, [ebp+arg_8]
.text:00001A20                 push    eax
.text:00001A21                 mov     ecx, [ebp+arg_4]
.text:00001A24                 movzx   edx, byte ptr [ecx+33h]
.text:00001A28                 test    edx, edx
.text:00001A2A                 setz    al
.text:00001A2D                 movzx   ecx, al
.text:00001A30                 push    ecx
.text:00001A31                 mov     edx, [ebp+arg_4]
.text:00001A34                 add     edx, 0Ch
.text:00001A37                 push    edx
.text:00001A38                 mov     ecx, [ebp+arg_0]
.text:00001A3B                 call    ?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z ; NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)
.text:00001A40                 movzx   eax, al
.text:00001A43                 test    eax, eax
.text:00001A45                 jz      short loc_1A6E
.text:00001A47                 mov     ecx, [ebp+arg_8]
.text:00001A4A                 movzx   edx, byte ptr [ecx]
.text:00001A4D                 test    edx, edx
.text:00001A4F                 jnz     short loc_1A58
.text:00001A51                 mov     al, 1
.text:00001A53                 jmp     loc_1B22
.text:00001A58 ; ---------------------------------------------------------------------------
.text:00001A58
.text:00001A58 loc_1A58:                               ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+6Bj
.text:00001A58                 mov     eax, [ebp+arg_4]
.text:00001A5B                 movzx   ecx, byte ptr [eax+30h]
.text:00001A5F                 test    ecx, ecx
.text:00001A61                 jnz     short loc_1A6A
.text:00001A63                 mov     al, 1
.text:00001A65                 jmp     loc_1B22
.text:00001A6A ; ---------------------------------------------------------------------------
.text:00001A6A
.text:00001A6A loc_1A6A:                               ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+7Dj
.text:00001A6A                 mov     [ebp+var_D], 1
.text:00001A6E
.text:00001A6E loc_1A6E:                               ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+61j
.text:00001A6E                 mov     edx, [ebp+arg_4]
.text:00001A71                 movzx   eax, byte ptr [edx+30h]
.text:00001A75                 test    eax, eax
.text:00001A77                 jnz     short loc_1A80
.text:00001A79                 xor     al, al
.text:00001A7B                 jmp     loc_1B22
.text:00001A80 ; ---------------------------------------------------------------------------
.text:00001A80
.text:00001A80 loc_1A80:                               ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+93j
.text:00001A80                 mov     ecx, [ebp+arg_4]
.text:00001A83                 add     ecx, 0Ch
.text:00001A86                 push    ecx
.text:00001A87                 lea     ecx, [ebp+var_20]
.text:00001A8A                 call    ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z ; CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)
.text:00001A8F                 mov     [ebp+var_4], 0
.text:00001A96                 lea     ecx, [ebp+var_20]
.text:00001A99                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:00001A9E                 movzx   edx, al
.text:00001AA1                 test    edx, edx
.text:00001AA3                 jz      short loc_1AAD
.text:00001AA5                 lea     ecx, [ebp+var_20]
.text:00001AA8                 call    ?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::AddNew(void)
.text:00001AAD
.text:00001AAD loc_1AAD:                               ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+BFj
.text:00001AAD                 lea     ecx, [ebp+var_20]
.text:00001AB0                 call    ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::Back(void)
.text:00001AB5                 mov     [ebp+var_28], eax
.text:00001AB8                 push    3Ah ; ':'
.text:00001ABA                 mov     ecx, [ebp+var_28]
.text:00001ABD                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:00001AC2                 mov     eax, [ebp+arg_4]
.text:00001AC5                 add     eax, 24h ; '$'
.text:00001AC8                 push    eax
.text:00001AC9                 mov     ecx, [ebp+var_28]
.text:00001ACC                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00001AD1                 lea     ecx, [ebp+var_2D]
.text:00001AD4                 push    ecx
.text:00001AD5                 push    1
.text:00001AD7                 lea     edx, [ebp+var_20]
.text:00001ADA                 push    edx
.text:00001ADB                 mov     ecx, [ebp+arg_0]
.text:00001ADE                 call    ?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z ; NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)
.text:00001AE3                 movzx   eax, al
.text:00001AE6                 test    eax, eax
.text:00001AE8                 jz      short loc_1B0A
.text:00001AEA                 mov     ecx, [ebp+arg_8]
.text:00001AED                 mov     dl, [ebp+var_2D]
.text:00001AF0                 mov     [ecx], dl
.text:00001AF2                 mov     [ebp+var_35], 1
.text:00001AF6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001AFD                 lea     ecx, [ebp+var_20]
.text:00001B00                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001B05                 mov     al, [ebp+var_35]
.text:00001B08                 jmp     short loc_1B22
.text:00001B0A ; ---------------------------------------------------------------------------
.text:00001B0A
.text:00001B0A loc_1B0A:                               ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+104j
.text:00001B0A                 mov     al, [ebp+var_D]
.text:00001B0D                 mov     [ebp+var_36], al
.text:00001B10                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001B17                 lea     ecx, [ebp+var_20]
.text:00001B1A                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001B1F                 mov     al, [ebp+var_36]
.text:00001B22
.text:00001B22 loc_1B22:                               ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+6Fj
.text:00001B22                                         ; CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+81j ...
.text:00001B22                 push    edx
.text:00001B23                 mov     ecx, ebp
.text:00001B25                 push    eax
.text:00001B26                 lea     edx, $LN14_0
.text:00001B2C                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001B31                 pop     eax
.text:00001B32                 pop     edx
.text:00001B33                 mov     ecx, [ebp+var_C]
.text:00001B36                 mov     large fs:0, ecx
.text:00001B3D                 pop     ecx
.text:00001B3E                 pop     edi
.text:00001B3F                 add     esp, 38h
.text:00001B42                 cmp     ebp, esp
.text:00001B44                 call    __RTC_CheckEsp
.text:00001B49                 mov     esp, ebp
.text:00001B4B                 pop     ebp
.text:00001B4C                 retn    0Ch
.text:00001B4C ?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z endp
.text:00001B4C
.text:00001B4C ; ---------------------------------------------------------------------------
.text:00001B4F                 align 10h
.text:00001B50 $LN14_0         dd 2                    ; DATA XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+142o
.text:00001B54                 dd offset $LN13_0
.text:00001B58 $LN13_0         dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:00001B54o
.text:00001B60                 dd offset $LN10_2       ; "pathParts2"
.text:00001B64                 dd 0FFFFFFD3h, 1
.text:00001B6C                 dd offset $LN11_2       ; "include2"
.text:00001B70 $LN11_2         db 'include2',0         ; DATA XREF: .text:00001B6Co
.text:00001B79 $LN10_2         db 'pathParts2',0       ; DATA XREF: .text:00001B60o
.text:00001B84
.text:00001B84 ; =============== S U B R O U T I N E =======================================
.text:00001B84
.text:00001B84 ; Attributes: bp-based frame
.text:00001B84
.text:00001B84 ; bool __stdcall CensorNode_CheckPath(const struct NWildcard::CCensorNode *, const struct CReadArcItem *)
.text:00001B84                 public ?CensorNode_CheckPath@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@@Z
.text:00001B84 ?CensorNode_CheckPath@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@@Z proc near
.text:00001B84                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+920p
.text:00001B84
.text:00001B84 var_C           = dword ptr -0Ch
.text:00001B84 var_8           = byte ptr -8
.text:00001B84 var_4           = dword ptr -4
.text:00001B84 arg_0           = dword ptr  8
.text:00001B84 arg_4           = dword ptr  0Ch
.text:00001B84
.text:00001B84                 push    ebp
.text:00001B85                 mov     ebp, esp
.text:00001B87                 sub     esp, 0Ch
.text:00001B8A                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00001B91                 mov     dword ptr [ebp+var_8], 0CCCCCCCCh
.text:00001B98                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001B9F                 lea     eax, [ebp+var_8+3]
.text:00001BA2                 push    eax             ; bool *
.text:00001BA3                 mov     ecx, [ebp+arg_4]
.text:00001BA6                 push    ecx             ; struct CReadArcItem *
.text:00001BA7                 mov     edx, [ebp+arg_0]
.text:00001BAA                 push    edx             ; struct NWildcard::CCensorNode *
.text:00001BAB                 call    ?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z ; CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)
.text:00001BB0                 movzx   eax, al
.text:00001BB3                 test    eax, eax
.text:00001BB5                 jz      short loc_1BBC
.text:00001BB7                 mov     al, [ebp+var_8+3]
.text:00001BBA                 jmp     short loc_1BBE
.text:00001BBC ; ---------------------------------------------------------------------------
.text:00001BBC
.text:00001BBC loc_1BBC:                               ; CODE XREF: CensorNode_CheckPath(NWildcard::CCensorNode const &,CReadArcItem const &)+31j
.text:00001BBC                 xor     al, al
.text:00001BBE
.text:00001BBE loc_1BBE:                               ; CODE XREF: CensorNode_CheckPath(NWildcard::CCensorNode const &,CReadArcItem const &)+36j
.text:00001BBE                 push    edx
.text:00001BBF                 mov     ecx, ebp
.text:00001BC1                 push    eax
.text:00001BC2                 lea     edx, $LN6_3
.text:00001BC8                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001BCD                 pop     eax
.text:00001BCE                 pop     edx
.text:00001BCF                 add     esp, 0Ch
.text:00001BD2                 cmp     ebp, esp
.text:00001BD4                 call    __RTC_CheckEsp
.text:00001BD9                 mov     esp, ebp
.text:00001BDB                 pop     ebp
.text:00001BDC                 retn    8
.text:00001BDC ?CensorNode_CheckPath@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@@Z endp
.text:00001BDC
.text:00001BDC ; ---------------------------------------------------------------------------
.text:00001BDF                 align 10h
.text:00001BE0 $LN6_3          dd 1                    ; DATA XREF: CensorNode_CheckPath(NWildcard::CCensorNode const &,CReadArcItem const &)+3Eo
.text:00001BE4                 dd offset $LN5_0
.text:00001BE8 $LN5_0          dd 0FFFFFFFBh, 1        ; DATA XREF: .text:00001BE4o
.text:00001BF0                 dd offset $LN4_2        ; "include"
.text:00001BF4 $LN4_2          db 'include',0          ; DATA XREF: .text:00001BF0o
.text:00001BFC                 db 8 dup(0CCh)
.text:00001C04
.text:00001C04 ; =============== S U B R O U T I N E =======================================
.text:00001C04
.text:00001C04 ; Attributes: bp-based frame
.text:00001C04
.text:00001C04 ; __int32 CArchiveExtractCallback::GetStream(CArchiveExtractCallback *__hidden this, unsigned int, struct ISequentialOutStream **, int)
.text:00001C04                 public ?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z
.text:00001C04 ?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z proc near
.text:00001C04                                         ; DATA XREF: .rdata:000075B8o
.text:00001C04
.text:00001C04 var_80C         = dword ptr -80Ch
.text:00001C04 var_808         = dword ptr -808h
.text:00001C04 var_804         = dword ptr -804h
.text:00001C04 var_800         = dword ptr -800h
.text:00001C04 var_7FC         = dword ptr -7FCh
.text:00001C04 var_7F8         = dword ptr -7F8h
.text:00001C04 var_7F4         = dword ptr -7F4h
.text:00001C04 var_7F0         = dword ptr -7F0h
.text:00001C04 var_7EC         = dword ptr -7ECh
.text:00001C04 var_7E8         = dword ptr -7E8h
.text:00001C04 var_7E4         = dword ptr -7E4h
.text:00001C04 var_7DD         = byte ptr -7DDh
.text:00001C04 var_7DC         = dword ptr -7DCh
.text:00001C04 var_7D8         = dword ptr -7D8h
.text:00001C04 var_7D4         = dword ptr -7D4h
.text:00001C04 var_7D0         = dword ptr -7D0h
.text:00001C04 var_7CC         = dword ptr -7CCh
.text:00001C04 var_7C5         = byte ptr -7C5h
.text:00001C04 var_7C4         = dword ptr -7C4h
.text:00001C04 var_7C0         = dword ptr -7C0h
.text:00001C04 var_7B9         = byte ptr -7B9h
.text:00001C04 var_7B8         = dword ptr -7B8h
.text:00001C04 var_7B4         = dword ptr -7B4h
.text:00001C04 var_7B0         = dword ptr -7B0h
.text:00001C04 var_7A9         = byte ptr -7A9h
.text:00001C04 var_7A8         = dword ptr -7A8h
.text:00001C04 var_7A1         = byte ptr -7A1h
.text:00001C04 var_7A0         = dword ptr -7A0h
.text:00001C04 var_79C         = byte ptr -79Ch
.text:00001C04 var_798         = dword ptr -798h
.text:00001C04 var_794         = dword ptr -794h
.text:00001C04 var_78D         = byte ptr -78Dh
.text:00001C04 var_78C         = dword ptr -78Ch
.text:00001C04 var_788         = dword ptr -788h
.text:00001C04 var_784         = dword ptr -784h
.text:00001C04 var_77D         = byte ptr -77Dh
.text:00001C04 var_77C         = dword ptr -77Ch
.text:00001C04 var_778         = dword ptr -778h
.text:00001C04 var_774         = dword ptr -774h
.text:00001C04 var_76D         = byte ptr -76Dh
.text:00001C04 var_76C         = dword ptr -76Ch
.text:00001C04 var_768         = dword ptr -768h
.text:00001C04 var_761         = byte ptr -761h
.text:00001C04 var_760         = dword ptr -760h
.text:00001C04 var_759         = byte ptr -759h
.text:00001C04 var_758         = dword ptr -758h
.text:00001C04 var_754         = dword ptr -754h
.text:00001C04 var_750         = dword ptr -750h
.text:00001C04 var_74C         = dword ptr -74Ch
.text:00001C04 var_745         = byte ptr -745h
.text:00001C04 var_744         = dword ptr -744h
.text:00001C04 var_740         = dword ptr -740h
.text:00001C04 var_73C         = dword ptr -73Ch
.text:00001C04 var_735         = byte ptr -735h
.text:00001C04 var_734         = dword ptr -734h
.text:00001C04 var_72E         = byte ptr -72Eh
.text:00001C04 var_72D         = byte ptr -72Dh
.text:00001C04 var_72C         = dword ptr -72Ch
.text:00001C04 var_728         = dword ptr -728h
.text:00001C04 var_724         = dword ptr -724h
.text:00001C04 var_720         = dword ptr -720h
.text:00001C04 var_71C         = dword ptr -71Ch
.text:00001C04 var_718         = dword ptr -718h
.text:00001C04 var_714         = dword ptr -714h
.text:00001C04 var_70D         = byte ptr -70Dh
.text:00001C04 var_70C         = dword ptr -70Ch
.text:00001C04 var_708         = dword ptr -708h
.text:00001C04 var_701         = byte ptr -701h
.text:00001C04 var_700         = dword ptr -700h
.text:00001C04 var_6F9         = byte ptr -6F9h
.text:00001C04 var_6F8         = dword ptr -6F8h
.text:00001C04 var_6F1         = byte ptr -6F1h
.text:00001C04 var_6F0         = dword ptr -6F0h
.text:00001C04 var_6EC         = dword ptr -6ECh
.text:00001C04 var_6E8         = dword ptr -6E8h
.text:00001C04 var_6E1         = byte ptr -6E1h
.text:00001C04 var_6E0         = dword ptr -6E0h
.text:00001C04 var_6DC         = dword ptr -6DCh
.text:00001C04 var_6D5         = byte ptr -6D5h
.text:00001C04 var_6D4         = dword ptr -6D4h
.text:00001C04 var_6D0         = dword ptr -6D0h
.text:00001C04 var_6CC         = dword ptr -6CCh
.text:00001C04 var_6C8         = dword ptr -6C8h
.text:00001C04 var_6C4         = dword ptr -6C4h
.text:00001C04 var_6C0         = dword ptr -6C0h
.text:00001C04 var_6BC         = dword ptr -6BCh
.text:00001C04 var_6B8         = dword ptr -6B8h
.text:00001C04 var_6B4         = dword ptr -6B4h
.text:00001C04 var_6B0         = dword ptr -6B0h
.text:00001C04 var_6AC         = dword ptr -6ACh
.text:00001C04 var_6A8         = dword ptr -6A8h
.text:00001C04 var_6A1         = byte ptr -6A1h
.text:00001C04 var_6A0         = dword ptr -6A0h
.text:00001C04 var_69C         = dword ptr -69Ch
.text:00001C04 var_695         = byte ptr -695h
.text:00001C04 var_694         = dword ptr -694h
.text:00001C04 var_690         = dword ptr -690h
.text:00001C04 var_68C         = dword ptr -68Ch
.text:00001C04 var_688         = dword ptr -688h
.text:00001C04 var_684         = dword ptr -684h
.text:00001C04 var_680         = dword ptr -680h
.text:00001C04 var_67C         = dword ptr -67Ch
.text:00001C04 var_678         = dword ptr -678h
.text:00001C04 var_674         = dword ptr -674h
.text:00001C04 var_670         = dword ptr -670h
.text:00001C04 var_66C         = dword ptr -66Ch
.text:00001C04 var_668         = dword ptr -668h
.text:00001C04 var_664         = dword ptr -664h
.text:00001C04 var_660         = dword ptr -660h
.text:00001C04 var_65C         = dword ptr -65Ch
.text:00001C04 var_656         = byte ptr -656h
.text:00001C04 var_655         = byte ptr -655h
.text:00001C04 var_654         = dword ptr -654h
.text:00001C04 var_650         = dword ptr -650h
.text:00001C04 var_64C         = dword ptr -64Ch
.text:00001C04 var_648         = dword ptr -648h
.text:00001C04 var_641         = byte ptr -641h
.text:00001C04 var_640         = dword ptr -640h
.text:00001C04 var_639         = byte ptr -639h
.text:00001C04 var_638         = dword ptr -638h
.text:00001C04 var_634         = dword ptr -634h
.text:00001C04 var_630         = dword ptr -630h
.text:00001C04 var_62C         = dword ptr -62Ch
.text:00001C04 var_628         = dword ptr -628h
.text:00001C04 var_624         = dword ptr -624h
.text:00001C04 var_620         = dword ptr -620h
.text:00001C04 var_61C         = dword ptr -61Ch
.text:00001C04 var_618         = dword ptr -618h
.text:00001C04 var_614         = dword ptr -614h
.text:00001C04 var_610         = dword ptr -610h
.text:00001C04 var_60C         = dword ptr -60Ch
.text:00001C04 var_608         = dword ptr -608h
.text:00001C04 var_604         = dword ptr -604h
.text:00001C04 var_600         = dword ptr -600h
.text:00001C04 var_5FC         = dword ptr -5FCh
.text:00001C04 var_5F8         = dword ptr -5F8h
.text:00001C04 var_5F1         = byte ptr -5F1h
.text:00001C04 var_5F0         = dword ptr -5F0h
.text:00001C04 var_5EC         = dword ptr -5ECh
.text:00001C04 var_5E8         = dword ptr -5E8h
.text:00001C04 var_5E4         = dword ptr -5E4h
.text:00001C04 var_5DD         = byte ptr -5DDh
.text:00001C04 var_5DC         = dword ptr -5DCh
.text:00001C04 var_5D8         = dword ptr -5D8h
.text:00001C04 var_5D1         = byte ptr -5D1h
.text:00001C04 var_5D0         = dword ptr -5D0h
.text:00001C04 var_5CC         = dword ptr -5CCh
.text:00001C04 var_5C5         = byte ptr -5C5h
.text:00001C04 var_5C4         = dword ptr -5C4h
.text:00001C04 var_5C0         = dword ptr -5C0h
.text:00001C04 var_5BC         = dword ptr -5BCh
.text:00001C04 var_5B8         = dword ptr -5B8h
.text:00001C04 var_5B4         = dword ptr -5B4h
.text:00001C04 var_5B0         = dword ptr -5B0h
.text:00001C04 var_5AC         = dword ptr -5ACh
.text:00001C04 var_5A8         = dword ptr -5A8h
.text:00001C04 var_5A4         = dword ptr -5A4h
.text:00001C04 var_5A0         = dword ptr -5A0h
.text:00001C04 var_59C         = dword ptr -59Ch
.text:00001C04 var_595         = byte ptr -595h
.text:00001C04 var_594         = dword ptr -594h
.text:00001C04 var_58D         = byte ptr -58Dh
.text:00001C04 var_58C         = dword ptr -58Ch
.text:00001C04 var_588         = dword ptr -588h
.text:00001C04 var_582         = byte ptr -582h
.text:00001C04 var_581         = byte ptr -581h
.text:00001C04 var_580         = dword ptr -580h
.text:00001C04 var_57C         = dword ptr -57Ch
.text:00001C04 var_578         = dword ptr -578h
.text:00001C04 var_574         = dword ptr -574h
.text:00001C04 var_570         = dword ptr -570h
.text:00001C04 var_56C         = dword ptr -56Ch
.text:00001C04 var_568         = dword ptr -568h
.text:00001C04 var_564         = dword ptr -564h
.text:00001C04 var_560         = dword ptr -560h
.text:00001C04 var_55C         = dword ptr -55Ch
.text:00001C04 var_558         = dword ptr -558h
.text:00001C04 var_554         = dword ptr -554h
.text:00001C04 var_54D         = byte ptr -54Dh
.text:00001C04 var_54C         = dword ptr -54Ch
.text:00001C04 var_547         = byte ptr -547h
.text:00001C04 var_546         = byte ptr -546h
.text:00001C04 var_545         = byte ptr -545h
.text:00001C04 var_544         = dword ptr -544h
.text:00001C04 var_540         = dword ptr -540h
.text:00001C04 var_539         = byte ptr -539h
.text:00001C04 var_538         = dword ptr -538h
.text:00001C04 var_534         = dword ptr -534h
.text:00001C04 var_530         = dword ptr -530h
.text:00001C04 var_52C         = dword ptr -52Ch
.text:00001C04 var_528         = dword ptr -528h
.text:00001C04 var_521         = byte ptr -521h
.text:00001C04 var_520         = dword ptr -520h
.text:00001C04 var_51C         = dword ptr -51Ch
.text:00001C04 var_518         = dword ptr -518h
.text:00001C04 var_514         = dword ptr -514h
.text:00001C04 var_510         = dword ptr -510h
.text:00001C04 var_50C         = dword ptr -50Ch
.text:00001C04 var_508         = dword ptr -508h
.text:00001C04 var_504         = dword ptr -504h
.text:00001C04 var_500         = dword ptr -500h
.text:00001C04 var_4FC         = dword ptr -4FCh
.text:00001C04 var_4F4         = dword ptr -4F4h
.text:00001C04 var_4F0         = dword ptr -4F0h
.text:00001C04 var_4EC         = dword ptr -4ECh
.text:00001C04 var_4E8         = dword ptr -4E8h
.text:00001C04 var_4E4         = dword ptr -4E4h
.text:00001C04 var_4E0         = dword ptr -4E0h
.text:00001C04 var_4DC         = dword ptr -4DCh
.text:00001C04 var_4D8         = dword ptr -4D8h
.text:00001C04 var_4D4         = dword ptr -4D4h
.text:00001C04 var_4D0         = dword ptr -4D0h
.text:00001C04 var_4CC         = dword ptr -4CCh
.text:00001C04 var_4C8         = dword ptr -4C8h
.text:00001C04 var_4C4         = dword ptr -4C4h
.text:00001C04 var_4C0         = dword ptr -4C0h
.text:00001C04 var_4BC         = byte ptr -4BCh
.text:00001C04 var_4B0         = dword ptr -4B0h
.text:00001C04 var_4AC         = dword ptr -4ACh
.text:00001C04 var_4A8         = dword ptr -4A8h
.text:00001C04 var_4A4         = dword ptr -4A4h
.text:00001C04 var_4A0         = dword ptr -4A0h
.text:00001C04 var_49C         = dword ptr -49Ch
.text:00001C04 var_498         = dword ptr -498h
.text:00001C04 var_494         = dword ptr -494h
.text:00001C04 var_490         = dword ptr -490h
.text:00001C04 var_48C         = dword ptr -48Ch
.text:00001C04 var_488         = dword ptr -488h
.text:00001C04 var_484         = dword ptr -484h
.text:00001C04 var_480         = dword ptr -480h
.text:00001C04 var_47C         = dword ptr -47Ch
.text:00001C04 var_478         = dword ptr -478h
.text:00001C04 var_474         = byte ptr -474h
.text:00001C04 var_468         = dword ptr -468h
.text:00001C04 var_464         = dword ptr -464h
.text:00001C04 var_460         = dword ptr -460h
.text:00001C04 var_454         = dword ptr -454h
.text:00001C04 var_450         = dword ptr -450h
.text:00001C04 var_44C         = dword ptr -44Ch
.text:00001C04 var_448         = dword ptr -448h
.text:00001C04 var_444         = dword ptr -444h
.text:00001C04 var_440         = dword ptr -440h
.text:00001C04 var_43C         = dword ptr -43Ch
.text:00001C04 var_438         = dword ptr -438h
.text:00001C04 var_434         = dword ptr -434h
.text:00001C04 var_430         = dword ptr -430h
.text:00001C04 var_42C         = dword ptr -42Ch
.text:00001C04 var_428         = dword ptr -428h
.text:00001C04 var_424         = dword ptr -424h
.text:00001C04 var_420         = dword ptr -420h
.text:00001C04 var_41C         = dword ptr -41Ch
.text:00001C04 var_418         = dword ptr -418h
.text:00001C04 var_414         = dword ptr -414h
.text:00001C04 var_410         = byte ptr -410h
.text:00001C04 var_404         = word ptr -404h
.text:00001C04 var_3F8         = dword ptr -3F8h
.text:00001C04 var_3F4         = dword ptr -3F4h
.text:00001C04 var_3F0         = dword ptr -3F0h
.text:00001C04 var_3EC         = dword ptr -3ECh
.text:00001C04 var_3E8         = dword ptr -3E8h
.text:00001C04 var_3E4         = dword ptr -3E4h
.text:00001C04 var_3E0         = dword ptr -3E0h
.text:00001C04 var_3DC         = dword ptr -3DCh
.text:00001C04 var_3D8         = dword ptr -3D8h
.text:00001C04 var_3D4         = dword ptr -3D4h
.text:00001C04 var_3CC         = byte ptr -3CCh
.text:00001C04 var_3B8         = dword ptr -3B8h
.text:00001C04 var_3B0         = byte ptr -3B0h
.text:00001C04 var_3A8         = dword ptr -3A8h
.text:00001C04 var_3A4         = dword ptr -3A4h
.text:00001C04 var_3A0         = dword ptr -3A0h
.text:00001C04 var_39C         = dword ptr -39Ch
.text:00001C04 var_391         = dword ptr -391h
.text:00001C04 var_388         = qword ptr -388h
.text:00001C04 var_371         = byte ptr -371h
.text:00001C04 var_370         = dword ptr -370h
.text:00001C04 var_36C         = dword ptr -36Ch
.text:00001C04 var_364         = byte ptr -364h
.text:00001C04 var_33C         = byte ptr -33Ch
.text:00001C04 var_330         = dword ptr -330h
.text:00001C04 var_32C         = dword ptr -32Ch
.text:00001C04 var_324         = word ptr -324h
.text:00001C04 var_314         = dword ptr -314h
.text:00001C04 var_30C         = byte ptr -30Ch
.text:00001C04 var_2F8         = byte ptr -2F8h
.text:00001C04 var_2D8         = dword ptr -2D8h
.text:00001C04 var_2B8         = byte ptr -2B8h
.text:00001C04 var_2A8         = dword ptr -2A8h
.text:00001C04 var_2A4         = dword ptr -2A4h
.text:00001C04 var_29D         = byte ptr -29Dh
.text:00001C04 var_29C         = dword ptr -29Ch
.text:00001C04 var_298         = dword ptr -298h
.text:00001C04 var_294         = dword ptr -294h
.text:00001C04 var_28C         = byte ptr -28Ch
.text:00001C04 var_27C         = dword ptr -27Ch
.text:00001C04 var_278         = dword ptr -278h
.text:00001C04 var_270         = word ptr -270h
.text:00001C04 var_264         = byte ptr -264h
.text:00001C04 var_254         = dword ptr -254h
.text:00001C04 var_24C         = byte ptr -24Ch
.text:00001C04 var_234         = byte ptr -234h
.text:00001C04 var_224         = byte ptr -224h
.text:00001C04 var_20D         = byte ptr -20Dh
.text:00001C04 var_208         = byte ptr -208h
.text:00001C04 var_1F8         = dword ptr -1F8h
.text:00001C04 var_1F4         = dword ptr -1F4h
.text:00001C04 var_1EC         = byte ptr -1ECh
.text:00001C04 var_1D4         = byte ptr -1D4h
.text:00001C04 var_1C0         = byte ptr -1C0h
.text:00001C04 var_1AC         = word ptr -1ACh
.text:00001C04 var_19C         = dword ptr -19Ch
.text:00001C04 var_195         = byte ptr -195h
.text:00001C04 var_190         = byte ptr -190h
.text:00001C04 var_180         = dword ptr -180h
.text:00001C04 var_175         = byte ptr -175h
.text:00001C04 var_170         = dword ptr -170h
.text:00001C04 var_16C         = dword ptr -16Ch
.text:00001C04 var_168         = dword ptr -168h
.text:00001C04 var_164         = dword ptr -164h
.text:00001C04 var_15C         = word ptr -15Ch
.text:00001C04 var_154         = dword ptr -154h
.text:00001C04 var_144         = byte ptr -144h
.text:00001C04 var_138         = byte ptr -138h
.text:00001C04 var_128         = dword ptr -128h
.text:00001C04 var_121         = byte ptr -121h
.text:00001C04 var_120         = dword ptr -120h
.text:00001C04 var_11C         = dword ptr -11Ch
.text:00001C04 var_118         = dword ptr -118h
.text:00001C04 var_114         = dword ptr -114h
.text:00001C04 var_110         = dword ptr -110h
.text:00001C04 var_10C         = dword ptr -10Ch
.text:00001C04 var_105         = byte ptr -105h
.text:00001C04 var_100         = byte ptr -100h
.text:00001C04 var_F0          = dword ptr -0F0h
.text:00001C04 var_E8          = byte ptr -0E8h
.text:00001C04 var_C0          = byte ptr -0C0h
.text:00001C04 var_AC          = dword ptr -0ACh
.text:00001C04 var_A0          = dword ptr -0A0h
.text:00001C04 var_94          = dword ptr -94h
.text:00001C04 var_89          = byte ptr -89h
.text:00001C04 var_88          = dword ptr -88h
.text:00001C04 var_80          = word ptr -80h
.text:00001C04 var_78          = dword ptr -78h
.text:00001C04 var_6C          = dword ptr -6Ch
.text:00001C04 var_64          = word ptr -64h
.text:00001C04 var_5C          = dword ptr -5Ch
.text:00001C04 var_4C          = word ptr -4Ch
.text:00001C04 var_3B          = byte ptr -3Bh
.text:00001C04 var_3A          = byte ptr -3Ah
.text:00001C04 var_39          = byte ptr -39h
.text:00001C04 var_38          = dword ptr -38h
.text:00001C04 var_30          = word ptr -30h
.text:00001C04 var_28          = dword ptr -28h
.text:00001C04 var_24          = dword ptr -24h
.text:00001C04 var_1C          = dword ptr -1Ch
.text:00001C04 var_18          = dword ptr -18h
.text:00001C04 var_14          = dword ptr -14h
.text:00001C04 var_10          = dword ptr -10h
.text:00001C04 var_C           = dword ptr -0Ch
.text:00001C04 var_4           = dword ptr -4
.text:00001C04 this            = dword ptr  8
.text:00001C04 arg_4           = dword ptr  0Ch
.text:00001C04 arg_8           = dword ptr  10h
.text:00001C04 arg_C           = dword ptr  14h
.text:00001C04
.text:00001C04 ; FUNCTION CHUNK AT .text:00004F97 SIZE 0000003C BYTES
.text:00001C04
.text:00001C04                 push    ebp
.text:00001C05                 mov     ebp, esp
.text:00001C07                 push    0FFFFFFFFh
.text:00001C09                 push    offset __ehhandler$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z
.text:00001C0E                 mov     eax, large fs:0
.text:00001C14                 push    eax
.text:00001C15                 push    ecx
.text:00001C16                 sub     esp, 7FCh
.text:00001C1C                 push    ebx
.text:00001C1D                 push    esi
.text:00001C1E                 push    edi             ; wchar_t *
.text:00001C1F                 lea     edi, [ebp+var_80C]
.text:00001C25                 mov     ecx, 1FFh
.text:00001C2A                 mov     eax, 0CCCCCCCCh
.text:00001C2F                 rep stosd
.text:00001C31                 mov     eax, dword ptr ds:___security_cookie
.text:00001C36                 xor     eax, ebp
.text:00001C38                 mov     [ebp+var_14], eax
.text:00001C3B                 push    eax             ; struct _FILETIME *
.text:00001C3C                 lea     eax, [ebp+var_C]
.text:00001C3F                 mov     large fs:0, eax
.text:00001C45                 mov     [ebp+var_10], esp
.text:00001C48                 mov     [ebp+var_4], 0
.text:00001C4F                 mov     eax, [ebp+arg_8]
.text:00001C52                 mov     dword ptr [eax], 0
.text:00001C58                 mov     ecx, [ebp+this]
.text:00001C5B                 add     ecx, 108h
.text:00001C61                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00001C66                 mov     [ebp+var_4FC], eax
.text:00001C6C                 cmp     [ebp+var_4FC], 0
.text:00001C73                 jz      short loc_1C83
.text:00001C75                 mov     ecx, [ebp+this]
.text:00001C78                 mov     ecx, [ecx+104h] ; this
.text:00001C7E                 call    ?ReleaseStream@COutStreamWithHash@@QAEXXZ ; COutStreamWithHash::ReleaseStream(void)
.text:00001C83
.text:00001C83 loc_1C83:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+6Fj
.text:00001C83                 mov     edx, [ebp+this]
.text:00001C86                 mov     byte ptr [edx+10Ch], 0
.text:00001C8D                 mov     ecx, [ebp+this]
.text:00001C90                 add     ecx, 100h
.text:00001C96                 call    ?Release@?$CMyComPtr@UISequentialOutStream@@@@QAEXXZ ; CMyComPtr<ISequentialOutStream>::Release(void)
.text:00001C9B                 mov     eax, [ebp+this]
.text:00001C9E                 mov     byte ptr [eax+0C5h], 0
.text:00001CA5                 mov     ecx, [ebp+this]
.text:00001CA8                 mov     dword ptr [ecx+0B8h], 0
.text:00001CB2                 mov     dword ptr [ecx+0BCh], 0
.text:00001CBC                 mov     edx, [ebp+this]
.text:00001CBF                 mov     byte ptr [edx+0C0h], 0
.text:00001CC6                 mov     eax, [ebp+this]
.text:00001CC9                 mov     dword ptr [eax+0F0h], 0
.text:00001CD3                 mov     dword ptr [eax+0F4h], 0
.text:00001CDD                 mov     ecx, [ebp+this]
.text:00001CE0                 mov     byte ptr [ecx+0F8h], 0
.text:00001CE7                 mov     edx, [ebp+this]
.text:00001CEA                 mov     eax, [ebp+arg_4]
.text:00001CED                 mov     [edx+0E8h], eax
.text:00001CF3                 mov     ecx, [ebp+this]
.text:00001CF6                 mov     ecx, [ecx+14h]
.text:00001CF9                 call    ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ ; CMyComPtr<IInArchive>::operator IInArchive *(void)
.text:00001CFE                 mov     [ebp+var_500], eax
.text:00001D04                 mov     edx, [ebp+var_500]
.text:00001D0A                 mov     [ebp+var_18], edx
.text:00001D0D                 mov     eax, [ebp+this]
.text:00001D10                 mov     ecx, [ebp+this]
.text:00001D13                 mov     dl, [ecx+11Ch]
.text:00001D19                 mov     [eax+0A0h], dl
.text:00001D1F                 mov     eax, [ebp+this]
.text:00001D22                 movzx   ecx, byte ptr [eax+11Ch]
.text:00001D29                 test    ecx, ecx
.text:00001D2B                 jz      short loc_1D5E
.text:00001D2D                 mov     edx, [ebp+this]
.text:00001D30                 mov     eax, [ebp+this]
.text:00001D33                 mov     ecx, [eax+120h]
.text:00001D39                 mov     [edx+0A4h], ecx
.text:00001D3F                 mov     edx, [ebp+this]
.text:00001D42                 cmp     dword ptr [edx+54h], 0
.text:00001D46                 jz      short loc_1D51
.text:00001D48                 mov     eax, [ebp+this]
.text:00001D4B                 cmp     dword ptr [eax+54h], 3
.text:00001D4F                 jnz     short loc_1D5E
.text:00001D51
.text:00001D51 loc_1D51:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+142j
.text:00001D51                 mov     ecx, [ebp+this]
.text:00001D54                 mov     dword ptr [ecx+0A4h], 0FFFFFFFFh
.text:00001D5E
.text:00001D5E loc_1D5E:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+127j
.text:00001D5E                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+14Bj
.text:00001D5E                 mov     edx, [ebp+this]
.text:00001D61                 mov     eax, [ebp+this]
.text:00001D64                 mov     cl, [eax+21h]
.text:00001D67                 mov     [edx+99h], cl
.text:00001D6D                 mov     edx, [ebp+this]
.text:00001D70                 add     edx, 68h ; 'h'
.text:00001D73                 push    edx             ; struct CReadArcItem *
.text:00001D74                 mov     eax, [ebp+arg_4]
.text:00001D77                 push    eax             ; unsigned int
.text:00001D78                 mov     ecx, [ebp+this]
.text:00001D7B                 mov     ecx, [ecx+14h]  ; this
.text:00001D7E                 call    ?GetItem@CArc@@QBEJIAAUCReadArcItem@@@Z ; CArc::GetItem(uint,CReadArcItem &)
.text:00001D83                 mov     [ebp+var_504], eax
.text:00001D89                 mov     edx, [ebp+var_504]
.text:00001D8F                 mov     [ebp+var_1C], edx
.text:00001D92                 cmp     [ebp+var_1C], 0
.text:00001D96                 jz      short loc_1DA0
.text:00001D98                 mov     eax, [ebp+var_1C]
.text:00001D9B                 jmp     loc_4F97
.text:00001DA0 ; ---------------------------------------------------------------------------
.text:00001DA0
.text:00001DA0 loc_1DA0:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+192j
.text:00001DA0                 lea     ecx, [ebp+var_30] ; this
.text:00001DA3                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00001DA8                 mov     [ebp+var_508], eax
.text:00001DAE                 mov     byte ptr [ebp+var_4], 1
.text:00001DB2                 mov     esi, esp
.text:00001DB4                 lea     eax, [ebp+var_30]
.text:00001DB7                 push    eax
.text:00001DB8                 push    1Dh
.text:00001DBA                 mov     ecx, [ebp+arg_4]
.text:00001DBD                 push    ecx
.text:00001DBE                 mov     edx, [ebp+var_18]
.text:00001DC1                 push    edx
.text:00001DC2                 mov     eax, [ebp+var_18]
.text:00001DC5                 mov     ecx, [eax]
.text:00001DC7                 mov     edx, [ecx+18h]
.text:00001DCA                 call    edx
.text:00001DCC                 cmp     esi, esp
.text:00001DCE                 call    __RTC_CheckEsp
.text:00001DD3                 mov     [ebp+var_50C], eax
.text:00001DD9                 mov     eax, [ebp+var_50C]
.text:00001DDF                 mov     [ebp+var_38], eax
.text:00001DE2                 cmp     [ebp+var_38], 0
.text:00001DE6                 jz      short loc_1E08
.text:00001DE8                 mov     ecx, [ebp+var_38]
.text:00001DEB                 mov     [ebp+var_3E0], ecx
.text:00001DF1                 mov     byte ptr [ebp+var_4], 0
.text:00001DF5                 lea     ecx, [ebp+var_30] ; this
.text:00001DF8                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00001DFD                 mov     eax, [ebp+var_3E0]
.text:00001E03                 jmp     loc_4F97
.text:00001E08 ; ---------------------------------------------------------------------------
.text:00001E08
.text:00001E08 loc_1E08:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1E2j
.text:00001E08                 movzx   edx, [ebp+var_30]
.text:00001E0C                 test    edx, edx
.text:00001E0E                 jz      short loc_1E59
.text:00001E10                 movzx   eax, [ebp+var_30]
.text:00001E14                 cmp     eax, 15h
.text:00001E17                 jz      short loc_1E3A
.text:00001E19                 mov     [ebp+var_3E4], 80004005h
.text:00001E23                 mov     byte ptr [ebp+var_4], 0
.text:00001E27                 lea     ecx, [ebp+var_30] ; this
.text:00001E2A                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00001E2F                 mov     eax, [ebp+var_3E4]
.text:00001E35                 jmp     loc_4F97
.text:00001E3A ; ---------------------------------------------------------------------------
.text:00001E3A
.text:00001E3A loc_1E3A:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+213j
.text:00001E3A                 mov     ecx, [ebp+this]
.text:00001E3D                 mov     edx, [ebp+var_28]
.text:00001E40                 mov     [ecx+0B8h], edx
.text:00001E46                 mov     eax, [ebp+var_24]
.text:00001E49                 mov     [ecx+0BCh], eax
.text:00001E4F                 mov     ecx, [ebp+this]
.text:00001E52                 mov     byte ptr [ecx+0C0h], 1
.text:00001E59
.text:00001E59 loc_1E59:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+20Aj
.text:00001E59                 mov     byte ptr [ebp+var_4], 0
.text:00001E5D                 lea     ecx, [ebp+var_30] ; this
.text:00001E60                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00001E65                 mov     [ebp+var_39], 0
.text:00001E69                 mov     [ebp+var_3A], 0
.text:00001E6D                 mov     [ebp+var_3B], 0
.text:00001E71                 lea     ecx, [ebp+var_4C]
.text:00001E74                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00001E79                 mov     [ebp+var_510], eax
.text:00001E7F                 mov     byte ptr [ebp+var_4], 2
.text:00001E83                 lea     ecx, [ebp+var_64] ; this
.text:00001E86                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00001E8B                 mov     [ebp+var_514], eax
.text:00001E91                 mov     byte ptr [ebp+var_4], 3
.text:00001E95                 mov     esi, esp
.text:00001E97                 lea     edx, [ebp+var_64]
.text:00001E9A                 push    edx
.text:00001E9B                 push    5Ah ; 'Z'
.text:00001E9D                 mov     eax, [ebp+arg_4]
.text:00001EA0                 push    eax
.text:00001EA1                 mov     ecx, [ebp+var_18]
.text:00001EA4                 push    ecx
.text:00001EA5                 mov     edx, [ebp+var_18]
.text:00001EA8                 mov     eax, [edx]
.text:00001EAA                 mov     ecx, [eax+18h]
.text:00001EAD                 call    ecx
.text:00001EAF                 cmp     esi, esp
.text:00001EB1                 call    __RTC_CheckEsp
.text:00001EB6                 mov     [ebp+var_518], eax
.text:00001EBC                 mov     edx, [ebp+var_518]
.text:00001EC2                 mov     [ebp+var_6C], edx
.text:00001EC5                 cmp     [ebp+var_6C], 0
.text:00001EC9                 jz      short loc_1EF7
.text:00001ECB                 mov     eax, [ebp+var_6C]
.text:00001ECE                 mov     [ebp+var_3E8], eax
.text:00001ED4                 mov     byte ptr [ebp+var_4], 2
.text:00001ED8                 lea     ecx, [ebp+var_64] ; this
.text:00001EDB                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00001EE0                 mov     byte ptr [ebp+var_4], 0
.text:00001EE4                 lea     ecx, [ebp+var_4C] ; this
.text:00001EE7                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001EEC                 mov     eax, [ebp+var_3E8]
.text:00001EF2                 jmp     loc_4F97
.text:00001EF7 ; ---------------------------------------------------------------------------
.text:00001EF7
.text:00001EF7 loc_1EF7:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2C5j
.text:00001EF7                 movzx   ecx, [ebp+var_64]
.text:00001EFB                 cmp     ecx, 8
.text:00001EFE                 jnz     short loc_1F16
.text:00001F00                 mov     [ebp+var_39], 1
.text:00001F04                 mov     edx, [ebp+var_5C]
.text:00001F07                 push    edx             ; wchar_t *
.text:00001F08                 lea     ecx, [ebp+var_4C] ; this
.text:00001F0B                 call    ?SetFromBstr@UString@@QAEXPA_W@Z ; UString::SetFromBstr(wchar_t *)
.text:00001F10                 mov     [ebp+var_3B], 0
.text:00001F14                 jmp     short loc_1F4D
.text:00001F16 ; ---------------------------------------------------------------------------
.text:00001F16
.text:00001F16 loc_1F16:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2FAj
.text:00001F16                 movzx   eax, [ebp+var_64]
.text:00001F1A                 test    eax, eax
.text:00001F1C                 jnz     short loc_1F20
.text:00001F1E                 jmp     short loc_1F4D
.text:00001F20 ; ---------------------------------------------------------------------------
.text:00001F20
.text:00001F20 loc_1F20:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+318j
.text:00001F20                 mov     [ebp+var_3EC], 80004005h
.text:00001F2A                 mov     byte ptr [ebp+var_4], 2
.text:00001F2E                 lea     ecx, [ebp+var_64] ; this
.text:00001F31                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00001F36                 mov     byte ptr [ebp+var_4], 0
.text:00001F3A                 lea     ecx, [ebp+var_4C] ; this
.text:00001F3D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001F42                 mov     eax, [ebp+var_3EC]
.text:00001F48                 jmp     loc_4F97
.text:00001F4D ; ---------------------------------------------------------------------------
.text:00001F4D
.text:00001F4D loc_1F4D:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+310j
.text:00001F4D                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+31Aj
.text:00001F4D                 mov     byte ptr [ebp+var_4], 2
.text:00001F51                 lea     ecx, [ebp+var_64] ; this
.text:00001F54                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00001F59                 lea     ecx, [ebp+var_80] ; this
.text:00001F5C                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00001F61                 mov     [ebp+var_51C], eax
.text:00001F67                 mov     byte ptr [ebp+var_4], 4
.text:00001F6B                 mov     esi, esp
.text:00001F6D                 lea     ecx, [ebp+var_80]
.text:00001F70                 push    ecx
.text:00001F71                 push    36h ; '6'
.text:00001F73                 mov     edx, [ebp+arg_4]
.text:00001F76                 push    edx
.text:00001F77                 mov     eax, [ebp+var_18]
.text:00001F7A                 push    eax
.text:00001F7B                 mov     ecx, [ebp+var_18]
.text:00001F7E                 mov     edx, [ecx]
.text:00001F80                 mov     eax, [edx+18h]
.text:00001F83                 call    eax
.text:00001F85                 cmp     esi, esp
.text:00001F87                 call    __RTC_CheckEsp
.text:00001F8C                 mov     [ebp+var_520], eax
.text:00001F92                 mov     ecx, [ebp+var_520]
.text:00001F98                 mov     [ebp+var_88], ecx
.text:00001F9E                 cmp     [ebp+var_88], 0
.text:00001FA5                 jz      short loc_1FD6
.text:00001FA7                 mov     edx, [ebp+var_88]
.text:00001FAD                 mov     [ebp+var_3F0], edx
.text:00001FB3                 mov     byte ptr [ebp+var_4], 2
.text:00001FB7                 lea     ecx, [ebp+var_80] ; this
.text:00001FBA                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00001FBF                 mov     byte ptr [ebp+var_4], 0
.text:00001FC3                 lea     ecx, [ebp+var_4C] ; this
.text:00001FC6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001FCB                 mov     eax, [ebp+var_3F0]
.text:00001FD1                 jmp     loc_4F97
.text:00001FD6 ; ---------------------------------------------------------------------------
.text:00001FD6
.text:00001FD6 loc_1FD6:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3A1j
.text:00001FD6                 movzx   eax, [ebp+var_80]
.text:00001FDA                 cmp     eax, 8
.text:00001FDD                 jnz     short loc_1FF5
.text:00001FDF                 mov     [ebp+var_39], 0
.text:00001FE3                 mov     ecx, [ebp+var_78]
.text:00001FE6                 push    ecx             ; wchar_t *
.text:00001FE7                 lea     ecx, [ebp+var_4C] ; this
.text:00001FEA                 call    ?SetFromBstr@UString@@QAEXPA_W@Z ; UString::SetFromBstr(wchar_t *)
.text:00001FEF                 mov     [ebp+var_3B], 1
.text:00001FF3                 jmp     short loc_202C
.text:00001FF5 ; ---------------------------------------------------------------------------
.text:00001FF5
.text:00001FF5 loc_1FF5:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3D9j
.text:00001FF5                 movzx   edx, [ebp+var_80]
.text:00001FF9                 test    edx, edx
.text:00001FFB                 jnz     short loc_1FFF
.text:00001FFD                 jmp     short loc_202C
.text:00001FFF ; ---------------------------------------------------------------------------
.text:00001FFF
.text:00001FFF loc_1FFF:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3F7j
.text:00001FFF                 mov     [ebp+var_3F4], 80004005h
.text:00002009                 mov     byte ptr [ebp+var_4], 2
.text:0000200D                 lea     ecx, [ebp+var_80] ; this
.text:00002010                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00002015                 mov     byte ptr [ebp+var_4], 0
.text:00002019                 lea     ecx, [ebp+var_4C] ; this
.text:0000201C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002021                 mov     eax, [ebp+var_3F4]
.text:00002027                 jmp     loc_4F97
.text:0000202C ; ---------------------------------------------------------------------------
.text:0000202C
.text:0000202C loc_202C:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3EFj
.text:0000202C                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3F9j
.text:0000202C                 mov     byte ptr [ebp+var_4], 2
.text:00002030                 lea     ecx, [ebp+var_80] ; this
.text:00002033                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00002038                 mov     [ebp+var_89], 0
.text:0000203F                 lea     ecx, [ebp+var_4C] ; this
.text:00002042                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00002047                 mov     [ebp+var_521], al
.text:0000204D                 movzx   eax, [ebp+var_521]
.text:00002054                 test    eax, eax
.text:00002056                 jz      loc_220E
.text:0000205C                 mov     ecx, [ebp+this]
.text:0000205F                 mov     ecx, [ecx+14h]
.text:00002062                 add     ecx, 8
.text:00002065                 call    ??B?$CMyComPtr@UIArchiveGetRawProps@@@@QBEPAUIArchiveGetRawProps@@XZ ; CMyComPtr<IArchiveGetRawProps>::operator IArchiveGetRawProps *(void)
.text:0000206A                 mov     [ebp+var_528], eax
.text:00002070                 cmp     [ebp+var_528], 0
.text:00002077                 jz      loc_220E
.text:0000207D                 mov     edx, [ebp+this]
.text:00002080                 mov     ecx, [edx+14h]
.text:00002083                 add     ecx, 8
.text:00002086                 call    ??C?$CMyComPtr@UIArchiveGetRawProps@@@@QBEPAUIArchiveGetRawProps@@XZ ; CMyComPtr<IArchiveGetRawProps>::operator->(void)
.text:0000208B                 mov     [ebp+var_52C], eax
.text:00002091                 mov     eax, [ebp+var_52C]
.text:00002097                 mov     [ebp+var_530], eax
.text:0000209D                 mov     esi, esp
.text:0000209F                 lea     ecx, [ebp+var_AC]
.text:000020A5                 push    ecx
.text:000020A6                 lea     edx, [ebp+var_A0]
.text:000020AC                 push    edx
.text:000020AD                 lea     eax, [ebp+var_94]
.text:000020B3                 push    eax
.text:000020B4                 push    59h ; 'Y'
.text:000020B6                 mov     ecx, [ebp+this]
.text:000020B9                 mov     edx, [ecx+0E8h]
.text:000020BF                 push    edx
.text:000020C0                 mov     eax, [ebp+var_530]
.text:000020C6                 push    eax
.text:000020C7                 mov     ecx, [ebp+var_530]
.text:000020CD                 mov     edx, [ecx]
.text:000020CF                 mov     eax, [edx+10h]
.text:000020D2                 call    eax
.text:000020D4                 cmp     esi, esp
.text:000020D6                 call    __RTC_CheckEsp
.text:000020DB                 cmp     [ebp+var_A0], 0
.text:000020E2                 jz      loc_220E
.text:000020E8                 cmp     [ebp+var_AC], 1
.text:000020EF                 jz      short loc_2112
.text:000020F1                 mov     [ebp+var_3F8], 80004005h
.text:000020FB                 mov     byte ptr [ebp+var_4], 0
.text:000020FF                 lea     ecx, [ebp+var_4C] ; this
.text:00002102                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002107                 mov     eax, [ebp+var_3F8]
.text:0000210D                 jmp     loc_4F97
.text:00002112 ; ---------------------------------------------------------------------------
.text:00002112
.text:00002112 loc_2112:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+4EBj
.text:00002112                 lea     ecx, [ebp+var_C0]
.text:00002118                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000211D                 mov     [ebp+var_534], eax
.text:00002123                 mov     byte ptr [ebp+var_4], 5
.text:00002127                 lea     ecx, [ebp+var_E8] ; this
.text:0000212D                 call    ??0CReparseAttr@NFile@NWindows@@QAE@XZ ; NWindows::NFile::CReparseAttr::CReparseAttr(void)
.text:00002132                 mov     [ebp+var_538], eax
.text:00002138                 mov     byte ptr [ebp+var_4], 6
.text:0000213C                 mov     ecx, [ebp+var_A0]
.text:00002142                 push    ecx             ; unsigned int
.text:00002143                 mov     edx, [ebp+var_94]
.text:00002149                 push    edx             ; unsigned __int8 *
.text:0000214A                 lea     ecx, [ebp+var_E8] ; this
.text:00002150                 call    ?Parse@CReparseAttr@NFile@NWindows@@QAE_NPBEI@Z ; NWindows::NFile::CReparseAttr::Parse(uchar const *,uint)
.text:00002155                 mov     [ebp+var_539], al
.text:0000215B                 mov     al, [ebp+var_539]
.text:00002161                 mov     [ebp+var_89], al
.text:00002167                 movzx   ecx, [ebp+var_89]
.text:0000216E                 test    ecx, ecx
.text:00002170                 jz      short loc_21F0
.text:00002172                 mov     [ebp+var_39], 0
.text:00002176                 lea     edx, [ebp+var_404]
.text:0000217C                 push    edx             ; wchar_t *
.text:0000217D                 lea     ecx, [ebp+var_E8]
.text:00002183                 call    ?GetPath@CReparseAttr@NFile@NWindows@@QBE?AVUString@@XZ ; NWindows::NFile::CReparseAttr::GetPath(void)
.text:00002188                 mov     [ebp+var_540], eax
.text:0000218E                 mov     eax, [ebp+var_540]
.text:00002194                 mov     [ebp+var_544], eax
.text:0000219A                 mov     byte ptr [ebp+var_4], 7
.text:0000219E                 mov     ecx, [ebp+var_544]
.text:000021A4                 push    ecx
.text:000021A5                 lea     ecx, [ebp+var_4C]
.text:000021A8                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000021AD                 mov     byte ptr [ebp+var_4], 6
.text:000021B1                 lea     ecx, [ebp+var_404] ; this
.text:000021B7                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000021BC                 lea     ecx, [ebp+var_E8] ; this
.text:000021C2                 call    ?IsMountPoint@CReparseAttr@NFile@NWindows@@QBE_NXZ ; NWindows::NFile::CReparseAttr::IsMountPoint(void)
.text:000021C7                 mov     [ebp+var_545], al
.text:000021CD                 mov     dl, [ebp+var_545]
.text:000021D3                 mov     [ebp+var_3A], dl
.text:000021D6                 lea     ecx, [ebp+var_E8] ; this
.text:000021DC                 call    ?IsRelative@CReparseAttr@NFile@NWindows@@QBE_NXZ ; NWindows::NFile::CReparseAttr::IsRelative(void)
.text:000021E1                 mov     [ebp+var_546], al
.text:000021E7                 mov     al, [ebp+var_546]
.text:000021ED                 mov     [ebp+var_3B], al
.text:000021F0
.text:000021F0 loc_21F0:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+56Cj
.text:000021F0                 mov     byte ptr [ebp+var_4], 5
.text:000021F4                 lea     ecx, [ebp+var_E8] ; this
.text:000021FA                 call    ??1CReparseAttr@NFile@NWindows@@QAE@XZ ; NWindows::NFile::CReparseAttr::~CReparseAttr(void)
.text:000021FF                 mov     byte ptr [ebp+var_4], 2
.text:00002203                 lea     ecx, [ebp+var_C0] ; this
.text:00002209                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000220E
.text:0000220E loc_220E:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+452j
.text:0000220E                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+473j ...
.text:0000220E                 lea     ecx, [ebp+var_4C] ; this
.text:00002211                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00002216                 mov     [ebp+var_547], al
.text:0000221C                 movzx   ecx, [ebp+var_547]
.text:00002223                 test    ecx, ecx
.text:00002225                 jnz     short loc_2273
.text:00002227                 push    5Ch ; '\'       ; wchar_t
.text:00002229                 push    2Fh ; '/'       ; wchar_t
.text:0000222B                 lea     ecx, [ebp+var_4C] ; this
.text:0000222E                 call    ?Replace@UString@@QAEX_W0@Z ; UString::Replace(wchar_t,wchar_t)
.text:00002233
.text:00002233 loc_2233:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+66Dj
.text:00002233                 lea     ecx, [ebp+var_4C]
.text:00002236                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000223B                 mov     [ebp+var_54C], eax
.text:00002241                 mov     edx, [ebp+var_54C]
.text:00002247                 push    edx             ; this
.text:00002248                 call    ?GetRootPrefixSize@NName@NFile@NWindows@@YGIPB_W@Z ; NWindows::NFile::NName::GetRootPrefixSize(wchar_t const *)
.text:0000224D                 mov     [ebp+var_F0], eax
.text:00002253                 cmp     [ebp+var_F0], 0
.text:0000225A                 jnz     short loc_225E
.text:0000225C                 jmp     short loc_2273
.text:0000225E ; ---------------------------------------------------------------------------
.text:0000225E
.text:0000225E loc_225E:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+656j
.text:0000225E                 mov     [ebp+var_3B], 0
.text:00002262                 mov     eax, [ebp+var_F0]
.text:00002268                 push    eax             ; unsigned int
.text:00002269                 lea     ecx, [ebp+var_4C] ; this
.text:0000226C                 call    ?DeleteFrontal@UString@@QAEXI@Z ; UString::DeleteFrontal(uint)
.text:00002271                 jmp     short loc_2233
.text:00002273 ; ---------------------------------------------------------------------------
.text:00002273
.text:00002273 loc_2273:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+621j
.text:00002273                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+658j
.text:00002273                 lea     ecx, [ebp+var_4C] ; this
.text:00002276                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000227B                 mov     [ebp+var_54D], al
.text:00002281                 movzx   ecx, [ebp+var_54D]
.text:00002288                 test    ecx, ecx
.text:0000228A                 jnz     loc_2436
.text:00002290                 movzx   edx, [ebp+var_3B]
.text:00002294                 test    edx, edx
.text:00002296                 jnz     loc_2436
.text:0000229C                 mov     ecx, [ebp+this]
.text:0000229F                 add     ecx, 110h
.text:000022A5                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000022AA                 mov     [ebp+var_554], eax
.text:000022B0                 cmp     [ebp+var_554], 0
.text:000022B7                 jz      loc_2436
.text:000022BD                 lea     ecx, [ebp+var_100]
.text:000022C3                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:000022C8                 mov     [ebp+var_558], eax
.text:000022CE                 mov     byte ptr [ebp+var_4], 8
.text:000022D2                 lea     eax, [ebp+var_100]
.text:000022D8                 push    eax
.text:000022D9                 lea     ecx, [ebp+var_4C]
.text:000022DC                 push    ecx
.text:000022DD                 call    ?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z ; SplitPathToParts(UString const &,CObjectVector<UString> &)
.text:000022E2                 mov     [ebp+var_105], 0
.text:000022E9                 mov     [ebp+var_10C], 0
.text:000022F3                 jmp     short loc_2304
.text:000022F5 ; ---------------------------------------------------------------------------
.text:000022F5
.text:000022F5 loc_22F5:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):loc_23AAj
.text:000022F5                 mov     edx, [ebp+var_10C]
.text:000022FB                 add     edx, 1
.text:000022FE                 mov     [ebp+var_10C], edx
.text:00002304
.text:00002304 loc_2304:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+6EFj
.text:00002304                 mov     ecx, [ebp+this]
.text:00002307                 add     ecx, 110h
.text:0000230D                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00002312                 mov     [ebp+var_55C], eax
.text:00002318                 mov     eax, [ebp+var_10C]
.text:0000231E                 cmp     eax, [ebp+var_55C]
.text:00002324                 jnb     loc_23AF
.text:0000232A                 mov     ecx, [ebp+var_10C]
.text:00002330                 push    ecx
.text:00002331                 lea     ecx, [ebp+var_100]
.text:00002337                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000233C                 mov     [ebp+var_560], eax
.text:00002342                 mov     ecx, [ebp+var_560]
.text:00002348                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000234D                 mov     [ebp+var_564], eax
.text:00002353                 mov     edx, [ebp+var_10C]
.text:00002359                 push    edx
.text:0000235A                 mov     ecx, [ebp+this]
.text:0000235D                 add     ecx, 110h
.text:00002363                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002368                 mov     [ebp+var_568], eax
.text:0000236E                 mov     ecx, [ebp+var_568]
.text:00002374                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002379                 mov     [ebp+var_56C], eax
.text:0000237F                 mov     eax, [ebp+var_564]
.text:00002385                 push    eax             ; wchar_t *
.text:00002386                 mov     ecx, [ebp+var_56C]
.text:0000238C                 push    ecx             ; wchar_t *
.text:0000238D                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:00002392                 mov     [ebp+var_570], eax
.text:00002398                 cmp     [ebp+var_570], 0
.text:0000239F                 jz      short loc_23AA
.text:000023A1                 mov     [ebp+var_105], 1
.text:000023A8                 jmp     short loc_23AF
.text:000023AA ; ---------------------------------------------------------------------------
.text:000023AA
.text:000023AA loc_23AA:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+79Bj
.text:000023AA                 jmp     loc_22F5
.text:000023AF ; ---------------------------------------------------------------------------
.text:000023AF
.text:000023AF loc_23AF:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+720j
.text:000023AF                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+7A4j
.text:000023AF                 movzx   edx, [ebp+var_105]
.text:000023B6                 test    edx, edx
.text:000023B8                 jnz     short loc_23E0
.text:000023BA                 mov     ecx, [ebp+this]
.text:000023BD                 add     ecx, 110h
.text:000023C3                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000023C8                 mov     [ebp+var_574], eax
.text:000023CE                 mov     eax, [ebp+var_574]
.text:000023D4                 push    eax
.text:000023D5                 lea     ecx, [ebp+var_100]
.text:000023DB                 call    ?DeleteFrontal@?$CObjectVector@VUString@@@@QAEXI@Z ; CObjectVector<UString>::DeleteFrontal(uint)
.text:000023E0
.text:000023E0 loc_23E0:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+7B4j
.text:000023E0                 lea     ecx, [ebp+var_100]
.text:000023E6                 push    ecx
.text:000023E7                 lea     edx, [ebp+var_410]
.text:000023ED                 push    edx
.text:000023EE                 call    ?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z ; MakePathFromParts(CObjectVector<UString> const &)
.text:000023F3                 mov     [ebp+var_578], eax
.text:000023F9                 mov     eax, [ebp+var_578]
.text:000023FF                 mov     [ebp+var_57C], eax
.text:00002405                 mov     byte ptr [ebp+var_4], 9
.text:00002409                 mov     ecx, [ebp+var_57C]
.text:0000240F                 push    ecx
.text:00002410                 lea     ecx, [ebp+var_4C]
.text:00002413                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00002418                 mov     byte ptr [ebp+var_4], 8
.text:0000241C                 lea     ecx, [ebp+var_410] ; this
.text:00002422                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002427                 mov     byte ptr [ebp+var_4], 2
.text:0000242B                 lea     ecx, [ebp+var_100]
.text:00002431                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00002436
.text:00002436 loc_2436:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+686j
.text:00002436                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+692j ...
.text:00002436                 mov     edx, [ebp+this]
.text:00002439                 add     edx, 0C5h ; '+'
.text:0000243F                 push    edx             ; bool *
.text:00002440                 push    0Fh             ; unsigned __int32
.text:00002442                 mov     eax, [ebp+arg_4]
.text:00002445                 push    eax             ; unsigned int
.text:00002446                 mov     ecx, [ebp+var_18]
.text:00002449                 push    ecx             ; struct IInArchive *
.text:0000244A                 call    ?Archive_GetItemBoolProp@@YGJPAUIInArchive@@IKAA_N@Z ; Archive_GetItemBoolProp(IInArchive *,uint,ulong,bool &)
.text:0000244F                 mov     [ebp+var_110], eax
.text:00002455                 cmp     [ebp+var_110], 0
.text:0000245C                 jz      short loc_2481
.text:0000245E                 mov     edx, [ebp+var_110]
.text:00002464                 mov     [ebp+var_414], edx
.text:0000246A                 mov     byte ptr [ebp+var_4], 0
.text:0000246E                 lea     ecx, [ebp+var_4C] ; this
.text:00002471                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002476                 mov     eax, [ebp+var_414]
.text:0000247C                 jmp     loc_4F97
.text:00002481 ; ---------------------------------------------------------------------------
.text:00002481
.text:00002481 loc_2481:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+858j
.text:00002481                 mov     ecx, [ebp+this] ; this
.text:00002484                 call    ?GetUnpackSize@CArchiveExtractCallback@@AAEJXZ ; CArchiveExtractCallback::GetUnpackSize(void)
.text:00002489                 mov     [ebp+var_580], eax
.text:0000248F                 mov     eax, [ebp+var_580]
.text:00002495                 mov     [ebp+var_114], eax
.text:0000249B                 cmp     [ebp+var_114], 0
.text:000024A2                 jz      short loc_24C7
.text:000024A4                 mov     ecx, [ebp+var_114]
.text:000024AA                 mov     [ebp+var_418], ecx
.text:000024B0                 mov     byte ptr [ebp+var_4], 0
.text:000024B4                 lea     ecx, [ebp+var_4C] ; this
.text:000024B7                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000024BC                 mov     eax, [ebp+var_418]
.text:000024C2                 jmp     loc_4F97
.text:000024C7 ; ---------------------------------------------------------------------------
.text:000024C7
.text:000024C7 loc_24C7:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+89Ej
.text:000024C7                 mov     edx, [ebp+this]
.text:000024CA                 movzx   eax, byte ptr [edx+1Eh]
.text:000024CE                 test    eax, eax
.text:000024D0                 jnz     short loc_2501
.text:000024D2                 mov     ecx, [ebp+this]
.text:000024D5                 movzx   edx, byte ptr [ecx+98h]
.text:000024DC                 test    edx, edx
.text:000024DE                 jz      short loc_2501
.text:000024E0                 mov     [ebp+var_41C], 0
.text:000024EA                 mov     byte ptr [ebp+var_4], 0
.text:000024EE                 lea     ecx, [ebp+var_4C] ; this
.text:000024F1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000024F6                 mov     eax, [ebp+var_41C]
.text:000024FC                 jmp     loc_4F97
.text:00002501 ; ---------------------------------------------------------------------------
.text:00002501
.text:00002501 loc_2501:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+8CCj
.text:00002501                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+8DAj
.text:00002501                 mov     eax, [ebp+this]
.text:00002504                 add     eax, 74h ; 't'
.text:00002507                 mov     [ebp+var_118], eax
.text:0000250D                 mov     ecx, [ebp+this]
.text:00002510                 cmp     dword ptr [ecx+24h], 0
.text:00002514                 jz      short loc_255B
.text:00002516                 mov     edx, [ebp+this]
.text:00002519                 add     edx, 68h ; 'h'
.text:0000251C                 push    edx             ; struct CReadArcItem *
.text:0000251D                 mov     eax, [ebp+this]
.text:00002520                 mov     ecx, [eax+24h]
.text:00002523                 push    ecx             ; struct NWildcard::CCensorNode *
.text:00002524                 call    ?CensorNode_CheckPath@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@@Z ; CensorNode_CheckPath(NWildcard::CCensorNode const &,CReadArcItem const &)
.text:00002529                 mov     [ebp+var_581], al
.text:0000252F                 movzx   edx, [ebp+var_581]
.text:00002536                 test    edx, edx
.text:00002538                 jnz     short loc_255B
.text:0000253A                 mov     [ebp+var_420], 0
.text:00002544                 mov     byte ptr [ebp+var_4], 0
.text:00002548                 lea     ecx, [ebp+var_4C] ; this
.text:0000254B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002550                 mov     eax, [ebp+var_420]
.text:00002556                 jmp     loc_4F97
.text:0000255B ; ---------------------------------------------------------------------------
.text:0000255B
.text:0000255B loc_255B:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+910j
.text:0000255B                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+934j
.text:0000255B                 mov     eax, [ebp+this]
.text:0000255E                 movzx   ecx, byte ptr [eax+11Ch]
.text:00002565                 test    ecx, ecx
.text:00002567                 jz      loc_2616
.text:0000256D                 mov     ecx, [ebp+var_118]
.text:00002573                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:00002578                 mov     [ebp+var_582], al
.text:0000257E                 movzx   edx, [ebp+var_582]
.text:00002585                 test    edx, edx
.text:00002587                 jnz     loc_2611
.text:0000258D                 mov     [ebp+var_11C], 0
.text:00002597                 mov     eax, [ebp+this]
.text:0000259A                 cmp     dword ptr [eax+54h], 4
.text:0000259E                 jnz     short loc_25CD
.text:000025A0                 mov     ecx, [ebp+this]
.text:000025A3                 movzx   edx, byte ptr [ecx+98h]
.text:000025AA                 test    edx, edx
.text:000025AC                 jz      short loc_25CD
.text:000025AE                 mov     ecx, [ebp+var_118]
.text:000025B4                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000025B9                 mov     [ebp+var_588], eax
.text:000025BF                 mov     eax, [ebp+var_588]
.text:000025C5                 mov     [ebp+var_11C], eax
.text:000025CB                 jmp     short loc_25FF
.text:000025CD ; ---------------------------------------------------------------------------
.text:000025CD
.text:000025CD loc_25CD:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+99Aj
.text:000025CD                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+9A8j
.text:000025CD                 mov     ecx, [ebp+this]
.text:000025D0                 cmp     dword ptr [ecx+54h], 2
.text:000025D4                 jz      short loc_25DF
.text:000025D6                 mov     edx, [ebp+this]
.text:000025D9                 cmp     dword ptr [edx+54h], 4
.text:000025DD                 jnz     short loc_25FF
.text:000025DF
.text:000025DF loc_25DF:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+9D0j
.text:000025DF                 mov     ecx, [ebp+var_118]
.text:000025E5                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000025EA                 mov     [ebp+var_58C], eax
.text:000025F0                 mov     eax, [ebp+var_58C]
.text:000025F6                 sub     eax, 1
.text:000025F9                 mov     [ebp+var_11C], eax
.text:000025FF
.text:000025FF loc_25FF:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+9C7j
.text:000025FF                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+9D9j
.text:000025FF                 mov     ecx, [ebp+var_11C]
.text:00002605                 push    ecx
.text:00002606                 mov     ecx, [ebp+var_118]
.text:0000260C                 call    ?DeleteFrontal@?$CObjectVector@VUString@@@@QAEXI@Z ; CObjectVector<UString>::DeleteFrontal(uint)
.text:00002611
.text:00002611 loc_2611:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+983j
.text:00002611                 jmp     loc_295D
.text:00002616 ; ---------------------------------------------------------------------------
.text:00002616
.text:00002616 loc_2616:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+963j
.text:00002616                 mov     ecx, [ebp+var_118]
.text:0000261C                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:00002621                 mov     [ebp+var_58D], al
.text:00002627                 movzx   edx, [ebp+var_58D]
.text:0000262E                 test    edx, edx
.text:00002630                 jz      short loc_2661
.text:00002632                 mov     eax, [ebp+this]
.text:00002635                 movzx   ecx, byte ptr [eax+9Ah]
.text:0000263C                 test    ecx, ecx
.text:0000263E                 jz      short loc_2661
.text:00002640                 mov     [ebp+var_424], 0
.text:0000264A                 mov     byte ptr [ebp+var_4], 0
.text:0000264E                 lea     ecx, [ebp+var_4C] ; this
.text:00002651                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002656                 mov     eax, [ebp+var_424]
.text:0000265C                 jmp     loc_4F97
.text:00002661 ; ---------------------------------------------------------------------------
.text:00002661
.text:00002661 loc_2661:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+A2Cj
.text:00002661                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+A3Aj
.text:00002661                 mov     [ebp+var_120], 0
.text:0000266B                 mov     edx, [ebp+this]
.text:0000266E                 mov     eax, [edx+54h]
.text:00002671                 mov     [ebp+var_594], eax
.text:00002677                 cmp     [ebp+var_594], 4 ; switch 5 cases
.text:0000267E                 ja      $LN139          ; jumptable 0000268A default case
.text:00002684                 mov     ecx, [ebp+var_594]
.text:0000268A                 jmp     ds:$LN288[ecx*4] ; switch jump
.text:00002691 ; ---------------------------------------------------------------------------
.text:00002691
.text:00002691 $LN138:                                 ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+A86j
.text:00002691                                         ; DATA XREF: .text:$LN288o
.text:00002691                 mov     ecx, [ebp+this] ; jumptable 0000268A cases 0,1
.text:00002694                 add     ecx, 110h
.text:0000269A                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:0000269F                 mov     [ebp+var_595], al
.text:000026A5                 movzx   edx, [ebp+var_595]
.text:000026AC                 test    edx, edx
.text:000026AE                 jz      short loc_26B5
.text:000026B0                 jmp     $LN139          ; jumptable 0000268A default case
.text:000026B5 ; ---------------------------------------------------------------------------
.text:000026B5
.text:000026B5 loc_26B5:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+AAAj
.text:000026B5                 mov     [ebp+var_121], 0
.text:000026BC                 mov     ecx, [ebp+var_118]
.text:000026C2                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000026C7                 mov     [ebp+var_59C], eax
.text:000026CD                 mov     ecx, [ebp+this]
.text:000026D0                 add     ecx, 110h
.text:000026D6                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000026DB                 mov     [ebp+var_5A0], eax
.text:000026E1                 mov     eax, [ebp+var_59C]
.text:000026E7                 cmp     eax, [ebp+var_5A0]
.text:000026ED                 jnb     short loc_26FB
.text:000026EF                 mov     [ebp+var_121], 1
.text:000026F6                 jmp     loc_283D
.text:000026FB ; ---------------------------------------------------------------------------
.text:000026FB
.text:000026FB loc_26FB:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+AE9j
.text:000026FB                 mov     ecx, [ebp+var_118]
.text:00002701                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00002706                 mov     [ebp+var_5A4], eax
.text:0000270C                 mov     ecx, [ebp+this]
.text:0000270F                 add     ecx, 110h
.text:00002715                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000271A                 mov     [ebp+var_5A8], eax
.text:00002720                 mov     ecx, [ebp+var_5A4]
.text:00002726                 cmp     ecx, [ebp+var_5A8]
.text:0000272C                 jnz     short loc_2768
.text:0000272E                 mov     edx, [ebp+this]
.text:00002731                 movzx   eax, byte ptr [edx+10Dh]
.text:00002738                 test    eax, eax
.text:0000273A                 jz      short loc_2753
.text:0000273C                 mov     ecx, [ebp+this]
.text:0000273F                 movzx   edx, byte ptr [ecx+98h]
.text:00002746                 test    edx, edx
.text:00002748                 jnz     short loc_2751
.text:0000274A                 mov     [ebp+var_121], 1
.text:00002751
.text:00002751 loc_2751:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+B44j
.text:00002751                 jmp     short loc_2768
.text:00002753 ; ---------------------------------------------------------------------------
.text:00002753
.text:00002753 loc_2753:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+B36j
.text:00002753                 mov     eax, [ebp+this]
.text:00002756                 movzx   ecx, byte ptr [eax+9Bh]
.text:0000275D                 test    ecx, ecx
.text:0000275F                 jnz     short loc_2768
.text:00002761                 mov     [ebp+var_121], 1
.text:00002768
.text:00002768 loc_2768:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+B28j
.text:00002768                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):loc_2751j ...
.text:00002768                 movzx   edx, [ebp+var_121]
.text:0000276F                 test    edx, edx
.text:00002771                 jnz     loc_283D
.text:00002777                 mov     [ebp+var_128], 0
.text:00002781                 jmp     short loc_2792
.text:00002783 ; ---------------------------------------------------------------------------
.text:00002783
.text:00002783 loc_2783:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):loc_2838j
.text:00002783                 mov     eax, [ebp+var_128]
.text:00002789                 add     eax, 1
.text:0000278C                 mov     [ebp+var_128], eax
.text:00002792
.text:00002792 loc_2792:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+B7Dj
.text:00002792                 mov     ecx, [ebp+this]
.text:00002795                 add     ecx, 110h
.text:0000279B                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000027A0                 mov     [ebp+var_5AC], eax
.text:000027A6                 mov     ecx, [ebp+var_128]
.text:000027AC                 cmp     ecx, [ebp+var_5AC]
.text:000027B2                 jnb     loc_283D
.text:000027B8                 mov     edx, [ebp+var_128]
.text:000027BE                 push    edx
.text:000027BF                 mov     ecx, [ebp+var_118]
.text:000027C5                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000027CA                 mov     [ebp+var_5B0], eax
.text:000027D0                 mov     ecx, [ebp+var_5B0]
.text:000027D6                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000027DB                 mov     [ebp+var_5B4], eax
.text:000027E1                 mov     eax, [ebp+var_128]
.text:000027E7                 push    eax
.text:000027E8                 mov     ecx, [ebp+this]
.text:000027EB                 add     ecx, 110h
.text:000027F1                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000027F6                 mov     [ebp+var_5B8], eax
.text:000027FC                 mov     ecx, [ebp+var_5B8]
.text:00002802                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002807                 mov     [ebp+var_5BC], eax
.text:0000280D                 mov     ecx, [ebp+var_5B4]
.text:00002813                 push    ecx             ; wchar_t *
.text:00002814                 mov     edx, [ebp+var_5BC]
.text:0000281A                 push    edx             ; wchar_t *
.text:0000281B                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:00002820                 mov     [ebp+var_5C0], eax
.text:00002826                 cmp     [ebp+var_5C0], 0
.text:0000282D                 jz      short loc_2838
.text:0000282F                 mov     [ebp+var_121], 1
.text:00002836                 jmp     short loc_283D
.text:00002838 ; ---------------------------------------------------------------------------
.text:00002838
.text:00002838 loc_2838:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+C29j
.text:00002838                 jmp     loc_2783
.text:0000283D ; ---------------------------------------------------------------------------
.text:0000283D
.text:0000283D loc_283D:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+AF2j
.text:0000283D                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+B6Dj ...
.text:0000283D                 movzx   eax, [ebp+var_121]
.text:00002844                 test    eax, eax
.text:00002846                 jz      short loc_287F
.text:00002848                 cmp     [ebp+arg_C], 0
.text:0000284C                 jnz     short loc_287D
.text:0000284E                 mov     ecx, [ebp+this]
.text:00002851                 movzx   edx, byte ptr [ecx+125h]
.text:00002858                 test    edx, edx
.text:0000285A                 jnz     short loc_287D
.text:0000285C                 mov     [ebp+var_428], 80004005h
.text:00002866                 mov     byte ptr [ebp+var_4], 0
.text:0000286A                 lea     ecx, [ebp+var_4C] ; this
.text:0000286D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002872                 mov     eax, [ebp+var_428]
.text:00002878                 jmp     loc_4F97
.text:0000287D ; ---------------------------------------------------------------------------
.text:0000287D
.text:0000287D loc_287D:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+C48j
.text:0000287D                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+C56j
.text:0000287D                 jmp     short loc_289F
.text:0000287F ; ---------------------------------------------------------------------------
.text:0000287F
.text:0000287F loc_287F:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+C42j
.text:0000287F                 mov     ecx, [ebp+this]
.text:00002882                 add     ecx, 110h
.text:00002888                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000288D                 mov     [ebp+var_5C4], eax
.text:00002893                 mov     eax, [ebp+var_5C4]
.text:00002899                 mov     [ebp+var_120], eax
.text:0000289F
.text:0000289F loc_289F:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):loc_287Dj
.text:0000289F                 jmp     $LN139          ; jumptable 0000268A default case
.text:000028A4 ; ---------------------------------------------------------------------------
.text:000028A4
.text:000028A4 $LN121:                                 ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+A86j
.text:000028A4                                         ; DATA XREF: .text:$LN288o
.text:000028A4                 mov     ecx, [ebp+var_118] ; jumptable 0000268A case 2
.text:000028AA                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:000028AF                 mov     [ebp+var_5C5], al
.text:000028B5                 movzx   ecx, [ebp+var_5C5]
.text:000028BC                 test    ecx, ecx
.text:000028BE                 jnz     short loc_28E0
.text:000028C0                 mov     ecx, [ebp+var_118]
.text:000028C6                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000028CB                 mov     [ebp+var_5CC], eax
.text:000028D1                 mov     edx, [ebp+var_5CC]
.text:000028D7                 sub     edx, 1
.text:000028DA                 mov     [ebp+var_120], edx
.text:000028E0
.text:000028E0 loc_28E0:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+CBAj
.text:000028E0                 jmp     short $LN139    ; jumptable 0000268A default case
.text:000028E2 ; ---------------------------------------------------------------------------
.text:000028E2
.text:000028E2 $LN119:                                 ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+A86j
.text:000028E2                                         ; DATA XREF: .text:$LN288o
.text:000028E2                 mov     eax, [ebp+this] ; jumptable 0000268A case 4
.text:000028E5                 movzx   ecx, byte ptr [eax+98h]
.text:000028EC                 test    ecx, ecx
.text:000028EE                 jz      short loc_290F
.text:000028F0                 mov     ecx, [ebp+var_118]
.text:000028F6                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000028FB                 mov     [ebp+var_5D0], eax
.text:00002901                 mov     edx, [ebp+var_5D0]
.text:00002907                 mov     [ebp+var_120], edx
.text:0000290D                 jmp     short $LN139    ; jumptable 0000268A default case
.text:0000290F ; ---------------------------------------------------------------------------
.text:0000290F
.text:0000290F loc_290F:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+CEAj
.text:0000290F                 mov     ecx, [ebp+var_118]
.text:00002915                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:0000291A                 mov     [ebp+var_5D1], al
.text:00002920                 movzx   eax, [ebp+var_5D1]
.text:00002927                 test    eax, eax
.text:00002929                 jnz     short $LN139    ; jumptable 0000268A default case
.text:0000292B                 mov     ecx, [ebp+var_118]
.text:00002931                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00002936                 mov     [ebp+var_5D8], eax
.text:0000293C                 mov     ecx, [ebp+var_5D8]
.text:00002942                 sub     ecx, 1
.text:00002945                 mov     [ebp+var_120], ecx
.text:0000294B
.text:0000294B $LN139:                                 ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+A7Aj
.text:0000294B                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+A86j ...
.text:0000294B                 mov     edx, [ebp+var_120] ; jumptable 0000268A default case
.text:00002951                 push    edx
.text:00002952                 mov     ecx, [ebp+var_118]
.text:00002958                 call    ?DeleteFrontal@?$CObjectVector@VUString@@@@QAEXI@Z ; CObjectVector<UString>::DeleteFrontal(uint)
.text:0000295D
.text:0000295D loc_295D:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):loc_2611j
.text:0000295D                 mov     ecx, [ebp+this]
.text:00002960                 add     ecx, 5Ch ; '\'
.text:00002963                 call    ??B?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::operator IFolderExtractToStreamCallback *(void)
.text:00002968                 mov     [ebp+var_5DC], eax
.text:0000296E                 cmp     [ebp+var_5DC], 0
.text:00002975                 jz      loc_2B7D
.text:0000297B                 mov     ecx, [ebp+this]
.text:0000297E                 add     ecx, 64h ; 'd'
.text:00002981                 call    ??7?$CMyComPtr@UIGetProp@@@@QBE_NXZ ; CMyComPtr<IGetProp>::operator!(void)
.text:00002986                 mov     [ebp+var_5DD], al
.text:0000298C                 movzx   eax, [ebp+var_5DD]
.text:00002993                 test    eax, eax
.text:00002995                 jz      loc_2A1B
.text:0000299B                 push    10h             ; unsigned int
.text:0000299D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000029A2                 add     esp, 4
.text:000029A5                 mov     [ebp+var_5E4], eax
.text:000029AB                 mov     ecx, [ebp+var_5E4]
.text:000029B1                 mov     [ebp+var_430], ecx
.text:000029B7                 mov     byte ptr [ebp+var_4], 0Ah
.text:000029BB                 cmp     [ebp+var_430], 0
.text:000029C2                 jz      short loc_29E3
.text:000029C4                 mov     ecx, [ebp+var_430]
.text:000029CA                 call    ??0CGetProp@@QAE@XZ ; CGetProp::CGetProp(void)
.text:000029CF                 mov     [ebp+var_5E8], eax
.text:000029D5                 mov     edx, [ebp+var_5E8]
.text:000029DB                 mov     [ebp+var_5EC], edx
.text:000029E1                 jmp     short loc_29ED
.text:000029E3 ; ---------------------------------------------------------------------------
.text:000029E3
.text:000029E3 loc_29E3:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+DBEj
.text:000029E3                 mov     [ebp+var_5EC], 0
.text:000029ED
.text:000029ED loc_29ED:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+DDDj
.text:000029ED                 mov     eax, [ebp+var_5EC]
.text:000029F3                 mov     [ebp+var_42C], eax
.text:000029F9                 mov     byte ptr [ebp+var_4], 2
.text:000029FD                 mov     ecx, [ebp+this]
.text:00002A00                 mov     edx, [ebp+var_42C]
.text:00002A06                 mov     [ecx+60h], edx
.text:00002A09                 mov     eax, [ebp+this]
.text:00002A0C                 mov     ecx, [eax+60h]
.text:00002A0F                 push    ecx
.text:00002A10                 mov     ecx, [ebp+this]
.text:00002A13                 add     ecx, 64h ; 'd'
.text:00002A16                 call    ??4?$CMyComPtr@UIGetProp@@@@QAEPAUIGetProp@@PAU1@@Z ; CMyComPtr<IGetProp>::operator=(IGetProp *)
.text:00002A1B
.text:00002A1B loc_2A1B:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+D91j
.text:00002A1B                 mov     edx, [ebp+this]
.text:00002A1E                 mov     eax, [edx+60h]
.text:00002A21                 mov     ecx, [ebp+this]
.text:00002A24                 mov     edx, [ecx+14h]
.text:00002A27                 mov     [eax+8], edx
.text:00002A2A                 mov     eax, [ebp+this]
.text:00002A2D                 mov     ecx, [eax+60h]
.text:00002A30                 mov     edx, [ebp+arg_4]
.text:00002A33                 mov     [ecx+0Ch], edx
.text:00002A36                 mov     eax, [ebp+var_118]
.text:00002A3C                 push    eax
.text:00002A3D                 lea     ecx, [ebp+var_138]
.text:00002A43                 push    ecx
.text:00002A44                 call    ?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z ; MakePathFromParts(CObjectVector<UString> const &)
.text:00002A49                 mov     [ebp+var_5F0], eax
.text:00002A4F                 mov     byte ptr [ebp+var_4], 0Bh
.text:00002A53                 mov     edx, [ebp+this]
.text:00002A56                 movzx   eax, byte ptr [edx+98h]
.text:00002A5D                 test    eax, eax
.text:00002A5F                 jz      short loc_2AB6
.text:00002A61                 mov     ecx, [ebp+var_118]
.text:00002A67                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:00002A6C                 mov     [ebp+var_5F1], al
.text:00002A72                 movzx   ecx, [ebp+var_5F1]
.text:00002A79                 test    ecx, ecx
.text:00002A7B                 jz      short loc_2A94
.text:00002A7D                 mov     edx, [ebp+this]
.text:00002A80                 movzx   eax, byte ptr [edx+10Dh]
.text:00002A87                 test    eax, eax
.text:00002A89                 jnz     short loc_2AA1
.text:00002A8B                 mov     ecx, [ebp+this]
.text:00002A8E                 cmp     dword ptr [ecx+54h], 4
.text:00002A92                 jz      short loc_2AA1
.text:00002A94
.text:00002A94 loc_2A94:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+E77j
.text:00002A94                 push    3Ah ; ':'
.text:00002A96                 lea     ecx, [ebp+var_138]
.text:00002A9C                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:00002AA1
.text:00002AA1 loc_2AA1:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+E85j
.text:00002AA1                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+E8Ej
.text:00002AA1                 mov     edx, [ebp+this]
.text:00002AA4                 add     edx, 8Ch ; 'î'
.text:00002AAA                 push    edx
.text:00002AAB                 lea     ecx, [ebp+var_138]
.text:00002AB1                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00002AB6
.text:00002AB6 loc_2AB6:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+E5Bj
.text:00002AB6                 mov     ecx, [ebp+this]
.text:00002AB9                 add     ecx, 5Ch ; '\'
.text:00002ABC                 call    ??C?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::operator->(void)
.text:00002AC1                 mov     [ebp+var_5F8], eax
.text:00002AC7                 mov     eax, [ebp+var_5F8]
.text:00002ACD                 mov     [ebp+var_5FC], eax
.text:00002AD3                 mov     ecx, [ebp+this]
.text:00002AD6                 add     ecx, 64h ; 'd'
.text:00002AD9                 call    ??B?$CMyComPtr@UIGetProp@@@@QBEPAUIGetProp@@XZ ; CMyComPtr<IGetProp>::operator IGetProp *(void)
.text:00002ADE                 mov     [ebp+var_600], eax
.text:00002AE4                 mov     ecx, [ebp+this]
.text:00002AE7                 movzx   edx, byte ptr [ecx+9Ah]
.text:00002AEE                 push    edx             ; bool
.text:00002AEF                 call    ?BoolToInt@@YGH_N@Z ; BoolToInt(bool)
.text:00002AF4                 mov     [ebp+var_604], eax
.text:00002AFA                 lea     ecx, [ebp+var_138]
.text:00002B00                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002B05                 mov     [ebp+var_608], eax
.text:00002B0B                 mov     esi, esp
.text:00002B0D                 mov     eax, [ebp+var_600]
.text:00002B13                 push    eax
.text:00002B14                 mov     ecx, [ebp+arg_C]
.text:00002B17                 push    ecx
.text:00002B18                 mov     edx, [ebp+arg_8]
.text:00002B1B                 push    edx
.text:00002B1C                 mov     eax, [ebp+var_604]
.text:00002B22                 push    eax
.text:00002B23                 mov     ecx, [ebp+var_608]
.text:00002B29                 push    ecx
.text:00002B2A                 mov     edx, [ebp+var_5FC]
.text:00002B30                 push    edx
.text:00002B31                 mov     eax, [ebp+var_5FC]
.text:00002B37                 mov     ecx, [eax]
.text:00002B39                 mov     edx, [ecx+10h]
.text:00002B3C                 call    edx
.text:00002B3E                 cmp     esi, esp
.text:00002B40                 call    __RTC_CheckEsp
.text:00002B45                 mov     [ebp+var_60C], eax
.text:00002B4B                 mov     eax, [ebp+var_60C]
.text:00002B51                 mov     [ebp+var_434], eax
.text:00002B57                 mov     byte ptr [ebp+var_4], 2
.text:00002B5B                 lea     ecx, [ebp+var_138] ; this
.text:00002B61                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002B66                 mov     byte ptr [ebp+var_4], 0
.text:00002B6A                 lea     ecx, [ebp+var_4C] ; this
.text:00002B6D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002B72                 mov     eax, [ebp+var_434]
.text:00002B78                 jmp     loc_4F97
.text:00002B7D ; ---------------------------------------------------------------------------
.text:00002B7D
.text:00002B7D loc_2B7D:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+D71j
.text:00002B7D                 lea     ecx, [ebp+var_144]
.text:00002B83                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(void)
.text:00002B88                 mov     [ebp+var_610], eax
.text:00002B8E                 mov     byte ptr [ebp+var_4], 0Ch
.text:00002B92                 cmp     [ebp+arg_C], 0
.text:00002B96                 jnz     loc_4E8B
.text:00002B9C                 mov     ecx, [ebp+this]
.text:00002B9F                 movzx   edx, byte ptr [ecx+125h]
.text:00002BA6                 test    edx, edx
.text:00002BA8                 jnz     loc_4E8B
.text:00002BAE                 mov     eax, [ebp+this]
.text:00002BB1                 movzx   ecx, byte ptr [eax+124h]
.text:00002BB8                 test    ecx, ecx
.text:00002BBA                 jz      short loc_2C35
.text:00002BBC                 push    10h             ; unsigned int
.text:00002BBE                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002BC3                 add     esp, 4
.text:00002BC6                 mov     [ebp+var_614], eax
.text:00002BCC                 mov     edx, [ebp+var_614]
.text:00002BD2                 mov     [ebp+var_43C], edx
.text:00002BD8                 mov     byte ptr [ebp+var_4], 0Dh
.text:00002BDC                 cmp     [ebp+var_43C], 0
.text:00002BE3                 jz      short loc_2C04
.text:00002BE5                 mov     ecx, [ebp+var_43C]
.text:00002BEB                 call    ??0CStdOutFileStream@@QAE@XZ ; CStdOutFileStream::CStdOutFileStream(void)
.text:00002BF0                 mov     [ebp+var_618], eax
.text:00002BF6                 mov     eax, [ebp+var_618]
.text:00002BFC                 mov     [ebp+var_61C], eax
.text:00002C02                 jmp     short loc_2C0E
.text:00002C04 ; ---------------------------------------------------------------------------
.text:00002C04
.text:00002C04 loc_2C04:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+FDFj
.text:00002C04                 mov     [ebp+var_61C], 0
.text:00002C0E
.text:00002C0E loc_2C0E:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+FFEj
.text:00002C0E                 mov     ecx, [ebp+var_61C]
.text:00002C14                 mov     [ebp+var_438], ecx
.text:00002C1A                 mov     byte ptr [ebp+var_4], 0Ch
.text:00002C1E                 mov     edx, [ebp+var_438]
.text:00002C24                 push    edx
.text:00002C25                 lea     ecx, [ebp+var_144]
.text:00002C2B                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:00002C30                 jmp     loc_4E8B
.text:00002C35 ; ---------------------------------------------------------------------------
.text:00002C35
.text:00002C35 loc_2C35:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+FB6j
.text:00002C35                 lea     ecx, [ebp+var_15C] ; this
.text:00002C3B                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00002C40                 mov     [ebp+var_620], eax
.text:00002C46                 mov     byte ptr [ebp+var_4], 0Eh
.text:00002C4A                 mov     esi, esp
.text:00002C4C                 lea     eax, [ebp+var_15C]
.text:00002C52                 push    eax
.text:00002C53                 push    9
.text:00002C55                 mov     ecx, [ebp+arg_4]
.text:00002C58                 push    ecx
.text:00002C59                 mov     edx, [ebp+var_18]
.text:00002C5C                 push    edx
.text:00002C5D                 mov     eax, [ebp+var_18]
.text:00002C60                 mov     ecx, [eax]
.text:00002C62                 mov     edx, [ecx+18h]
.text:00002C65                 call    edx
.text:00002C67                 cmp     esi, esp
.text:00002C69                 call    __RTC_CheckEsp
.text:00002C6E                 mov     [ebp+var_624], eax
.text:00002C74                 mov     eax, [ebp+var_624]
.text:00002C7A                 mov     [ebp+var_164], eax
.text:00002C80                 cmp     [ebp+var_164], 0
.text:00002C87                 jz      short loc_2CCA
.text:00002C89                 mov     ecx, [ebp+var_164]
.text:00002C8F                 mov     [ebp+var_440], ecx
.text:00002C95                 mov     byte ptr [ebp+var_4], 0Ch
.text:00002C99                 lea     ecx, [ebp+var_15C] ; this
.text:00002C9F                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00002CA4                 mov     byte ptr [ebp+var_4], 2
.text:00002CA8                 lea     ecx, [ebp+var_144]
.text:00002CAE                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002CB3                 mov     byte ptr [ebp+var_4], 0
.text:00002CB7                 lea     ecx, [ebp+var_4C] ; this
.text:00002CBA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002CBF                 mov     eax, [ebp+var_440]
.text:00002CC5                 jmp     loc_4F97
.text:00002CCA ; ---------------------------------------------------------------------------
.text:00002CCA
.text:00002CCA loc_2CCA:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1083j
.text:00002CCA                 movzx   edx, [ebp+var_15C]
.text:00002CD1                 cmp     edx, 13h
.text:00002CD4                 jnz     short loc_2CF1
.text:00002CD6                 mov     eax, [ebp+this]
.text:00002CD9                 mov     ecx, [ebp+var_154]
.text:00002CDF                 mov     [eax+0E0h], ecx
.text:00002CE5                 mov     edx, [ebp+this]
.text:00002CE8                 mov     byte ptr [edx+0E7h], 1
.text:00002CEF                 jmp     short loc_2D47
.text:00002CF1 ; ---------------------------------------------------------------------------
.text:00002CF1
.text:00002CF1 loc_2CF1:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+10D0j
.text:00002CF1                 movzx   eax, [ebp+var_15C]
.text:00002CF8                 test    eax, eax
.text:00002CFA                 jnz     short loc_2D08
.text:00002CFC                 mov     ecx, [ebp+this]
.text:00002CFF                 mov     byte ptr [ecx+0E7h], 0
.text:00002D06                 jmp     short loc_2D47
.text:00002D08 ; ---------------------------------------------------------------------------
.text:00002D08
.text:00002D08 loc_2D08:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+10F6j
.text:00002D08                 mov     [ebp+var_444], 80004005h
.text:00002D12                 mov     byte ptr [ebp+var_4], 0Ch
.text:00002D16                 lea     ecx, [ebp+var_15C] ; this
.text:00002D1C                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00002D21                 mov     byte ptr [ebp+var_4], 2
.text:00002D25                 lea     ecx, [ebp+var_144]
.text:00002D2B                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002D30                 mov     byte ptr [ebp+var_4], 0
.text:00002D34                 lea     ecx, [ebp+var_4C] ; this
.text:00002D37                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002D3C                 mov     eax, [ebp+var_444]
.text:00002D42                 jmp     loc_4F97
.text:00002D47 ; ---------------------------------------------------------------------------
.text:00002D47
.text:00002D47 loc_2D47:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+10EBj
.text:00002D47                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1102j
.text:00002D47                 mov     byte ptr [ebp+var_4], 0Ch
.text:00002D4B                 lea     ecx, [ebp+var_15C] ; this
.text:00002D51                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00002D56                 mov     edx, [ebp+this]
.text:00002D59                 add     edx, 0E4h ; 'S'
.text:00002D5F                 push    edx             ; bool *
.text:00002D60                 mov     eax, [ebp+this]
.text:00002D63                 add     eax, 0C8h ; '+'
.text:00002D68                 push    eax             ; struct _FILETIME *
.text:00002D69                 push    0Ah             ; unsigned __int32
.text:00002D6B                 mov     ecx, [ebp+arg_4]
.text:00002D6E                 push    ecx             ; int
.text:00002D6F                 mov     ecx, [ebp+this] ; this
.text:00002D72                 call    ?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z ; CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)
.text:00002D77                 mov     [ebp+var_628], eax
.text:00002D7D                 mov     edx, [ebp+var_628]
.text:00002D83                 mov     [ebp+var_168], edx
.text:00002D89                 cmp     [ebp+var_168], 0
.text:00002D90                 jz      short loc_2DC4
.text:00002D92                 mov     eax, [ebp+var_168]
.text:00002D98                 mov     [ebp+var_448], eax
.text:00002D9E                 mov     byte ptr [ebp+var_4], 2
.text:00002DA2                 lea     ecx, [ebp+var_144]
.text:00002DA8                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002DAD                 mov     byte ptr [ebp+var_4], 0
.text:00002DB1                 lea     ecx, [ebp+var_4C] ; this
.text:00002DB4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002DB9                 mov     eax, [ebp+var_448]
.text:00002DBF                 jmp     loc_4F97
.text:00002DC4 ; ---------------------------------------------------------------------------
.text:00002DC4
.text:00002DC4 loc_2DC4:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+118Cj
.text:00002DC4                 mov     ecx, [ebp+this]
.text:00002DC7                 add     ecx, 0E5h ; 's'
.text:00002DCD                 push    ecx             ; bool *
.text:00002DCE                 mov     edx, [ebp+this]
.text:00002DD1                 add     edx, 0D0h ; '-'
.text:00002DD7                 push    edx             ; struct _FILETIME *
.text:00002DD8                 push    0Bh             ; unsigned __int32
.text:00002DDA                 mov     eax, [ebp+arg_4]
.text:00002DDD                 push    eax             ; int
.text:00002DDE                 mov     ecx, [ebp+this] ; this
.text:00002DE1                 call    ?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z ; CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)
.text:00002DE6                 mov     [ebp+var_62C], eax
.text:00002DEC                 mov     ecx, [ebp+var_62C]
.text:00002DF2                 mov     [ebp+var_16C], ecx
.text:00002DF8                 cmp     [ebp+var_16C], 0
.text:00002DFF                 jz      short loc_2E33
.text:00002E01                 mov     edx, [ebp+var_16C]
.text:00002E07                 mov     [ebp+var_44C], edx
.text:00002E0D                 mov     byte ptr [ebp+var_4], 2
.text:00002E11                 lea     ecx, [ebp+var_144]
.text:00002E17                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002E1C                 mov     byte ptr [ebp+var_4], 0
.text:00002E20                 lea     ecx, [ebp+var_4C] ; this
.text:00002E23                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002E28                 mov     eax, [ebp+var_44C]
.text:00002E2E                 jmp     loc_4F97
.text:00002E33 ; ---------------------------------------------------------------------------
.text:00002E33
.text:00002E33 loc_2E33:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+11FBj
.text:00002E33                 mov     eax, [ebp+this]
.text:00002E36                 add     eax, 0E6h ; 'µ'
.text:00002E3B                 push    eax             ; bool *
.text:00002E3C                 mov     ecx, [ebp+this]
.text:00002E3F                 add     ecx, 0D8h ; '+'
.text:00002E45                 push    ecx             ; struct _FILETIME *
.text:00002E46                 push    0Ch             ; unsigned __int32
.text:00002E48                 mov     edx, [ebp+arg_4]
.text:00002E4B                 push    edx             ; int
.text:00002E4C                 mov     ecx, [ebp+this] ; this
.text:00002E4F                 call    ?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z ; CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)
.text:00002E54                 mov     [ebp+var_630], eax
.text:00002E5A                 mov     eax, [ebp+var_630]
.text:00002E60                 mov     [ebp+var_170], eax
.text:00002E66                 cmp     [ebp+var_170], 0
.text:00002E6D                 jz      short loc_2EA1
.text:00002E6F                 mov     ecx, [ebp+var_170]
.text:00002E75                 mov     [ebp+var_450], ecx
.text:00002E7B                 mov     byte ptr [ebp+var_4], 2
.text:00002E7F                 lea     ecx, [ebp+var_144]
.text:00002E85                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002E8A                 mov     byte ptr [ebp+var_4], 0
.text:00002E8E                 lea     ecx, [ebp+var_4C] ; this
.text:00002E91                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002E96                 mov     eax, [ebp+var_450]
.text:00002E9C                 jmp     loc_4F97
.text:00002EA1 ; ---------------------------------------------------------------------------
.text:00002EA1
.text:00002EA1 loc_2EA1:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1269j
.text:00002EA1                 mov     [ebp+var_175], 0
.text:00002EA8                 lea     edx, [ebp+var_175]
.text:00002EAE                 push    edx             ; bool *
.text:00002EAF                 mov     eax, [ebp+arg_4]
.text:00002EB2                 push    eax             ; unsigned int
.text:00002EB3                 mov     ecx, [ebp+this]
.text:00002EB6                 mov     ecx, [ecx+14h]  ; this
.text:00002EB9                 call    ?IsItemAnti@CArc@@QBEJIAA_N@Z ; CArc::IsItemAnti(uint,bool &)
.text:00002EBE                 mov     [ebp+var_634], eax
.text:00002EC4                 mov     edx, [ebp+var_634]
.text:00002ECA                 mov     [ebp+var_180], edx
.text:00002ED0                 cmp     [ebp+var_180], 0
.text:00002ED7                 jz      short loc_2F0B
.text:00002ED9                 mov     eax, [ebp+var_180]
.text:00002EDF                 mov     [ebp+var_454], eax
.text:00002EE5                 mov     byte ptr [ebp+var_4], 2
.text:00002EE9                 lea     ecx, [ebp+var_144]
.text:00002EEF                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002EF4                 mov     byte ptr [ebp+var_4], 0
.text:00002EF8                 lea     ecx, [ebp+var_4C] ; this
.text:00002EFB                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002F00                 mov     eax, [ebp+var_454]
.text:00002F06                 jmp     loc_4F97
.text:00002F0B ; ---------------------------------------------------------------------------
.text:00002F0B
.text:00002F0B loc_2F0B:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+12D3j
.text:00002F0B                 mov     ecx, [ebp+this]
.text:00002F0E                 movzx   edx, byte ptr [ecx+9Bh]
.text:00002F15                 push    edx
.text:00002F16                 mov     eax, [ebp+var_118]
.text:00002F1C                 push    eax
.text:00002F1D                 mov     ecx, [ebp+this]
.text:00002F20                 cmp     dword ptr [ecx+54h], 3
.text:00002F24                 setz    dl
.text:00002F27                 movzx   eax, dl
.text:00002F2A                 push    eax
.text:00002F2B                 call    ?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z ; Correct_FsPath(bool,CObjectVector<UString> &,bool)
.text:00002F30                 mov     ecx, [ebp+this]
.text:00002F33                 movzx   edx, byte ptr [ecx+98h]
.text:00002F3A                 test    edx, edx
.text:00002F3C                 jz      loc_3093
.text:00002F42                 mov     eax, [ebp+this]
.text:00002F45                 add     eax, 8Ch ; 'î'
.text:00002F4A                 push    eax
.text:00002F4B                 lea     ecx, [ebp+var_190]
.text:00002F51                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00002F56                 mov     [ebp+var_638], eax
.text:00002F5C                 mov     byte ptr [ebp+var_4], 0Fh
.text:00002F60                 lea     ecx, [ebp+var_190]
.text:00002F66                 push    ecx             ; struct UString *
.text:00002F67                 call    ?Correct_AltStream_Name@@YGXAAVUString@@@Z ; Correct_AltStream_Name(UString &)
.text:00002F6C                 mov     edx, [ebp+this]
.text:00002F6F                 movzx   eax, byte ptr [edx+10Dh]
.text:00002F76                 test    eax, eax
.text:00002F78                 jnz     short loc_2F83
.text:00002F7A                 mov     ecx, [ebp+this]
.text:00002F7D                 cmp     dword ptr [ecx+54h], 4
.text:00002F81                 jnz     short loc_2FAB
.text:00002F83
.text:00002F83 loc_2F83:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1374j
.text:00002F83                 mov     ecx, [ebp+var_118]
.text:00002F89                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:00002F8E                 mov     [ebp+var_639], al
.text:00002F94                 movzx   edx, [ebp+var_639]
.text:00002F9B                 test    edx, edx
.text:00002F9D                 jz      short loc_2FAB
.text:00002F9F                 mov     [ebp+var_640], 0
.text:00002FA9                 jmp     short loc_2FB5
.text:00002FAB ; ---------------------------------------------------------------------------
.text:00002FAB
.text:00002FAB loc_2FAB:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+137Dj
.text:00002FAB                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1399j
.text:00002FAB                 mov     [ebp+var_640], 1
.text:00002FB5
.text:00002FB5 loc_2FB5:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+13A5j
.text:00002FB5                 mov     al, byte ptr [ebp+var_640]
.text:00002FBB                 mov     [ebp+var_195], al
.text:00002FC1                 mov     ecx, [ebp+var_118]
.text:00002FC7                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:00002FCC                 mov     [ebp+var_641], al
.text:00002FD2                 movzx   ecx, [ebp+var_641]
.text:00002FD9                 test    ecx, ecx
.text:00002FDB                 jz      short loc_2FE8
.text:00002FDD                 mov     ecx, [ebp+var_118]
.text:00002FE3                 call    ?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::AddNew(void)
.text:00002FE8
.text:00002FE8 loc_2FE8:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+13D7j
.text:00002FE8                 mov     edx, [ebp+this]
.text:00002FEB                 cmp     dword ptr [edx+54h], 3
.text:00002FEF                 jnz     short loc_302D
.text:00002FF1                 mov     eax, [ebp+var_118]
.text:00002FF7                 push    eax
.text:00002FF8                 call    ?GetNumPrefixParts_if_DrivePath@NWildcard@@YGIAAV?$CObjectVector@VUString@@@@@Z ; NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)
.text:00002FFD                 mov     [ebp+var_648], eax
.text:00003003                 mov     ecx, [ebp+var_118]
.text:00003009                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000300E                 mov     [ebp+var_64C], eax
.text:00003014                 mov     ecx, [ebp+var_648]
.text:0000301A                 cmp     ecx, [ebp+var_64C]
.text:00003020                 jnz     short loc_302D
.text:00003022                 mov     ecx, [ebp+var_118]
.text:00003028                 call    ?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::AddNew(void)
.text:0000302D
.text:0000302D loc_302D:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+13EBj
.text:0000302D                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+141Cj
.text:0000302D                 mov     ecx, [ebp+var_118]
.text:00003033                 call    ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::Back(void)
.text:00003038                 mov     [ebp+var_650], eax
.text:0000303E                 mov     edx, [ebp+var_650]
.text:00003044                 mov     [ebp+var_19C], edx
.text:0000304A                 movzx   eax, [ebp+var_195]
.text:00003051                 test    eax, eax
.text:00003053                 jz      short loc_3072
.text:00003055                 mov     ecx, [ebp+this]
.text:00003058                 movzx   edx, byte ptr [ecx+20h]
.text:0000305C                 neg     edx
.text:0000305E                 sbb     edx, edx
.text:00003060                 and     edx, 25h
.text:00003063                 add     edx, 3Ah ; ':'
.text:00003066                 push    edx
.text:00003067                 mov     ecx, [ebp+var_19C]
.text:0000306D                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:00003072
.text:00003072 loc_3072:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+144Fj
.text:00003072                 lea     eax, [ebp+var_190]
.text:00003078                 push    eax
.text:00003079                 mov     ecx, [ebp+var_19C]
.text:0000307F                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00003084                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003088                 lea     ecx, [ebp+var_190] ; this
.text:0000308E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003093
.text:00003093 loc_3093:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1338j
.text:00003093                 mov     ecx, [ebp+var_118]
.text:00003099                 push    ecx
.text:0000309A                 lea     edx, [ebp+var_1AC]
.text:000030A0                 push    edx
.text:000030A1                 call    ?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z ; MakePathFromParts(CObjectVector<UString> const &)
.text:000030A6                 mov     [ebp+var_654], eax
.text:000030AC                 mov     byte ptr [ebp+var_4], 10h
.text:000030B0                 movzx   eax, [ebp+var_175]
.text:000030B7                 test    eax, eax
.text:000030B9                 jnz     loc_328E
.text:000030BF                 mov     ecx, [ebp+this]
.text:000030C2                 movzx   edx, byte ptr [ecx+9Ah]
.text:000030C9                 test    edx, edx
.text:000030CB                 jnz     short loc_30F4
.text:000030CD                 mov     ecx, [ebp+var_118]
.text:000030D3                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:000030D8                 mov     [ebp+var_655], al
.text:000030DE                 movzx   eax, [ebp+var_655]
.text:000030E5                 test    eax, eax
.text:000030E7                 jnz     short loc_30F4
.text:000030E9                 mov     ecx, [ebp+var_118]
.text:000030EF                 call    ?DeleteBack@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::DeleteBack(void)
.text:000030F4
.text:000030F4 loc_30F4:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+14C7j
.text:000030F4                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+14E3j
.text:000030F4                 mov     ecx, [ebp+var_118]
.text:000030FA                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:000030FF                 mov     [ebp+var_656], al
.text:00003105                 movzx   ecx, [ebp+var_656]
.text:0000310C                 test    ecx, ecx
.text:0000310E                 jnz     loc_328E
.text:00003114                 lea     ecx, [ebp+var_1C0]
.text:0000311A                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000311F                 mov     [ebp+var_65C], eax
.text:00003125                 mov     byte ptr [ebp+var_4], 11h
.text:00003129                 lea     edx, [ebp+var_1C0]
.text:0000312F                 push    edx             ; UString *
.text:00003130                 mov     eax, [ebp+var_118]
.text:00003136                 push    eax             ; int
.text:00003137                 mov     ecx, [ebp+this]
.text:0000313A                 call    ?CreateComplexDirectory@CArchiveExtractCallback@@AAEXABV?$CObjectVector@VUString@@@@AAVUString@@@Z ; CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)
.text:0000313F                 mov     ecx, [ebp+this]
.text:00003142                 movzx   edx, byte ptr [ecx+9Ah]
.text:00003149                 test    edx, edx
.text:0000314B                 jz      loc_327F
.text:00003151                 lea     eax, [ebp+var_1C0]
.text:00003157                 push    eax
.text:00003158                 mov     ecx, [ebp+this]
.text:0000315B                 add     ecx, 144h
.text:00003161                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:00003166                 mov     ecx, [ebp+arg_4]
.text:00003169                 push    ecx
.text:0000316A                 mov     ecx, [ebp+this]
.text:0000316D                 add     ecx, 150h
.text:00003173                 call    ?Add@?$CRecordVector@I@@QAEII@Z ; CRecordVector<uint>::Add(uint)
.text:00003178                 mov     edx, [ebp+this]
.text:0000317B                 movzx   eax, byte ptr [edx+0C4h]
.text:00003182                 test    eax, eax
.text:00003184                 jz      short loc_31A4
.text:00003186                 mov     ecx, [ebp+this]
.text:00003189                 movzx   edx, byte ptr [ecx+0E6h]
.text:00003190                 test    edx, edx
.text:00003192                 jz      short loc_31A4
.text:00003194                 mov     eax, [ebp+this]
.text:00003197                 add     eax, 0D8h ; '+'
.text:0000319C                 mov     [ebp+var_660], eax
.text:000031A2                 jmp     short loc_31DF
.text:000031A4 ; ---------------------------------------------------------------------------
.text:000031A4
.text:000031A4 loc_31A4:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1580j
.text:000031A4                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+158Ej
.text:000031A4                 mov     ecx, [ebp+this]
.text:000031A7                 mov     edx, [ecx+14h]
.text:000031AA                 movzx   eax, byte ptr [edx+0A4h]
.text:000031B1                 test    eax, eax
.text:000031B3                 jz      short loc_31C9
.text:000031B5                 mov     ecx, [ebp+this]
.text:000031B8                 mov     edx, [ecx+14h]
.text:000031BB                 add     edx, 9Ch ; '£'
.text:000031C1                 mov     [ebp+var_664], edx
.text:000031C7                 jmp     short loc_31D3
.text:000031C9 ; ---------------------------------------------------------------------------
.text:000031C9
.text:000031C9 loc_31C9:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+15AFj
.text:000031C9                 mov     [ebp+var_664], 0
.text:000031D3
.text:000031D3 loc_31D3:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+15C3j
.text:000031D3                 mov     eax, [ebp+var_664]
.text:000031D9                 mov     [ebp+var_660], eax
.text:000031DF
.text:000031DF loc_31DF:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+159Ej
.text:000031DF                 mov     ecx, [ebp+this]
.text:000031E2                 movzx   edx, byte ptr [ecx+0C3h]
.text:000031E9                 test    edx, edx
.text:000031EB                 jz      short loc_320C
.text:000031ED                 mov     eax, [ebp+this]
.text:000031F0                 movzx   ecx, byte ptr [eax+0E5h]
.text:000031F7                 test    ecx, ecx
.text:000031F9                 jz      short loc_320C
.text:000031FB                 mov     edx, [ebp+this]
.text:000031FE                 add     edx, 0D0h ; '-'
.text:00003204                 mov     [ebp+var_668], edx
.text:0000320A                 jmp     short loc_3216
.text:0000320C ; ---------------------------------------------------------------------------
.text:0000320C
.text:0000320C loc_320C:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+15E7j
.text:0000320C                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+15F5j
.text:0000320C                 mov     [ebp+var_668], 0
.text:00003216
.text:00003216 loc_3216:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1606j
.text:00003216                 mov     eax, [ebp+this]
.text:00003219                 movzx   ecx, byte ptr [eax+0C2h]
.text:00003220                 test    ecx, ecx
.text:00003222                 jz      short loc_3243
.text:00003224                 mov     edx, [ebp+this]
.text:00003227                 movzx   eax, byte ptr [edx+0E4h]
.text:0000322E                 test    eax, eax
.text:00003230                 jz      short loc_3243
.text:00003232                 mov     ecx, [ebp+this]
.text:00003235                 add     ecx, 0C8h ; '+'
.text:0000323B                 mov     [ebp+var_66C], ecx
.text:00003241                 jmp     short loc_324D
.text:00003243 ; ---------------------------------------------------------------------------
.text:00003243
.text:00003243 loc_3243:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+161Ej
.text:00003243                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+162Cj
.text:00003243                 mov     [ebp+var_66C], 0
.text:0000324D
.text:0000324D loc_324D:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+163Dj
.text:0000324D                 lea     ecx, [ebp+var_1C0]
.text:00003253                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003258                 mov     [ebp+var_670], eax
.text:0000325E                 mov     edx, [ebp+var_660]
.text:00003264                 push    edx             ; struct _FILETIME *
.text:00003265                 mov     eax, [ebp+var_668]
.text:0000326B                 push    eax             ; struct _FILETIME *
.text:0000326C                 mov     ecx, [ebp+var_66C]
.text:00003272                 push    ecx             ; wchar_t *
.text:00003273                 mov     edx, [ebp+var_670]
.text:00003279                 push    edx             ; this
.text:0000327A                 call    ?SetDirTime@NDir@NFile@NWindows@@YG_NPB_WPBU_FILETIME@@11@Z ; NWindows::NFile::NDir::SetDirTime(wchar_t const *,_FILETIME const *,_FILETIME const *,_FILETIME const *)
.text:0000327F
.text:0000327F loc_327F:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1547j
.text:0000327F                 mov     byte ptr [ebp+var_4], 10h
.text:00003283                 lea     ecx, [ebp+var_1C0] ; this
.text:00003289                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000328E
.text:0000328E loc_328E:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+14B5j
.text:0000328E                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+150Aj
.text:0000328E                 lea     eax, [ebp+var_1AC]
.text:00003294                 push    eax             ; wchar_t *
.text:00003295                 lea     ecx, [ebp+var_1D4]
.text:0000329B                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000032A0                 mov     [ebp+var_674], eax
.text:000032A6                 mov     byte ptr [ebp+var_4], 12h
.text:000032AA                 mov     ecx, [ebp+this]
.text:000032AD                 cmp     dword ptr [ecx+54h], 3
.text:000032B1                 jnz     short loc_32D7
.text:000032B3                 lea     ecx, [ebp+var_1AC]
.text:000032B9                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000032BE                 mov     [ebp+var_678], eax
.text:000032C4                 mov     edx, [ebp+var_678]
.text:000032CA                 push    edx             ; wchar_t *
.text:000032CB                 call    ?IsAbsolutePath@NName@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NName::IsAbsolutePath(wchar_t const *)
.text:000032D0                 movzx   eax, al
.text:000032D3                 test    eax, eax
.text:000032D5                 jnz     short loc_3328
.text:000032D7
.text:000032D7 loc_32D7:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+16ADj
.text:000032D7                 lea     ecx, [ebp+var_1D4]
.text:000032DD                 push    ecx             ; UString *
.text:000032DE                 mov     edx, [ebp+this]
.text:000032E1                 add     edx, 3Ch ; '<'
.text:000032E4                 push    edx             ; UString *
.text:000032E5                 lea     eax, [ebp+var_460]
.text:000032EB                 push    eax             ; int
.text:000032EC                 call    ?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z ; MakePath_from_2_Parts(UString const &,UString const &)
.text:000032F1                 mov     [ebp+var_67C], eax
.text:000032F7                 mov     ecx, [ebp+var_67C]
.text:000032FD                 mov     [ebp+var_680], ecx
.text:00003303                 mov     byte ptr [ebp+var_4], 13h
.text:00003307                 mov     edx, [ebp+var_680]
.text:0000330D                 push    edx
.text:0000330E                 lea     ecx, [ebp+var_1D4]
.text:00003314                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00003319                 mov     byte ptr [ebp+var_4], 12h
.text:0000331D                 lea     ecx, [ebp+var_460] ; this
.text:00003323                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003328
.text:00003328 loc_3328:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+16D1j
.text:00003328                 mov     eax, [ebp+this]
.text:0000332B                 movzx   ecx, byte ptr [eax+98h]
.text:00003332                 test    ecx, ecx
.text:00003334                 jz      loc_3441
.text:0000333A                 mov     edx, [ebp+this]
.text:0000333D                 cmp     dword ptr [edx+9Ch], 0FFFFFFFFh
.text:00003344                 jz      loc_3441
.text:0000334A                 mov     eax, [ebp+this]
.text:0000334D                 mov     ecx, [eax+9Ch]
.text:00003353                 push    ecx             ; unsigned int
.text:00003354                 lea     ecx, [ebp+var_1EC] ; this
.text:0000335A                 call    ??0CIndexToPathPair@@QAE@I@Z ; CIndexToPathPair::CIndexToPathPair(uint)
.text:0000335F                 mov     [ebp+var_684], eax
.text:00003365                 mov     byte ptr [ebp+var_4], 14h
.text:00003369                 lea     edx, [ebp+var_1EC]
.text:0000336F                 push    edx             ; CIndexToPathPair *
.text:00003370                 mov     ecx, [ebp+this]
.text:00003373                 add     ecx, 1A8h
.text:00003379                 call    ?FindInSorted@?$CObjectVector@UCIndexToPathPair@@@@QBEHABUCIndexToPathPair@@@Z ; CObjectVector<CIndexToPathPair>::FindInSorted(CIndexToPathPair const &)
.text:0000337E                 mov     [ebp+var_688], eax
.text:00003384                 mov     eax, [ebp+var_688]
.text:0000338A                 mov     [ebp+var_1F4], eax
.text:00003390                 cmp     [ebp+var_1F4], 0
.text:00003397                 jl      loc_3432
.text:0000339D                 mov     ecx, [ebp+var_1F4]
.text:000033A3                 push    ecx
.text:000033A4                 mov     ecx, [ebp+this]
.text:000033A7                 add     ecx, 1A8h
.text:000033AD                 call    ??A?$CObjectVector@UCIndexToPathPair@@@@QAEAAUCIndexToPathPair@@I@Z ; CObjectVector<CIndexToPathPair>::operator[](uint)
.text:000033B2                 mov     [ebp+var_68C], eax
.text:000033B8                 mov     edx, [ebp+var_68C]
.text:000033BE                 mov     [ebp+var_1F8], edx
.text:000033C4                 mov     eax, [ebp+var_1F8]
.text:000033CA                 add     eax, 4
.text:000033CD                 push    eax
.text:000033CE                 lea     ecx, [ebp+var_1D4]
.text:000033D4                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000033D9                 push    3Ah ; ':'
.text:000033DB                 lea     ecx, [ebp+var_1D4]
.text:000033E1                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:000033E6                 mov     ecx, [ebp+this]
.text:000033E9                 add     ecx, 8Ch ; 'î'
.text:000033EF                 push    ecx
.text:000033F0                 lea     ecx, [ebp+var_208]
.text:000033F6                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000033FB                 mov     [ebp+var_690], eax
.text:00003401                 mov     byte ptr [ebp+var_4], 15h
.text:00003405                 lea     edx, [ebp+var_208]
.text:0000340B                 push    edx             ; struct UString *
.text:0000340C                 call    ?Correct_AltStream_Name@@YGXAAVUString@@@Z ; Correct_AltStream_Name(UString &)
.text:00003411                 lea     eax, [ebp+var_208]
.text:00003417                 push    eax
.text:00003418                 lea     ecx, [ebp+var_1D4]
.text:0000341E                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00003423                 mov     byte ptr [ebp+var_4], 14h
.text:00003427                 lea     ecx, [ebp+var_208] ; this
.text:0000342D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003432
.text:00003432 loc_3432:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1793j
.text:00003432                 mov     byte ptr [ebp+var_4], 12h
.text:00003436                 lea     ecx, [ebp+var_1EC] ; this
.text:0000343C                 call    ??1CIndexToPathPair@@QAE@XZ ; CIndexToPathPair::~CIndexToPathPair(void)
.text:00003441
.text:00003441 loc_3441:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1730j
.text:00003441                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1740j
.text:00003441                 mov     [ebp+var_20D], 0
.text:00003448                 mov     ecx, [ebp+this]
.text:0000344B                 movzx   edx, byte ptr [ecx+9Ah]
.text:00003452                 test    edx, edx
.text:00003454                 jz      loc_3506
.text:0000345A                 lea     eax, [ebp+var_1D4]
.text:00003460                 push    eax
.text:00003461                 mov     ecx, [ebp+this]
.text:00003464                 add     ecx, 0A8h ; '¿'
.text:0000346A                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:0000346F                 movzx   ecx, [ebp+var_175]
.text:00003476                 test    ecx, ecx
.text:00003478                 jz      short loc_349A
.text:0000347A                 mov     ecx, [ebp+this]
.text:0000347D                 add     ecx, 0A8h ; '¿'
.text:00003483                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003488                 mov     [ebp+var_694], eax
.text:0000348E                 mov     edx, [ebp+var_694]
.text:00003494                 push    edx             ; this
.text:00003495                 call    ?RemoveDir@NDir@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NDir::RemoveDir(wchar_t const *)
.text:0000349A
.text:0000349A loc_349A:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1874j
.text:0000349A                 lea     ecx, [ebp+var_4C] ; this
.text:0000349D                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000034A2                 mov     [ebp+var_695], al
.text:000034A8                 movzx   eax, [ebp+var_695]
.text:000034AF                 test    eax, eax
.text:000034B1                 jz      short loc_3501
.text:000034B3                 mov     [ebp+var_464], 0
.text:000034BD                 mov     byte ptr [ebp+var_4], 10h
.text:000034C1                 lea     ecx, [ebp+var_1D4] ; this
.text:000034C7                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000034CC                 mov     byte ptr [ebp+var_4], 0Ch
.text:000034D0                 lea     ecx, [ebp+var_1AC] ; this
.text:000034D6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000034DB                 mov     byte ptr [ebp+var_4], 2
.text:000034DF                 lea     ecx, [ebp+var_144]
.text:000034E5                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000034EA                 mov     byte ptr [ebp+var_4], 0
.text:000034EE                 lea     ecx, [ebp+var_4C] ; this
.text:000034F1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000034F6                 mov     eax, [ebp+var_464]
.text:000034FC                 jmp     loc_4F97
.text:00003501 ; ---------------------------------------------------------------------------
.text:00003501
.text:00003501 loc_3501:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+18ADj
.text:00003501                 jmp     loc_417E
.text:00003506 ; ---------------------------------------------------------------------------
.text:00003506
.text:00003506 loc_3506:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1850j
.text:00003506                 mov     ecx, [ebp+this]
.text:00003509                 movzx   edx, byte ptr [ecx+0C0h]
.text:00003510                 test    edx, edx
.text:00003512                 jnz     loc_417E
.text:00003518                 lea     ecx, [ebp+var_24C] ; this
.text:0000351E                 call    ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::CFileInfo(void)
.text:00003523                 mov     [ebp+var_69C], eax
.text:00003529                 mov     byte ptr [ebp+var_4], 16h
.text:0000352D                 lea     ecx, [ebp+var_1D4]
.text:00003533                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003538                 mov     [ebp+var_6A0], eax
.text:0000353E                 mov     eax, [ebp+var_6A0]
.text:00003544                 push    eax             ; wchar_t *
.text:00003545                 lea     ecx, [ebp+var_24C] ; this
.text:0000354B                 call    ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z ; NWindows::NFile::NFind::CFileInfo::Find(wchar_t const *)
.text:00003550                 mov     [ebp+var_6A1], al
.text:00003556                 movzx   ecx, [ebp+var_6A1]
.text:0000355D                 test    ecx, ecx
.text:0000355F                 jz      loc_4031
.text:00003565                 mov     edx, [ebp+this]
.text:00003568                 mov     eax, [edx+58h]
.text:0000356B                 mov     [ebp+var_6A8], eax
.text:00003571                 cmp     [ebp+var_6A8], 0
.text:00003578                 jz      short loc_35E5
.text:0000357A                 cmp     [ebp+var_6A8], 2
.text:00003581                 jz      short loc_3588
.text:00003583                 jmp     loc_39C9
.text:00003588 ; ---------------------------------------------------------------------------
.text:00003588
.text:00003588 loc_3588:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+197Dj
.text:00003588                 mov     [ebp+var_468], 0
.text:00003592                 mov     byte ptr [ebp+var_4], 12h
.text:00003596                 lea     ecx, [ebp+var_24C] ; this
.text:0000359C                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:000035A1                 mov     byte ptr [ebp+var_4], 10h
.text:000035A5                 lea     ecx, [ebp+var_1D4] ; this
.text:000035AB                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000035B0                 mov     byte ptr [ebp+var_4], 0Ch
.text:000035B4                 lea     ecx, [ebp+var_1AC] ; this
.text:000035BA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000035BF                 mov     byte ptr [ebp+var_4], 2
.text:000035C3                 lea     ecx, [ebp+var_144]
.text:000035C9                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000035CE                 mov     byte ptr [ebp+var_4], 0
.text:000035D2                 lea     ecx, [ebp+var_4C] ; this
.text:000035D5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000035DA                 mov     eax, [ebp+var_468]
.text:000035E0                 jmp     loc_4F97
.text:000035E5 ; ---------------------------------------------------------------------------
.text:000035E5
.text:000035E5 loc_35E5:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1974j
.text:000035E5                 lea     ecx, [ebp+var_1D4] ; this
.text:000035EB                 call    ?ReverseFind_PathSepar@UString@@QBEHXZ ; UString::ReverseFind_PathSepar(void)
.text:000035F0                 mov     [ebp+var_254], eax
.text:000035F6                 mov     ecx, [ebp+var_254]
.text:000035FC                 add     ecx, 1
.text:000035FF                 push    ecx
.text:00003600                 lea     edx, [ebp+var_474]
.text:00003606                 push    edx
.text:00003607                 lea     ecx, [ebp+var_1D4]
.text:0000360D                 call    ?Left@UString@@QBE?AV1@I@Z ; UString::Left(uint)
.text:00003612                 mov     [ebp+var_6AC], eax
.text:00003618                 mov     eax, [ebp+var_6AC]
.text:0000361E                 mov     [ebp+var_6B0], eax
.text:00003624                 mov     byte ptr [ebp+var_4], 17h
.text:00003628                 lea     ecx, [ebp+var_224]
.text:0000362E                 push    ecx
.text:0000362F                 mov     edx, [ebp+var_6B0]
.text:00003635                 push    edx
.text:00003636                 lea     eax, [ebp+var_264]
.text:0000363C                 push    eax
.text:0000363D                 call    ??H@YG?AVUString@@ABV0@0@Z ; operator+(UString const &,UString const &)
.text:00003642                 mov     [ebp+var_6B4], eax
.text:00003648                 mov     byte ptr [ebp+var_4], 19h
.text:0000364C                 lea     ecx, [ebp+var_474] ; this
.text:00003652                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003657                 mov     ecx, [ebp+this]
.text:0000365A                 movzx   edx, byte ptr [ecx+0F8h]
.text:00003661                 test    edx, edx
.text:00003663                 jz      short loc_3675
.text:00003665                 mov     eax, [ebp+this]
.text:00003668                 add     eax, 0F0h ; '='
.text:0000366D                 mov     [ebp+var_6B8], eax
.text:00003673                 jmp     short loc_367F
.text:00003675 ; ---------------------------------------------------------------------------
.text:00003675
.text:00003675 loc_3675:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1A5Fj
.text:00003675                 mov     [ebp+var_6B8], 0
.text:0000367F
.text:0000367F loc_367F:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1A6Fj
.text:0000367F                 mov     ecx, [ebp+this]
.text:00003682                 movzx   edx, byte ptr [ecx+0E6h]
.text:00003689                 test    edx, edx
.text:0000368B                 jz      short loc_369D
.text:0000368D                 mov     eax, [ebp+this]
.text:00003690                 add     eax, 0D8h ; '+'
.text:00003695                 mov     [ebp+var_6BC], eax
.text:0000369B                 jmp     short loc_36A7
.text:0000369D ; ---------------------------------------------------------------------------
.text:0000369D
.text:0000369D loc_369D:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1A87j
.text:0000369D                 mov     [ebp+var_6BC], 0
.text:000036A7
.text:000036A7 loc_36A7:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1A97j
.text:000036A7                 mov     ecx, [ebp+this]
.text:000036AA                 add     ecx, 28h ; '('
.text:000036AD                 call    ??C?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::operator->(void)
.text:000036B2                 mov     [ebp+var_6C0], eax
.text:000036B8                 mov     ecx, [ebp+var_6C0]
.text:000036BE                 mov     [ebp+var_6C4], ecx
.text:000036C4                 mov     ecx, [ebp+this]
.text:000036C7                 add     ecx, 68h ; 'h'
.text:000036CA                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000036CF                 mov     [ebp+var_6C8], eax
.text:000036D5                 lea     ecx, [ebp+var_264]
.text:000036DB                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000036E0                 mov     [ebp+var_6CC], eax
.text:000036E6                 mov     esi, esp
.text:000036E8                 lea     edx, [ebp+var_270]
.text:000036EE                 push    edx             ; wchar_t *
.text:000036EF                 mov     eax, [ebp+var_6B8]
.text:000036F5                 push    eax
.text:000036F6                 mov     ecx, [ebp+var_6BC]
.text:000036FC                 push    ecx
.text:000036FD                 mov     edx, [ebp+var_6C8]
.text:00003703                 push    edx
.text:00003704                 lea     eax, [ebp+var_24C]
.text:0000370A                 push    eax
.text:0000370B                 lea     ecx, [ebp+var_234]
.text:00003711                 push    ecx
.text:00003712                 mov     edx, [ebp+var_6CC]
.text:00003718                 push    edx
.text:00003719                 mov     eax, [ebp+var_6C4]
.text:0000371F                 push    eax
.text:00003720                 mov     ecx, [ebp+var_6C4]
.text:00003726                 mov     edx, [ecx]
.text:00003728                 mov     eax, [edx+14h]
.text:0000372B                 call    eax
.text:0000372D                 cmp     esi, esp
.text:0000372F                 call    __RTC_CheckEsp
.text:00003734                 mov     [ebp+var_6D0], eax
.text:0000373A                 mov     ecx, [ebp+var_6D0]
.text:00003740                 mov     [ebp+var_278], ecx
.text:00003746                 cmp     [ebp+var_278], 0
.text:0000374D                 jz      short loc_37BD
.text:0000374F                 mov     edx, [ebp+var_278]
.text:00003755                 mov     [ebp+var_478], edx
.text:0000375B                 mov     byte ptr [ebp+var_4], 16h
.text:0000375F                 lea     ecx, [ebp+var_264] ; this
.text:00003765                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000376A                 mov     byte ptr [ebp+var_4], 12h
.text:0000376E                 lea     ecx, [ebp+var_24C] ; this
.text:00003774                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003779                 mov     byte ptr [ebp+var_4], 10h
.text:0000377D                 lea     ecx, [ebp+var_1D4] ; this
.text:00003783                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003788                 mov     byte ptr [ebp+var_4], 0Ch
.text:0000378C                 lea     ecx, [ebp+var_1AC] ; this
.text:00003792                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003797                 mov     byte ptr [ebp+var_4], 2
.text:0000379B                 lea     ecx, [ebp+var_144]
.text:000037A1                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000037A6                 mov     byte ptr [ebp+var_4], 0
.text:000037AA                 lea     ecx, [ebp+var_4C] ; this
.text:000037AD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000037B2                 mov     eax, [ebp+var_478]
.text:000037B8                 jmp     loc_4F97
.text:000037BD ; ---------------------------------------------------------------------------
.text:000037BD
.text:000037BD loc_37BD:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1B49j
.text:000037BD                 mov     eax, dword ptr [ebp+var_270]
.text:000037C3                 mov     [ebp+var_6D4], eax
.text:000037C9                 cmp     [ebp+var_6D4], 5 ; switch 6 cases
.text:000037D0                 ja      loc_394E        ; jumptable 000037DC default case
.text:000037D6                 mov     ecx, [ebp+var_6D4]
.text:000037DC                 jmp     ds:$LN289[ecx*4] ; switch jump
.text:000037E3 ; ---------------------------------------------------------------------------
.text:000037E3
.text:000037E3 $LN72:                                  ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1BD8j
.text:000037E3                                         ; DATA XREF: .text:$LN289o
.text:000037E3                 mov     [ebp+var_47C], 80004004h ; jumptable 000037DC case 5
.text:000037ED                 mov     byte ptr [ebp+var_4], 16h
.text:000037F1                 lea     ecx, [ebp+var_264] ; this
.text:000037F7                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000037FC                 mov     byte ptr [ebp+var_4], 12h
.text:00003800                 lea     ecx, [ebp+var_24C] ; this
.text:00003806                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:0000380B                 mov     byte ptr [ebp+var_4], 10h
.text:0000380F                 lea     ecx, [ebp+var_1D4] ; this
.text:00003815                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000381A                 mov     byte ptr [ebp+var_4], 0Ch
.text:0000381E                 lea     ecx, [ebp+var_1AC] ; this
.text:00003824                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003829                 mov     byte ptr [ebp+var_4], 2
.text:0000382D                 lea     ecx, [ebp+var_144]
.text:00003833                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00003838                 mov     byte ptr [ebp+var_4], 0
.text:0000383C                 lea     ecx, [ebp+var_4C] ; this
.text:0000383F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003844                 mov     eax, [ebp+var_47C]
.text:0000384A                 jmp     loc_4F97
.text:0000384F ; ---------------------------------------------------------------------------
.text:0000384F
.text:0000384F $LN71:                                  ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1BD8j
.text:0000384F                                         ; DATA XREF: .text:$LN289o
.text:0000384F                 mov     [ebp+var_480], 0 ; jumptable 000037DC case 2
.text:00003859                 mov     byte ptr [ebp+var_4], 16h
.text:0000385D                 lea     ecx, [ebp+var_264] ; this
.text:00003863                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003868                 mov     byte ptr [ebp+var_4], 12h
.text:0000386C                 lea     ecx, [ebp+var_24C] ; this
.text:00003872                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003877                 mov     byte ptr [ebp+var_4], 10h
.text:0000387B                 lea     ecx, [ebp+var_1D4] ; this
.text:00003881                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003886                 mov     byte ptr [ebp+var_4], 0Ch
.text:0000388A                 lea     ecx, [ebp+var_1AC] ; this
.text:00003890                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003895                 mov     byte ptr [ebp+var_4], 2
.text:00003899                 lea     ecx, [ebp+var_144]
.text:0000389F                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000038A4                 mov     byte ptr [ebp+var_4], 0
.text:000038A8                 lea     ecx, [ebp+var_4C] ; this
.text:000038AB                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000038B0                 mov     eax, [ebp+var_480]
.text:000038B6                 jmp     loc_4F97
.text:000038BB ; ---------------------------------------------------------------------------
.text:000038BB
.text:000038BB $LN70:                                  ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1BD8j
.text:000038BB                                         ; DATA XREF: .text:$LN289o
.text:000038BB                 mov     edx, [ebp+this] ; jumptable 000037DC case 3
.text:000038BE                 mov     dword ptr [edx+58h], 2
.text:000038C5                 mov     [ebp+var_484], 0
.text:000038CF                 mov     byte ptr [ebp+var_4], 16h
.text:000038D3                 lea     ecx, [ebp+var_264] ; this
.text:000038D9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000038DE                 mov     byte ptr [ebp+var_4], 12h
.text:000038E2                 lea     ecx, [ebp+var_24C] ; this
.text:000038E8                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:000038ED                 mov     byte ptr [ebp+var_4], 10h
.text:000038F1                 lea     ecx, [ebp+var_1D4] ; this
.text:000038F7                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000038FC                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003900                 lea     ecx, [ebp+var_1AC] ; this
.text:00003906                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000390B                 mov     byte ptr [ebp+var_4], 2
.text:0000390F                 lea     ecx, [ebp+var_144]
.text:00003915                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000391A                 mov     byte ptr [ebp+var_4], 0
.text:0000391E                 lea     ecx, [ebp+var_4C] ; this
.text:00003921                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003926                 mov     eax, [ebp+var_484]
.text:0000392C                 jmp     loc_4F97
.text:00003931 ; ---------------------------------------------------------------------------
.text:00003931
.text:00003931 $LN69:                                  ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1BD8j
.text:00003931                                         ; DATA XREF: .text:$LN289o
.text:00003931                 jmp     loc_39BA        ; jumptable 000037DC case 0
.text:00003936 ; ---------------------------------------------------------------------------
.text:00003936
.text:00003936 $LN68:                                  ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1BD8j
.text:00003936                                         ; DATA XREF: .text:$LN289o
.text:00003936                 mov     eax, [ebp+this] ; jumptable 000037DC case 1
.text:00003939                 mov     dword ptr [eax+58h], 1
.text:00003940                 jmp     short loc_39BA
.text:00003942 ; ---------------------------------------------------------------------------
.text:00003942
.text:00003942 $LN67:                                  ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1BD8j
.text:00003942                                         ; DATA XREF: .text:$LN289o
.text:00003942                 mov     ecx, [ebp+this] ; jumptable 000037DC case 4
.text:00003945                 mov     dword ptr [ecx+58h], 3
.text:0000394C                 jmp     short loc_39BA
.text:0000394E ; ---------------------------------------------------------------------------
.text:0000394E
.text:0000394E loc_394E:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1BCCj
.text:0000394E                 mov     [ebp+var_488], 80004005h ; jumptable 000037DC default case
.text:00003958                 mov     byte ptr [ebp+var_4], 16h
.text:0000395C                 lea     ecx, [ebp+var_264] ; this
.text:00003962                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003967                 mov     byte ptr [ebp+var_4], 12h
.text:0000396B                 lea     ecx, [ebp+var_24C] ; this
.text:00003971                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003976                 mov     byte ptr [ebp+var_4], 10h
.text:0000397A                 lea     ecx, [ebp+var_1D4] ; this
.text:00003980                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003985                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003989                 lea     ecx, [ebp+var_1AC] ; this
.text:0000398F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003994                 mov     byte ptr [ebp+var_4], 2
.text:00003998                 lea     ecx, [ebp+var_144]
.text:0000399E                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000039A3                 mov     byte ptr [ebp+var_4], 0
.text:000039A7                 lea     ecx, [ebp+var_4C] ; this
.text:000039AA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000039AF                 mov     eax, [ebp+var_488]
.text:000039B5                 jmp     loc_4F97
.text:000039BA ; ---------------------------------------------------------------------------
.text:000039BA
.text:000039BA loc_39BA:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):$LN69j
.text:000039BA                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1D3Cj ...
.text:000039BA                 mov     byte ptr [ebp+var_4], 16h
.text:000039BE                 lea     ecx, [ebp+var_264] ; this
.text:000039C4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000039C9
.text:000039C9 loc_39C9:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+197Fj
.text:000039C9                 mov     edx, [ebp+this]
.text:000039CC                 cmp     dword ptr [edx+58h], 3
.text:000039D0                 jnz     loc_3AEF
.text:000039D6                 lea     eax, [ebp+var_1D4]
.text:000039DC                 push    eax             ; struct UString *
.text:000039DD                 call    ?AutoRenamePath@@YG_NAAVUString@@@Z ; AutoRenamePath(UString &)
.text:000039E2                 mov     [ebp+var_6D5], al
.text:000039E8                 movzx   ecx, [ebp+var_6D5]
.text:000039EF                 test    ecx, ecx
.text:000039F1                 jnz     loc_3AE3
.text:000039F7                 lea     edx, [ebp+var_1D4]
.text:000039FD                 push    edx             ; struct UString *
.text:000039FE                 mov     eax, ds:_kCantAutoRename
.text:00003A03                 push    eax             ; char *
.text:00003A04                 mov     ecx, [ebp+this] ; this
.text:00003A07                 call    ?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z ; CArchiveExtractCallback::SendMessageError(char const *,UString const &)
.text:00003A0C                 mov     [ebp+var_6DC], eax
.text:00003A12                 mov     ecx, [ebp+var_6DC]
.text:00003A18                 mov     [ebp+var_27C], ecx
.text:00003A1E                 cmp     [ebp+var_27C], 0
.text:00003A25                 jz      short loc_3A86
.text:00003A27                 mov     edx, [ebp+var_27C]
.text:00003A2D                 mov     [ebp+var_48C], edx
.text:00003A33                 mov     byte ptr [ebp+var_4], 12h
.text:00003A37                 lea     ecx, [ebp+var_24C] ; this
.text:00003A3D                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003A42                 mov     byte ptr [ebp+var_4], 10h
.text:00003A46                 lea     ecx, [ebp+var_1D4] ; this
.text:00003A4C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003A51                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003A55                 lea     ecx, [ebp+var_1AC] ; this
.text:00003A5B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003A60                 mov     byte ptr [ebp+var_4], 2
.text:00003A64                 lea     ecx, [ebp+var_144]
.text:00003A6A                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00003A6F                 mov     byte ptr [ebp+var_4], 0
.text:00003A73                 lea     ecx, [ebp+var_4C] ; this
.text:00003A76                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003A7B                 mov     eax, [ebp+var_48C]
.text:00003A81                 jmp     loc_4F97
.text:00003A86 ; ---------------------------------------------------------------------------
.text:00003A86
.text:00003A86 loc_3A86:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1E21j
.text:00003A86                 mov     [ebp+var_490], 80004005h
.text:00003A90                 mov     byte ptr [ebp+var_4], 12h
.text:00003A94                 lea     ecx, [ebp+var_24C] ; this
.text:00003A9A                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003A9F                 mov     byte ptr [ebp+var_4], 10h
.text:00003AA3                 lea     ecx, [ebp+var_1D4] ; this
.text:00003AA9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003AAE                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003AB2                 lea     ecx, [ebp+var_1AC] ; this
.text:00003AB8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003ABD                 mov     byte ptr [ebp+var_4], 2
.text:00003AC1                 lea     ecx, [ebp+var_144]
.text:00003AC7                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00003ACC                 mov     byte ptr [ebp+var_4], 0
.text:00003AD0                 lea     ecx, [ebp+var_4C] ; this
.text:00003AD3                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003AD8                 mov     eax, [ebp+var_490]
.text:00003ADE                 jmp     loc_4F97
.text:00003AE3 ; ---------------------------------------------------------------------------
.text:00003AE3
.text:00003AE3 loc_3AE3:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1DEDj
.text:00003AE3                 mov     [ebp+var_20D], 1
.text:00003AEA                 jmp     loc_402C
.text:00003AEF ; ---------------------------------------------------------------------------
.text:00003AEF
.text:00003AEF loc_3AEF:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1DCCj
.text:00003AEF                 mov     eax, [ebp+this]
.text:00003AF2                 cmp     dword ptr [eax+58h], 4
.text:00003AF6                 jnz     loc_3DB4
.text:00003AFC                 lea     ecx, [ebp+var_1D4]
.text:00003B02                 push    ecx
.text:00003B03                 lea     ecx, [ebp+var_28C]
.text:00003B09                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00003B0E                 mov     [ebp+var_6E0], eax
.text:00003B14                 mov     byte ptr [ebp+var_4], 1Ah
.text:00003B18                 lea     edx, [ebp+var_28C]
.text:00003B1E                 push    edx             ; struct UString *
.text:00003B1F                 call    ?AutoRenamePath@@YG_NAAVUString@@@Z ; AutoRenamePath(UString &)
.text:00003B24                 mov     [ebp+var_6E1], al
.text:00003B2A                 movzx   eax, [ebp+var_6E1]
.text:00003B31                 test    eax, eax
.text:00003B33                 jnz     loc_3C44
.text:00003B39                 lea     ecx, [ebp+var_1D4]
.text:00003B3F                 push    ecx             ; struct UString *
.text:00003B40                 mov     edx, ds:_kCantAutoRename
.text:00003B46                 push    edx             ; char *
.text:00003B47                 mov     ecx, [ebp+this] ; this
.text:00003B4A                 call    ?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z ; CArchiveExtractCallback::SendMessageError(char const *,UString const &)
.text:00003B4F                 mov     [ebp+var_6E8], eax
.text:00003B55                 mov     eax, [ebp+var_6E8]
.text:00003B5B                 mov     [ebp+var_294], eax
.text:00003B61                 cmp     [ebp+var_294], 0
.text:00003B68                 jz      short loc_3BD8
.text:00003B6A                 mov     ecx, [ebp+var_294]
.text:00003B70                 mov     [ebp+var_494], ecx
.text:00003B76                 mov     byte ptr [ebp+var_4], 16h
.text:00003B7A                 lea     ecx, [ebp+var_28C] ; this
.text:00003B80                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003B85                 mov     byte ptr [ebp+var_4], 12h
.text:00003B89                 lea     ecx, [ebp+var_24C] ; this
.text:00003B8F                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003B94                 mov     byte ptr [ebp+var_4], 10h
.text:00003B98                 lea     ecx, [ebp+var_1D4] ; this
.text:00003B9E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003BA3                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003BA7                 lea     ecx, [ebp+var_1AC] ; this
.text:00003BAD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003BB2                 mov     byte ptr [ebp+var_4], 2
.text:00003BB6                 lea     ecx, [ebp+var_144]
.text:00003BBC                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00003BC1                 mov     byte ptr [ebp+var_4], 0
.text:00003BC5                 lea     ecx, [ebp+var_4C] ; this
.text:00003BC8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003BCD                 mov     eax, [ebp+var_494]
.text:00003BD3                 jmp     loc_4F97
.text:00003BD8 ; ---------------------------------------------------------------------------
.text:00003BD8
.text:00003BD8 loc_3BD8:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1F64j
.text:00003BD8                 mov     [ebp+var_498], 80004005h
.text:00003BE2                 mov     byte ptr [ebp+var_4], 16h
.text:00003BE6                 lea     ecx, [ebp+var_28C] ; this
.text:00003BEC                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003BF1                 mov     byte ptr [ebp+var_4], 12h
.text:00003BF5                 lea     ecx, [ebp+var_24C] ; this
.text:00003BFB                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003C00                 mov     byte ptr [ebp+var_4], 10h
.text:00003C04                 lea     ecx, [ebp+var_1D4] ; this
.text:00003C0A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003C0F                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003C13                 lea     ecx, [ebp+var_1AC] ; this
.text:00003C19                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003C1E                 mov     byte ptr [ebp+var_4], 2
.text:00003C22                 lea     ecx, [ebp+var_144]
.text:00003C28                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00003C2D                 mov     byte ptr [ebp+var_4], 0
.text:00003C31                 lea     ecx, [ebp+var_4C] ; this
.text:00003C34                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003C39                 mov     eax, [ebp+var_498]
.text:00003C3F                 jmp     loc_4F97
.text:00003C44 ; ---------------------------------------------------------------------------
.text:00003C44
.text:00003C44 loc_3C44:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1F2Fj
.text:00003C44                 lea     ecx, [ebp+var_28C]
.text:00003C4A                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003C4F                 mov     [ebp+var_6EC], eax
.text:00003C55                 lea     ecx, [ebp+var_1D4]
.text:00003C5B                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003C60                 mov     [ebp+var_6F0], eax
.text:00003C66                 mov     edx, [ebp+var_6EC]
.text:00003C6C                 push    edx             ; wchar_t *
.text:00003C6D                 mov     eax, [ebp+var_6F0]
.text:00003C73                 push    eax             ; this
.text:00003C74                 call    ?MyMoveFile@NDir@NFile@NWindows@@YG_NPB_W0@Z ; NWindows::NFile::NDir::MyMoveFile(wchar_t const *,wchar_t const *)
.text:00003C79                 mov     [ebp+var_6F1], al
.text:00003C7F                 movzx   ecx, [ebp+var_6F1]
.text:00003C86                 test    ecx, ecx
.text:00003C88                 jnz     loc_3DA0
.text:00003C8E                 lea     edx, [ebp+var_1D4]
.text:00003C94                 push    edx             ; struct UString *
.text:00003C95                 lea     eax, [ebp+var_28C]
.text:00003C9B                 push    eax             ; struct UString *
.text:00003C9C                 mov     ecx, ds:_kCantRenameFile
.text:00003CA2                 push    ecx             ; char *
.text:00003CA3                 mov     ecx, [ebp+this] ; this
.text:00003CA6                 call    ?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z ; CArchiveExtractCallback::SendMessageError2(char const *,UString const &,UString const &)
.text:00003CAB                 mov     [ebp+var_6F8], eax
.text:00003CB1                 mov     edx, [ebp+var_6F8]
.text:00003CB7                 mov     [ebp+var_298], edx
.text:00003CBD                 cmp     [ebp+var_298], 0
.text:00003CC4                 jz      short loc_3D34
.text:00003CC6                 mov     eax, [ebp+var_298]
.text:00003CCC                 mov     [ebp+var_49C], eax
.text:00003CD2                 mov     byte ptr [ebp+var_4], 16h
.text:00003CD6                 lea     ecx, [ebp+var_28C] ; this
.text:00003CDC                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003CE1                 mov     byte ptr [ebp+var_4], 12h
.text:00003CE5                 lea     ecx, [ebp+var_24C] ; this
.text:00003CEB                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003CF0                 mov     byte ptr [ebp+var_4], 10h
.text:00003CF4                 lea     ecx, [ebp+var_1D4] ; this
.text:00003CFA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003CFF                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003D03                 lea     ecx, [ebp+var_1AC] ; this
.text:00003D09                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003D0E                 mov     byte ptr [ebp+var_4], 2
.text:00003D12                 lea     ecx, [ebp+var_144]
.text:00003D18                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00003D1D                 mov     byte ptr [ebp+var_4], 0
.text:00003D21                 lea     ecx, [ebp+var_4C] ; this
.text:00003D24                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003D29                 mov     eax, [ebp+var_49C]
.text:00003D2F                 jmp     loc_4F97
.text:00003D34 ; ---------------------------------------------------------------------------
.text:00003D34
.text:00003D34 loc_3D34:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+20C0j
.text:00003D34                 mov     [ebp+var_4A0], 80004005h
.text:00003D3E                 mov     byte ptr [ebp+var_4], 16h
.text:00003D42                 lea     ecx, [ebp+var_28C] ; this
.text:00003D48                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003D4D                 mov     byte ptr [ebp+var_4], 12h
.text:00003D51                 lea     ecx, [ebp+var_24C] ; this
.text:00003D57                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003D5C                 mov     byte ptr [ebp+var_4], 10h
.text:00003D60                 lea     ecx, [ebp+var_1D4] ; this
.text:00003D66                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003D6B                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003D6F                 lea     ecx, [ebp+var_1AC] ; this
.text:00003D75                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003D7A                 mov     byte ptr [ebp+var_4], 2
.text:00003D7E                 lea     ecx, [ebp+var_144]
.text:00003D84                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00003D89                 mov     byte ptr [ebp+var_4], 0
.text:00003D8D                 lea     ecx, [ebp+var_4C] ; this
.text:00003D90                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003D95                 mov     eax, [ebp+var_4A0]
.text:00003D9B                 jmp     loc_4F97
.text:00003DA0 ; ---------------------------------------------------------------------------
.text:00003DA0
.text:00003DA0 loc_3DA0:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2084j
.text:00003DA0                 mov     byte ptr [ebp+var_4], 16h
.text:00003DA4                 lea     ecx, [ebp+var_28C] ; this
.text:00003DAA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003DAF                 jmp     loc_402C
.text:00003DB4 ; ---------------------------------------------------------------------------
.text:00003DB4
.text:00003DB4 loc_3DB4:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1EF2j
.text:00003DB4                 lea     ecx, [ebp+var_24C] ; this
.text:00003DBA                 call    ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ ; NWindows::NFile::NFind::CFileInfoBase::IsDir(void)
.text:00003DBF                 mov     [ebp+var_6F9], al
.text:00003DC5                 movzx   ecx, [ebp+var_6F9]
.text:00003DCC                 test    ecx, ecx
.text:00003DCE                 jz      loc_3EF8
.text:00003DD4                 lea     ecx, [ebp+var_1D4]
.text:00003DDA                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003DDF                 mov     [ebp+var_700], eax
.text:00003DE5                 mov     edx, [ebp+var_700]
.text:00003DEB                 push    edx             ; this
.text:00003DEC                 call    ?RemoveDir@NDir@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NDir::RemoveDir(wchar_t const *)
.text:00003DF1                 mov     [ebp+var_701], al
.text:00003DF7                 movzx   eax, [ebp+var_701]
.text:00003DFE                 test    eax, eax
.text:00003E00                 jnz     loc_3EF3
.text:00003E06                 lea     ecx, [ebp+var_1D4]
.text:00003E0C                 push    ecx             ; struct UString *
.text:00003E0D                 mov     edx, ds:_kCantDeleteOutputDir
.text:00003E13                 push    edx             ; char *
.text:00003E14                 mov     ecx, [ebp+this] ; this
.text:00003E17                 call    ?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z ; CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)
.text:00003E1C                 mov     [ebp+var_708], eax
.text:00003E22                 mov     eax, [ebp+var_708]
.text:00003E28                 mov     [ebp+var_29C], eax
.text:00003E2E                 cmp     [ebp+var_29C], 0
.text:00003E35                 jz      short loc_3E96
.text:00003E37                 mov     ecx, [ebp+var_29C]
.text:00003E3D                 mov     [ebp+var_4A4], ecx
.text:00003E43                 mov     byte ptr [ebp+var_4], 12h
.text:00003E47                 lea     ecx, [ebp+var_24C] ; this
.text:00003E4D                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003E52                 mov     byte ptr [ebp+var_4], 10h
.text:00003E56                 lea     ecx, [ebp+var_1D4] ; this
.text:00003E5C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003E61                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003E65                 lea     ecx, [ebp+var_1AC] ; this
.text:00003E6B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003E70                 mov     byte ptr [ebp+var_4], 2
.text:00003E74                 lea     ecx, [ebp+var_144]
.text:00003E7A                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00003E7F                 mov     byte ptr [ebp+var_4], 0
.text:00003E83                 lea     ecx, [ebp+var_4C] ; this
.text:00003E86                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003E8B                 mov     eax, [ebp+var_4A4]
.text:00003E91                 jmp     loc_4F97
.text:00003E96 ; ---------------------------------------------------------------------------
.text:00003E96
.text:00003E96 loc_3E96:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2231j
.text:00003E96                 mov     [ebp+var_4A8], 0
.text:00003EA0                 mov     byte ptr [ebp+var_4], 12h
.text:00003EA4                 lea     ecx, [ebp+var_24C] ; this
.text:00003EAA                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003EAF                 mov     byte ptr [ebp+var_4], 10h
.text:00003EB3                 lea     ecx, [ebp+var_1D4] ; this
.text:00003EB9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003EBE                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003EC2                 lea     ecx, [ebp+var_1AC] ; this
.text:00003EC8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003ECD                 mov     byte ptr [ebp+var_4], 2
.text:00003ED1                 lea     ecx, [ebp+var_144]
.text:00003ED7                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00003EDC                 mov     byte ptr [ebp+var_4], 0
.text:00003EE0                 lea     ecx, [ebp+var_4C] ; this
.text:00003EE3                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003EE8                 mov     eax, [ebp+var_4A8]
.text:00003EEE                 jmp     loc_4F97
.text:00003EF3 ; ---------------------------------------------------------------------------
.text:00003EF3
.text:00003EF3 loc_3EF3:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+21FCj
.text:00003EF3                 jmp     loc_402C
.text:00003EF8 ; ---------------------------------------------------------------------------
.text:00003EF8
.text:00003EF8 loc_3EF8:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+21CAj
.text:00003EF8                 mov     [ebp+var_29D], 1
.text:00003EFF                 movzx   edx, [ebp+var_29D]
.text:00003F06                 test    edx, edx
.text:00003F08                 jz      loc_402C
.text:00003F0E                 lea     ecx, [ebp+var_1D4]
.text:00003F14                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003F19                 mov     [ebp+var_70C], eax
.text:00003F1F                 mov     eax, [ebp+var_70C]
.text:00003F25                 push    eax             ; this
.text:00003F26                 call    ?DeleteFileAlways@NDir@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NDir::DeleteFileAlways(wchar_t const *)
.text:00003F2B                 mov     [ebp+var_70D], al
.text:00003F31                 movzx   ecx, [ebp+var_70D]
.text:00003F38                 test    ecx, ecx
.text:00003F3A                 jnz     loc_402C
.text:00003F40                 lea     edx, [ebp+var_1D4]
.text:00003F46                 push    edx             ; struct UString *
.text:00003F47                 mov     eax, ds:_kCantDeleteOutputFile
.text:00003F4C                 push    eax             ; char *
.text:00003F4D                 mov     ecx, [ebp+this] ; this
.text:00003F50                 call    ?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z ; CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)
.text:00003F55                 mov     [ebp+var_714], eax
.text:00003F5B                 mov     ecx, [ebp+var_714]
.text:00003F61                 mov     [ebp+var_2A4], ecx
.text:00003F67                 cmp     [ebp+var_2A4], 0
.text:00003F6E                 jz      short loc_3FCF
.text:00003F70                 mov     edx, [ebp+var_2A4]
.text:00003F76                 mov     [ebp+var_4AC], edx
.text:00003F7C                 mov     byte ptr [ebp+var_4], 12h
.text:00003F80                 lea     ecx, [ebp+var_24C] ; this
.text:00003F86                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003F8B                 mov     byte ptr [ebp+var_4], 10h
.text:00003F8F                 lea     ecx, [ebp+var_1D4] ; this
.text:00003F95                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003F9A                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003F9E                 lea     ecx, [ebp+var_1AC] ; this
.text:00003FA4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003FA9                 mov     byte ptr [ebp+var_4], 2
.text:00003FAD                 lea     ecx, [ebp+var_144]
.text:00003FB3                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00003FB8                 mov     byte ptr [ebp+var_4], 0
.text:00003FBC                 lea     ecx, [ebp+var_4C] ; this
.text:00003FBF                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003FC4                 mov     eax, [ebp+var_4AC]
.text:00003FCA                 jmp     loc_4F97
.text:00003FCF ; ---------------------------------------------------------------------------
.text:00003FCF
.text:00003FCF loc_3FCF:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+236Aj
.text:00003FCF                 mov     [ebp+var_4B0], 0
.text:00003FD9                 mov     byte ptr [ebp+var_4], 12h
.text:00003FDD                 lea     ecx, [ebp+var_24C] ; this
.text:00003FE3                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00003FE8                 mov     byte ptr [ebp+var_4], 10h
.text:00003FEC                 lea     ecx, [ebp+var_1D4] ; this
.text:00003FF2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003FF7                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003FFB                 lea     ecx, [ebp+var_1AC] ; this
.text:00004001                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004006                 mov     byte ptr [ebp+var_4], 2
.text:0000400A                 lea     ecx, [ebp+var_144]
.text:00004010                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004015                 mov     byte ptr [ebp+var_4], 0
.text:00004019                 lea     ecx, [ebp+var_4C] ; this
.text:0000401C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004021                 mov     eax, [ebp+var_4B0]
.text:00004027                 jmp     loc_4F97
.text:0000402C ; ---------------------------------------------------------------------------
.text:0000402C
.text:0000402C loc_402C:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1EE6j
.text:0000402C                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+21ABj ...
.text:0000402C                 jmp     loc_416F
.text:00004031 ; ---------------------------------------------------------------------------
.text:00004031
.text:00004031 loc_4031:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+195Bj
.text:00004031                 lea     ecx, [ebp+var_1D4]
.text:00004037                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000403C                 mov     [ebp+var_718], eax
.text:00004042                 mov     eax, [ebp+var_718]
.text:00004048                 push    eax             ; unsigned __int32
.text:00004049                 call    ?FindAltStreamColon@NName@NFile@NWindows@@YGHPB_W@Z ; NWindows::NFile::NName::FindAltStreamColon(wchar_t const *)
.text:0000404E                 mov     [ebp+var_71C], eax
.text:00004054                 mov     ecx, [ebp+var_71C]
.text:0000405A                 mov     [ebp+var_2A8], ecx
.text:00004060                 cmp     [ebp+var_2A8], 0
.text:00004067                 jl      loc_416F
.text:0000406D                 lea     ecx, [ebp+var_1D4]
.text:00004073                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00004078                 mov     [ebp+var_720], eax
.text:0000407E                 mov     edx, [ebp+var_2A8]
.text:00004084                 mov     eax, [ebp+var_720]
.text:0000408A                 movzx   ecx, word ptr [eax+edx*2+2]
.text:0000408F                 test    ecx, ecx
.text:00004091                 jz      loc_416F
.text:00004097                 lea     edx, [ebp+var_1D4]
.text:0000409D                 push    edx
.text:0000409E                 lea     ecx, [ebp+var_2B8]
.text:000040A4                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000040A9                 mov     [ebp+var_724], eax
.text:000040AF                 mov     byte ptr [ebp+var_4], 1Bh
.text:000040B3                 mov     eax, [ebp+var_2A8]
.text:000040B9                 push    eax             ; unsigned int
.text:000040BA                 lea     ecx, [ebp+var_2B8] ; this
.text:000040C0                 call    ?DeleteFrom@UString@@QAEXI@Z ; UString::DeleteFrom(uint)
.text:000040C5                 lea     ecx, [ebp+var_2F8] ; this
.text:000040CB                 call    ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::CFileInfo(void)
.text:000040D0                 mov     [ebp+var_728], eax
.text:000040D6                 mov     byte ptr [ebp+var_4], 1Ch
.text:000040DA                 lea     ecx, [ebp+var_2B8]
.text:000040E0                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000040E5                 mov     [ebp+var_72C], eax
.text:000040EB                 mov     ecx, [ebp+var_72C]
.text:000040F1                 push    ecx             ; wchar_t *
.text:000040F2                 lea     ecx, [ebp+var_2F8] ; this
.text:000040F8                 call    ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z ; NWindows::NFile::NFind::CFileInfo::Find(wchar_t const *)
.text:000040FD                 mov     [ebp+var_72D], al
.text:00004103                 movzx   edx, [ebp+var_72D]
.text:0000410A                 test    edx, edx
.text:0000410C                 jz      short loc_4151
.text:0000410E                 lea     ecx, [ebp+var_2F8] ; this
.text:00004114                 call    ?IsReadOnly@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ ; NWindows::NFile::NFind::CFileInfoBase::IsReadOnly(void)
.text:00004119                 mov     [ebp+var_72E], al
.text:0000411F                 movzx   eax, [ebp+var_72E]
.text:00004126                 test    eax, eax
.text:00004128                 jz      short loc_4151
.text:0000412A                 lea     ecx, [ebp+var_2B8]
.text:00004130                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00004135                 mov     [ebp+var_734], eax
.text:0000413B                 mov     ecx, [ebp+var_2D8]
.text:00004141                 and     ecx, 0FFFFFFFEh
.text:00004144                 push    ecx             ; struct UString *
.text:00004145                 mov     edx, [ebp+var_734]
.text:0000414B                 push    edx             ; wchar_t *
.text:0000414C                 call    ?SetFileAttrib@NDir@NFile@NWindows@@YG_NPB_WK@Z ; NWindows::NFile::NDir::SetFileAttrib(wchar_t const *,ulong)
.text:00004151
.text:00004151 loc_4151:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2508j
.text:00004151                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2524j
.text:00004151                 mov     byte ptr [ebp+var_4], 1Bh
.text:00004155                 lea     ecx, [ebp+var_2F8] ; this
.text:0000415B                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00004160                 mov     byte ptr [ebp+var_4], 16h
.text:00004164                 lea     ecx, [ebp+var_2B8] ; this
.text:0000416A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000416F
.text:0000416F loc_416F:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):loc_402Cj
.text:0000416F                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2463j ...
.text:0000416F                 mov     byte ptr [ebp+var_4], 12h
.text:00004173                 lea     ecx, [ebp+var_24C] ; this
.text:00004179                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:0000417E
.text:0000417E loc_417E:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):loc_3501j
.text:0000417E                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+190Ej
.text:0000417E                 lea     eax, [ebp+var_1D4]
.text:00004184                 push    eax
.text:00004185                 mov     ecx, [ebp+this]
.text:00004188                 add     ecx, 0A8h ; '¿'
.text:0000418E                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00004193                 movzx   ecx, [ebp+var_175]
.text:0000419A                 test    ecx, ecx
.text:0000419C                 jnz     loc_4E59
.text:000041A2                 lea     ecx, [ebp+var_4C] ; this
.text:000041A5                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000041AA                 mov     [ebp+var_735], al
.text:000041B0                 movzx   edx, [ebp+var_735]
.text:000041B7                 test    edx, edx
.text:000041B9                 jnz     loc_4830
.text:000041BF                 lea     ecx, [ebp+var_30C]
.text:000041C5                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000041CA                 mov     [ebp+var_73C], eax
.text:000041D0                 mov     byte ptr [ebp+var_4], 1Dh
.text:000041D4                 movzx   eax, [ebp+var_3B]
.text:000041D8                 test    eax, eax
.text:000041DA                 jz      short loc_4226
.text:000041DC                 mov     ecx, [ebp+this]
.text:000041DF                 add     ecx, 68h ; 'h'
.text:000041E2                 push    ecx
.text:000041E3                 lea     edx, [ebp+var_4BC]
.text:000041E9                 push    edx
.text:000041EA                 call    ?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z ; GetDirPrefixOf(UString const &)
.text:000041EF                 mov     [ebp+var_740], eax
.text:000041F5                 mov     eax, [ebp+var_740]
.text:000041FB                 mov     [ebp+var_744], eax
.text:00004201                 mov     byte ptr [ebp+var_4], 1Eh
.text:00004205                 mov     ecx, [ebp+var_744]
.text:0000420B                 push    ecx
.text:0000420C                 lea     ecx, [ebp+var_30C]
.text:00004212                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00004217                 mov     byte ptr [ebp+var_4], 1Dh
.text:0000421B                 lea     ecx, [ebp+var_4BC] ; this
.text:00004221                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004226
.text:00004226 loc_4226:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+25D6j
.text:00004226                 lea     edx, [ebp+var_4C]
.text:00004229                 push    edx
.text:0000422A                 lea     ecx, [ebp+var_30C]
.text:00004230                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00004235                 lea     eax, [ebp+var_30C]
.text:0000423B                 push    eax
.text:0000423C                 call    ?IsSafePath@@YG_NABVUString@@@Z ; IsSafePath(UString const &)
.text:00004241                 mov     [ebp+var_745], al
.text:00004247                 movzx   ecx, [ebp+var_745]
.text:0000424E                 test    ecx, ecx
.text:00004250                 jnz     loc_42E9
.text:00004256                 lea     edx, [ebp+var_30C]
.text:0000425C                 push    edx             ; struct UString *
.text:0000425D                 push    offset $SG76721 ; "Dangerous link path was ignored"
.text:00004262                 mov     ecx, [ebp+this] ; this
.text:00004265                 call    ?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z ; CArchiveExtractCallback::SendMessageError(char const *,UString const &)
.text:0000426A                 mov     [ebp+var_74C], eax
.text:00004270                 mov     eax, [ebp+var_74C]
.text:00004276                 mov     [ebp+var_314], eax
.text:0000427C                 cmp     [ebp+var_314], 0
.text:00004283                 jz      short loc_42E4
.text:00004285                 mov     ecx, [ebp+var_314]
.text:0000428B                 mov     [ebp+var_4C0], ecx
.text:00004291                 mov     byte ptr [ebp+var_4], 12h
.text:00004295                 lea     ecx, [ebp+var_30C] ; this
.text:0000429B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000042A0                 mov     byte ptr [ebp+var_4], 10h
.text:000042A4                 lea     ecx, [ebp+var_1D4] ; this
.text:000042AA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000042AF                 mov     byte ptr [ebp+var_4], 0Ch
.text:000042B3                 lea     ecx, [ebp+var_1AC] ; this
.text:000042B9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000042BE                 mov     byte ptr [ebp+var_4], 2
.text:000042C2                 lea     ecx, [ebp+var_144]
.text:000042C8                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000042CD                 mov     byte ptr [ebp+var_4], 0
.text:000042D1                 lea     ecx, [ebp+var_4C] ; this
.text:000042D4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000042D9                 mov     eax, [ebp+var_4C0]
.text:000042DF                 jmp     loc_4F97
.text:000042E4 ; ---------------------------------------------------------------------------
.text:000042E4
.text:000042E4 loc_42E4:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+267Fj
.text:000042E4                 jmp     loc_481C
.text:000042E9 ; ---------------------------------------------------------------------------
.text:000042E9
.text:000042E9 loc_42E9:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+264Cj
.text:000042E9                 lea     ecx, [ebp+var_324]
.text:000042EF                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000042F4                 mov     [ebp+var_750], eax
.text:000042FA                 mov     byte ptr [ebp+var_4], 1Fh
.text:000042FE                 movzx   edx, [ebp+var_39]
.text:00004302                 test    edx, edx
.text:00004304                 jnz     short loc_4312
.text:00004306                 movzx   eax, [ebp+var_3B]
.text:0000430A                 test    eax, eax
.text:0000430C                 jnz     loc_4402
.text:00004312
.text:00004312 loc_4312:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2700j
.text:00004312                 lea     ecx, [ebp+var_30C]
.text:00004318                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000431D                 mov     [ebp+var_754], eax
.text:00004323                 mov     ecx, [ebp+this]
.text:00004326                 add     ecx, 48h ; 'H'
.text:00004329                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000432E                 mov     [ebp+var_758], eax
.text:00004334                 lea     ecx, [ebp+var_324]
.text:0000433A                 push    ecx             ; wchar_t *
.text:0000433B                 mov     edx, [ebp+var_754]
.text:00004341                 push    edx             ; wchar_t *
.text:00004342                 mov     eax, [ebp+var_758]
.text:00004348                 push    eax             ; this
.text:00004349                 call    ?GetFullPath@NName@NFile@NWindows@@YG_NPB_W0AAVUString@@@Z ; NWindows::NFile::NName::GetFullPath(wchar_t const *,wchar_t const *,UString &)
.text:0000434E                 mov     [ebp+var_759], al
.text:00004354                 movzx   ecx, [ebp+var_759]
.text:0000435B                 test    ecx, ecx
.text:0000435D                 jnz     loc_4400
.text:00004363                 lea     edx, [ebp+var_30C]
.text:00004369                 push    edx             ; struct UString *
.text:0000436A                 push    offset $SG76730 ; "Incorrect path"
.text:0000436F                 mov     ecx, [ebp+this] ; this
.text:00004372                 call    ?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z ; CArchiveExtractCallback::SendMessageError(char const *,UString const &)
.text:00004377                 mov     [ebp+var_760], eax
.text:0000437D                 mov     eax, [ebp+var_760]
.text:00004383                 mov     [ebp+var_32C], eax
.text:00004389                 cmp     [ebp+var_32C], 0
.text:00004390                 jz      short loc_4400
.text:00004392                 mov     ecx, [ebp+var_32C]
.text:00004398                 mov     [ebp+var_4C4], ecx
.text:0000439E                 mov     byte ptr [ebp+var_4], 1Dh
.text:000043A2                 lea     ecx, [ebp+var_324] ; this
.text:000043A8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000043AD                 mov     byte ptr [ebp+var_4], 12h
.text:000043B1                 lea     ecx, [ebp+var_30C] ; this
.text:000043B7                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000043BC                 mov     byte ptr [ebp+var_4], 10h
.text:000043C0                 lea     ecx, [ebp+var_1D4] ; this
.text:000043C6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000043CB                 mov     byte ptr [ebp+var_4], 0Ch
.text:000043CF                 lea     ecx, [ebp+var_1AC] ; this
.text:000043D5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000043DA                 mov     byte ptr [ebp+var_4], 2
.text:000043DE                 lea     ecx, [ebp+var_144]
.text:000043E4                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000043E9                 mov     byte ptr [ebp+var_4], 0
.text:000043ED                 lea     ecx, [ebp+var_4C] ; this
.text:000043F0                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000043F5                 mov     eax, [ebp+var_4C4]
.text:000043FB                 jmp     loc_4F97
.text:00004400 ; ---------------------------------------------------------------------------
.text:00004400
.text:00004400 loc_4400:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2759j
.text:00004400                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+278Cj
.text:00004400                 jmp     short loc_4411
.text:00004402 ; ---------------------------------------------------------------------------
.text:00004402
.text:00004402 loc_4402:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2708j
.text:00004402                 lea     edx, [ebp+var_4C]
.text:00004405                 push    edx             ; unsigned __int32
.text:00004406                 lea     ecx, [ebp+var_324]
.text:0000440C                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00004411
.text:00004411 loc_4411:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):loc_4400j
.text:00004411                 lea     ecx, [ebp+var_324] ; this
.text:00004417                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000441C                 mov     [ebp+var_761], al
.text:00004422                 movzx   eax, [ebp+var_761]
.text:00004429                 test    eax, eax
.text:0000442B                 jnz     loc_480D
.text:00004431                 movzx   ecx, [ebp+var_39]
.text:00004435                 test    ecx, ecx
.text:00004437                 jz      loc_4530
.text:0000443D                 lea     ecx, [ebp+var_324]
.text:00004443                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00004448                 mov     [ebp+var_768], eax
.text:0000444E                 lea     ecx, [ebp+var_1D4]
.text:00004454                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00004459                 mov     [ebp+var_76C], eax
.text:0000445F                 mov     edx, [ebp+var_768]
.text:00004465                 push    edx             ; wchar_t *
.text:00004466                 mov     eax, [ebp+var_76C]
.text:0000446C                 push    eax             ; this
.text:0000446D                 call    ?MyCreateHardLink@NDir@NFile@NWindows@@YG_NPB_W0@Z ; NWindows::NFile::NDir::MyCreateHardLink(wchar_t const *,wchar_t const *)
.text:00004472                 mov     [ebp+var_76D], al
.text:00004478                 movzx   ecx, [ebp+var_76D]
.text:0000447F                 test    ecx, ecx
.text:00004481                 jnz     loc_452B
.text:00004487                 lea     edx, [ebp+var_324]
.text:0000448D                 push    edx             ; struct UString *
.text:0000448E                 lea     eax, [ebp+var_1D4]
.text:00004494                 push    eax             ; struct UString *
.text:00004495                 push    offset $SG76738 ; "Can not create hard link"
.text:0000449A                 mov     ecx, [ebp+this] ; this
.text:0000449D                 call    ?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z ; CArchiveExtractCallback::SendMessageError2(char const *,UString const &,UString const &)
.text:000044A2                 mov     [ebp+var_774], eax
.text:000044A8                 mov     ecx, [ebp+var_774]
.text:000044AE                 mov     [ebp+var_330], ecx
.text:000044B4                 cmp     [ebp+var_330], 0
.text:000044BB                 jz      short loc_452B
.text:000044BD                 mov     edx, [ebp+var_330]
.text:000044C3                 mov     [ebp+var_4C8], edx
.text:000044C9                 mov     byte ptr [ebp+var_4], 1Dh
.text:000044CD                 lea     ecx, [ebp+var_324] ; this
.text:000044D3                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000044D8                 mov     byte ptr [ebp+var_4], 12h
.text:000044DC                 lea     ecx, [ebp+var_30C] ; this
.text:000044E2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000044E7                 mov     byte ptr [ebp+var_4], 10h
.text:000044EB                 lea     ecx, [ebp+var_1D4] ; this
.text:000044F1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000044F6                 mov     byte ptr [ebp+var_4], 0Ch
.text:000044FA                 lea     ecx, [ebp+var_1AC] ; this
.text:00004500                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004505                 mov     byte ptr [ebp+var_4], 2
.text:00004509                 lea     ecx, [ebp+var_144]
.text:0000450F                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004514                 mov     byte ptr [ebp+var_4], 0
.text:00004518                 lea     ecx, [ebp+var_4C] ; this
.text:0000451B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004520                 mov     eax, [ebp+var_4C8]
.text:00004526                 jmp     loc_4F97
.text:0000452B ; ---------------------------------------------------------------------------
.text:0000452B
.text:0000452B loc_452B:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+287Dj
.text:0000452B                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+28B7j
.text:0000452B                 jmp     loc_480D
.text:00004530 ; ---------------------------------------------------------------------------
.text:00004530
.text:00004530 loc_4530:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2833j
.text:00004530                 mov     eax, [ebp+this]
.text:00004533                 movzx   ecx, byte ptr [eax+1Ah]
.text:00004537                 test    ecx, ecx
.text:00004539                 jz      loc_480D
.text:0000453F                 lea     ecx, [ebp+var_33C]
.text:00004545                 call    ??0?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::CBuffer<uchar>(void)
.text:0000454A                 mov     [ebp+var_778], eax
.text:00004550                 mov     byte ptr [ebp+var_4], 20h ; ' '
.text:00004554                 lea     ecx, [ebp+var_324]
.text:0000455A                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000455F                 mov     [ebp+var_77C], eax
.text:00004565                 movzx   edx, [ebp+var_3A]
.text:00004569                 test    edx, edx
.text:0000456B                 setz    al
.text:0000456E                 movzx   ecx, al
.text:00004571                 push    ecx
.text:00004572                 mov     edx, [ebp+var_77C]
.text:00004578                 push    edx
.text:00004579                 lea     eax, [ebp+var_33C]
.text:0000457F                 push    eax
.text:00004580                 call    ?FillLinkData@NFile@NWindows@@YG_NAAV?$CBuffer@E@@PB_W_N@Z ; NWindows::NFile::FillLinkData(CBuffer<uchar> &,wchar_t const *,bool)
.text:00004585                 mov     [ebp+var_77D], al
.text:0000458B                 movzx   ecx, [ebp+var_77D]
.text:00004592                 test    ecx, ecx
.text:00004594                 jz      loc_47FE
.text:0000459A                 lea     ecx, [ebp+var_364] ; this
.text:000045A0                 call    ??0CReparseAttr@NFile@NWindows@@QAE@XZ ; NWindows::NFile::CReparseAttr::CReparseAttr(void)
.text:000045A5                 mov     [ebp+var_784], eax
.text:000045AB                 mov     byte ptr [ebp+var_4], 21h ; '!'
.text:000045AF                 lea     ecx, [ebp+var_33C]
.text:000045B5                 call    ?Size@?$CBuffer@E@@QBEIXZ ; CBuffer<uchar>::Size(void)
.text:000045BA                 mov     [ebp+var_788], eax
.text:000045C0                 lea     ecx, [ebp+var_33C]
.text:000045C6                 call    ??B?$CBuffer@E@@QAEPAEXZ ; CBuffer<uchar>::operator uchar *(void)
.text:000045CB                 mov     [ebp+var_78C], eax
.text:000045D1                 mov     edx, [ebp+var_788]
.text:000045D7                 push    edx             ; unsigned int
.text:000045D8                 mov     eax, [ebp+var_78C]
.text:000045DE                 push    eax             ; unsigned __int8 *
.text:000045DF                 lea     ecx, [ebp+var_364] ; this
.text:000045E5                 call    ?Parse@CReparseAttr@NFile@NWindows@@QAE_NPBEI@Z ; NWindows::NFile::CReparseAttr::Parse(uchar const *,uint)
.text:000045EA                 mov     [ebp+var_78D], al
.text:000045F0                 movzx   ecx, [ebp+var_78D]
.text:000045F7                 test    ecx, ecx
.text:000045F9                 jnz     loc_46C3
.text:000045FF                 mov     edx, [ebp+this]
.text:00004602                 add     edx, 68h ; 'h'
.text:00004605                 push    edx             ; struct UString *
.text:00004606                 push    offset $SG76749 ; "Internal error for symbolic link file"
.text:0000460B                 mov     ecx, [ebp+this] ; this
.text:0000460E                 call    ?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z ; CArchiveExtractCallback::SendMessageError(char const *,UString const &)
.text:00004613                 mov     [ebp+var_794], eax
.text:00004619                 mov     eax, [ebp+var_794]
.text:0000461F                 mov     [ebp+var_36C], eax
.text:00004625                 cmp     [ebp+var_36C], 0
.text:0000462C                 jz      loc_46BE
.text:00004632                 mov     ecx, [ebp+var_36C]
.text:00004638                 mov     [ebp+var_4CC], ecx
.text:0000463E                 mov     byte ptr [ebp+var_4], 20h ; ' '
.text:00004642                 lea     ecx, [ebp+var_364] ; this
.text:00004648                 call    ??1CReparseAttr@NFile@NWindows@@QAE@XZ ; NWindows::NFile::CReparseAttr::~CReparseAttr(void)
.text:0000464D                 mov     byte ptr [ebp+var_4], 1Fh
.text:00004651                 lea     ecx, [ebp+var_33C]
.text:00004657                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:0000465C                 mov     byte ptr [ebp+var_4], 1Dh
.text:00004660                 lea     ecx, [ebp+var_324] ; this
.text:00004666                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000466B                 mov     byte ptr [ebp+var_4], 12h
.text:0000466F                 lea     ecx, [ebp+var_30C] ; this
.text:00004675                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000467A                 mov     byte ptr [ebp+var_4], 10h
.text:0000467E                 lea     ecx, [ebp+var_1D4] ; this
.text:00004684                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004689                 mov     byte ptr [ebp+var_4], 0Ch
.text:0000468D                 lea     ecx, [ebp+var_1AC] ; this
.text:00004693                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004698                 mov     byte ptr [ebp+var_4], 2
.text:0000469C                 lea     ecx, [ebp+var_144]
.text:000046A2                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000046A7                 mov     byte ptr [ebp+var_4], 0
.text:000046AB                 lea     ecx, [ebp+var_4C] ; this
.text:000046AE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000046B3                 mov     eax, [ebp+var_4CC]
.text:000046B9                 jmp     loc_4F97
.text:000046BE ; ---------------------------------------------------------------------------
.text:000046BE
.text:000046BE loc_46BE:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2A28j
.text:000046BE                 jmp     loc_47EF
.text:000046C3 ; ---------------------------------------------------------------------------
.text:000046C3
.text:000046C3 loc_46C3:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+29F5j
.text:000046C3                 lea     ecx, [ebp+var_33C]
.text:000046C9                 call    ?Size@?$CBuffer@E@@QBEIXZ ; CBuffer<uchar>::Size(void)
.text:000046CE                 mov     [ebp+var_798], eax
.text:000046D4                 lea     ecx, [ebp+var_33C]
.text:000046DA                 call    ??B?$CBuffer@E@@QAEPAEXZ ; CBuffer<uchar>::operator uchar *(void)
.text:000046DF                 mov     dword ptr [ebp+var_79C], eax
.text:000046E5                 lea     ecx, [ebp+var_1D4]
.text:000046EB                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000046F0                 mov     [ebp+var_7A0], eax
.text:000046F6                 mov     edx, [ebp+var_798]
.text:000046FC                 push    edx             ; void *
.text:000046FD                 mov     eax, dword ptr [ebp+var_79C]
.text:00004703                 push    eax             ; bool
.text:00004704                 mov     ecx, [ebp+this]
.text:00004707                 movzx   edx, byte ptr [ecx+9Ah]
.text:0000470E                 push    edx             ; wchar_t *
.text:0000470F                 mov     eax, [ebp+var_7A0]
.text:00004715                 push    eax             ; this
.text:00004716                 call    ?SetReparseData@NIO@NFile@NWindows@@YG_NPB_W_NPBXK@Z ; NWindows::NFile::NIO::SetReparseData(wchar_t const *,bool,void const *,ulong)
.text:0000471B                 mov     [ebp+var_7A1], al
.text:00004721                 movzx   ecx, [ebp+var_7A1]
.text:00004728                 test    ecx, ecx
.text:0000472A                 jnz     loc_47EF
.text:00004730                 lea     edx, [ebp+var_1D4]
.text:00004736                 push    edx             ; struct UString *
.text:00004737                 push    offset $SG76756 ; "Can not create symbolic link"
.text:0000473C                 mov     ecx, [ebp+this] ; this
.text:0000473F                 call    ?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z ; CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)
.text:00004744                 mov     [ebp+var_7A8], eax
.text:0000474A                 mov     eax, [ebp+var_7A8]
.text:00004750                 mov     [ebp+var_370], eax
.text:00004756                 cmp     [ebp+var_370], 0
.text:0000475D                 jz      loc_47EF
.text:00004763                 mov     ecx, [ebp+var_370]
.text:00004769                 mov     [ebp+var_4D0], ecx
.text:0000476F                 mov     byte ptr [ebp+var_4], 20h ; ' '
.text:00004773                 lea     ecx, [ebp+var_364] ; this
.text:00004779                 call    ??1CReparseAttr@NFile@NWindows@@QAE@XZ ; NWindows::NFile::CReparseAttr::~CReparseAttr(void)
.text:0000477E                 mov     byte ptr [ebp+var_4], 1Fh
.text:00004782                 lea     ecx, [ebp+var_33C]
.text:00004788                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:0000478D                 mov     byte ptr [ebp+var_4], 1Dh
.text:00004791                 lea     ecx, [ebp+var_324] ; this
.text:00004797                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000479C                 mov     byte ptr [ebp+var_4], 12h
.text:000047A0                 lea     ecx, [ebp+var_30C] ; this
.text:000047A6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000047AB                 mov     byte ptr [ebp+var_4], 10h
.text:000047AF                 lea     ecx, [ebp+var_1D4] ; this
.text:000047B5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000047BA                 mov     byte ptr [ebp+var_4], 0Ch
.text:000047BE                 lea     ecx, [ebp+var_1AC] ; this
.text:000047C4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000047C9                 mov     byte ptr [ebp+var_4], 2
.text:000047CD                 lea     ecx, [ebp+var_144]
.text:000047D3                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000047D8                 mov     byte ptr [ebp+var_4], 0
.text:000047DC                 lea     ecx, [ebp+var_4C] ; this
.text:000047DF                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000047E4                 mov     eax, [ebp+var_4D0]
.text:000047EA                 jmp     loc_4F97
.text:000047EF ; ---------------------------------------------------------------------------
.text:000047EF
.text:000047EF loc_47EF:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):loc_46BEj
.text:000047EF                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2B26j ...
.text:000047EF                 mov     byte ptr [ebp+var_4], 20h ; ' '
.text:000047F3                 lea     ecx, [ebp+var_364] ; this
.text:000047F9                 call    ??1CReparseAttr@NFile@NWindows@@QAE@XZ ; NWindows::NFile::CReparseAttr::~CReparseAttr(void)
.text:000047FE
.text:000047FE loc_47FE:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2990j
.text:000047FE                 mov     byte ptr [ebp+var_4], 1Fh
.text:00004802                 lea     ecx, [ebp+var_33C]
.text:00004808                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:0000480D
.text:0000480D loc_480D:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2827j
.text:0000480D                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):loc_452Bj ...
.text:0000480D                 mov     byte ptr [ebp+var_4], 1Dh
.text:00004811                 lea     ecx, [ebp+var_324] ; this
.text:00004817                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000481C
.text:0000481C loc_481C:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int):loc_42E4j
.text:0000481C                 mov     byte ptr [ebp+var_4], 12h
.text:00004820                 lea     ecx, [ebp+var_30C] ; this
.text:00004826                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000482B                 jmp     loc_4E59
.text:00004830 ; ---------------------------------------------------------------------------
.text:00004830
.text:00004830 loc_4830:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+25B5j
.text:00004830                 mov     [ebp+var_371], 1
.text:00004837                 mov     ecx, [ebp+this]
.text:0000483A                 add     ecx, 190h
.text:00004840                 call    ?IsEmpty@?$CRecordVector@UCHardLinkNode@@@@QBE_NXZ ; CRecordVector<CHardLinkNode>::IsEmpty(void)
.text:00004845                 mov     [ebp+var_7A9], al
.text:0000484B                 movzx   edx, [ebp+var_7A9]
.text:00004852                 test    edx, edx
.text:00004854                 jnz     loc_4AB4
.text:0000485A                 mov     eax, [ebp+this]
.text:0000485D                 movzx   ecx, byte ptr [eax+98h]
.text:00004864                 test    ecx, ecx
.text:00004866                 jnz     loc_4AB4
.text:0000486C                 lea     edx, [ebp+var_391]
.text:00004872                 push    edx             ; int
.text:00004873                 lea     eax, [ebp+var_388]
.text:00004879                 push    eax             ; unsigned __int64 *
.text:0000487A                 mov     ecx, [ebp+arg_4]
.text:0000487D                 push    ecx             ; int
.text:0000487E                 mov     edx, [ebp+var_18]
.text:00004881                 push    edx             ; int
.text:00004882                 call    ?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z ; Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)
.text:00004887                 mov     [ebp+var_7B0], eax
.text:0000488D                 mov     eax, [ebp+var_7B0]
.text:00004893                 mov     [ebp+var_39C], eax
.text:00004899                 cmp     [ebp+var_39C], 0
.text:000048A0                 jz      short loc_48F2
.text:000048A2                 mov     ecx, [ebp+var_39C]
.text:000048A8                 mov     [ebp+var_4D4], ecx
.text:000048AE                 mov     byte ptr [ebp+var_4], 10h
.text:000048B2                 lea     ecx, [ebp+var_1D4] ; this
.text:000048B8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000048BD                 mov     byte ptr [ebp+var_4], 0Ch
.text:000048C1                 lea     ecx, [ebp+var_1AC] ; this
.text:000048C7                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000048CC                 mov     byte ptr [ebp+var_4], 2
.text:000048D0                 lea     ecx, [ebp+var_144]
.text:000048D6                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000048DB                 mov     byte ptr [ebp+var_4], 0
.text:000048DF                 lea     ecx, [ebp+var_4C] ; this
.text:000048E2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000048E7                 mov     eax, [ebp+var_4D4]
.text:000048ED                 jmp     loc_4F97
.text:000048F2 ; ---------------------------------------------------------------------------
.text:000048F2
.text:000048F2 loc_48F2:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2C9Cj
.text:000048F2                 movzx   edx, byte ptr [ebp+var_391]
.text:000048F9                 test    edx, edx
.text:000048FB                 jz      loc_4AB4
.text:00004901                 lea     eax, [ebp+var_388]
.text:00004907                 push    eax             ; CHardLinkNode *
.text:00004908                 mov     ecx, [ebp+this]
.text:0000490B                 add     ecx, 190h
.text:00004911                 call    ?FindInSorted2@?$CRecordVector@UCHardLinkNode@@@@QBEHABUCHardLinkNode@@@Z ; CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode const &)
.text:00004916                 mov     [ebp+var_7B4], eax
.text:0000491C                 mov     ecx, [ebp+var_7B4]
.text:00004922                 mov     [ebp+var_3A0], ecx
.text:00004928                 cmp     [ebp+var_3A0], 0
.text:0000492F                 jl      loc_4AB4
.text:00004935                 mov     edx, [ebp+var_3A0]
.text:0000493B                 push    edx
.text:0000493C                 mov     ecx, [ebp+this]
.text:0000493F                 add     ecx, 19Ch
.text:00004945                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000494A                 mov     [ebp+var_7B8], eax
.text:00004950                 mov     eax, [ebp+var_7B8]
.text:00004956                 mov     [ebp+var_3A4], eax
.text:0000495C                 mov     ecx, [ebp+var_3A4] ; this
.text:00004962                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00004967                 mov     [ebp+var_7B9], al
.text:0000496D                 movzx   ecx, [ebp+var_7B9]
.text:00004974                 test    ecx, ecx
.text:00004976                 jz      short loc_498F
.text:00004978                 lea     edx, [ebp+var_1D4]
.text:0000497E                 push    edx
.text:0000497F                 mov     ecx, [ebp+var_3A4]
.text:00004985                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:0000498A                 jmp     loc_4AB4
.text:0000498F ; ---------------------------------------------------------------------------
.text:0000498F
.text:0000498F loc_498F:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2D72j
.text:0000498F                 mov     ecx, [ebp+var_3A4]
.text:00004995                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000499A                 mov     [ebp+var_7C0], eax
.text:000049A0                 lea     ecx, [ebp+var_1D4]
.text:000049A6                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000049AB                 mov     [ebp+var_7C4], eax
.text:000049B1                 mov     eax, [ebp+var_7C0]
.text:000049B7                 push    eax             ; wchar_t *
.text:000049B8                 mov     ecx, [ebp+var_7C4]
.text:000049BE                 push    ecx             ; this
.text:000049BF                 call    ?MyCreateHardLink@NDir@NFile@NWindows@@YG_NPB_W0@Z ; NWindows::NFile::NDir::MyCreateHardLink(wchar_t const *,wchar_t const *)
.text:000049C4                 mov     [ebp+var_7C5], al
.text:000049CA                 movzx   edx, [ebp+var_7C5]
.text:000049D1                 test    edx, edx
.text:000049D3                 jnz     loc_4AAD
.text:000049D9                 mov     eax, [ebp+var_3A4]
.text:000049DF                 push    eax             ; struct UString *
.text:000049E0                 lea     ecx, [ebp+var_1D4]
.text:000049E6                 push    ecx             ; struct UString *
.text:000049E7                 push    offset $SG76775 ; "Can not create hard link"
.text:000049EC                 mov     ecx, [ebp+this] ; this
.text:000049EF                 call    ?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z ; CArchiveExtractCallback::SendMessageError2(char const *,UString const &,UString const &)
.text:000049F4                 mov     [ebp+var_7CC], eax
.text:000049FA                 mov     edx, [ebp+var_7CC]
.text:00004A00                 mov     [ebp+var_3A8], edx
.text:00004A06                 cmp     [ebp+var_3A8], 0
.text:00004A0D                 jz      short loc_4A5F
.text:00004A0F                 mov     eax, [ebp+var_3A8]
.text:00004A15                 mov     [ebp+var_4D8], eax
.text:00004A1B                 mov     byte ptr [ebp+var_4], 10h
.text:00004A1F                 lea     ecx, [ebp+var_1D4] ; this
.text:00004A25                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004A2A                 mov     byte ptr [ebp+var_4], 0Ch
.text:00004A2E                 lea     ecx, [ebp+var_1AC] ; this
.text:00004A34                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004A39                 mov     byte ptr [ebp+var_4], 2
.text:00004A3D                 lea     ecx, [ebp+var_144]
.text:00004A43                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004A48                 mov     byte ptr [ebp+var_4], 0
.text:00004A4C                 lea     ecx, [ebp+var_4C] ; this
.text:00004A4F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004A54                 mov     eax, [ebp+var_4D8]
.text:00004A5A                 jmp     loc_4F97
.text:00004A5F ; ---------------------------------------------------------------------------
.text:00004A5F
.text:00004A5F loc_4A5F:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2E09j
.text:00004A5F                 mov     [ebp+var_4DC], 0
.text:00004A69                 mov     byte ptr [ebp+var_4], 10h
.text:00004A6D                 lea     ecx, [ebp+var_1D4] ; this
.text:00004A73                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004A78                 mov     byte ptr [ebp+var_4], 0Ch
.text:00004A7C                 lea     ecx, [ebp+var_1AC] ; this
.text:00004A82                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004A87                 mov     byte ptr [ebp+var_4], 2
.text:00004A8B                 lea     ecx, [ebp+var_144]
.text:00004A91                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004A96                 mov     byte ptr [ebp+var_4], 0
.text:00004A9A                 lea     ecx, [ebp+var_4C] ; this
.text:00004A9D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004AA2                 mov     eax, [ebp+var_4DC]
.text:00004AA8                 jmp     loc_4F97
.text:00004AAD ; ---------------------------------------------------------------------------
.text:00004AAD
.text:00004AAD loc_4AAD:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2DCFj
.text:00004AAD                 mov     [ebp+var_371], 0
.text:00004AB4
.text:00004AB4 loc_4AB4:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2C50j
.text:00004AB4                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2C62j ...
.text:00004AB4                 movzx   ecx, [ebp+var_371]
.text:00004ABB                 test    ecx, ecx
.text:00004ABD                 jz      loc_4E59
.text:00004AC3                 push    20h ; ' '       ; unsigned int
.text:00004AC5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00004ACA                 add     esp, 4
.text:00004ACD                 mov     [ebp+var_7D0], eax
.text:00004AD3                 mov     edx, [ebp+var_7D0]
.text:00004AD9                 mov     [ebp+var_4E4], edx
.text:00004ADF                 mov     byte ptr [ebp+var_4], 22h ; '"'
.text:00004AE3                 cmp     [ebp+var_4E4], 0
.text:00004AEA                 jz      short loc_4B0B
.text:00004AEC                 mov     ecx, [ebp+var_4E4]
.text:00004AF2                 call    ??0COutFileStream@@QAE@XZ ; COutFileStream::COutFileStream(void)
.text:00004AF7                 mov     [ebp+var_7D4], eax
.text:00004AFD                 mov     eax, [ebp+var_7D4]
.text:00004B03                 mov     [ebp+var_7D8], eax
.text:00004B09                 jmp     short loc_4B15
.text:00004B0B ; ---------------------------------------------------------------------------
.text:00004B0B
.text:00004B0B loc_4B0B:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2EE6j
.text:00004B0B                 mov     [ebp+var_7D8], 0
.text:00004B15
.text:00004B15 loc_4B15:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2F05j
.text:00004B15                 mov     ecx, [ebp+var_7D8]
.text:00004B1B                 mov     [ebp+var_4E0], ecx
.text:00004B21                 mov     byte ptr [ebp+var_4], 12h
.text:00004B25                 mov     edx, [ebp+this]
.text:00004B28                 mov     eax, [ebp+var_4E0]
.text:00004B2E                 mov     [edx+0FCh], eax
.text:00004B34                 mov     ecx, [ebp+this]
.text:00004B37                 mov     edx, [ecx+0FCh]
.text:00004B3D                 push    edx
.text:00004B3E                 lea     ecx, [ebp+var_3B0]
.text:00004B44                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@PAUISequentialOutStream@@@Z ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(ISequentialOutStream *)
.text:00004B49                 mov     byte ptr [ebp+var_4], 23h ; '#'
.text:00004B4D                 lea     ecx, [ebp+var_1D4]
.text:00004B53                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00004B58                 mov     [ebp+var_7DC], eax
.text:00004B5E                 mov     eax, [ebp+this]
.text:00004B61                 movzx   ecx, byte ptr [eax+0C0h]
.text:00004B68                 neg     ecx
.text:00004B6A                 sbb     ecx, ecx
.text:00004B6C                 and     ecx, 2
.text:00004B6F                 add     ecx, 2
.text:00004B72                 push    ecx             ; unsigned __int32
.text:00004B73                 mov     edx, [ebp+var_7DC]
.text:00004B79                 push    edx             ; wchar_t *
.text:00004B7A                 mov     eax, [ebp+this]
.text:00004B7D                 mov     ecx, [eax+0FCh] ; this
.text:00004B83                 call    ?Open@COutFileStream@@QAE_NPB_WK@Z ; COutFileStream::Open(wchar_t const *,ulong)
.text:00004B88                 mov     [ebp+var_7DD], al
.text:00004B8E                 movzx   ecx, [ebp+var_7DD]
.text:00004B95                 test    ecx, ecx
.text:00004B97                 jnz     loc_4C88
.text:00004B9D                 lea     edx, [ebp+var_1D4]
.text:00004BA3                 push    edx             ; struct UString *
.text:00004BA4                 push    offset $SG76789 ; "Can not open output file"
.text:00004BA9                 mov     ecx, [ebp+this] ; this
.text:00004BAC                 call    ?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z ; CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)
.text:00004BB1                 mov     [ebp+var_7E4], eax
.text:00004BB7                 mov     eax, [ebp+var_7E4]
.text:00004BBD                 mov     [ebp+var_3B8], eax
.text:00004BC3                 cmp     [ebp+var_3B8], 0
.text:00004BCA                 jz      short loc_4C2B
.text:00004BCC                 mov     ecx, [ebp+var_3B8]
.text:00004BD2                 mov     [ebp+var_4E8], ecx
.text:00004BD8                 mov     byte ptr [ebp+var_4], 12h
.text:00004BDC                 lea     ecx, [ebp+var_3B0]
.text:00004BE2                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004BE7                 mov     byte ptr [ebp+var_4], 10h
.text:00004BEB                 lea     ecx, [ebp+var_1D4] ; this
.text:00004BF1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004BF6                 mov     byte ptr [ebp+var_4], 0Ch
.text:00004BFA                 lea     ecx, [ebp+var_1AC] ; this
.text:00004C00                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004C05                 mov     byte ptr [ebp+var_4], 2
.text:00004C09                 lea     ecx, [ebp+var_144]
.text:00004C0F                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004C14                 mov     byte ptr [ebp+var_4], 0
.text:00004C18                 lea     ecx, [ebp+var_4C] ; this
.text:00004C1B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004C20                 mov     eax, [ebp+var_4E8]
.text:00004C26                 jmp     loc_4F97
.text:00004C2B ; ---------------------------------------------------------------------------
.text:00004C2B
.text:00004C2B loc_4C2B:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2FC6j
.text:00004C2B                 mov     [ebp+var_4EC], 0
.text:00004C35                 mov     byte ptr [ebp+var_4], 12h
.text:00004C39                 lea     ecx, [ebp+var_3B0]
.text:00004C3F                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004C44                 mov     byte ptr [ebp+var_4], 10h
.text:00004C48                 lea     ecx, [ebp+var_1D4] ; this
.text:00004C4E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004C53                 mov     byte ptr [ebp+var_4], 0Ch
.text:00004C57                 lea     ecx, [ebp+var_1AC] ; this
.text:00004C5D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004C62                 mov     byte ptr [ebp+var_4], 2
.text:00004C66                 lea     ecx, [ebp+var_144]
.text:00004C6C                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004C71                 mov     byte ptr [ebp+var_4], 0
.text:00004C75                 lea     ecx, [ebp+var_4C] ; this
.text:00004C78                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004C7D                 mov     eax, [ebp+var_4EC]
.text:00004C83                 jmp     loc_4F97
.text:00004C88 ; ---------------------------------------------------------------------------
.text:00004C88
.text:00004C88 loc_4C88:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2F93j
.text:00004C88                 movzx   edx, [ebp+var_20D]
.text:00004C8F                 test    edx, edx
.text:00004C91                 jz      loc_4D71
.text:00004C97                 mov     eax, [ebp+this]
.text:00004C9A                 movzx   ecx, byte ptr [eax+98h]
.text:00004CA1                 test    ecx, ecx
.text:00004CA3                 jnz     loc_4D71
.text:00004CA9                 lea     edx, [ebp+var_1D4]
.text:00004CAF                 push    edx
.text:00004CB0                 mov     eax, [ebp+arg_4]
.text:00004CB3                 push    eax
.text:00004CB4                 lea     ecx, [ebp+var_3CC]
.text:00004CBA                 call    ??0CIndexToPathPair@@QAE@IABVUString@@@Z ; CIndexToPathPair::CIndexToPathPair(uint,UString const &)
.text:00004CBF                 mov     [ebp+var_7E8], eax
.text:00004CC5                 mov     byte ptr [ebp+var_4], 24h ; '$'
.text:00004CC9                 mov     ecx, [ebp+this]
.text:00004CCC                 add     ecx, 1A8h
.text:00004CD2                 call    ?Size@?$CObjectVector@UCIndexToPathPair@@@@QBEIXZ ; CObjectVector<CIndexToPathPair>::Size(void)
.text:00004CD7                 mov     [ebp+var_7EC], eax
.text:00004CDD                 mov     ecx, [ebp+var_7EC]
.text:00004CE3                 mov     [ebp+var_3D4], ecx
.text:00004CE9                 lea     edx, [ebp+var_3CC]
.text:00004CEF                 push    edx             ; CIndexToPathPair *
.text:00004CF0                 mov     ecx, [ebp+this]
.text:00004CF3                 add     ecx, 1A8h
.text:00004CF9                 call    ?AddToUniqueSorted@?$CObjectVector@UCIndexToPathPair@@@@QAEIABUCIndexToPathPair@@@Z ; CObjectVector<CIndexToPathPair>::AddToUniqueSorted(CIndexToPathPair const &)
.text:00004CFE                 mov     [ebp+var_7F0], eax
.text:00004D04                 mov     eax, [ebp+var_7F0]
.text:00004D0A                 mov     [ebp+var_3D8], eax
.text:00004D10                 mov     ecx, [ebp+this]
.text:00004D13                 add     ecx, 1A8h
.text:00004D19                 call    ?Size@?$CObjectVector@UCIndexToPathPair@@@@QBEIXZ ; CObjectVector<CIndexToPathPair>::Size(void)
.text:00004D1E                 mov     [ebp+var_7F4], eax
.text:00004D24                 mov     ecx, [ebp+var_3D4]
.text:00004D2A                 cmp     ecx, [ebp+var_7F4]
.text:00004D30                 jnz     short loc_4D62
.text:00004D32                 mov     edx, [ebp+var_3D8]
.text:00004D38                 push    edx
.text:00004D39                 mov     ecx, [ebp+this]
.text:00004D3C                 add     ecx, 1A8h
.text:00004D42                 call    ??A?$CObjectVector@UCIndexToPathPair@@@@QAEAAUCIndexToPathPair@@I@Z ; CObjectVector<CIndexToPathPair>::operator[](uint)
.text:00004D47                 mov     [ebp+var_7F8], eax
.text:00004D4D                 lea     eax, [ebp+var_1D4]
.text:00004D53                 push    eax
.text:00004D54                 mov     ecx, [ebp+var_7F8]
.text:00004D5A                 add     ecx, 4
.text:00004D5D                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00004D62
.text:00004D62 loc_4D62:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+312Cj
.text:00004D62                 mov     byte ptr [ebp+var_4], 23h ; '#'
.text:00004D66                 lea     ecx, [ebp+var_3CC] ; this
.text:00004D6C                 call    ??1CIndexToPathPair@@QAE@XZ ; CIndexToPathPair::~CIndexToPathPair(void)
.text:00004D71
.text:00004D71 loc_4D71:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+308Dj
.text:00004D71                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+309Fj
.text:00004D71                 mov     ecx, [ebp+this]
.text:00004D74                 movzx   edx, byte ptr [ecx+0C0h]
.text:00004D7B                 test    edx, edx
.text:00004D7D                 jz      loc_4E35
.text:00004D83                 mov     esi, esp
.text:00004D85                 push    0
.text:00004D87                 push    0
.text:00004D89                 mov     eax, [ebp+this]
.text:00004D8C                 mov     ecx, [eax+0BCh]
.text:00004D92                 push    ecx
.text:00004D93                 mov     edx, [eax+0B8h]
.text:00004D99                 push    edx
.text:00004D9A                 mov     eax, [ebp+this]
.text:00004D9D                 mov     ecx, [eax+0FCh]
.text:00004DA3                 push    ecx
.text:00004DA4                 mov     edx, [ebp+this]
.text:00004DA7                 mov     eax, [edx+0FCh]
.text:00004DAD                 mov     ecx, [eax]
.text:00004DAF                 mov     edx, [ecx+10h]
.text:00004DB2                 call    edx
.text:00004DB4                 cmp     esi, esp
.text:00004DB6                 call    __RTC_CheckEsp
.text:00004DBB                 mov     [ebp+var_7FC], eax
.text:00004DC1                 mov     eax, [ebp+var_7FC]
.text:00004DC7                 mov     [ebp+var_3DC], eax
.text:00004DCD                 cmp     [ebp+var_3DC], 0
.text:00004DD4                 jz      short loc_4E35
.text:00004DD6                 mov     ecx, [ebp+var_3DC]
.text:00004DDC                 mov     [ebp+var_4F0], ecx
.text:00004DE2                 mov     byte ptr [ebp+var_4], 12h
.text:00004DE6                 lea     ecx, [ebp+var_3B0]
.text:00004DEC                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004DF1                 mov     byte ptr [ebp+var_4], 10h
.text:00004DF5                 lea     ecx, [ebp+var_1D4] ; this
.text:00004DFB                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004E00                 mov     byte ptr [ebp+var_4], 0Ch
.text:00004E04                 lea     ecx, [ebp+var_1AC] ; this
.text:00004E0A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004E0F                 mov     byte ptr [ebp+var_4], 2
.text:00004E13                 lea     ecx, [ebp+var_144]
.text:00004E19                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004E1E                 mov     byte ptr [ebp+var_4], 0
.text:00004E22                 lea     ecx, [ebp+var_4C] ; this
.text:00004E25                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004E2A                 mov     eax, [ebp+var_4F0]
.text:00004E30                 jmp     loc_4F97
.text:00004E35 ; ---------------------------------------------------------------------------
.text:00004E35
.text:00004E35 loc_4E35:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3179j
.text:00004E35                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+31D0j
.text:00004E35                 lea     edx, [ebp+var_3B0]
.text:00004E3B                 push    edx
.text:00004E3C                 mov     ecx, [ebp+this]
.text:00004E3F                 add     ecx, 100h
.text:00004E45                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z ; CMyComPtr<ISequentialOutStream>::operator=(CMyComPtr<ISequentialOutStream> const &)
.text:00004E4A                 mov     byte ptr [ebp+var_4], 12h
.text:00004E4E                 lea     ecx, [ebp+var_3B0]
.text:00004E54                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004E59
.text:00004E59 loc_4E59:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2598j
.text:00004E59                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2C27j ...
.text:00004E59                 mov     eax, [ebp+this]
.text:00004E5C                 add     eax, 100h
.text:00004E61                 push    eax
.text:00004E62                 lea     ecx, [ebp+var_144]
.text:00004E68                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z ; CMyComPtr<ISequentialOutStream>::operator=(CMyComPtr<ISequentialOutStream> const &)
.text:00004E6D                 mov     byte ptr [ebp+var_4], 10h
.text:00004E71                 lea     ecx, [ebp+var_1D4] ; this
.text:00004E77                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004E7C                 mov     byte ptr [ebp+var_4], 0Ch
.text:00004E80                 lea     ecx, [ebp+var_1AC] ; this
.text:00004E86                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004E8B
.text:00004E8B loc_4E8B:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+F92j
.text:00004E8B                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+FA4j ...
.text:00004E8B                 mov     ecx, [ebp+this]
.text:00004E8E                 add     ecx, 108h
.text:00004E94                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00004E99                 mov     [ebp+var_800], eax
.text:00004E9F                 cmp     [ebp+var_800], 0
.text:00004EA6                 jz      short loc_4F08
.text:00004EA8                 cmp     [ebp+arg_C], 0
.text:00004EAC                 jz      short loc_4EB4
.text:00004EAE                 cmp     [ebp+arg_C], 1
.text:00004EB2                 jnz     short loc_4F08
.text:00004EB4
.text:00004EB4 loc_4EB4:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+32A8j
.text:00004EB4                 lea     ecx, [ebp+var_144]
.text:00004EBA                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00004EBF                 mov     [ebp+var_804], eax
.text:00004EC5                 mov     ecx, [ebp+var_804]
.text:00004ECB                 push    ecx             ; struct ISequentialOutStream *
.text:00004ECC                 mov     edx, [ebp+this]
.text:00004ECF                 mov     ecx, [edx+104h] ; this
.text:00004ED5                 call    ?SetStream@COutStreamWithHash@@QAEXPAUISequentialOutStream@@@Z ; COutStreamWithHash::SetStream(ISequentialOutStream *)
.text:00004EDA                 mov     eax, [ebp+this]
.text:00004EDD                 add     eax, 108h
.text:00004EE2                 push    eax
.text:00004EE3                 lea     ecx, [ebp+var_144]
.text:00004EE9                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z ; CMyComPtr<ISequentialOutStream>::operator=(CMyComPtr<ISequentialOutStream> const &)
.text:00004EEE                 push    1               ; bool
.text:00004EF0                 mov     ecx, [ebp+this]
.text:00004EF3                 mov     ecx, [ecx+104h] ; this
.text:00004EF9                 call    ?Init@COutStreamWithHash@@QAEX_N@Z ; COutStreamWithHash::Init(bool)
.text:00004EFE                 mov     edx, [ebp+this]
.text:00004F01                 mov     byte ptr [edx+10Ch], 1
.text:00004F08
.text:00004F08 loc_4F08:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+32A2j
.text:00004F08                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+32AEj
.text:00004F08                 lea     ecx, [ebp+var_144]
.text:00004F0E                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00004F13                 mov     [ebp+var_808], eax
.text:00004F19                 cmp     [ebp+var_808], 0
.text:00004F20                 jz      short loc_4F3E
.text:00004F22                 lea     ecx, [ebp+var_144]
.text:00004F28                 call    ?Detach@?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::Detach(void)
.text:00004F2D                 mov     [ebp+var_80C], eax
.text:00004F33                 mov     eax, [ebp+arg_8]
.text:00004F36                 mov     ecx, [ebp+var_80C]
.text:00004F3C                 mov     [eax], ecx
.text:00004F3E
.text:00004F3E loc_4F3E:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+331Cj
.text:00004F3E                 mov     [ebp+var_4F4], 0
.text:00004F48                 mov     byte ptr [ebp+var_4], 2
.text:00004F4C                 lea     ecx, [ebp+var_144]
.text:00004F52                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004F57                 mov     byte ptr [ebp+var_4], 0
.text:00004F5B                 lea     ecx, [ebp+var_4C] ; this
.text:00004F5E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004F63                 mov     eax, [ebp+var_4F4]
.text:00004F69                 jmp     short loc_4F97
.text:00004F69 ?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z endp ; sp-analysis failed
.text:00004F69
.text:00004F6B
.text:00004F6B ; =============== S U B R O U T I N E =======================================
.text:00004F6B
.text:00004F6B
.text:00004F6B __catch$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$0 proc near
.text:00004F6B                                         ; DATA XREF: .xdata$x:00006E68o
.text:00004F6B                 mov     dword ptr [ebp-4F8h], 8007000Eh
.text:00004F75                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00004F7C                 mov     eax, offset $LN249
.text:00004F81                 retn
.text:00004F81 __catch$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$0 endp
.text:00004F81
.text:00004F82 ; ---------------------------------------------------------------------------
.text:00004F82                 mov     eax, offset __tryend$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$1
.text:00004F87                 retn
.text:00004F88 ; ---------------------------------------------------------------------------
.text:00004F88
.text:00004F88 __tryend$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$1:
.text:00004F88                                         ; DATA XREF: .text:00004F82o
.text:00004F88                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00004F8F                 jmp     short loc_4F97
.text:00004F91 ; ---------------------------------------------------------------------------
.text:00004F91
.text:00004F91 $LN249:                                 ; DATA XREF: __catch$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$0+11o
.text:00004F91                 mov     eax, [ebp-4F8h]
.text:00004F97 ; START OF FUNCTION CHUNK FOR ?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z
.text:00004F97
.text:00004F97 loc_4F97:                               ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+197j
.text:00004F97                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1FFj ...
.text:00004F97                 push    edx
.text:00004F98                 mov     ecx, ebp
.text:00004F9A                 push    eax
.text:00004F9B                 lea     edx, $LN287
.text:00004FA1                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00004FA6                 pop     eax
.text:00004FA7                 pop     edx
.text:00004FA8                 mov     ecx, [ebp+var_C]
.text:00004FAB                 mov     large fs:0, ecx
.text:00004FB2                 pop     ecx
.text:00004FB3                 pop     edi
.text:00004FB4                 pop     esi
.text:00004FB5                 pop     ebx
.text:00004FB6                 mov     ecx, [ebp+var_14]
.text:00004FB9                 xor     ecx, ebp
.text:00004FBB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00004FC0                 add     esp, 80Ch
.text:00004FC6                 cmp     ebp, esp
.text:00004FC8                 call    __RTC_CheckEsp
.text:00004FCD                 mov     esp, ebp
.text:00004FCF                 pop     ebp
.text:00004FD0                 retn    10h
.text:00004FD0 ; END OF FUNCTION CHUNK FOR ?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z
.text:00004FD0 ; ---------------------------------------------------------------------------
.text:00004FD3                 align 4
.text:00004FD4 $LN287          dd offset $SG76080+22h  ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3397o
.text:00004FD4                                         ; ""
.text:00004FD8                 dd offset $LN286
.text:00004FDC $LN286          dd 0FFFFFFD0h, 10h      ; DATA XREF: .text:00004FD8o
.text:00004FE4                 dd offset $LN251        ; "prop"
.text:00004FE8                 dd 0FFFFFFB4h, 0Ch
.text:00004FF0                 dd offset $LN252        ; "linkPath"
.text:00004FF4                 dd 0FFFFFF9Ch, 10h
.text:00004FFC                 dd offset $LN253        ; "prop"
.text:00005000                 dd 0FFFFFF80h, 10h
.text:00005008                 dd offset $LN254        ; "prop"
.text:0000500C                 dd 0FFFFFF6Ch, 4
.text:00005014                 dd offset $LN255        ; "data"
.text:00005018                 dd 0FFFFFF60h, 4
.text:00005020                 dd offset $LN256        ; "dataSize"
.text:00005024                 dd 0FFFFFF54h, 4
.text:0000502C                 dd offset $LN257        ; "propType"
.text:00005030                 dd 0FFFFFF40h, 0Ch
.text:00005038                 dd offset $LN258        ; "s"
.text:0000503C                 dd 0FFFFFF18h, 20h
.text:00005044                 dd offset $LN259        ; "reparse"
.text:00005048                 dd 0FFFFFF00h, 0Ch
.text:00005050                 dd offset $LN260        ; "pathParts"
.text:00005054                 dd 0FFFFFEC8h, 0Ch
.text:0000505C                 dd offset $LN261        ; "name"
.text:00005060                 dd 0FFFFFEBCh, 4
.text:00005068                 dd offset $LN262        ; "outStreamLoc"
.text:0000506C                 dd 0FFFFFEA4h, 10h
.text:00005074                 dd offset $LN263        ; "prop"
.text:00005078                 dd 0FFFFFE8Bh, 1
.text:00005080                 dd offset $LN264        ; "isAnti"
.text:00005084                 dd 0FFFFFE70h, 0Ch
.text:0000508C                 dd offset $LN265        ; "s"
.text:00005090                 dd 0FFFFFE54h, 0Ch
.text:00005098                 dd offset $LN266        ; "processedPath"
.text:0000509C                 dd 0FFFFFE40h, 0Ch
.text:000050A4                 dd offset $LN267        ; "fullPathNew"
.text:000050A8                 dd 0FFFFFE2Ch, 0Ch
.text:000050B0                 dd offset $LN268        ; "fullProcessedPath"
.text:000050B4                 dd 0FFFFFE14h, 10h
.text:000050BC                 dd offset $LN269        ; "pair"
.text:000050C0                 dd 0FFFFFDF8h, 0Ch
.text:000050C8                 dd offset $LN270        ; "s"
.text:000050CC                 dd 0FFFFFDB4h, 38h
.text:000050D4                 dd offset $LN271        ; "fileInfo"
.text:000050D8                 dd 0FFFFFD9Ch, 0Ch
.text:000050E0                 dd offset $LN272        ; "realFullProcessedPath"
.text:000050E4                 db 90h
.text:000050E5                 db 0FDh, 2 dup(0FFh)
.text:000050E8                 dd 4
.text:000050EC                 dd offset $LN273        ; "overwriteResult"
.text:000050F0                 dd 0FFFFFD74h, 0Ch
.text:000050F8                 dd offset $LN274        ; "existPath"
.text:000050FC                 dd 0FFFFFD48h, 0Ch
.text:00005104                 dd offset $LN275        ; "parentFsPath"
.text:00005108                 dd 0FFFFFD08h, 38h
.text:00005110                 dd offset $LN276        ; "parentFi"
.text:00005114                 dd 0FFFFFCF4h, 0Ch
.text:0000511C                 dd offset $LN277        ; "relatPath"
.text:00005120                 dd 0FFFFFCDCh, 0Ch
.text:00005128                 dd offset $LN278        ; "existPath"
.text:0000512C                 dd 0FFFFFCC4h, 8
.text:00005134                 dd offset $LN279        ; "data"
.text:00005138                 dd 0FFFFFC9Ch, 20h
.text:00005140                 dd offset $LN280        ; "attr"
.text:00005144                 dd 0FFFFFC78h, 10h
.text:0000514C                 dd offset $LN281        ; "h"
.text:00005150                 dd 0FFFFFC6Fh, 1
.text:00005158                 dd offset $LN282        ; "defined"
.text:0000515C                 dd 0FFFFFC50h, 4
.text:00005164                 dd offset $LN283        ; "outStreamLoc"
.text:00005168                 dd 0FFFFFC34h, 10h
.text:00005170                 dd offset $LN284        ; "pair"
.text:00005174 $LN284          db 'pair',0             ; DATA XREF: .text:00005170o
.text:00005179 $LN283          db 'outStreamLoc',0     ; DATA XREF: .text:00005164o
.text:00005186 $LN282          db 'defined',0          ; DATA XREF: .text:00005158o
.text:0000518E $LN281          db 'h',0                ; DATA XREF: .text:0000514Co
.text:00005190 $LN280          db 'attr',0             ; DATA XREF: .text:00005140o
.text:00005195 $LN279          db 'data',0             ; DATA XREF: .text:00005134o
.text:0000519A $LN278          db 'existPath',0        ; DATA XREF: .text:00005128o
.text:000051A4 $LN277          db 'relatPath',0        ; DATA XREF: .text:0000511Co
.text:000051AE $LN276          db 'parentFi',0         ; DATA XREF: .text:00005110o
.text:000051B7 $LN275          db 'parentFsPath',0     ; DATA XREF: .text:00005104o
.text:000051C4 $LN274          db 'existPath',0        ; DATA XREF: .text:000050F8o
.text:000051CE $LN273          db 'overwriteResult',0  ; DATA XREF: .text:000050ECo
.text:000051DE $LN272          db 'realFullProcessedPath',0 ; DATA XREF: .text:000050E0o
.text:000051F4 $LN271          db 'fileInfo',0         ; DATA XREF: .text:000050D4o
.text:000051FD $LN270          db 's',0                ; DATA XREF: .text:000050C8o
.text:000051FF $LN269          db 'pair',0             ; DATA XREF: .text:000050BCo
.text:00005204 $LN268          db 'fullProcessedPath',0 ; DATA XREF: .text:000050B0o
.text:00005216 $LN267          db 'fullPathNew',0      ; DATA XREF: .text:000050A4o
.text:00005222 $LN266          db 'processedPath',0    ; DATA XREF: .text:00005098o
.text:00005230 $LN265          db 's',0                ; DATA XREF: .text:0000508Co
.text:00005232 $LN264          db 'isAnti',0           ; DATA XREF: .text:00005080o
.text:00005239 $LN263          db 'prop',0             ; DATA XREF: .text:00005074o
.text:0000523E $LN262          db 'outStreamLoc',0     ; DATA XREF: .text:00005068o
.text:0000524B $LN261          db 'name',0             ; DATA XREF: .text:0000505Co
.text:00005250 $LN260          db 'pathParts',0        ; DATA XREF: .text:00005050o
.text:0000525A $LN259          db 'reparse',0          ; DATA XREF: .text:00005044o
.text:00005262 $LN258          db 's',0                ; DATA XREF: .text:00005038o
.text:00005264 $LN257          db 'propType',0         ; DATA XREF: .text:0000502Co
.text:0000526D $LN256          db 'dataSize',0         ; DATA XREF: .text:00005020o
.text:00005276 $LN255          db 'data',0             ; DATA XREF: .text:00005014o
.text:0000527B $LN254          db 'prop',0             ; DATA XREF: .text:00005008o
.text:00005280 $LN253          db 'prop',0             ; DATA XREF: .text:00004FFCo
.text:00005285 $LN252          db 'linkPath',0         ; DATA XREF: .text:00004FF0o
.text:0000528E $LN251          db 'prop',0             ; DATA XREF: .text:00004FE4o
.text:00005293                 align 4
.text:00005294 $LN288          dd offset $LN138        ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+A86r
.text:00005294                 dd offset $LN138        ; jump table for switch statement
.text:00005294                 dd offset $LN121
.text:00005294                 dd offset $LN139
.text:00005294                 dd offset $LN119
.text:000052A8 $LN289          dd offset $LN69         ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1BD8r
.text:000052A8                 dd offset $LN68         ; jump table for switch statement
.text:000052A8                 dd offset $LN71
.text:000052A8                 dd offset $LN70
.text:000052A8                 dd offset $LN67
.text:000052A8                 dd offset $LN72
.text:000052C0                 db 4 dup(0CCh)
.text:000052C4
.text:000052C4 ; =============== S U B R O U T I N E =======================================
.text:000052C4
.text:000052C4 ; Attributes: bp-based frame
.text:000052C4
.text:000052C4 ; class UString __stdcall GetDirPrefixOf(class UString const &)
.text:000052C4 ?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z proc near
.text:000052C4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+25E6p
.text:000052C4
.text:000052C4 var_28          = dword ptr -28h
.text:000052C4 var_24          = dword ptr -24h
.text:000052C4 var_20          = dword ptr -20h
.text:000052C4 var_1C          = dword ptr -1Ch
.text:000052C4 var_18          = dword ptr -18h
.text:000052C4 var_14          = dword ptr -14h
.text:000052C4 var_10          = dword ptr -10h
.text:000052C4 var_C           = dword ptr -0Ch
.text:000052C4 var_4           = dword ptr -4
.text:000052C4 arg_0           = dword ptr  8
.text:000052C4 arg_4           = dword ptr  0Ch
.text:000052C4
.text:000052C4                 push    ebp
.text:000052C5                 mov     ebp, esp
.text:000052C7                 push    0FFFFFFFFh
.text:000052C9                 push    offset __ehhandler$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z
.text:000052CE                 mov     eax, large fs:0
.text:000052D4                 push    eax
.text:000052D5                 sub     esp, 1Ch
.text:000052D8                 mov     eax, 0CCCCCCCCh
.text:000052DD                 mov     [ebp+var_28], eax
.text:000052E0                 mov     [ebp+var_24], eax
.text:000052E3                 mov     [ebp+var_20], eax
.text:000052E6                 mov     [ebp+var_1C], eax
.text:000052E9                 mov     [ebp+var_18], eax
.text:000052EC                 mov     [ebp+var_14], eax
.text:000052EF                 mov     [ebp+var_10], eax
.text:000052F2                 mov     eax, dword ptr ds:___security_cookie
.text:000052F7                 xor     eax, ebp
.text:000052F9                 push    eax
.text:000052FA                 lea     eax, [ebp+var_C]
.text:000052FD                 mov     large fs:0, eax
.text:00005303                 mov     [ebp+var_28], 0
.text:0000530A                 mov     eax, [ebp+arg_4]
.text:0000530D                 push    eax
.text:0000530E                 lea     ecx, [ebp+var_1C]
.text:00005311                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00005316                 mov     [ebp+var_4], 1
.text:0000531D                 lea     ecx, [ebp+var_1C] ; this
.text:00005320                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00005325                 movzx   ecx, al
.text:00005328                 test    ecx, ecx
.text:0000532A                 jnz     short loc_5366
.text:0000532C                 lea     ecx, [ebp+var_1C] ; this
.text:0000532F                 call    ?Back@UString@@QBE_WXZ ; UString::Back(void)
.text:00005334                 movzx   edx, ax
.text:00005337                 push    edx             ; wchar_t
.text:00005338                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:0000533D                 movzx   eax, al
.text:00005340                 test    eax, eax
.text:00005342                 jz      short loc_534C
.text:00005344                 lea     ecx, [ebp+var_1C] ; this
.text:00005347                 call    ?DeleteBack@UString@@QAEXXZ ; UString::DeleteBack(void)
.text:0000534C
.text:0000534C loc_534C:                               ; CODE XREF: GetDirPrefixOf(UString const &)+7Ej
.text:0000534C                 lea     ecx, [ebp+var_1C] ; this
.text:0000534F                 call    ?ReverseFind_PathSepar@UString@@QBEHXZ ; UString::ReverseFind_PathSepar(void)
.text:00005354                 mov     [ebp+var_24], eax
.text:00005357                 mov     ecx, [ebp+var_24]
.text:0000535A                 add     ecx, 1
.text:0000535D                 push    ecx             ; unsigned int
.text:0000535E                 lea     ecx, [ebp+var_1C] ; this
.text:00005361                 call    ?DeleteFrom@UString@@QAEXI@Z ; UString::DeleteFrom(uint)
.text:00005366
.text:00005366 loc_5366:                               ; CODE XREF: GetDirPrefixOf(UString const &)+66j
.text:00005366                 lea     edx, [ebp+var_1C]
.text:00005369                 push    edx
.text:0000536A                 mov     ecx, [ebp+arg_0]
.text:0000536D                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00005372                 mov     eax, [ebp+var_28]
.text:00005375                 or      eax, 1
.text:00005378                 mov     [ebp+var_28], eax
.text:0000537B                 mov     byte ptr [ebp+var_4], 0
.text:0000537F                 lea     ecx, [ebp+var_1C] ; this
.text:00005382                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00005387                 mov     eax, [ebp+arg_0]
.text:0000538A                 push    edx
.text:0000538B                 mov     ecx, ebp
.text:0000538D                 push    eax
.text:0000538E                 lea     edx, $LN11_3
.text:00005394                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00005399                 pop     eax
.text:0000539A                 pop     edx
.text:0000539B                 mov     ecx, [ebp+var_C]
.text:0000539E                 mov     large fs:0, ecx
.text:000053A5                 pop     ecx
.text:000053A6                 add     esp, 28h
.text:000053A9                 cmp     ebp, esp
.text:000053AB                 call    __RTC_CheckEsp
.text:000053B0                 mov     esp, ebp
.text:000053B2                 pop     ebp
.text:000053B3                 retn    8
.text:000053B3 ?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z endp
.text:000053B3
.text:000053B3 ; ---------------------------------------------------------------------------
.text:000053B6                 align 4
.text:000053B8 $LN11_3         dd 1                    ; DATA XREF: GetDirPrefixOf(UString const &)+CAo
.text:000053BC                 dd offset $LN10_3
.text:000053C0 $LN10_3         dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:000053BCo
.text:000053C8                 dd offset $LN8_4
.text:000053CC $LN8_4          dd 0CCCC0073h, 0CCCCCCCCh ; DATA XREF: .text:000053C8o
.text:000053D4
.text:000053D4 ; =============== S U B R O U T I N E =======================================
.text:000053D4
.text:000053D4 ; Attributes: bp-based frame
.text:000053D4
.text:000053D4 ; bool __stdcall IsSafePath(class UString const &)
.text:000053D4 ?IsSafePath@@YG_NABVUString@@@Z proc near
.text:000053D4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2638p
.text:000053D4
.text:000053D4 var_30          = dword ptr -30h
.text:000053D4 var_2C          = dword ptr -2Ch
.text:000053D4 var_28          = dword ptr -28h
.text:000053D4 var_24          = dword ptr -24h
.text:000053D4 var_20          = dword ptr -20h
.text:000053D4 var_1C          = dword ptr -1Ch
.text:000053D4 var_18          = dword ptr -18h
.text:000053D4 var_14          = dword ptr -14h
.text:000053D4 var_10          = dword ptr -10h
.text:000053D4 var_C           = dword ptr -0Ch
.text:000053D4 var_4           = dword ptr -4
.text:000053D4 arg_0           = dword ptr  8
.text:000053D4
.text:000053D4                 push    ebp
.text:000053D5                 mov     ebp, esp
.text:000053D7                 push    0FFFFFFFFh
.text:000053D9                 push    offset __ehhandler$?IsSafePath@@YG_NABVUString@@@Z
.text:000053DE                 mov     eax, large fs:0
.text:000053E4                 push    eax
.text:000053E5                 sub     esp, 24h
.text:000053E8                 mov     eax, 0CCCCCCCCh
.text:000053ED                 mov     [ebp+var_30], eax
.text:000053F0                 mov     [ebp+var_2C], eax
.text:000053F3                 mov     [ebp+var_28], eax
.text:000053F6                 mov     [ebp+var_24], eax
.text:000053F9                 mov     [ebp+var_20], eax
.text:000053FC                 mov     [ebp+var_1C], eax
.text:000053FF                 mov     [ebp+var_18], eax
.text:00005402                 mov     [ebp+var_14], eax
.text:00005405                 mov     [ebp+var_10], eax
.text:00005408                 mov     eax, dword ptr ds:___security_cookie
.text:0000540D                 xor     eax, ebp
.text:0000540F                 push    eax
.text:00005410                 lea     eax, [ebp+var_C]
.text:00005413                 mov     large fs:0, eax
.text:00005419                 lea     ecx, [ebp+var_1C]
.text:0000541C                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00005421                 mov     [ebp+var_4], 0
.text:00005428                 lea     eax, [ebp+var_1C]
.text:0000542B                 push    eax
.text:0000542C                 mov     ecx, [ebp+arg_0]
.text:0000542F                 push    ecx
.text:00005430                 call    ?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z ; SplitPathToParts(UString const &,CObjectVector<UString> &)
.text:00005435                 mov     [ebp+var_24], 0
.text:0000543C                 mov     [ebp+var_28], 0
.text:00005443                 jmp     short loc_544E
.text:00005445 ; ---------------------------------------------------------------------------
.text:00005445
.text:00005445 loc_5445:                               ; CODE XREF: IsSafePath(UString const &)+A9j
.text:00005445                                         ; IsSafePath(UString const &)+C0j ...
.text:00005445                 mov     edx, [ebp+var_28]
.text:00005448                 add     edx, 1
.text:0000544B                 mov     [ebp+var_28], edx
.text:0000544E
.text:0000544E loc_544E:                               ; CODE XREF: IsSafePath(UString const &)+6Fj
.text:0000544E                 lea     ecx, [ebp+var_1C]
.text:00005451                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00005456                 cmp     [ebp+var_28], eax
.text:00005459                 jnb     loc_54E2
.text:0000545F                 mov     eax, [ebp+var_28]
.text:00005462                 push    eax
.text:00005463                 lea     ecx, [ebp+var_1C]
.text:00005466                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000546B                 mov     [ebp+var_2C], eax
.text:0000546E                 mov     ecx, [ebp+var_2C] ; this
.text:00005471                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00005476                 movzx   ecx, al
.text:00005479                 test    ecx, ecx
.text:0000547B                 jz      short loc_547F
.text:0000547D                 jmp     short loc_5445
.text:0000547F ; ---------------------------------------------------------------------------
.text:0000547F
.text:0000547F loc_547F:                               ; CODE XREF: IsSafePath(UString const &)+A7j
.text:0000547F                 push    offset $SG76377 ; Str2
.text:00005484                 mov     edx, [ebp+var_2C]
.text:00005487                 push    edx             ; int
.text:00005488                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:0000548D                 movzx   eax, al
.text:00005490                 test    eax, eax
.text:00005492                 jz      short loc_5496
.text:00005494                 jmp     short loc_5445
.text:00005496 ; ---------------------------------------------------------------------------
.text:00005496
.text:00005496 loc_5496:                               ; CODE XREF: IsSafePath(UString const &)+BEj
.text:00005496                 push    offset $SG76379 ; ".."
.text:0000549B                 mov     ecx, [ebp+var_2C]
.text:0000549E                 push    ecx             ; int
.text:0000549F                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:000054A4                 movzx   edx, al
.text:000054A7                 test    edx, edx
.text:000054A9                 jz      short loc_54D4
.text:000054AB                 cmp     [ebp+var_24], 0
.text:000054AF                 jg      short loc_54C9
.text:000054B1                 mov     byte ptr [ebp+var_30+3], 0
.text:000054B5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000054BC                 lea     ecx, [ebp+var_1C]
.text:000054BF                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000054C4                 mov     al, byte ptr [ebp+var_30+3]
.text:000054C7                 jmp     short loc_5500
.text:000054C9 ; ---------------------------------------------------------------------------
.text:000054C9
.text:000054C9 loc_54C9:                               ; CODE XREF: IsSafePath(UString const &)+DBj
.text:000054C9                 mov     eax, [ebp+var_24]
.text:000054CC                 sub     eax, 1
.text:000054CF                 mov     [ebp+var_24], eax
.text:000054D2                 jmp     short loc_54DD
.text:000054D4 ; ---------------------------------------------------------------------------
.text:000054D4
.text:000054D4 loc_54D4:                               ; CODE XREF: IsSafePath(UString const &)+D5j
.text:000054D4                 mov     ecx, [ebp+var_24]
.text:000054D7                 add     ecx, 1
.text:000054DA                 mov     [ebp+var_24], ecx
.text:000054DD
.text:000054DD loc_54DD:                               ; CODE XREF: IsSafePath(UString const &)+FEj
.text:000054DD                 jmp     loc_5445
.text:000054E2 ; ---------------------------------------------------------------------------
.text:000054E2
.text:000054E2 loc_54E2:                               ; CODE XREF: IsSafePath(UString const &)+85j
.text:000054E2                 xor     edx, edx
.text:000054E4                 cmp     [ebp+var_24], 0
.text:000054E8                 setnle  dl
.text:000054EB                 mov     byte ptr [ebp+var_30+2], dl
.text:000054EE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000054F5                 lea     ecx, [ebp+var_1C]
.text:000054F8                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000054FD                 mov     al, byte ptr [ebp+var_30+2]
.text:00005500
.text:00005500 loc_5500:                               ; CODE XREF: IsSafePath(UString const &)+F3j
.text:00005500                 push    edx
.text:00005501                 mov     ecx, ebp
.text:00005503                 push    eax
.text:00005504                 lea     edx, $LN15_0
.text:0000550A                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000550F                 pop     eax
.text:00005510                 pop     edx
.text:00005511                 mov     ecx, [ebp+var_C]
.text:00005514                 mov     large fs:0, ecx
.text:0000551B                 pop     ecx
.text:0000551C                 add     esp, 30h
.text:0000551F                 cmp     ebp, esp
.text:00005521                 call    __RTC_CheckEsp
.text:00005526                 mov     esp, ebp
.text:00005528                 pop     ebp
.text:00005529                 retn    4
.text:00005529 ?IsSafePath@@YG_NABVUString@@@Z endp
.text:00005529
.text:00005529 ; ---------------------------------------------------------------------------
.text:0000552C $LN15_0         dd 1                    ; DATA XREF: IsSafePath(UString const &)+130o
.text:00005530                 dd offset $LN14_1
.text:00005534 $LN14_1         dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:00005530o
.text:0000553C                 dd offset $LN12_3       ; "parts"
.text:00005540 $LN12_3         db 'parts',0            ; DATA XREF: .text:0000553Co
.text:00005546                 db 0Eh dup(0CCh)
.text:00005554
.text:00005554 ; =============== S U B R O U T I N E =======================================
.text:00005554
.text:00005554 ; Attributes: bp-based frame
.text:00005554
.text:00005554 ; int __stdcall MakePath_from_2_Parts(int, UString *, UString *)
.text:00005554 ?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z proc near
.text:00005554                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+16E8p
.text:00005554
.text:00005554 var_24          = dword ptr -24h
.text:00005554 var_20          = dword ptr -20h
.text:00005554 var_1C          = dword ptr -1Ch
.text:00005554 var_18          = dword ptr -18h
.text:00005554 var_14          = dword ptr -14h
.text:00005554 var_10          = dword ptr -10h
.text:00005554 var_C           = dword ptr -0Ch
.text:00005554 var_4           = dword ptr -4
.text:00005554 arg_0           = dword ptr  8
.text:00005554 arg_4           = dword ptr  0Ch
.text:00005554 arg_8           = dword ptr  10h
.text:00005554
.text:00005554                 push    ebp
.text:00005555                 mov     ebp, esp
.text:00005557                 push    0FFFFFFFFh
.text:00005559                 push    offset __ehhandler$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z
.text:0000555E                 mov     eax, large fs:0
.text:00005564                 push    eax
.text:00005565                 sub     esp, 18h
.text:00005568                 mov     eax, 0CCCCCCCCh
.text:0000556D                 mov     [ebp+var_24], eax
.text:00005570                 mov     [ebp+var_20], eax
.text:00005573                 mov     [ebp+var_1C], eax
.text:00005576                 mov     [ebp+var_18], eax
.text:00005579                 mov     [ebp+var_14], eax
.text:0000557C                 mov     [ebp+var_10], eax
.text:0000557F                 mov     eax, dword ptr ds:___security_cookie
.text:00005584                 xor     eax, ebp
.text:00005586                 push    eax             ; wchar_t *
.text:00005587                 lea     eax, [ebp+var_C]
.text:0000558A                 mov     large fs:0, eax
.text:00005590                 mov     [ebp+var_24], 0
.text:00005597                 mov     eax, [ebp+arg_4]
.text:0000559A                 push    eax
.text:0000559B                 lea     ecx, [ebp+var_1C]
.text:0000559E                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000055A3                 mov     [ebp+var_4], 1
.text:000055AA                 mov     ecx, [ebp+arg_8] ; this
.text:000055AD                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000055B2                 movzx   ecx, al
.text:000055B5                 test    ecx, ecx
.text:000055B7                 jnz     short loc_560D
.text:000055B9                 mov     ecx, [ebp+arg_8]
.text:000055BC                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000055C1                 movzx   edx, word ptr [eax]
.text:000055C4                 cmp     edx, 3Ah ; ':'
.text:000055C7                 jnz     short loc_560D
.text:000055C9                 mov     ecx, [ebp+arg_4] ; this
.text:000055CC                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000055D1                 movzx   eax, al
.text:000055D4                 test    eax, eax
.text:000055D6                 jnz     short loc_560D
.text:000055D8                 mov     ecx, [ebp+arg_4] ; this
.text:000055DB                 call    ?Back@UString@@QBE_WXZ ; UString::Back(void)
.text:000055E0                 movzx   ecx, ax
.text:000055E3                 push    ecx             ; wchar_t
.text:000055E4                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:000055E9                 movzx   edx, al
.text:000055EC                 test    edx, edx
.text:000055EE                 jz      short loc_560D
.text:000055F0                 mov     ecx, [ebp+arg_4]
.text:000055F3                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000055F8                 push    eax             ; this
.text:000055F9                 call    ?IsDriveRootPath_SuperAllowed@NName@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NName::IsDriveRootPath_SuperAllowed(wchar_t const *)
.text:000055FE                 movzx   eax, al
.text:00005601                 test    eax, eax
.text:00005603                 jnz     short loc_560D
.text:00005605                 lea     ecx, [ebp+var_1C] ; this
.text:00005608                 call    ?DeleteBack@UString@@QAEXXZ ; UString::DeleteBack(void)
.text:0000560D
.text:0000560D loc_560D:                               ; CODE XREF: MakePath_from_2_Parts(UString const &,UString const &)+63j
.text:0000560D                                         ; MakePath_from_2_Parts(UString const &,UString const &)+73j ...
.text:0000560D                 mov     ecx, [ebp+arg_8]
.text:00005610                 push    ecx
.text:00005611                 lea     ecx, [ebp+var_1C]
.text:00005614                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00005619                 lea     edx, [ebp+var_1C]
.text:0000561C                 push    edx
.text:0000561D                 mov     ecx, [ebp+arg_0]
.text:00005620                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00005625                 mov     eax, [ebp+var_24]
.text:00005628                 or      eax, 1
.text:0000562B                 mov     [ebp+var_24], eax
.text:0000562E                 mov     byte ptr [ebp+var_4], 0
.text:00005632                 lea     ecx, [ebp+var_1C] ; this
.text:00005635                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000563A                 mov     eax, [ebp+arg_0]
.text:0000563D                 push    edx
.text:0000563E                 mov     ecx, ebp
.text:00005640                 push    eax
.text:00005641                 lea     edx, $LN11_4
.text:00005647                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000564C                 pop     eax
.text:0000564D                 pop     edx
.text:0000564E                 mov     ecx, [ebp+var_C]
.text:00005651                 mov     large fs:0, ecx
.text:00005658                 pop     ecx
.text:00005659                 add     esp, 24h
.text:0000565C                 cmp     ebp, esp
.text:0000565E                 call    __RTC_CheckEsp
.text:00005663                 mov     esp, ebp
.text:00005665                 pop     ebp
.text:00005666                 retn    0Ch
.text:00005666 ?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z endp ; sp-analysis failed
.text:00005666
.text:00005666 ; ---------------------------------------------------------------------------
.text:00005669                 align 4
.text:0000566C $LN11_4         dd 1                    ; DATA XREF: MakePath_from_2_Parts(UString const &,UString const &)+EDo
.text:00005670                 dd offset $LN10_4
.text:00005674 $LN10_4         dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:00005670o
.text:0000567C                 dd offset $LN8_5
.text:00005680 $LN8_5          dd 0CCCC0073h           ; DATA XREF: .text:0000567Co
.text:00005684
.text:00005684 ; =============== S U B R O U T I N E =======================================
.text:00005684
.text:00005684 ; Attributes: bp-based frame
.text:00005684
.text:00005684 ; __int32 __cdecl CArchiveExtractCallback::PrepareOperation(CArchiveExtractCallback *this, int)
.text:00005684                 public ?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z
.text:00005684 ?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z proc near
.text:00005684                                         ; DATA XREF: .rdata:000075BCo
.text:00005684
.text:00005684 var_40          = dword ptr -40h
.text:00005684 var_3C          = dword ptr -3Ch
.text:00005684 var_38          = dword ptr -38h
.text:00005684 var_34          = dword ptr -34h
.text:00005684 var_30          = dword ptr -30h
.text:00005684 var_2C          = dword ptr -2Ch
.text:00005684 var_28          = dword ptr -28h
.text:00005684 var_24          = dword ptr -24h
.text:00005684 var_20          = dword ptr -20h
.text:00005684 var_1C          = dword ptr -1Ch
.text:00005684 var_18          = dword ptr -18h
.text:00005684 var_10          = dword ptr -10h
.text:00005684 var_C           = dword ptr -0Ch
.text:00005684 var_4           = dword ptr -4
.text:00005684 this            = dword ptr  8
.text:00005684 arg_4           = dword ptr  0Ch
.text:00005684
.text:00005684 ; FUNCTION CHUNK AT .text:000057FA SIZE 0000001E BYTES
.text:00005684
.text:00005684                 push    ebp
.text:00005685                 mov     ebp, esp
.text:00005687                 push    0FFFFFFFFh
.text:00005689                 push    offset __ehhandler$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z
.text:0000568E                 mov     eax, large fs:0
.text:00005694                 push    eax
.text:00005695                 push    ecx
.text:00005696                 sub     esp, 30h
.text:00005699                 push    ebx
.text:0000569A                 push    esi
.text:0000569B                 push    edi
.text:0000569C                 lea     edi, [ebp+var_40]
.text:0000569F                 mov     ecx, 0Ch
.text:000056A4                 mov     eax, 0CCCCCCCCh
.text:000056A9                 rep stosd
.text:000056AB                 mov     eax, dword ptr ds:___security_cookie
.text:000056B0                 xor     eax, ebp
.text:000056B2                 push    eax
.text:000056B3                 lea     eax, [ebp+var_C]
.text:000056B6                 mov     large fs:0, eax
.text:000056BC                 mov     [ebp+var_10], esp
.text:000056BF                 mov     [ebp+var_4], 0
.text:000056C6                 mov     ecx, [ebp+this]
.text:000056C9                 add     ecx, 5Ch ; '\'
.text:000056CC                 call    ??B?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::operator IFolderExtractToStreamCallback *(void)
.text:000056D1                 mov     [ebp+var_18], eax
.text:000056D4                 cmp     [ebp+var_18], 0
.text:000056D8                 jz      short loc_5714
.text:000056DA                 mov     ecx, [ebp+this]
.text:000056DD                 add     ecx, 5Ch ; '\'
.text:000056E0                 call    ??C?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::operator->(void)
.text:000056E5                 mov     [ebp+var_1C], eax
.text:000056E8                 mov     eax, [ebp+var_1C]
.text:000056EB                 mov     [ebp+var_20], eax
.text:000056EE                 mov     esi, esp
.text:000056F0                 mov     ecx, [ebp+arg_4]
.text:000056F3                 push    ecx
.text:000056F4                 mov     edx, [ebp+var_20]
.text:000056F7                 push    edx
.text:000056F8                 mov     eax, [ebp+var_20]
.text:000056FB                 mov     ecx, [eax]
.text:000056FD                 mov     edx, [ecx+14h]
.text:00005700                 call    edx
.text:00005702                 cmp     esi, esp
.text:00005704                 call    __RTC_CheckEsp
.text:00005709                 mov     [ebp+var_24], eax
.text:0000570C                 mov     eax, [ebp+var_24]
.text:0000570F                 jmp     loc_57FA
.text:00005714 ; ---------------------------------------------------------------------------
.text:00005714
.text:00005714 loc_5714:                               ; CODE XREF: CArchiveExtractCallback::PrepareOperation(int)+54j
.text:00005714                 mov     eax, [ebp+this]
.text:00005717                 mov     byte ptr [eax+0C1h], 0
.text:0000571E                 mov     ecx, [ebp+arg_4]
.text:00005721                 mov     [ebp+var_28], ecx
.text:00005724                 cmp     [ebp+var_28], 0
.text:00005728                 jz      short loc_572C
.text:0000572A                 jmp     short loc_574D
.text:0000572C ; ---------------------------------------------------------------------------
.text:0000572C
.text:0000572C loc_572C:                               ; CODE XREF: CArchiveExtractCallback::PrepareOperation(int)+A4j
.text:0000572C                 mov     edx, [ebp+this]
.text:0000572F                 movzx   eax, byte ptr [edx+125h]
.text:00005736                 test    eax, eax
.text:00005738                 jz      short loc_5743
.text:0000573A                 mov     [ebp+arg_4], 1
.text:00005741                 jmp     short loc_574D
.text:00005743 ; ---------------------------------------------------------------------------
.text:00005743
.text:00005743 loc_5743:                               ; CODE XREF: CArchiveExtractCallback::PrepareOperation(int)+B4j
.text:00005743                 mov     ecx, [ebp+this]
.text:00005746                 mov     byte ptr [ecx+0C1h], 1
.text:0000574D
.text:0000574D loc_574D:                               ; CODE XREF: CArchiveExtractCallback::PrepareOperation(int)+A6j
.text:0000574D                                         ; CArchiveExtractCallback::PrepareOperation(int)+BDj
.text:0000574D                 mov     edx, [ebp+this]
.text:00005750                 movzx   eax, byte ptr [edx+0C0h]
.text:00005757                 test    eax, eax
.text:00005759                 jz      short loc_5769
.text:0000575B                 mov     ecx, [ebp+this]
.text:0000575E                 add     ecx, 0B8h ; '+'
.text:00005764                 mov     [ebp+var_2C], ecx
.text:00005767                 jmp     short loc_5770
.text:00005769 ; ---------------------------------------------------------------------------
.text:00005769
.text:00005769 loc_5769:                               ; CODE XREF: CArchiveExtractCallback::PrepareOperation(int)+D5j
.text:00005769                 mov     [ebp+var_2C], 0
.text:00005770
.text:00005770 loc_5770:                               ; CODE XREF: CArchiveExtractCallback::PrepareOperation(int)+E3j
.text:00005770                 mov     ecx, [ebp+this]
.text:00005773                 add     ecx, 28h ; '('
.text:00005776                 call    ??C?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::operator->(void)
.text:0000577B                 mov     [ebp+var_30], eax
.text:0000577E                 mov     edx, [ebp+var_30]
.text:00005781                 mov     [ebp+var_34], edx
.text:00005784                 mov     eax, [ebp+this]
.text:00005787                 movzx   ecx, byte ptr [eax+9Ah]
.text:0000578E                 push    ecx             ; bool
.text:0000578F                 call    ?BoolToInt@@YGH_N@Z ; BoolToInt(bool)
.text:00005794                 mov     [ebp+var_38], eax
.text:00005797                 mov     ecx, [ebp+this]
.text:0000579A                 add     ecx, 68h ; 'h'
.text:0000579D                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000057A2                 mov     [ebp+var_3C], eax
.text:000057A5                 mov     esi, esp
.text:000057A7                 mov     edx, [ebp+var_2C]
.text:000057AA                 push    edx
.text:000057AB                 mov     eax, [ebp+arg_4]
.text:000057AE                 push    eax
.text:000057AF                 mov     ecx, [ebp+var_38]
.text:000057B2                 push    ecx
.text:000057B3                 mov     edx, [ebp+var_3C]
.text:000057B6                 push    edx
.text:000057B7                 mov     eax, [ebp+var_34]
.text:000057BA                 push    eax
.text:000057BB                 mov     ecx, [ebp+var_34]
.text:000057BE                 mov     edx, [ecx]
.text:000057C0                 mov     eax, [edx+18h]
.text:000057C3                 call    eax
.text:000057C5                 cmp     esi, esp
.text:000057C7                 call    __RTC_CheckEsp
.text:000057CC                 mov     [ebp+var_40], eax
.text:000057CF                 mov     eax, [ebp+var_40]
.text:000057D2                 jmp     short loc_57FA
.text:000057D2 ?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z endp
.text:000057D2
.text:000057D4
.text:000057D4 ; =============== S U B R O U T I N E =======================================
.text:000057D4
.text:000057D4
.text:000057D4 __catch$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z$0 proc near
.text:000057D4                                         ; DATA XREF: .xdata$x:00007074o
.text:000057D4                 mov     dword ptr [ebp-14h], 8007000Eh
.text:000057DB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:000057E2                 mov     eax, offset $LN15_1
.text:000057E7                 retn
.text:000057E7 __catch$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z$0 endp
.text:000057E7
.text:000057E8 ; ---------------------------------------------------------------------------
.text:000057E8                 mov     eax, offset __tryend$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z$1
.text:000057ED                 retn
.text:000057EE ; ---------------------------------------------------------------------------
.text:000057EE
.text:000057EE __tryend$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z$1:
.text:000057EE                                         ; DATA XREF: .text:000057E8o
.text:000057EE                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:000057F5                 jmp     short loc_57FA
.text:000057F7 ; ---------------------------------------------------------------------------
.text:000057F7
.text:000057F7 $LN15_1:                                ; DATA XREF: __catch$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z$0+Eo
.text:000057F7                 mov     eax, [ebp-14h]
.text:000057FA ; START OF FUNCTION CHUNK FOR ?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z
.text:000057FA
.text:000057FA loc_57FA:                               ; CODE XREF: CArchiveExtractCallback::PrepareOperation(int)+8Bj
.text:000057FA                                         ; CArchiveExtractCallback::PrepareOperation(int)+14Ej ...
.text:000057FA                 mov     ecx, [ebp+var_C]
.text:000057FD                 mov     large fs:0, ecx
.text:00005804                 pop     ecx
.text:00005805                 pop     edi
.text:00005806                 pop     esi
.text:00005807                 pop     ebx
.text:00005808                 add     esp, 40h
.text:0000580B                 cmp     ebp, esp
.text:0000580D                 call    __RTC_CheckEsp
.text:00005812                 mov     esp, ebp
.text:00005814                 pop     ebp
.text:00005815                 retn    8
.text:00005815 ; END OF FUNCTION CHUNK FOR ?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z
.text:00005815 ; ---------------------------------------------------------------------------
.text:00005818                 db 0Ch dup(0CCh)
.text:00005824
.text:00005824 ; =============== S U B R O U T I N E =======================================
.text:00005824
.text:00005824 ; Attributes: bp-based frame
.text:00005824
.text:00005824 ; __int32 __cdecl CArchiveExtractCallback::SetOperationResult(CArchiveExtractCallback *this, int)
.text:00005824                 public ?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z
.text:00005824 ?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z proc near
.text:00005824                                         ; DATA XREF: .rdata:000075C0o
.text:00005824
.text:00005824 var_9C          = dword ptr -9Ch
.text:00005824 var_98          = dword ptr -98h
.text:00005824 var_94          = dword ptr -94h
.text:00005824 var_90          = dword ptr -90h
.text:00005824 var_8C          = dword ptr -8Ch
.text:00005824 lpFileName      = dword ptr -88h
.text:00005824 var_84          = dword ptr -84h
.text:00005824 var_80          = dword ptr -80h
.text:00005824 var_7C          = dword ptr -7Ch
.text:00005824 var_78          = dword ptr -78h
.text:00005824 var_74          = dword ptr -74h
.text:00005824 var_70          = dword ptr -70h
.text:00005824 var_6C          = dword ptr -6Ch
.text:00005824 var_68          = dword ptr -68h
.text:00005824 var_64          = dword ptr -64h
.text:00005824 var_60          = dword ptr -60h
.text:00005824 var_5C          = dword ptr -5Ch
.text:00005824 var_58          = dword ptr -58h
.text:00005824 var_54          = dword ptr -54h
.text:00005824 var_50          = dword ptr -50h
.text:00005824 var_4C          = dword ptr -4Ch
.text:00005824 var_48          = dword ptr -48h
.text:00005824 var_40          = dword ptr -40h
.text:00005824 SecurityInformation= dword ptr -3Ch
.text:00005824 var_34          = dword ptr -34h
.text:00005824 var_28          = dword ptr -28h
.text:00005824 pSecurityDescriptor= dword ptr -1Ch
.text:00005824 var_14          = dword ptr -14h
.text:00005824 var_10          = dword ptr -10h
.text:00005824 var_C           = dword ptr -0Ch
.text:00005824 var_4           = dword ptr -4
.text:00005824 this            = dword ptr  8
.text:00005824 arg_4           = dword ptr  0Ch
.text:00005824
.text:00005824 ; FUNCTION CHUNK AT .text:00005DAF SIZE 00000032 BYTES
.text:00005824
.text:00005824                 push    ebp
.text:00005825                 mov     ebp, esp
.text:00005827                 push    0FFFFFFFFh
.text:00005829                 push    offset __ehhandler$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z
.text:0000582E                 mov     eax, large fs:0
.text:00005834                 push    eax
.text:00005835                 push    ecx
.text:00005836                 sub     esp, 8Ch
.text:0000583C                 push    ebx
.text:0000583D                 push    esi
.text:0000583E                 push    edi
.text:0000583F                 lea     edi, [ebp+var_9C]
.text:00005845                 mov     ecx, 23h ; '#'
.text:0000584A                 mov     eax, 0CCCCCCCCh
.text:0000584F                 rep stosd
.text:00005851                 mov     eax, dword ptr ds:___security_cookie
.text:00005856                 xor     eax, ebp
.text:00005858                 push    eax             ; unsigned __int32
.text:00005859                 lea     eax, [ebp+var_C]
.text:0000585C                 mov     large fs:0, eax
.text:00005862                 mov     [ebp+var_10], esp
.text:00005865                 mov     [ebp+var_4], 0
.text:0000586C                 mov     ecx, [ebp+this]
.text:0000586F                 add     ecx, 5Ch ; '\'
.text:00005872                 call    ??B?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::operator IFolderExtractToStreamCallback *(void)
.text:00005877                 mov     [ebp+var_48], eax
.text:0000587A                 cmp     [ebp+var_48], 0
.text:0000587E                 jz      short loc_58D1
.text:00005880                 mov     ecx, [ebp+this]
.text:00005883                 add     ecx, 5Ch ; '\'
.text:00005886                 call    ??C?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::operator->(void)
.text:0000588B                 mov     [ebp+var_4C], eax
.text:0000588E                 mov     eax, [ebp+var_4C]
.text:00005891                 mov     [ebp+var_50], eax
.text:00005894                 mov     ecx, [ebp+this]
.text:00005897                 movzx   edx, byte ptr [ecx+0C5h]
.text:0000589E                 push    edx             ; bool
.text:0000589F                 call    ?BoolToInt@@YGH_N@Z ; BoolToInt(bool)
.text:000058A4                 mov     [ebp+var_54], eax
.text:000058A7                 mov     esi, esp
.text:000058A9                 mov     eax, [ebp+var_54]
.text:000058AC                 push    eax
.text:000058AD                 mov     ecx, [ebp+arg_4]
.text:000058B0                 push    ecx
.text:000058B1                 mov     edx, [ebp+var_50]
.text:000058B4                 push    edx
.text:000058B5                 mov     eax, [ebp+var_50]
.text:000058B8                 mov     ecx, [eax]
.text:000058BA                 mov     edx, [ecx+18h]
.text:000058BD                 call    edx
.text:000058BF                 cmp     esi, esp
.text:000058C1                 call    __RTC_CheckEsp
.text:000058C6                 mov     [ebp+var_58], eax
.text:000058C9                 mov     eax, [ebp+var_58]
.text:000058CC                 jmp     loc_5DAF
.text:000058D1 ; ---------------------------------------------------------------------------
.text:000058D1
.text:000058D1 loc_58D1:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+5Aj
.text:000058D1                 mov     eax, [ebp+this]
.text:000058D4                 movzx   ecx, byte ptr [eax+10Ch]
.text:000058DB                 test    ecx, ecx
.text:000058DD                 jz      loc_5973
.text:000058E3                 mov     edx, [ebp+this]
.text:000058E6                 add     edx, 68h ; 'h'
.text:000058E9                 mov     esi, esp
.text:000058EB                 push    edx
.text:000058EC                 mov     eax, [ebp+this]
.text:000058EF                 movzx   ecx, byte ptr [eax+98h]
.text:000058F6                 push    ecx
.text:000058F7                 mov     edx, [ebp+this]
.text:000058FA                 movzx   eax, byte ptr [edx+9Ah]
.text:00005901                 push    eax
.text:00005902                 mov     ecx, [ebp+this]
.text:00005905                 mov     edx, [ecx+104h]
.text:0000590B                 mov     ecx, [edx+1Ch]
.text:0000590E                 mov     eax, [ebp+this]
.text:00005911                 mov     edx, [eax+104h]
.text:00005917                 mov     eax, [edx+1Ch]
.text:0000591A                 mov     edx, [eax]
.text:0000591C                 mov     eax, [edx+0Ch]
.text:0000591F                 call    eax
.text:00005921                 cmp     esi, esp
.text:00005923                 call    __RTC_CheckEsp
.text:00005928                 mov     ecx, [ebp+this]
.text:0000592B                 mov     ecx, [ecx+104h] ; this
.text:00005931                 call    ?GetSize@COutStreamWithHash@@QBE_KXZ ; COutStreamWithHash::GetSize(void)
.text:00005936                 mov     [ebp+var_60], eax
.text:00005939                 mov     [ebp+var_5C], edx
.text:0000593C                 mov     edx, [ebp+this]
.text:0000593F                 mov     eax, [ebp+var_60]
.text:00005942                 mov     [edx+0F0h], eax
.text:00005948                 mov     ecx, [ebp+var_5C]
.text:0000594B                 mov     [edx+0F4h], ecx
.text:00005951                 mov     edx, [ebp+this]
.text:00005954                 mov     byte ptr [edx+0F8h], 1
.text:0000595B                 mov     eax, [ebp+this]
.text:0000595E                 mov     ecx, [eax+104h] ; this
.text:00005964                 call    ?ReleaseStream@COutStreamWithHash@@QAEXXZ ; COutStreamWithHash::ReleaseStream(void)
.text:00005969                 mov     ecx, [ebp+this]
.text:0000596C                 mov     byte ptr [ecx+10Ch], 0
.text:00005973
.text:00005973 loc_5973:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+B9j
.text:00005973                 mov     ecx, [ebp+this]
.text:00005976                 add     ecx, 100h
.text:0000597C                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00005981                 mov     [ebp+var_64], eax
.text:00005984                 cmp     [ebp+var_64], 0
.text:00005988                 jz      loc_5ABD
.text:0000598E                 mov     edx, [ebp+this]
.text:00005991                 movzx   eax, byte ptr [edx+0C4h]
.text:00005998                 test    eax, eax
.text:0000599A                 jz      short loc_59B7
.text:0000599C                 mov     ecx, [ebp+this]
.text:0000599F                 movzx   edx, byte ptr [ecx+0E6h]
.text:000059A6                 test    edx, edx
.text:000059A8                 jz      short loc_59B7
.text:000059AA                 mov     eax, [ebp+this]
.text:000059AD                 add     eax, 0D8h ; '+'
.text:000059B2                 mov     [ebp+var_68], eax
.text:000059B5                 jmp     short loc_59E6
.text:000059B7 ; ---------------------------------------------------------------------------
.text:000059B7
.text:000059B7 loc_59B7:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+176j
.text:000059B7                                         ; CArchiveExtractCallback::SetOperationResult(int)+184j
.text:000059B7                 mov     ecx, [ebp+this]
.text:000059BA                 mov     edx, [ecx+14h]
.text:000059BD                 movzx   eax, byte ptr [edx+0A4h]
.text:000059C4                 test    eax, eax
.text:000059C6                 jz      short loc_59D9
.text:000059C8                 mov     ecx, [ebp+this]
.text:000059CB                 mov     edx, [ecx+14h]
.text:000059CE                 add     edx, 9Ch ; '£'
.text:000059D4                 mov     [ebp+var_6C], edx
.text:000059D7                 jmp     short loc_59E0
.text:000059D9 ; ---------------------------------------------------------------------------
.text:000059D9
.text:000059D9 loc_59D9:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+1A2j
.text:000059D9                 mov     [ebp+var_6C], 0
.text:000059E0
.text:000059E0 loc_59E0:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+1B3j
.text:000059E0                 mov     eax, [ebp+var_6C]
.text:000059E3                 mov     [ebp+var_68], eax
.text:000059E6
.text:000059E6 loc_59E6:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+191j
.text:000059E6                 mov     ecx, [ebp+this]
.text:000059E9                 movzx   edx, byte ptr [ecx+0C3h]
.text:000059F0                 test    edx, edx
.text:000059F2                 jz      short loc_5A10
.text:000059F4                 mov     eax, [ebp+this]
.text:000059F7                 movzx   ecx, byte ptr [eax+0E5h]
.text:000059FE                 test    ecx, ecx
.text:00005A00                 jz      short loc_5A10
.text:00005A02                 mov     edx, [ebp+this]
.text:00005A05                 add     edx, 0D0h ; '-'
.text:00005A0B                 mov     [ebp+var_70], edx
.text:00005A0E                 jmp     short loc_5A17
.text:00005A10 ; ---------------------------------------------------------------------------
.text:00005A10
.text:00005A10 loc_5A10:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+1CEj
.text:00005A10                                         ; CArchiveExtractCallback::SetOperationResult(int)+1DCj
.text:00005A10                 mov     [ebp+var_70], 0
.text:00005A17
.text:00005A17 loc_5A17:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+1EAj
.text:00005A17                 mov     eax, [ebp+this]
.text:00005A1A                 movzx   ecx, byte ptr [eax+0C2h]
.text:00005A21                 test    ecx, ecx
.text:00005A23                 jz      short loc_5A41
.text:00005A25                 mov     edx, [ebp+this]
.text:00005A28                 movzx   eax, byte ptr [edx+0E4h]
.text:00005A2F                 test    eax, eax
.text:00005A31                 jz      short loc_5A41
.text:00005A33                 mov     ecx, [ebp+this]
.text:00005A36                 add     ecx, 0C8h ; '+'
.text:00005A3C                 mov     [ebp+var_74], ecx
.text:00005A3F                 jmp     short loc_5A48
.text:00005A41 ; ---------------------------------------------------------------------------
.text:00005A41
.text:00005A41 loc_5A41:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+1FFj
.text:00005A41                                         ; CArchiveExtractCallback::SetOperationResult(int)+20Dj
.text:00005A41                 mov     [ebp+var_74], 0
.text:00005A48
.text:00005A48 loc_5A48:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+21Bj
.text:00005A48                 mov     edx, [ebp+var_68]
.text:00005A4B                 push    edx             ; struct _FILETIME *
.text:00005A4C                 mov     eax, [ebp+var_70]
.text:00005A4F                 push    eax             ; struct _FILETIME *
.text:00005A50                 mov     ecx, [ebp+var_74]
.text:00005A53                 push    ecx             ; struct _FILETIME *
.text:00005A54                 mov     edx, [ebp+this]
.text:00005A57                 mov     ecx, [edx+0FCh] ; this
.text:00005A5D                 call    ?SetTime@COutFileStream@@QAE_NPBU_FILETIME@@00@Z ; COutFileStream::SetTime(_FILETIME const *,_FILETIME const *,_FILETIME const *)
.text:00005A62                 mov     eax, [ebp+this]
.text:00005A65                 mov     ecx, [eax+0FCh]
.text:00005A6B                 mov     edx, [ebp+this]
.text:00005A6E                 mov     eax, [ecx+18h]
.text:00005A71                 mov     [edx+0F0h], eax
.text:00005A77                 mov     ecx, [ecx+1Ch]
.text:00005A7A                 mov     [edx+0F4h], ecx
.text:00005A80                 mov     edx, [ebp+this]
.text:00005A83                 mov     byte ptr [edx+0F8h], 1
.text:00005A8A                 mov     eax, [ebp+this]
.text:00005A8D                 mov     ecx, [eax+0FCh] ; this
.text:00005A93                 call    ?Close@COutFileStream@@QAEJXZ ; COutFileStream::Close(void)
.text:00005A98                 mov     [ebp+var_78], eax
.text:00005A9B                 mov     ecx, [ebp+var_78]
.text:00005A9E                 mov     [ebp+var_14], ecx
.text:00005AA1                 cmp     [ebp+var_14], 0
.text:00005AA5                 jz      short loc_5AAF
.text:00005AA7                 mov     eax, [ebp+var_14]
.text:00005AAA                 jmp     loc_5DAF
.text:00005AAF ; ---------------------------------------------------------------------------
.text:00005AAF
.text:00005AAF loc_5AAF:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+281j
.text:00005AAF                 mov     ecx, [ebp+this]
.text:00005AB2                 add     ecx, 100h
.text:00005AB8                 call    ?Release@?$CMyComPtr@UISequentialOutStream@@@@QAEXXZ ; CMyComPtr<ISequentialOutStream>::Release(void)
.text:00005ABD
.text:00005ABD loc_5ABD:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+164j
.text:00005ABD                 mov     edx, [ebp+this]
.text:00005AC0                 movzx   eax, byte ptr [edx+18h]
.text:00005AC4                 test    eax, eax
.text:00005AC6                 jz      loc_5BB0
.text:00005ACC                 mov     ecx, [ebp+this]
.text:00005ACF                 mov     ecx, [ecx+14h]
.text:00005AD2                 add     ecx, 8
.text:00005AD5                 call    ??B?$CMyComPtr@UIArchiveGetRawProps@@@@QBEPAUIArchiveGetRawProps@@XZ ; CMyComPtr<IArchiveGetRawProps>::operator IArchiveGetRawProps *(void)
.text:00005ADA                 mov     [ebp+var_7C], eax
.text:00005ADD                 cmp     [ebp+var_7C], 0
.text:00005AE1                 jz      loc_5BB0
.text:00005AE7                 mov     edx, [ebp+this]
.text:00005AEA                 mov     ecx, [edx+14h]
.text:00005AED                 add     ecx, 8
.text:00005AF0                 call    ??C?$CMyComPtr@UIArchiveGetRawProps@@@@QBEPAUIArchiveGetRawProps@@XZ ; CMyComPtr<IArchiveGetRawProps>::operator->(void)
.text:00005AF5                 mov     [ebp+var_80], eax
.text:00005AF8                 mov     eax, [ebp+var_80]
.text:00005AFB                 mov     [ebp+var_84], eax
.text:00005B01                 mov     esi, esp
.text:00005B03                 lea     ecx, [ebp+var_34]
.text:00005B06                 push    ecx
.text:00005B07                 lea     edx, [ebp+var_28]
.text:00005B0A                 push    edx
.text:00005B0B                 lea     eax, [ebp+pSecurityDescriptor]
.text:00005B0E                 push    eax
.text:00005B0F                 push    3Eh ; '>'
.text:00005B11                 mov     ecx, [ebp+this]
.text:00005B14                 mov     edx, [ecx+0E8h]
.text:00005B1A                 push    edx
.text:00005B1B                 mov     eax, [ebp+var_84]
.text:00005B21                 push    eax
.text:00005B22                 mov     ecx, [ebp+var_84]
.text:00005B28                 mov     edx, [ecx]
.text:00005B2A                 mov     eax, [edx+10h]
.text:00005B2D                 call    eax
.text:00005B2F                 cmp     esi, esp
.text:00005B31                 call    __RTC_CheckEsp
.text:00005B36                 cmp     [ebp+var_28], 0
.text:00005B3A                 jz      short loc_5BB0
.text:00005B3C                 cmp     [ebp+var_34], 1
.text:00005B40                 jz      short loc_5B4C
.text:00005B42                 mov     eax, 80004005h
.text:00005B47                 jmp     loc_5DAF
.text:00005B4C ; ---------------------------------------------------------------------------
.text:00005B4C
.text:00005B4C loc_5B4C:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+31Cj
.text:00005B4C                 mov     ecx, [ebp+var_28]
.text:00005B4F                 push    ecx             ; unsigned int
.text:00005B50                 mov     edx, [ebp+pSecurityDescriptor]
.text:00005B53                 push    edx             ; unsigned __int8 *
.text:00005B54                 call    ?CheckNtSecure@@YG_NPBEI@Z ; CheckNtSecure(uchar const *,uint)
.text:00005B59                 movzx   eax, al
.text:00005B5C                 test    eax, eax
.text:00005B5E                 jz      short loc_5BB0
.text:00005B60                 mov     [ebp+SecurityInformation], 7
.text:00005B67                 mov     ecx, [ebp+this]
.text:00005B6A                 movzx   edx, byte ptr [ecx+15Ch]
.text:00005B71                 test    edx, edx
.text:00005B73                 jz      short loc_5B7E
.text:00005B75                 mov     eax, [ebp+SecurityInformation]
.text:00005B78                 or      eax, 8
.text:00005B7B                 mov     [ebp+SecurityInformation], eax
.text:00005B7E
.text:00005B7E loc_5B7E:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+34Fj
.text:00005B7E                 mov     ecx, [ebp+this]
.text:00005B81                 add     ecx, 0A8h ; '¿'
.text:00005B87                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00005B8C                 mov     [ebp+lpFileName], eax
.text:00005B92                 mov     esi, esp
.text:00005B94                 mov     ecx, [ebp+pSecurityDescriptor]
.text:00005B97                 push    ecx             ; pSecurityDescriptor
.text:00005B98                 mov     edx, [ebp+SecurityInformation]
.text:00005B9B                 push    edx             ; SecurityInformation
.text:00005B9C                 mov     eax, [ebp+lpFileName]
.text:00005BA2                 push    eax             ; lpFileName
.text:00005BA3                 call    dword ptr ds:__imp__SetFileSecurityW@12 ; SetFileSecurityW(x,x,x)
.text:00005BA9                 cmp     esi, esp
.text:00005BAB                 call    __RTC_CheckEsp
.text:00005BB0
.text:00005BB0 loc_5BB0:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+2A2j
.text:00005BB0                                         ; CArchiveExtractCallback::SetOperationResult(int)+2BDj ...
.text:00005BB0                 mov     ecx, [ebp+this]
.text:00005BB3                 movzx   edx, byte ptr [ecx+0F8h]
.text:00005BBA                 test    edx, edx
.text:00005BBC                 jnz     short loc_5BC6
.text:00005BBE                 mov     ecx, [ebp+this] ; this
.text:00005BC1                 call    ?GetUnpackSize@CArchiveExtractCallback@@AAEJXZ ; CArchiveExtractCallback::GetUnpackSize(void)
.text:00005BC6
.text:00005BC6 loc_5BC6:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+398j
.text:00005BC6                 mov     eax, [ebp+this]
.text:00005BC9                 movzx   ecx, byte ptr [eax+0F8h]
.text:00005BD0                 test    ecx, ecx
.text:00005BD2                 jz      short loc_5C3E
.text:00005BD4                 mov     edx, [ebp+this]
.text:00005BD7                 movzx   eax, byte ptr [edx+98h]
.text:00005BDE                 test    eax, eax
.text:00005BE0                 jz      short loc_5C11
.text:00005BE2                 mov     ecx, [ebp+this]
.text:00005BE5                 mov     edx, [ebp+this]
.text:00005BE8                 mov     eax, [ecx+188h]
.text:00005BEE                 add     eax, [edx+0F0h]
.text:00005BF4                 mov     ecx, [ecx+18Ch]
.text:00005BFA                 adc     ecx, [edx+0F4h]
.text:00005C00                 mov     edx, [ebp+this]
.text:00005C03                 mov     [edx+188h], eax
.text:00005C09                 mov     [edx+18Ch], ecx
.text:00005C0F                 jmp     short loc_5C3E
.text:00005C11 ; ---------------------------------------------------------------------------
.text:00005C11
.text:00005C11 loc_5C11:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+3BCj
.text:00005C11                 mov     eax, [ebp+this]
.text:00005C14                 mov     ecx, [ebp+this]
.text:00005C17                 mov     edx, [eax+180h]
.text:00005C1D                 add     edx, [ecx+0F0h]
.text:00005C23                 mov     eax, [eax+184h]
.text:00005C29                 adc     eax, [ecx+0F4h]
.text:00005C2F                 mov     ecx, [ebp+this]
.text:00005C32                 mov     [ecx+180h], edx
.text:00005C38                 mov     [ecx+184h], eax
.text:00005C3E
.text:00005C3E loc_5C3E:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+3AEj
.text:00005C3E                                         ; CArchiveExtractCallback::SetOperationResult(int)+3EBj
.text:00005C3E                 mov     edx, [ebp+this]
.text:00005C41                 movzx   eax, byte ptr [edx+9Ah]
.text:00005C48                 test    eax, eax
.text:00005C4A                 jz      short loc_5C72
.text:00005C4C                 mov     ecx, [ebp+this]
.text:00005C4F                 mov     edx, [ecx+168h]
.text:00005C55                 add     edx, 1
.text:00005C58                 mov     eax, [ecx+16Ch]
.text:00005C5E                 adc     eax, 0
.text:00005C61                 mov     ecx, [ebp+this]
.text:00005C64                 mov     [ecx+168h], edx
.text:00005C6A                 mov     [ecx+16Ch], eax
.text:00005C70                 jmp     short loc_5CCA
.text:00005C72 ; ---------------------------------------------------------------------------
.text:00005C72
.text:00005C72 loc_5C72:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+426j
.text:00005C72                 mov     edx, [ebp+this]
.text:00005C75                 movzx   eax, byte ptr [edx+98h]
.text:00005C7C                 test    eax, eax
.text:00005C7E                 jz      short loc_5CA6
.text:00005C80                 mov     ecx, [ebp+this]
.text:00005C83                 mov     edx, [ecx+178h]
.text:00005C89                 add     edx, 1
.text:00005C8C                 mov     eax, [ecx+17Ch]
.text:00005C92                 adc     eax, 0
.text:00005C95                 mov     ecx, [ebp+this]
.text:00005C98                 mov     [ecx+178h], edx
.text:00005C9E                 mov     [ecx+17Ch], eax
.text:00005CA4                 jmp     short loc_5CCA
.text:00005CA6 ; ---------------------------------------------------------------------------
.text:00005CA6
.text:00005CA6 loc_5CA6:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+45Aj
.text:00005CA6                 mov     edx, [ebp+this]
.text:00005CA9                 mov     eax, [edx+170h]
.text:00005CAF                 add     eax, 1
.text:00005CB2                 mov     ecx, [edx+174h]
.text:00005CB8                 adc     ecx, 0
.text:00005CBB                 mov     edx, [ebp+this]
.text:00005CBE                 mov     [edx+170h], eax
.text:00005CC4                 mov     [edx+174h], ecx
.text:00005CCA
.text:00005CCA loc_5CCA:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+44Cj
.text:00005CCA                                         ; CArchiveExtractCallback::SetOperationResult(int)+480j
.text:00005CCA                 mov     eax, [ebp+this]
.text:00005CCD                 movzx   ecx, byte ptr [eax+0C1h]
.text:00005CD4                 test    ecx, ecx
.text:00005CD6                 jz      short loc_5D10
.text:00005CD8                 mov     edx, [ebp+this]
.text:00005CDB                 movzx   eax, byte ptr [edx+0E7h]
.text:00005CE2                 test    eax, eax
.text:00005CE4                 jz      short loc_5D10
.text:00005CE6                 mov     ecx, [ebp+this]
.text:00005CE9                 add     ecx, 0A8h ; '¿'
.text:00005CEF                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00005CF4                 mov     [ebp+var_8C], eax
.text:00005CFA                 mov     ecx, [ebp+this]
.text:00005CFD                 mov     edx, [ecx+0E0h]
.text:00005D03                 push    edx             ; wchar_t *
.text:00005D04                 mov     eax, [ebp+var_8C]
.text:00005D0A                 push    eax             ; this
.text:00005D0B                 call    ?SetFileAttrib@NDir@NFile@NWindows@@YG_NPB_WK@Z ; NWindows::NFile::NDir::SetFileAttrib(wchar_t const *,ulong)
.text:00005D10
.text:00005D10 loc_5D10:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+4B2j
.text:00005D10                                         ; CArchiveExtractCallback::SetOperationResult(int)+4C0j
.text:00005D10                 mov     ecx, [ebp+this]
.text:00005D13                 add     ecx, 28h ; '('
.text:00005D16                 call    ??C?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::operator->(void)
.text:00005D1B                 mov     [ebp+var_90], eax
.text:00005D21                 mov     ecx, [ebp+var_90]
.text:00005D27                 mov     [ebp+var_94], ecx
.text:00005D2D                 mov     edx, [ebp+this]
.text:00005D30                 movzx   eax, byte ptr [edx+0C5h]
.text:00005D37                 push    eax             ; bool
.text:00005D38                 call    ?BoolToInt@@YGH_N@Z ; BoolToInt(bool)
.text:00005D3D                 mov     [ebp+var_98], eax
.text:00005D43                 mov     esi, esp
.text:00005D45                 mov     ecx, [ebp+var_98]
.text:00005D4B                 push    ecx
.text:00005D4C                 mov     edx, [ebp+arg_4]
.text:00005D4F                 push    edx
.text:00005D50                 mov     eax, [ebp+var_94]
.text:00005D56                 push    eax
.text:00005D57                 mov     ecx, [ebp+var_94]
.text:00005D5D                 mov     edx, [ecx]
.text:00005D5F                 mov     eax, [edx+20h]
.text:00005D62                 call    eax
.text:00005D64                 cmp     esi, esp
.text:00005D66                 call    __RTC_CheckEsp
.text:00005D6B                 mov     [ebp+var_9C], eax
.text:00005D71                 mov     ecx, [ebp+var_9C]
.text:00005D77                 mov     [ebp+var_40], ecx
.text:00005D7A                 cmp     [ebp+var_40], 0
.text:00005D7E                 jz      short loc_5D85
.text:00005D80                 mov     eax, [ebp+var_40]
.text:00005D83                 jmp     short loc_5DAF
.text:00005D85 ; ---------------------------------------------------------------------------
.text:00005D85
.text:00005D85 loc_5D85:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+55Aj
.text:00005D85                 xor     eax, eax
.text:00005D87                 jmp     short loc_5DAF
.text:00005D87 ?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z endp ; sp-analysis failed
.text:00005D87
.text:00005D89
.text:00005D89 ; =============== S U B R O U T I N E =======================================
.text:00005D89
.text:00005D89
.text:00005D89 __catch$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z$0 proc near
.text:00005D89                                         ; DATA XREF: .xdata$x:000070CCo
.text:00005D89                 mov     dword ptr [ebp-44h], 8007000Eh
.text:00005D90                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00005D97                 mov     eax, offset $LN34
.text:00005D9C                 retn
.text:00005D9C __catch$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z$0 endp
.text:00005D9C
.text:00005D9D ; ---------------------------------------------------------------------------
.text:00005D9D                 mov     eax, offset __tryend$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z$1
.text:00005DA2                 retn
.text:00005DA3 ; ---------------------------------------------------------------------------
.text:00005DA3
.text:00005DA3 __tryend$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z$1:
.text:00005DA3                                         ; DATA XREF: .text:00005D9Do
.text:00005DA3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00005DAA                 jmp     short loc_5DAF
.text:00005DAC ; ---------------------------------------------------------------------------
.text:00005DAC
.text:00005DAC $LN34:                                  ; DATA XREF: __catch$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z$0+Eo
.text:00005DAC                 mov     eax, [ebp-44h]
.text:00005DAF ; START OF FUNCTION CHUNK FOR ?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z
.text:00005DAF
.text:00005DAF loc_5DAF:                               ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+A8j
.text:00005DAF                                         ; CArchiveExtractCallback::SetOperationResult(int)+286j ...
.text:00005DAF                 push    edx
.text:00005DB0                 mov     ecx, ebp
.text:00005DB2                 push    eax
.text:00005DB3                 lea     edx, $LN41
.text:00005DB9                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00005DBE                 pop     eax
.text:00005DBF                 pop     edx
.text:00005DC0                 mov     ecx, [ebp+var_C]
.text:00005DC3                 mov     large fs:0, ecx
.text:00005DCA                 pop     ecx
.text:00005DCB                 pop     edi
.text:00005DCC                 pop     esi
.text:00005DCD                 pop     ebx
.text:00005DCE                 add     esp, 9Ch
.text:00005DD4                 cmp     ebp, esp
.text:00005DD6                 call    __RTC_CheckEsp
.text:00005DDB                 mov     esp, ebp
.text:00005DDD                 pop     ebp
.text:00005DDE                 retn    8
.text:00005DDE ; END OF FUNCTION CHUNK FOR ?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z
.text:00005DDE ; ---------------------------------------------------------------------------
.text:00005DE1                 align 4
.text:00005DE4 $LN41           dd 3                    ; DATA XREF: CArchiveExtractCallback::SetOperationResult(int)+58Fo
.text:00005DE8                 dd offset $LN40
.text:00005DEC $LN40           dd 0FFFFFFE4h, 4        ; DATA XREF: .text:00005DE8o
.text:00005DF4                 dd offset $LN36         ; "data"
.text:00005DF8                 dd 0FFFFFFD8h, 4
.text:00005E00                 dd offset $LN37         ; "dataSize"
.text:00005E04                 db 0CCh
.text:00005E05                 db 3 dup(0FFh)
.text:00005E08                 dd 4
.text:00005E0C                 dd offset $LN38         ; "propType"
.text:00005E10 $LN38           db 'propType',0         ; DATA XREF: .text:00005E0Co
.text:00005E19 $LN37           db 'dataSize',0         ; DATA XREF: .text:00005E00o
.text:00005E22 $LN36           db 'data',0             ; DATA XREF: .text:00005DF4o
.text:00005E27                 db 0Dh dup(0CCh)
.text:00005E34
.text:00005E34 ; =============== S U B R O U T I N E =======================================
.text:00005E34
.text:00005E34 ; Attributes: bp-based frame
.text:00005E34
.text:00005E34 ; __int32 __stdcall CArchiveExtractCallback::ReportExtractResult(CArchiveExtractCallback *this, unsigned int, unsigned int, int)
.text:00005E34                 public ?ReportExtractResult@CArchiveExtractCallback@@UAGJIIH@Z
.text:00005E34 ?ReportExtractResult@CArchiveExtractCallback@@UAGJIIH@Z proc near
.text:00005E34                                         ; DATA XREF: .rdata:0000759Co
.text:00005E34
.text:00005E34 var_B0          = dword ptr -0B0h
.text:00005E34 var_AC          = dword ptr -0ACh
.text:00005E34 var_A8          = dword ptr -0A8h
.text:00005E34 var_A4          = dword ptr -0A4h
.text:00005E34 var_A0          = dword ptr -0A0h
.text:00005E34 var_9C          = dword ptr -9Ch
.text:00005E34 var_94          = byte ptr -94h
.text:00005E34 var_50          = dword ptr -50h
.text:00005E34 var_48          = byte ptr -48h
.text:00005E34 var_34          = word ptr -34h
.text:00005E34 var_32          = word ptr -32h
.text:00005E34 var_9           = byte ptr -9
.text:00005E34 var_4           = dword ptr -4
.text:00005E34 this            = dword ptr  8
.text:00005E34 arg_4           = dword ptr  0Ch
.text:00005E34 arg_8           = dword ptr  10h
.text:00005E34 arg_C           = dword ptr  14h
.text:00005E34
.text:00005E34                 push    ebp
.text:00005E35                 mov     ebp, esp
.text:00005E37                 sub     esp, 0B0h
.text:00005E3D                 push    esi
.text:00005E3E                 push    edi
.text:00005E3F                 lea     edi, [ebp+var_B0]
.text:00005E45                 mov     ecx, 2Ch ; ','
.text:00005E4A                 mov     eax, 0CCCCCCCCh
.text:00005E4F                 rep stosd
.text:00005E51                 mov     eax, dword ptr ds:___security_cookie
.text:00005E56                 xor     eax, ebp
.text:00005E58                 mov     [ebp+var_4], eax
.text:00005E5B                 mov     ecx, [ebp+this]
.text:00005E5E                 add     ecx, 34h ; '4'
.text:00005E61                 call    ??B?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QBEPAUIFolderArchiveExtractCallback2@@XZ ; CMyComPtr<IFolderArchiveExtractCallback2>::operator IFolderArchiveExtractCallback2 *(void)
.text:00005E66                 test    eax, eax
.text:00005E68                 jz      loc_5FD4
.text:00005E6E                 mov     [ebp+var_9], 0
.text:00005E72                 lea     ecx, [ebp+var_48]
.text:00005E75                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00005E7A                 mov     [ebp+var_50], 0
.text:00005E81                 cmp     [ebp+arg_4], 1
.text:00005E85                 jnz     loc_5F67
.text:00005E8B                 cmp     [ebp+arg_8], 0FFFFFFFFh
.text:00005E8F                 jz      loc_5F67
.text:00005E95                 lea     ecx, [ebp+var_94] ; this
.text:00005E9B                 call    ??0CReadArcItem@@QAE@XZ ; CReadArcItem::CReadArcItem(void)
.text:00005EA0                 lea     eax, [ebp+var_94]
.text:00005EA6                 push    eax             ; struct CReadArcItem *
.text:00005EA7                 mov     ecx, [ebp+arg_8]
.text:00005EAA                 push    ecx             ; unsigned int
.text:00005EAB                 mov     edx, [ebp+this]
.text:00005EAE                 mov     ecx, [edx+10h]  ; this
.text:00005EB1                 call    ?GetItem@CArc@@QBEJIAAUCReadArcItem@@@Z ; CArc::GetItem(uint,CReadArcItem &)
.text:00005EB6                 mov     [ebp+var_9C], eax
.text:00005EBC                 cmp     [ebp+var_9C], 0
.text:00005EC3                 jz      short loc_5EEF
.text:00005EC5                 mov     eax, [ebp+var_9C]
.text:00005ECB                 mov     [ebp+var_A4], eax
.text:00005ED1                 lea     ecx, [ebp+var_94] ; this
.text:00005ED7                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:00005EDC                 lea     ecx, [ebp+var_48] ; this
.text:00005EDF                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00005EE4                 mov     eax, [ebp+var_A4]
.text:00005EEA                 jmp     loc_5FD6
.text:00005EEF ; ---------------------------------------------------------------------------
.text:00005EEF
.text:00005EEF loc_5EEF:                               ; CODE XREF: CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+8Fj
.text:00005EEF                 lea     ecx, [ebp+var_94]
.text:00005EF5                 push    ecx
.text:00005EF6                 lea     ecx, [ebp+var_48]
.text:00005EF9                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00005EFE                 lea     ecx, [ebp+var_48]
.text:00005F01                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00005F06                 mov     [ebp+var_50], eax
.text:00005F09                 lea     edx, [ebp+var_9]
.text:00005F0C                 push    edx             ; bool *
.text:00005F0D                 push    0Fh             ; unsigned __int32
.text:00005F0F                 mov     eax, [ebp+arg_8]
.text:00005F12                 push    eax             ; unsigned int
.text:00005F13                 mov     ecx, [ebp+this]
.text:00005F16                 mov     ecx, [ecx+10h]
.text:00005F19                 call    ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ ; CMyComPtr<IInArchive>::operator IInArchive *(void)
.text:00005F1E                 push    eax             ; struct IInArchive *
.text:00005F1F                 call    ?Archive_GetItemBoolProp@@YGJPAUIInArchive@@IKAA_N@Z ; Archive_GetItemBoolProp(IInArchive *,uint,ulong,bool &)
.text:00005F24                 mov     [ebp+var_A0], eax
.text:00005F2A                 cmp     [ebp+var_A0], 0
.text:00005F31                 jz      short loc_5F5A
.text:00005F33                 mov     edx, [ebp+var_A0]
.text:00005F39                 mov     [ebp+var_A8], edx
.text:00005F3F                 lea     ecx, [ebp+var_94] ; this
.text:00005F45                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:00005F4A                 lea     ecx, [ebp+var_48] ; this
.text:00005F4D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00005F52                 mov     eax, [ebp+var_A8]
.text:00005F58                 jmp     short loc_5FD6
.text:00005F5A ; ---------------------------------------------------------------------------
.text:00005F5A
.text:00005F5A loc_5F5A:                               ; CODE XREF: CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+FDj
.text:00005F5A                 lea     ecx, [ebp+var_94] ; this
.text:00005F60                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:00005F65                 jmp     short loc_5F83
.text:00005F67 ; ---------------------------------------------------------------------------
.text:00005F67
.text:00005F67 loc_5F67:                               ; CODE XREF: CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+51j
.text:00005F67                                         ; CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+5Bj
.text:00005F67                 mov     eax, 23h ; '#'
.text:00005F6C                 mov     [ebp+var_34], ax
.text:00005F70                 lea     ecx, [ebp+var_32]
.text:00005F73                 push    ecx             ; wchar_t *
.text:00005F74                 mov     edx, [ebp+arg_8]
.text:00005F77                 push    edx             ; unsigned int
.text:00005F78                 call    ?ConvertUInt32ToString@@YGXIPA_W@Z ; ConvertUInt32ToString(uint,wchar_t *)
.text:00005F7D                 lea     eax, [ebp+var_34]
.text:00005F80                 mov     [ebp+var_50], eax
.text:00005F83
.text:00005F83 loc_5F83:                               ; CODE XREF: CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+131j
.text:00005F83                 mov     ecx, [ebp+this]
.text:00005F86                 add     ecx, 34h ; '4'
.text:00005F89                 call    ??C?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QBEPAUIFolderArchiveExtractCallback2@@XZ ; CMyComPtr<IFolderArchiveExtractCallback2>::operator->(void)
.text:00005F8E                 mov     [ebp+var_B0], eax
.text:00005F94                 mov     esi, esp
.text:00005F96                 mov     ecx, [ebp+var_50]
.text:00005F99                 push    ecx
.text:00005F9A                 movzx   edx, [ebp+var_9]
.text:00005F9E                 push    edx
.text:00005F9F                 mov     eax, [ebp+arg_C]
.text:00005FA2                 push    eax
.text:00005FA3                 mov     ecx, [ebp+var_B0]
.text:00005FA9                 push    ecx
.text:00005FAA                 mov     edx, [ebp+var_B0]
.text:00005FB0                 mov     eax, [edx]
.text:00005FB2                 mov     ecx, [eax+0Ch]
.text:00005FB5                 call    ecx
.text:00005FB7                 cmp     esi, esp
.text:00005FB9                 call    __RTC_CheckEsp
.text:00005FBE                 mov     [ebp+var_AC], eax
.text:00005FC4                 lea     ecx, [ebp+var_48] ; this
.text:00005FC7                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00005FCC                 mov     eax, [ebp+var_AC]
.text:00005FD2                 jmp     short loc_5FD6
.text:00005FD4 ; ---------------------------------------------------------------------------
.text:00005FD4
.text:00005FD4 loc_5FD4:                               ; CODE XREF: CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+34j
.text:00005FD4                 xor     eax, eax
.text:00005FD6
.text:00005FD6 loc_5FD6:                               ; CODE XREF: CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+B6j
.text:00005FD6                                         ; CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+124j ...
.text:00005FD6                 push    edx
.text:00005FD7                 mov     ecx, ebp
.text:00005FD9                 push    eax
.text:00005FDA                 lea     edx, $LN13_1
.text:00005FE0                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00005FE5                 pop     eax
.text:00005FE6                 pop     edx
.text:00005FE7                 pop     edi
.text:00005FE8                 pop     esi
.text:00005FE9                 mov     ecx, [ebp+var_4]
.text:00005FEC                 xor     ecx, ebp
.text:00005FEE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00005FF3                 add     esp, 0B0h
.text:00005FF9                 cmp     ebp, esp
.text:00005FFB                 call    __RTC_CheckEsp
.text:00006000                 mov     esp, ebp
.text:00006002                 pop     ebp
.text:00006003                 retn    10h
.text:00006003 ?ReportExtractResult@CArchiveExtractCallback@@UAGJIIH@Z endp
.text:00006003
.text:00006003 ; ---------------------------------------------------------------------------
.text:00006006                 align 4
.text:00006008 $LN13_1         dd 4                    ; DATA XREF: CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+1A6o
.text:0000600C                 dd offset $LN12_4
.text:00006010 $LN12_4         dd 0FFFFFFF7h, 1        ; DATA XREF: .text:0000600Co
.text:00006018                 dd offset $LN8_6        ; "isEncrypted"
.text:0000601C                 db 0CCh
.text:0000601D                 db 3 dup(0FFh)
.text:00006020                 dd offset $SG76080+20h  ; "me"
.text:00006024                 dd offset $LN9_2        ; "temp"
.text:00006028                 dd 0FFFFFFB8h, 0Ch
.text:00006030                 dd offset $LN10_5       ; "s2"
.text:00006034                 dd 0FFFFFF6Ch, 40h
.text:0000603C                 dd offset $LN11_5       ; "item"
.text:00006040 $LN11_5         db 'item',0             ; DATA XREF: .text:0000603Co
.text:00006045 $LN10_5         db 's2',0               ; DATA XREF: .text:00006030o
.text:00006048 $LN9_2          db 'temp',0             ; DATA XREF: .text:00006024o
.text:0000604D $LN8_6          db 'isEncrypted',0      ; DATA XREF: .text:00006018o
.text:00006059                 db 0Bh dup(0CCh)
.text:00006064
.text:00006064 ; =============== S U B R O U T I N E =======================================
.text:00006064
.text:00006064 ; Attributes: bp-based frame
.text:00006064
.text:00006064 ; __int32 __cdecl CArchiveExtractCallback::CryptoGetTextPassword(CArchiveExtractCallback *this, wchar_t **)
.text:00006064                 public ?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z
.text:00006064 ?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z proc near
.text:00006064                                         ; DATA XREF: .rdata:00007580o
.text:00006064
.text:00006064 var_2C          = dword ptr -2Ch
.text:00006064 var_28          = dword ptr -28h
.text:00006064 var_24          = dword ptr -24h
.text:00006064 var_20          = dword ptr -20h
.text:00006064 var_1C          = dword ptr -1Ch
.text:00006064 var_18          = dword ptr -18h
.text:00006064 var_14          = dword ptr -14h
.text:00006064 var_10          = dword ptr -10h
.text:00006064 var_C           = dword ptr -0Ch
.text:00006064 var_4           = dword ptr -4
.text:00006064 this            = dword ptr  8
.text:00006064 arg_4           = dword ptr  0Ch
.text:00006064
.text:00006064 ; FUNCTION CHUNK AT .text:00006154 SIZE 0000001E BYTES
.text:00006064
.text:00006064                 push    ebp
.text:00006065                 mov     ebp, esp
.text:00006067                 push    0FFFFFFFFh
.text:00006069                 push    offset __ehhandler$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z
.text:0000606E                 mov     eax, large fs:0
.text:00006074                 push    eax
.text:00006075                 push    ecx
.text:00006076                 sub     esp, 1Ch
.text:00006079                 push    ebx
.text:0000607A                 push    esi
.text:0000607B                 push    edi
.text:0000607C                 mov     eax, 0CCCCCCCCh
.text:00006081                 mov     [ebp+var_2C], eax
.text:00006084                 mov     [ebp+var_28], eax
.text:00006087                 mov     [ebp+var_24], eax
.text:0000608A                 mov     [ebp+var_20], eax
.text:0000608D                 mov     [ebp+var_1C], eax
.text:00006090                 mov     [ebp+var_18], eax
.text:00006093                 mov     [ebp+var_14], eax
.text:00006096                 mov     eax, dword ptr ds:___security_cookie
.text:0000609B                 xor     eax, ebp
.text:0000609D                 push    eax
.text:0000609E                 lea     eax, [ebp+var_C]
.text:000060A1                 mov     large fs:0, eax
.text:000060A7                 mov     [ebp+var_10], esp
.text:000060AA                 mov     [ebp+var_4], 0
.text:000060B1                 mov     ecx, [ebp+this]
.text:000060B4                 add     ecx, 28h ; '('
.text:000060B7                 call    ??7?$CMyComPtr@UICryptoGetTextPassword@@@@QBE_NXZ ; CMyComPtr<ICryptoGetTextPassword>::operator!(void)
.text:000060BC                 mov     byte ptr [ebp+var_1C+3], al
.text:000060BF                 movzx   eax, byte ptr [ebp+var_1C+3]
.text:000060C3                 test    eax, eax
.text:000060C5                 jz      short loc_60F7
.text:000060C7                 mov     ecx, [ebp+this]
.text:000060CA                 add     ecx, 28h ; '('
.text:000060CD                 call    ??I?$CMyComPtr@UICryptoGetTextPassword@@@@QAEPAPAUICryptoGetTextPassword@@XZ ; CMyComPtr<ICryptoGetTextPassword>::operator&(void)
.text:000060D2                 mov     [ebp+var_20], eax
.text:000060D5                 mov     ecx, [ebp+var_20]
.text:000060D8                 push    ecx
.text:000060D9                 push    offset _IID_ICryptoGetTextPassword
.text:000060DE                 mov     ecx, [ebp+this]
.text:000060E1                 add     ecx, 20h ; ' '
.text:000060E4                 call    ??$QueryInterface@UICryptoGetTextPassword@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUICryptoGetTextPassword@@@Z ; CMyComPtr<IFolderArchiveExtractCallback>::QueryInterface<ICryptoGetTextPassword>(_GUID const &,ICryptoGetTextPassword * *)
.text:000060E9                 mov     [ebp+var_14], eax
.text:000060EC                 cmp     [ebp+var_14], 0
.text:000060F0                 jz      short loc_60F7
.text:000060F2                 mov     eax, [ebp+var_14]
.text:000060F5                 jmp     short loc_6154
.text:000060F7 ; ---------------------------------------------------------------------------
.text:000060F7
.text:000060F7 loc_60F7:                               ; CODE XREF: CArchiveExtractCallback::CryptoGetTextPassword(wchar_t * *)+61j
.text:000060F7                                         ; CArchiveExtractCallback::CryptoGetTextPassword(wchar_t * *)+8Cj
.text:000060F7                 mov     ecx, [ebp+this]
.text:000060FA                 add     ecx, 28h ; '('
.text:000060FD                 call    ??C?$CMyComPtr@UICryptoGetTextPassword@@@@QBEPAUICryptoGetTextPassword@@XZ ; CMyComPtr<ICryptoGetTextPassword>::operator->(void)
.text:00006102                 mov     [ebp+var_24], eax
.text:00006105                 mov     edx, [ebp+var_24]
.text:00006108                 mov     [ebp+var_28], edx
.text:0000610B                 mov     esi, esp
.text:0000610D                 mov     eax, [ebp+arg_4]
.text:00006110                 push    eax
.text:00006111                 mov     ecx, [ebp+var_28]
.text:00006114                 push    ecx
.text:00006115                 mov     edx, [ebp+var_28]
.text:00006118                 mov     eax, [edx]
.text:0000611A                 mov     ecx, [eax+0Ch]
.text:0000611D                 call    ecx
.text:0000611F                 cmp     esi, esp
.text:00006121                 call    __RTC_CheckEsp
.text:00006126                 mov     [ebp+var_2C], eax
.text:00006129                 mov     eax, [ebp+var_2C]
.text:0000612C                 jmp     short loc_6154
.text:0000612C ?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z endp
.text:0000612C
.text:0000612E
.text:0000612E ; =============== S U B R O U T I N E =======================================
.text:0000612E
.text:0000612E
.text:0000612E __catch$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z$0 proc near
.text:0000612E                                         ; DATA XREF: .xdata$x:00007124o
.text:0000612E                 mov     dword ptr [ebp-18h], 8007000Eh
.text:00006135                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:0000613C                 mov     eax, offset $LN9_3
.text:00006141                 retn
.text:00006141 __catch$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z$0 endp
.text:00006141
.text:00006142 ; ---------------------------------------------------------------------------
.text:00006142                 mov     eax, offset __tryend$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z$1
.text:00006147                 retn
.text:00006148 ; ---------------------------------------------------------------------------
.text:00006148
.text:00006148 __tryend$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z$1:
.text:00006148                                         ; DATA XREF: .text:00006142o
.text:00006148                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:0000614F                 jmp     short loc_6154
.text:00006151 ; ---------------------------------------------------------------------------
.text:00006151
.text:00006151 $LN9_3:                                 ; DATA XREF: __catch$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z$0+Eo
.text:00006151                 mov     eax, [ebp-18h]
.text:00006154 ; START OF FUNCTION CHUNK FOR ?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z
.text:00006154
.text:00006154 loc_6154:                               ; CODE XREF: CArchiveExtractCallback::CryptoGetTextPassword(wchar_t * *)+91j
.text:00006154                                         ; CArchiveExtractCallback::CryptoGetTextPassword(wchar_t * *)+C8j ...
.text:00006154                 mov     ecx, [ebp+var_C]
.text:00006157                 mov     large fs:0, ecx
.text:0000615E                 pop     ecx
.text:0000615F                 pop     edi
.text:00006160                 pop     esi
.text:00006161                 pop     ebx
.text:00006162                 add     esp, 2Ch
.text:00006165                 cmp     ebp, esp
.text:00006167                 call    __RTC_CheckEsp
.text:0000616C                 mov     esp, ebp
.text:0000616E                 pop     ebp
.text:0000616F                 retn    8
.text:0000616F ; END OF FUNCTION CHUNK FOR ?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z
.text:0000616F ; ---------------------------------------------------------------------------
.text:00006172                 align 4
.text:00006174
.text:00006174 ; =============== S U B R O U T I N E =======================================
.text:00006174
.text:00006174 ; Attributes: bp-based frame
.text:00006174
.text:00006174 ; int __thiscall CExtrRefSortPair::Compare(CExtrRefSortPair *this, const struct CExtrRefSortPair *)
.text:00006174                 public ?Compare@CExtrRefSortPair@@QBEHABU1@@Z
.text:00006174 ?Compare@CExtrRefSortPair@@QBEHABU1@@Z proc near
.text:00006174                                         ; CODE XREF: CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)+5Cp
.text:00006174                                         ; CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)+7Bp
.text:00006174
.text:00006174 var_8           = dword ptr -8
.text:00006174 var_4           = dword ptr -4
.text:00006174 arg_0           = dword ptr  8
.text:00006174
.text:00006174                 push    ebp
.text:00006175                 mov     ebp, esp
.text:00006177                 sub     esp, 8
.text:0000617A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00006181                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006188                 mov     [ebp+var_4], ecx
.text:0000618B                 mov     eax, [ebp+arg_0]
.text:0000618E                 mov     ecx, [eax]
.text:00006190                 push    ecx
.text:00006191                 mov     edx, [ebp+var_4]
.text:00006194                 mov     eax, [edx]
.text:00006196                 push    eax
.text:00006197                 call    ??$MyCompare@I@@YGHII@Z ; MyCompare<uint>(uint,uint)
.text:0000619C                 neg     eax
.text:0000619E                 mov     [ebp+var_8], eax
.text:000061A1                 jz      short loc_61A8
.text:000061A3                 mov     eax, [ebp+var_8]
.text:000061A6                 jmp     short loc_61BB
.text:000061A8 ; ---------------------------------------------------------------------------
.text:000061A8
.text:000061A8 loc_61A8:                               ; CODE XREF: CExtrRefSortPair::Compare(CExtrRefSortPair const &)+2Dj
.text:000061A8                 mov     ecx, [ebp+arg_0]
.text:000061AB                 mov     edx, [ecx+4]
.text:000061AE                 push    edx
.text:000061AF                 mov     eax, [ebp+var_4]
.text:000061B2                 mov     ecx, [eax+4]
.text:000061B5                 push    ecx
.text:000061B6                 call    ??$MyCompare@I@@YGHII@Z ; MyCompare<uint>(uint,uint)
.text:000061BB
.text:000061BB loc_61BB:                               ; CODE XREF: CExtrRefSortPair::Compare(CExtrRefSortPair const &)+32j
.text:000061BB                 add     esp, 8
.text:000061BE                 cmp     ebp, esp
.text:000061C0                 call    __RTC_CheckEsp
.text:000061C5                 mov     esp, ebp
.text:000061C7                 pop     ebp
.text:000061C8                 retn    4
.text:000061C8 ?Compare@CExtrRefSortPair@@QBEHABU1@@Z endp
.text:000061C8
.text:000061C8 ; ---------------------------------------------------------------------------
.text:000061CB                 db 9 dup(0CCh)
.text:000061D4
.text:000061D4 ; =============== S U B R O U T I N E =======================================
.text:000061D4
.text:000061D4 ; Attributes: bp-based frame
.text:000061D4
.text:000061D4 ; __int32 __thiscall CArchiveExtractCallback::SetDirsTimes(CArchiveExtractCallback *__hidden this)
.text:000061D4                 public ?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ
.text:000061D4 ?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ proc near
.text:000061D4
.text:000061D4 var_B4          = dword ptr -0B4h
.text:000061D4 var_B0          = dword ptr -0B0h
.text:000061D4 var_AC          = dword ptr -0ACh
.text:000061D4 var_A8          = dword ptr -0A8h
.text:000061D4 var_A4          = dword ptr -0A4h
.text:000061D4 var_A0          = dword ptr -0A0h
.text:000061D4 var_9C          = dword ptr -9Ch
.text:000061D4 var_98          = dword ptr -98h
.text:000061D4 var_94          = dword ptr -94h
.text:000061D4 var_90          = dword ptr -90h
.text:000061D4 var_8C          = dword ptr -8Ch
.text:000061D4 var_81          = byte ptr -81h
.text:000061D4 var_75          = byte ptr -75h
.text:000061D4 var_69          = byte ptr -69h
.text:000061D4 var_60          = _FILETIME ptr -60h
.text:000061D4 var_50          = _FILETIME ptr -50h
.text:000061D4 var_40          = _FILETIME ptr -40h
.text:000061D4 var_34          = dword ptr -34h
.text:000061D4 var_30          = dword ptr -30h
.text:000061D4 var_2C          = dword ptr -2Ch
.text:000061D4 var_28          = dword ptr -28h
.text:000061D4 var_20          = byte ptr -20h
.text:000061D4 var_10          = dword ptr -10h
.text:000061D4 var_C           = dword ptr -0Ch
.text:000061D4 var_4           = dword ptr -4
.text:000061D4
.text:000061D4                 push    ebp
.text:000061D5                 mov     ebp, esp
.text:000061D7                 push    0FFFFFFFFh
.text:000061D9                 push    offset __ehhandler$?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ
.text:000061DE                 mov     eax, large fs:0
.text:000061E4                 push    eax
.text:000061E5                 sub     esp, 0A8h
.text:000061EB                 push    edi
.text:000061EC                 push    ecx
.text:000061ED                 lea     edi, [ebp+var_B4]
.text:000061F3                 mov     ecx, 2Ah ; '*'
.text:000061F8                 mov     eax, 0CCCCCCCCh
.text:000061FD                 rep stosd
.text:000061FF                 pop     ecx
.text:00006200                 mov     eax, dword ptr ds:___security_cookie
.text:00006205                 xor     eax, ebp
.text:00006207                 push    eax             ; struct _FILETIME *
.text:00006208                 lea     eax, [ebp+var_C]
.text:0000620B                 mov     large fs:0, eax
.text:00006211                 mov     [ebp+var_10], ecx
.text:00006214                 lea     ecx, [ebp+var_20]
.text:00006217                 call    ??0?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ ; CRecordVector<CExtrRefSortPair>::CRecordVector<CExtrRefSortPair>(void)
.text:0000621C                 mov     [ebp+var_4], 0
.text:00006223                 mov     ecx, [ebp+var_10]
.text:00006226                 add     ecx, 144h
.text:0000622C                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00006231                 push    eax
.text:00006232                 lea     ecx, [ebp+var_20]
.text:00006235                 call    ?ClearAndSetSize@?$CRecordVector@UCExtrRefSortPair@@@@QAEXI@Z ; CRecordVector<CExtrRefSortPair>::ClearAndSetSize(uint)
.text:0000623A                 mov     [ebp+var_28], 0
.text:00006241                 jmp     short loc_624C
.text:00006243 ; ---------------------------------------------------------------------------
.text:00006243
.text:00006243 loc_6243:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+C7j
.text:00006243                 mov     eax, [ebp+var_28]
.text:00006246                 add     eax, 1
.text:00006249                 mov     [ebp+var_28], eax
.text:0000624C
.text:0000624C loc_624C:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+6Dj
.text:0000624C                 mov     ecx, [ebp+var_10]
.text:0000624F                 add     ecx, 144h
.text:00006255                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000625A                 cmp     [ebp+var_28], eax
.text:0000625D                 jnb     short loc_629D
.text:0000625F                 mov     ecx, [ebp+var_28]
.text:00006262                 push    ecx
.text:00006263                 lea     ecx, [ebp+var_20]
.text:00006266                 call    ??A?$CRecordVector@UCExtrRefSortPair@@@@QAEAAUCExtrRefSortPair@@I@Z ; CRecordVector<CExtrRefSortPair>::operator[](uint)
.text:0000626B                 mov     [ebp+var_2C], eax
.text:0000626E                 mov     edx, [ebp+var_2C]
.text:00006271                 mov     eax, [ebp+var_28]
.text:00006274                 mov     [edx+4], eax
.text:00006277                 mov     ecx, [ebp+var_28]
.text:0000627A                 push    ecx
.text:0000627B                 mov     ecx, [ebp+var_10]
.text:0000627E                 add     ecx, 144h
.text:00006284                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00006289                 mov     ecx, eax
.text:0000628B                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00006290                 push    eax
.text:00006291                 call    ?GetNumSlashes@@YGIPB_W@Z ; GetNumSlashes(wchar_t const *)
.text:00006296                 mov     edx, [ebp+var_2C]
.text:00006299                 mov     [edx], eax
.text:0000629B                 jmp     short loc_6243
.text:0000629D ; ---------------------------------------------------------------------------
.text:0000629D
.text:0000629D loc_629D:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+89j
.text:0000629D                 lea     ecx, [ebp+var_20]
.text:000062A0                 call    ?Sort2@?$CRecordVector@UCExtrRefSortPair@@@@QAEXXZ ; CRecordVector<CExtrRefSortPair>::Sort2(void)
.text:000062A5                 mov     [ebp+var_28], 0
.text:000062AC                 jmp     short loc_62B7
.text:000062AE ; ---------------------------------------------------------------------------
.text:000062AE
.text:000062AE loc_62AE:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+2EAj
.text:000062AE                 mov     eax, [ebp+var_28]
.text:000062B1                 add     eax, 1
.text:000062B4                 mov     [ebp+var_28], eax
.text:000062B7
.text:000062B7 loc_62B7:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+D8j
.text:000062B7                 lea     ecx, [ebp+var_20]
.text:000062BA                 call    ?Size@?$CRecordVector@UCExtrRefSortPair@@@@QBEIXZ ; CRecordVector<CExtrRefSortPair>::Size(void)
.text:000062BF                 cmp     [ebp+var_28], eax
.text:000062C2                 jnb     loc_64C3
.text:000062C8                 mov     ecx, [ebp+var_28]
.text:000062CB                 push    ecx
.text:000062CC                 lea     ecx, [ebp+var_20]
.text:000062CF                 call    ??A?$CRecordVector@UCExtrRefSortPair@@@@QAEAAUCExtrRefSortPair@@I@Z ; CRecordVector<CExtrRefSortPair>::operator[](uint)
.text:000062D4                 mov     edx, [eax+4]
.text:000062D7                 mov     [ebp+var_30], edx
.text:000062DA                 mov     eax, [ebp+var_30]
.text:000062DD                 push    eax
.text:000062DE                 mov     ecx, [ebp+var_10]
.text:000062E1                 add     ecx, 150h
.text:000062E7                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:000062EC                 mov     ecx, [eax]
.text:000062EE                 mov     [ebp+var_34], ecx
.text:000062F1                 lea     edx, [ebp+var_69]
.text:000062F4                 push    edx             ; bool *
.text:000062F5                 lea     eax, [ebp+var_40]
.text:000062F8                 push    eax             ; struct _FILETIME *
.text:000062F9                 push    0Ah             ; unsigned __int32
.text:000062FB                 mov     ecx, [ebp+var_34]
.text:000062FE                 push    ecx             ; int
.text:000062FF                 mov     ecx, [ebp+var_10] ; this
.text:00006302                 call    ?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z ; CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)
.text:00006307                 mov     [ebp+var_8C], eax
.text:0000630D                 cmp     [ebp+var_8C], 0
.text:00006314                 jz      short loc_633C
.text:00006316                 mov     edx, [ebp+var_8C]
.text:0000631C                 mov     [ebp+var_98], edx
.text:00006322                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006329                 lea     ecx, [ebp+var_20]
.text:0000632C                 call    ??1?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ ; CRecordVector<CExtrRefSortPair>::~CRecordVector<CExtrRefSortPair>(void)
.text:00006331                 mov     eax, [ebp+var_98]
.text:00006337                 jmp     loc_64E2
.text:0000633C ; ---------------------------------------------------------------------------
.text:0000633C
.text:0000633C loc_633C:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+140j
.text:0000633C                 lea     eax, [ebp+var_75]
.text:0000633F                 push    eax             ; bool *
.text:00006340                 lea     ecx, [ebp+var_50]
.text:00006343                 push    ecx             ; struct _FILETIME *
.text:00006344                 push    0Bh             ; unsigned __int32
.text:00006346                 mov     edx, [ebp+var_34]
.text:00006349                 push    edx             ; int
.text:0000634A                 mov     ecx, [ebp+var_10] ; this
.text:0000634D                 call    ?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z ; CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)
.text:00006352                 mov     [ebp+var_90], eax
.text:00006358                 cmp     [ebp+var_90], 0
.text:0000635F                 jz      short loc_6387
.text:00006361                 mov     eax, [ebp+var_90]
.text:00006367                 mov     [ebp+var_9C], eax
.text:0000636D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006374                 lea     ecx, [ebp+var_20]
.text:00006377                 call    ??1?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ ; CRecordVector<CExtrRefSortPair>::~CRecordVector<CExtrRefSortPair>(void)
.text:0000637C                 mov     eax, [ebp+var_9C]
.text:00006382                 jmp     loc_64E2
.text:00006387 ; ---------------------------------------------------------------------------
.text:00006387
.text:00006387 loc_6387:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+18Bj
.text:00006387                 lea     ecx, [ebp+var_81]
.text:0000638D                 push    ecx             ; bool *
.text:0000638E                 lea     edx, [ebp+var_60]
.text:00006391                 push    edx             ; struct _FILETIME *
.text:00006392                 push    0Ch             ; unsigned __int32
.text:00006394                 mov     eax, [ebp+var_34]
.text:00006397                 push    eax             ; int
.text:00006398                 mov     ecx, [ebp+var_10] ; this
.text:0000639B                 call    ?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z ; CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)
.text:000063A0                 mov     [ebp+var_94], eax
.text:000063A6                 cmp     [ebp+var_94], 0
.text:000063AD                 jz      short loc_63D5
.text:000063AF                 mov     ecx, [ebp+var_94]
.text:000063B5                 mov     [ebp+var_A0], ecx
.text:000063BB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000063C2                 lea     ecx, [ebp+var_20]
.text:000063C5                 call    ??1?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ ; CRecordVector<CExtrRefSortPair>::~CRecordVector<CExtrRefSortPair>(void)
.text:000063CA                 mov     eax, [ebp+var_A0]
.text:000063D0                 jmp     loc_64E2
.text:000063D5 ; ---------------------------------------------------------------------------
.text:000063D5
.text:000063D5 loc_63D5:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+1D9j
.text:000063D5                 mov     edx, [ebp+var_10]
.text:000063D8                 movzx   eax, byte ptr [edx+0C4h]
.text:000063DF                 test    eax, eax
.text:000063E1                 jz      short loc_63F9
.text:000063E3                 movzx   ecx, [ebp+var_81]
.text:000063EA                 test    ecx, ecx
.text:000063EC                 jz      short loc_63F9
.text:000063EE                 lea     edx, [ebp+var_60]
.text:000063F1                 mov     [ebp+var_A8], edx
.text:000063F7                 jmp     short loc_6434
.text:000063F9 ; ---------------------------------------------------------------------------
.text:000063F9
.text:000063F9 loc_63F9:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+20Dj
.text:000063F9                                         ; CArchiveExtractCallback::SetDirsTimes(void)+218j
.text:000063F9                 mov     eax, [ebp+var_10]
.text:000063FC                 mov     ecx, [eax+14h]
.text:000063FF                 movzx   edx, byte ptr [ecx+0A4h]
.text:00006406                 test    edx, edx
.text:00006408                 jz      short loc_641E
.text:0000640A                 mov     eax, [ebp+var_10]
.text:0000640D                 mov     ecx, [eax+14h]
.text:00006410                 add     ecx, 9Ch ; '£'
.text:00006416                 mov     [ebp+var_AC], ecx
.text:0000641C                 jmp     short loc_6428
.text:0000641E ; ---------------------------------------------------------------------------
.text:0000641E
.text:0000641E loc_641E:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+234j
.text:0000641E                 mov     [ebp+var_AC], 0
.text:00006428
.text:00006428 loc_6428:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+248j
.text:00006428                 mov     edx, [ebp+var_AC]
.text:0000642E                 mov     [ebp+var_A8], edx
.text:00006434
.text:00006434 loc_6434:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+223j
.text:00006434                 mov     eax, [ebp+var_10]
.text:00006437                 movzx   ecx, byte ptr [eax+0C3h]
.text:0000643E                 test    ecx, ecx
.text:00006440                 jz      short loc_6455
.text:00006442                 movzx   edx, [ebp+var_75]
.text:00006446                 test    edx, edx
.text:00006448                 jz      short loc_6455
.text:0000644A                 lea     eax, [ebp+var_50]
.text:0000644D                 mov     [ebp+var_B0], eax
.text:00006453                 jmp     short loc_645F
.text:00006455 ; ---------------------------------------------------------------------------
.text:00006455
.text:00006455 loc_6455:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+26Cj
.text:00006455                                         ; CArchiveExtractCallback::SetDirsTimes(void)+274j
.text:00006455                 mov     [ebp+var_B0], 0
.text:0000645F
.text:0000645F loc_645F:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+27Fj
.text:0000645F                 mov     ecx, [ebp+var_10]
.text:00006462                 movzx   edx, byte ptr [ecx+0C2h]
.text:00006469                 test    edx, edx
.text:0000646B                 jz      short loc_6480
.text:0000646D                 movzx   eax, [ebp+var_69]
.text:00006471                 test    eax, eax
.text:00006473                 jz      short loc_6480
.text:00006475                 lea     ecx, [ebp+var_40]
.text:00006478                 mov     [ebp+var_B4], ecx
.text:0000647E                 jmp     short loc_648A
.text:00006480 ; ---------------------------------------------------------------------------
.text:00006480
.text:00006480 loc_6480:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+297j
.text:00006480                                         ; CArchiveExtractCallback::SetDirsTimes(void)+29Fj
.text:00006480                 mov     [ebp+var_B4], 0
.text:0000648A
.text:0000648A loc_648A:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+2AAj
.text:0000648A                 mov     edx, [ebp+var_A8]
.text:00006490                 push    edx             ; struct _FILETIME *
.text:00006491                 mov     eax, [ebp+var_B0]
.text:00006497                 push    eax             ; struct _FILETIME *
.text:00006498                 mov     ecx, [ebp+var_B4]
.text:0000649E                 push    ecx             ; wchar_t *
.text:0000649F                 mov     edx, [ebp+var_30]
.text:000064A2                 push    edx
.text:000064A3                 mov     ecx, [ebp+var_10]
.text:000064A6                 add     ecx, 144h
.text:000064AC                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000064B1                 mov     ecx, eax
.text:000064B3                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000064B8                 push    eax             ; this
.text:000064B9                 call    ?SetDirTime@NDir@NFile@NWindows@@YG_NPB_WPBU_FILETIME@@11@Z ; NWindows::NFile::NDir::SetDirTime(wchar_t const *,_FILETIME const *,_FILETIME const *,_FILETIME const *)
.text:000064BE                 jmp     loc_62AE
.text:000064C3 ; ---------------------------------------------------------------------------
.text:000064C3
.text:000064C3 loc_64C3:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+EEj
.text:000064C3                 mov     [ebp+var_A4], 0
.text:000064CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000064D4                 lea     ecx, [ebp+var_20]
.text:000064D7                 call    ??1?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ ; CRecordVector<CExtrRefSortPair>::~CRecordVector<CExtrRefSortPair>(void)
.text:000064DC                 mov     eax, [ebp+var_A4]
.text:000064E2
.text:000064E2 loc_64E2:                               ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+163j
.text:000064E2                                         ; CArchiveExtractCallback::SetDirsTimes(void)+1AEj ...
.text:000064E2                 push    edx
.text:000064E3                 mov     ecx, ebp
.text:000064E5                 push    eax
.text:000064E6                 lea     edx, $LN30
.text:000064EC                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000064F1                 pop     eax
.text:000064F2                 pop     edx
.text:000064F3                 mov     ecx, [ebp+var_C]
.text:000064F6                 mov     large fs:0, ecx
.text:000064FD                 pop     ecx
.text:000064FE                 pop     edi
.text:000064FF                 add     esp, 0B4h
.text:00006505                 cmp     ebp, esp
.text:00006507                 call    __RTC_CheckEsp
.text:0000650C                 mov     esp, ebp
.text:0000650E                 pop     ebp
.text:0000650F                 retn
.text:0000650F ?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ endp ; sp-analysis failed
.text:0000650F
.text:0000650F ; ---------------------------------------------------------------------------
.text:00006510 $LN30           dd 7                    ; DATA XREF: CArchiveExtractCallback::SetDirsTimes(void)+312o
.text:00006514                 dd offset $LN29
.text:00006518 $LN29           dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:00006514o
.text:00006520                 dd offset $LN21         ; "pairs"
.text:00006524                 dd 0FFFFFFC0h, 8
.text:0000652C                 dd offset $LN22         ; "CTime"
.text:00006530                 dd 0FFFFFFB0h, 8
.text:00006538                 dd offset $LN23_0       ; "ATime"
.text:0000653C                 dd 0FFFFFFA0h, 8
.text:00006544                 dd offset $LN24_0       ; "MTime"
.text:00006548                 dd 0FFFFFF97h, 1
.text:00006550                 dd offset $LN25_0       ; "CTimeDefined"
.text:00006554                 db 8Bh, 0FFh
.text:00006556                 dw 0FFFFh
.text:00006558                 dd 1
.text:0000655C                 dd offset $LN26_0       ; "ATimeDefined"
.text:00006560                 dd 0FFFFFF7Fh, 1
.text:00006568                 dd offset $LN27_0       ; "MTimeDefined"
.text:0000656C $LN27_0         db 'MTimeDefined',0     ; DATA XREF: .text:00006568o
.text:00006579 $LN26_0         db 'ATimeDefined',0     ; DATA XREF: .text:0000655Co
.text:00006586 $LN25_0         db 'CTimeDefined',0     ; DATA XREF: .text:00006550o
.text:00006593 $LN24_0         db 'MTime',0            ; DATA XREF: .text:00006544o
.text:00006599 $LN23_0         db 'ATime',0            ; DATA XREF: .text:00006538o
.text:0000659F $LN22           db 'CTime',0            ; DATA XREF: .text:0000652Co
.text:000065A5 $LN21           db 'pairs',0            ; DATA XREF: .text:00006520o
.text:000065AB                 db 9 dup(0CCh)
.text:000065B4
.text:000065B4 ; =============== S U B R O U T I N E =======================================
.text:000065B4
.text:000065B4 ; Attributes: bp-based frame
.text:000065B4
.text:000065B4 ; unsigned int __stdcall GetNumSlashes(wchar_t const *)
.text:000065B4 ?GetNumSlashes@@YGIPB_W@Z proc near     ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+BDp
.text:000065B4
.text:000065B4 var_8           = dword ptr -8
.text:000065B4 var_4           = dword ptr -4
.text:000065B4 arg_0           = dword ptr  8
.text:000065B4
.text:000065B4                 push    ebp
.text:000065B5                 mov     ebp, esp
.text:000065B7                 sub     esp, 8
.text:000065BA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000065C1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000065C8                 mov     [ebp+var_4], 0
.text:000065CF
.text:000065CF loc_65CF:                               ; CODE XREF: GetNumSlashes(wchar_t const *):loc_660Aj
.text:000065CF                 mov     eax, [ebp+arg_0]
.text:000065D2                 mov     cx, [eax]
.text:000065D5                 mov     word ptr [ebp+var_8], cx
.text:000065D9                 mov     edx, [ebp+arg_0]
.text:000065DC                 add     edx, 2
.text:000065DF                 mov     [ebp+arg_0], edx
.text:000065E2                 movzx   eax, word ptr [ebp+var_8]
.text:000065E6                 test    eax, eax
.text:000065E8                 jnz     short loc_65EF
.text:000065EA                 mov     eax, [ebp+var_4]
.text:000065ED                 jmp     short loc_660C
.text:000065EF ; ---------------------------------------------------------------------------
.text:000065EF
.text:000065EF loc_65EF:                               ; CODE XREF: GetNumSlashes(wchar_t const *)+34j
.text:000065EF                 movzx   ecx, word ptr [ebp+var_8]
.text:000065F3                 cmp     ecx, 5Ch ; '\'
.text:000065F6                 jz      short loc_6601
.text:000065F8                 movzx   edx, word ptr [ebp+var_8]
.text:000065FC                 cmp     edx, 2Fh ; '/'
.text:000065FF                 jnz     short loc_660A
.text:00006601
.text:00006601 loc_6601:                               ; CODE XREF: GetNumSlashes(wchar_t const *)+42j
.text:00006601                 mov     eax, [ebp+var_4]
.text:00006604                 add     eax, 1
.text:00006607                 mov     [ebp+var_4], eax
.text:0000660A
.text:0000660A loc_660A:                               ; CODE XREF: GetNumSlashes(wchar_t const *)+4Bj
.text:0000660A                 jmp     short loc_65CF
.text:0000660C ; ---------------------------------------------------------------------------
.text:0000660C
.text:0000660C loc_660C:                               ; CODE XREF: GetNumSlashes(wchar_t const *)+39j
.text:0000660C                 mov     esp, ebp
.text:0000660E                 pop     ebp
.text:0000660F                 retn    4
.text:0000660F ?GetNumSlashes@@YGIPB_W@Z endp
.text:0000660F
.text:0000660F ; ---------------------------------------------------------------------------
.text:00006612                 align 4
.text:00006612 _text           ends
.text:00006612
.rtc$TMZ:00006614 ; ===========================================================================
.rtc$TMZ:00006614
.rtc$TMZ:00006614 ; Segment type: Pure data
.rtc$TMZ:00006614 ; Segment permissions: Read
.rtc$TMZ:00006614 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00006614                 assume cs:_rtc$TMZ
.rtc$TMZ:00006614                 ;org 6614h
.rtc$TMZ:00006614 ; COMDAT (pick any)
.rtc$TMZ:00006614 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00006614 _rtc$TMZ        ends
.rtc$TMZ:00006614
.rtc$IMZ:00006618 ; ===========================================================================
.rtc$IMZ:00006618
.rtc$IMZ:00006618 ; Segment type: Pure data
.rtc$IMZ:00006618 ; Segment permissions: Read
.rtc$IMZ:00006618 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00006618                 assume cs:_rtc$IMZ
.rtc$IMZ:00006618                 ;org 6618h
.rtc$IMZ:00006618 ; COMDAT (pick any)
.rtc$IMZ:00006618 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00006618 _rtc$IMZ        ends
.rtc$IMZ:00006618
.text$x:0000661C ; ===========================================================================
.text$x:0000661C
.text$x:0000661C ; Segment type: Pure code
.text$x:0000661C ; Segment permissions: Read/Execute
.text$x:0000661C _text$x         segment para public 'CODE' use32
.text$x:0000661C                 assume cs:_text$x
.text$x:0000661C                 ;org 661Ch
.text$x:0000661C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000661C
.text$x:0000661C ; =============== S U B R O U T I N E =======================================
.text$x:0000661C
.text$x:0000661C
.text$x:0000661C __unwindfunclet$?InitLocalPrivileges@@YG_NXZ$0 proc near
.text$x:0000661C                                         ; DATA XREF: .xdata$x:00006B50o
.text$x:0000661C                 lea     ecx, [ebp-18h]  ; this
.text$x:0000661F                 jmp     ??1CAccessToken@NSecurity@NWindows@@QAE@XZ ; NWindows::NSecurity::CAccessToken::~CAccessToken(void)
.text$x:0000661F __unwindfunclet$?InitLocalPrivileges@@YG_NXZ$0 endp
.text$x:0000661F
.text$x:00006624
.text$x:00006624 ; =============== S U B R O U T I N E =======================================
.text$x:00006624
.text$x:00006624
.text$x:00006624 __ehhandler$?InitLocalPrivileges@@YG_NXZ proc near
.text$x:00006624                                         ; DATA XREF: InitLocalPrivileges(void)+5o
.text$x:00006624
.text$x:00006624 arg_4           = dword ptr  8
.text$x:00006624
.text$x:00006624                 mov     edx, [esp+arg_4]
.text$x:00006628                 lea     eax, [edx+0Ch]
.text$x:0000662B                 mov     ecx, [edx-38h]
.text$x:0000662E                 xor     ecx, eax
.text$x:00006630                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006635                 mov     ecx, [edx-4]
.text$x:00006638                 xor     ecx, eax
.text$x:0000663A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000663F                 mov     eax, offset __ehfuncinfo$?InitLocalPrivileges@@YG_NXZ
.text$x:00006644                 jmp     ___CxxFrameHandler3
.text$x:00006644 __ehhandler$?InitLocalPrivileges@@YG_NXZ endp
.text$x:00006644
.text$x:00006649
.text$x:00006649 ; =============== S U B R O U T I N E =======================================
.text$x:00006649
.text$x:00006649
.text$x:00006649 __unwindfunclet$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z$0 proc near
.text$x:00006649                                         ; DATA XREF: .xdata$x:00006B7Co
.text$x:00006649                 lea     ecx, [ebp-20h]  ; this
.text$x:0000664C                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:0000664C __unwindfunclet$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z$0 endp
.text$x:0000664C
.text$x:00006651
.text$x:00006651 ; =============== S U B R O U T I N E =======================================
.text$x:00006651
.text$x:00006651
.text$x:00006651 __unwindfunclet$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z$1 proc near
.text$x:00006651                                         ; DATA XREF: .xdata$x:00006B84o
.text$x:00006651                 lea     ecx, [ebp-3Ch]  ; this
.text$x:00006654                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00006654 __unwindfunclet$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z$1 endp
.text$x:00006654
.text$x:00006659
.text$x:00006659 ; =============== S U B R O U T I N E =======================================
.text$x:00006659
.text$x:00006659
.text$x:00006659 __ehhandler$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z proc near
.text$x:00006659                                         ; DATA XREF: Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+5o
.text$x:00006659
.text$x:00006659 arg_4           = dword ptr  8
.text$x:00006659
.text$x:00006659                 mov     edx, [esp+arg_4]
.text$x:0000665D                 lea     eax, [edx+0Ch]
.text$x:00006660                 mov     ecx, [edx-50h]
.text$x:00006663                 xor     ecx, eax
.text$x:00006665                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000666A                 mov     eax, offset __ehfuncinfo$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z
.text$x:0000666F                 jmp     ___CxxFrameHandler3
.text$x:0000666F __ehhandler$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z endp
.text$x:0000666F
.text$x:00006674
.text$x:00006674 ; =============== S U B R O U T I N E =======================================
.text$x:00006674
.text$x:00006674
.text$x:00006674 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$0 proc near
.text$x:00006674                                         ; DATA XREF: .xdata$x:00006BD4o
.text$x:00006674                 mov     ecx, [ebp-10h]
.text$x:00006677                 add     ecx, 28h ; '('
.text$x:0000667A                 jmp     ??1?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::~CMyComPtr<IFolderArchiveExtractCallback>(void)
.text$x:0000667A __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$0 endp
.text$x:0000667A
.text$x:0000667F
.text$x:0000667F ; =============== S U B R O U T I N E =======================================
.text$x:0000667F
.text$x:0000667F
.text$x:0000667F __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$1 proc near
.text$x:0000667F                                         ; DATA XREF: .xdata$x:00006BDCo
.text$x:0000667F                 mov     ecx, [ebp-10h]
.text$x:00006682                 add     ecx, 2Ch ; ','
.text$x:00006685                 jmp     ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text$x:00006685 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$1 endp
.text$x:00006685
.text$x:0000668A
.text$x:0000668A ; =============== S U B R O U T I N E =======================================
.text$x:0000668A
.text$x:0000668A
.text$x:0000668A __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$2 proc near
.text$x:0000668A                                         ; DATA XREF: .xdata$x:00006BE4o
.text$x:0000668A                 mov     ecx, [ebp-10h]
.text$x:0000668D                 add     ecx, 30h ; '0'
.text$x:00006690                 jmp     ??1?$CMyComPtr@UICryptoGetTextPassword@@@@QAE@XZ ; CMyComPtr<ICryptoGetTextPassword>::~CMyComPtr<ICryptoGetTextPassword>(void)
.text$x:00006690 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$2 endp
.text$x:00006690
.text$x:00006695
.text$x:00006695 ; =============== S U B R O U T I N E =======================================
.text$x:00006695
.text$x:00006695
.text$x:00006695 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$3 proc near
.text$x:00006695                                         ; DATA XREF: .xdata$x:00006BECo
.text$x:00006695                 mov     ecx, [ebp-10h]
.text$x:00006698                 add     ecx, 34h ; '4'
.text$x:0000669B                 jmp     ??1?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallbackMessage>::~CMyComPtr<IArchiveExtractCallbackMessage>(void)
.text$x:0000669B __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$3 endp
.text$x:0000669B
.text$x:000066A0
.text$x:000066A0 ; =============== S U B R O U T I N E =======================================
.text$x:000066A0
.text$x:000066A0
.text$x:000066A0 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$4 proc near
.text$x:000066A0                                         ; DATA XREF: .xdata$x:00006BF4o
.text$x:000066A0                 mov     ecx, [ebp-10h]
.text$x:000066A3                 add     ecx, 38h ; '8'
.text$x:000066A6                 jmp     ??1?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAE@XZ ; CMyComPtr<IFolderArchiveExtractCallback2>::~CMyComPtr<IFolderArchiveExtractCallback2>(void)
.text$x:000066A6 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$4 endp
.text$x:000066A6
.text$x:000066AB
.text$x:000066AB ; =============== S U B R O U T I N E =======================================
.text$x:000066AB
.text$x:000066AB
.text$x:000066AB __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$5 proc near
.text$x:000066AB                                         ; DATA XREF: .xdata$x:00006BFCo
.text$x:000066AB                 mov     ecx, [ebp-10h]
.text$x:000066AE                 add     ecx, 3Ch ; '<'  ; this
.text$x:000066B1                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000066B1 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$5 endp
.text$x:000066B1
.text$x:000066B6
.text$x:000066B6 ; =============== S U B R O U T I N E =======================================
.text$x:000066B6
.text$x:000066B6
.text$x:000066B6 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$6 proc near
.text$x:000066B6                                         ; DATA XREF: .xdata$x:00006C04o
.text$x:000066B6                 mov     ecx, [ebp-10h]
.text$x:000066B9                 add     ecx, 48h ; 'H'  ; this
.text$x:000066BC                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000066BC __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$6 endp
.text$x:000066BC
.text$x:000066C1
.text$x:000066C1 ; =============== S U B R O U T I N E =======================================
.text$x:000066C1
.text$x:000066C1
.text$x:000066C1 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$7 proc near
.text$x:000066C1                                         ; DATA XREF: .xdata$x:00006C0Co
.text$x:000066C1                 mov     ecx, [ebp-10h]
.text$x:000066C4                 add     ecx, 5Ch ; '\'
.text$x:000066C7                 jmp     ??1?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAE@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::~CMyComPtr<IFolderExtractToStreamCallback>(void)
.text$x:000066C7 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$7 endp
.text$x:000066C7
.text$x:000066CC
.text$x:000066CC ; =============== S U B R O U T I N E =======================================
.text$x:000066CC
.text$x:000066CC
.text$x:000066CC __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$8 proc near
.text$x:000066CC                                         ; DATA XREF: .xdata$x:00006C14o
.text$x:000066CC                 mov     ecx, [ebp-10h]
.text$x:000066CF                 add     ecx, 64h ; 'd'
.text$x:000066D2                 jmp     ??1?$CMyComPtr@UIGetProp@@@@QAE@XZ ; CMyComPtr<IGetProp>::~CMyComPtr<IGetProp>(void)
.text$x:000066D2 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$8 endp
.text$x:000066D2
.text$x:000066D7
.text$x:000066D7 ; =============== S U B R O U T I N E =======================================
.text$x:000066D7
.text$x:000066D7
.text$x:000066D7 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$9 proc near
.text$x:000066D7                                         ; DATA XREF: .xdata$x:00006C1Co
.text$x:000066D7                 mov     ecx, [ebp-10h]
.text$x:000066DA                 add     ecx, 68h ; 'h'  ; this
.text$x:000066DD                 jmp     ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text$x:000066DD __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$9 endp
.text$x:000066DD
.text$x:000066E2
.text$x:000066E2 ; =============== S U B R O U T I N E =======================================
.text$x:000066E2
.text$x:000066E2
.text$x:000066E2 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$10 proc near
.text$x:000066E2                                         ; DATA XREF: .xdata$x:00006C24o
.text$x:000066E2                 mov     ecx, [ebp-10h]
.text$x:000066E5                 add     ecx, 0A8h ; '¿' ; this
.text$x:000066EB                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000066EB __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$10 endp
.text$x:000066EB
.text$x:000066F0
.text$x:000066F0 ; =============== S U B R O U T I N E =======================================
.text$x:000066F0
.text$x:000066F0
.text$x:000066F0 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$11 proc near
.text$x:000066F0                                         ; DATA XREF: .xdata$x:00006C2Co
.text$x:000066F0                 mov     ecx, [ebp-10h]
.text$x:000066F3                 add     ecx, 100h
.text$x:000066F9                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:000066F9 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$11 endp
.text$x:000066F9
.text$x:000066FE
.text$x:000066FE ; =============== S U B R O U T I N E =======================================
.text$x:000066FE
.text$x:000066FE
.text$x:000066FE __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$12 proc near
.text$x:000066FE                                         ; DATA XREF: .xdata$x:00006C34o
.text$x:000066FE                 mov     ecx, [ebp-10h]
.text$x:00006701                 add     ecx, 108h
.text$x:00006707                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:00006707 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$12 endp
.text$x:00006707
.text$x:0000670C
.text$x:0000670C ; =============== S U B R O U T I N E =======================================
.text$x:0000670C
.text$x:0000670C
.text$x:0000670C __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$13 proc near
.text$x:0000670C                                         ; DATA XREF: .xdata$x:00006C3Co
.text$x:0000670C                 mov     ecx, [ebp-10h]
.text$x:0000670F                 add     ecx, 110h
.text$x:00006715                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00006715 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$13 endp
.text$x:00006715
.text$x:0000671A
.text$x:0000671A ; =============== S U B R O U T I N E =======================================
.text$x:0000671A
.text$x:0000671A
.text$x:0000671A __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$14 proc near
.text$x:0000671A                                         ; DATA XREF: .xdata$x:00006C44o
.text$x:0000671A                 mov     ecx, [ebp-10h]
.text$x:0000671D                 add     ecx, 128h
.text$x:00006723                 jmp     ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text$x:00006723 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$14 endp
.text$x:00006723
.text$x:00006728
.text$x:00006728 ; =============== S U B R O U T I N E =======================================
.text$x:00006728
.text$x:00006728
.text$x:00006728 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$15 proc near
.text$x:00006728                                         ; DATA XREF: .xdata$x:00006C4Co
.text$x:00006728                 mov     ecx, [ebp-10h]
.text$x:0000672B                 add     ecx, 144h
.text$x:00006731                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00006731 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$15 endp
.text$x:00006731
.text$x:00006736
.text$x:00006736 ; =============== S U B R O U T I N E =======================================
.text$x:00006736
.text$x:00006736
.text$x:00006736 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$16 proc near
.text$x:00006736                                         ; DATA XREF: .xdata$x:00006C54o
.text$x:00006736                 mov     ecx, [ebp-10h]
.text$x:00006739                 add     ecx, 150h
.text$x:0000673F                 jmp     ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text$x:0000673F __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$16 endp
.text$x:0000673F
.text$x:00006744
.text$x:00006744 ; =============== S U B R O U T I N E =======================================
.text$x:00006744
.text$x:00006744
.text$x:00006744 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$17 proc near
.text$x:00006744                                         ; DATA XREF: .xdata$x:00006C5Co
.text$x:00006744                 mov     ecx, [ebp-10h]
.text$x:00006747                 add     ecx, 190h       ; this
.text$x:0000674D                 jmp     ??1CHardLinks@@QAE@XZ ; CHardLinks::~CHardLinks(void)
.text$x:0000674D __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$17 endp
.text$x:0000674D
.text$x:00006752
.text$x:00006752 ; =============== S U B R O U T I N E =======================================
.text$x:00006752
.text$x:00006752
.text$x:00006752 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$18 proc near
.text$x:00006752                                         ; DATA XREF: .xdata$x:00006C64o
.text$x:00006752                 mov     ecx, [ebp-10h]
.text$x:00006755                 add     ecx, 1A8h
.text$x:0000675B                 jmp     ??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ ; CObjectVector<CIndexToPathPair>::~CObjectVector<CIndexToPathPair>(void)
.text$x:0000675B __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$18 endp
.text$x:0000675B
.text$x:00006760
.text$x:00006760 ; =============== S U B R O U T I N E =======================================
.text$x:00006760
.text$x:00006760
.text$x:00006760 __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$19 proc near
.text$x:00006760                                         ; DATA XREF: .xdata$x:00006C6Co
.text$x:00006760                 mov     eax, [ebp-18h]
.text$x:00006763                 push    eax             ; void *
.text$x:00006764                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00006769                 pop     ecx
.text$x:0000676A                 retn
.text$x:0000676A __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$19 endp
.text$x:0000676A
.text$x:0000676B
.text$x:0000676B ; =============== S U B R O U T I N E =======================================
.text$x:0000676B
.text$x:0000676B
.text$x:0000676B __ehhandler$??0CArchiveExtractCallback@@QAE@XZ proc near
.text$x:0000676B                                         ; DATA XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+5o
.text$x:0000676B
.text$x:0000676B arg_4           = dword ptr  8
.text$x:0000676B
.text$x:0000676B                 mov     edx, [esp+arg_4]
.text$x:0000676F                 lea     eax, [edx+0Ch]
.text$x:00006772                 mov     ecx, [edx-14h]
.text$x:00006775                 xor     ecx, eax
.text$x:00006777                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000677C                 mov     eax, offset __ehfuncinfo$??0CArchiveExtractCallback@@QAE@XZ
.text$x:00006781                 jmp     ___CxxFrameHandler3
.text$x:00006781 __ehhandler$??0CArchiveExtractCallback@@QAE@XZ endp
.text$x:00006781
.text$x:00006786
.text$x:00006786 ; =============== S U B R O U T I N E =======================================
.text$x:00006786
.text$x:00006786
.text$x:00006786 __ehhandler$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z proc near
.text$x:00006786                                         ; DATA XREF: CArchiveExtractCallback::SetTotal(unsigned __int64)+5o
.text$x:00006786
.text$x:00006786 arg_4           = dword ptr  8
.text$x:00006786
.text$x:00006786                 mov     edx, [esp+arg_4]
.text$x:0000678A                 lea     eax, [edx+0Ch]
.text$x:0000678D                 mov     ecx, [edx-28h]
.text$x:00006790                 xor     ecx, eax
.text$x:00006792                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006797                 mov     eax, offset __ehfuncinfo$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z
.text$x:0000679C                 jmp     ___CxxFrameHandler3
.text$x:0000679C __ehhandler$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z endp
.text$x:0000679C
.text$x:000067A1
.text$x:000067A1 ; =============== S U B R O U T I N E =======================================
.text$x:000067A1
.text$x:000067A1
.text$x:000067A1 __ehhandler$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z proc near
.text$x:000067A1                                         ; DATA XREF: CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)+5o
.text$x:000067A1
.text$x:000067A1 arg_4           = dword ptr  8
.text$x:000067A1
.text$x:000067A1                 mov     edx, [esp+arg_4]
.text$x:000067A5                 lea     eax, [edx+0Ch]
.text$x:000067A8                 mov     ecx, [edx-40h]
.text$x:000067AB                 xor     ecx, eax
.text$x:000067AD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000067B2                 mov     eax, offset __ehfuncinfo$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z
.text$x:000067B7                 jmp     ___CxxFrameHandler3
.text$x:000067B7 __ehhandler$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z endp
.text$x:000067B7
.text$x:000067BC
.text$x:000067BC ; =============== S U B R O U T I N E =======================================
.text$x:000067BC
.text$x:000067BC
.text$x:000067BC __ehhandler$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z proc near
.text$x:000067BC                                         ; DATA XREF: CArchiveExtractCallback::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+5o
.text$x:000067BC
.text$x:000067BC arg_4           = dword ptr  8
.text$x:000067BC
.text$x:000067BC                 mov     edx, [esp+arg_4]
.text$x:000067C0                 lea     eax, [edx+0Ch]
.text$x:000067C3                 mov     ecx, [edx-24h]
.text$x:000067C6                 xor     ecx, eax
.text$x:000067C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000067CD                 mov     eax, offset __ehfuncinfo$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z
.text$x:000067D2                 jmp     ___CxxFrameHandler3
.text$x:000067D2 __ehhandler$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z endp
.text$x:000067D2
.text$x:000067D7
.text$x:000067D7 ; =============== S U B R O U T I N E =======================================
.text$x:000067D7
.text$x:000067D7
.text$x:000067D7 __unwindfunclet$?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z$0 proc near
.text$x:000067D7                                         ; DATA XREF: .xdata$x:00006D7Co
.text$x:000067D7                 lea     ecx, [ebp-24h]  ; this
.text$x:000067DA                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:000067DA __unwindfunclet$?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z$0 endp
.text$x:000067DA
.text$x:000067DF
.text$x:000067DF ; =============== S U B R O U T I N E =======================================
.text$x:000067DF
.text$x:000067DF
.text$x:000067DF __ehhandler$?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z proc near
.text$x:000067DF                                         ; DATA XREF: CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+5o
.text$x:000067DF
.text$x:000067DF arg_4           = dword ptr  8
.text$x:000067DF
.text$x:000067DF                 mov     edx, [esp+arg_4]
.text$x:000067E3                 lea     eax, [edx+0Ch]
.text$x:000067E6                 mov     ecx, [edx-40h]
.text$x:000067E9                 xor     ecx, eax
.text$x:000067EB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000067F0                 mov     eax, offset __ehfuncinfo$?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z
.text$x:000067F5                 jmp     ___CxxFrameHandler3
.text$x:000067F5 __ehhandler$?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z endp
.text$x:000067F5
.text$x:000067FA
.text$x:000067FA ; =============== S U B R O U T I N E =======================================
.text$x:000067FA
.text$x:000067FA
.text$x:000067FA __unwindfunclet$?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z$0 proc near
.text$x:000067FA                                         ; DATA XREF: .xdata$x:00006DA8o
.text$x:000067FA                 lea     ecx, [ebp-20h]  ; this
.text$x:000067FD                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000067FD __unwindfunclet$?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z$0 endp
.text$x:000067FD
.text$x:00006802
.text$x:00006802 ; =============== S U B R O U T I N E =======================================
.text$x:00006802
.text$x:00006802
.text$x:00006802 __ehhandler$?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z proc near
.text$x:00006802                                         ; DATA XREF: CArchiveExtractCallback::SendMessageError(char const *,UString const &)+5o
.text$x:00006802
.text$x:00006802 arg_4           = dword ptr  8
.text$x:00006802
.text$x:00006802                 mov     edx, [esp+arg_4]
.text$x:00006806                 lea     eax, [edx+0Ch]
.text$x:00006809                 mov     ecx, [edx-28h]
.text$x:0000680C                 xor     ecx, eax
.text$x:0000680E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006813                 mov     eax, offset __ehfuncinfo$?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z
.text$x:00006818                 jmp     ___CxxFrameHandler3
.text$x:00006818 __ehhandler$?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z endp
.text$x:00006818
.text$x:0000681D
.text$x:0000681D ; =============== S U B R O U T I N E =======================================
.text$x:0000681D
.text$x:0000681D
.text$x:0000681D __unwindfunclet$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z$0 proc near
.text$x:0000681D                                         ; DATA XREF: .xdata$x:00006DD4o
.text$x:0000681D                 lea     ecx, [ebp-24h]  ; this
.text$x:00006820                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006820 __unwindfunclet$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z$0 endp
.text$x:00006820
.text$x:00006825
.text$x:00006825 ; =============== S U B R O U T I N E =======================================
.text$x:00006825
.text$x:00006825
.text$x:00006825 __unwindfunclet$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z$1 proc near
.text$x:00006825                                         ; DATA XREF: .xdata$x:00006DDCo
.text$x:00006825                 lea     ecx, [ebp-34h]  ; this
.text$x:00006828                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006828 __unwindfunclet$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z$1 endp
.text$x:00006828
.text$x:0000682D
.text$x:0000682D ; =============== S U B R O U T I N E =======================================
.text$x:0000682D
.text$x:0000682D
.text$x:0000682D __ehhandler$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z proc near
.text$x:0000682D                                         ; DATA XREF: CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)+5o
.text$x:0000682D
.text$x:0000682D arg_4           = dword ptr  8
.text$x:0000682D
.text$x:0000682D                 mov     edx, [esp+arg_4]
.text$x:00006831                 lea     eax, [edx+0Ch]
.text$x:00006834                 mov     ecx, [edx-44h]
.text$x:00006837                 xor     ecx, eax
.text$x:00006839                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000683E                 mov     eax, offset __ehfuncinfo$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z
.text$x:00006843                 jmp     ___CxxFrameHandler3
.text$x:00006843 __ehhandler$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z endp
.text$x:00006843
.text$x:00006848
.text$x:00006848 ; =============== S U B R O U T I N E =======================================
.text$x:00006848
.text$x:00006848
.text$x:00006848 __unwindfunclet$?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z$0 proc near
.text$x:00006848                                         ; DATA XREF: .xdata$x:00006E08o
.text$x:00006848                 lea     ecx, [ebp-20h]  ; this
.text$x:0000684B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000684B __unwindfunclet$?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z$0 endp
.text$x:0000684B
.text$x:00006850
.text$x:00006850 ; =============== S U B R O U T I N E =======================================
.text$x:00006850
.text$x:00006850
.text$x:00006850 __ehhandler$?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z proc near
.text$x:00006850                                         ; DATA XREF: CArchiveExtractCallback::SendMessageError2(char const *,UString const &,UString const &)+5o
.text$x:00006850
.text$x:00006850 arg_4           = dword ptr  8
.text$x:00006850
.text$x:00006850                 mov     edx, [esp+arg_4]
.text$x:00006854                 lea     eax, [edx+0Ch]
.text$x:00006857                 mov     ecx, [edx-28h]
.text$x:0000685A                 xor     ecx, eax
.text$x:0000685C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006861                 mov     eax, offset __ehfuncinfo$?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z
.text$x:00006866                 jmp     ___CxxFrameHandler3
.text$x:00006866 __ehhandler$?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z endp
.text$x:00006866
.text$x:0000686B
.text$x:0000686B ; =============== S U B R O U T I N E =======================================
.text$x:0000686B
.text$x:0000686B
.text$x:0000686B __unwindfunclet$?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z$0 proc near
.text$x:0000686B                                         ; DATA XREF: .xdata$x:00006E34o
.text$x:0000686B                 lea     ecx, [ebp-20h]
.text$x:0000686E                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:0000686E __unwindfunclet$?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z$0 endp
.text$x:0000686E
.text$x:00006873
.text$x:00006873 ; =============== S U B R O U T I N E =======================================
.text$x:00006873
.text$x:00006873
.text$x:00006873 __ehhandler$?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z proc near
.text$x:00006873                                         ; DATA XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+5o
.text$x:00006873
.text$x:00006873 arg_4           = dword ptr  8
.text$x:00006873
.text$x:00006873                 mov     edx, [esp+arg_4]
.text$x:00006877                 lea     eax, [edx+0Ch]
.text$x:0000687A                 mov     ecx, [edx-34h]
.text$x:0000687D                 xor     ecx, eax
.text$x:0000687F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006884                 mov     eax, offset __ehfuncinfo$?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z
.text$x:00006889                 jmp     ___CxxFrameHandler3
.text$x:00006889 __ehhandler$?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z endp
.text$x:00006889
.text$x:0000688E
.text$x:0000688E ; =============== S U B R O U T I N E =======================================
.text$x:0000688E
.text$x:0000688E
.text$x:0000688E __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$2 proc near
.text$x:0000688E                                         ; DATA XREF: .xdata$x:00006EB0o
.text$x:0000688E                 lea     ecx, [ebp-30h]  ; this
.text$x:00006891                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00006891 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$2 endp
.text$x:00006891
.text$x:00006896
.text$x:00006896 ; =============== S U B R O U T I N E =======================================
.text$x:00006896
.text$x:00006896
.text$x:00006896 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$3 proc near
.text$x:00006896                                         ; DATA XREF: .xdata$x:00006EB8o
.text$x:00006896                 lea     ecx, [ebp-4Ch]  ; this
.text$x:00006899                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006899 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$3 endp
.text$x:00006899
.text$x:0000689E
.text$x:0000689E ; =============== S U B R O U T I N E =======================================
.text$x:0000689E
.text$x:0000689E
.text$x:0000689E __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$4 proc near
.text$x:0000689E                                         ; DATA XREF: .xdata$x:00006EC0o
.text$x:0000689E                 lea     ecx, [ebp-64h]  ; this
.text$x:000068A1                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:000068A1 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$4 endp
.text$x:000068A1
.text$x:000068A6
.text$x:000068A6 ; =============== S U B R O U T I N E =======================================
.text$x:000068A6
.text$x:000068A6
.text$x:000068A6 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$5 proc near
.text$x:000068A6                                         ; DATA XREF: .xdata$x:00006EC8o
.text$x:000068A6                 lea     ecx, [ebp-80h]  ; this
.text$x:000068A9                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:000068A9 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$5 endp
.text$x:000068A9
.text$x:000068AE
.text$x:000068AE ; =============== S U B R O U T I N E =======================================
.text$x:000068AE
.text$x:000068AE
.text$x:000068AE __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$6 proc near
.text$x:000068AE                                         ; DATA XREF: .xdata$x:00006ED0o
.text$x:000068AE                 lea     ecx, [ebp-0C0h] ; this
.text$x:000068B4                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000068B4 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$6 endp
.text$x:000068B4
.text$x:000068B9
.text$x:000068B9 ; =============== S U B R O U T I N E =======================================
.text$x:000068B9
.text$x:000068B9
.text$x:000068B9 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$7 proc near
.text$x:000068B9                                         ; DATA XREF: .xdata$x:00006ED8o
.text$x:000068B9                 lea     ecx, [ebp-0E8h] ; this
.text$x:000068BF                 jmp     ??1CReparseAttr@NFile@NWindows@@QAE@XZ ; NWindows::NFile::CReparseAttr::~CReparseAttr(void)
.text$x:000068BF __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$7 endp
.text$x:000068BF
.text$x:000068C4
.text$x:000068C4 ; =============== S U B R O U T I N E =======================================
.text$x:000068C4
.text$x:000068C4
.text$x:000068C4 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$8 proc near
.text$x:000068C4                                         ; DATA XREF: .xdata$x:00006EE0o
.text$x:000068C4                 lea     ecx, [ebp-404h] ; this
.text$x:000068CA                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000068CA __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$8 endp
.text$x:000068CA
.text$x:000068CF
.text$x:000068CF ; =============== S U B R O U T I N E =======================================
.text$x:000068CF
.text$x:000068CF
.text$x:000068CF __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$9 proc near
.text$x:000068CF                                         ; DATA XREF: .xdata$x:00006EE8o
.text$x:000068CF                 lea     ecx, [ebp-100h]
.text$x:000068D5                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:000068D5 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$9 endp
.text$x:000068D5
.text$x:000068DA
.text$x:000068DA ; =============== S U B R O U T I N E =======================================
.text$x:000068DA
.text$x:000068DA
.text$x:000068DA __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$10 proc near
.text$x:000068DA                                         ; DATA XREF: .xdata$x:00006EF0o
.text$x:000068DA                 lea     ecx, [ebp-410h] ; this
.text$x:000068E0                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000068E0 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$10 endp
.text$x:000068E0
.text$x:000068E5
.text$x:000068E5 ; =============== S U B R O U T I N E =======================================
.text$x:000068E5
.text$x:000068E5
.text$x:000068E5 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$11 proc near
.text$x:000068E5                                         ; DATA XREF: .xdata$x:00006EF8o
.text$x:000068E5                 mov     eax, [ebp-430h]
.text$x:000068EB                 push    eax             ; void *
.text$x:000068EC                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000068F1                 pop     ecx
.text$x:000068F2                 retn
.text$x:000068F2 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$11 endp
.text$x:000068F2
.text$x:000068F3
.text$x:000068F3 ; =============== S U B R O U T I N E =======================================
.text$x:000068F3
.text$x:000068F3
.text$x:000068F3 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$12 proc near
.text$x:000068F3                                         ; DATA XREF: .xdata$x:00006F00o
.text$x:000068F3                 lea     ecx, [ebp-138h] ; this
.text$x:000068F9                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000068F9 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$12 endp
.text$x:000068F9
.text$x:000068FE
.text$x:000068FE ; =============== S U B R O U T I N E =======================================
.text$x:000068FE
.text$x:000068FE
.text$x:000068FE __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$13 proc near
.text$x:000068FE                                         ; DATA XREF: .xdata$x:00006F08o
.text$x:000068FE                 lea     ecx, [ebp-144h]
.text$x:00006904                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:00006904 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$13 endp
.text$x:00006904
.text$x:00006909
.text$x:00006909 ; =============== S U B R O U T I N E =======================================
.text$x:00006909
.text$x:00006909
.text$x:00006909 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$14 proc near
.text$x:00006909                                         ; DATA XREF: .xdata$x:00006F10o
.text$x:00006909                 mov     eax, [ebp-43Ch]
.text$x:0000690F                 push    eax             ; void *
.text$x:00006910                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00006915                 pop     ecx
.text$x:00006916                 retn
.text$x:00006916 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$14 endp
.text$x:00006916
.text$x:00006917
.text$x:00006917 ; =============== S U B R O U T I N E =======================================
.text$x:00006917
.text$x:00006917
.text$x:00006917 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$15 proc near
.text$x:00006917                                         ; DATA XREF: .xdata$x:00006F18o
.text$x:00006917                 lea     ecx, [ebp-15Ch] ; this
.text$x:0000691D                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:0000691D __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$15 endp
.text$x:0000691D
.text$x:00006922
.text$x:00006922 ; =============== S U B R O U T I N E =======================================
.text$x:00006922
.text$x:00006922
.text$x:00006922 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$16 proc near
.text$x:00006922                                         ; DATA XREF: .xdata$x:00006F20o
.text$x:00006922                 lea     ecx, [ebp-190h] ; this
.text$x:00006928                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006928 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$16 endp
.text$x:00006928
.text$x:0000692D
.text$x:0000692D ; =============== S U B R O U T I N E =======================================
.text$x:0000692D
.text$x:0000692D
.text$x:0000692D __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$17 proc near
.text$x:0000692D                                         ; DATA XREF: .xdata$x:00006F28o
.text$x:0000692D                 lea     ecx, [ebp-1ACh] ; this
.text$x:00006933                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006933 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$17 endp
.text$x:00006933
.text$x:00006938
.text$x:00006938 ; =============== S U B R O U T I N E =======================================
.text$x:00006938
.text$x:00006938
.text$x:00006938 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$18 proc near
.text$x:00006938                                         ; DATA XREF: .xdata$x:00006F30o
.text$x:00006938                 lea     ecx, [ebp-1C0h] ; this
.text$x:0000693E                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000693E __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$18 endp
.text$x:0000693E
.text$x:00006943
.text$x:00006943 ; =============== S U B R O U T I N E =======================================
.text$x:00006943
.text$x:00006943
.text$x:00006943 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$19 proc near
.text$x:00006943                                         ; DATA XREF: .xdata$x:00006F38o
.text$x:00006943                 lea     ecx, [ebp-1D4h] ; this
.text$x:00006949                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006949 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$19 endp
.text$x:00006949
.text$x:0000694E
.text$x:0000694E ; =============== S U B R O U T I N E =======================================
.text$x:0000694E
.text$x:0000694E
.text$x:0000694E __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$20 proc near
.text$x:0000694E                                         ; DATA XREF: .xdata$x:00006F40o
.text$x:0000694E                 lea     ecx, [ebp-460h] ; this
.text$x:00006954                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006954 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$20 endp
.text$x:00006954
.text$x:00006959
.text$x:00006959 ; =============== S U B R O U T I N E =======================================
.text$x:00006959
.text$x:00006959
.text$x:00006959 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$21 proc near
.text$x:00006959                                         ; DATA XREF: .xdata$x:00006F48o
.text$x:00006959                 lea     ecx, [ebp-1ECh] ; this
.text$x:0000695F                 jmp     ??1CIndexToPathPair@@QAE@XZ ; CIndexToPathPair::~CIndexToPathPair(void)
.text$x:0000695F __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$21 endp
.text$x:0000695F
.text$x:00006964
.text$x:00006964 ; =============== S U B R O U T I N E =======================================
.text$x:00006964
.text$x:00006964
.text$x:00006964 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$22 proc near
.text$x:00006964                                         ; DATA XREF: .xdata$x:00006F50o
.text$x:00006964                 lea     ecx, [ebp-208h] ; this
.text$x:0000696A                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000696A __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$22 endp
.text$x:0000696A
.text$x:0000696F
.text$x:0000696F ; =============== S U B R O U T I N E =======================================
.text$x:0000696F
.text$x:0000696F
.text$x:0000696F __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$23 proc near
.text$x:0000696F                                         ; DATA XREF: .xdata$x:00006F58o
.text$x:0000696F                 lea     ecx, [ebp-24Ch] ; this
.text$x:00006975                 jmp     ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text$x:00006975 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$23 endp
.text$x:00006975
.text$x:0000697A
.text$x:0000697A ; =============== S U B R O U T I N E =======================================
.text$x:0000697A
.text$x:0000697A
.text$x:0000697A __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$24 proc near
.text$x:0000697A                                         ; DATA XREF: .xdata$x:00006F60o
.text$x:0000697A                 lea     ecx, [ebp-474h] ; this
.text$x:00006980                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006980 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$24 endp
.text$x:00006980
.text$x:00006985
.text$x:00006985 ; =============== S U B R O U T I N E =======================================
.text$x:00006985
.text$x:00006985
.text$x:00006985 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$25 proc near
.text$x:00006985                                         ; DATA XREF: .xdata$x:00006F68o
.text$x:00006985                                         ; .xdata$x:00006F70o
.text$x:00006985                 lea     ecx, [ebp-264h] ; this
.text$x:0000698B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000698B __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$25 endp
.text$x:0000698B
.text$x:00006990
.text$x:00006990 ; =============== S U B R O U T I N E =======================================
.text$x:00006990
.text$x:00006990
.text$x:00006990 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$26 proc near
.text$x:00006990                                         ; DATA XREF: .xdata$x:00006F78o
.text$x:00006990                 lea     ecx, [ebp-28Ch] ; this
.text$x:00006996                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006996 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$26 endp
.text$x:00006996
.text$x:0000699B
.text$x:0000699B ; =============== S U B R O U T I N E =======================================
.text$x:0000699B
.text$x:0000699B
.text$x:0000699B __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$27 proc near
.text$x:0000699B                                         ; DATA XREF: .xdata$x:00006F80o
.text$x:0000699B                 lea     ecx, [ebp-2B8h] ; this
.text$x:000069A1                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000069A1 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$27 endp
.text$x:000069A1
.text$x:000069A6
.text$x:000069A6 ; =============== S U B R O U T I N E =======================================
.text$x:000069A6
.text$x:000069A6
.text$x:000069A6 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$28 proc near
.text$x:000069A6                                         ; DATA XREF: .xdata$x:00006F88o
.text$x:000069A6                 lea     ecx, [ebp-2F8h] ; this
.text$x:000069AC                 jmp     ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text$x:000069AC __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$28 endp
.text$x:000069AC
.text$x:000069B1
.text$x:000069B1 ; =============== S U B R O U T I N E =======================================
.text$x:000069B1
.text$x:000069B1
.text$x:000069B1 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$29 proc near
.text$x:000069B1                                         ; DATA XREF: .xdata$x:00006F90o
.text$x:000069B1                 lea     ecx, [ebp-30Ch] ; this
.text$x:000069B7                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000069B7 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$29 endp
.text$x:000069B7
.text$x:000069BC
.text$x:000069BC ; =============== S U B R O U T I N E =======================================
.text$x:000069BC
.text$x:000069BC
.text$x:000069BC __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$30 proc near
.text$x:000069BC                                         ; DATA XREF: .xdata$x:00006F98o
.text$x:000069BC                 lea     ecx, [ebp-4BCh] ; this
.text$x:000069C2                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000069C2 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$30 endp
.text$x:000069C2
.text$x:000069C7
.text$x:000069C7 ; =============== S U B R O U T I N E =======================================
.text$x:000069C7
.text$x:000069C7
.text$x:000069C7 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$31 proc near
.text$x:000069C7                                         ; DATA XREF: .xdata$x:00006FA0o
.text$x:000069C7                 lea     ecx, [ebp-324h] ; this
.text$x:000069CD                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000069CD __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$31 endp
.text$x:000069CD
.text$x:000069D2
.text$x:000069D2 ; =============== S U B R O U T I N E =======================================
.text$x:000069D2
.text$x:000069D2
.text$x:000069D2 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$32 proc near
.text$x:000069D2                                         ; DATA XREF: .xdata$x:00006FA8o
.text$x:000069D2                 lea     ecx, [ebp-33Ch]
.text$x:000069D8                 jmp     ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text$x:000069D8 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$32 endp
.text$x:000069D8
.text$x:000069DD
.text$x:000069DD ; =============== S U B R O U T I N E =======================================
.text$x:000069DD
.text$x:000069DD
.text$x:000069DD __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$33 proc near
.text$x:000069DD                                         ; DATA XREF: .xdata$x:00006FB0o
.text$x:000069DD                 lea     ecx, [ebp-364h] ; this
.text$x:000069E3                 jmp     ??1CReparseAttr@NFile@NWindows@@QAE@XZ ; NWindows::NFile::CReparseAttr::~CReparseAttr(void)
.text$x:000069E3 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$33 endp
.text$x:000069E3
.text$x:000069E8
.text$x:000069E8 ; =============== S U B R O U T I N E =======================================
.text$x:000069E8
.text$x:000069E8
.text$x:000069E8 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$34 proc near
.text$x:000069E8                                         ; DATA XREF: .xdata$x:00006FB8o
.text$x:000069E8                 mov     eax, [ebp-4E4h]
.text$x:000069EE                 push    eax             ; void *
.text$x:000069EF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000069F4                 pop     ecx
.text$x:000069F5                 retn
.text$x:000069F5 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$34 endp
.text$x:000069F5
.text$x:000069F6
.text$x:000069F6 ; =============== S U B R O U T I N E =======================================
.text$x:000069F6
.text$x:000069F6
.text$x:000069F6 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$35 proc near
.text$x:000069F6                                         ; DATA XREF: .xdata$x:00006FC0o
.text$x:000069F6                 lea     ecx, [ebp-3B0h]
.text$x:000069FC                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:000069FC __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$35 endp
.text$x:000069FC
.text$x:00006A01
.text$x:00006A01 ; =============== S U B R O U T I N E =======================================
.text$x:00006A01
.text$x:00006A01
.text$x:00006A01 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$36 proc near
.text$x:00006A01                                         ; DATA XREF: .xdata$x:00006FC8o
.text$x:00006A01                 lea     ecx, [ebp-3CCh] ; this
.text$x:00006A07                 jmp     ??1CIndexToPathPair@@QAE@XZ ; CIndexToPathPair::~CIndexToPathPair(void)
.text$x:00006A07 __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$36 endp
.text$x:00006A07
.text$x:00006A0C
.text$x:00006A0C ; =============== S U B R O U T I N E =======================================
.text$x:00006A0C
.text$x:00006A0C
.text$x:00006A0C __ehhandler$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z proc near
.text$x:00006A0C                                         ; DATA XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+5o
.text$x:00006A0C
.text$x:00006A0C arg_4           = dword ptr  8
.text$x:00006A0C
.text$x:00006A0C                 mov     edx, [esp+arg_4]
.text$x:00006A10                 lea     eax, [edx+0Ch]
.text$x:00006A13                 mov     ecx, [edx-810h]
.text$x:00006A19                 xor     ecx, eax
.text$x:00006A1B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A20                 mov     ecx, [edx-8]
.text$x:00006A23                 xor     ecx, eax
.text$x:00006A25                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A2A                 mov     eax, offset __ehfuncinfo$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z
.text$x:00006A2F                 jmp     ___CxxFrameHandler3
.text$x:00006A2F __ehhandler$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z endp
.text$x:00006A2F
.text$x:00006A34
.text$x:00006A34 ; =============== S U B R O U T I N E =======================================
.text$x:00006A34
.text$x:00006A34
.text$x:00006A34 __unwindfunclet$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z$0 proc near
.text$x:00006A34                                         ; DATA XREF: .xdata$x:00006FE0o
.text$x:00006A34                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00006A37                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006A37 __unwindfunclet$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z$0 endp
.text$x:00006A37
.text$x:00006A3C
.text$x:00006A3C ; =============== S U B R O U T I N E =======================================
.text$x:00006A3C
.text$x:00006A3C
.text$x:00006A3C __unwindfunclet$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z$1 proc near
.text$x:00006A3C                                         ; DATA XREF: .xdata$x:00006FD8o
.text$x:00006A3C                 mov     eax, [ebp-28h]
.text$x:00006A3F                 and     eax, 1
.text$x:00006A42                 jz      locret_6A54
.text$x:00006A48                 and     dword ptr [ebp-28h], 0FFFFFFFEh
.text$x:00006A4C                 mov     ecx, [ebp+8]    ; this
.text$x:00006A4F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006A54 ; ---------------------------------------------------------------------------
.text$x:00006A54
.text$x:00006A54 locret_6A54:                            ; CODE XREF: __unwindfunclet$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z$1+6j
.text$x:00006A54                 retn
.text$x:00006A54 __unwindfunclet$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z$1 endp
.text$x:00006A54
.text$x:00006A55
.text$x:00006A55 ; =============== S U B R O U T I N E =======================================
.text$x:00006A55
.text$x:00006A55
.text$x:00006A55 __ehhandler$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z proc near
.text$x:00006A55                                         ; DATA XREF: GetDirPrefixOf(UString const &)+5o
.text$x:00006A55
.text$x:00006A55 arg_4           = dword ptr  8
.text$x:00006A55
.text$x:00006A55                 mov     edx, [esp+arg_4]
.text$x:00006A59                 lea     eax, [edx+0Ch]
.text$x:00006A5C                 mov     ecx, [edx-20h]
.text$x:00006A5F                 xor     ecx, eax
.text$x:00006A61                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A66                 mov     eax, offset __ehfuncinfo$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z
.text$x:00006A6B                 jmp     ___CxxFrameHandler3
.text$x:00006A6B __ehhandler$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z endp
.text$x:00006A6B
.text$x:00006A70
.text$x:00006A70 ; =============== S U B R O U T I N E =======================================
.text$x:00006A70
.text$x:00006A70
.text$x:00006A70 __unwindfunclet$?IsSafePath@@YG_NABVUString@@@Z$0 proc near
.text$x:00006A70                                         ; DATA XREF: .xdata$x:0000700Co
.text$x:00006A70                 lea     ecx, [ebp-1Ch]
.text$x:00006A73                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00006A73 __unwindfunclet$?IsSafePath@@YG_NABVUString@@@Z$0 endp
.text$x:00006A73
.text$x:00006A78
.text$x:00006A78 ; =============== S U B R O U T I N E =======================================
.text$x:00006A78
.text$x:00006A78
.text$x:00006A78 __ehhandler$?IsSafePath@@YG_NABVUString@@@Z proc near
.text$x:00006A78                                         ; DATA XREF: IsSafePath(UString const &)+5o
.text$x:00006A78
.text$x:00006A78 arg_4           = dword ptr  8
.text$x:00006A78
.text$x:00006A78                 mov     edx, [esp+arg_4]
.text$x:00006A7C                 lea     eax, [edx+0Ch]
.text$x:00006A7F                 mov     ecx, [edx-28h]
.text$x:00006A82                 xor     ecx, eax
.text$x:00006A84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A89                 mov     eax, offset __ehfuncinfo$?IsSafePath@@YG_NABVUString@@@Z
.text$x:00006A8E                 jmp     ___CxxFrameHandler3
.text$x:00006A8E __ehhandler$?IsSafePath@@YG_NABVUString@@@Z endp
.text$x:00006A8E
.text$x:00006A93
.text$x:00006A93 ; =============== S U B R O U T I N E =======================================
.text$x:00006A93
.text$x:00006A93
.text$x:00006A93 __unwindfunclet$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z$0 proc near
.text$x:00006A93                                         ; DATA XREF: .xdata$x:00007040o
.text$x:00006A93                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00006A96                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006A96 __unwindfunclet$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z$0 endp
.text$x:00006A96
.text$x:00006A9B
.text$x:00006A9B ; =============== S U B R O U T I N E =======================================
.text$x:00006A9B
.text$x:00006A9B
.text$x:00006A9B __unwindfunclet$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z$1 proc near
.text$x:00006A9B                                         ; DATA XREF: .xdata$x:00007038o
.text$x:00006A9B                 mov     eax, [ebp-24h]
.text$x:00006A9E                 and     eax, 1
.text$x:00006AA1                 jz      locret_6AB3
.text$x:00006AA7                 and     dword ptr [ebp-24h], 0FFFFFFFEh
.text$x:00006AAB                 mov     ecx, [ebp+8]    ; this
.text$x:00006AAE                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006AB3 ; ---------------------------------------------------------------------------
.text$x:00006AB3
.text$x:00006AB3 locret_6AB3:                            ; CODE XREF: __unwindfunclet$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z$1+6j
.text$x:00006AB3                 retn
.text$x:00006AB3 __unwindfunclet$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z$1 endp
.text$x:00006AB3
.text$x:00006AB4
.text$x:00006AB4 ; =============== S U B R O U T I N E =======================================
.text$x:00006AB4
.text$x:00006AB4
.text$x:00006AB4 __ehhandler$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z proc near
.text$x:00006AB4                                         ; DATA XREF: MakePath_from_2_Parts(UString const &,UString const &)+5o
.text$x:00006AB4
.text$x:00006AB4 arg_4           = dword ptr  8
.text$x:00006AB4
.text$x:00006AB4                 mov     edx, [esp+arg_4]
.text$x:00006AB8                 lea     eax, [edx+0Ch]
.text$x:00006ABB                 mov     ecx, [edx-1Ch]
.text$x:00006ABE                 xor     ecx, eax
.text$x:00006AC0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006AC5                 mov     eax, offset __ehfuncinfo$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z
.text$x:00006ACA                 jmp     ___CxxFrameHandler3
.text$x:00006ACA __ehhandler$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z endp
.text$x:00006ACA
.text$x:00006ACF
.text$x:00006ACF ; =============== S U B R O U T I N E =======================================
.text$x:00006ACF
.text$x:00006ACF
.text$x:00006ACF __ehhandler$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z proc near
.text$x:00006ACF                                         ; DATA XREF: CArchiveExtractCallback::PrepareOperation(int)+5o
.text$x:00006ACF
.text$x:00006ACF arg_4           = dword ptr  8
.text$x:00006ACF
.text$x:00006ACF                 mov     edx, [esp+arg_4]
.text$x:00006AD3                 lea     eax, [edx+0Ch]
.text$x:00006AD6                 mov     ecx, [edx-44h]
.text$x:00006AD9                 xor     ecx, eax
.text$x:00006ADB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006AE0                 mov     eax, offset __ehfuncinfo$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z
.text$x:00006AE5                 jmp     ___CxxFrameHandler3
.text$x:00006AE5 __ehhandler$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z endp
.text$x:00006AE5
.text$x:00006AEA
.text$x:00006AEA ; =============== S U B R O U T I N E =======================================
.text$x:00006AEA
.text$x:00006AEA
.text$x:00006AEA __ehhandler$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z proc near
.text$x:00006AEA                                         ; DATA XREF: CArchiveExtractCallback::SetOperationResult(int)+5o
.text$x:00006AEA
.text$x:00006AEA arg_4           = dword ptr  8
.text$x:00006AEA
.text$x:00006AEA                 mov     edx, [esp+arg_4]
.text$x:00006AEE                 lea     eax, [edx+0Ch]
.text$x:00006AF1                 mov     ecx, [edx-0A0h]
.text$x:00006AF7                 xor     ecx, eax
.text$x:00006AF9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006AFE                 mov     eax, offset __ehfuncinfo$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z
.text$x:00006B03                 jmp     ___CxxFrameHandler3
.text$x:00006B03 __ehhandler$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z endp
.text$x:00006B03
.text$x:00006B08
.text$x:00006B08 ; =============== S U B R O U T I N E =======================================
.text$x:00006B08
.text$x:00006B08
.text$x:00006B08 __ehhandler$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z proc near
.text$x:00006B08                                         ; DATA XREF: CArchiveExtractCallback::CryptoGetTextPassword(wchar_t * *)+5o
.text$x:00006B08
.text$x:00006B08 arg_4           = dword ptr  8
.text$x:00006B08
.text$x:00006B08                 mov     edx, [esp+arg_4]
.text$x:00006B0C                 lea     eax, [edx+0Ch]
.text$x:00006B0F                 mov     ecx, [edx-30h]
.text$x:00006B12                 xor     ecx, eax
.text$x:00006B14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006B19                 mov     eax, offset __ehfuncinfo$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z
.text$x:00006B1E                 jmp     ___CxxFrameHandler3
.text$x:00006B1E __ehhandler$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z endp
.text$x:00006B1E
.text$x:00006B23
.text$x:00006B23 ; =============== S U B R O U T I N E =======================================
.text$x:00006B23
.text$x:00006B23
.text$x:00006B23 __unwindfunclet$?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ$0 proc near
.text$x:00006B23                                         ; DATA XREF: .xdata$x:00007174o
.text$x:00006B23                 lea     ecx, [ebp-20h]
.text$x:00006B26                 jmp     ??1?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ ; CRecordVector<CExtrRefSortPair>::~CRecordVector<CExtrRefSortPair>(void)
.text$x:00006B26 __unwindfunclet$?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ$0 endp
.text$x:00006B26
.text$x:00006B2B
.text$x:00006B2B ; =============== S U B R O U T I N E =======================================
.text$x:00006B2B
.text$x:00006B2B
.text$x:00006B2B __ehhandler$?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ proc near
.text$x:00006B2B                                         ; DATA XREF: CArchiveExtractCallback::SetDirsTimes(void)+5o
.text$x:00006B2B
.text$x:00006B2B arg_4           = dword ptr  8
.text$x:00006B2B
.text$x:00006B2B                 mov     edx, [esp+arg_4]
.text$x:00006B2F                 lea     eax, [edx+0Ch]
.text$x:00006B32                 mov     ecx, [edx-0B0h]
.text$x:00006B38                 xor     ecx, eax
.text$x:00006B3A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006B3F                 mov     eax, offset __ehfuncinfo$?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ
.text$x:00006B44                 jmp     ___CxxFrameHandler3
.text$x:00006B44 __ehhandler$?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ endp
.text$x:00006B44
.text$x:00006B44 ; ---------------------------------------------------------------------------
.text$x:00006B49                 align 4
.text$x:00006B49 _text$x         ends
.text$x:00006B49
.xdata$x:00006B4C ; ===========================================================================
.xdata$x:00006B4C
.xdata$x:00006B4C ; Segment type: Pure data
.xdata$x:00006B4C ; Segment permissions: Read
.xdata$x:00006B4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006B4C                 assume cs:_xdata$x
.xdata$x:00006B4C                 ;org 6B4Ch
.xdata$x:00006B4C __unwindtable$?InitLocalPrivileges@@YG_NXZ db 0FFh
.xdata$x:00006B4C                                         ; DATA XREF: .xdata$x:00006B5Co
.xdata$x:00006B4D                 db 0FFh
.xdata$x:00006B4E                 db 0FFh
.xdata$x:00006B4F                 db 0FFh
.xdata$x:00006B50                 dd offset __unwindfunclet$?InitLocalPrivileges@@YG_NXZ$0
.xdata$x:00006B54 __ehfuncinfo$?InitLocalPrivileges@@YG_NXZ db  22h ; "
.xdata$x:00006B54                                         ; DATA XREF: __ehhandler$?InitLocalPrivileges@@YG_NXZ+1Bo
.xdata$x:00006B55                 db    5
.xdata$x:00006B56                 db  93h ; ô
.xdata$x:00006B57                 db  19h
.xdata$x:00006B58                 db    1
.xdata$x:00006B59                 db    0
.xdata$x:00006B5A                 db    0
.xdata$x:00006B5B                 db    0
.xdata$x:00006B5C                 dd offset __unwindtable$?InitLocalPrivileges@@YG_NXZ
.xdata$x:00006B60                 db    0
.xdata$x:00006B61                 db    0
.xdata$x:00006B62                 db    0
.xdata$x:00006B63                 db    0
.xdata$x:00006B64                 db    0
.xdata$x:00006B65                 db    0
.xdata$x:00006B66                 db    0
.xdata$x:00006B67                 db    0
.xdata$x:00006B68                 db    0
.xdata$x:00006B69                 db    0
.xdata$x:00006B6A                 db    0
.xdata$x:00006B6B                 db    0
.xdata$x:00006B6C                 db    0
.xdata$x:00006B6D                 db    0
.xdata$x:00006B6E                 db    0
.xdata$x:00006B6F                 db    0
.xdata$x:00006B70                 db    0
.xdata$x:00006B71                 db    0
.xdata$x:00006B72                 db    0
.xdata$x:00006B73                 db    0
.xdata$x:00006B74                 db    1
.xdata$x:00006B75                 db    0
.xdata$x:00006B76                 db    0
.xdata$x:00006B77                 db    0
.xdata$x:00006B78 __unwindtable$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z db 0FFh
.xdata$x:00006B78                                         ; DATA XREF: .xdata$x:00006B90o
.xdata$x:00006B79                 db 0FFh
.xdata$x:00006B7A                 db 0FFh
.xdata$x:00006B7B                 db 0FFh
.xdata$x:00006B7C                 dd offset __unwindfunclet$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z$0
.xdata$x:00006B80                 db 0FFh
.xdata$x:00006B81                 db 0FFh
.xdata$x:00006B82                 db 0FFh
.xdata$x:00006B83                 db 0FFh
.xdata$x:00006B84                 dd offset __unwindfunclet$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z$1
.xdata$x:00006B88 __ehfuncinfo$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z db  22h ; "
.xdata$x:00006B88                                         ; DATA XREF: __ehhandler$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z+11o
.xdata$x:00006B89                 db    5
.xdata$x:00006B8A                 db  93h ; ô
.xdata$x:00006B8B                 db  19h
.xdata$x:00006B8C                 db    2
.xdata$x:00006B8D                 db    0
.xdata$x:00006B8E                 db    0
.xdata$x:00006B8F                 db    0
.xdata$x:00006B90                 dd offset __unwindtable$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z
.xdata$x:00006B94                 db    0
.xdata$x:00006B95                 db    0
.xdata$x:00006B96                 db    0
.xdata$x:00006B97                 db    0
.xdata$x:00006B98                 db    0
.xdata$x:00006B99                 db    0
.xdata$x:00006B9A                 db    0
.xdata$x:00006B9B                 db    0
.xdata$x:00006B9C                 db    0
.xdata$x:00006B9D                 db    0
.xdata$x:00006B9E                 db    0
.xdata$x:00006B9F                 db    0
.xdata$x:00006BA0                 db    0
.xdata$x:00006BA1                 db    0
.xdata$x:00006BA2                 db    0
.xdata$x:00006BA3                 db    0
.xdata$x:00006BA4                 db    0
.xdata$x:00006BA5                 db    0
.xdata$x:00006BA6                 db    0
.xdata$x:00006BA7                 db    0
.xdata$x:00006BA8                 db    1
.xdata$x:00006BA9                 db    0
.xdata$x:00006BAA                 db    0
.xdata$x:00006BAB                 db    0
.xdata$x:00006BAC __ehfuncinfo$??0CArchiveExtractCallback@@QAE@XZ db  22h ; "
.xdata$x:00006BAC                                         ; DATA XREF: __ehhandler$??0CArchiveExtractCallback@@QAE@XZ+11o
.xdata$x:00006BAD                 db    5
.xdata$x:00006BAE                 db  93h ; ô
.xdata$x:00006BAF                 db  19h
.xdata$x:00006BB0                 db  14h
.xdata$x:00006BB1                 db    0
.xdata$x:00006BB2                 db    0
.xdata$x:00006BB3                 db    0
.xdata$x:00006BB4                 dd offset __unwindtable$??0CArchiveExtractCallback@@QAE@XZ
.xdata$x:00006BB8                 db    0
.xdata$x:00006BB9                 db    0
.xdata$x:00006BBA                 db    0
.xdata$x:00006BBB                 db    0
.xdata$x:00006BBC                 db    0
.xdata$x:00006BBD                 db    0
.xdata$x:00006BBE                 db    0
.xdata$x:00006BBF                 db    0
.xdata$x:00006BC0                 db    0
.xdata$x:00006BC1                 db    0
.xdata$x:00006BC2                 db    0
.xdata$x:00006BC3                 db    0
.xdata$x:00006BC4                 db    0
.xdata$x:00006BC5                 db    0
.xdata$x:00006BC6                 db    0
.xdata$x:00006BC7                 db    0
.xdata$x:00006BC8                 db    0
.xdata$x:00006BC9                 db    0
.xdata$x:00006BCA                 db    0
.xdata$x:00006BCB                 db    0
.xdata$x:00006BCC                 db    1
.xdata$x:00006BCD                 db    0
.xdata$x:00006BCE                 db    0
.xdata$x:00006BCF                 db    0
.xdata$x:00006BD0 __unwindtable$??0CArchiveExtractCallback@@QAE@XZ db 0FFh
.xdata$x:00006BD0                                         ; DATA XREF: .xdata$x:00006BB4o
.xdata$x:00006BD1                 db 0FFh
.xdata$x:00006BD2                 db 0FFh
.xdata$x:00006BD3                 db 0FFh
.xdata$x:00006BD4                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$0
.xdata$x:00006BD8                 db    0
.xdata$x:00006BD9                 db    0
.xdata$x:00006BDA                 db    0
.xdata$x:00006BDB                 db    0
.xdata$x:00006BDC                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$1
.xdata$x:00006BE0                 db    1
.xdata$x:00006BE1                 db    0
.xdata$x:00006BE2                 db    0
.xdata$x:00006BE3                 db    0
.xdata$x:00006BE4                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$2
.xdata$x:00006BE8                 db    2
.xdata$x:00006BE9                 db    0
.xdata$x:00006BEA                 db    0
.xdata$x:00006BEB                 db    0
.xdata$x:00006BEC                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$3
.xdata$x:00006BF0                 db    3
.xdata$x:00006BF1                 db    0
.xdata$x:00006BF2                 db    0
.xdata$x:00006BF3                 db    0
.xdata$x:00006BF4                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$4
.xdata$x:00006BF8                 db    4
.xdata$x:00006BF9                 db    0
.xdata$x:00006BFA                 db    0
.xdata$x:00006BFB                 db    0
.xdata$x:00006BFC                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$5
.xdata$x:00006C00                 db    5
.xdata$x:00006C01                 db    0
.xdata$x:00006C02                 db    0
.xdata$x:00006C03                 db    0
.xdata$x:00006C04                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$6
.xdata$x:00006C08                 db    6
.xdata$x:00006C09                 db    0
.xdata$x:00006C0A                 db    0
.xdata$x:00006C0B                 db    0
.xdata$x:00006C0C                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$7
.xdata$x:00006C10                 db    7
.xdata$x:00006C11                 db    0
.xdata$x:00006C12                 db    0
.xdata$x:00006C13                 db    0
.xdata$x:00006C14                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$8
.xdata$x:00006C18                 db    8
.xdata$x:00006C19                 db    0
.xdata$x:00006C1A                 db    0
.xdata$x:00006C1B                 db    0
.xdata$x:00006C1C                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$9
.xdata$x:00006C20                 db    9
.xdata$x:00006C21                 db    0
.xdata$x:00006C22                 db    0
.xdata$x:00006C23                 db    0
.xdata$x:00006C24                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$10
.xdata$x:00006C28                 db  0Ah
.xdata$x:00006C29                 db    0
.xdata$x:00006C2A                 db    0
.xdata$x:00006C2B                 db    0
.xdata$x:00006C2C                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$11
.xdata$x:00006C30                 db  0Bh
.xdata$x:00006C31                 db    0
.xdata$x:00006C32                 db    0
.xdata$x:00006C33                 db    0
.xdata$x:00006C34                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$12
.xdata$x:00006C38                 db  0Ch
.xdata$x:00006C39                 db    0
.xdata$x:00006C3A                 db    0
.xdata$x:00006C3B                 db    0
.xdata$x:00006C3C                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$13
.xdata$x:00006C40                 db  0Dh
.xdata$x:00006C41                 db    0
.xdata$x:00006C42                 db    0
.xdata$x:00006C43                 db    0
.xdata$x:00006C44                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$14
.xdata$x:00006C48                 db  0Eh
.xdata$x:00006C49                 db    0
.xdata$x:00006C4A                 db    0
.xdata$x:00006C4B                 db    0
.xdata$x:00006C4C                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$15
.xdata$x:00006C50                 db  0Fh
.xdata$x:00006C51                 db    0
.xdata$x:00006C52                 db    0
.xdata$x:00006C53                 db    0
.xdata$x:00006C54                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$16
.xdata$x:00006C58                 db  10h
.xdata$x:00006C59                 db    0
.xdata$x:00006C5A                 db    0
.xdata$x:00006C5B                 db    0
.xdata$x:00006C5C                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$17
.xdata$x:00006C60                 db  11h
.xdata$x:00006C61                 db    0
.xdata$x:00006C62                 db    0
.xdata$x:00006C63                 db    0
.xdata$x:00006C64                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$18
.xdata$x:00006C68                 db  12h
.xdata$x:00006C69                 db    0
.xdata$x:00006C6A                 db    0
.xdata$x:00006C6B                 db    0
.xdata$x:00006C6C                 dd offset __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$19
.xdata$x:00006C70 __catchsym$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z$2 dd offset aNameExistingFi+12h
.xdata$x:00006C70                                         ; DATA XREF: .xdata$x:00006CA0o
.xdata$x:00006C70                                         ; ""
.xdata$x:00006C74                 db    0
.xdata$x:00006C75                 db    0
.xdata$x:00006C76                 db    0
.xdata$x:00006C77                 db    0
.xdata$x:00006C78                 db    0
.xdata$x:00006C79                 db    0
.xdata$x:00006C7A                 db    0
.xdata$x:00006C7B                 db    0
.xdata$x:00006C7C                 dd offset __catch$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z$0
.xdata$x:00006C80 __unwindtable$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z db 0FFh
.xdata$x:00006C80                                         ; DATA XREF: .xdata$x:00006CACo
.xdata$x:00006C81                 db 0FFh
.xdata$x:00006C82                 db 0FFh
.xdata$x:00006C83                 db 0FFh
.xdata$x:00006C84                 db    0
.xdata$x:00006C85                 db    0
.xdata$x:00006C86                 db    0
.xdata$x:00006C87                 db    0
.xdata$x:00006C88                 db 0FFh
.xdata$x:00006C89                 db 0FFh
.xdata$x:00006C8A                 db 0FFh
.xdata$x:00006C8B                 db 0FFh
.xdata$x:00006C8C                 db    0
.xdata$x:00006C8D                 db    0
.xdata$x:00006C8E                 db    0
.xdata$x:00006C8F                 db    0
.xdata$x:00006C90 __tryblocktable$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z db    0
.xdata$x:00006C90                                         ; DATA XREF: .xdata$x:00006CB4o
.xdata$x:00006C91                 db    0
.xdata$x:00006C92                 db    0
.xdata$x:00006C93                 db    0
.xdata$x:00006C94                 db    0
.xdata$x:00006C95                 db    0
.xdata$x:00006C96                 db    0
.xdata$x:00006C97                 db    0
.xdata$x:00006C98                 db    1
.xdata$x:00006C99                 db    0
.xdata$x:00006C9A                 db    0
.xdata$x:00006C9B                 db    0
.xdata$x:00006C9C                 db    1
.xdata$x:00006C9D                 db    0
.xdata$x:00006C9E                 db    0
.xdata$x:00006C9F                 db    0
.xdata$x:00006CA0                 dd offset __catchsym$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z$2
.xdata$x:00006CA4 __ehfuncinfo$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z db  22h ; "
.xdata$x:00006CA4                                         ; DATA XREF: __ehhandler$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z+11o
.xdata$x:00006CA5                 db    5
.xdata$x:00006CA6                 db  93h ; ô
.xdata$x:00006CA7                 db  19h
.xdata$x:00006CA8                 db    2
.xdata$x:00006CA9                 db    0
.xdata$x:00006CAA                 db    0
.xdata$x:00006CAB                 db    0
.xdata$x:00006CAC                 dd offset __unwindtable$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z
.xdata$x:00006CB0                 db    1
.xdata$x:00006CB1                 db    0
.xdata$x:00006CB2                 db    0
.xdata$x:00006CB3                 db    0
.xdata$x:00006CB4                 dd offset __tryblocktable$?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z
.xdata$x:00006CB8                 db    0
.xdata$x:00006CB9                 db    0
.xdata$x:00006CBA                 db    0
.xdata$x:00006CBB                 db    0
.xdata$x:00006CBC                 db    0
.xdata$x:00006CBD                 db    0
.xdata$x:00006CBE                 db    0
.xdata$x:00006CBF                 db    0
.xdata$x:00006CC0                 db    0
.xdata$x:00006CC1                 db    0
.xdata$x:00006CC2                 db    0
.xdata$x:00006CC3                 db    0
.xdata$x:00006CC4                 db    1
.xdata$x:00006CC5                 db    0
.xdata$x:00006CC6                 db    0
.xdata$x:00006CC7                 db    0
.xdata$x:00006CC8 __catchsym$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z$2 dd offset aNameExistingFi+12h
.xdata$x:00006CC8                                         ; DATA XREF: .xdata$x:00006CF8o
.xdata$x:00006CC8                                         ; ""
.xdata$x:00006CCC                 db    0
.xdata$x:00006CCD                 db    0
.xdata$x:00006CCE                 db    0
.xdata$x:00006CCF                 db    0
.xdata$x:00006CD0                 db    0
.xdata$x:00006CD1                 db    0
.xdata$x:00006CD2                 db    0
.xdata$x:00006CD3                 db    0
.xdata$x:00006CD4                 dd offset __catch$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z$0
.xdata$x:00006CD8 __unwindtable$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z db 0FFh
.xdata$x:00006CD8                                         ; DATA XREF: .xdata$x:00006D04o
.xdata$x:00006CD9                 db 0FFh
.xdata$x:00006CDA                 db 0FFh
.xdata$x:00006CDB                 db 0FFh
.xdata$x:00006CDC                 db    0
.xdata$x:00006CDD                 db    0
.xdata$x:00006CDE                 db    0
.xdata$x:00006CDF                 db    0
.xdata$x:00006CE0                 db 0FFh
.xdata$x:00006CE1                 db 0FFh
.xdata$x:00006CE2                 db 0FFh
.xdata$x:00006CE3                 db 0FFh
.xdata$x:00006CE4                 db    0
.xdata$x:00006CE5                 db    0
.xdata$x:00006CE6                 db    0
.xdata$x:00006CE7                 db    0
.xdata$x:00006CE8 __tryblocktable$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z db    0
.xdata$x:00006CE8                                         ; DATA XREF: .xdata$x:00006D0Co
.xdata$x:00006CE9                 db    0
.xdata$x:00006CEA                 db    0
.xdata$x:00006CEB                 db    0
.xdata$x:00006CEC                 db    0
.xdata$x:00006CED                 db    0
.xdata$x:00006CEE                 db    0
.xdata$x:00006CEF                 db    0
.xdata$x:00006CF0                 db    1
.xdata$x:00006CF1                 db    0
.xdata$x:00006CF2                 db    0
.xdata$x:00006CF3                 db    0
.xdata$x:00006CF4                 db    1
.xdata$x:00006CF5                 db    0
.xdata$x:00006CF6                 db    0
.xdata$x:00006CF7                 db    0
.xdata$x:00006CF8                 dd offset __catchsym$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z$2
.xdata$x:00006CFC __ehfuncinfo$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z db  22h ; "
.xdata$x:00006CFC                                         ; DATA XREF: __ehhandler$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z+11o
.xdata$x:00006CFD                 db    5
.xdata$x:00006CFE                 db  93h ; ô
.xdata$x:00006CFF                 db  19h
.xdata$x:00006D00                 db    2
.xdata$x:00006D01                 db    0
.xdata$x:00006D02                 db    0
.xdata$x:00006D03                 db    0
.xdata$x:00006D04                 dd offset __unwindtable$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z
.xdata$x:00006D08                 db    1
.xdata$x:00006D09                 db    0
.xdata$x:00006D0A                 db    0
.xdata$x:00006D0B                 db    0
.xdata$x:00006D0C                 dd offset __tryblocktable$?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z
.xdata$x:00006D10                 db    0
.xdata$x:00006D11                 db    0
.xdata$x:00006D12                 db    0
.xdata$x:00006D13                 db    0
.xdata$x:00006D14                 db    0
.xdata$x:00006D15                 db    0
.xdata$x:00006D16                 db    0
.xdata$x:00006D17                 db    0
.xdata$x:00006D18                 db    0
.xdata$x:00006D19                 db    0
.xdata$x:00006D1A                 db    0
.xdata$x:00006D1B                 db    0
.xdata$x:00006D1C                 db    1
.xdata$x:00006D1D                 db    0
.xdata$x:00006D1E                 db    0
.xdata$x:00006D1F                 db    0
.xdata$x:00006D20 __catchsym$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z$2 dd offset aNameExistingFi+12h
.xdata$x:00006D20                                         ; DATA XREF: .xdata$x:00006D50o
.xdata$x:00006D20                                         ; ""
.xdata$x:00006D24                 db    0
.xdata$x:00006D25                 db    0
.xdata$x:00006D26                 db    0
.xdata$x:00006D27                 db    0
.xdata$x:00006D28                 db    0
.xdata$x:00006D29                 db    0
.xdata$x:00006D2A                 db    0
.xdata$x:00006D2B                 db    0
.xdata$x:00006D2C                 dd offset __catch$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z$0
.xdata$x:00006D30 __unwindtable$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z db 0FFh
.xdata$x:00006D30                                         ; DATA XREF: .xdata$x:00006D5Co
.xdata$x:00006D31                 db 0FFh
.xdata$x:00006D32                 db 0FFh
.xdata$x:00006D33                 db 0FFh
.xdata$x:00006D34                 db    0
.xdata$x:00006D35                 db    0
.xdata$x:00006D36                 db    0
.xdata$x:00006D37                 db    0
.xdata$x:00006D38                 db 0FFh
.xdata$x:00006D39                 db 0FFh
.xdata$x:00006D3A                 db 0FFh
.xdata$x:00006D3B                 db 0FFh
.xdata$x:00006D3C                 db    0
.xdata$x:00006D3D                 db    0
.xdata$x:00006D3E                 db    0
.xdata$x:00006D3F                 db    0
.xdata$x:00006D40 __tryblocktable$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z db    0
.xdata$x:00006D40                                         ; DATA XREF: .xdata$x:00006D64o
.xdata$x:00006D41                 db    0
.xdata$x:00006D42                 db    0
.xdata$x:00006D43                 db    0
.xdata$x:00006D44                 db    0
.xdata$x:00006D45                 db    0
.xdata$x:00006D46                 db    0
.xdata$x:00006D47                 db    0
.xdata$x:00006D48                 db    1
.xdata$x:00006D49                 db    0
.xdata$x:00006D4A                 db    0
.xdata$x:00006D4B                 db    0
.xdata$x:00006D4C                 db    1
.xdata$x:00006D4D                 db    0
.xdata$x:00006D4E                 db    0
.xdata$x:00006D4F                 db    0
.xdata$x:00006D50                 dd offset __catchsym$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z$2
.xdata$x:00006D54 __ehfuncinfo$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z db  22h ; "
.xdata$x:00006D54                                         ; DATA XREF: __ehhandler$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z+11o
.xdata$x:00006D55                 db    5
.xdata$x:00006D56                 db  93h ; ô
.xdata$x:00006D57                 db  19h
.xdata$x:00006D58                 db    2
.xdata$x:00006D59                 db    0
.xdata$x:00006D5A                 db    0
.xdata$x:00006D5B                 db    0
.xdata$x:00006D5C                 dd offset __unwindtable$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z
.xdata$x:00006D60                 db    1
.xdata$x:00006D61                 db    0
.xdata$x:00006D62                 db    0
.xdata$x:00006D63                 db    0
.xdata$x:00006D64                 dd offset __tryblocktable$?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z
.xdata$x:00006D68                 db    0
.xdata$x:00006D69                 db    0
.xdata$x:00006D6A                 db    0
.xdata$x:00006D6B                 db    0
.xdata$x:00006D6C                 db    0
.xdata$x:00006D6D                 db    0
.xdata$x:00006D6E                 db    0
.xdata$x:00006D6F                 db    0
.xdata$x:00006D70                 db    0
.xdata$x:00006D71                 db    0
.xdata$x:00006D72                 db    0
.xdata$x:00006D73                 db    0
.xdata$x:00006D74                 db    1
.xdata$x:00006D75                 db    0
.xdata$x:00006D76                 db    0
.xdata$x:00006D77                 db    0
.xdata$x:00006D78 __unwindtable$?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z db 0FFh
.xdata$x:00006D78                                         ; DATA XREF: .xdata$x:00006D88o
.xdata$x:00006D79                 db 0FFh
.xdata$x:00006D7A                 db 0FFh
.xdata$x:00006D7B                 db 0FFh
.xdata$x:00006D7C                 dd offset __unwindfunclet$?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z$0
.xdata$x:00006D80 __ehfuncinfo$?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z db  22h ; "
.xdata$x:00006D80                                         ; DATA XREF: __ehhandler$?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z+11o
.xdata$x:00006D81                 db    5
.xdata$x:00006D82                 db  93h ; ô
.xdata$x:00006D83                 db  19h
.xdata$x:00006D84                 db    1
.xdata$x:00006D85                 db    0
.xdata$x:00006D86                 db    0
.xdata$x:00006D87                 db    0
.xdata$x:00006D88                 dd offset __unwindtable$?GetTime@CArchiveExtractCallback@@AAEJHKAAU_FILETIME@@AA_N@Z
.xdata$x:00006D8C                 align 20h
.xdata$x:00006DA0                 db    1
.xdata$x:00006DA1                 db    0
.xdata$x:00006DA2                 db    0
.xdata$x:00006DA3                 db    0
.xdata$x:00006DA4 __unwindtable$?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z db 0FFh
.xdata$x:00006DA4                                         ; DATA XREF: .xdata$x:00006DB4o
.xdata$x:00006DA5                 db 0FFh
.xdata$x:00006DA6                 db 0FFh
.xdata$x:00006DA7                 db 0FFh
.xdata$x:00006DA8                 dd offset __unwindfunclet$?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z$0
.xdata$x:00006DAC __ehfuncinfo$?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z db  22h ; "
.xdata$x:00006DAC                                         ; DATA XREF: __ehhandler$?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z+11o
.xdata$x:00006DAD                 db    5
.xdata$x:00006DAE                 db  93h ; ô
.xdata$x:00006DAF                 db  19h
.xdata$x:00006DB0                 db    1
.xdata$x:00006DB1                 db    0
.xdata$x:00006DB2                 db    0
.xdata$x:00006DB3                 db    0
.xdata$x:00006DB4                 dd offset __unwindtable$?SendMessageError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z
.xdata$x:00006DB8                 db    0
.xdata$x:00006DB9                 db    0
.xdata$x:00006DBA                 db    0
.xdata$x:00006DBB                 db    0
.xdata$x:00006DBC                 db    0
.xdata$x:00006DBD                 db    0
.xdata$x:00006DBE                 db    0
.xdata$x:00006DBF                 db    0
.xdata$x:00006DC0                 db    0
.xdata$x:00006DC1                 db    0
.xdata$x:00006DC2                 db    0
.xdata$x:00006DC3                 db    0
.xdata$x:00006DC4                 db    0
.xdata$x:00006DC5                 db    0
.xdata$x:00006DC6                 db    0
.xdata$x:00006DC7                 db    0
.xdata$x:00006DC8                 db    0
.xdata$x:00006DC9                 db    0
.xdata$x:00006DCA                 db    0
.xdata$x:00006DCB                 db    0
.xdata$x:00006DCC                 db    1
.xdata$x:00006DCD                 db    0
.xdata$x:00006DCE                 db    0
.xdata$x:00006DCF                 db    0
.xdata$x:00006DD0 __unwindtable$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z db 0FFh
.xdata$x:00006DD0                                         ; DATA XREF: .xdata$x:00006DE8o
.xdata$x:00006DD1                 db 0FFh
.xdata$x:00006DD2                 db 0FFh
.xdata$x:00006DD3                 db 0FFh
.xdata$x:00006DD4                 dd offset __unwindfunclet$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z$0
.xdata$x:00006DD8                 db    0
.xdata$x:00006DD9                 db    0
.xdata$x:00006DDA                 db    0
.xdata$x:00006DDB                 db    0
.xdata$x:00006DDC                 dd offset __unwindfunclet$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z$1
.xdata$x:00006DE0 __ehfuncinfo$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z db  22h ; "
.xdata$x:00006DE0                                         ; DATA XREF: __ehhandler$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z+11o
.xdata$x:00006DE1                 db    5
.xdata$x:00006DE2                 db  93h ; ô
.xdata$x:00006DE3                 db  19h
.xdata$x:00006DE4                 db    2
.xdata$x:00006DE5                 db    0
.xdata$x:00006DE6                 db    0
.xdata$x:00006DE7                 db    0
.xdata$x:00006DE8                 dd offset __unwindtable$?SendMessageError_with_LastError@CArchiveExtractCallback@@AAEJPBDABVUString@@@Z
.xdata$x:00006DEC                 align 20h
.xdata$x:00006E00                 db    1
.xdata$x:00006E01                 db    0
.xdata$x:00006E02                 db    0
.xdata$x:00006E03                 db    0
.xdata$x:00006E04 __unwindtable$?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z db 0FFh
.xdata$x:00006E04                                         ; DATA XREF: .xdata$x:00006E14o
.xdata$x:00006E05                 db 0FFh
.xdata$x:00006E06                 db 0FFh
.xdata$x:00006E07                 db 0FFh
.xdata$x:00006E08                 dd offset __unwindfunclet$?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z$0
.xdata$x:00006E0C __ehfuncinfo$?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z db  22h ; "
.xdata$x:00006E0C                                         ; DATA XREF: __ehhandler$?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z+11o
.xdata$x:00006E0D                 db    5
.xdata$x:00006E0E                 db  93h ; ô
.xdata$x:00006E0F                 db  19h
.xdata$x:00006E10                 db    1
.xdata$x:00006E11                 db    0
.xdata$x:00006E12                 db    0
.xdata$x:00006E13                 db    0
.xdata$x:00006E14                 dd offset __unwindtable$?SendMessageError2@CArchiveExtractCallback@@AAEJPBDABVUString@@1@Z
.xdata$x:00006E18                 db    0
.xdata$x:00006E19                 db    0
.xdata$x:00006E1A                 db    0
.xdata$x:00006E1B                 db    0
.xdata$x:00006E1C                 db    0
.xdata$x:00006E1D                 db    0
.xdata$x:00006E1E                 db    0
.xdata$x:00006E1F                 db    0
.xdata$x:00006E20                 db    0
.xdata$x:00006E21                 db    0
.xdata$x:00006E22                 db    0
.xdata$x:00006E23                 db    0
.xdata$x:00006E24                 db    0
.xdata$x:00006E25                 db    0
.xdata$x:00006E26                 db    0
.xdata$x:00006E27                 db    0
.xdata$x:00006E28                 db    0
.xdata$x:00006E29                 db    0
.xdata$x:00006E2A                 db    0
.xdata$x:00006E2B                 db    0
.xdata$x:00006E2C                 db    1
.xdata$x:00006E2D                 db    0
.xdata$x:00006E2E                 db    0
.xdata$x:00006E2F                 db    0
.xdata$x:00006E30 __unwindtable$?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z db 0FFh
.xdata$x:00006E30                                         ; DATA XREF: .xdata$x:00006E40o
.xdata$x:00006E31                 db 0FFh
.xdata$x:00006E32                 db 0FFh
.xdata$x:00006E33                 db 0FFh
.xdata$x:00006E34                 dd offset __unwindfunclet$?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z$0
.xdata$x:00006E38 __ehfuncinfo$?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z db  22h ; "
.xdata$x:00006E38                                         ; DATA XREF: __ehhandler$?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z+11o
.xdata$x:00006E39                 db    5
.xdata$x:00006E3A                 db  93h ; ô
.xdata$x:00006E3B                 db  19h
.xdata$x:00006E3C                 db    1
.xdata$x:00006E3D                 db    0
.xdata$x:00006E3E                 db    0
.xdata$x:00006E3F                 db    0
.xdata$x:00006E40                 dd offset __unwindtable$?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z
.xdata$x:00006E44                 db    0
.xdata$x:00006E45                 db    0
.xdata$x:00006E46                 db    0
.xdata$x:00006E47                 db    0
.xdata$x:00006E48                 db    0
.xdata$x:00006E49                 db    0
.xdata$x:00006E4A                 db    0
.xdata$x:00006E4B                 db    0
.xdata$x:00006E4C                 db    0
.xdata$x:00006E4D                 db    0
.xdata$x:00006E4E                 db    0
.xdata$x:00006E4F                 db    0
.xdata$x:00006E50                 db    0
.xdata$x:00006E51                 db    0
.xdata$x:00006E52                 db    0
.xdata$x:00006E53                 db    0
.xdata$x:00006E54                 db    0
.xdata$x:00006E55                 db    0
.xdata$x:00006E56                 db    0
.xdata$x:00006E57                 db    0
.xdata$x:00006E58                 db    1
.xdata$x:00006E59                 db    0
.xdata$x:00006E5A                 db    0
.xdata$x:00006E5B                 db    0
.xdata$x:00006E5C __catchsym$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$37 dd offset aNameExistingFi+12h
.xdata$x:00006E5C                                         ; DATA XREF: .xdata$x:00006E7Co
.xdata$x:00006E5C                                         ; ""
.xdata$x:00006E60                 db    0
.xdata$x:00006E61                 db    0
.xdata$x:00006E62                 db    0
.xdata$x:00006E63                 db    0
.xdata$x:00006E64                 db    0
.xdata$x:00006E65                 db    0
.xdata$x:00006E66                 db    0
.xdata$x:00006E67                 db    0
.xdata$x:00006E68                 dd offset __catch$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$0
.xdata$x:00006E6C __tryblocktable$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z db    0
.xdata$x:00006E6C                                         ; DATA XREF: .xdata$x:00006E90o
.xdata$x:00006E6D                 db    0
.xdata$x:00006E6E                 db    0
.xdata$x:00006E6F                 db    0
.xdata$x:00006E70                 db  24h ; $
.xdata$x:00006E71                 db    0
.xdata$x:00006E72                 db    0
.xdata$x:00006E73                 db    0
.xdata$x:00006E74                 db  25h ; %
.xdata$x:00006E75                 db    0
.xdata$x:00006E76                 db    0
.xdata$x:00006E77                 db    0
.xdata$x:00006E78                 db    1
.xdata$x:00006E79                 db    0
.xdata$x:00006E7A                 db    0
.xdata$x:00006E7B                 db    0
.xdata$x:00006E7C                 dd offset __catchsym$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$37
.xdata$x:00006E80 __ehfuncinfo$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z db  22h ; "
.xdata$x:00006E80                                         ; DATA XREF: __ehhandler$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z+1Eo
.xdata$x:00006E81                 db    5
.xdata$x:00006E82                 db  93h ; ô
.xdata$x:00006E83                 db  19h
.xdata$x:00006E84                 db  26h ; &
.xdata$x:00006E85                 db    0
.xdata$x:00006E86                 db    0
.xdata$x:00006E87                 db    0
.xdata$x:00006E88                 dd offset __unwindtable$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z
.xdata$x:00006E8C                 db    1
.xdata$x:00006E8D                 db    0
.xdata$x:00006E8E                 db    0
.xdata$x:00006E8F                 db    0
.xdata$x:00006E90                 dd offset __tryblocktable$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z
.xdata$x:00006E94                 align 10h
.xdata$x:00006EA0                 db    1
.xdata$x:00006EA1                 db    0
.xdata$x:00006EA2                 db    0
.xdata$x:00006EA3                 db    0
.xdata$x:00006EA4 __unwindtable$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z db 0FFh
.xdata$x:00006EA4                                         ; DATA XREF: .xdata$x:00006E88o
.xdata$x:00006EA5                 db 0FFh
.xdata$x:00006EA6                 db 0FFh
.xdata$x:00006EA7                 db 0FFh
.xdata$x:00006EA8                 db    0
.xdata$x:00006EA9                 db    0
.xdata$x:00006EAA                 db    0
.xdata$x:00006EAB                 db    0
.xdata$x:00006EAC                 db    0
.xdata$x:00006EAD                 db    0
.xdata$x:00006EAE                 db    0
.xdata$x:00006EAF                 db    0
.xdata$x:00006EB0                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$2
.xdata$x:00006EB4                 align 8
.xdata$x:00006EB8                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$3
.xdata$x:00006EBC                 db    2
.xdata$x:00006EBD                 db    0
.xdata$x:00006EBE                 db    0
.xdata$x:00006EBF                 db    0
.xdata$x:00006EC0                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$4
.xdata$x:00006EC4                 db    2
.xdata$x:00006EC5                 db    0
.xdata$x:00006EC6                 db    0
.xdata$x:00006EC7                 db    0
.xdata$x:00006EC8                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$5
.xdata$x:00006ECC                 db    2
.xdata$x:00006ECD                 db    0
.xdata$x:00006ECE                 db    0
.xdata$x:00006ECF                 db    0
.xdata$x:00006ED0                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$6
.xdata$x:00006ED4                 db    5
.xdata$x:00006ED5                 db    0
.xdata$x:00006ED6                 db    0
.xdata$x:00006ED7                 db    0
.xdata$x:00006ED8                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$7
.xdata$x:00006EDC                 db    6
.xdata$x:00006EDD                 db    0
.xdata$x:00006EDE                 db    0
.xdata$x:00006EDF                 db    0
.xdata$x:00006EE0                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$8
.xdata$x:00006EE4                 db    2
.xdata$x:00006EE5                 db    0
.xdata$x:00006EE6                 db    0
.xdata$x:00006EE7                 db    0
.xdata$x:00006EE8                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$9
.xdata$x:00006EEC                 db    8
.xdata$x:00006EED                 db    0
.xdata$x:00006EEE                 db    0
.xdata$x:00006EEF                 db    0
.xdata$x:00006EF0                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$10
.xdata$x:00006EF4                 db    2
.xdata$x:00006EF5                 db    0
.xdata$x:00006EF6                 db    0
.xdata$x:00006EF7                 db    0
.xdata$x:00006EF8                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$11
.xdata$x:00006EFC                 db    2
.xdata$x:00006EFD                 db    0
.xdata$x:00006EFE                 db    0
.xdata$x:00006EFF                 db    0
.xdata$x:00006F00                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$12
.xdata$x:00006F04                 db    2
.xdata$x:00006F05                 db    0
.xdata$x:00006F06                 db    0
.xdata$x:00006F07                 db    0
.xdata$x:00006F08                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$13
.xdata$x:00006F0C                 db  0Ch
.xdata$x:00006F0D                 db    0
.xdata$x:00006F0E                 db    0
.xdata$x:00006F0F                 db    0
.xdata$x:00006F10                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$14
.xdata$x:00006F14                 db  0Ch
.xdata$x:00006F15                 db    0
.xdata$x:00006F16                 db    0
.xdata$x:00006F17                 db    0
.xdata$x:00006F18                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$15
.xdata$x:00006F1C                 db  0Ch
.xdata$x:00006F1D                 db    0
.xdata$x:00006F1E                 db    0
.xdata$x:00006F1F                 db    0
.xdata$x:00006F20                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$16
.xdata$x:00006F24                 db  0Ch
.xdata$x:00006F25                 db    0
.xdata$x:00006F26                 db    0
.xdata$x:00006F27                 db    0
.xdata$x:00006F28                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$17
.xdata$x:00006F2C                 db  10h
.xdata$x:00006F2D                 db    0
.xdata$x:00006F2E                 db    0
.xdata$x:00006F2F                 db    0
.xdata$x:00006F30                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$18
.xdata$x:00006F34                 db  10h
.xdata$x:00006F35                 db    0
.xdata$x:00006F36                 db    0
.xdata$x:00006F37                 db    0
.xdata$x:00006F38                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$19
.xdata$x:00006F3C                 db  12h
.xdata$x:00006F3D                 db    0
.xdata$x:00006F3E                 db    0
.xdata$x:00006F3F                 db    0
.xdata$x:00006F40                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$20
.xdata$x:00006F44                 db  12h
.xdata$x:00006F45                 db    0
.xdata$x:00006F46                 db    0
.xdata$x:00006F47                 db    0
.xdata$x:00006F48                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$21
.xdata$x:00006F4C                 db  14h
.xdata$x:00006F4D                 db    0
.xdata$x:00006F4E                 db    0
.xdata$x:00006F4F                 db    0
.xdata$x:00006F50                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$22
.xdata$x:00006F54                 db  12h
.xdata$x:00006F55                 db    0
.xdata$x:00006F56                 db    0
.xdata$x:00006F57                 db    0
.xdata$x:00006F58                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$23
.xdata$x:00006F5C                 db  16h
.xdata$x:00006F5D                 db    0
.xdata$x:00006F5E                 db    0
.xdata$x:00006F5F                 db    0
.xdata$x:00006F60                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$24
.xdata$x:00006F64                 db  17h
.xdata$x:00006F65                 db    0
.xdata$x:00006F66                 db    0
.xdata$x:00006F67                 db    0
.xdata$x:00006F68                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$25
.xdata$x:00006F6C                 db  16h
.xdata$x:00006F6D                 db    0
.xdata$x:00006F6E                 db    0
.xdata$x:00006F6F                 db    0
.xdata$x:00006F70                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$25
.xdata$x:00006F74                 db  16h
.xdata$x:00006F75                 db    0
.xdata$x:00006F76                 db    0
.xdata$x:00006F77                 db    0
.xdata$x:00006F78                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$26
.xdata$x:00006F7C                 db  16h
.xdata$x:00006F7D                 db    0
.xdata$x:00006F7E                 db    0
.xdata$x:00006F7F                 db    0
.xdata$x:00006F80                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$27
.xdata$x:00006F84                 db  1Bh
.xdata$x:00006F85                 db    0
.xdata$x:00006F86                 db    0
.xdata$x:00006F87                 db    0
.xdata$x:00006F88                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$28
.xdata$x:00006F8C                 db  12h
.xdata$x:00006F8D                 db    0
.xdata$x:00006F8E                 db    0
.xdata$x:00006F8F                 db    0
.xdata$x:00006F90                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$29
.xdata$x:00006F94                 db  1Dh
.xdata$x:00006F95                 db    0
.xdata$x:00006F96                 db    0
.xdata$x:00006F97                 db    0
.xdata$x:00006F98                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$30
.xdata$x:00006F9C                 db  1Dh
.xdata$x:00006F9D                 db    0
.xdata$x:00006F9E                 db    0
.xdata$x:00006F9F                 db    0
.xdata$x:00006FA0                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$31
.xdata$x:00006FA4                 db  1Fh
.xdata$x:00006FA5                 db    0
.xdata$x:00006FA6                 db    0
.xdata$x:00006FA7                 db    0
.xdata$x:00006FA8                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$32
.xdata$x:00006FAC                 dd offset $SG76080+20h  ; "me"
.xdata$x:00006FB0                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$33
.xdata$x:00006FB4                 db  12h
.xdata$x:00006FB5                 db    0
.xdata$x:00006FB6                 db    0
.xdata$x:00006FB7                 db    0
.xdata$x:00006FB8                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$34
.xdata$x:00006FBC                 db  12h
.xdata$x:00006FBD                 db    0
.xdata$x:00006FBE                 db    0
.xdata$x:00006FBF                 db    0
.xdata$x:00006FC0                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$35
.xdata$x:00006FC4                 dd offset unk_23
.xdata$x:00006FC8                 dd offset __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$36
.xdata$x:00006FCC                 db 0FFh
.xdata$x:00006FCD                 db 0FFh
.xdata$x:00006FCE                 db 0FFh
.xdata$x:00006FCF                 db 0FFh
.xdata$x:00006FD0                 db    0
.xdata$x:00006FD1                 db    0
.xdata$x:00006FD2                 db    0
.xdata$x:00006FD3                 db    0
.xdata$x:00006FD4 __unwindtable$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z db 0FFh
.xdata$x:00006FD4                                         ; DATA XREF: .xdata$x:00006FECo
.xdata$x:00006FD5                 db 0FFh
.xdata$x:00006FD6                 db 0FFh
.xdata$x:00006FD7                 db 0FFh
.xdata$x:00006FD8                 dd offset __unwindfunclet$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z$1
.xdata$x:00006FDC                 align 10h
.xdata$x:00006FE0                 dd offset __unwindfunclet$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z$0
.xdata$x:00006FE4 __ehfuncinfo$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z db  22h ; "
.xdata$x:00006FE4                                         ; DATA XREF: __ehhandler$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z+11o
.xdata$x:00006FE5                 db    5
.xdata$x:00006FE6                 db  93h ; ô
.xdata$x:00006FE7                 db  19h
.xdata$x:00006FE8                 db    2
.xdata$x:00006FE9                 db    0
.xdata$x:00006FEA                 db    0
.xdata$x:00006FEB                 db    0
.xdata$x:00006FEC                 dd offset __unwindtable$?GetDirPrefixOf@@YG?AVUString@@ABV1@@Z
.xdata$x:00006FF0                 db    0
.xdata$x:00006FF1                 db    0
.xdata$x:00006FF2                 db    0
.xdata$x:00006FF3                 db    0
.xdata$x:00006FF4                 db    0
.xdata$x:00006FF5                 db    0
.xdata$x:00006FF6                 db    0
.xdata$x:00006FF7                 db    0
.xdata$x:00006FF8                 db    0
.xdata$x:00006FF9                 db    0
.xdata$x:00006FFA                 db    0
.xdata$x:00006FFB                 db    0
.xdata$x:00006FFC                 db    0
.xdata$x:00006FFD                 db    0
.xdata$x:00006FFE                 db    0
.xdata$x:00006FFF                 db    0
.xdata$x:00007000                 db    0
.xdata$x:00007001                 db    0
.xdata$x:00007002                 db    0
.xdata$x:00007003                 db    0
.xdata$x:00007004                 db    1
.xdata$x:00007005                 db    0
.xdata$x:00007006                 db    0
.xdata$x:00007007                 db    0
.xdata$x:00007008 __unwindtable$?IsSafePath@@YG_NABVUString@@@Z db 0FFh
.xdata$x:00007008                                         ; DATA XREF: .xdata$x:00007018o
.xdata$x:00007009                 db 0FFh
.xdata$x:0000700A                 db 0FFh
.xdata$x:0000700B                 db 0FFh
.xdata$x:0000700C                 dd offset __unwindfunclet$?IsSafePath@@YG_NABVUString@@@Z$0
.xdata$x:00007010 __ehfuncinfo$?IsSafePath@@YG_NABVUString@@@Z db  22h ; "
.xdata$x:00007010                                         ; DATA XREF: __ehhandler$?IsSafePath@@YG_NABVUString@@@Z+11o
.xdata$x:00007011                 db    5
.xdata$x:00007012                 db  93h ; ô
.xdata$x:00007013                 db  19h
.xdata$x:00007014                 db    1
.xdata$x:00007015                 db    0
.xdata$x:00007016                 db    0
.xdata$x:00007017                 db    0
.xdata$x:00007018                 dd offset __unwindtable$?IsSafePath@@YG_NABVUString@@@Z
.xdata$x:0000701C                 db    0
.xdata$x:0000701D                 db    0
.xdata$x:0000701E                 db    0
.xdata$x:0000701F                 db    0
.xdata$x:00007020                 db    0
.xdata$x:00007021                 db    0
.xdata$x:00007022                 db    0
.xdata$x:00007023                 db    0
.xdata$x:00007024                 db    0
.xdata$x:00007025                 db    0
.xdata$x:00007026                 db    0
.xdata$x:00007027                 db    0
.xdata$x:00007028                 db    0
.xdata$x:00007029                 db    0
.xdata$x:0000702A                 db    0
.xdata$x:0000702B                 db    0
.xdata$x:0000702C                 db    0
.xdata$x:0000702D                 db    0
.xdata$x:0000702E                 db    0
.xdata$x:0000702F                 db    0
.xdata$x:00007030                 db    1
.xdata$x:00007031                 db    0
.xdata$x:00007032                 db    0
.xdata$x:00007033                 db    0
.xdata$x:00007034 __unwindtable$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z db 0FFh
.xdata$x:00007034                                         ; DATA XREF: .xdata$x:0000704Co
.xdata$x:00007035                 db 0FFh
.xdata$x:00007036                 db 0FFh
.xdata$x:00007037                 db 0FFh
.xdata$x:00007038                 dd offset __unwindfunclet$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z$1
.xdata$x:0000703C                 align 10h
.xdata$x:00007040                 dd offset __unwindfunclet$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z$0
.xdata$x:00007044 __ehfuncinfo$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z db  22h ; "
.xdata$x:00007044                                         ; DATA XREF: __ehhandler$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z+11o
.xdata$x:00007045                 db    5
.xdata$x:00007046                 db  93h ; ô
.xdata$x:00007047                 db  19h
.xdata$x:00007048                 db    2
.xdata$x:00007049                 db    0
.xdata$x:0000704A                 db    0
.xdata$x:0000704B                 db    0
.xdata$x:0000704C                 dd offset __unwindtable$?MakePath_from_2_Parts@@YG?AVUString@@ABV1@0@Z
.xdata$x:00007050                 db    0
.xdata$x:00007051                 db    0
.xdata$x:00007052                 db    0
.xdata$x:00007053                 db    0
.xdata$x:00007054                 db    0
.xdata$x:00007055                 db    0
.xdata$x:00007056                 db    0
.xdata$x:00007057                 db    0
.xdata$x:00007058                 db    0
.xdata$x:00007059                 db    0
.xdata$x:0000705A                 db    0
.xdata$x:0000705B                 db    0
.xdata$x:0000705C                 db    0
.xdata$x:0000705D                 db    0
.xdata$x:0000705E                 db    0
.xdata$x:0000705F                 db    0
.xdata$x:00007060                 db    0
.xdata$x:00007061                 db    0
.xdata$x:00007062                 db    0
.xdata$x:00007063                 db    0
.xdata$x:00007064                 db    1
.xdata$x:00007065                 db    0
.xdata$x:00007066                 db    0
.xdata$x:00007067                 db    0
.xdata$x:00007068 __catchsym$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z$2 dd offset aNameExistingFi+12h
.xdata$x:00007068                                         ; DATA XREF: .xdata$x:00007098o
.xdata$x:00007068                                         ; ""
.xdata$x:0000706C                 db    0
.xdata$x:0000706D                 db    0
.xdata$x:0000706E                 db    0
.xdata$x:0000706F                 db    0
.xdata$x:00007070                 db    0
.xdata$x:00007071                 db    0
.xdata$x:00007072                 db    0
.xdata$x:00007073                 db    0
.xdata$x:00007074                 dd offset __catch$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z$0
.xdata$x:00007078 __unwindtable$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z db 0FFh
.xdata$x:00007078                                         ; DATA XREF: .xdata$x:000070A4o
.xdata$x:00007079                 db 0FFh
.xdata$x:0000707A                 db 0FFh
.xdata$x:0000707B                 db 0FFh
.xdata$x:0000707C                 db    0
.xdata$x:0000707D                 db    0
.xdata$x:0000707E                 db    0
.xdata$x:0000707F                 db    0
.xdata$x:00007080                 db 0FFh
.xdata$x:00007081                 db 0FFh
.xdata$x:00007082                 db 0FFh
.xdata$x:00007083                 db 0FFh
.xdata$x:00007084                 db    0
.xdata$x:00007085                 db    0
.xdata$x:00007086                 db    0
.xdata$x:00007087                 db    0
.xdata$x:00007088 __tryblocktable$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z db    0
.xdata$x:00007088                                         ; DATA XREF: .xdata$x:000070ACo
.xdata$x:00007089                 db    0
.xdata$x:0000708A                 db    0
.xdata$x:0000708B                 db    0
.xdata$x:0000708C                 db    0
.xdata$x:0000708D                 db    0
.xdata$x:0000708E                 db    0
.xdata$x:0000708F                 db    0
.xdata$x:00007090                 db    1
.xdata$x:00007091                 db    0
.xdata$x:00007092                 db    0
.xdata$x:00007093                 db    0
.xdata$x:00007094                 db    1
.xdata$x:00007095                 db    0
.xdata$x:00007096                 db    0
.xdata$x:00007097                 db    0
.xdata$x:00007098                 dd offset __catchsym$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z$2
.xdata$x:0000709C __ehfuncinfo$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z db  22h ; "
.xdata$x:0000709C                                         ; DATA XREF: __ehhandler$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z+11o
.xdata$x:0000709D                 db    5
.xdata$x:0000709E                 db  93h ; ô
.xdata$x:0000709F                 db  19h
.xdata$x:000070A0                 db    2
.xdata$x:000070A1                 db    0
.xdata$x:000070A2                 db    0
.xdata$x:000070A3                 db    0
.xdata$x:000070A4                 dd offset __unwindtable$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z
.xdata$x:000070A8                 db    1
.xdata$x:000070A9                 db    0
.xdata$x:000070AA                 db    0
.xdata$x:000070AB                 db    0
.xdata$x:000070AC                 dd offset __tryblocktable$?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z
.xdata$x:000070B0                 db    0
.xdata$x:000070B1                 db    0
.xdata$x:000070B2                 db    0
.xdata$x:000070B3                 db    0
.xdata$x:000070B4                 db    0
.xdata$x:000070B5                 db    0
.xdata$x:000070B6                 db    0
.xdata$x:000070B7                 db    0
.xdata$x:000070B8                 db    0
.xdata$x:000070B9                 db    0
.xdata$x:000070BA                 db    0
.xdata$x:000070BB                 db    0
.xdata$x:000070BC                 db    1
.xdata$x:000070BD                 db    0
.xdata$x:000070BE                 db    0
.xdata$x:000070BF                 db    0
.xdata$x:000070C0 __catchsym$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z$2 dd offset aNameExistingFi+12h
.xdata$x:000070C0                                         ; DATA XREF: .xdata$x:000070F0o
.xdata$x:000070C0                                         ; ""
.xdata$x:000070C4                 db    0
.xdata$x:000070C5                 db    0
.xdata$x:000070C6                 db    0
.xdata$x:000070C7                 db    0
.xdata$x:000070C8                 db    0
.xdata$x:000070C9                 db    0
.xdata$x:000070CA                 db    0
.xdata$x:000070CB                 db    0
.xdata$x:000070CC                 dd offset __catch$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z$0
.xdata$x:000070D0 __unwindtable$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z db 0FFh
.xdata$x:000070D0                                         ; DATA XREF: .xdata$x:000070FCo
.xdata$x:000070D1                 db 0FFh
.xdata$x:000070D2                 db 0FFh
.xdata$x:000070D3                 db 0FFh
.xdata$x:000070D4                 db    0
.xdata$x:000070D5                 db    0
.xdata$x:000070D6                 db    0
.xdata$x:000070D7                 db    0
.xdata$x:000070D8                 db 0FFh
.xdata$x:000070D9                 db 0FFh
.xdata$x:000070DA                 db 0FFh
.xdata$x:000070DB                 db 0FFh
.xdata$x:000070DC                 db    0
.xdata$x:000070DD                 db    0
.xdata$x:000070DE                 db    0
.xdata$x:000070DF                 db    0
.xdata$x:000070E0 __tryblocktable$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z db    0
.xdata$x:000070E0                                         ; DATA XREF: .xdata$x:00007104o
.xdata$x:000070E1                 db    0
.xdata$x:000070E2                 db    0
.xdata$x:000070E3                 db    0
.xdata$x:000070E4                 db    0
.xdata$x:000070E5                 db    0
.xdata$x:000070E6                 db    0
.xdata$x:000070E7                 db    0
.xdata$x:000070E8                 db    1
.xdata$x:000070E9                 db    0
.xdata$x:000070EA                 db    0
.xdata$x:000070EB                 db    0
.xdata$x:000070EC                 db    1
.xdata$x:000070ED                 db    0
.xdata$x:000070EE                 db    0
.xdata$x:000070EF                 db    0
.xdata$x:000070F0                 dd offset __catchsym$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z$2
.xdata$x:000070F4 __ehfuncinfo$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z db  22h ; "
.xdata$x:000070F4                                         ; DATA XREF: __ehhandler$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z+14o
.xdata$x:000070F5                 db    5
.xdata$x:000070F6                 db  93h ; ô
.xdata$x:000070F7                 db  19h
.xdata$x:000070F8                 db    2
.xdata$x:000070F9                 db    0
.xdata$x:000070FA                 db    0
.xdata$x:000070FB                 db    0
.xdata$x:000070FC                 dd offset __unwindtable$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z
.xdata$x:00007100                 db    1
.xdata$x:00007101                 db    0
.xdata$x:00007102                 db    0
.xdata$x:00007103                 db    0
.xdata$x:00007104                 dd offset __tryblocktable$?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z
.xdata$x:00007108                 db    0
.xdata$x:00007109                 db    0
.xdata$x:0000710A                 db    0
.xdata$x:0000710B                 db    0
.xdata$x:0000710C                 db    0
.xdata$x:0000710D                 db    0
.xdata$x:0000710E                 db    0
.xdata$x:0000710F                 db    0
.xdata$x:00007110                 db    0
.xdata$x:00007111                 db    0
.xdata$x:00007112                 db    0
.xdata$x:00007113                 db    0
.xdata$x:00007114                 db    1
.xdata$x:00007115                 db    0
.xdata$x:00007116                 db    0
.xdata$x:00007117                 db    0
.xdata$x:00007118 __catchsym$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z$2 dd offset aNameExistingFi+12h
.xdata$x:00007118                                         ; DATA XREF: .xdata$x:00007148o
.xdata$x:00007118                                         ; ""
.xdata$x:0000711C                 db    0
.xdata$x:0000711D                 db    0
.xdata$x:0000711E                 db    0
.xdata$x:0000711F                 db    0
.xdata$x:00007120                 db    0
.xdata$x:00007121                 db    0
.xdata$x:00007122                 db    0
.xdata$x:00007123                 db    0
.xdata$x:00007124                 dd offset __catch$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z$0
.xdata$x:00007128 __unwindtable$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z db 0FFh
.xdata$x:00007128                                         ; DATA XREF: .xdata$x:00007154o
.xdata$x:00007129                 db 0FFh
.xdata$x:0000712A                 db 0FFh
.xdata$x:0000712B                 db 0FFh
.xdata$x:0000712C                 db    0
.xdata$x:0000712D                 db    0
.xdata$x:0000712E                 db    0
.xdata$x:0000712F                 db    0
.xdata$x:00007130                 db 0FFh
.xdata$x:00007131                 db 0FFh
.xdata$x:00007132                 db 0FFh
.xdata$x:00007133                 db 0FFh
.xdata$x:00007134                 db    0
.xdata$x:00007135                 db    0
.xdata$x:00007136                 db    0
.xdata$x:00007137                 db    0
.xdata$x:00007138 __tryblocktable$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z db    0
.xdata$x:00007138                                         ; DATA XREF: .xdata$x:0000715Co
.xdata$x:00007139                 db    0
.xdata$x:0000713A                 db    0
.xdata$x:0000713B                 db    0
.xdata$x:0000713C                 db    0
.xdata$x:0000713D                 db    0
.xdata$x:0000713E                 db    0
.xdata$x:0000713F                 db    0
.xdata$x:00007140                 db    1
.xdata$x:00007141                 db    0
.xdata$x:00007142                 db    0
.xdata$x:00007143                 db    0
.xdata$x:00007144                 db    1
.xdata$x:00007145                 db    0
.xdata$x:00007146                 db    0
.xdata$x:00007147                 db    0
.xdata$x:00007148                 dd offset __catchsym$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z$2
.xdata$x:0000714C __ehfuncinfo$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z db  22h ; "
.xdata$x:0000714C                                         ; DATA XREF: __ehhandler$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z+11o
.xdata$x:0000714D                 db    5
.xdata$x:0000714E                 db  93h ; ô
.xdata$x:0000714F                 db  19h
.xdata$x:00007150                 db    2
.xdata$x:00007151                 db    0
.xdata$x:00007152                 db    0
.xdata$x:00007153                 db    0
.xdata$x:00007154                 dd offset __unwindtable$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z
.xdata$x:00007158                 db    1
.xdata$x:00007159                 db    0
.xdata$x:0000715A                 db    0
.xdata$x:0000715B                 db    0
.xdata$x:0000715C                 dd offset __tryblocktable$?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z
.xdata$x:00007160                 db    0
.xdata$x:00007161                 db    0
.xdata$x:00007162                 db    0
.xdata$x:00007163                 db    0
.xdata$x:00007164                 db    0
.xdata$x:00007165                 db    0
.xdata$x:00007166                 db    0
.xdata$x:00007167                 db    0
.xdata$x:00007168                 db    0
.xdata$x:00007169                 db    0
.xdata$x:0000716A                 db    0
.xdata$x:0000716B                 db    0
.xdata$x:0000716C                 db    1
.xdata$x:0000716D                 db    0
.xdata$x:0000716E                 db    0
.xdata$x:0000716F                 db    0
.xdata$x:00007170 __unwindtable$?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ db 0FFh
.xdata$x:00007170                                         ; DATA XREF: .xdata$x:00007180o
.xdata$x:00007171                 db 0FFh
.xdata$x:00007172                 db 0FFh
.xdata$x:00007173                 db 0FFh
.xdata$x:00007174                 dd offset __unwindfunclet$?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ$0
.xdata$x:00007178 __ehfuncinfo$?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ db  22h ; "
.xdata$x:00007178                                         ; DATA XREF: __ehhandler$?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ+14o
.xdata$x:00007179                 db    5
.xdata$x:0000717A                 db  93h ; ô
.xdata$x:0000717B                 db  19h
.xdata$x:0000717C                 db    1
.xdata$x:0000717D                 db    0
.xdata$x:0000717E                 db    0
.xdata$x:0000717F                 db    0
.xdata$x:00007180                 dd offset __unwindtable$?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ
.xdata$x:00007184                 db    0
.xdata$x:00007185                 db    0
.xdata$x:00007186                 db    0
.xdata$x:00007187                 db    0
.xdata$x:00007188                 db    0
.xdata$x:00007189                 db    0
.xdata$x:0000718A                 db    0
.xdata$x:0000718B                 db    0
.xdata$x:0000718C                 db    0
.xdata$x:0000718D                 db    0
.xdata$x:0000718E                 db    0
.xdata$x:0000718F                 db    0
.xdata$x:00007190                 db    0
.xdata$x:00007191                 db    0
.xdata$x:00007192                 db    0
.xdata$x:00007193                 db    0
.xdata$x:00007194                 db    0
.xdata$x:00007195                 db    0
.xdata$x:00007196                 db    0
.xdata$x:00007197                 db    0
.xdata$x:00007198                 db    1
.xdata$x:00007199                 db    0
.xdata$x:0000719A                 db    0
.xdata$x:0000719B                 db    0
.xdata$x:0000719B _xdata$x        ends
.xdata$x:0000719B
.text:0000719C ; ===========================================================================
.text:0000719C
.text:0000719C ; Segment type: Pure code
.text:0000719C ; Segment permissions: Read/Execute
.text:0000719C _text           segment para public 'CODE' use32
.text:0000719C                 assume cs:_text
.text:0000719C                 ;org 719Ch
.text:0000719C ; COMDAT (pick any)
.text:0000719C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000719C
.text:0000719C ; =============== S U B R O U T I N E =======================================
.text:0000719C
.text:0000719C ; Attributes: bp-based frame
.text:0000719C
.text:0000719C ; _DWORD __thiscall NWindows::NSecurity::CAccessToken::CAccessToken(NWindows::NSecurity::CAccessToken *__hidden this)
.text:0000719C                 public ??0CAccessToken@NSecurity@NWindows@@QAE@XZ
.text:0000719C ??0CAccessToken@NSecurity@NWindows@@QAE@XZ proc near
.text:0000719C                                         ; CODE XREF: InitLocalPrivileges(void)+3Cp
.text:0000719C
.text:0000719C var_4           = dword ptr -4
.text:0000719C
.text:0000719C                 push    ebp
.text:0000719D                 mov     ebp, esp
.text:0000719F                 push    ecx
.text:000071A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000071A7                 mov     [ebp+var_4], ecx
.text:000071AA                 mov     eax, [ebp+var_4]
.text:000071AD                 mov     dword ptr [eax], 0
.text:000071B3                 mov     eax, [ebp+var_4]
.text:000071B6                 mov     esp, ebp
.text:000071B8                 pop     ebp
.text:000071B9                 retn
.text:000071B9 ??0CAccessToken@NSecurity@NWindows@@QAE@XZ endp
.text:000071B9
.text:000071B9 ; ---------------------------------------------------------------------------
.text:000071BA                 align 4
.text:000071BA _text           ends
.text:000071BA
.text:000071BC ; ===========================================================================
.text:000071BC
.text:000071BC ; Segment type: Pure code
.text:000071BC ; Segment permissions: Read/Execute
.text:000071BC _text           segment para public 'CODE' use32
.text:000071BC                 assume cs:_text
.text:000071BC                 ;org 71BCh
.text:000071BC ; COMDAT (pick any)
.text:000071BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000071BC
.text:000071BC ; =============== S U B R O U T I N E =======================================
.text:000071BC
.text:000071BC ; Attributes: bp-based frame
.text:000071BC
.text:000071BC ; _DWORD __thiscall NWindows::NSecurity::CAccessToken::~CAccessToken(NWindows::NSecurity::CAccessToken *__hidden this)
.text:000071BC                 public ??1CAccessToken@NSecurity@NWindows@@QAE@XZ
.text:000071BC ??1CAccessToken@NSecurity@NWindows@@QAE@XZ proc near
.text:000071BC                                         ; CODE XREF: InitLocalPrivileges(void)+77p
.text:000071BC                                         ; InitLocalPrivileges(void)+BEp ...
.text:000071BC
.text:000071BC var_4           = dword ptr -4
.text:000071BC
.text:000071BC                 push    ebp
.text:000071BD                 mov     ebp, esp
.text:000071BF                 push    ecx
.text:000071C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000071C7                 mov     [ebp+var_4], ecx
.text:000071CA                 mov     ecx, [ebp+var_4] ; this
.text:000071CD                 call    ?Close@CAccessToken@NSecurity@NWindows@@QAE_NXZ ; NWindows::NSecurity::CAccessToken::Close(void)
.text:000071D2                 add     esp, 4
.text:000071D5                 cmp     ebp, esp
.text:000071D7                 call    __RTC_CheckEsp
.text:000071DC                 mov     esp, ebp
.text:000071DE                 pop     ebp
.text:000071DF                 retn
.text:000071DF ??1CAccessToken@NSecurity@NWindows@@QAE@XZ endp
.text:000071DF
.text:000071DF _text           ends
.text:000071DF
.text:000071E0 ; ===========================================================================
.text:000071E0
.text:000071E0 ; Segment type: Pure code
.text:000071E0 ; Segment permissions: Read/Execute
.text:000071E0 _text           segment para public 'CODE' use32
.text:000071E0                 assume cs:_text
.text:000071E0                 ;org 71E0h
.text:000071E0 ; COMDAT (pick any)
.text:000071E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000071E0
.text:000071E0 ; =============== S U B R O U T I N E =======================================
.text:000071E0
.text:000071E0 ; Attributes: bp-based frame
.text:000071E0
.text:000071E0 ; bool __thiscall NWindows::NSecurity::CAccessToken::Close(NWindows::NSecurity::CAccessToken *__hidden this)
.text:000071E0                 public ?Close@CAccessToken@NSecurity@NWindows@@QAE_NXZ
.text:000071E0 ?Close@CAccessToken@NSecurity@NWindows@@QAE_NXZ proc near
.text:000071E0                                         ; CODE XREF: NWindows::NSecurity::CAccessToken::~CAccessToken(void)+11p
.text:000071E0                                         ; NWindows::NSecurity::CAccessToken::OpenProcessToken(void *,ulong)+12p
.text:000071E0
.text:000071E0 var_8           = dword ptr -8
.text:000071E0 var_4           = dword ptr -4
.text:000071E0
.text:000071E0                 push    ebp
.text:000071E1                 mov     ebp, esp
.text:000071E3                 sub     esp, 8
.text:000071E6                 push    esi
.text:000071E7                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000071EE                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000071F5                 mov     [ebp+var_4], ecx
.text:000071F8                 mov     eax, [ebp+var_4]
.text:000071FB                 cmp     dword ptr [eax], 0
.text:000071FE                 jnz     short loc_7204
.text:00007200                 mov     al, 1
.text:00007202                 jmp     short loc_7236
.text:00007204 ; ---------------------------------------------------------------------------
.text:00007204
.text:00007204 loc_7204:                               ; CODE XREF: NWindows::NSecurity::CAccessToken::Close(void)+1Ej
.text:00007204                 mov     esi, esp
.text:00007206                 mov     ecx, [ebp+var_4]
.text:00007209                 mov     edx, [ecx]
.text:0000720B                 push    edx             ; hObject
.text:0000720C                 call    dword ptr ds:__imp__CloseHandle@4 ; CloseHandle(x)
.text:00007212                 cmp     esi, esp
.text:00007214                 call    __RTC_CheckEsp
.text:00007219                 push    eax             ; int
.text:0000721A                 call    ?BOOLToBool@@YG_NH@Z ; BOOLToBool(int)
.text:0000721F                 mov     byte ptr [ebp+var_8+3], al
.text:00007222                 movzx   eax, byte ptr [ebp+var_8+3]
.text:00007226                 test    eax, eax
.text:00007228                 jz      short loc_7233
.text:0000722A                 mov     ecx, [ebp+var_4]
.text:0000722D                 mov     dword ptr [ecx], 0
.text:00007233
.text:00007233 loc_7233:                               ; CODE XREF: NWindows::NSecurity::CAccessToken::Close(void)+48j
.text:00007233                 mov     al, byte ptr [ebp+var_8+3]
.text:00007236
.text:00007236 loc_7236:                               ; CODE XREF: NWindows::NSecurity::CAccessToken::Close(void)+22j
.text:00007236                 pop     esi
.text:00007237                 add     esp, 8
.text:0000723A                 cmp     ebp, esp
.text:0000723C                 call    __RTC_CheckEsp
.text:00007241                 mov     esp, ebp
.text:00007243                 pop     ebp
.text:00007244                 retn
.text:00007244 ?Close@CAccessToken@NSecurity@NWindows@@QAE_NXZ endp
.text:00007244
.text:00007244 ; ---------------------------------------------------------------------------
.text:00007245                 align 4
.text:00007245 _text           ends
.text:00007245
.text:00007248 ; ===========================================================================
.text:00007248
.text:00007248 ; Segment type: Pure code
.text:00007248 ; Segment permissions: Read/Execute
.text:00007248 _text           segment para public 'CODE' use32
.text:00007248                 assume cs:_text
.text:00007248                 ;org 7248h
.text:00007248 ; COMDAT (pick any)
.text:00007248                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007248
.text:00007248 ; =============== S U B R O U T I N E =======================================
.text:00007248
.text:00007248 ; Attributes: bp-based frame
.text:00007248
.text:00007248 ; bool __stdcall BOOLToBool(int)
.text:00007248                 public ?BOOLToBool@@YG_NH@Z
.text:00007248 ?BOOLToBool@@YG_NH@Z proc near          ; CODE XREF: NWindows::NSecurity::CAccessToken::Close(void)+3Ap
.text:00007248                                         ; NWindows::NSecurity::CAccessToken::OpenProcessToken(void *,ulong)+33p ...
.text:00007248
.text:00007248 arg_0           = dword ptr  8
.text:00007248
.text:00007248                 push    ebp
.text:00007249                 mov     ebp, esp
.text:0000724B                 xor     eax, eax
.text:0000724D                 cmp     [ebp+arg_0], 0
.text:00007251                 setnz   al
.text:00007254                 pop     ebp
.text:00007255                 retn    4
.text:00007255 ?BOOLToBool@@YG_NH@Z endp
.text:00007255
.text:00007255 _text           ends
.text:00007255
.text:00007258 ; ===========================================================================
.text:00007258
.text:00007258 ; Segment type: Pure code
.text:00007258 ; Segment permissions: Read/Execute
.text:00007258 _text           segment para public 'CODE' use32
.text:00007258                 assume cs:_text
.text:00007258                 ;org 7258h
.text:00007258 ; COMDAT (pick any)
.text:00007258                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007258
.text:00007258 ; =============== S U B R O U T I N E =======================================
.text:00007258
.text:00007258 ; Attributes: bp-based frame
.text:00007258
.text:00007258 ; bool __thiscall NWindows::NSecurity::CAccessToken::OpenProcessToken(NWindows::NSecurity::CAccessToken *this, HANDLE ProcessHandle, unsigned __int32)
.text:00007258                 public ?OpenProcessToken@CAccessToken@NSecurity@NWindows@@QAE_NPAXK@Z
.text:00007258 ?OpenProcessToken@CAccessToken@NSecurity@NWindows@@QAE_NPAXK@Z proc near
.text:00007258                                         ; CODE XREF: InitLocalPrivileges(void)+5Dp
.text:00007258
.text:00007258 TokenHandle     = dword ptr -4
.text:00007258 ProcessHandle   = dword ptr  8
.text:00007258 DesiredAccess   = dword ptr  0Ch
.text:00007258
.text:00007258                 push    ebp
.text:00007259                 mov     ebp, esp
.text:0000725B                 push    ecx
.text:0000725C                 push    esi
.text:0000725D                 mov     [ebp+TokenHandle], 0CCCCCCCCh
.text:00007264                 mov     [ebp+TokenHandle], ecx
.text:00007267                 mov     ecx, [ebp+TokenHandle] ; this
.text:0000726A                 call    ?Close@CAccessToken@NSecurity@NWindows@@QAE_NXZ ; NWindows::NSecurity::CAccessToken::Close(void)
.text:0000726F                 mov     esi, esp
.text:00007271                 mov     eax, [ebp+TokenHandle]
.text:00007274                 push    eax             ; TokenHandle
.text:00007275                 mov     ecx, [ebp+DesiredAccess]
.text:00007278                 push    ecx             ; DesiredAccess
.text:00007279                 mov     edx, [ebp+ProcessHandle]
.text:0000727C                 push    edx             ; ProcessHandle
.text:0000727D                 call    dword ptr ds:__imp__OpenProcessToken@12 ; OpenProcessToken(x,x,x)
.text:00007283                 cmp     esi, esp
.text:00007285                 call    __RTC_CheckEsp
.text:0000728A                 push    eax             ; int
.text:0000728B                 call    ?BOOLToBool@@YG_NH@Z ; BOOLToBool(int)
.text:00007290                 pop     esi
.text:00007291                 add     esp, 4
.text:00007294                 cmp     ebp, esp
.text:00007296                 call    __RTC_CheckEsp
.text:0000729B                 mov     esp, ebp
.text:0000729D                 pop     ebp
.text:0000729E                 retn    8
.text:0000729E ?OpenProcessToken@CAccessToken@NSecurity@NWindows@@QAE_NPAXK@Z endp
.text:0000729E
.text:0000729E ; ---------------------------------------------------------------------------
.text:000072A1                 align 4
.text:000072A1 _text           ends
.text:000072A1
.text:000072A4 ; ===========================================================================
.text:000072A4
.text:000072A4 ; Segment type: Pure code
.text:000072A4 ; Segment permissions: Read/Execute
.text:000072A4 _text           segment para public 'CODE' use32
.text:000072A4                 assume cs:_text
.text:000072A4                 ;org 72A4h
.text:000072A4 ; COMDAT (pick any)
.text:000072A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000072A4
.text:000072A4 ; =============== S U B R O U T I N E =======================================
.text:000072A4
.text:000072A4 ; Attributes: bp-based frame
.text:000072A4
.text:000072A4 ; bool __thiscall NWindows::NSecurity::CAccessToken::AdjustPrivileges(NWindows::NSecurity::CAccessToken *this, struct _TOKEN_PRIVILEGES *)
.text:000072A4                 public ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_NPAU_TOKEN_PRIVILEGES@@@Z
.text:000072A4 ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_NPAU_TOKEN_PRIVILEGES@@@Z proc near
.text:000072A4                                         ; CODE XREF: InitLocalPrivileges(void)+CFp
.text:000072A4
.text:000072A4 var_4           = dword ptr -4
.text:000072A4 arg_0           = dword ptr  8
.text:000072A4
.text:000072A4                 push    ebp
.text:000072A5                 mov     ebp, esp
.text:000072A7                 push    ecx
.text:000072A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000072AF                 mov     [ebp+var_4], ecx
.text:000072B2                 mov     eax, [ebp+arg_0]
.text:000072B5                 push    eax             ; struct _TOKEN_PRIVILEGES *
.text:000072B6                 push    0               ; bool
.text:000072B8                 mov     ecx, [ebp+var_4] ; this
.text:000072BB                 call    ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_N_NPAU_TOKEN_PRIVILEGES@@@Z ; NWindows::NSecurity::CAccessToken::AdjustPrivileges(bool,_TOKEN_PRIVILEGES *)
.text:000072C0                 add     esp, 4
.text:000072C3                 cmp     ebp, esp
.text:000072C5                 call    __RTC_CheckEsp
.text:000072CA                 mov     esp, ebp
.text:000072CC                 pop     ebp
.text:000072CD                 retn    4
.text:000072CD ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_NPAU_TOKEN_PRIVILEGES@@@Z endp
.text:000072CD
.text:000072CD _text           ends
.text:000072CD
.text:000072D0 ; ===========================================================================
.text:000072D0
.text:000072D0 ; Segment type: Pure code
.text:000072D0 ; Segment permissions: Read/Execute
.text:000072D0 _text           segment para public 'CODE' use32
.text:000072D0                 assume cs:_text
.text:000072D0                 ;org 72D0h
.text:000072D0 ; COMDAT (pick any)
.text:000072D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000072D0
.text:000072D0 ; =============== S U B R O U T I N E =======================================
.text:000072D0
.text:000072D0 ; Attributes: bp-based frame
.text:000072D0
.text:000072D0 ; bool __thiscall NWindows::NSecurity::CAccessToken::AdjustPrivileges(NWindows::NSecurity::CAccessToken *this, bool, struct _TOKEN_PRIVILEGES *)
.text:000072D0                 public ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_N_NPAU_TOKEN_PRIVILEGES@@@Z
.text:000072D0 ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_N_NPAU_TOKEN_PRIVILEGES@@@Z proc near
.text:000072D0                                         ; CODE XREF: NWindows::NSecurity::CAccessToken::AdjustPrivileges(_TOKEN_PRIVILEGES *)+17p
.text:000072D0
.text:000072D0 var_4           = dword ptr -4
.text:000072D0 arg_0           = byte ptr  8
.text:000072D0 NewState        = dword ptr  0Ch
.text:000072D0
.text:000072D0                 push    ebp
.text:000072D1                 mov     ebp, esp
.text:000072D3                 push    ecx
.text:000072D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000072DB                 mov     [ebp+var_4], ecx
.text:000072DE                 push    0               ; unsigned __int32 *
.text:000072E0                 push    0               ; PreviousState
.text:000072E2                 push    0               ; BufferLength
.text:000072E4                 mov     eax, [ebp+NewState]
.text:000072E7                 push    eax             ; NewState
.text:000072E8                 movzx   ecx, [ebp+arg_0]
.text:000072EC                 push    ecx             ; bool
.text:000072ED                 mov     ecx, [ebp+var_4] ; this
.text:000072F0                 call    ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_N_NPAU_TOKEN_PRIVILEGES@@K1PAK@Z ; NWindows::NSecurity::CAccessToken::AdjustPrivileges(bool,_TOKEN_PRIVILEGES *,ulong,_TOKEN_PRIVILEGES *,ulong *)
.text:000072F5                 add     esp, 4
.text:000072F8                 cmp     ebp, esp
.text:000072FA                 call    __RTC_CheckEsp
.text:000072FF                 mov     esp, ebp
.text:00007301                 pop     ebp
.text:00007302                 retn    8
.text:00007302 ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_N_NPAU_TOKEN_PRIVILEGES@@@Z endp
.text:00007302
.text:00007302 ; ---------------------------------------------------------------------------
.text:00007305                 align 4
.text:00007305 _text           ends
.text:00007305
.text:00007308 ; ===========================================================================
.text:00007308
.text:00007308 ; Segment type: Pure code
.text:00007308 ; Segment permissions: Read/Execute
.text:00007308 _text           segment para public 'CODE' use32
.text:00007308                 assume cs:_text
.text:00007308                 ;org 7308h
.text:00007308 ; COMDAT (pick any)
.text:00007308                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007308
.text:00007308 ; =============== S U B R O U T I N E =======================================
.text:00007308
.text:00007308 ; Attributes: bp-based frame
.text:00007308
.text:00007308 ; bool __thiscall NWindows::NSecurity::CAccessToken::AdjustPrivileges(NWindows::NSecurity::CAccessToken *this, bool, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, unsigned __int32 *)
.text:00007308                 public ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_N_NPAU_TOKEN_PRIVILEGES@@K1PAK@Z
.text:00007308 ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_N_NPAU_TOKEN_PRIVILEGES@@K1PAK@Z proc near
.text:00007308                                         ; CODE XREF: NWindows::NSecurity::CAccessToken::AdjustPrivileges(bool,_TOKEN_PRIVILEGES *)+20p
.text:00007308
.text:00007308 var_4           = dword ptr -4
.text:00007308 arg_0           = byte ptr  8
.text:00007308 NewState        = dword ptr  0Ch
.text:00007308 BufferLength    = dword ptr  10h
.text:00007308 PreviousState   = dword ptr  14h
.text:00007308 ReturnLength    = dword ptr  18h
.text:00007308
.text:00007308                 push    ebp
.text:00007309                 mov     ebp, esp
.text:0000730B                 push    ecx
.text:0000730C                 push    esi
.text:0000730D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007314                 mov     [ebp+var_4], ecx
.text:00007317                 mov     esi, esp
.text:00007319                 mov     eax, [ebp+ReturnLength]
.text:0000731C                 push    eax             ; ReturnLength
.text:0000731D                 mov     ecx, [ebp+PreviousState]
.text:00007320                 push    ecx             ; PreviousState
.text:00007321                 mov     edx, [ebp+BufferLength]
.text:00007324                 push    edx             ; BufferLength
.text:00007325                 mov     eax, [ebp+NewState]
.text:00007328                 push    eax             ; NewState
.text:00007329                 movzx   ecx, [ebp+arg_0]
.text:0000732D                 push    ecx             ; bool
.text:0000732E                 call    ?BoolToBOOL@@YGH_N@Z ; BoolToBOOL(bool)
.text:00007333                 push    eax             ; DisableAllPrivileges
.text:00007334                 mov     edx, [ebp+var_4]
.text:00007337                 mov     eax, [edx]
.text:00007339                 push    eax             ; TokenHandle
.text:0000733A                 call    dword ptr ds:__imp__AdjustTokenPrivileges@24 ; AdjustTokenPrivileges(x,x,x,x,x,x)
.text:00007340                 cmp     esi, esp
.text:00007342                 call    __RTC_CheckEsp
.text:00007347                 push    eax             ; int
.text:00007348                 call    ?BOOLToBool@@YG_NH@Z ; BOOLToBool(int)
.text:0000734D                 pop     esi
.text:0000734E                 add     esp, 4
.text:00007351                 cmp     ebp, esp
.text:00007353                 call    __RTC_CheckEsp
.text:00007358                 mov     esp, ebp
.text:0000735A                 pop     ebp
.text:0000735B                 retn    14h
.text:0000735B ?AdjustPrivileges@CAccessToken@NSecurity@NWindows@@QAE_N_NPAU_TOKEN_PRIVILEGES@@K1PAK@Z endp
.text:0000735B
.text:0000735B ; ---------------------------------------------------------------------------
.text:0000735E                 align 10h
.text:0000735E _text           ends
.text:0000735E
.text:00007360 ; ===========================================================================
.text:00007360
.text:00007360 ; Segment type: Pure code
.text:00007360 ; Segment permissions: Read/Execute
.text:00007360 _text           segment para public 'CODE' use32
.text:00007360                 assume cs:_text
.text:00007360                 ;org 7360h
.text:00007360 ; COMDAT (pick any)
.text:00007360                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007360
.text:00007360 ; =============== S U B R O U T I N E =======================================
.text:00007360
.text:00007360 ; Attributes: bp-based frame
.text:00007360
.text:00007360 ; int __stdcall BoolToBOOL(bool)
.text:00007360                 public ?BoolToBOOL@@YGH_N@Z
.text:00007360 ?BoolToBOOL@@YGH_N@Z proc near          ; CODE XREF: NWindows::NSecurity::CAccessToken::AdjustPrivileges(bool,_TOKEN_PRIVILEGES *,ulong,_TOKEN_PRIVILEGES *,ulong *)+26p
.text:00007360
.text:00007360 arg_0           = byte ptr  8
.text:00007360
.text:00007360                 push    ebp
.text:00007361                 mov     ebp, esp
.text:00007363                 movzx   eax, [ebp+arg_0]
.text:00007367                 neg     eax
.text:00007369                 sbb     eax, eax
.text:0000736B                 neg     eax
.text:0000736D                 pop     ebp
.text:0000736E                 retn    4
.text:0000736E ?BoolToBOOL@@YGH_N@Z endp
.text:0000736E
.text:0000736E ; ---------------------------------------------------------------------------
.text:00007371                 align 4
.text:00007371 _text           ends
.text:00007371
.text:00007374 ; ===========================================================================
.text:00007374
.text:00007374 ; Segment type: Pure code
.text:00007374 ; Segment permissions: Read/Execute
.text:00007374 _text           segment para public 'CODE' use32
.text:00007374                 assume cs:_text
.text:00007374                 ;org 7374h
.text:00007374 ; COMDAT (pick any)
.text:00007374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007374
.text:00007374 ; =============== S U B R O U T I N E =======================================
.text:00007374
.text:00007374 ; Attributes: bp-based frame
.text:00007374
.text:00007374 ; void __thiscall CHardLinks::Clear(CHardLinks *__hidden this)
.text:00007374                 public ?Clear@CHardLinks@@QAEXXZ
.text:00007374 ?Clear@CHardLinks@@QAEXXZ proc near     ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+2Fp
.text:00007374                                         ; CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+43p
.text:00007374
.text:00007374 var_4           = dword ptr -4
.text:00007374
.text:00007374                 push    ebp
.text:00007375                 mov     ebp, esp
.text:00007377                 push    ecx
.text:00007378                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000737F                 mov     [ebp+var_4], ecx
.text:00007382                 mov     ecx, [ebp+var_4]
.text:00007385                 call    ?Clear@?$CRecordVector@UCHardLinkNode@@@@QAEXXZ ; CRecordVector<CHardLinkNode>::Clear(void)
.text:0000738A                 mov     ecx, [ebp+var_4]
.text:0000738D                 add     ecx, 0Ch
.text:00007390                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:00007395                 add     esp, 4
.text:00007398                 cmp     ebp, esp
.text:0000739A                 call    __RTC_CheckEsp
.text:0000739F                 mov     esp, ebp
.text:000073A1                 pop     ebp
.text:000073A2                 retn
.text:000073A2 ?Clear@CHardLinks@@QAEXXZ endp
.text:000073A2
.text:000073A2 ; ---------------------------------------------------------------------------
.text:000073A3                 align 4
.text:000073A3 _text           ends
.text:000073A3
.text:000073A4 ; ===========================================================================
.text:000073A4
.text:000073A4 ; Segment type: Pure code
.text:000073A4 ; Segment permissions: Read/Execute
.text:000073A4 _text           segment para public 'CODE' use32
.text:000073A4                 assume cs:_text
.text:000073A4                 ;org 73A4h
.text:000073A4 ; COMDAT (pick any)
.text:000073A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000073A4
.text:000073A4 ; =============== S U B R O U T I N E =======================================
.text:000073A4
.text:000073A4 ; Attributes: bp-based frame
.text:000073A4
.text:000073A4 ; void __thiscall CHardLinks::PrepareLinks(CHardLinks *__hidden this)
.text:000073A4                 public ?PrepareLinks@CHardLinks@@QAEXXZ
.text:000073A4 ?PrepareLinks@CHardLinks@@QAEXXZ proc near
.text:000073A4                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+246p
.text:000073A4
.text:000073A4 var_4           = dword ptr -4
.text:000073A4
.text:000073A4                 push    ebp
.text:000073A5                 mov     ebp, esp
.text:000073A7                 push    ecx
.text:000073A8                 push    esi
.text:000073A9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000073B0                 mov     [ebp+var_4], ecx
.text:000073B3
.text:000073B3 loc_73B3:                               ; CODE XREF: CHardLinks::PrepareLinks(void)+33j
.text:000073B3                 mov     ecx, [ebp+var_4]
.text:000073B6                 add     ecx, 0Ch
.text:000073B9                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000073BE                 mov     esi, eax
.text:000073C0                 mov     ecx, [ebp+var_4]
.text:000073C3                 call    ?Size@?$CRecordVector@UCHardLinkNode@@@@QBEIXZ ; CRecordVector<CHardLinkNode>::Size(void)
.text:000073C8                 cmp     esi, eax
.text:000073CA                 jnb     short loc_73D9
.text:000073CC                 mov     ecx, [ebp+var_4]
.text:000073CF                 add     ecx, 0Ch
.text:000073D2                 call    ?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::AddNew(void)
.text:000073D7                 jmp     short loc_73B3
.text:000073D9 ; ---------------------------------------------------------------------------
.text:000073D9
.text:000073D9 loc_73D9:                               ; CODE XREF: CHardLinks::PrepareLinks(void)+26j
.text:000073D9                 pop     esi
.text:000073DA                 add     esp, 4
.text:000073DD                 cmp     ebp, esp
.text:000073DF                 call    __RTC_CheckEsp
.text:000073E4                 mov     esp, ebp
.text:000073E6                 pop     ebp
.text:000073E7                 retn
.text:000073E7 ?PrepareLinks@CHardLinks@@QAEXXZ endp
.text:000073E7
.text:000073E7 _text           ends
.text:000073E7
.text:000073E8 ; ===========================================================================
.text:000073E8
.text:000073E8 ; Segment type: Pure code
.text:000073E8 ; Segment permissions: Read/Execute
.text:000073E8 _text           segment para public 'CODE' use32
.text:000073E8                 assume cs:_text
.text:000073E8                 ;org 73E8h
.text:000073E8 ; COMDAT (pick any)
.text:000073E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000073E8
.text:000073E8 ; =============== S U B R O U T I N E =======================================
.text:000073E8
.text:000073E8 ; Attributes: bp-based frame
.text:000073E8
.text:000073E8 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:000073E8                 public ??0CPropVariant@NCOM@NWindows@@QAE@XZ
.text:000073E8 ??0CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:000073E8                                         ; CODE XREF: Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+60p
.text:000073E8                                         ; Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+FAp ...
.text:000073E8
.text:000073E8 var_4           = dword ptr -4
.text:000073E8
.text:000073E8                 push    ebp
.text:000073E9                 mov     ebp, esp
.text:000073EB                 push    ecx
.text:000073EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000073F3                 mov     [ebp+var_4], ecx
.text:000073F6                 xor     eax, eax
.text:000073F8                 mov     ecx, [ebp+var_4]
.text:000073FB                 mov     [ecx], ax
.text:000073FE                 xor     edx, edx
.text:00007400                 mov     eax, [ebp+var_4]
.text:00007403                 mov     [eax+2], dx
.text:00007407                 mov     ecx, [ebp+var_4]
.text:0000740A                 mov     dword ptr [ecx+8], 0
.text:00007411                 mov     eax, [ebp+var_4]
.text:00007414                 mov     esp, ebp
.text:00007416                 pop     ebp
.text:00007417                 retn
.text:00007417 ??0CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:00007417
.text:00007417 _text           ends
.text:00007417
.text:00007418 ; ===========================================================================
.text:00007418
.text:00007418 ; Segment type: Pure code
.text:00007418 ; Segment permissions: Read/Execute
.text:00007418 _text           segment para public 'CODE' use32
.text:00007418                 assume cs:_text
.text:00007418                 ;org 7418h
.text:00007418 ; COMDAT (pick any)
.text:00007418                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007418
.text:00007418 ; =============== S U B R O U T I N E =======================================
.text:00007418
.text:00007418 ; Attributes: bp-based frame
.text:00007418
.text:00007418 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::~CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:00007418                 public ??1CPropVariant@NCOM@NWindows@@QAE@XZ
.text:00007418 ??1CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:00007418                                         ; CODE XREF: Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+A6p
.text:00007418                                         ; Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+DBp ...
.text:00007418
.text:00007418 var_4           = dword ptr -4
.text:00007418
.text:00007418                 push    ebp
.text:00007419                 mov     ebp, esp
.text:0000741B                 push    ecx
.text:0000741C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007423                 mov     [ebp+var_4], ecx
.text:00007426                 mov     ecx, [ebp+var_4] ; this
.text:00007429                 call    ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ ; NWindows::NCOM::CPropVariant::Clear(void)
.text:0000742E                 add     esp, 4
.text:00007431                 cmp     ebp, esp
.text:00007433                 call    __RTC_CheckEsp
.text:00007438                 mov     esp, ebp
.text:0000743A                 pop     ebp
.text:0000743B                 retn
.text:0000743B ??1CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:0000743B
.text:0000743B _text           ends
.text:0000743B
.text:0000743C ; ===========================================================================
.text:0000743C
.text:0000743C ; Segment type: Pure code
.text:0000743C ; Segment permissions: Read/Execute
.text:0000743C _text           segment para public 'CODE' use32
.text:0000743C                 assume cs:_text
.text:0000743C                 ;org 743Ch
.text:0000743C ; COMDAT (pick any)
.text:0000743C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000743C
.text:0000743C ; =============== S U B R O U T I N E =======================================
.text:0000743C
.text:0000743C ; Attributes: bp-based frame
.text:0000743C
.text:0000743C ; bool __stdcall ConvertPropVariantToUInt64(const struct tagPROPVARIANT *, unsigned __int64 *)
.text:0000743C                 public ?ConvertPropVariantToUInt64@@YG_NABUtagPROPVARIANT@@AA_K@Z
.text:0000743C ?ConvertPropVariantToUInt64@@YG_NABUtagPROPVARIANT@@AA_K@Z proc near
.text:0000743C                                         ; CODE XREF: Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+BEp
.text:0000743C                                         ; Archive_Get_HardLinkNode(IInArchive *,uint,CHardLinkNode &,bool &)+152p
.text:0000743C
.text:0000743C var_8           = dword ptr -8
.text:0000743C var_4           = dword ptr -4
.text:0000743C arg_0           = dword ptr  8
.text:0000743C arg_4           = dword ptr  0Ch
.text:0000743C
.text:0000743C                 push    ebp
.text:0000743D                 mov     ebp, esp
.text:0000743F                 sub     esp, 8
.text:00007442                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00007449                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007450                 mov     eax, [ebp+arg_0]
.text:00007453                 movzx   ecx, word ptr [eax]
.text:00007456                 mov     [ebp+var_8], ecx
.text:00007459                 cmp     [ebp+var_8], 15h ; switch 22 cases
.text:0000745D                 ja      short $LN1      ; jumptable 00007469 default case
.text:0000745F                 mov     edx, [ebp+var_8]
.text:00007462                 movzx   eax, ds:$LN11_1[edx]
.text:00007469                 jmp     ds:$LN12_0[eax*4] ; switch jump
.text:00007470 ; ---------------------------------------------------------------------------
.text:00007470
.text:00007470 $LN6:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:00007470                                         ; DATA XREF: .text:$LN12_0o
.text:00007470                 mov     ecx, [ebp+arg_4] ; jumptable 00007469 case 21
.text:00007473                 mov     edx, [ebp+arg_0]
.text:00007476                 mov     eax, [edx+8]
.text:00007479                 mov     [ecx], eax
.text:0000747B                 mov     edx, [edx+0Ch]
.text:0000747E                 mov     [ecx+4], edx
.text:00007481                 mov     al, 1
.text:00007483                 jmp     short loc_74DA
.text:00007485 ; ---------------------------------------------------------------------------
.text:00007485
.text:00007485 $LN5:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:00007485                                         ; DATA XREF: .text:$LN12_0o
.text:00007485                 mov     eax, [ebp+arg_0] ; jumptable 00007469 case 19
.text:00007488                 mov     ecx, [eax+8]
.text:0000748B                 xor     edx, edx
.text:0000748D                 mov     eax, [ebp+arg_4]
.text:00007490                 mov     [eax], ecx
.text:00007492                 mov     [eax+4], edx
.text:00007495                 mov     al, 1
.text:00007497                 jmp     short loc_74DA
.text:00007499 ; ---------------------------------------------------------------------------
.text:00007499
.text:00007499 $LN4:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:00007499                                         ; DATA XREF: .text:$LN12_0o
.text:00007499                 mov     ecx, [ebp+arg_0] ; jumptable 00007469 case 18
.text:0000749C                 movzx   eax, word ptr [ecx+8]
.text:000074A0                 cdq
.text:000074A1                 mov     ecx, [ebp+arg_4]
.text:000074A4                 mov     [ecx], eax
.text:000074A6                 mov     [ecx+4], edx
.text:000074A9                 mov     al, 1
.text:000074AB                 jmp     short loc_74DA
.text:000074AD ; ---------------------------------------------------------------------------
.text:000074AD
.text:000074AD $LN3:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:000074AD                                         ; DATA XREF: .text:$LN12_0o
.text:000074AD                 mov     edx, [ebp+arg_0] ; jumptable 00007469 case 17
.text:000074B0                 movzx   eax, byte ptr [edx+8]
.text:000074B4                 cdq
.text:000074B5                 mov     ecx, [ebp+arg_4]
.text:000074B8                 mov     [ecx], eax
.text:000074BA                 mov     [ecx+4], edx
.text:000074BD                 mov     al, 1
.text:000074BF                 jmp     short loc_74DA
.text:000074C1 ; ---------------------------------------------------------------------------
.text:000074C1
.text:000074C1 $LN2:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:000074C1                                         ; DATA XREF: .text:$LN12_0o
.text:000074C1                 xor     al, al          ; jumptable 00007469 case 0
.text:000074C3                 jmp     short loc_74DA
.text:000074C5 ; ---------------------------------------------------------------------------
.text:000074C5
.text:000074C5 $LN1:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+21j
.text:000074C5                                         ; ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:000074C5                                         ; DATA XREF: ...
.text:000074C5                 mov     [ebp+var_4], 24E9Fh ; jumptable 00007469 default case
.text:000074CC                 push    offset __TI1H
.text:000074D1                 lea     edx, [ebp+var_4]
.text:000074D4                 push    edx
.text:000074D5                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000074DA ; ---------------------------------------------------------------------------
.text:000074DA
.text:000074DA loc_74DA:                               ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+47j
.text:000074DA                                         ; ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+5Bj ...
.text:000074DA                 add     esp, 8
.text:000074DD                 cmp     ebp, esp
.text:000074DF                 call    __RTC_CheckEsp
.text:000074E4                 mov     esp, ebp
.text:000074E6                 pop     ebp
.text:000074E7                 retn    8
.text:000074E7 ?ConvertPropVariantToUInt64@@YG_NABUtagPROPVARIANT@@AA_K@Z endp
.text:000074E7
.text:000074E7 ; ---------------------------------------------------------------------------
.text:000074EA                 align 4
.text:000074EC $LN12_0         dd offset $LN2          ; DATA XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dr
.text:000074EC                 dd offset $LN3          ; jump table for switch statement
.text:000074EC                 dd offset $LN4
.text:000074EC                 dd offset $LN5
.text:000074EC                 dd offset $LN6
.text:000074EC                 dd offset $LN1
.text:00007504 $LN11_1         db      0,     5,     5,     5
.text:00007504                                         ; DATA XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+26r
.text:00007504                 db      5,     5,     5,     5 ; indirect table for switch statement
.text:00007504                 db      5,     5,     5,     5
.text:00007504                 db      5,     5,     5,     5
.text:00007504                 db      5,     1,     2,     3
.text:00007504                 db      5,     4
.text:0000751A                 align 4
.text:0000751A _text           ends
.text:0000751A
.xdata$x:0000751C ; ===========================================================================
.xdata$x:0000751C
.xdata$x:0000751C ; Segment type: Pure data
.xdata$x:0000751C ; Segment permissions: Read
.xdata$x:0000751C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000751C                 assume cs:_xdata$x
.xdata$x:0000751C                 ;org 751Ch
.xdata$x:0000751C ; COMDAT (pick any)
.xdata$x:0000751C                 public __TI1H
.xdata$x:0000751C __TI1H          db    0                 ; DATA XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+90o
.xdata$x:0000751D                 db    0
.xdata$x:0000751E                 db    0
.xdata$x:0000751F                 db    0
.xdata$x:00007520                 db    0
.xdata$x:00007521                 db    0
.xdata$x:00007522                 db    0
.xdata$x:00007523                 db    0
.xdata$x:00007524                 db    0
.xdata$x:00007525                 db    0
.xdata$x:00007526                 db    0
.xdata$x:00007527                 db    0
.xdata$x:00007528                 dd offset __CTA1H
.xdata$x:00007528 _xdata$x        ends
.xdata$x:00007528
.xdata$x:0000752C ; ===========================================================================
.xdata$x:0000752C
.xdata$x:0000752C ; Segment type: Pure data
.xdata$x:0000752C ; Segment permissions: Read
.xdata$x:0000752C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000752C                 assume cs:_xdata$x
.xdata$x:0000752C                 ;org 752Ch
.xdata$x:0000752C ; COMDAT (pick any)
.xdata$x:0000752C                 public __CTA1H
.xdata$x:0000752C __CTA1H         db    1                 ; DATA XREF: .xdata$x:00007528o
.xdata$x:0000752D                 db    0
.xdata$x:0000752E                 db    0
.xdata$x:0000752F                 db    0
.xdata$x:00007530                 dd offset __CT??_R0H@84
.xdata$x:00007530 _xdata$x        ends
.xdata$x:00007530
.xdata$x:00007534 ; ===========================================================================
.xdata$x:00007534
.xdata$x:00007534 ; Segment type: Pure data
.xdata$x:00007534 ; Segment permissions: Read
.xdata$x:00007534 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007534                 assume cs:_xdata$x
.xdata$x:00007534                 ;org 7534h
.xdata$x:00007534 ; COMDAT (pick any)
.xdata$x:00007534                 public __CT??_R0H@84
.xdata$x:00007534 __CT??_R0H@84   db    1                 ; DATA XREF: .xdata$x:00007530o
.xdata$x:00007535                 db    0
.xdata$x:00007536                 db    0
.xdata$x:00007537                 db    0
.xdata$x:00007538                 dd offset ??_R0H@8      ; int `RTTI Type Descriptor'
.xdata$x:0000753C                 align 10h
.xdata$x:00007540                 db 0FFh
.xdata$x:00007541                 db 0FFh
.xdata$x:00007542                 db 0FFh
.xdata$x:00007543                 db 0FFh
.xdata$x:00007544                 db    0
.xdata$x:00007545                 db    0
.xdata$x:00007546                 db    0
.xdata$x:00007547                 db    0
.xdata$x:00007548                 db    4
.xdata$x:00007549                 db    0
.xdata$x:0000754A                 db    0
.xdata$x:0000754B                 db    0
.xdata$x:0000754C                 db    0
.xdata$x:0000754D                 db    0
.xdata$x:0000754E                 db    0
.xdata$x:0000754F                 db    0
.xdata$x:0000754F _xdata$x        ends
.xdata$x:0000754F
.data:00007550 ; ===========================================================================
.data:00007550
.data:00007550 ; Segment type: Pure data
.data:00007550 ; Segment permissions: Read/Write
.data:00007550 _data           segment dword public 'DATA' use32
.data:00007550                 assume cs:_data
.data:00007550                 ;org 7550h
.data:00007550 ; COMDAT (pick any)
.data:00007550                 public ??_R0H@8
.data:00007550 ; int `RTTI Type Descriptor'
.data:00007550 ??_R0H@8        dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00007538o
.data:00007550                                         ; const type_info::`vftable'
.data:00007554                 align 8
.data:00007558                 db  2Eh ; .
.data:00007559                 db  48h ; H
.data:0000755A                 db    0
.data:0000755B                 align 4
.data:0000755B _data           ends
.data:0000755B
.rdata:0000755C ; ===========================================================================
.rdata:0000755C
.rdata:0000755C ; Segment type: Pure data
.rdata:0000755C ; Segment permissions: Read
.rdata:0000755C _rdata          segment dword public 'DATA' use32
.rdata:0000755C                 assume cs:_rdata
.rdata:0000755C                 ;org 755Ch
.rdata:0000755C ; COMDAT (pick largest)
.rdata:0000755C                 dd offset ??_R4CArchiveExtractCallback@@6BICompressProgressInfo@@@ ; const CArchiveExtractCallback::`RTTI Complete Object Locator'{for `ICompressProgressInfo'}
.rdata:00007560                 public ??_7CArchiveExtractCallback@@6BICompressProgressInfo@@@
.rdata:00007560 ; const CArchiveExtractCallback::`vftable'{for `ICompressProgressInfo'}
.rdata:00007560 ??_7CArchiveExtractCallback@@6BICompressProgressInfo@@@ dd offset ?QueryInterface@CArchiveExtractCallback@@WM@AGJABU_GUID@@PAPAX@Z
.rdata:00007560                                         ; DATA XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+8Do
.rdata:00007560                                         ; [thunk]:CArchiveExtractCallback::QueryInterface`adjustor{12}' (_GUID const &,void * *)
.rdata:00007564                 dd offset ?AddRef@CArchiveExtractCallback@@WM@AGKXZ ; [thunk]:CArchiveExtractCallback::AddRef`adjustor{12}' (void)
.rdata:00007568                 dd offset ?Release@CArchiveExtractCallback@@WM@AGKXZ ; [thunk]:CArchiveExtractCallback::Release`adjustor{12}' (void)
.rdata:0000756C                 dd offset ?SetRatioInfo@CArchiveExtractCallback@@UAGJPB_K0@Z ; CArchiveExtractCallback::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)
.rdata:0000756C _rdata          ends
.rdata:0000756C
.rdata:00007570 ; ===========================================================================
.rdata:00007570
.rdata:00007570 ; Segment type: Pure data
.rdata:00007570 ; Segment permissions: Read
.rdata:00007570 _rdata          segment dword public 'DATA' use32
.rdata:00007570                 assume cs:_rdata
.rdata:00007570                 ;org 7570h
.rdata:00007570 ; COMDAT (pick largest)
.rdata:00007570                 dd offset ??_R4CArchiveExtractCallback@@6BICryptoGetTextPassword@@@ ; const CArchiveExtractCallback::`RTTI Complete Object Locator'{for `ICryptoGetTextPassword'}
.rdata:00007574                 public ??_7CArchiveExtractCallback@@6BICryptoGetTextPassword@@@
.rdata:00007574 ; const CArchiveExtractCallback::`vftable'{for `ICryptoGetTextPassword'}
.rdata:00007574 ??_7CArchiveExtractCallback@@6BICryptoGetTextPassword@@@ dd offset ?QueryInterface@CArchiveExtractCallback@@W7AGJABU_GUID@@PAPAX@Z
.rdata:00007574                                         ; DATA XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+83o
.rdata:00007574                                         ; [thunk]:CArchiveExtractCallback::QueryInterface`adjustor{8}' (_GUID const &,void * *)
.rdata:00007578                 dd offset ?AddRef@CArchiveExtractCallback@@W7AGKXZ ; [thunk]:CArchiveExtractCallback::AddRef`adjustor{8}' (void)
.rdata:0000757C                 dd offset ?Release@CArchiveExtractCallback@@W7AGKXZ ; [thunk]:CArchiveExtractCallback::Release`adjustor{8}' (void)
.rdata:00007580                 dd offset ?CryptoGetTextPassword@CArchiveExtractCallback@@UAGJPAPA_W@Z ; CArchiveExtractCallback::CryptoGetTextPassword(wchar_t * *)
.rdata:00007580 _rdata          ends
.rdata:00007580
.rdata:00007584 ; ===========================================================================
.rdata:00007584
.rdata:00007584 ; Segment type: Pure data
.rdata:00007584 ; Segment permissions: Read
.rdata:00007584 _rdata          segment dword public 'DATA' use32
.rdata:00007584                 assume cs:_rdata
.rdata:00007584                 ;org 7584h
.rdata:00007584 ; COMDAT (pick largest)
.rdata:00007584                 dd offset ??_R4CArchiveExtractCallback@@6BIArchiveExtractCallbackMessage@@@ ; const CArchiveExtractCallback::`RTTI Complete Object Locator'{for `IArchiveExtractCallbackMessage'}
.rdata:00007588                 public ??_7CArchiveExtractCallback@@6BIArchiveExtractCallbackMessage@@@
.rdata:00007588 ; const CArchiveExtractCallback::`vftable'{for `IArchiveExtractCallbackMessage'}
.rdata:00007588 ??_7CArchiveExtractCallback@@6BIArchiveExtractCallbackMessage@@@ dd offset ?QueryInterface@CArchiveExtractCallback@@W3AGJABU_GUID@@PAPAX@Z
.rdata:00007588                                         ; DATA XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+79o
.rdata:00007588                                         ; [thunk]:CArchiveExtractCallback::QueryInterface`adjustor{4}' (_GUID const &,void * *)
.rdata:0000758C                 dd offset ?AddRef@CArchiveExtractCallback@@W3AGKXZ ; [thunk]:CArchiveExtractCallback::AddRef`adjustor{4}' (void)
.rdata:00007590                 dd offset ?Release@CArchiveExtractCallback@@W3AGKXZ ; [thunk]:CArchiveExtractCallback::Release`adjustor{4}' (void)
.rdata:00007594                 dd offset ?SetTotal@CArchiveExtractCallback@@W3AGJ_K@Z ; [thunk]:CArchiveExtractCallback::SetTotal`adjustor{4}' (unsigned __int64)
.rdata:00007598                 dd offset ?SetCompleted@CArchiveExtractCallback@@W3AGJPB_K@Z ; [thunk]:CArchiveExtractCallback::SetCompleted`adjustor{4}' (unsigned __int64 const *)
.rdata:0000759C                 dd offset ?ReportExtractResult@CArchiveExtractCallback@@UAGJIIH@Z ; CArchiveExtractCallback::ReportExtractResult(uint,uint,int)
.rdata:0000759C _rdata          ends
.rdata:0000759C
.rdata:000075A0 ; ===========================================================================
.rdata:000075A0
.rdata:000075A0 ; Segment type: Pure data
.rdata:000075A0 ; Segment permissions: Read
.rdata:000075A0 _rdata          segment dword public 'DATA' use32
.rdata:000075A0                 assume cs:_rdata
.rdata:000075A0                 ;org 75A0h
.rdata:000075A0 ; COMDAT (pick largest)
.rdata:000075A0                 dd offset ??_R4CArchiveExtractCallback@@6BIArchiveExtractCallback@@@ ; const CArchiveExtractCallback::`RTTI Complete Object Locator'{for `IArchiveExtractCallback'}
.rdata:000075A4                 public ??_7CArchiveExtractCallback@@6BIArchiveExtractCallback@@@
.rdata:000075A4 ; const CArchiveExtractCallback::`vftable'{for `IArchiveExtractCallback'}
.rdata:000075A4 ??_7CArchiveExtractCallback@@6BIArchiveExtractCallback@@@ dd offset ?QueryInterface@CArchiveExtractCallback@@UAGJABU_GUID@@PAPAX@Z
.rdata:000075A4                                         ; DATA XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+70o
.rdata:000075A4                                         ; CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)
.rdata:000075A8                 dd offset ?AddRef@CArchiveExtractCallback@@UAGKXZ ; CArchiveExtractCallback::AddRef(void)
.rdata:000075AC                 dd offset ?Release@CArchiveExtractCallback@@UAGKXZ ; CArchiveExtractCallback::Release(void)
.rdata:000075B0                 dd offset ?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z ; CArchiveExtractCallback::SetTotal(unsigned __int64)
.rdata:000075B4                 dd offset ?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z ; CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)
.rdata:000075B8                 dd offset ?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)
.rdata:000075BC                 dd offset ?PrepareOperation@CArchiveExtractCallback@@UAGJH@Z ; CArchiveExtractCallback::PrepareOperation(int)
.rdata:000075C0                 dd offset ?SetOperationResult@CArchiveExtractCallback@@UAGJH@Z ; CArchiveExtractCallback::SetOperationResult(int)
.rdata:000075C0 _rdata          ends
.rdata:000075C0
.rdata$r:000075C4 ; ===========================================================================
.rdata$r:000075C4
.rdata$r:000075C4 ; Segment type: Pure data
.rdata$r:000075C4 ; Segment permissions: Read
.rdata$r:000075C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000075C4                 assume cs:_rdata$r
.rdata$r:000075C4                 ;org 75C4h
.rdata$r:000075C4 ; COMDAT (pick any)
.rdata$r:000075C4                 public ??_R4CArchiveExtractCallback@@6BIArchiveExtractCallback@@@
.rdata$r:000075C4 ; const CArchiveExtractCallback::`RTTI Complete Object Locator'{for `IArchiveExtractCallback'}
.rdata$r:000075C4 ??_R4CArchiveExtractCallback@@6BIArchiveExtractCallback@@@ db    0
.rdata$r:000075C4                                         ; DATA XREF: .rdata:000075A0o
.rdata$r:000075C5                 db    0
.rdata$r:000075C6                 db    0
.rdata$r:000075C7                 db    0
.rdata$r:000075C8                 db    0
.rdata$r:000075C9                 db    0
.rdata$r:000075CA                 db    0
.rdata$r:000075CB                 db    0
.rdata$r:000075CC                 db    0
.rdata$r:000075CD                 db    0
.rdata$r:000075CE                 db    0
.rdata$r:000075CF                 db    0
.rdata$r:000075D0                 dd offset ??_R0?AVCArchiveExtractCallback@@@8 ; CArchiveExtractCallback `RTTI Type Descriptor'
.rdata$r:000075D4                 dd offset ??_R3CArchiveExtractCallback@@8 ; CArchiveExtractCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:000075D4 _rdata$r        ends
.rdata$r:000075D4
.data:000075D8 ; ===========================================================================
.data:000075D8
.data:000075D8 ; Segment type: Pure data
.data:000075D8 ; Segment permissions: Read/Write
.data:000075D8 _data           segment dword public 'DATA' use32
.data:000075D8                 assume cs:_data
.data:000075D8                 ;org 75D8h
.data:000075D8 ; COMDAT (pick any)
.data:000075D8                 public ??_R0?AVCArchiveExtractCallback@@@8
.data:000075D8 ; class CArchiveExtractCallback `RTTI Type Descriptor'
.data:000075D8 ??_R0?AVCArchiveExtractCallback@@@8 dd offset ??_7type_info@@6B@
.data:000075D8                                         ; DATA XREF: .rdata$r:000075D0o
.data:000075D8                                         ; .rdata$r:CArchiveExtractCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:000075D8                                         ; const type_info::`vftable'
.data:000075DC                 align 10h
.data:000075E0 a_?avcarchiveex db '.?AVCArchiveExtractCallback@@',0
.data:000075FE                 align 10h
.data:000075FE _data           ends
.data:000075FE
.rdata$r:00007600 ; ===========================================================================
.rdata$r:00007600
.rdata$r:00007600 ; Segment type: Pure data
.rdata$r:00007600 ; Segment permissions: Read
.rdata$r:00007600 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007600                 assume cs:_rdata$r
.rdata$r:00007600                 ;org 7600h
.rdata$r:00007600 ; COMDAT (pick any)
.rdata$r:00007600                 public ??_R3CArchiveExtractCallback@@8
.rdata$r:00007600 ; CArchiveExtractCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007600 ??_R3CArchiveExtractCallback@@8 db    0 ; DATA XREF: .rdata$r:000075D4o
.rdata$r:00007600                                         ; .rdata$r:0000765Co ...
.rdata$r:00007601                 db    0
.rdata$r:00007602                 db    0
.rdata$r:00007603                 db    0
.rdata$r:00007604                 db    5
.rdata$r:00007605                 db    0
.rdata$r:00007606                 db    0
.rdata$r:00007607                 db    0
.rdata$r:00007608                 db  0Ch
.rdata$r:00007609                 db    0
.rdata$r:0000760A                 db    0
.rdata$r:0000760B                 db    0
.rdata$r:0000760C                 dd offset ??_R2CArchiveExtractCallback@@8 ; CArchiveExtractCallback::`RTTI Base Class Array'
.rdata$r:0000760C _rdata$r        ends
.rdata$r:0000760C
.rdata$r:00007610 ; ===========================================================================
.rdata$r:00007610
.rdata$r:00007610 ; Segment type: Pure data
.rdata$r:00007610 ; Segment permissions: Read
.rdata$r:00007610 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007610                 assume cs:_rdata$r
.rdata$r:00007610                 ;org 7610h
.rdata$r:00007610 ; COMDAT (pick any)
.rdata$r:00007610                 public ??_R2CArchiveExtractCallback@@8
.rdata$r:00007610 ; CArchiveExtractCallback::`RTTI Base Class Array'
.rdata$r:00007610 ??_R2CArchiveExtractCallback@@8 dd offset ??_R1A@?0A@EA@CArchiveExtractCallback@@8
.rdata$r:00007610                                         ; DATA XREF: .rdata$r:0000760Co
.rdata$r:00007610                                         ; CArchiveExtractCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007614                 dd offset ??_R1A@?0A@EA@IArchiveExtractCallback@@8 ; IArchiveExtractCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007618                 dd offset ??_R1A@?0A@EC@IProgress@@8 ; IProgress::`RTTI Base Class Descriptor at (0,-1,0,66)'
.rdata$r:0000761C                 dd offset ??_R1A@?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
.rdata$r:00007620                 dd offset ??_R13?0A@EA@IArchiveExtractCallbackMessage@@8 ; IArchiveExtractCallbackMessage::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:00007624                 dd offset ??_R13?0A@EC@IProgress@@8 ; IProgress::`RTTI Base Class Descriptor at (4,-1,0,66)'
.rdata$r:00007628                 dd offset ??_R13?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
.rdata$r:0000762C                 dd offset ??_R17?0A@EA@ICryptoGetTextPassword@@8 ; ICryptoGetTextPassword::`RTTI Base Class Descriptor at (8,-1,0,64)'
.rdata$r:00007630                 dd offset ??_R17?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (8,-1,0,66)'
.rdata$r:00007634                 dd offset ??_R1M@?0A@EA@ICompressProgressInfo@@8 ; ICompressProgressInfo::`RTTI Base Class Descriptor at (12,-1,0,64)'
.rdata$r:00007638                 dd offset ??_R1M@?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (12,-1,0,66)'
.rdata$r:0000763C                 dd offset ??_R1BA@?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (16,-1,0,64)'
.rdata$r:00007640                 db    0
.rdata$r:00007641                 align 4
.rdata$r:00007641 _rdata$r        ends
.rdata$r:00007641
.rdata$r:00007644 ; ===========================================================================
.rdata$r:00007644
.rdata$r:00007644 ; Segment type: Pure data
.rdata$r:00007644 ; Segment permissions: Read
.rdata$r:00007644 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007644                 assume cs:_rdata$r
.rdata$r:00007644                 ;org 7644h
.rdata$r:00007644 ; COMDAT (pick any)
.rdata$r:00007644                 public ??_R1A@?0A@EA@CArchiveExtractCallback@@8
.rdata$r:00007644 ; CArchiveExtractCallback::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00007644 ??_R1A@?0A@EA@CArchiveExtractCallback@@8 dd offset ??_R0?AVCArchiveExtractCallback@@@8
.rdata$r:00007644                                         ; DATA XREF: .rdata$r:CArchiveExtractCallback::`RTTI Base Class Array'o
.rdata$r:00007644                                         ; CArchiveExtractCallback `RTTI Type Descriptor'
.rdata$r:00007648                 db  0Bh
.rdata$r:00007649                 db    0
.rdata$r:0000764A                 db    0
.rdata$r:0000764B                 db    0
.rdata$r:0000764C                 db    0
.rdata$r:0000764D                 db    0
.rdata$r:0000764E                 db    0
.rdata$r:0000764F                 db    0
.rdata$r:00007650                 db 0FFh
.rdata$r:00007651                 db 0FFh
.rdata$r:00007652                 db 0FFh
.rdata$r:00007653                 db 0FFh
.rdata$r:00007654                 db    0
.rdata$r:00007655                 db    0
.rdata$r:00007656                 db    0
.rdata$r:00007657                 db    0
.rdata$r:00007658                 db  40h ; @
.rdata$r:00007659                 db    0
.rdata$r:0000765A                 db    0
.rdata$r:0000765B                 db    0
.rdata$r:0000765C                 dd offset ??_R3CArchiveExtractCallback@@8 ; CArchiveExtractCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000765C _rdata$r        ends
.rdata$r:0000765C
.rdata$r:00007660 ; ===========================================================================
.rdata$r:00007660
.rdata$r:00007660 ; Segment type: Pure data
.rdata$r:00007660 ; Segment permissions: Read
.rdata$r:00007660 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007660                 assume cs:_rdata$r
.rdata$r:00007660                 ;org 7660h
.rdata$r:00007660 ; COMDAT (pick any)
.rdata$r:00007660                 public ??_R1A@?0A@EA@IArchiveExtractCallback@@8
.rdata$r:00007660 ; IArchiveExtractCallback::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00007660 ??_R1A@?0A@EA@IArchiveExtractCallback@@8 dd offset ??_R0?AUIArchiveExtractCallback@@@8
.rdata$r:00007660                                         ; DATA XREF: .rdata$r:00007614o
.rdata$r:00007660                                         ; .rdata$r:IArchiveExtractCallback::`RTTI Base Class Array'o
.rdata$r:00007660                                         ; IArchiveExtractCallback `RTTI Type Descriptor'
.rdata$r:00007664                 db    2
.rdata$r:00007665                 db    0
.rdata$r:00007666                 db    0
.rdata$r:00007667                 db    0
.rdata$r:00007668                 db    0
.rdata$r:00007669                 db    0
.rdata$r:0000766A                 db    0
.rdata$r:0000766B                 db    0
.rdata$r:0000766C                 db 0FFh
.rdata$r:0000766D                 db 0FFh
.rdata$r:0000766E                 db 0FFh
.rdata$r:0000766F                 db 0FFh
.rdata$r:00007670                 db    0
.rdata$r:00007671                 db    0
.rdata$r:00007672                 db    0
.rdata$r:00007673                 db    0
.rdata$r:00007674                 db  40h ; @
.rdata$r:00007675                 db    0
.rdata$r:00007676                 db    0
.rdata$r:00007677                 db    0
.rdata$r:00007678                 dd offset ??_R3IArchiveExtractCallback@@8 ; IArchiveExtractCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007678 _rdata$r        ends
.rdata$r:00007678
.data:0000767C ; ===========================================================================
.data:0000767C
.data:0000767C ; Segment type: Pure data
.data:0000767C ; Segment permissions: Read/Write
.data:0000767C _data           segment dword public 'DATA' use32
.data:0000767C                 assume cs:_data
.data:0000767C                 ;org 767Ch
.data:0000767C ; COMDAT (pick any)
.data:0000767C                 public ??_R0?AUIArchiveExtractCallback@@@8
.data:0000767C ; struct IArchiveExtractCallback `RTTI Type Descriptor'
.data:0000767C ??_R0?AUIArchiveExtractCallback@@@8 dd offset ??_7type_info@@6B@
.data:0000767C                                         ; DATA XREF: .rdata$r:IArchiveExtractCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000767C                                         ; .rdata$r:0000842Co
.data:0000767C                                         ; const type_info::`vftable'
.data:00007680                 db    0
.data:00007681                 db    0
.data:00007682                 db    0
.data:00007683                 db    0
.data:00007684                 db  2Eh ; .
.data:00007685                 db  3Fh ; ?
.data:00007686                 db  41h ; A
.data:00007687                 db  55h ; U
.data:00007688                 db  49h ; I
.data:00007689                 db  41h ; A
.data:0000768A                 db  72h ; r
.data:0000768B                 db  63h ; c
.data:0000768C                 db  68h ; h
.data:0000768D                 db  69h ; i
.data:0000768E                 db  76h ; v
.data:0000768F                 db  65h ; e
.data:00007690                 db  45h ; E
.data:00007691                 db  78h ; x
.data:00007692                 db  74h ; t
.data:00007693                 db  72h ; r
.data:00007694                 db  61h ; a
.data:00007695                 db  63h ; c
.data:00007696                 db  74h ; t
.data:00007697                 db  43h ; C
.data:00007698                 db  61h ; a
.data:00007699                 db  6Ch ; l
.data:0000769A                 db  6Ch ; l
.data:0000769B                 db  62h ; b
.data:0000769C                 db  61h ; a
.data:0000769D                 db  63h ; c
.data:0000769E                 db  6Bh ; k
.data:0000769F                 db  40h ; @
.data:000076A0                 db  40h ; @
.data:000076A1                 db    0
.data:000076A2                 align 4
.data:000076A2 _data           ends
.data:000076A2
.rdata$r:000076A4 ; ===========================================================================
.rdata$r:000076A4
.rdata$r:000076A4 ; Segment type: Pure data
.rdata$r:000076A4 ; Segment permissions: Read
.rdata$r:000076A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000076A4                 assume cs:_rdata$r
.rdata$r:000076A4                 ;org 76A4h
.rdata$r:000076A4 ; COMDAT (pick any)
.rdata$r:000076A4                 public ??_R3IArchiveExtractCallback@@8
.rdata$r:000076A4 ; IArchiveExtractCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:000076A4 ??_R3IArchiveExtractCallback@@8 db    0 ; DATA XREF: .rdata$r:00007678o
.rdata$r:000076A4                                         ; .rdata$r:00008430o
.rdata$r:000076A5                 db    0
.rdata$r:000076A6                 db    0
.rdata$r:000076A7                 db    0
.rdata$r:000076A8                 db    0
.rdata$r:000076A9                 db    0
.rdata$r:000076AA                 db    0
.rdata$r:000076AB                 db    0
.rdata$r:000076AC                 db    3
.rdata$r:000076AD                 db    0
.rdata$r:000076AE                 db    0
.rdata$r:000076AF                 db    0
.rdata$r:000076B0                 dd offset ??_R2IArchiveExtractCallback@@8 ; IArchiveExtractCallback::`RTTI Base Class Array'
.rdata$r:000076B0 _rdata$r        ends
.rdata$r:000076B0
.rdata$r:000076B4 ; ===========================================================================
.rdata$r:000076B4
.rdata$r:000076B4 ; Segment type: Pure data
.rdata$r:000076B4 ; Segment permissions: Read
.rdata$r:000076B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000076B4                 assume cs:_rdata$r
.rdata$r:000076B4                 ;org 76B4h
.rdata$r:000076B4 ; COMDAT (pick any)
.rdata$r:000076B4                 public ??_R2IArchiveExtractCallback@@8
.rdata$r:000076B4 ; IArchiveExtractCallback::`RTTI Base Class Array'
.rdata$r:000076B4 ??_R2IArchiveExtractCallback@@8 dd offset ??_R1A@?0A@EA@IArchiveExtractCallback@@8
.rdata$r:000076B4                                         ; DATA XREF: .rdata$r:000076B0o
.rdata$r:000076B4                                         ; IArchiveExtractCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000076B8                 dd offset ??_R1A@?0A@EA@IProgress@@8 ; IProgress::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000076BC                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000076C0                 db    0
.rdata$r:000076C1                 align 4
.rdata$r:000076C1 _rdata$r        ends
.rdata$r:000076C1
.rdata$r:000076C4 ; ===========================================================================
.rdata$r:000076C4
.rdata$r:000076C4 ; Segment type: Pure data
.rdata$r:000076C4 ; Segment permissions: Read
.rdata$r:000076C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000076C4                 assume cs:_rdata$r
.rdata$r:000076C4                 ;org 76C4h
.rdata$r:000076C4 ; COMDAT (pick any)
.rdata$r:000076C4                 public ??_R1A@?0A@EA@IProgress@@8
.rdata$r:000076C4 ; IProgress::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000076C4 ??_R1A@?0A@EA@IProgress@@8 dd offset ??_R0?AUIProgress@@@8
.rdata$r:000076C4                                         ; DATA XREF: .rdata$r:000076B8o
.rdata$r:000076C4                                         ; .rdata$r:IProgress::`RTTI Base Class Array'o ...
.rdata$r:000076C4                                         ; IProgress `RTTI Type Descriptor'
.rdata$r:000076C8                 db    1
.rdata$r:000076C9                 db    0
.rdata$r:000076CA                 db    0
.rdata$r:000076CB                 db    0
.rdata$r:000076CC                 db    0
.rdata$r:000076CD                 db    0
.rdata$r:000076CE                 db    0
.rdata$r:000076CF                 db    0
.rdata$r:000076D0                 db 0FFh
.rdata$r:000076D1                 db 0FFh
.rdata$r:000076D2                 db 0FFh
.rdata$r:000076D3                 db 0FFh
.rdata$r:000076D4                 db    0
.rdata$r:000076D5                 db    0
.rdata$r:000076D6                 db    0
.rdata$r:000076D7                 db    0
.rdata$r:000076D8                 db  40h ; @
.rdata$r:000076D9                 db    0
.rdata$r:000076DA                 db    0
.rdata$r:000076DB                 db    0
.rdata$r:000076DC                 dd offset ??_R3IProgress@@8 ; IProgress::`RTTI Class Hierarchy Descriptor'
.rdata$r:000076DC _rdata$r        ends
.rdata$r:000076DC
.data:000076E0 ; ===========================================================================
.data:000076E0
.data:000076E0 ; Segment type: Pure data
.data:000076E0 ; Segment permissions: Read/Write
.data:000076E0 _data           segment dword public 'DATA' use32
.data:000076E0                 assume cs:_data
.data:000076E0                 ;org 76E0h
.data:000076E0 ; COMDAT (pick any)
.data:000076E0                 public ??_R0?AUIProgress@@@8
.data:000076E0 ; struct IProgress `RTTI Type Descriptor'
.data:000076E0 ??_R0?AUIProgress@@@8 dd offset ??_7type_info@@6B@
.data:000076E0                                         ; DATA XREF: .rdata$r:IProgress::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000076E0                                         ; .rdata$r:IProgress::`RTTI Base Class Descriptor at (0,-1,0,66)'o ...
.data:000076E0                                         ; const type_info::`vftable'
.data:000076E4                 align 8
.data:000076E8 a_?auiprogress@ db '.?AUIProgress@@',0
.data:000076E8 _data           ends
.data:000076E8
.rdata$r:000076F8 ; ===========================================================================
.rdata$r:000076F8
.rdata$r:000076F8 ; Segment type: Pure data
.rdata$r:000076F8 ; Segment permissions: Read
.rdata$r:000076F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000076F8                 assume cs:_rdata$r
.rdata$r:000076F8                 ;org 76F8h
.rdata$r:000076F8 ; COMDAT (pick any)
.rdata$r:000076F8                 public ??_R3IProgress@@8
.rdata$r:000076F8 ; IProgress::`RTTI Class Hierarchy Descriptor'
.rdata$r:000076F8 ??_R3IProgress@@8 db    0               ; DATA XREF: .rdata$r:000076DCo
.rdata$r:000076F8                                         ; .rdata$r:00007778o ...
.rdata$r:000076F9                 db    0
.rdata$r:000076FA                 db    0
.rdata$r:000076FB                 db    0
.rdata$r:000076FC                 db    0
.rdata$r:000076FD                 db    0
.rdata$r:000076FE                 db    0
.rdata$r:000076FF                 db    0
.rdata$r:00007700                 db    2
.rdata$r:00007701                 db    0
.rdata$r:00007702                 db    0
.rdata$r:00007703                 db    0
.rdata$r:00007704                 dd offset ??_R2IProgress@@8 ; IProgress::`RTTI Base Class Array'
.rdata$r:00007704 _rdata$r        ends
.rdata$r:00007704
.rdata$r:00007708 ; ===========================================================================
.rdata$r:00007708
.rdata$r:00007708 ; Segment type: Pure data
.rdata$r:00007708 ; Segment permissions: Read
.rdata$r:00007708 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007708                 assume cs:_rdata$r
.rdata$r:00007708                 ;org 7708h
.rdata$r:00007708 ; COMDAT (pick any)
.rdata$r:00007708                 public ??_R2IProgress@@8
.rdata$r:00007708 ; IProgress::`RTTI Base Class Array'
.rdata$r:00007708 ??_R2IProgress@@8 dd offset ??_R1A@?0A@EA@IProgress@@8
.rdata$r:00007708                                         ; DATA XREF: .rdata$r:00007704o
.rdata$r:00007708                                         ; IProgress::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000770C                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007710                 db    0
.rdata$r:00007711                 align 4
.rdata$r:00007711 _rdata$r        ends
.rdata$r:00007711
.rdata$r:00007714 ; ===========================================================================
.rdata$r:00007714
.rdata$r:00007714 ; Segment type: Pure data
.rdata$r:00007714 ; Segment permissions: Read
.rdata$r:00007714 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007714                 assume cs:_rdata$r
.rdata$r:00007714                 ;org 7714h
.rdata$r:00007714 ; COMDAT (pick any)
.rdata$r:00007714                 public ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:00007714 ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00007714 ??_R1A@?0A@EA@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:00007714                                         ; DATA XREF: .rdata$r:000076BCo
.rdata$r:00007714                                         ; .rdata$r:0000770Co ...
.rdata$r:00007714                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00007718                 align 10h
.rdata$r:00007720                 db 0FFh
.rdata$r:00007721                 db 0FFh
.rdata$r:00007722                 db 0FFh
.rdata$r:00007723                 db 0FFh
.rdata$r:00007724                 db    0
.rdata$r:00007725                 db    0
.rdata$r:00007726                 db    0
.rdata$r:00007727                 db    0
.rdata$r:00007728                 db  40h ; @
.rdata$r:00007729                 db    0
.rdata$r:0000772A                 db    0
.rdata$r:0000772B                 db    0
.rdata$r:0000772C                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000772C _rdata$r        ends
.rdata$r:0000772C
.data:00007730 ; ===========================================================================
.data:00007730
.data:00007730 ; Segment type: Pure data
.data:00007730 ; Segment permissions: Read/Write
.data:00007730 _data           segment dword public 'DATA' use32
.data:00007730                 assume cs:_data
.data:00007730                 ;org 7730h
.data:00007730 ; COMDAT (pick any)
.data:00007730                 public ??_R0?AUIUnknown@@@8
.data:00007730 ; struct IUnknown `RTTI Type Descriptor'
.data:00007730 ??_R0?AUIUnknown@@@8 dd offset ??_7type_info@@6B@
.data:00007730                                         ; DATA XREF: .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00007730                                         ; .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'o ...
.data:00007730                                         ; const type_info::`vftable'
.data:00007734                 align 8
.data:00007738 a_?auiunknown@@ db '.?AUIUnknown@@',0
.data:00007747                 align 4
.data:00007747 _data           ends
.data:00007747
.rdata$r:00007748 ; ===========================================================================
.rdata$r:00007748
.rdata$r:00007748 ; Segment type: Pure data
.rdata$r:00007748 ; Segment permissions: Read
.rdata$r:00007748 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007748                 assume cs:_rdata$r
.rdata$r:00007748                 ;org 7748h
.rdata$r:00007748 ; COMDAT (pick any)
.rdata$r:00007748                 public ??_R3IUnknown@@8
.rdata$r:00007748 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007748 ??_R3IUnknown@@8 db    0                ; DATA XREF: .rdata$r:0000772Co
.rdata$r:00007748                                         ; .rdata$r:00007794o ...
.rdata$r:00007749                 db    0
.rdata$r:0000774A                 db    0
.rdata$r:0000774B                 db    0
.rdata$r:0000774C                 db    0
.rdata$r:0000774D                 db    0
.rdata$r:0000774E                 db    0
.rdata$r:0000774F                 db    0
.rdata$r:00007750                 db    1
.rdata$r:00007751                 db    0
.rdata$r:00007752                 db    0
.rdata$r:00007753                 db    0
.rdata$r:00007754                 dd offset ??_R2IUnknown@@8 ; IUnknown::`RTTI Base Class Array'
.rdata$r:00007754 _rdata$r        ends
.rdata$r:00007754
.rdata$r:00007758 ; ===========================================================================
.rdata$r:00007758
.rdata$r:00007758 ; Segment type: Pure data
.rdata$r:00007758 ; Segment permissions: Read
.rdata$r:00007758 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007758                 assume cs:_rdata$r
.rdata$r:00007758                 ;org 7758h
.rdata$r:00007758 ; COMDAT (pick any)
.rdata$r:00007758                 public ??_R2IUnknown@@8
.rdata$r:00007758 ; IUnknown::`RTTI Base Class Array'
.rdata$r:00007758 ??_R2IUnknown@@8 dd offset ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:00007758                                         ; DATA XREF: .rdata$r:00007754o
.rdata$r:00007758                                         ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000775C                 db    0
.rdata$r:0000775D                 align 10h
.rdata$r:0000775D _rdata$r        ends
.rdata$r:0000775D
.rdata$r:00007760 ; ===========================================================================
.rdata$r:00007760
.rdata$r:00007760 ; Segment type: Pure data
.rdata$r:00007760 ; Segment permissions: Read
.rdata$r:00007760 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007760                 assume cs:_rdata$r
.rdata$r:00007760                 ;org 7760h
.rdata$r:00007760 ; COMDAT (pick any)
.rdata$r:00007760                 public ??_R1A@?0A@EC@IProgress@@8
.rdata$r:00007760 ; IProgress::`RTTI Base Class Descriptor at (0, -1, 0, 66)'
.rdata$r:00007760 ??_R1A@?0A@EC@IProgress@@8 dd offset ??_R0?AUIProgress@@@8
.rdata$r:00007760                                         ; DATA XREF: .rdata$r:00007618o
.rdata$r:00007760                                         ; IProgress `RTTI Type Descriptor'
.rdata$r:00007764                 db    1
.rdata$r:00007765                 db    0
.rdata$r:00007766                 db    0
.rdata$r:00007767                 db    0
.rdata$r:00007768                 db    0
.rdata$r:00007769                 db    0
.rdata$r:0000776A                 db    0
.rdata$r:0000776B                 db    0
.rdata$r:0000776C                 db 0FFh
.rdata$r:0000776D                 db 0FFh
.rdata$r:0000776E                 db 0FFh
.rdata$r:0000776F                 db 0FFh
.rdata$r:00007770                 db    0
.rdata$r:00007771                 db    0
.rdata$r:00007772                 db    0
.rdata$r:00007773                 db    0
.rdata$r:00007774                 db  42h ; B
.rdata$r:00007775                 db    0
.rdata$r:00007776                 db    0
.rdata$r:00007777                 db    0
.rdata$r:00007778                 dd offset ??_R3IProgress@@8 ; IProgress::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007778 _rdata$r        ends
.rdata$r:00007778
.rdata$r:0000777C ; ===========================================================================
.rdata$r:0000777C
.rdata$r:0000777C ; Segment type: Pure data
.rdata$r:0000777C ; Segment permissions: Read
.rdata$r:0000777C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000777C                 assume cs:_rdata$r
.rdata$r:0000777C                 ;org 777Ch
.rdata$r:0000777C ; COMDAT (pick any)
.rdata$r:0000777C                 public ??_R1A@?0A@EC@IUnknown@@8
.rdata$r:0000777C ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 66)'
.rdata$r:0000777C ??_R1A@?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:0000777C                                         ; DATA XREF: .rdata$r:0000761Co
.rdata$r:0000777C                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00007780                 db    0
.rdata$r:00007781                 db    0
.rdata$r:00007782                 db    0
.rdata$r:00007783                 db    0
.rdata$r:00007784                 db    0
.rdata$r:00007785                 db    0
.rdata$r:00007786                 db    0
.rdata$r:00007787                 db    0
.rdata$r:00007788                 db 0FFh
.rdata$r:00007789                 db 0FFh
.rdata$r:0000778A                 db 0FFh
.rdata$r:0000778B                 db 0FFh
.rdata$r:0000778C                 db    0
.rdata$r:0000778D                 db    0
.rdata$r:0000778E                 db    0
.rdata$r:0000778F                 db    0
.rdata$r:00007790                 db  42h ; B
.rdata$r:00007791                 db    0
.rdata$r:00007792                 db    0
.rdata$r:00007793                 db    0
.rdata$r:00007794                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007794 _rdata$r        ends
.rdata$r:00007794
.rdata$r:00007798 ; ===========================================================================
.rdata$r:00007798
.rdata$r:00007798 ; Segment type: Pure data
.rdata$r:00007798 ; Segment permissions: Read
.rdata$r:00007798 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007798                 assume cs:_rdata$r
.rdata$r:00007798                 ;org 7798h
.rdata$r:00007798 ; COMDAT (pick any)
.rdata$r:00007798                 public ??_R13?0A@EA@IArchiveExtractCallbackMessage@@8
.rdata$r:00007798 ; IArchiveExtractCallbackMessage::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:00007798 ??_R13?0A@EA@IArchiveExtractCallbackMessage@@8 dd offset ??_R0?AUIArchiveExtractCallbackMessage@@@8
.rdata$r:00007798                                         ; DATA XREF: .rdata$r:00007620o
.rdata$r:00007798                                         ; IArchiveExtractCallbackMessage `RTTI Type Descriptor'
.rdata$r:0000779C                 db    2
.rdata$r:0000779D                 db    0
.rdata$r:0000779E                 db    0
.rdata$r:0000779F                 db    0
.rdata$r:000077A0                 db    4
.rdata$r:000077A1                 db    0
.rdata$r:000077A2                 db    0
.rdata$r:000077A3                 db    0
.rdata$r:000077A4                 db 0FFh
.rdata$r:000077A5                 db 0FFh
.rdata$r:000077A6                 db 0FFh
.rdata$r:000077A7                 db 0FFh
.rdata$r:000077A8                 db    0
.rdata$r:000077A9                 db    0
.rdata$r:000077AA                 db    0
.rdata$r:000077AB                 db    0
.rdata$r:000077AC                 db  40h ; @
.rdata$r:000077AD                 db    0
.rdata$r:000077AE                 db    0
.rdata$r:000077AF                 db    0
.rdata$r:000077B0                 dd offset ??_R3IArchiveExtractCallbackMessage@@8 ; IArchiveExtractCallbackMessage::`RTTI Class Hierarchy Descriptor'
.rdata$r:000077B0 _rdata$r        ends
.rdata$r:000077B0
.data:000077B4 ; ===========================================================================
.data:000077B4
.data:000077B4 ; Segment type: Pure data
.data:000077B4 ; Segment permissions: Read/Write
.data:000077B4 _data           segment dword public 'DATA' use32
.data:000077B4                 assume cs:_data
.data:000077B4                 ;org 77B4h
.data:000077B4 ; COMDAT (pick any)
.data:000077B4                 public ??_R0?AUIArchiveExtractCallbackMessage@@@8
.data:000077B4 ; struct IArchiveExtractCallbackMessage `RTTI Type Descriptor'
.data:000077B4 ??_R0?AUIArchiveExtractCallbackMessage@@@8 dd offset ??_7type_info@@6B@
.data:000077B4                                         ; DATA XREF: .rdata$r:IArchiveExtractCallbackMessage::`RTTI Base Class Descriptor at (4,-1,0,64)'o
.data:000077B4                                         ; .rdata$r:IArchiveExtractCallbackMessage::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:000077B4                                         ; const type_info::`vftable'
.data:000077B8                 db    0
.data:000077B9                 db    0
.data:000077BA                 db    0
.data:000077BB                 db    0
.data:000077BC                 db  2Eh ; .
.data:000077BD                 db  3Fh ; ?
.data:000077BE                 db  41h ; A
.data:000077BF                 db  55h ; U
.data:000077C0                 db  49h ; I
.data:000077C1                 db  41h ; A
.data:000077C2                 db  72h ; r
.data:000077C3                 db  63h ; c
.data:000077C4                 db  68h ; h
.data:000077C5                 db  69h ; i
.data:000077C6                 db  76h ; v
.data:000077C7                 db  65h ; e
.data:000077C8                 db  45h ; E
.data:000077C9                 db  78h ; x
.data:000077CA                 db  74h ; t
.data:000077CB                 db  72h ; r
.data:000077CC                 db  61h ; a
.data:000077CD                 db  63h ; c
.data:000077CE                 db  74h ; t
.data:000077CF                 db  43h ; C
.data:000077D0                 db  61h ; a
.data:000077D1                 db  6Ch ; l
.data:000077D2                 db  6Ch ; l
.data:000077D3                 db  62h ; b
.data:000077D4                 db  61h ; a
.data:000077D5                 db  63h ; c
.data:000077D6                 db  6Bh ; k
.data:000077D7                 db  4Dh ; M
.data:000077D8                 db  65h ; e
.data:000077D9                 db  73h ; s
.data:000077DA                 db  73h ; s
.data:000077DB                 db  61h ; a
.data:000077DC                 db  67h ; g
.data:000077DD                 db  65h ; e
.data:000077DE                 db  40h ; @
.data:000077DF                 db  40h ; @
.data:000077E0                 db    0
.data:000077E1                 align 4
.data:000077E1 _data           ends
.data:000077E1
.rdata$r:000077E4 ; ===========================================================================
.rdata$r:000077E4
.rdata$r:000077E4 ; Segment type: Pure data
.rdata$r:000077E4 ; Segment permissions: Read
.rdata$r:000077E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000077E4                 assume cs:_rdata$r
.rdata$r:000077E4                 ;org 77E4h
.rdata$r:000077E4 ; COMDAT (pick any)
.rdata$r:000077E4                 public ??_R3IArchiveExtractCallbackMessage@@8
.rdata$r:000077E4 ; IArchiveExtractCallbackMessage::`RTTI Class Hierarchy Descriptor'
.rdata$r:000077E4 ??_R3IArchiveExtractCallbackMessage@@8 db    0
.rdata$r:000077E4                                         ; DATA XREF: .rdata$r:000077B0o
.rdata$r:000077E4                                         ; .rdata$r:0000781Co ...
.rdata$r:000077E5                 db    0
.rdata$r:000077E6                 db    0
.rdata$r:000077E7                 db    0
.rdata$r:000077E8                 db    0
.rdata$r:000077E9                 db    0
.rdata$r:000077EA                 db    0
.rdata$r:000077EB                 db    0
.rdata$r:000077EC                 db    3
.rdata$r:000077ED                 db    0
.rdata$r:000077EE                 db    0
.rdata$r:000077EF                 db    0
.rdata$r:000077F0                 dd offset ??_R2IArchiveExtractCallbackMessage@@8 ; IArchiveExtractCallbackMessage::`RTTI Base Class Array'
.rdata$r:000077F0 _rdata$r        ends
.rdata$r:000077F0
.rdata$r:000077F4 ; ===========================================================================
.rdata$r:000077F4
.rdata$r:000077F4 ; Segment type: Pure data
.rdata$r:000077F4 ; Segment permissions: Read
.rdata$r:000077F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000077F4                 assume cs:_rdata$r
.rdata$r:000077F4                 ;org 77F4h
.rdata$r:000077F4 ; COMDAT (pick any)
.rdata$r:000077F4                 public ??_R2IArchiveExtractCallbackMessage@@8
.rdata$r:000077F4 ; IArchiveExtractCallbackMessage::`RTTI Base Class Array'
.rdata$r:000077F4 ??_R2IArchiveExtractCallbackMessage@@8 dd offset ??_R1A@?0A@EA@IArchiveExtractCallbackMessage@@8
.rdata$r:000077F4                                         ; DATA XREF: .rdata$r:000077F0o
.rdata$r:000077F4                                         ; IArchiveExtractCallbackMessage::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000077F8                 dd offset ??_R1A@?0A@EA@IProgress@@8 ; IProgress::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000077FC                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007800                 db    0
.rdata$r:00007801                 align 4
.rdata$r:00007801 _rdata$r        ends
.rdata$r:00007801
.rdata$r:00007804 ; ===========================================================================
.rdata$r:00007804
.rdata$r:00007804 ; Segment type: Pure data
.rdata$r:00007804 ; Segment permissions: Read
.rdata$r:00007804 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007804                 assume cs:_rdata$r
.rdata$r:00007804                 ;org 7804h
.rdata$r:00007804 ; COMDAT (pick any)
.rdata$r:00007804                 public ??_R1A@?0A@EA@IArchiveExtractCallbackMessage@@8
.rdata$r:00007804 ; IArchiveExtractCallbackMessage::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00007804 ??_R1A@?0A@EA@IArchiveExtractCallbackMessage@@8 dd offset ??_R0?AUIArchiveExtractCallbackMessage@@@8
.rdata$r:00007804                                         ; DATA XREF: .rdata$r:IArchiveExtractCallbackMessage::`RTTI Base Class Array'o
.rdata$r:00007804                                         ; IArchiveExtractCallbackMessage `RTTI Type Descriptor'
.rdata$r:00007808                 db    2
.rdata$r:00007809                 db    0
.rdata$r:0000780A                 db    0
.rdata$r:0000780B                 db    0
.rdata$r:0000780C                 db    0
.rdata$r:0000780D                 db    0
.rdata$r:0000780E                 db    0
.rdata$r:0000780F                 db    0
.rdata$r:00007810                 db 0FFh
.rdata$r:00007811                 db 0FFh
.rdata$r:00007812                 db 0FFh
.rdata$r:00007813                 db 0FFh
.rdata$r:00007814                 db    0
.rdata$r:00007815                 db    0
.rdata$r:00007816                 db    0
.rdata$r:00007817                 db    0
.rdata$r:00007818                 db  40h ; @
.rdata$r:00007819                 db    0
.rdata$r:0000781A                 db    0
.rdata$r:0000781B                 db    0
.rdata$r:0000781C                 dd offset ??_R3IArchiveExtractCallbackMessage@@8 ; IArchiveExtractCallbackMessage::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000781C _rdata$r        ends
.rdata$r:0000781C
.rdata$r:00007820 ; ===========================================================================
.rdata$r:00007820
.rdata$r:00007820 ; Segment type: Pure data
.rdata$r:00007820 ; Segment permissions: Read
.rdata$r:00007820 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007820                 assume cs:_rdata$r
.rdata$r:00007820                 ;org 7820h
.rdata$r:00007820 ; COMDAT (pick any)
.rdata$r:00007820                 public ??_R13?0A@EC@IProgress@@8
.rdata$r:00007820 ; IProgress::`RTTI Base Class Descriptor at (4, -1, 0, 66)'
.rdata$r:00007820 ??_R13?0A@EC@IProgress@@8 dd offset ??_R0?AUIProgress@@@8
.rdata$r:00007820                                         ; DATA XREF: .rdata$r:00007624o
.rdata$r:00007820                                         ; IProgress `RTTI Type Descriptor'
.rdata$r:00007824                 db    1
.rdata$r:00007825                 db    0
.rdata$r:00007826                 db    0
.rdata$r:00007827                 db    0
.rdata$r:00007828                 db    4
.rdata$r:00007829                 db    0
.rdata$r:0000782A                 db    0
.rdata$r:0000782B                 db    0
.rdata$r:0000782C                 db 0FFh
.rdata$r:0000782D                 db 0FFh
.rdata$r:0000782E                 db 0FFh
.rdata$r:0000782F                 db 0FFh
.rdata$r:00007830                 db    0
.rdata$r:00007831                 db    0
.rdata$r:00007832                 db    0
.rdata$r:00007833                 db    0
.rdata$r:00007834                 db  42h ; B
.rdata$r:00007835                 db    0
.rdata$r:00007836                 db    0
.rdata$r:00007837                 db    0
.rdata$r:00007838                 dd offset ??_R3IProgress@@8 ; IProgress::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007838 _rdata$r        ends
.rdata$r:00007838
.rdata$r:0000783C ; ===========================================================================
.rdata$r:0000783C
.rdata$r:0000783C ; Segment type: Pure data
.rdata$r:0000783C ; Segment permissions: Read
.rdata$r:0000783C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000783C                 assume cs:_rdata$r
.rdata$r:0000783C                 ;org 783Ch
.rdata$r:0000783C ; COMDAT (pick any)
.rdata$r:0000783C                 public ??_R13?0A@EC@IUnknown@@8
.rdata$r:0000783C ; IUnknown::`RTTI Base Class Descriptor at (4, -1, 0, 66)'
.rdata$r:0000783C ??_R13?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:0000783C                                         ; DATA XREF: .rdata$r:00007628o
.rdata$r:0000783C                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00007840                 db    0
.rdata$r:00007841                 db    0
.rdata$r:00007842                 db    0
.rdata$r:00007843                 db    0
.rdata$r:00007844                 db    4
.rdata$r:00007845                 db    0
.rdata$r:00007846                 db    0
.rdata$r:00007847                 db    0
.rdata$r:00007848                 db 0FFh
.rdata$r:00007849                 db 0FFh
.rdata$r:0000784A                 db 0FFh
.rdata$r:0000784B                 db 0FFh
.rdata$r:0000784C                 db    0
.rdata$r:0000784D                 db    0
.rdata$r:0000784E                 db    0
.rdata$r:0000784F                 db    0
.rdata$r:00007850                 db  42h ; B
.rdata$r:00007851                 db    0
.rdata$r:00007852                 db    0
.rdata$r:00007853                 db    0
.rdata$r:00007854                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007854 _rdata$r        ends
.rdata$r:00007854
.rdata$r:00007858 ; ===========================================================================
.rdata$r:00007858
.rdata$r:00007858 ; Segment type: Pure data
.rdata$r:00007858 ; Segment permissions: Read
.rdata$r:00007858 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007858                 assume cs:_rdata$r
.rdata$r:00007858                 ;org 7858h
.rdata$r:00007858 ; COMDAT (pick any)
.rdata$r:00007858                 public ??_R17?0A@EA@ICryptoGetTextPassword@@8
.rdata$r:00007858 ; ICryptoGetTextPassword::`RTTI Base Class Descriptor at (8, -1, 0, 64)'
.rdata$r:00007858 ??_R17?0A@EA@ICryptoGetTextPassword@@8 dd offset ??_R0?AUICryptoGetTextPassword@@@8
.rdata$r:00007858                                         ; DATA XREF: .rdata$r:0000762Co
.rdata$r:00007858                                         ; ICryptoGetTextPassword `RTTI Type Descriptor'
.rdata$r:0000785C                 db    1
.rdata$r:0000785D                 db    0
.rdata$r:0000785E                 db    0
.rdata$r:0000785F                 db    0
.rdata$r:00007860                 db    8
.rdata$r:00007861                 db    0
.rdata$r:00007862                 db    0
.rdata$r:00007863                 db    0
.rdata$r:00007864                 db 0FFh
.rdata$r:00007865                 db 0FFh
.rdata$r:00007866                 db 0FFh
.rdata$r:00007867                 db 0FFh
.rdata$r:00007868                 db    0
.rdata$r:00007869                 db    0
.rdata$r:0000786A                 db    0
.rdata$r:0000786B                 db    0
.rdata$r:0000786C                 db  40h ; @
.rdata$r:0000786D                 db    0
.rdata$r:0000786E                 db    0
.rdata$r:0000786F                 db    0
.rdata$r:00007870                 dd offset ??_R3ICryptoGetTextPassword@@8 ; ICryptoGetTextPassword::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007870 _rdata$r        ends
.rdata$r:00007870
.data:00007874 ; ===========================================================================
.data:00007874
.data:00007874 ; Segment type: Pure data
.data:00007874 ; Segment permissions: Read/Write
.data:00007874 _data           segment dword public 'DATA' use32
.data:00007874                 assume cs:_data
.data:00007874                 ;org 7874h
.data:00007874 ; COMDAT (pick any)
.data:00007874                 public ??_R0?AUICryptoGetTextPassword@@@8
.data:00007874 ; struct ICryptoGetTextPassword `RTTI Type Descriptor'
.data:00007874 ??_R0?AUICryptoGetTextPassword@@@8 dd offset ??_7type_info@@6B@
.data:00007874                                         ; DATA XREF: .rdata$r:ICryptoGetTextPassword::`RTTI Base Class Descriptor at (8,-1,0,64)'o
.data:00007874                                         ; .rdata$r:ICryptoGetTextPassword::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:00007874                                         ; const type_info::`vftable'
.data:00007878                 db    0
.data:00007879                 db    0
.data:0000787A                 db    0
.data:0000787B                 db    0
.data:0000787C                 db  2Eh ; .
.data:0000787D                 db  3Fh ; ?
.data:0000787E                 db  41h ; A
.data:0000787F                 db  55h ; U
.data:00007880                 db  49h ; I
.data:00007881                 db  43h ; C
.data:00007882                 db  72h ; r
.data:00007883                 db  79h ; y
.data:00007884                 db  70h ; p
.data:00007885                 db  74h ; t
.data:00007886                 db  6Fh ; o
.data:00007887                 db  47h ; G
.data:00007888                 db  65h ; e
.data:00007889                 db  74h ; t
.data:0000788A                 db  54h ; T
.data:0000788B                 db  65h ; e
.data:0000788C                 db  78h ; x
.data:0000788D                 db  74h ; t
.data:0000788E                 db  50h ; P
.data:0000788F                 db  61h ; a
.data:00007890                 db  73h ; s
.data:00007891                 db  73h ; s
.data:00007892                 db  77h ; w
.data:00007893                 db  6Fh ; o
.data:00007894                 db  72h ; r
.data:00007895                 db  64h ; d
.data:00007896                 db  40h ; @
.data:00007897                 db  40h ; @
.data:00007898                 db    0
.data:00007899                 align 4
.data:00007899 _data           ends
.data:00007899
.rdata$r:0000789C ; ===========================================================================
.rdata$r:0000789C
.rdata$r:0000789C ; Segment type: Pure data
.rdata$r:0000789C ; Segment permissions: Read
.rdata$r:0000789C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000789C                 assume cs:_rdata$r
.rdata$r:0000789C                 ;org 789Ch
.rdata$r:0000789C ; COMDAT (pick any)
.rdata$r:0000789C                 public ??_R3ICryptoGetTextPassword@@8
.rdata$r:0000789C ; ICryptoGetTextPassword::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000789C ??_R3ICryptoGetTextPassword@@8 db    0  ; DATA XREF: .rdata$r:00007870o
.rdata$r:0000789C                                         ; .rdata$r:000078D0o ...
.rdata$r:0000789D                 db    0
.rdata$r:0000789E                 db    0
.rdata$r:0000789F                 db    0
.rdata$r:000078A0                 db    0
.rdata$r:000078A1                 db    0
.rdata$r:000078A2                 db    0
.rdata$r:000078A3                 db    0
.rdata$r:000078A4                 db    2
.rdata$r:000078A5                 db    0
.rdata$r:000078A6                 db    0
.rdata$r:000078A7                 db    0
.rdata$r:000078A8                 dd offset ??_R2ICryptoGetTextPassword@@8 ; ICryptoGetTextPassword::`RTTI Base Class Array'
.rdata$r:000078A8 _rdata$r        ends
.rdata$r:000078A8
.rdata$r:000078AC ; ===========================================================================
.rdata$r:000078AC
.rdata$r:000078AC ; Segment type: Pure data
.rdata$r:000078AC ; Segment permissions: Read
.rdata$r:000078AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000078AC                 assume cs:_rdata$r
.rdata$r:000078AC                 ;org 78ACh
.rdata$r:000078AC ; COMDAT (pick any)
.rdata$r:000078AC                 public ??_R2ICryptoGetTextPassword@@8
.rdata$r:000078AC ; ICryptoGetTextPassword::`RTTI Base Class Array'
.rdata$r:000078AC ??_R2ICryptoGetTextPassword@@8 dd offset ??_R1A@?0A@EA@ICryptoGetTextPassword@@8
.rdata$r:000078AC                                         ; DATA XREF: .rdata$r:000078A8o
.rdata$r:000078AC                                         ; ICryptoGetTextPassword::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000078B0                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000078B4                 db    0
.rdata$r:000078B5                 align 4
.rdata$r:000078B5 _rdata$r        ends
.rdata$r:000078B5
.rdata$r:000078B8 ; ===========================================================================
.rdata$r:000078B8
.rdata$r:000078B8 ; Segment type: Pure data
.rdata$r:000078B8 ; Segment permissions: Read
.rdata$r:000078B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000078B8                 assume cs:_rdata$r
.rdata$r:000078B8                 ;org 78B8h
.rdata$r:000078B8 ; COMDAT (pick any)
.rdata$r:000078B8                 public ??_R1A@?0A@EA@ICryptoGetTextPassword@@8
.rdata$r:000078B8 ; ICryptoGetTextPassword::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000078B8 ??_R1A@?0A@EA@ICryptoGetTextPassword@@8 dd offset ??_R0?AUICryptoGetTextPassword@@@8
.rdata$r:000078B8                                         ; DATA XREF: .rdata$r:ICryptoGetTextPassword::`RTTI Base Class Array'o
.rdata$r:000078B8                                         ; ICryptoGetTextPassword `RTTI Type Descriptor'
.rdata$r:000078BC                 db    1
.rdata$r:000078BD                 db    0
.rdata$r:000078BE                 db    0
.rdata$r:000078BF                 db    0
.rdata$r:000078C0                 db    0
.rdata$r:000078C1                 db    0
.rdata$r:000078C2                 db    0
.rdata$r:000078C3                 db    0
.rdata$r:000078C4                 db 0FFh
.rdata$r:000078C5                 db 0FFh
.rdata$r:000078C6                 db 0FFh
.rdata$r:000078C7                 db 0FFh
.rdata$r:000078C8                 db    0
.rdata$r:000078C9                 db    0
.rdata$r:000078CA                 db    0
.rdata$r:000078CB                 db    0
.rdata$r:000078CC                 db  40h ; @
.rdata$r:000078CD                 db    0
.rdata$r:000078CE                 db    0
.rdata$r:000078CF                 db    0
.rdata$r:000078D0                 dd offset ??_R3ICryptoGetTextPassword@@8 ; ICryptoGetTextPassword::`RTTI Class Hierarchy Descriptor'
.rdata$r:000078D0 _rdata$r        ends
.rdata$r:000078D0
.rdata$r:000078D4 ; ===========================================================================
.rdata$r:000078D4
.rdata$r:000078D4 ; Segment type: Pure data
.rdata$r:000078D4 ; Segment permissions: Read
.rdata$r:000078D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000078D4                 assume cs:_rdata$r
.rdata$r:000078D4                 ;org 78D4h
.rdata$r:000078D4 ; COMDAT (pick any)
.rdata$r:000078D4                 public ??_R17?0A@EC@IUnknown@@8
.rdata$r:000078D4 ; IUnknown::`RTTI Base Class Descriptor at (8, -1, 0, 66)'
.rdata$r:000078D4 ??_R17?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:000078D4                                         ; DATA XREF: .rdata$r:00007630o
.rdata$r:000078D4                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:000078D8                 db    0
.rdata$r:000078D9                 db    0
.rdata$r:000078DA                 db    0
.rdata$r:000078DB                 db    0
.rdata$r:000078DC                 db    8
.rdata$r:000078DD                 db    0
.rdata$r:000078DE                 db    0
.rdata$r:000078DF                 db    0
.rdata$r:000078E0                 db 0FFh
.rdata$r:000078E1                 db 0FFh
.rdata$r:000078E2                 db 0FFh
.rdata$r:000078E3                 db 0FFh
.rdata$r:000078E4                 db    0
.rdata$r:000078E5                 db    0
.rdata$r:000078E6                 db    0
.rdata$r:000078E7                 db    0
.rdata$r:000078E8                 db  42h ; B
.rdata$r:000078E9                 db    0
.rdata$r:000078EA                 db    0
.rdata$r:000078EB                 db    0
.rdata$r:000078EC                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:000078EC _rdata$r        ends
.rdata$r:000078EC
.rdata$r:000078F0 ; ===========================================================================
.rdata$r:000078F0
.rdata$r:000078F0 ; Segment type: Pure data
.rdata$r:000078F0 ; Segment permissions: Read
.rdata$r:000078F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000078F0                 assume cs:_rdata$r
.rdata$r:000078F0                 ;org 78F0h
.rdata$r:000078F0 ; COMDAT (pick any)
.rdata$r:000078F0                 public ??_R1M@?0A@EA@ICompressProgressInfo@@8
.rdata$r:000078F0 ; ICompressProgressInfo::`RTTI Base Class Descriptor at (12, -1, 0, 64)'
.rdata$r:000078F0 ??_R1M@?0A@EA@ICompressProgressInfo@@8 dd offset ??_R0?AUICompressProgressInfo@@@8
.rdata$r:000078F0                                         ; DATA XREF: .rdata$r:00007634o
.rdata$r:000078F0                                         ; ICompressProgressInfo `RTTI Type Descriptor'
.rdata$r:000078F4                 db    1
.rdata$r:000078F5                 db    0
.rdata$r:000078F6                 db    0
.rdata$r:000078F7                 db    0
.rdata$r:000078F8                 db  0Ch
.rdata$r:000078F9                 db    0
.rdata$r:000078FA                 db    0
.rdata$r:000078FB                 db    0
.rdata$r:000078FC                 db 0FFh
.rdata$r:000078FD                 db 0FFh
.rdata$r:000078FE                 db 0FFh
.rdata$r:000078FF                 db 0FFh
.rdata$r:00007900                 db    0
.rdata$r:00007901                 db    0
.rdata$r:00007902                 db    0
.rdata$r:00007903                 db    0
.rdata$r:00007904                 db  40h ; @
.rdata$r:00007905                 db    0
.rdata$r:00007906                 db    0
.rdata$r:00007907                 db    0
.rdata$r:00007908                 dd offset ??_R3ICompressProgressInfo@@8 ; ICompressProgressInfo::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007908 _rdata$r        ends
.rdata$r:00007908
.data:0000790C ; ===========================================================================
.data:0000790C
.data:0000790C ; Segment type: Pure data
.data:0000790C ; Segment permissions: Read/Write
.data:0000790C _data           segment dword public 'DATA' use32
.data:0000790C                 assume cs:_data
.data:0000790C                 ;org 790Ch
.data:0000790C ; COMDAT (pick any)
.data:0000790C                 public ??_R0?AUICompressProgressInfo@@@8
.data:0000790C ; struct ICompressProgressInfo `RTTI Type Descriptor'
.data:0000790C ??_R0?AUICompressProgressInfo@@@8 dd offset ??_7type_info@@6B@
.data:0000790C                                         ; DATA XREF: .rdata$r:ICompressProgressInfo::`RTTI Base Class Descriptor at (12,-1,0,64)'o
.data:0000790C                                         ; .rdata$r:ICompressProgressInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:0000790C                                         ; const type_info::`vftable'
.data:00007910                 db    0
.data:00007911                 db    0
.data:00007912                 db    0
.data:00007913                 db    0
.data:00007914                 db  2Eh ; .
.data:00007915                 db  3Fh ; ?
.data:00007916                 db  41h ; A
.data:00007917                 db  55h ; U
.data:00007918                 db  49h ; I
.data:00007919                 db  43h ; C
.data:0000791A                 db  6Fh ; o
.data:0000791B                 db  6Dh ; m
.data:0000791C                 db  70h ; p
.data:0000791D                 db  72h ; r
.data:0000791E                 db  65h ; e
.data:0000791F                 db  73h ; s
.data:00007920                 db  73h ; s
.data:00007921                 db  50h ; P
.data:00007922                 db  72h ; r
.data:00007923                 db  6Fh ; o
.data:00007924                 db  67h ; g
.data:00007925                 db  72h ; r
.data:00007926                 db  65h ; e
.data:00007927                 db  73h ; s
.data:00007928                 db  73h ; s
.data:00007929                 db  49h ; I
.data:0000792A                 db  6Eh ; n
.data:0000792B                 db  66h ; f
.data:0000792C                 db  6Fh ; o
.data:0000792D                 db  40h ; @
.data:0000792E                 db  40h ; @
.data:0000792F                 db    0
.data:0000792F _data           ends
.data:0000792F
.rdata$r:00007930 ; ===========================================================================
.rdata$r:00007930
.rdata$r:00007930 ; Segment type: Pure data
.rdata$r:00007930 ; Segment permissions: Read
.rdata$r:00007930 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007930                 assume cs:_rdata$r
.rdata$r:00007930                 ;org 7930h
.rdata$r:00007930 ; COMDAT (pick any)
.rdata$r:00007930                 public ??_R3ICompressProgressInfo@@8
.rdata$r:00007930 ; ICompressProgressInfo::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007930 ??_R3ICompressProgressInfo@@8 db    0   ; DATA XREF: .rdata$r:00007908o
.rdata$r:00007930                                         ; .rdata$r:00007964o ...
.rdata$r:00007931                 db    0
.rdata$r:00007932                 db    0
.rdata$r:00007933                 db    0
.rdata$r:00007934                 db    0
.rdata$r:00007935                 db    0
.rdata$r:00007936                 db    0
.rdata$r:00007937                 db    0
.rdata$r:00007938                 db    2
.rdata$r:00007939                 db    0
.rdata$r:0000793A                 db    0
.rdata$r:0000793B                 db    0
.rdata$r:0000793C                 dd offset ??_R2ICompressProgressInfo@@8 ; ICompressProgressInfo::`RTTI Base Class Array'
.rdata$r:0000793C _rdata$r        ends
.rdata$r:0000793C
.rdata$r:00007940 ; ===========================================================================
.rdata$r:00007940
.rdata$r:00007940 ; Segment type: Pure data
.rdata$r:00007940 ; Segment permissions: Read
.rdata$r:00007940 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007940                 assume cs:_rdata$r
.rdata$r:00007940                 ;org 7940h
.rdata$r:00007940 ; COMDAT (pick any)
.rdata$r:00007940                 public ??_R2ICompressProgressInfo@@8
.rdata$r:00007940 ; ICompressProgressInfo::`RTTI Base Class Array'
.rdata$r:00007940 ??_R2ICompressProgressInfo@@8 dd offset ??_R1A@?0A@EA@ICompressProgressInfo@@8
.rdata$r:00007940                                         ; DATA XREF: .rdata$r:0000793Co
.rdata$r:00007940                                         ; ICompressProgressInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007944                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007948                 db    0
.rdata$r:00007949                 align 4
.rdata$r:00007949 _rdata$r        ends
.rdata$r:00007949
.rdata$r:0000794C ; ===========================================================================
.rdata$r:0000794C
.rdata$r:0000794C ; Segment type: Pure data
.rdata$r:0000794C ; Segment permissions: Read
.rdata$r:0000794C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000794C                 assume cs:_rdata$r
.rdata$r:0000794C                 ;org 794Ch
.rdata$r:0000794C ; COMDAT (pick any)
.rdata$r:0000794C                 public ??_R1A@?0A@EA@ICompressProgressInfo@@8
.rdata$r:0000794C ; ICompressProgressInfo::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000794C ??_R1A@?0A@EA@ICompressProgressInfo@@8 dd offset ??_R0?AUICompressProgressInfo@@@8
.rdata$r:0000794C                                         ; DATA XREF: .rdata$r:ICompressProgressInfo::`RTTI Base Class Array'o
.rdata$r:0000794C                                         ; ICompressProgressInfo `RTTI Type Descriptor'
.rdata$r:00007950                 db    1
.rdata$r:00007951                 db    0
.rdata$r:00007952                 db    0
.rdata$r:00007953                 db    0
.rdata$r:00007954                 db    0
.rdata$r:00007955                 db    0
.rdata$r:00007956                 db    0
.rdata$r:00007957                 db    0
.rdata$r:00007958                 db 0FFh
.rdata$r:00007959                 db 0FFh
.rdata$r:0000795A                 db 0FFh
.rdata$r:0000795B                 db 0FFh
.rdata$r:0000795C                 db    0
.rdata$r:0000795D                 db    0
.rdata$r:0000795E                 db    0
.rdata$r:0000795F                 db    0
.rdata$r:00007960                 db  40h ; @
.rdata$r:00007961                 db    0
.rdata$r:00007962                 db    0
.rdata$r:00007963                 db    0
.rdata$r:00007964                 dd offset ??_R3ICompressProgressInfo@@8 ; ICompressProgressInfo::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007964 _rdata$r        ends
.rdata$r:00007964
.rdata$r:00007968 ; ===========================================================================
.rdata$r:00007968
.rdata$r:00007968 ; Segment type: Pure data
.rdata$r:00007968 ; Segment permissions: Read
.rdata$r:00007968 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007968                 assume cs:_rdata$r
.rdata$r:00007968                 ;org 7968h
.rdata$r:00007968 ; COMDAT (pick any)
.rdata$r:00007968                 public ??_R1M@?0A@EC@IUnknown@@8
.rdata$r:00007968 ; IUnknown::`RTTI Base Class Descriptor at (12, -1, 0, 66)'
.rdata$r:00007968 ??_R1M@?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:00007968                                         ; DATA XREF: .rdata$r:00007638o
.rdata$r:00007968                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:0000796C                 align 10h
.rdata$r:00007970                 db  0Ch
.rdata$r:00007971                 db    0
.rdata$r:00007972                 db    0
.rdata$r:00007973                 db    0
.rdata$r:00007974                 db 0FFh
.rdata$r:00007975                 db 0FFh
.rdata$r:00007976                 db 0FFh
.rdata$r:00007977                 db 0FFh
.rdata$r:00007978                 db    0
.rdata$r:00007979                 db    0
.rdata$r:0000797A                 db    0
.rdata$r:0000797B                 db    0
.rdata$r:0000797C                 db  42h ; B
.rdata$r:0000797D                 db    0
.rdata$r:0000797E                 db    0
.rdata$r:0000797F                 db    0
.rdata$r:00007980                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007980 _rdata$r        ends
.rdata$r:00007980
.rdata$r:00007984 ; ===========================================================================
.rdata$r:00007984
.rdata$r:00007984 ; Segment type: Pure data
.rdata$r:00007984 ; Segment permissions: Read
.rdata$r:00007984 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007984                 assume cs:_rdata$r
.rdata$r:00007984                 ;org 7984h
.rdata$r:00007984 ; COMDAT (pick any)
.rdata$r:00007984                 public ??_R1BA@?0A@EA@CMyUnknownImp@@8
.rdata$r:00007984 ; CMyUnknownImp::`RTTI Base Class Descriptor at (16, -1, 0, 64)'
.rdata$r:00007984 ??_R1BA@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:00007984                                         ; DATA XREF: .rdata$r:0000763Co
.rdata$r:00007984                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:00007988                 db    0
.rdata$r:00007989                 db    0
.rdata$r:0000798A                 db    0
.rdata$r:0000798B                 db    0
.rdata$r:0000798C                 db  10h
.rdata$r:0000798D                 db    0
.rdata$r:0000798E                 db    0
.rdata$r:0000798F                 db    0
.rdata$r:00007990                 db 0FFh
.rdata$r:00007991                 db 0FFh
.rdata$r:00007992                 db 0FFh
.rdata$r:00007993                 db 0FFh
.rdata$r:00007994                 db    0
.rdata$r:00007995                 db    0
.rdata$r:00007996                 db    0
.rdata$r:00007997                 db    0
.rdata$r:00007998                 db  40h ; @
.rdata$r:00007999                 db    0
.rdata$r:0000799A                 db    0
.rdata$r:0000799B                 db    0
.rdata$r:0000799C                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000799C _rdata$r        ends
.rdata$r:0000799C
.data:000079A0 ; ===========================================================================
.data:000079A0
.data:000079A0 ; Segment type: Pure data
.data:000079A0 ; Segment permissions: Read/Write
.data:000079A0 _data           segment dword public 'DATA' use32
.data:000079A0                 assume cs:_data
.data:000079A0                 ;org 79A0h
.data:000079A0 ; COMDAT (pick any)
.data:000079A0                 public ??_R0?AVCMyUnknownImp@@@8
.data:000079A0 ; class CMyUnknownImp `RTTI Type Descriptor'
.data:000079A0 ??_R0?AVCMyUnknownImp@@@8 dd offset ??_7type_info@@6B@
.data:000079A0                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (16,-1,0,64)'o
.data:000079A0                                         ; .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:000079A0                                         ; const type_info::`vftable'
.data:000079A4                 align 8
.data:000079A8 a_?avcmyunknown db '.?AVCMyUnknownImp@@',0
.data:000079A8 _data           ends
.data:000079A8
.rdata$r:000079BC ; ===========================================================================
.rdata$r:000079BC
.rdata$r:000079BC ; Segment type: Pure data
.rdata$r:000079BC ; Segment permissions: Read
.rdata$r:000079BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000079BC                 assume cs:_rdata$r
.rdata$r:000079BC                 ;org 79BCh
.rdata$r:000079BC ; COMDAT (pick any)
.rdata$r:000079BC                 public ??_R3CMyUnknownImp@@8
.rdata$r:000079BC ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000079BC ??_R3CMyUnknownImp@@8 db    0           ; DATA XREF: .rdata$r:0000799Co
.rdata$r:000079BC                                         ; .rdata$r:000079ECo ...
.rdata$r:000079BD                 db    0
.rdata$r:000079BE                 db    0
.rdata$r:000079BF                 db    0
.rdata$r:000079C0                 db    0
.rdata$r:000079C1                 db    0
.rdata$r:000079C2                 db    0
.rdata$r:000079C3                 db    0
.rdata$r:000079C4                 db    1
.rdata$r:000079C5                 db    0
.rdata$r:000079C6                 db    0
.rdata$r:000079C7                 db    0
.rdata$r:000079C8                 dd offset ??_R2CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:000079C8 _rdata$r        ends
.rdata$r:000079C8
.rdata$r:000079CC ; ===========================================================================
.rdata$r:000079CC
.rdata$r:000079CC ; Segment type: Pure data
.rdata$r:000079CC ; Segment permissions: Read
.rdata$r:000079CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000079CC                 assume cs:_rdata$r
.rdata$r:000079CC                 ;org 79CCh
.rdata$r:000079CC ; COMDAT (pick any)
.rdata$r:000079CC                 public ??_R2CMyUnknownImp@@8
.rdata$r:000079CC ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:000079CC ??_R2CMyUnknownImp@@8 dd offset ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:000079CC                                         ; DATA XREF: .rdata$r:000079C8o
.rdata$r:000079CC                                         ; CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000079D0                 db    0
.rdata$r:000079D1                 align 4
.rdata$r:000079D1 _rdata$r        ends
.rdata$r:000079D1
.rdata$r:000079D4 ; ===========================================================================
.rdata$r:000079D4
.rdata$r:000079D4 ; Segment type: Pure data
.rdata$r:000079D4 ; Segment permissions: Read
.rdata$r:000079D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000079D4                 assume cs:_rdata$r
.rdata$r:000079D4                 ;org 79D4h
.rdata$r:000079D4 ; COMDAT (pick any)
.rdata$r:000079D4                 public ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:000079D4 ; CMyUnknownImp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000079D4 ??_R1A@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:000079D4                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Array'o
.rdata$r:000079D4                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:000079D8                 align 10h
.rdata$r:000079E0                 db 0FFh
.rdata$r:000079E1                 db 0FFh
.rdata$r:000079E2                 db 0FFh
.rdata$r:000079E3                 db 0FFh
.rdata$r:000079E4                 db    0
.rdata$r:000079E5                 db    0
.rdata$r:000079E6                 db    0
.rdata$r:000079E7                 db    0
.rdata$r:000079E8                 db  40h ; @
.rdata$r:000079E9                 db    0
.rdata$r:000079EA                 db    0
.rdata$r:000079EB                 db    0
.rdata$r:000079EC                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000079EC _rdata$r        ends
.rdata$r:000079EC
.rdata$r:000079F0 ; ===========================================================================
.rdata$r:000079F0
.rdata$r:000079F0 ; Segment type: Pure data
.rdata$r:000079F0 ; Segment permissions: Read
.rdata$r:000079F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000079F0                 assume cs:_rdata$r
.rdata$r:000079F0                 ;org 79F0h
.rdata$r:000079F0 ; COMDAT (pick any)
.rdata$r:000079F0                 public ??_R4CArchiveExtractCallback@@6BIArchiveExtractCallbackMessage@@@
.rdata$r:000079F0 ; const CArchiveExtractCallback::`RTTI Complete Object Locator'{for `IArchiveExtractCallbackMessage'}
.rdata$r:000079F0 ??_R4CArchiveExtractCallback@@6BIArchiveExtractCallbackMessage@@@ db    0
.rdata$r:000079F0                                         ; DATA XREF: .rdata:00007584o
.rdata$r:000079F1                 db    0
.rdata$r:000079F2                 db    0
.rdata$r:000079F3                 db    0
.rdata$r:000079F4                 db    4
.rdata$r:000079F5                 db    0
.rdata$r:000079F6                 db    0
.rdata$r:000079F7                 db    0
.rdata$r:000079F8                 db    0
.rdata$r:000079F9                 db    0
.rdata$r:000079FA                 db    0
.rdata$r:000079FB                 db    0
.rdata$r:000079FC                 dd offset ??_R0?AVCArchiveExtractCallback@@@8 ; CArchiveExtractCallback `RTTI Type Descriptor'
.rdata$r:00007A00                 dd offset ??_R3CArchiveExtractCallback@@8 ; CArchiveExtractCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007A00 _rdata$r        ends
.rdata$r:00007A00
.rdata$r:00007A04 ; ===========================================================================
.rdata$r:00007A04
.rdata$r:00007A04 ; Segment type: Pure data
.rdata$r:00007A04 ; Segment permissions: Read
.rdata$r:00007A04 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007A04                 assume cs:_rdata$r
.rdata$r:00007A04                 ;org 7A04h
.rdata$r:00007A04 ; COMDAT (pick any)
.rdata$r:00007A04                 public ??_R4CArchiveExtractCallback@@6BICryptoGetTextPassword@@@
.rdata$r:00007A04 ; const CArchiveExtractCallback::`RTTI Complete Object Locator'{for `ICryptoGetTextPassword'}
.rdata$r:00007A04 ??_R4CArchiveExtractCallback@@6BICryptoGetTextPassword@@@ db    0
.rdata$r:00007A04                                         ; DATA XREF: .rdata:00007570o
.rdata$r:00007A05                 db    0
.rdata$r:00007A06                 db    0
.rdata$r:00007A07                 db    0
.rdata$r:00007A08                 db    8
.rdata$r:00007A09                 db    0
.rdata$r:00007A0A                 db    0
.rdata$r:00007A0B                 db    0
.rdata$r:00007A0C                 db    0
.rdata$r:00007A0D                 db    0
.rdata$r:00007A0E                 db    0
.rdata$r:00007A0F                 db    0
.rdata$r:00007A10                 dd offset ??_R0?AVCArchiveExtractCallback@@@8 ; CArchiveExtractCallback `RTTI Type Descriptor'
.rdata$r:00007A14                 dd offset ??_R3CArchiveExtractCallback@@8 ; CArchiveExtractCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007A14 _rdata$r        ends
.rdata$r:00007A14
.rdata$r:00007A18 ; ===========================================================================
.rdata$r:00007A18
.rdata$r:00007A18 ; Segment type: Pure data
.rdata$r:00007A18 ; Segment permissions: Read
.rdata$r:00007A18 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007A18                 assume cs:_rdata$r
.rdata$r:00007A18                 ;org 7A18h
.rdata$r:00007A18 ; COMDAT (pick any)
.rdata$r:00007A18                 public ??_R4CArchiveExtractCallback@@6BICompressProgressInfo@@@
.rdata$r:00007A18 ; const CArchiveExtractCallback::`RTTI Complete Object Locator'{for `ICompressProgressInfo'}
.rdata$r:00007A18 ??_R4CArchiveExtractCallback@@6BICompressProgressInfo@@@ db    0
.rdata$r:00007A18                                         ; DATA XREF: .rdata:0000755Co
.rdata$r:00007A19                 db    0
.rdata$r:00007A1A                 db    0
.rdata$r:00007A1B                 db    0
.rdata$r:00007A1C                 db  0Ch
.rdata$r:00007A1D                 db    0
.rdata$r:00007A1E                 db    0
.rdata$r:00007A1F                 db    0
.rdata$r:00007A20                 db    0
.rdata$r:00007A21                 db    0
.rdata$r:00007A22                 db    0
.rdata$r:00007A23                 db    0
.rdata$r:00007A24                 dd offset ??_R0?AVCArchiveExtractCallback@@@8 ; CArchiveExtractCallback `RTTI Type Descriptor'
.rdata$r:00007A28                 dd offset ??_R3CArchiveExtractCallback@@8 ; CArchiveExtractCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007A28 _rdata$r        ends
.rdata$r:00007A28
.text:00007A2C ; ===========================================================================
.text:00007A2C
.text:00007A2C ; Segment type: Pure code
.text:00007A2C ; Segment permissions: Read/Execute
.text:00007A2C _text           segment para public 'CODE' use32
.text:00007A2C                 assume cs:_text
.text:00007A2C                 ;org 7A2Ch
.text:00007A2C ; COMDAT (pick any)
.text:00007A2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007A2C
.text:00007A2C ; =============== S U B R O U T I N E =======================================
.text:00007A2C
.text:00007A2C ; Attributes: bp-based frame
.text:00007A2C
.text:00007A2C ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:00007A2C                 public ??1UString@@QAE@XZ
.text:00007A2C ??1UString@@QAE@XZ proc near            ; CODE XREF: CArchiveExtractCallback::SendMessageError(char const *,UString const &)+A9p
.text:00007A2C                                         ; CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)+A8p ...
.text:00007A2C
.text:00007A2C var_8           = dword ptr -8
.text:00007A2C var_4           = dword ptr -4
.text:00007A2C
.text:00007A2C                 push    ebp
.text:00007A2D                 mov     ebp, esp
.text:00007A2F                 sub     esp, 8
.text:00007A32                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00007A39                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007A40                 mov     [ebp+var_4], ecx
.text:00007A43                 mov     eax, [ebp+var_4]
.text:00007A46                 mov     ecx, [eax]
.text:00007A48                 mov     [ebp+var_8], ecx
.text:00007A4B                 mov     edx, [ebp+var_8]
.text:00007A4E                 push    edx             ; void *
.text:00007A4F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00007A54                 add     esp, 4
.text:00007A57                 add     esp, 8
.text:00007A5A                 cmp     ebp, esp
.text:00007A5C                 call    __RTC_CheckEsp
.text:00007A61                 mov     esp, ebp
.text:00007A63                 pop     ebp
.text:00007A64                 retn
.text:00007A64 ??1UString@@QAE@XZ endp
.text:00007A64
.text:00007A64 ; ---------------------------------------------------------------------------
.text:00007A65                 align 4
.text:00007A65 _text           ends
.text:00007A65
.text:00007A68 ; ===========================================================================
.text:00007A68
.text:00007A68 ; Segment type: Pure code
.text:00007A68 ; Segment permissions: Read/Execute
.text:00007A68 _text           segment para public 'CODE' use32
.text:00007A68                 assume cs:_text
.text:00007A68                 ;org 7A68h
.text:00007A68 ; COMDAT (pick any)
.text:00007A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007A68
.text:00007A68 ; =============== S U B R O U T I N E =======================================
.text:00007A68
.text:00007A68 ; Attributes: bp-based frame
.text:00007A68
.text:00007A68 ; _DWORD __thiscall CMyUnknownImp::CMyUnknownImp(CMyUnknownImp *__hidden this)
.text:00007A68                 public ??0CMyUnknownImp@@QAE@XZ
.text:00007A68 ??0CMyUnknownImp@@QAE@XZ proc near      ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+68p
.text:00007A68                                         ; CStdOutFileStream::CStdOutFileStream(void)+1Cp ...
.text:00007A68
.text:00007A68 var_4           = dword ptr -4
.text:00007A68
.text:00007A68                 push    ebp
.text:00007A69                 mov     ebp, esp
.text:00007A6B                 push    ecx
.text:00007A6C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007A73                 mov     [ebp+var_4], ecx
.text:00007A76                 mov     eax, [ebp+var_4]
.text:00007A79                 mov     dword ptr [eax], 0
.text:00007A7F                 mov     eax, [ebp+var_4]
.text:00007A82                 mov     esp, ebp
.text:00007A84                 pop     ebp
.text:00007A85                 retn
.text:00007A85 ??0CMyUnknownImp@@QAE@XZ endp
.text:00007A85
.text:00007A85 ; ---------------------------------------------------------------------------
.text:00007A86                 align 4
.text:00007A86 _text           ends
.text:00007A86
.text:00007A88 ; ===========================================================================
.text:00007A88
.text:00007A88 ; Segment type: Pure code
.text:00007A88 ; Segment permissions: Read/Execute
.text:00007A88 _text           segment para public 'CODE' use32
.text:00007A88                 assume cs:_text
.text:00007A88                 ;org 7A88h
.text:00007A88 ; COMDAT (pick any)
.text:00007A88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007A88
.text:00007A88 ; =============== S U B R O U T I N E =======================================
.text:00007A88
.text:00007A88 ; Attributes: bp-based frame
.text:00007A88
.text:00007A88 ; _DWORD __thiscall ICryptoGetTextPassword::ICryptoGetTextPassword(ICryptoGetTextPassword *__hidden this)
.text:00007A88                 public ??0ICryptoGetTextPassword@@QAE@XZ
.text:00007A88 ??0ICryptoGetTextPassword@@QAE@XZ proc near
.text:00007A88                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+52p
.text:00007A88
.text:00007A88 var_4           = dword ptr -4
.text:00007A88
.text:00007A88                 push    ebp
.text:00007A89                 mov     ebp, esp
.text:00007A8B                 push    ecx
.text:00007A8C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007A93                 mov     [ebp+var_4], ecx
.text:00007A96                 mov     ecx, [ebp+var_4]
.text:00007A99                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00007A9E                 mov     eax, [ebp+var_4]
.text:00007AA1                 mov     dword ptr [eax], offset ??_7ICryptoGetTextPassword@@6B@ ; const ICryptoGetTextPassword::`vftable'
.text:00007AA7                 mov     eax, [ebp+var_4]
.text:00007AAA                 add     esp, 4
.text:00007AAD                 cmp     ebp, esp
.text:00007AAF                 call    __RTC_CheckEsp
.text:00007AB4                 mov     esp, ebp
.text:00007AB6                 pop     ebp
.text:00007AB7                 retn
.text:00007AB7 ??0ICryptoGetTextPassword@@QAE@XZ endp
.text:00007AB7
.text:00007AB7 _text           ends
.text:00007AB7
.rdata:00007AB8 ; ===========================================================================
.rdata:00007AB8
.rdata:00007AB8 ; Segment type: Pure data
.rdata:00007AB8 ; Segment permissions: Read
.rdata:00007AB8 _rdata          segment dword public 'DATA' use32
.rdata:00007AB8                 assume cs:_rdata
.rdata:00007AB8                 ;org 7AB8h
.rdata:00007AB8 ; COMDAT (pick largest)
.rdata:00007AB8                 dd offset ??_R4ICryptoGetTextPassword@@6B@ ; const ICryptoGetTextPassword::`RTTI Complete Object Locator'
.rdata:00007ABC                 public ??_7ICryptoGetTextPassword@@6B@
.rdata:00007ABC ; const ICryptoGetTextPassword::`vftable'
.rdata:00007ABC ??_7ICryptoGetTextPassword@@6B@ dd offset __purecall
.rdata:00007ABC                                         ; DATA XREF: ICryptoGetTextPassword::ICryptoGetTextPassword(void)+19o
.rdata:00007AC0                 dd offset __purecall
.rdata:00007AC4                 dd offset __purecall
.rdata:00007AC8                 dd offset __purecall
.rdata:00007AC8 _rdata          ends
.rdata:00007AC8
.rdata$r:00007ACC ; ===========================================================================
.rdata$r:00007ACC
.rdata$r:00007ACC ; Segment type: Pure data
.rdata$r:00007ACC ; Segment permissions: Read
.rdata$r:00007ACC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007ACC                 assume cs:_rdata$r
.rdata$r:00007ACC                 ;org 7ACCh
.rdata$r:00007ACC ; COMDAT (pick any)
.rdata$r:00007ACC                 public ??_R4ICryptoGetTextPassword@@6B@
.rdata$r:00007ACC ; const ICryptoGetTextPassword::`RTTI Complete Object Locator'
.rdata$r:00007ACC ??_R4ICryptoGetTextPassword@@6B@ db    0 ; DATA XREF: .rdata:00007AB8o
.rdata$r:00007ACD                 db    0
.rdata$r:00007ACE                 db    0
.rdata$r:00007ACF                 db    0
.rdata$r:00007AD0                 db    0
.rdata$r:00007AD1                 db    0
.rdata$r:00007AD2                 db    0
.rdata$r:00007AD3                 db    0
.rdata$r:00007AD4                 db    0
.rdata$r:00007AD5                 db    0
.rdata$r:00007AD6                 db    0
.rdata$r:00007AD7                 db    0
.rdata$r:00007AD8                 dd offset ??_R0?AUICryptoGetTextPassword@@@8 ; ICryptoGetTextPassword `RTTI Type Descriptor'
.rdata$r:00007ADC                 dd offset ??_R3ICryptoGetTextPassword@@8 ; ICryptoGetTextPassword::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007ADC _rdata$r        ends
.rdata$r:00007ADC
.text:00007AE0 ; ===========================================================================
.text:00007AE0
.text:00007AE0 ; Segment type: Pure code
.text:00007AE0 ; Segment permissions: Read/Execute
.text:00007AE0 _text           segment para public 'CODE' use32
.text:00007AE0                 assume cs:_text
.text:00007AE0                 ;org 7AE0h
.text:00007AE0 ; COMDAT (pick any)
.text:00007AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007AE0
.text:00007AE0 ; =============== S U B R O U T I N E =======================================
.text:00007AE0
.text:00007AE0 ; Attributes: bp-based frame
.text:00007AE0
.text:00007AE0 ; public: __thiscall IUnknown::IUnknown(void)
.text:00007AE0                 public ??0IUnknown@@QAE@XZ
.text:00007AE0 ??0IUnknown@@QAE@XZ proc near           ; CODE XREF: ICryptoGetTextPassword::ICryptoGetTextPassword(void)+11p
.text:00007AE0                                         ; ICompressProgressInfo::ICompressProgressInfo(void)+11p ...
.text:00007AE0
.text:00007AE0 var_4           = dword ptr -4
.text:00007AE0
.text:00007AE0                 push    ebp
.text:00007AE1                 mov     ebp, esp
.text:00007AE3                 push    ecx
.text:00007AE4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007AEB                 mov     [ebp+var_4], ecx
.text:00007AEE                 mov     eax, [ebp+var_4]
.text:00007AF1                 mov     esp, ebp
.text:00007AF3                 pop     ebp
.text:00007AF4                 retn
.text:00007AF4 ??0IUnknown@@QAE@XZ endp
.text:00007AF4
.text:00007AF4 ; ---------------------------------------------------------------------------
.text:00007AF5                 align 4
.text:00007AF5 _text           ends
.text:00007AF5
.text:00007AF8 ; ===========================================================================
.text:00007AF8
.text:00007AF8 ; Segment type: Pure code
.text:00007AF8 ; Segment permissions: Read/Execute
.text:00007AF8 _text           segment para public 'CODE' use32
.text:00007AF8                 assume cs:_text
.text:00007AF8                 ;org 7AF8h
.text:00007AF8 ; COMDAT (pick any)
.text:00007AF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007AF8
.text:00007AF8 ; =============== S U B R O U T I N E =======================================
.text:00007AF8
.text:00007AF8 ; Attributes: bp-based frame
.text:00007AF8
.text:00007AF8 ; _DWORD __thiscall CReadArcItem::CReadArcItem(CReadArcItem *__hidden this)
.text:00007AF8                 public ??0CReadArcItem@@QAE@XZ
.text:00007AF8 ??0CReadArcItem@@QAE@XZ proc near       ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+12Fp
.text:00007AF8                                         ; CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+67p
.text:00007AF8
.text:00007AF8 var_10          = dword ptr -10h
.text:00007AF8 var_C           = dword ptr -0Ch
.text:00007AF8 var_4           = dword ptr -4
.text:00007AF8
.text:00007AF8                 push    ebp
.text:00007AF9                 mov     ebp, esp
.text:00007AFB                 push    0FFFFFFFFh
.text:00007AFD                 push    offset __ehhandler$??0CReadArcItem@@QAE@XZ
.text:00007B02                 mov     eax, large fs:0
.text:00007B08                 push    eax
.text:00007B09                 push    ecx
.text:00007B0A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00007B11                 mov     eax, dword ptr ds:___security_cookie
.text:00007B16                 xor     eax, ebp
.text:00007B18                 push    eax
.text:00007B19                 lea     eax, [ebp+var_C]
.text:00007B1C                 mov     large fs:0, eax
.text:00007B22                 mov     [ebp+var_10], ecx
.text:00007B25                 mov     ecx, [ebp+var_10]
.text:00007B28                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00007B2D                 mov     [ebp+var_4], 0
.text:00007B34                 mov     ecx, [ebp+var_10]
.text:00007B37                 add     ecx, 0Ch
.text:00007B3A                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00007B3F                 mov     byte ptr [ebp+var_4], 1
.text:00007B43                 mov     ecx, [ebp+var_10]
.text:00007B46                 add     ecx, 18h
.text:00007B49                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00007B4E                 mov     byte ptr [ebp+var_4], 2
.text:00007B52                 mov     ecx, [ebp+var_10]
.text:00007B55                 add     ecx, 24h ; '$'
.text:00007B58                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00007B5D                 mov     eax, [ebp+var_10]
.text:00007B60                 mov     byte ptr [eax+31h], 0
.text:00007B64                 mov     ecx, [ebp+var_10]
.text:00007B67                 mov     byte ptr [ecx+38h], 0
.text:00007B6B                 mov     edx, [ebp+var_10]
.text:00007B6E                 mov     dword ptr [edx+3Ch], 0FFFFFFFFh
.text:00007B75                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00007B7C                 mov     eax, [ebp+var_10]
.text:00007B7F                 mov     ecx, [ebp+var_C]
.text:00007B82                 mov     large fs:0, ecx
.text:00007B89                 pop     ecx
.text:00007B8A                 add     esp, 10h
.text:00007B8D                 cmp     ebp, esp
.text:00007B8F                 call    __RTC_CheckEsp
.text:00007B94                 mov     esp, ebp
.text:00007B96                 pop     ebp
.text:00007B97                 retn
.text:00007B97 ??0CReadArcItem@@QAE@XZ endp
.text:00007B97
.text:00007B97 _text           ends
.text:00007B97
.text$x:00007B98 ; ===========================================================================
.text$x:00007B98
.text$x:00007B98 ; Segment type: Pure code
.text$x:00007B98 ; Segment permissions: Read/Execute
.text$x:00007B98 _text$x         segment para public 'CODE' use32
.text$x:00007B98                 assume cs:_text$x
.text$x:00007B98                 ;org 7B98h
.text$x:00007B98 ; COMDAT (pick associative to section at 7AF8)
.text$x:00007B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007B98
.text$x:00007B98 ; =============== S U B R O U T I N E =======================================
.text$x:00007B98
.text$x:00007B98
.text$x:00007B98 __unwindfunclet$??0CReadArcItem@@QAE@XZ$0 proc near
.text$x:00007B98                                         ; DATA XREF: .xdata$x:00007BD8o
.text$x:00007B98                 mov     ecx, [ebp-10h]  ; this
.text$x:00007B9B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007B9B __unwindfunclet$??0CReadArcItem@@QAE@XZ$0 endp
.text$x:00007B9B
.text$x:00007BA0
.text$x:00007BA0 ; =============== S U B R O U T I N E =======================================
.text$x:00007BA0
.text$x:00007BA0
.text$x:00007BA0 __unwindfunclet$??0CReadArcItem@@QAE@XZ$1 proc near
.text$x:00007BA0                                         ; DATA XREF: .xdata$x:00007BE0o
.text$x:00007BA0                 mov     ecx, [ebp-10h]
.text$x:00007BA3                 add     ecx, 0Ch
.text$x:00007BA6                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00007BA6 __unwindfunclet$??0CReadArcItem@@QAE@XZ$1 endp
.text$x:00007BA6
.text$x:00007BAB
.text$x:00007BAB ; =============== S U B R O U T I N E =======================================
.text$x:00007BAB
.text$x:00007BAB
.text$x:00007BAB __unwindfunclet$??0CReadArcItem@@QAE@XZ$2 proc near
.text$x:00007BAB                                         ; DATA XREF: .xdata$x:00007BE8o
.text$x:00007BAB                 mov     ecx, [ebp-10h]
.text$x:00007BAE                 add     ecx, 18h        ; this
.text$x:00007BB1                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007BB1 __unwindfunclet$??0CReadArcItem@@QAE@XZ$2 endp
.text$x:00007BB1
.text$x:00007BB6
.text$x:00007BB6 ; =============== S U B R O U T I N E =======================================
.text$x:00007BB6
.text$x:00007BB6
.text$x:00007BB6 __ehhandler$??0CReadArcItem@@QAE@XZ proc near
.text$x:00007BB6                                         ; DATA XREF: CReadArcItem::CReadArcItem(void)+5o
.text$x:00007BB6
.text$x:00007BB6 arg_4           = dword ptr  8
.text$x:00007BB6
.text$x:00007BB6                 mov     edx, [esp+arg_4]
.text$x:00007BBA                 lea     eax, [edx+0Ch]
.text$x:00007BBD                 mov     ecx, [edx-8]
.text$x:00007BC0                 xor     ecx, eax
.text$x:00007BC2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007BC7                 mov     eax, offset __ehfuncinfo$??0CReadArcItem@@QAE@XZ
.text$x:00007BCC                 jmp     ___CxxFrameHandler3
.text$x:00007BCC __ehhandler$??0CReadArcItem@@QAE@XZ endp
.text$x:00007BCC
.text$x:00007BCC ; ---------------------------------------------------------------------------
.text$x:00007BD1                 align 4
.text$x:00007BD1 _text$x         ends
.text$x:00007BD1
.xdata$x:00007BD4 ; ===========================================================================
.xdata$x:00007BD4
.xdata$x:00007BD4 ; Segment type: Pure data
.xdata$x:00007BD4 ; Segment permissions: Read
.xdata$x:00007BD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007BD4                 assume cs:_xdata$x
.xdata$x:00007BD4                 ;org 7BD4h
.xdata$x:00007BD4 ; COMDAT (pick associative to section at 7AF8)
.xdata$x:00007BD4 __unwindtable$??0CReadArcItem@@QAE@XZ db 0FFh
.xdata$x:00007BD4                                         ; DATA XREF: .xdata$x:00007BF4o
.xdata$x:00007BD5                 db 0FFh
.xdata$x:00007BD6                 db 0FFh
.xdata$x:00007BD7                 db 0FFh
.xdata$x:00007BD8                 dd offset __unwindfunclet$??0CReadArcItem@@QAE@XZ$0
.xdata$x:00007BDC                 align 10h
.xdata$x:00007BE0                 dd offset __unwindfunclet$??0CReadArcItem@@QAE@XZ$1
.xdata$x:00007BE4                 db    1
.xdata$x:00007BE5                 db    0
.xdata$x:00007BE6                 db    0
.xdata$x:00007BE7                 db    0
.xdata$x:00007BE8                 dd offset __unwindfunclet$??0CReadArcItem@@QAE@XZ$2
.xdata$x:00007BEC __ehfuncinfo$??0CReadArcItem@@QAE@XZ db  22h ; "
.xdata$x:00007BEC                                         ; DATA XREF: __ehhandler$??0CReadArcItem@@QAE@XZ+11o
.xdata$x:00007BED                 db    5
.xdata$x:00007BEE                 db  93h ; ô
.xdata$x:00007BEF                 db  19h
.xdata$x:00007BF0                 db    3
.xdata$x:00007BF1                 db    0
.xdata$x:00007BF2                 db    0
.xdata$x:00007BF3                 db    0
.xdata$x:00007BF4                 dd offset __unwindtable$??0CReadArcItem@@QAE@XZ
.xdata$x:00007BF8                 db    0
.xdata$x:00007BF9                 db    0
.xdata$x:00007BFA                 db    0
.xdata$x:00007BFB                 db    0
.xdata$x:00007BFC                 db    0
.xdata$x:00007BFD                 db    0
.xdata$x:00007BFE                 db    0
.xdata$x:00007BFF                 db    0
.xdata$x:00007C00                 db    0
.xdata$x:00007C01                 db    0
.xdata$x:00007C02                 db    0
.xdata$x:00007C03                 db    0
.xdata$x:00007C04                 db    0
.xdata$x:00007C05                 db    0
.xdata$x:00007C06                 db    0
.xdata$x:00007C07                 db    0
.xdata$x:00007C08                 db    0
.xdata$x:00007C09                 db    0
.xdata$x:00007C0A                 db    0
.xdata$x:00007C0B                 db    0
.xdata$x:00007C0C                 db    1
.xdata$x:00007C0D                 db    0
.xdata$x:00007C0E                 db    0
.xdata$x:00007C0F                 db    0
.xdata$x:00007C0F _xdata$x        ends
.xdata$x:00007C0F
.text:00007C10 ; ===========================================================================
.text:00007C10
.text:00007C10 ; Segment type: Pure code
.text:00007C10 ; Segment permissions: Read/Execute
.text:00007C10 _text           segment para public 'CODE' use32
.text:00007C10                 assume cs:_text
.text:00007C10                 ;org 7C10h
.text:00007C10 ; COMDAT (pick any)
.text:00007C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007C10
.text:00007C10 ; =============== S U B R O U T I N E =======================================
.text:00007C10
.text:00007C10 ; Attributes: bp-based frame
.text:00007C10
.text:00007C10 ; _DWORD __thiscall CExtractNtOptions::CExtractNtOptions(CExtractNtOptions *__hidden this)
.text:00007C10                 public ??0CExtractNtOptions@@QAE@XZ
.text:00007C10 ??0CExtractNtOptions@@QAE@XZ proc near  ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+9Ap
.text:00007C10
.text:00007C10 var_4           = dword ptr -4
.text:00007C10
.text:00007C10                 push    ebp
.text:00007C11                 mov     ebp, esp
.text:00007C13                 push    ecx
.text:00007C14                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007C1B                 mov     [ebp+var_4], ecx
.text:00007C1E                 mov     ecx, [ebp+var_4] ; this
.text:00007C21                 call    ??0CBoolPair@@QAE@XZ ; CBoolPair::CBoolPair(void)
.text:00007C26                 mov     ecx, [ebp+var_4]
.text:00007C29                 add     ecx, 2          ; this
.text:00007C2C                 call    ??0CBoolPair@@QAE@XZ ; CBoolPair::CBoolPair(void)
.text:00007C31                 mov     ecx, [ebp+var_4]
.text:00007C34                 add     ecx, 4          ; this
.text:00007C37                 call    ??0CBoolPair@@QAE@XZ ; CBoolPair::CBoolPair(void)
.text:00007C3C                 mov     ecx, [ebp+var_4]
.text:00007C3F                 add     ecx, 6          ; this
.text:00007C42                 call    ??0CBoolPair@@QAE@XZ ; CBoolPair::CBoolPair(void)
.text:00007C47                 mov     eax, [ebp+var_4]
.text:00007C4A                 mov     byte ptr [eax+8], 0
.text:00007C4E                 mov     ecx, [ebp+var_4]
.text:00007C51                 mov     byte ptr [ecx+9], 0
.text:00007C55                 mov     edx, [ebp+var_4]
.text:00007C58                 mov     byte ptr [edx+2], 1
.text:00007C5C                 mov     eax, [ebp+var_4]
.text:00007C5F                 mov     byte ptr [eax+4], 1
.text:00007C63                 mov     ecx, [ebp+var_4]
.text:00007C66                 mov     byte ptr [ecx+6], 1
.text:00007C6A                 mov     eax, [ebp+var_4]
.text:00007C6D                 add     esp, 4
.text:00007C70                 cmp     ebp, esp
.text:00007C72                 call    __RTC_CheckEsp
.text:00007C77                 mov     esp, ebp
.text:00007C79                 pop     ebp
.text:00007C7A                 retn
.text:00007C7A ??0CExtractNtOptions@@QAE@XZ endp
.text:00007C7A
.text:00007C7A ; ---------------------------------------------------------------------------
.text:00007C7B                 align 4
.text:00007C7B _text           ends
.text:00007C7B
.text:00007C7C ; ===========================================================================
.text:00007C7C
.text:00007C7C ; Segment type: Pure code
.text:00007C7C ; Segment permissions: Read/Execute
.text:00007C7C _text           segment para public 'CODE' use32
.text:00007C7C                 assume cs:_text
.text:00007C7C                 ;org 7C7Ch
.text:00007C7C ; COMDAT (pick any)
.text:00007C7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007C7C
.text:00007C7C ; =============== S U B R O U T I N E =======================================
.text:00007C7C
.text:00007C7C ; Attributes: bp-based frame
.text:00007C7C
.text:00007C7C ; _DWORD __thiscall CBoolPair::CBoolPair(CBoolPair *__hidden this)
.text:00007C7C                 public ??0CBoolPair@@QAE@XZ
.text:00007C7C ??0CBoolPair@@QAE@XZ proc near          ; CODE XREF: CExtractNtOptions::CExtractNtOptions(void)+11p
.text:00007C7C                                         ; CExtractNtOptions::CExtractNtOptions(void)+1Cp ...
.text:00007C7C
.text:00007C7C var_4           = dword ptr -4
.text:00007C7C
.text:00007C7C                 push    ebp
.text:00007C7D                 mov     ebp, esp
.text:00007C7F                 push    ecx
.text:00007C80                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007C87                 mov     [ebp+var_4], ecx
.text:00007C8A                 mov     eax, [ebp+var_4]
.text:00007C8D                 mov     byte ptr [eax], 0
.text:00007C90                 mov     ecx, [ebp+var_4]
.text:00007C93                 mov     byte ptr [ecx+1], 0
.text:00007C97                 mov     eax, [ebp+var_4]
.text:00007C9A                 mov     esp, ebp
.text:00007C9C                 pop     ebp
.text:00007C9D                 retn
.text:00007C9D ??0CBoolPair@@QAE@XZ endp
.text:00007C9D
.text:00007C9D ; ---------------------------------------------------------------------------
.text:00007C9E                 align 10h
.text:00007C9E _text           ends
.text:00007C9E
.text:00007CA0 ; ===========================================================================
.text:00007CA0
.text:00007CA0 ; Segment type: Pure code
.text:00007CA0 ; Segment permissions: Read/Execute
.text:00007CA0 _text           segment para public 'CODE' use32
.text:00007CA0                 assume cs:_text
.text:00007CA0                 ;org 7CA0h
.text:00007CA0 ; COMDAT (pick any)
.text:00007CA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007CA0
.text:00007CA0 ; =============== S U B R O U T I N E =======================================
.text:00007CA0
.text:00007CA0 ; Attributes: bp-based frame
.text:00007CA0
.text:00007CA0 ; __int32 __stdcall CArchiveExtractCallback::QueryInterface(CArchiveExtractCallback *this, const struct _GUID *Buf1, void **)
.text:00007CA0                 public ?QueryInterface@CArchiveExtractCallback@@UAGJABU_GUID@@PAPAX@Z
.text:00007CA0 ?QueryInterface@CArchiveExtractCallback@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00007CA0                                         ; CODE XREF: [thunk]:CArchiveExtractCallback::QueryInterface`adjustor{4}' (_GUID const &,void * *)+5j
.text:00007CA0                                         ; [thunk]:CArchiveExtractCallback::QueryInterface`adjustor{8}' (_GUID const &,void * *)+5j ...
.text:00007CA0
.text:00007CA0 var_10          = dword ptr -10h
.text:00007CA0 var_C           = dword ptr -0Ch
.text:00007CA0 var_8           = dword ptr -8
.text:00007CA0 var_4           = dword ptr -4
.text:00007CA0 this            = dword ptr  8
.text:00007CA0 Buf1            = dword ptr  0Ch
.text:00007CA0 arg_8           = dword ptr  10h
.text:00007CA0
.text:00007CA0                 push    ebp
.text:00007CA1                 mov     ebp, esp
.text:00007CA3                 sub     esp, 10h
.text:00007CA6                 mov     eax, 0CCCCCCCCh
.text:00007CAB                 mov     [ebp+var_10], eax
.text:00007CAE                 mov     [ebp+var_C], eax
.text:00007CB1                 mov     [ebp+var_8], eax
.text:00007CB4                 mov     [ebp+var_4], eax
.text:00007CB7                 mov     eax, [ebp+arg_8]
.text:00007CBA                 mov     dword ptr [eax], 0
.text:00007CC0                 push    offset _IID_IUnknown ; Buf2
.text:00007CC5                 mov     ecx, [ebp+Buf1]
.text:00007CC8                 push    ecx             ; Buf1
.text:00007CC9                 call    ___@8           ; __(x,x)
.text:00007CCE                 test    eax, eax
.text:00007CD0                 jz      short loc_7CF7
.text:00007CD2                 cmp     [ebp+this], 0
.text:00007CD6                 jz      short loc_7CE3
.text:00007CD8                 mov     edx, [ebp+this]
.text:00007CDB                 add     edx, 4
.text:00007CDE                 mov     [ebp+var_4], edx
.text:00007CE1                 jmp     short loc_7CEA
.text:00007CE3 ; ---------------------------------------------------------------------------
.text:00007CE3
.text:00007CE3 loc_7CE3:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+36j
.text:00007CE3                 mov     [ebp+var_4], 0
.text:00007CEA
.text:00007CEA loc_7CEA:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+41j
.text:00007CEA                 mov     eax, [ebp+arg_8]
.text:00007CED                 mov     ecx, [ebp+var_4]
.text:00007CF0                 mov     [eax], ecx
.text:00007CF2                 jmp     loc_7D9A
.text:00007CF7 ; ---------------------------------------------------------------------------
.text:00007CF7
.text:00007CF7 loc_7CF7:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+30j
.text:00007CF7                 push    offset _IID_IArchiveExtractCallbackMessage ; Buf2
.text:00007CFC                 mov     edx, [ebp+Buf1]
.text:00007CFF                 push    edx             ; Buf1
.text:00007D00                 call    ___@8           ; __(x,x)
.text:00007D05                 test    eax, eax
.text:00007D07                 jz      short loc_7D2B
.text:00007D09                 cmp     [ebp+this], 0
.text:00007D0D                 jz      short loc_7D1A
.text:00007D0F                 mov     eax, [ebp+this]
.text:00007D12                 add     eax, 4
.text:00007D15                 mov     [ebp+var_8], eax
.text:00007D18                 jmp     short loc_7D21
.text:00007D1A ; ---------------------------------------------------------------------------
.text:00007D1A
.text:00007D1A loc_7D1A:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+6Dj
.text:00007D1A                 mov     [ebp+var_8], 0
.text:00007D21
.text:00007D21 loc_7D21:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+78j
.text:00007D21                 mov     ecx, [ebp+arg_8]
.text:00007D24                 mov     edx, [ebp+var_8]
.text:00007D27                 mov     [ecx], edx
.text:00007D29                 jmp     short loc_7D9A
.text:00007D2B ; ---------------------------------------------------------------------------
.text:00007D2B
.text:00007D2B loc_7D2B:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+67j
.text:00007D2B                 push    offset _IID_ICryptoGetTextPassword ; Buf2
.text:00007D30                 mov     eax, [ebp+Buf1]
.text:00007D33                 push    eax             ; Buf1
.text:00007D34                 call    ___@8           ; __(x,x)
.text:00007D39                 test    eax, eax
.text:00007D3B                 jz      short loc_7D5F
.text:00007D3D                 cmp     [ebp+this], 0
.text:00007D41                 jz      short loc_7D4E
.text:00007D43                 mov     ecx, [ebp+this]
.text:00007D46                 add     ecx, 8
.text:00007D49                 mov     [ebp+var_C], ecx
.text:00007D4C                 jmp     short loc_7D55
.text:00007D4E ; ---------------------------------------------------------------------------
.text:00007D4E
.text:00007D4E loc_7D4E:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+A1j
.text:00007D4E                 mov     [ebp+var_C], 0
.text:00007D55
.text:00007D55 loc_7D55:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+ACj
.text:00007D55                 mov     edx, [ebp+arg_8]
.text:00007D58                 mov     eax, [ebp+var_C]
.text:00007D5B                 mov     [edx], eax
.text:00007D5D                 jmp     short loc_7D9A
.text:00007D5F ; ---------------------------------------------------------------------------
.text:00007D5F
.text:00007D5F loc_7D5F:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+9Bj
.text:00007D5F                 push    offset _IID_ICompressProgressInfo ; Buf2
.text:00007D64                 mov     ecx, [ebp+Buf1]
.text:00007D67                 push    ecx             ; Buf1
.text:00007D68                 call    ___@8           ; __(x,x)
.text:00007D6D                 test    eax, eax
.text:00007D6F                 jz      short loc_7D93
.text:00007D71                 cmp     [ebp+this], 0
.text:00007D75                 jz      short loc_7D82
.text:00007D77                 mov     edx, [ebp+this]
.text:00007D7A                 add     edx, 0Ch
.text:00007D7D                 mov     [ebp+var_10], edx
.text:00007D80                 jmp     short loc_7D89
.text:00007D82 ; ---------------------------------------------------------------------------
.text:00007D82
.text:00007D82 loc_7D82:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+D5j
.text:00007D82                 mov     [ebp+var_10], 0
.text:00007D89
.text:00007D89 loc_7D89:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+E0j
.text:00007D89                 mov     eax, [ebp+arg_8]
.text:00007D8C                 mov     ecx, [ebp+var_10]
.text:00007D8F                 mov     [eax], ecx
.text:00007D91                 jmp     short loc_7D9A
.text:00007D93 ; ---------------------------------------------------------------------------
.text:00007D93
.text:00007D93 loc_7D93:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+CFj
.text:00007D93                 mov     eax, 80004002h
.text:00007D98                 jmp     short loc_7DAB
.text:00007D9A ; ---------------------------------------------------------------------------
.text:00007D9A
.text:00007D9A loc_7D9A:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+52j
.text:00007D9A                                         ; CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+89j ...
.text:00007D9A                 mov     edx, [ebp+this]
.text:00007D9D                 mov     eax, [edx+10h]
.text:00007DA0                 add     eax, 1
.text:00007DA3                 mov     ecx, [ebp+this]
.text:00007DA6                 mov     [ecx+10h], eax
.text:00007DA9                 xor     eax, eax
.text:00007DAB
.text:00007DAB loc_7DAB:                               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+F8j
.text:00007DAB                 add     esp, 10h
.text:00007DAE                 cmp     ebp, esp
.text:00007DB0                 call    __RTC_CheckEsp
.text:00007DB5                 mov     esp, ebp
.text:00007DB7                 pop     ebp
.text:00007DB8                 retn    0Ch
.text:00007DB8 ?QueryInterface@CArchiveExtractCallback@@UAGJABU_GUID@@PAPAX@Z endp
.text:00007DB8
.text:00007DB8 ; ---------------------------------------------------------------------------
.text:00007DBB                 align 4
.text:00007DBB _text           ends
.text:00007DBB
.text:00007DBC ; ===========================================================================
.text:00007DBC
.text:00007DBC ; Segment type: Pure code
.text:00007DBC ; Segment permissions: Read/Execute
.text:00007DBC _text           segment para public 'CODE' use32
.text:00007DBC                 assume cs:_text
.text:00007DBC                 ;org 7DBCh
.text:00007DBC ; COMDAT (pick any)
.text:00007DBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007DBC
.text:00007DBC ; =============== S U B R O U T I N E =======================================
.text:00007DBC
.text:00007DBC ; Attributes: bp-based frame
.text:00007DBC
.text:00007DBC ; int __stdcall __(void *Buf1, void *Buf2)
.text:00007DBC                 public ___@8
.text:00007DBC ___@8           proc near               ; CODE XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+29p
.text:00007DBC                                         ; CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+60p ...
.text:00007DBC
.text:00007DBC Buf1            = dword ptr  8
.text:00007DBC Buf2            = dword ptr  0Ch
.text:00007DBC
.text:00007DBC                 push    ebp
.text:00007DBD                 mov     ebp, esp
.text:00007DBF                 mov     eax, [ebp+Buf2]
.text:00007DC2                 push    eax             ; Buf2
.text:00007DC3                 mov     ecx, [ebp+Buf1]
.text:00007DC6                 push    ecx             ; Buf1
.text:00007DC7                 call    _IsEqualGUID@8  ; IsEqualGUID(x,x)
.text:00007DCC                 cmp     ebp, esp
.text:00007DCE                 call    __RTC_CheckEsp
.text:00007DD3                 pop     ebp
.text:00007DD4                 retn    8
.text:00007DD4 ___@8           endp
.text:00007DD4
.text:00007DD4 ; ---------------------------------------------------------------------------
.text:00007DD7                 align 4
.text:00007DD7 _text           ends
.text:00007DD7
.text:00007DD8 ; ===========================================================================
.text:00007DD8
.text:00007DD8 ; Segment type: Pure code
.text:00007DD8 ; Segment permissions: Read/Execute
.text:00007DD8 _text           segment para public 'CODE' use32
.text:00007DD8                 assume cs:_text
.text:00007DD8                 ;org 7DD8h
.text:00007DD8 ; COMDAT (pick any)
.text:00007DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007DD8
.text:00007DD8 ; =============== S U B R O U T I N E =======================================
.text:00007DD8
.text:00007DD8 ; Attributes: bp-based frame
.text:00007DD8
.text:00007DD8 ; int __stdcall IsEqualGUID(void *Buf1, void *Buf2)
.text:00007DD8                 public _IsEqualGUID@8
.text:00007DD8 _IsEqualGUID@8  proc near               ; CODE XREF: __(x,x)+Bp
.text:00007DD8
.text:00007DD8 Buf1            = dword ptr  8
.text:00007DD8 Buf2            = dword ptr  0Ch
.text:00007DD8
.text:00007DD8                 push    ebp
.text:00007DD9                 mov     ebp, esp
.text:00007DDB                 push    10h             ; Size
.text:00007DDD                 mov     eax, [ebp+Buf2]
.text:00007DE0                 push    eax             ; Buf2
.text:00007DE1                 mov     ecx, [ebp+Buf1]
.text:00007DE4                 push    ecx             ; Buf1
.text:00007DE5                 call    _memcmp
.text:00007DEA                 add     esp, 0Ch
.text:00007DED                 neg     eax
.text:00007DEF                 sbb     eax, eax
.text:00007DF1                 add     eax, 1
.text:00007DF4                 cmp     ebp, esp
.text:00007DF6                 call    __RTC_CheckEsp
.text:00007DFB                 pop     ebp
.text:00007DFC                 retn    8
.text:00007DFC _IsEqualGUID@8  endp
.text:00007DFC
.text:00007DFC ; ---------------------------------------------------------------------------
.text:00007DFF                 align 10h
.text:00007DFF _text           ends
.text:00007DFF
.text:00007E00 ; ===========================================================================
.text:00007E00
.text:00007E00 ; Segment type: Pure code
.text:00007E00 ; Segment permissions: Read/Execute
.text:00007E00 _text           segment para public 'CODE' use32
.text:00007E00                 assume cs:_text
.text:00007E00                 ;org 7E00h
.text:00007E00 ; COMDAT (pick any)
.text:00007E00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007E00
.text:00007E00 ; =============== S U B R O U T I N E =======================================
.text:00007E00
.text:00007E00 ; Attributes: bp-based frame
.text:00007E00
.text:00007E00 ; unsigned __int32 __stdcall CArchiveExtractCallback::AddRef(CArchiveExtractCallback *this)
.text:00007E00                 public ?AddRef@CArchiveExtractCallback@@UAGKXZ
.text:00007E00 ?AddRef@CArchiveExtractCallback@@UAGKXZ proc near
.text:00007E00                                         ; CODE XREF: [thunk]:CArchiveExtractCallback::AddRef`adjustor{4}' (void)+5j
.text:00007E00                                         ; [thunk]:CArchiveExtractCallback::AddRef`adjustor{8}' (void)+5j ...
.text:00007E00
.text:00007E00 var_4           = dword ptr -4
.text:00007E00 this            = dword ptr  8
.text:00007E00
.text:00007E00                 push    ebp
.text:00007E01                 mov     ebp, esp
.text:00007E03                 push    ecx
.text:00007E04                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007E0B                 mov     eax, [ebp+this]
.text:00007E0E                 mov     ecx, [eax+10h]
.text:00007E11                 add     ecx, 1
.text:00007E14                 mov     [ebp+var_4], ecx
.text:00007E17                 mov     edx, [ebp+this]
.text:00007E1A                 mov     eax, [ebp+var_4]
.text:00007E1D                 mov     [edx+10h], eax
.text:00007E20                 mov     eax, [ebp+var_4]
.text:00007E23                 mov     esp, ebp
.text:00007E25                 pop     ebp
.text:00007E26                 retn    4
.text:00007E26 ?AddRef@CArchiveExtractCallback@@UAGKXZ endp
.text:00007E26
.text:00007E26 ; ---------------------------------------------------------------------------
.text:00007E29                 align 4
.text:00007E29 _text           ends
.text:00007E29
.text:00007E2C ; ===========================================================================
.text:00007E2C
.text:00007E2C ; Segment type: Pure code
.text:00007E2C ; Segment permissions: Read/Execute
.text:00007E2C _text           segment para public 'CODE' use32
.text:00007E2C                 assume cs:_text
.text:00007E2C                 ;org 7E2Ch
.text:00007E2C ; COMDAT (pick any)
.text:00007E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007E2C
.text:00007E2C ; =============== S U B R O U T I N E =======================================
.text:00007E2C
.text:00007E2C ; Attributes: bp-based frame
.text:00007E2C
.text:00007E2C ; unsigned __int32 __stdcall CArchiveExtractCallback::Release(CArchiveExtractCallback *this)
.text:00007E2C                 public ?Release@CArchiveExtractCallback@@UAGKXZ
.text:00007E2C ?Release@CArchiveExtractCallback@@UAGKXZ proc near
.text:00007E2C                                         ; CODE XREF: [thunk]:CArchiveExtractCallback::Release`adjustor{4}' (void)+5j
.text:00007E2C                                         ; [thunk]:CArchiveExtractCallback::Release`adjustor{8}' (void)+5j ...
.text:00007E2C
.text:00007E2C var_10          = dword ptr -10h
.text:00007E2C var_C           = dword ptr -0Ch
.text:00007E2C var_8           = dword ptr -8
.text:00007E2C var_4           = dword ptr -4
.text:00007E2C this            = dword ptr  8
.text:00007E2C
.text:00007E2C                 push    ebp
.text:00007E2D                 mov     ebp, esp
.text:00007E2F                 sub     esp, 10h
.text:00007E32                 mov     eax, 0CCCCCCCCh
.text:00007E37                 mov     [ebp+var_10], eax
.text:00007E3A                 mov     [ebp+var_C], eax
.text:00007E3D                 mov     [ebp+var_8], eax
.text:00007E40                 mov     [ebp+var_4], eax
.text:00007E43                 mov     eax, [ebp+this]
.text:00007E46                 mov     ecx, [eax+10h]
.text:00007E49                 sub     ecx, 1
.text:00007E4C                 mov     [ebp+var_C], ecx
.text:00007E4F                 mov     edx, [ebp+this]
.text:00007E52                 mov     eax, [ebp+var_C]
.text:00007E55                 mov     [edx+10h], eax
.text:00007E58                 cmp     [ebp+var_C], 0
.text:00007E5C                 jz      short loc_7E66
.text:00007E5E                 mov     ecx, [ebp+this]
.text:00007E61                 mov     eax, [ecx+10h]
.text:00007E64                 jmp     short loc_7E90
.text:00007E66 ; ---------------------------------------------------------------------------
.text:00007E66
.text:00007E66 loc_7E66:                               ; CODE XREF: CArchiveExtractCallback::Release(void)+30j
.text:00007E66                 mov     edx, [ebp+this]
.text:00007E69                 mov     [ebp+var_8], edx
.text:00007E6C                 mov     eax, [ebp+var_8]
.text:00007E6F                 mov     [ebp+var_4], eax
.text:00007E72                 cmp     [ebp+var_4], 0
.text:00007E76                 jz      short loc_7E87
.text:00007E78                 push    1
.text:00007E7A                 mov     ecx, [ebp+var_4]
.text:00007E7D                 call    ??_GCArchiveExtractCallback@@QAEPAXI@Z ; CArchiveExtractCallback::`scalar deleting destructor'(uint)
.text:00007E82                 mov     [ebp+var_10], eax
.text:00007E85                 jmp     short loc_7E8E
.text:00007E87 ; ---------------------------------------------------------------------------
.text:00007E87
.text:00007E87 loc_7E87:                               ; CODE XREF: CArchiveExtractCallback::Release(void)+4Aj
.text:00007E87                 mov     [ebp+var_10], 0
.text:00007E8E
.text:00007E8E loc_7E8E:                               ; CODE XREF: CArchiveExtractCallback::Release(void)+59j
.text:00007E8E                 xor     eax, eax
.text:00007E90
.text:00007E90 loc_7E90:                               ; CODE XREF: CArchiveExtractCallback::Release(void)+38j
.text:00007E90                 add     esp, 10h
.text:00007E93                 cmp     ebp, esp
.text:00007E95                 call    __RTC_CheckEsp
.text:00007E9A                 mov     esp, ebp
.text:00007E9C                 pop     ebp
.text:00007E9D                 retn    4
.text:00007E9D ?Release@CArchiveExtractCallback@@UAGKXZ endp
.text:00007E9D
.text:00007E9D _text           ends
.text:00007E9D
.text:00007EA0 ; ===========================================================================
.text:00007EA0
.text:00007EA0 ; Segment type: Pure code
.text:00007EA0 ; Segment permissions: Read/Execute
.text:00007EA0 _text           segment para public 'CODE' use32
.text:00007EA0                 assume cs:_text
.text:00007EA0                 ;org 7EA0h
.text:00007EA0 ; COMDAT (pick any)
.text:00007EA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007EA0
.text:00007EA0 ; =============== S U B R O U T I N E =======================================
.text:00007EA0
.text:00007EA0 ; Attributes: bp-based frame
.text:00007EA0
.text:00007EA0 ; public: void * __thiscall CArchiveExtractCallback::`scalar deleting destructor'(unsigned int)
.text:00007EA0                 public ??_GCArchiveExtractCallback@@QAEPAXI@Z
.text:00007EA0 ??_GCArchiveExtractCallback@@QAEPAXI@Z proc near
.text:00007EA0                                         ; CODE XREF: CArchiveExtractCallback::Release(void)+51p
.text:00007EA0
.text:00007EA0 var_4           = dword ptr -4
.text:00007EA0 arg_0           = dword ptr  8
.text:00007EA0
.text:00007EA0                 push    ebp
.text:00007EA1                 mov     ebp, esp
.text:00007EA3                 push    ecx
.text:00007EA4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007EAB                 mov     [ebp+var_4], ecx
.text:00007EAE                 mov     ecx, [ebp+var_4] ; this
.text:00007EB1                 call    ??1CArchiveExtractCallback@@QAE@XZ ; CArchiveExtractCallback::~CArchiveExtractCallback(void)
.text:00007EB6                 mov     eax, [ebp+arg_0]
.text:00007EB9                 and     eax, 1
.text:00007EBC                 jz      short loc_7ECA
.text:00007EBE                 mov     ecx, [ebp+var_4]
.text:00007EC1                 push    ecx             ; void *
.text:00007EC2                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00007EC7                 add     esp, 4
.text:00007ECA
.text:00007ECA loc_7ECA:                               ; CODE XREF: CArchiveExtractCallback::`scalar deleting destructor'(uint)+1Cj
.text:00007ECA                 mov     eax, [ebp+var_4]
.text:00007ECD                 add     esp, 4
.text:00007ED0                 cmp     ebp, esp
.text:00007ED2                 call    __RTC_CheckEsp
.text:00007ED7                 mov     esp, ebp
.text:00007ED9                 pop     ebp
.text:00007EDA                 retn    4
.text:00007EDA ??_GCArchiveExtractCallback@@QAEPAXI@Z endp
.text:00007EDA
.text:00007EDA ; ---------------------------------------------------------------------------
.text:00007EDD                 align 10h
.text:00007EDD _text           ends
.text:00007EDD
.text:00007EE0 ; ===========================================================================
.text:00007EE0
.text:00007EE0 ; Segment type: Pure code
.text:00007EE0 ; Segment permissions: Read/Execute
.text:00007EE0 _text           segment para public 'CODE' use32
.text:00007EE0                 assume cs:_text
.text:00007EE0                 ;org 7EE0h
.text:00007EE0 ; COMDAT (pick any)
.text:00007EE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007EE0
.text:00007EE0 ; =============== S U B R O U T I N E =======================================
.text:00007EE0
.text:00007EE0 ; Attributes: bp-based frame
.text:00007EE0
.text:00007EE0 ; _DWORD __thiscall CArchiveExtractCallback::~CArchiveExtractCallback(CArchiveExtractCallback *__hidden this)
.text:00007EE0                 public ??1CArchiveExtractCallback@@QAE@XZ
.text:00007EE0 ??1CArchiveExtractCallback@@QAE@XZ proc near
.text:00007EE0                                         ; CODE XREF: CArchiveExtractCallback::`scalar deleting destructor'(uint)+11p
.text:00007EE0
.text:00007EE0 var_10          = dword ptr -10h
.text:00007EE0 var_C           = dword ptr -0Ch
.text:00007EE0 var_4           = dword ptr -4
.text:00007EE0
.text:00007EE0                 push    ebp
.text:00007EE1                 mov     ebp, esp
.text:00007EE3                 push    0FFFFFFFFh
.text:00007EE5                 push    offset __ehhandler$??1CArchiveExtractCallback@@QAE@XZ
.text:00007EEA                 mov     eax, large fs:0
.text:00007EF0                 push    eax
.text:00007EF1                 push    ecx
.text:00007EF2                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00007EF9                 mov     eax, dword ptr ds:___security_cookie
.text:00007EFE                 xor     eax, ebp
.text:00007F00                 push    eax
.text:00007F01                 lea     eax, [ebp+var_C]
.text:00007F04                 mov     large fs:0, eax
.text:00007F0A                 mov     [ebp+var_10], ecx
.text:00007F0D                 mov     [ebp+var_4], 11h
.text:00007F14                 mov     ecx, [ebp+var_10]
.text:00007F17                 add     ecx, 1A8h
.text:00007F1D                 call    ??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ ; CObjectVector<CIndexToPathPair>::~CObjectVector<CIndexToPathPair>(void)
.text:00007F22                 mov     byte ptr [ebp+var_4], 10h
.text:00007F26                 mov     ecx, [ebp+var_10]
.text:00007F29                 add     ecx, 190h       ; this
.text:00007F2F                 call    ??1CHardLinks@@QAE@XZ ; CHardLinks::~CHardLinks(void)
.text:00007F34                 mov     byte ptr [ebp+var_4], 0Fh
.text:00007F38                 mov     ecx, [ebp+var_10]
.text:00007F3B                 add     ecx, 150h
.text:00007F41                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:00007F46                 mov     byte ptr [ebp+var_4], 0Eh
.text:00007F4A                 mov     ecx, [ebp+var_10]
.text:00007F4D                 add     ecx, 144h
.text:00007F53                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00007F58                 mov     byte ptr [ebp+var_4], 0Dh
.text:00007F5C                 mov     ecx, [ebp+var_10]
.text:00007F5F                 add     ecx, 128h
.text:00007F65                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00007F6A                 mov     byte ptr [ebp+var_4], 0Ch
.text:00007F6E                 mov     ecx, [ebp+var_10]
.text:00007F71                 add     ecx, 110h
.text:00007F77                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00007F7C                 mov     byte ptr [ebp+var_4], 0Bh
.text:00007F80                 mov     ecx, [ebp+var_10]
.text:00007F83                 add     ecx, 108h
.text:00007F89                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00007F8E                 mov     byte ptr [ebp+var_4], 0Ah
.text:00007F92                 mov     ecx, [ebp+var_10]
.text:00007F95                 add     ecx, 100h
.text:00007F9B                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00007FA0                 mov     byte ptr [ebp+var_4], 9
.text:00007FA4                 mov     ecx, [ebp+var_10]
.text:00007FA7                 add     ecx, 0A8h ; '¿' ; this
.text:00007FAD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00007FB2                 mov     byte ptr [ebp+var_4], 8
.text:00007FB6                 mov     ecx, [ebp+var_10]
.text:00007FB9                 add     ecx, 68h ; 'h'  ; this
.text:00007FBC                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:00007FC1                 mov     byte ptr [ebp+var_4], 7
.text:00007FC5                 mov     ecx, [ebp+var_10]
.text:00007FC8                 add     ecx, 64h ; 'd'
.text:00007FCB                 call    ??1?$CMyComPtr@UIGetProp@@@@QAE@XZ ; CMyComPtr<IGetProp>::~CMyComPtr<IGetProp>(void)
.text:00007FD0                 mov     byte ptr [ebp+var_4], 6
.text:00007FD4                 mov     ecx, [ebp+var_10]
.text:00007FD7                 add     ecx, 5Ch ; '\'
.text:00007FDA                 call    ??1?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAE@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::~CMyComPtr<IFolderExtractToStreamCallback>(void)
.text:00007FDF                 mov     byte ptr [ebp+var_4], 5
.text:00007FE3                 mov     ecx, [ebp+var_10]
.text:00007FE6                 add     ecx, 48h ; 'H'  ; this
.text:00007FE9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00007FEE                 mov     byte ptr [ebp+var_4], 4
.text:00007FF2                 mov     ecx, [ebp+var_10]
.text:00007FF5                 add     ecx, 3Ch ; '<'  ; this
.text:00007FF8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00007FFD                 mov     byte ptr [ebp+var_4], 3
.text:00008001                 mov     ecx, [ebp+var_10]
.text:00008004                 add     ecx, 38h ; '8'
.text:00008007                 call    ??1?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAE@XZ ; CMyComPtr<IFolderArchiveExtractCallback2>::~CMyComPtr<IFolderArchiveExtractCallback2>(void)
.text:0000800C                 mov     byte ptr [ebp+var_4], 2
.text:00008010                 mov     ecx, [ebp+var_10]
.text:00008013                 add     ecx, 34h ; '4'
.text:00008016                 call    ??1?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallbackMessage>::~CMyComPtr<IArchiveExtractCallbackMessage>(void)
.text:0000801B                 mov     byte ptr [ebp+var_4], 1
.text:0000801F                 mov     ecx, [ebp+var_10]
.text:00008022                 add     ecx, 30h ; '0'
.text:00008025                 call    ??1?$CMyComPtr@UICryptoGetTextPassword@@@@QAE@XZ ; CMyComPtr<ICryptoGetTextPassword>::~CMyComPtr<ICryptoGetTextPassword>(void)
.text:0000802A                 mov     byte ptr [ebp+var_4], 0
.text:0000802E                 mov     ecx, [ebp+var_10]
.text:00008031                 add     ecx, 2Ch ; ','
.text:00008034                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00008039                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008040                 mov     ecx, [ebp+var_10]
.text:00008043                 add     ecx, 28h ; '('
.text:00008046                 call    ??1?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::~CMyComPtr<IFolderArchiveExtractCallback>(void)
.text:0000804B                 mov     ecx, [ebp+var_C]
.text:0000804E                 mov     large fs:0, ecx
.text:00008055                 pop     ecx
.text:00008056                 add     esp, 10h
.text:00008059                 cmp     ebp, esp
.text:0000805B                 call    __RTC_CheckEsp
.text:00008060                 mov     esp, ebp
.text:00008062                 pop     ebp
.text:00008063                 retn
.text:00008063 ??1CArchiveExtractCallback@@QAE@XZ endp
.text:00008063
.text:00008063 _text           ends
.text:00008063
.text$x:00008064 ; ===========================================================================
.text$x:00008064
.text$x:00008064 ; Segment type: Pure code
.text$x:00008064 ; Segment permissions: Read/Execute
.text$x:00008064 _text$x         segment para public 'CODE' use32
.text$x:00008064                 assume cs:_text$x
.text$x:00008064                 ;org 8064h
.text$x:00008064 ; COMDAT (pick associative to section at 7EE0)
.text$x:00008064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008064
.text$x:00008064 ; =============== S U B R O U T I N E =======================================
.text$x:00008064
.text$x:00008064
.text$x:00008064 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$0 proc near
.text$x:00008064                                         ; DATA XREF: .xdata$x:00008188o
.text$x:00008064                 mov     ecx, [ebp-10h]
.text$x:00008067                 add     ecx, 28h ; '('
.text$x:0000806A                 jmp     ??1?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IFolderArchiveExtractCallback>::~CMyComPtr<IFolderArchiveExtractCallback>(void)
.text$x:0000806A __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$0 endp
.text$x:0000806A
.text$x:0000806F
.text$x:0000806F ; =============== S U B R O U T I N E =======================================
.text$x:0000806F
.text$x:0000806F
.text$x:0000806F __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$1 proc near
.text$x:0000806F                                         ; DATA XREF: .xdata$x:00008190o
.text$x:0000806F                 mov     ecx, [ebp-10h]
.text$x:00008072                 add     ecx, 2Ch ; ','
.text$x:00008075                 jmp     ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text$x:00008075 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$1 endp
.text$x:00008075
.text$x:0000807A
.text$x:0000807A ; =============== S U B R O U T I N E =======================================
.text$x:0000807A
.text$x:0000807A
.text$x:0000807A __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$2 proc near
.text$x:0000807A                                         ; DATA XREF: .xdata$x:00008198o
.text$x:0000807A                 mov     ecx, [ebp-10h]
.text$x:0000807D                 add     ecx, 30h ; '0'
.text$x:00008080                 jmp     ??1?$CMyComPtr@UICryptoGetTextPassword@@@@QAE@XZ ; CMyComPtr<ICryptoGetTextPassword>::~CMyComPtr<ICryptoGetTextPassword>(void)
.text$x:00008080 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$2 endp
.text$x:00008080
.text$x:00008085
.text$x:00008085 ; =============== S U B R O U T I N E =======================================
.text$x:00008085
.text$x:00008085
.text$x:00008085 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$3 proc near
.text$x:00008085                                         ; DATA XREF: .xdata$x:000081A0o
.text$x:00008085                 mov     ecx, [ebp-10h]
.text$x:00008088                 add     ecx, 34h ; '4'
.text$x:0000808B                 jmp     ??1?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallbackMessage>::~CMyComPtr<IArchiveExtractCallbackMessage>(void)
.text$x:0000808B __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$3 endp
.text$x:0000808B
.text$x:00008090
.text$x:00008090 ; =============== S U B R O U T I N E =======================================
.text$x:00008090
.text$x:00008090
.text$x:00008090 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$4 proc near
.text$x:00008090                                         ; DATA XREF: .xdata$x:000081A8o
.text$x:00008090                 mov     ecx, [ebp-10h]
.text$x:00008093                 add     ecx, 38h ; '8'
.text$x:00008096                 jmp     ??1?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAE@XZ ; CMyComPtr<IFolderArchiveExtractCallback2>::~CMyComPtr<IFolderArchiveExtractCallback2>(void)
.text$x:00008096 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$4 endp
.text$x:00008096
.text$x:0000809B
.text$x:0000809B ; =============== S U B R O U T I N E =======================================
.text$x:0000809B
.text$x:0000809B
.text$x:0000809B __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$5 proc near
.text$x:0000809B                                         ; DATA XREF: .xdata$x:000081B0o
.text$x:0000809B                 mov     ecx, [ebp-10h]
.text$x:0000809E                 add     ecx, 3Ch ; '<'  ; this
.text$x:000080A1                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000080A1 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$5 endp
.text$x:000080A1
.text$x:000080A6
.text$x:000080A6 ; =============== S U B R O U T I N E =======================================
.text$x:000080A6
.text$x:000080A6
.text$x:000080A6 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$6 proc near
.text$x:000080A6                                         ; DATA XREF: .xdata$x:000081B8o
.text$x:000080A6                 mov     ecx, [ebp-10h]
.text$x:000080A9                 add     ecx, 48h ; 'H'  ; this
.text$x:000080AC                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000080AC __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$6 endp
.text$x:000080AC
.text$x:000080B1
.text$x:000080B1 ; =============== S U B R O U T I N E =======================================
.text$x:000080B1
.text$x:000080B1
.text$x:000080B1 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$7 proc near
.text$x:000080B1                                         ; DATA XREF: .xdata$x:000081C0o
.text$x:000080B1                 mov     ecx, [ebp-10h]
.text$x:000080B4                 add     ecx, 5Ch ; '\'
.text$x:000080B7                 jmp     ??1?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAE@XZ ; CMyComPtr<IFolderExtractToStreamCallback>::~CMyComPtr<IFolderExtractToStreamCallback>(void)
.text$x:000080B7 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$7 endp
.text$x:000080B7
.text$x:000080BC
.text$x:000080BC ; =============== S U B R O U T I N E =======================================
.text$x:000080BC
.text$x:000080BC
.text$x:000080BC __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$8 proc near
.text$x:000080BC                                         ; DATA XREF: .xdata$x:000081C8o
.text$x:000080BC                 mov     ecx, [ebp-10h]
.text$x:000080BF                 add     ecx, 64h ; 'd'
.text$x:000080C2                 jmp     ??1?$CMyComPtr@UIGetProp@@@@QAE@XZ ; CMyComPtr<IGetProp>::~CMyComPtr<IGetProp>(void)
.text$x:000080C2 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$8 endp
.text$x:000080C2
.text$x:000080C7
.text$x:000080C7 ; =============== S U B R O U T I N E =======================================
.text$x:000080C7
.text$x:000080C7
.text$x:000080C7 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$9 proc near
.text$x:000080C7                                         ; DATA XREF: .xdata$x:000081D0o
.text$x:000080C7                 mov     ecx, [ebp-10h]
.text$x:000080CA                 add     ecx, 68h ; 'h'  ; this
.text$x:000080CD                 jmp     ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text$x:000080CD __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$9 endp
.text$x:000080CD
.text$x:000080D2
.text$x:000080D2 ; =============== S U B R O U T I N E =======================================
.text$x:000080D2
.text$x:000080D2
.text$x:000080D2 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$10 proc near
.text$x:000080D2                                         ; DATA XREF: .xdata$x:000081D8o
.text$x:000080D2                 mov     ecx, [ebp-10h]
.text$x:000080D5                 add     ecx, 0A8h ; '¿' ; this
.text$x:000080DB                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000080DB __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$10 endp
.text$x:000080DB
.text$x:000080E0
.text$x:000080E0 ; =============== S U B R O U T I N E =======================================
.text$x:000080E0
.text$x:000080E0
.text$x:000080E0 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$11 proc near
.text$x:000080E0                                         ; DATA XREF: .xdata$x:000081E0o
.text$x:000080E0                 mov     ecx, [ebp-10h]
.text$x:000080E3                 add     ecx, 100h
.text$x:000080E9                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:000080E9 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$11 endp
.text$x:000080E9
.text$x:000080EE
.text$x:000080EE ; =============== S U B R O U T I N E =======================================
.text$x:000080EE
.text$x:000080EE
.text$x:000080EE __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$12 proc near
.text$x:000080EE                                         ; DATA XREF: .xdata$x:000081E8o
.text$x:000080EE                 mov     ecx, [ebp-10h]
.text$x:000080F1                 add     ecx, 108h
.text$x:000080F7                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:000080F7 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$12 endp
.text$x:000080F7
.text$x:000080FC
.text$x:000080FC ; =============== S U B R O U T I N E =======================================
.text$x:000080FC
.text$x:000080FC
.text$x:000080FC __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$13 proc near
.text$x:000080FC                                         ; DATA XREF: .xdata$x:000081F0o
.text$x:000080FC                 mov     ecx, [ebp-10h]
.text$x:000080FF                 add     ecx, 110h
.text$x:00008105                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00008105 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$13 endp
.text$x:00008105
.text$x:0000810A
.text$x:0000810A ; =============== S U B R O U T I N E =======================================
.text$x:0000810A
.text$x:0000810A
.text$x:0000810A __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$14 proc near
.text$x:0000810A                                         ; DATA XREF: .xdata$x:000081F8o
.text$x:0000810A                 mov     ecx, [ebp-10h]
.text$x:0000810D                 add     ecx, 128h
.text$x:00008113                 jmp     ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text$x:00008113 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$14 endp
.text$x:00008113
.text$x:00008118
.text$x:00008118 ; =============== S U B R O U T I N E =======================================
.text$x:00008118
.text$x:00008118
.text$x:00008118 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$15 proc near
.text$x:00008118                                         ; DATA XREF: .xdata$x:00008200o
.text$x:00008118                 mov     ecx, [ebp-10h]
.text$x:0000811B                 add     ecx, 144h
.text$x:00008121                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00008121 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$15 endp
.text$x:00008121
.text$x:00008126
.text$x:00008126 ; =============== S U B R O U T I N E =======================================
.text$x:00008126
.text$x:00008126
.text$x:00008126 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$16 proc near
.text$x:00008126                                         ; DATA XREF: .xdata$x:00008208o
.text$x:00008126                 mov     ecx, [ebp-10h]
.text$x:00008129                 add     ecx, 150h
.text$x:0000812F                 jmp     ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text$x:0000812F __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$16 endp
.text$x:0000812F
.text$x:00008134
.text$x:00008134 ; =============== S U B R O U T I N E =======================================
.text$x:00008134
.text$x:00008134
.text$x:00008134 __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$17 proc near
.text$x:00008134                                         ; DATA XREF: .xdata$x:00008210o
.text$x:00008134                 mov     ecx, [ebp-10h]
.text$x:00008137                 add     ecx, 190h       ; this
.text$x:0000813D                 jmp     ??1CHardLinks@@QAE@XZ ; CHardLinks::~CHardLinks(void)
.text$x:0000813D __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$17 endp
.text$x:0000813D
.text$x:00008142
.text$x:00008142 ; =============== S U B R O U T I N E =======================================
.text$x:00008142
.text$x:00008142
.text$x:00008142 __ehhandler$??1CArchiveExtractCallback@@QAE@XZ proc near
.text$x:00008142                                         ; DATA XREF: CArchiveExtractCallback::~CArchiveExtractCallback(void)+5o
.text$x:00008142
.text$x:00008142 arg_4           = dword ptr  8
.text$x:00008142
.text$x:00008142                 mov     edx, [esp+arg_4]
.text$x:00008146                 lea     eax, [edx+0Ch]
.text$x:00008149                 mov     ecx, [edx-8]
.text$x:0000814C                 xor     ecx, eax
.text$x:0000814E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008153                 mov     eax, offset __ehfuncinfo$??1CArchiveExtractCallback@@QAE@XZ
.text$x:00008158                 jmp     ___CxxFrameHandler3
.text$x:00008158 __ehhandler$??1CArchiveExtractCallback@@QAE@XZ endp
.text$x:00008158
.text$x:00008158 ; ---------------------------------------------------------------------------
.text$x:0000815D                 align 10h
.text$x:0000815D _text$x         ends
.text$x:0000815D
.xdata$x:00008160 ; ===========================================================================
.xdata$x:00008160
.xdata$x:00008160 ; Segment type: Pure data
.xdata$x:00008160 ; Segment permissions: Read
.xdata$x:00008160 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008160                 assume cs:_xdata$x
.xdata$x:00008160                 ;org 8160h
.xdata$x:00008160 ; COMDAT (pick associative to section at 7EE0)
.xdata$x:00008160 __ehfuncinfo$??1CArchiveExtractCallback@@QAE@XZ db  22h ; "
.xdata$x:00008160                                         ; DATA XREF: __ehhandler$??1CArchiveExtractCallback@@QAE@XZ+11o
.xdata$x:00008161                 db    5
.xdata$x:00008162                 db  93h ; ô
.xdata$x:00008163                 db  19h
.xdata$x:00008164                 db  12h
.xdata$x:00008165                 db    0
.xdata$x:00008166                 db    0
.xdata$x:00008167                 db    0
.xdata$x:00008168                 dd offset __unwindtable$??1CArchiveExtractCallback@@QAE@XZ
.xdata$x:0000816C                 align 20h
.xdata$x:00008180                 db    1
.xdata$x:00008181                 db    0
.xdata$x:00008182                 db    0
.xdata$x:00008183                 db    0
.xdata$x:00008184 __unwindtable$??1CArchiveExtractCallback@@QAE@XZ db 0FFh
.xdata$x:00008184                                         ; DATA XREF: .xdata$x:00008168o
.xdata$x:00008185                 db 0FFh
.xdata$x:00008186                 db 0FFh
.xdata$x:00008187                 db 0FFh
.xdata$x:00008188                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$0
.xdata$x:0000818C                 align 10h
.xdata$x:00008190                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$1
.xdata$x:00008194                 db    1
.xdata$x:00008195                 db    0
.xdata$x:00008196                 db    0
.xdata$x:00008197                 db    0
.xdata$x:00008198                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$2
.xdata$x:0000819C                 db    2
.xdata$x:0000819D                 db    0
.xdata$x:0000819E                 db    0
.xdata$x:0000819F                 db    0
.xdata$x:000081A0                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$3
.xdata$x:000081A4                 db    3
.xdata$x:000081A5                 db    0
.xdata$x:000081A6                 db    0
.xdata$x:000081A7                 db    0
.xdata$x:000081A8                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$4
.xdata$x:000081AC                 db    4
.xdata$x:000081AD                 db    0
.xdata$x:000081AE                 db    0
.xdata$x:000081AF                 db    0
.xdata$x:000081B0                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$5
.xdata$x:000081B4                 db    5
.xdata$x:000081B5                 db    0
.xdata$x:000081B6                 db    0
.xdata$x:000081B7                 db    0
.xdata$x:000081B8                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$6
.xdata$x:000081BC                 db    6
.xdata$x:000081BD                 db    0
.xdata$x:000081BE                 db    0
.xdata$x:000081BF                 db    0
.xdata$x:000081C0                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$7
.xdata$x:000081C4                 db    7
.xdata$x:000081C5                 db    0
.xdata$x:000081C6                 db    0
.xdata$x:000081C7                 db    0
.xdata$x:000081C8                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$8
.xdata$x:000081CC                 db    8
.xdata$x:000081CD                 db    0
.xdata$x:000081CE                 db    0
.xdata$x:000081CF                 db    0
.xdata$x:000081D0                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$9
.xdata$x:000081D4                 db    9
.xdata$x:000081D5                 db    0
.xdata$x:000081D6                 db    0
.xdata$x:000081D7                 db    0
.xdata$x:000081D8                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$10
.xdata$x:000081DC                 db  0Ah
.xdata$x:000081DD                 db    0
.xdata$x:000081DE                 db    0
.xdata$x:000081DF                 db    0
.xdata$x:000081E0                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$11
.xdata$x:000081E4                 db  0Bh
.xdata$x:000081E5                 db    0
.xdata$x:000081E6                 db    0
.xdata$x:000081E7                 db    0
.xdata$x:000081E8                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$12
.xdata$x:000081EC                 db  0Ch
.xdata$x:000081ED                 db    0
.xdata$x:000081EE                 db    0
.xdata$x:000081EF                 db    0
.xdata$x:000081F0                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$13
.xdata$x:000081F4                 db  0Dh
.xdata$x:000081F5                 db    0
.xdata$x:000081F6                 db    0
.xdata$x:000081F7                 db    0
.xdata$x:000081F8                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$14
.xdata$x:000081FC                 db  0Eh
.xdata$x:000081FD                 db    0
.xdata$x:000081FE                 db    0
.xdata$x:000081FF                 db    0
.xdata$x:00008200                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$15
.xdata$x:00008204                 db  0Fh
.xdata$x:00008205                 db    0
.xdata$x:00008206                 db    0
.xdata$x:00008207                 db    0
.xdata$x:00008208                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$16
.xdata$x:0000820C                 db  10h
.xdata$x:0000820D                 db    0
.xdata$x:0000820E                 db    0
.xdata$x:0000820F                 db    0
.xdata$x:00008210                 dd offset __unwindfunclet$??1CArchiveExtractCallback@@QAE@XZ$17
.xdata$x:00008210 _xdata$x        ends
.xdata$x:00008210
.text:00008214 ; ===========================================================================
.text:00008214
.text:00008214 ; Segment type: Pure code
.text:00008214 ; Segment permissions: Read/Execute
.text:00008214 _text           segment para public 'CODE' use32
.text:00008214                 assume cs:_text
.text:00008214                 ;org 8214h
.text:00008214 ; COMDAT (pick any)
.text:00008214                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008214
.text:00008214 ; =============== S U B R O U T I N E =======================================
.text:00008214
.text:00008214 ; Attributes: bp-based frame
.text:00008214
.text:00008214 ; _DWORD __thiscall CReadArcItem::~CReadArcItem(CReadArcItem *__hidden this)
.text:00008214                 public ??1CReadArcItem@@QAE@XZ
.text:00008214 ??1CReadArcItem@@QAE@XZ proc near       ; CODE XREF: CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+A3p
.text:00008214                                         ; CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+111p ...
.text:00008214
.text:00008214 var_10          = dword ptr -10h
.text:00008214 var_C           = dword ptr -0Ch
.text:00008214 var_4           = dword ptr -4
.text:00008214
.text:00008214                 push    ebp
.text:00008215                 mov     ebp, esp
.text:00008217                 push    0FFFFFFFFh
.text:00008219                 push    offset __ehhandler$??1CReadArcItem@@QAE@XZ
.text:0000821E                 mov     eax, large fs:0
.text:00008224                 push    eax
.text:00008225                 push    ecx
.text:00008226                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000822D                 mov     eax, dword ptr ds:___security_cookie
.text:00008232                 xor     eax, ebp
.text:00008234                 push    eax
.text:00008235                 lea     eax, [ebp+var_C]
.text:00008238                 mov     large fs:0, eax
.text:0000823E                 mov     [ebp+var_10], ecx
.text:00008241                 mov     [ebp+var_4], 2
.text:00008248                 mov     ecx, [ebp+var_10]
.text:0000824B                 add     ecx, 24h ; '$'  ; this
.text:0000824E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00008253                 mov     byte ptr [ebp+var_4], 1
.text:00008257                 mov     ecx, [ebp+var_10]
.text:0000825A                 add     ecx, 18h        ; this
.text:0000825D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00008262                 mov     byte ptr [ebp+var_4], 0
.text:00008266                 mov     ecx, [ebp+var_10]
.text:00008269                 add     ecx, 0Ch
.text:0000826C                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00008271                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008278                 mov     ecx, [ebp+var_10] ; this
.text:0000827B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00008280                 mov     ecx, [ebp+var_C]
.text:00008283                 mov     large fs:0, ecx
.text:0000828A                 pop     ecx
.text:0000828B                 add     esp, 10h
.text:0000828E                 cmp     ebp, esp
.text:00008290                 call    __RTC_CheckEsp
.text:00008295                 mov     esp, ebp
.text:00008297                 pop     ebp
.text:00008298                 retn
.text:00008298 ??1CReadArcItem@@QAE@XZ endp
.text:00008298
.text:00008298 ; ---------------------------------------------------------------------------
.text:00008299                 align 4
.text:00008299 _text           ends
.text:00008299
.text$x:0000829C ; ===========================================================================
.text$x:0000829C
.text$x:0000829C ; Segment type: Pure code
.text$x:0000829C ; Segment permissions: Read/Execute
.text$x:0000829C _text$x         segment para public 'CODE' use32
.text$x:0000829C                 assume cs:_text$x
.text$x:0000829C                 ;org 829Ch
.text$x:0000829C ; COMDAT (pick associative to section at 8214)
.text$x:0000829C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000829C
.text$x:0000829C ; =============== S U B R O U T I N E =======================================
.text$x:0000829C
.text$x:0000829C
.text$x:0000829C __unwindfunclet$??1CReadArcItem@@QAE@XZ$0 proc near
.text$x:0000829C                                         ; DATA XREF: .xdata$x:000082DCo
.text$x:0000829C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000829F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000829F __unwindfunclet$??1CReadArcItem@@QAE@XZ$0 endp
.text$x:0000829F
.text$x:000082A4
.text$x:000082A4 ; =============== S U B R O U T I N E =======================================
.text$x:000082A4
.text$x:000082A4
.text$x:000082A4 __unwindfunclet$??1CReadArcItem@@QAE@XZ$1 proc near
.text$x:000082A4                                         ; DATA XREF: .xdata$x:000082E4o
.text$x:000082A4                 mov     ecx, [ebp-10h]
.text$x:000082A7                 add     ecx, 0Ch
.text$x:000082AA                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:000082AA __unwindfunclet$??1CReadArcItem@@QAE@XZ$1 endp
.text$x:000082AA
.text$x:000082AF
.text$x:000082AF ; =============== S U B R O U T I N E =======================================
.text$x:000082AF
.text$x:000082AF
.text$x:000082AF __unwindfunclet$??1CReadArcItem@@QAE@XZ$2 proc near
.text$x:000082AF                                         ; DATA XREF: .xdata$x:000082ECo
.text$x:000082AF                 mov     ecx, [ebp-10h]
.text$x:000082B2                 add     ecx, 18h        ; this
.text$x:000082B5                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000082B5 __unwindfunclet$??1CReadArcItem@@QAE@XZ$2 endp
.text$x:000082B5
.text$x:000082BA
.text$x:000082BA ; =============== S U B R O U T I N E =======================================
.text$x:000082BA
.text$x:000082BA
.text$x:000082BA __ehhandler$??1CReadArcItem@@QAE@XZ proc near
.text$x:000082BA                                         ; DATA XREF: CReadArcItem::~CReadArcItem(void)+5o
.text$x:000082BA
.text$x:000082BA arg_4           = dword ptr  8
.text$x:000082BA
.text$x:000082BA                 mov     edx, [esp+arg_4]
.text$x:000082BE                 lea     eax, [edx+0Ch]
.text$x:000082C1                 mov     ecx, [edx-8]
.text$x:000082C4                 xor     ecx, eax
.text$x:000082C6                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000082CB                 mov     eax, offset __ehfuncinfo$??1CReadArcItem@@QAE@XZ
.text$x:000082D0                 jmp     ___CxxFrameHandler3
.text$x:000082D0 __ehhandler$??1CReadArcItem@@QAE@XZ endp
.text$x:000082D0
.text$x:000082D0 ; ---------------------------------------------------------------------------
.text$x:000082D5                 align 4
.text$x:000082D5 _text$x         ends
.text$x:000082D5
.xdata$x:000082D8 ; ===========================================================================
.xdata$x:000082D8
.xdata$x:000082D8 ; Segment type: Pure data
.xdata$x:000082D8 ; Segment permissions: Read
.xdata$x:000082D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000082D8                 assume cs:_xdata$x
.xdata$x:000082D8                 ;org 82D8h
.xdata$x:000082D8 ; COMDAT (pick associative to section at 8214)
.xdata$x:000082D8 __unwindtable$??1CReadArcItem@@QAE@XZ db 0FFh
.xdata$x:000082D8                                         ; DATA XREF: .xdata$x:000082F8o
.xdata$x:000082D9                 db 0FFh
.xdata$x:000082DA                 db 0FFh
.xdata$x:000082DB                 db 0FFh
.xdata$x:000082DC                 dd offset __unwindfunclet$??1CReadArcItem@@QAE@XZ$0
.xdata$x:000082E0                 db    0
.xdata$x:000082E1                 db    0
.xdata$x:000082E2                 db    0
.xdata$x:000082E3                 db    0
.xdata$x:000082E4                 dd offset __unwindfunclet$??1CReadArcItem@@QAE@XZ$1
.xdata$x:000082E8                 db    1
.xdata$x:000082E9                 db    0
.xdata$x:000082EA                 db    0
.xdata$x:000082EB                 db    0
.xdata$x:000082EC                 dd offset __unwindfunclet$??1CReadArcItem@@QAE@XZ$2
.xdata$x:000082F0 __ehfuncinfo$??1CReadArcItem@@QAE@XZ db  22h ; "
.xdata$x:000082F0                                         ; DATA XREF: __ehhandler$??1CReadArcItem@@QAE@XZ+11o
.xdata$x:000082F1                 db    5
.xdata$x:000082F2                 db  93h ; ô
.xdata$x:000082F3                 db  19h
.xdata$x:000082F4                 db    3
.xdata$x:000082F5                 db    0
.xdata$x:000082F6                 db    0
.xdata$x:000082F7                 db    0
.xdata$x:000082F8                 dd offset __unwindtable$??1CReadArcItem@@QAE@XZ
.xdata$x:000082FC                 db    0
.xdata$x:000082FD                 db    0
.xdata$x:000082FE                 db    0
.xdata$x:000082FF                 db    0
.xdata$x:00008300                 db    0
.xdata$x:00008301                 db    0
.xdata$x:00008302                 db    0
.xdata$x:00008303                 db    0
.xdata$x:00008304                 db    0
.xdata$x:00008305                 db    0
.xdata$x:00008306                 db    0
.xdata$x:00008307                 db    0
.xdata$x:00008308                 db    0
.xdata$x:00008309                 db    0
.xdata$x:0000830A                 db    0
.xdata$x:0000830B                 db    0
.xdata$x:0000830C                 db    0
.xdata$x:0000830D                 db    0
.xdata$x:0000830E                 db    0
.xdata$x:0000830F                 db    0
.xdata$x:00008310                 db    1
.xdata$x:00008311                 db    0
.xdata$x:00008312                 db    0
.xdata$x:00008313                 db    0
.xdata$x:00008313 _xdata$x        ends
.xdata$x:00008313
.text:00008314 ; ===========================================================================
.text:00008314
.text:00008314 ; Segment type: Pure code
.text:00008314 ; Segment permissions: Read/Execute
.text:00008314 _text           segment para public 'CODE' use32
.text:00008314                 assume cs:_text
.text:00008314                 ;org 8314h
.text:00008314 ; COMDAT (pick any)
.text:00008314                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008314
.text:00008314 ; =============== S U B R O U T I N E =======================================
.text:00008314
.text:00008314 ; Attributes: bp-based frame
.text:00008314
.text:00008314 ; _DWORD __thiscall CHardLinks::~CHardLinks(CHardLinks *__hidden this)
.text:00008314                 public ??1CHardLinks@@QAE@XZ
.text:00008314 ??1CHardLinks@@QAE@XZ proc near         ; CODE XREF: __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$17+9j
.text:00008314                                         ; CArchiveExtractCallback::~CArchiveExtractCallback(void)+4Fp ...
.text:00008314
.text:00008314 var_10          = dword ptr -10h
.text:00008314 var_C           = dword ptr -0Ch
.text:00008314 var_4           = dword ptr -4
.text:00008314
.text:00008314                 push    ebp
.text:00008315                 mov     ebp, esp
.text:00008317                 push    0FFFFFFFFh
.text:00008319                 push    offset __ehhandler$??1CHardLinks@@QAE@XZ
.text:0000831E                 mov     eax, large fs:0
.text:00008324                 push    eax
.text:00008325                 push    ecx
.text:00008326                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000832D                 mov     eax, dword ptr ds:___security_cookie
.text:00008332                 xor     eax, ebp
.text:00008334                 push    eax
.text:00008335                 lea     eax, [ebp+var_C]
.text:00008338                 mov     large fs:0, eax
.text:0000833E                 mov     [ebp+var_10], ecx
.text:00008341                 mov     [ebp+var_4], 0
.text:00008348                 mov     ecx, [ebp+var_10]
.text:0000834B                 add     ecx, 0Ch
.text:0000834E                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00008353                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000835A                 mov     ecx, [ebp+var_10]
.text:0000835D                 call    ??1?$CRecordVector@UCHardLinkNode@@@@QAE@XZ ; CRecordVector<CHardLinkNode>::~CRecordVector<CHardLinkNode>(void)
.text:00008362                 mov     ecx, [ebp+var_C]
.text:00008365                 mov     large fs:0, ecx
.text:0000836C                 pop     ecx
.text:0000836D                 add     esp, 10h
.text:00008370                 cmp     ebp, esp
.text:00008372                 call    __RTC_CheckEsp
.text:00008377                 mov     esp, ebp
.text:00008379                 pop     ebp
.text:0000837A                 retn
.text:0000837A ??1CHardLinks@@QAE@XZ endp
.text:0000837A
.text:0000837A ; ---------------------------------------------------------------------------
.text:0000837B                 align 4
.text:0000837B _text           ends
.text:0000837B
.text$x:0000837C ; ===========================================================================
.text$x:0000837C
.text$x:0000837C ; Segment type: Pure code
.text$x:0000837C ; Segment permissions: Read/Execute
.text$x:0000837C _text$x         segment para public 'CODE' use32
.text$x:0000837C                 assume cs:_text$x
.text$x:0000837C                 ;org 837Ch
.text$x:0000837C ; COMDAT (pick associative to section at 8314)
.text$x:0000837C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000837C
.text$x:0000837C ; =============== S U B R O U T I N E =======================================
.text$x:0000837C
.text$x:0000837C
.text$x:0000837C __unwindfunclet$??1CHardLinks@@QAE@XZ$0 proc near
.text$x:0000837C                                         ; DATA XREF: .xdata$x:000083A4o
.text$x:0000837C                 mov     ecx, [ebp-10h]
.text$x:0000837F                 jmp     ??1?$CRecordVector@UCHardLinkNode@@@@QAE@XZ ; CRecordVector<CHardLinkNode>::~CRecordVector<CHardLinkNode>(void)
.text$x:0000837F __unwindfunclet$??1CHardLinks@@QAE@XZ$0 endp
.text$x:0000837F
.text$x:00008384
.text$x:00008384 ; =============== S U B R O U T I N E =======================================
.text$x:00008384
.text$x:00008384
.text$x:00008384 __ehhandler$??1CHardLinks@@QAE@XZ proc near
.text$x:00008384                                         ; DATA XREF: CHardLinks::~CHardLinks(void)+5o
.text$x:00008384
.text$x:00008384 arg_4           = dword ptr  8
.text$x:00008384
.text$x:00008384                 mov     edx, [esp+arg_4]
.text$x:00008388                 lea     eax, [edx+0Ch]
.text$x:0000838B                 mov     ecx, [edx-8]
.text$x:0000838E                 xor     ecx, eax
.text$x:00008390                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008395                 mov     eax, offset __ehfuncinfo$??1CHardLinks@@QAE@XZ
.text$x:0000839A                 jmp     ___CxxFrameHandler3
.text$x:0000839A __ehhandler$??1CHardLinks@@QAE@XZ endp
.text$x:0000839A
.text$x:0000839A ; ---------------------------------------------------------------------------
.text$x:0000839F                 align 10h
.text$x:0000839F _text$x         ends
.text$x:0000839F
.xdata$x:000083A0 ; ===========================================================================
.xdata$x:000083A0
.xdata$x:000083A0 ; Segment type: Pure data
.xdata$x:000083A0 ; Segment permissions: Read
.xdata$x:000083A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000083A0                 assume cs:_xdata$x
.xdata$x:000083A0                 ;org 83A0h
.xdata$x:000083A0 ; COMDAT (pick associative to section at 8314)
.xdata$x:000083A0 __unwindtable$??1CHardLinks@@QAE@XZ db 0FFh
.xdata$x:000083A0                                         ; DATA XREF: .xdata$x:000083B0o
.xdata$x:000083A1                 db 0FFh
.xdata$x:000083A2                 db 0FFh
.xdata$x:000083A3                 db 0FFh
.xdata$x:000083A4                 dd offset __unwindfunclet$??1CHardLinks@@QAE@XZ$0
.xdata$x:000083A8 __ehfuncinfo$??1CHardLinks@@QAE@XZ db  22h ; "
.xdata$x:000083A8                                         ; DATA XREF: __ehhandler$??1CHardLinks@@QAE@XZ+11o
.xdata$x:000083A9                 db    5
.xdata$x:000083AA                 db  93h ; ô
.xdata$x:000083AB                 db  19h
.xdata$x:000083AC                 db    1
.xdata$x:000083AD                 db    0
.xdata$x:000083AE                 db    0
.xdata$x:000083AF                 db    0
.xdata$x:000083B0                 dd offset __unwindtable$??1CHardLinks@@QAE@XZ
.xdata$x:000083B4                 db    0
.xdata$x:000083B5                 db    0
.xdata$x:000083B6                 db    0
.xdata$x:000083B7                 db    0
.xdata$x:000083B8                 db    0
.xdata$x:000083B9                 db    0
.xdata$x:000083BA                 db    0
.xdata$x:000083BB                 db    0
.xdata$x:000083BC                 db    0
.xdata$x:000083BD                 db    0
.xdata$x:000083BE                 db    0
.xdata$x:000083BF                 db    0
.xdata$x:000083C0                 db    0
.xdata$x:000083C1                 db    0
.xdata$x:000083C2                 db    0
.xdata$x:000083C3                 db    0
.xdata$x:000083C4                 db    0
.xdata$x:000083C5                 db    0
.xdata$x:000083C6                 db    0
.xdata$x:000083C7                 db    0
.xdata$x:000083C8                 db    1
.xdata$x:000083C9                 db    0
.xdata$x:000083CA                 db    0
.xdata$x:000083CB                 db    0
.xdata$x:000083CB _xdata$x        ends
.xdata$x:000083CB
.text:000083CC ; ===========================================================================
.text:000083CC
.text:000083CC ; Segment type: Pure code
.text:000083CC ; Segment permissions: Read/Execute
.text:000083CC _text           segment para public 'CODE' use32
.text:000083CC                 assume cs:_text
.text:000083CC                 ;org 83CCh
.text:000083CC ; COMDAT (pick any)
.text:000083CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000083CC
.text:000083CC ; =============== S U B R O U T I N E =======================================
.text:000083CC
.text:000083CC ; Attributes: bp-based frame
.text:000083CC
.text:000083CC ; _DWORD __thiscall IArchiveExtractCallback::IArchiveExtractCallback(IArchiveExtractCallback *__hidden this)
.text:000083CC                 public ??0IArchiveExtractCallback@@QAE@XZ
.text:000083CC ??0IArchiveExtractCallback@@QAE@XZ proc near
.text:000083CC                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+3Cp
.text:000083CC
.text:000083CC var_4           = dword ptr -4
.text:000083CC
.text:000083CC                 push    ebp
.text:000083CD                 mov     ebp, esp
.text:000083CF                 push    ecx
.text:000083D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000083D7                 mov     [ebp+var_4], ecx
.text:000083DA                 mov     ecx, [ebp+var_4] ; this
.text:000083DD                 call    ??0IProgress@@QAE@XZ ; IProgress::IProgress(void)
.text:000083E2                 mov     eax, [ebp+var_4]
.text:000083E5                 mov     dword ptr [eax], offset ??_7IArchiveExtractCallback@@6B@ ; const IArchiveExtractCallback::`vftable'
.text:000083EB                 mov     eax, [ebp+var_4]
.text:000083EE                 add     esp, 4
.text:000083F1                 cmp     ebp, esp
.text:000083F3                 call    __RTC_CheckEsp
.text:000083F8                 mov     esp, ebp
.text:000083FA                 pop     ebp
.text:000083FB                 retn
.text:000083FB ??0IArchiveExtractCallback@@QAE@XZ endp
.text:000083FB
.text:000083FB _text           ends
.text:000083FB
.rdata:000083FC ; ===========================================================================
.rdata:000083FC
.rdata:000083FC ; Segment type: Pure data
.rdata:000083FC ; Segment permissions: Read
.rdata:000083FC _rdata          segment dword public 'DATA' use32
.rdata:000083FC                 assume cs:_rdata
.rdata:000083FC                 ;org 83FCh
.rdata:000083FC ; COMDAT (pick largest)
.rdata:000083FC                 dd offset ??_R4IArchiveExtractCallback@@6B@ ; const IArchiveExtractCallback::`RTTI Complete Object Locator'
.rdata:00008400                 public ??_7IArchiveExtractCallback@@6B@
.rdata:00008400 ; const IArchiveExtractCallback::`vftable'
.rdata:00008400 ??_7IArchiveExtractCallback@@6B@ dd offset __purecall
.rdata:00008400                                         ; DATA XREF: IArchiveExtractCallback::IArchiveExtractCallback(void)+19o
.rdata:00008404                 dd offset __purecall
.rdata:00008408                 dd offset __purecall
.rdata:0000840C                 dd offset __purecall
.rdata:00008410                 dd offset __purecall
.rdata:00008414                 dd offset __purecall
.rdata:00008418                 dd offset __purecall
.rdata:0000841C                 dd offset __purecall
.rdata:0000841C _rdata          ends
.rdata:0000841C
.rdata$r:00008420 ; ===========================================================================
.rdata$r:00008420
.rdata$r:00008420 ; Segment type: Pure data
.rdata$r:00008420 ; Segment permissions: Read
.rdata$r:00008420 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008420                 assume cs:_rdata$r
.rdata$r:00008420                 ;org 8420h
.rdata$r:00008420 ; COMDAT (pick any)
.rdata$r:00008420                 public ??_R4IArchiveExtractCallback@@6B@
.rdata$r:00008420 ; const IArchiveExtractCallback::`RTTI Complete Object Locator'
.rdata$r:00008420 ??_R4IArchiveExtractCallback@@6B@ db    0 ; DATA XREF: .rdata:000083FCo
.rdata$r:00008421                 db    0
.rdata$r:00008422                 db    0
.rdata$r:00008423                 db    0
.rdata$r:00008424                 db    0
.rdata$r:00008425                 db    0
.rdata$r:00008426                 db    0
.rdata$r:00008427                 db    0
.rdata$r:00008428                 db    0
.rdata$r:00008429                 db    0
.rdata$r:0000842A                 db    0
.rdata$r:0000842B                 db    0
.rdata$r:0000842C                 dd offset ??_R0?AUIArchiveExtractCallback@@@8 ; IArchiveExtractCallback `RTTI Type Descriptor'
.rdata$r:00008430                 dd offset ??_R3IArchiveExtractCallback@@8 ; IArchiveExtractCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008430 _rdata$r        ends
.rdata$r:00008430
.text:00008434 ; ===========================================================================
.text:00008434
.text:00008434 ; Segment type: Pure code
.text:00008434 ; Segment permissions: Read/Execute
.text:00008434 _text           segment para public 'CODE' use32
.text:00008434                 assume cs:_text
.text:00008434                 ;org 8434h
.text:00008434 ; COMDAT (pick any)
.text:00008434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008434
.text:00008434 ; =============== S U B R O U T I N E =======================================
.text:00008434
.text:00008434 ; Attributes: bp-based frame
.text:00008434
.text:00008434 ; _DWORD __thiscall IArchiveExtractCallbackMessage::IArchiveExtractCallbackMessage(IArchiveExtractCallbackMessage *__hidden this)
.text:00008434                 public ??0IArchiveExtractCallbackMessage@@QAE@XZ
.text:00008434 ??0IArchiveExtractCallbackMessage@@QAE@XZ proc near
.text:00008434                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+47p
.text:00008434
.text:00008434 var_4           = dword ptr -4
.text:00008434
.text:00008434                 push    ebp
.text:00008435                 mov     ebp, esp
.text:00008437                 push    ecx
.text:00008438                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000843F                 mov     [ebp+var_4], ecx
.text:00008442                 mov     ecx, [ebp+var_4] ; this
.text:00008445                 call    ??0IProgress@@QAE@XZ ; IProgress::IProgress(void)
.text:0000844A                 mov     eax, [ebp+var_4]
.text:0000844D                 mov     dword ptr [eax], offset ??_7IArchiveExtractCallbackMessage@@6B@ ; const IArchiveExtractCallbackMessage::`vftable'
.text:00008453                 mov     eax, [ebp+var_4]
.text:00008456                 add     esp, 4
.text:00008459                 cmp     ebp, esp
.text:0000845B                 call    __RTC_CheckEsp
.text:00008460                 mov     esp, ebp
.text:00008462                 pop     ebp
.text:00008463                 retn
.text:00008463 ??0IArchiveExtractCallbackMessage@@QAE@XZ endp
.text:00008463
.text:00008463 _text           ends
.text:00008463
.rdata:00008464 ; ===========================================================================
.rdata:00008464
.rdata:00008464 ; Segment type: Pure data
.rdata:00008464 ; Segment permissions: Read
.rdata:00008464 _rdata          segment dword public 'DATA' use32
.rdata:00008464                 assume cs:_rdata
.rdata:00008464                 ;org 8464h
.rdata:00008464 ; COMDAT (pick largest)
.rdata:00008464                 dd offset ??_R4IArchiveExtractCallbackMessage@@6B@ ; const IArchiveExtractCallbackMessage::`RTTI Complete Object Locator'
.rdata:00008468                 public ??_7IArchiveExtractCallbackMessage@@6B@
.rdata:00008468 ; const IArchiveExtractCallbackMessage::`vftable'
.rdata:00008468 ??_7IArchiveExtractCallbackMessage@@6B@ dd offset __purecall
.rdata:00008468                                         ; DATA XREF: IArchiveExtractCallbackMessage::IArchiveExtractCallbackMessage(void)+19o
.rdata:0000846C                 dd offset __purecall
.rdata:00008470                 dd offset __purecall
.rdata:00008474                 dd offset __purecall
.rdata:00008478                 dd offset __purecall
.rdata:0000847C                 dd offset __purecall
.rdata:0000847C _rdata          ends
.rdata:0000847C
.rdata$r:00008480 ; ===========================================================================
.rdata$r:00008480
.rdata$r:00008480 ; Segment type: Pure data
.rdata$r:00008480 ; Segment permissions: Read
.rdata$r:00008480 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008480                 assume cs:_rdata$r
.rdata$r:00008480                 ;org 8480h
.rdata$r:00008480 ; COMDAT (pick any)
.rdata$r:00008480                 public ??_R4IArchiveExtractCallbackMessage@@6B@
.rdata$r:00008480 ; const IArchiveExtractCallbackMessage::`RTTI Complete Object Locator'
.rdata$r:00008480 ??_R4IArchiveExtractCallbackMessage@@6B@ db    0
.rdata$r:00008480                                         ; DATA XREF: .rdata:00008464o
.rdata$r:00008481                 db    0
.rdata$r:00008482                 db    0
.rdata$r:00008483                 db    0
.rdata$r:00008484                 db    0
.rdata$r:00008485                 db    0
.rdata$r:00008486                 db    0
.rdata$r:00008487                 db    0
.rdata$r:00008488                 db    0
.rdata$r:00008489                 db    0
.rdata$r:0000848A                 db    0
.rdata$r:0000848B                 db    0
.rdata$r:0000848C                 dd offset ??_R0?AUIArchiveExtractCallbackMessage@@@8 ; IArchiveExtractCallbackMessage `RTTI Type Descriptor'
.rdata$r:00008490                 dd offset ??_R3IArchiveExtractCallbackMessage@@8 ; IArchiveExtractCallbackMessage::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008490 _rdata$r        ends
.rdata$r:00008490
.text:00008494 ; ===========================================================================
.text:00008494
.text:00008494 ; Segment type: Pure code
.text:00008494 ; Segment permissions: Read/Execute
.text:00008494 _text           segment para public 'CODE' use32
.text:00008494                 assume cs:_text
.text:00008494                 ;org 8494h
.text:00008494 ; COMDAT (pick any)
.text:00008494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008494
.text:00008494 ; =============== S U B R O U T I N E =======================================
.text:00008494
.text:00008494 ; Attributes: bp-based frame
.text:00008494
.text:00008494 ; _DWORD __thiscall ICompressProgressInfo::ICompressProgressInfo(ICompressProgressInfo *__hidden this)
.text:00008494                 public ??0ICompressProgressInfo@@QAE@XZ
.text:00008494 ??0ICompressProgressInfo@@QAE@XZ proc near
.text:00008494                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+5Dp
.text:00008494
.text:00008494 var_4           = dword ptr -4
.text:00008494
.text:00008494                 push    ebp
.text:00008495                 mov     ebp, esp
.text:00008497                 push    ecx
.text:00008498                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000849F                 mov     [ebp+var_4], ecx
.text:000084A2                 mov     ecx, [ebp+var_4]
.text:000084A5                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:000084AA                 mov     eax, [ebp+var_4]
.text:000084AD                 mov     dword ptr [eax], offset ??_7ICompressProgressInfo@@6B@ ; const ICompressProgressInfo::`vftable'
.text:000084B3                 mov     eax, [ebp+var_4]
.text:000084B6                 add     esp, 4
.text:000084B9                 cmp     ebp, esp
.text:000084BB                 call    __RTC_CheckEsp
.text:000084C0                 mov     esp, ebp
.text:000084C2                 pop     ebp
.text:000084C3                 retn
.text:000084C3 ??0ICompressProgressInfo@@QAE@XZ endp
.text:000084C3
.text:000084C3 _text           ends
.text:000084C3
.rdata:000084C4 ; ===========================================================================
.rdata:000084C4
.rdata:000084C4 ; Segment type: Pure data
.rdata:000084C4 ; Segment permissions: Read
.rdata:000084C4 _rdata          segment dword public 'DATA' use32
.rdata:000084C4                 assume cs:_rdata
.rdata:000084C4                 ;org 84C4h
.rdata:000084C4 ; COMDAT (pick largest)
.rdata:000084C4                 dd offset ??_R4ICompressProgressInfo@@6B@ ; const ICompressProgressInfo::`RTTI Complete Object Locator'
.rdata:000084C8                 public ??_7ICompressProgressInfo@@6B@
.rdata:000084C8 ; const ICompressProgressInfo::`vftable'
.rdata:000084C8 ??_7ICompressProgressInfo@@6B@ dd offset __purecall
.rdata:000084C8                                         ; DATA XREF: ICompressProgressInfo::ICompressProgressInfo(void)+19o
.rdata:000084CC                 dd offset __purecall
.rdata:000084D0                 dd offset __purecall
.rdata:000084D4                 dd offset __purecall
.rdata:000084D4 _rdata          ends
.rdata:000084D4
.rdata$r:000084D8 ; ===========================================================================
.rdata$r:000084D8
.rdata$r:000084D8 ; Segment type: Pure data
.rdata$r:000084D8 ; Segment permissions: Read
.rdata$r:000084D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000084D8                 assume cs:_rdata$r
.rdata$r:000084D8                 ;org 84D8h
.rdata$r:000084D8 ; COMDAT (pick any)
.rdata$r:000084D8                 public ??_R4ICompressProgressInfo@@6B@
.rdata$r:000084D8 ; const ICompressProgressInfo::`RTTI Complete Object Locator'
.rdata$r:000084D8 ??_R4ICompressProgressInfo@@6B@ db    0 ; DATA XREF: .rdata:000084C4o
.rdata$r:000084D9                 db    0
.rdata$r:000084DA                 db    0
.rdata$r:000084DB                 db    0
.rdata$r:000084DC                 db    0
.rdata$r:000084DD                 db    0
.rdata$r:000084DE                 db    0
.rdata$r:000084DF                 db    0
.rdata$r:000084E0                 db    0
.rdata$r:000084E1                 db    0
.rdata$r:000084E2                 db    0
.rdata$r:000084E3                 db    0
.rdata$r:000084E4                 dd offset ??_R0?AUICompressProgressInfo@@@8 ; ICompressProgressInfo `RTTI Type Descriptor'
.rdata$r:000084E8                 dd offset ??_R3ICompressProgressInfo@@8 ; ICompressProgressInfo::`RTTI Class Hierarchy Descriptor'
.rdata$r:000084E8 _rdata$r        ends
.rdata$r:000084E8
.text:000084EC ; ===========================================================================
.text:000084EC
.text:000084EC ; Segment type: Pure code
.text:000084EC ; Segment permissions: Read/Execute
.text:000084EC _text           segment para public 'CODE' use32
.text:000084EC                 assume cs:_text
.text:000084EC                 ;org 84ECh
.text:000084EC ; COMDAT (pick any)
.text:000084EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000084EC
.text:000084EC ; =============== S U B R O U T I N E =======================================
.text:000084EC
.text:000084EC ; Attributes: bp-based frame
.text:000084EC
.text:000084EC ; _DWORD __thiscall CHardLinks::CHardLinks(CHardLinks *__hidden this)
.text:000084EC                 public ??0CHardLinks@@QAE@XZ
.text:000084EC ??0CHardLinks@@QAE@XZ proc near         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+1E7p
.text:000084EC
.text:000084EC var_10          = dword ptr -10h
.text:000084EC var_C           = dword ptr -0Ch
.text:000084EC var_4           = dword ptr -4
.text:000084EC
.text:000084EC                 push    ebp
.text:000084ED                 mov     ebp, esp
.text:000084EF                 push    0FFFFFFFFh
.text:000084F1                 push    offset __ehhandler$??0CHardLinks@@QAE@XZ
.text:000084F6                 mov     eax, large fs:0
.text:000084FC                 push    eax
.text:000084FD                 push    ecx
.text:000084FE                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00008505                 mov     eax, dword ptr ds:___security_cookie
.text:0000850A                 xor     eax, ebp
.text:0000850C                 push    eax
.text:0000850D                 lea     eax, [ebp+var_C]
.text:00008510                 mov     large fs:0, eax
.text:00008516                 mov     [ebp+var_10], ecx
.text:00008519                 mov     ecx, [ebp+var_10]
.text:0000851C                 call    ??0?$CRecordVector@UCHardLinkNode@@@@QAE@XZ ; CRecordVector<CHardLinkNode>::CRecordVector<CHardLinkNode>(void)
.text:00008521                 mov     [ebp+var_4], 0
.text:00008528                 mov     ecx, [ebp+var_10]
.text:0000852B                 add     ecx, 0Ch
.text:0000852E                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00008533                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000853A                 mov     eax, [ebp+var_10]
.text:0000853D                 mov     ecx, [ebp+var_C]
.text:00008540                 mov     large fs:0, ecx
.text:00008547                 pop     ecx
.text:00008548                 add     esp, 10h
.text:0000854B                 cmp     ebp, esp
.text:0000854D                 call    __RTC_CheckEsp
.text:00008552                 mov     esp, ebp
.text:00008554                 pop     ebp
.text:00008555                 retn
.text:00008555 ??0CHardLinks@@QAE@XZ endp
.text:00008555
.text:00008555 ; ---------------------------------------------------------------------------
.text:00008556                 align 4
.text:00008556 _text           ends
.text:00008556
.text$x:00008558 ; ===========================================================================
.text$x:00008558
.text$x:00008558 ; Segment type: Pure code
.text$x:00008558 ; Segment permissions: Read/Execute
.text$x:00008558 _text$x         segment para public 'CODE' use32
.text$x:00008558                 assume cs:_text$x
.text$x:00008558                 ;org 8558h
.text$x:00008558 ; COMDAT (pick associative to section at 84EC)
.text$x:00008558                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008558
.text$x:00008558 ; =============== S U B R O U T I N E =======================================
.text$x:00008558
.text$x:00008558
.text$x:00008558 __unwindfunclet$??0CHardLinks@@QAE@XZ$0 proc near
.text$x:00008558                                         ; DATA XREF: .xdata$x:00008580o
.text$x:00008558                 mov     ecx, [ebp-10h]
.text$x:0000855B                 jmp     ??1?$CRecordVector@UCHardLinkNode@@@@QAE@XZ ; CRecordVector<CHardLinkNode>::~CRecordVector<CHardLinkNode>(void)
.text$x:0000855B __unwindfunclet$??0CHardLinks@@QAE@XZ$0 endp
.text$x:0000855B
.text$x:00008560
.text$x:00008560 ; =============== S U B R O U T I N E =======================================
.text$x:00008560
.text$x:00008560
.text$x:00008560 __ehhandler$??0CHardLinks@@QAE@XZ proc near
.text$x:00008560                                         ; DATA XREF: CHardLinks::CHardLinks(void)+5o
.text$x:00008560
.text$x:00008560 arg_4           = dword ptr  8
.text$x:00008560
.text$x:00008560                 mov     edx, [esp+arg_4]
.text$x:00008564                 lea     eax, [edx+0Ch]
.text$x:00008567                 mov     ecx, [edx-8]
.text$x:0000856A                 xor     ecx, eax
.text$x:0000856C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008571                 mov     eax, offset __ehfuncinfo$??0CHardLinks@@QAE@XZ
.text$x:00008576                 jmp     ___CxxFrameHandler3
.text$x:00008576 __ehhandler$??0CHardLinks@@QAE@XZ endp
.text$x:00008576
.text$x:00008576 ; ---------------------------------------------------------------------------
.text$x:0000857B                 align 4
.text$x:0000857B _text$x         ends
.text$x:0000857B
.xdata$x:0000857C ; ===========================================================================
.xdata$x:0000857C
.xdata$x:0000857C ; Segment type: Pure data
.xdata$x:0000857C ; Segment permissions: Read
.xdata$x:0000857C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000857C                 assume cs:_xdata$x
.xdata$x:0000857C                 ;org 857Ch
.xdata$x:0000857C ; COMDAT (pick associative to section at 84EC)
.xdata$x:0000857C __unwindtable$??0CHardLinks@@QAE@XZ db 0FFh
.xdata$x:0000857C                                         ; DATA XREF: .xdata$x:0000858Co
.xdata$x:0000857D                 db 0FFh
.xdata$x:0000857E                 db 0FFh
.xdata$x:0000857F                 db 0FFh
.xdata$x:00008580                 dd offset __unwindfunclet$??0CHardLinks@@QAE@XZ$0
.xdata$x:00008584 __ehfuncinfo$??0CHardLinks@@QAE@XZ db  22h ; "
.xdata$x:00008584                                         ; DATA XREF: __ehhandler$??0CHardLinks@@QAE@XZ+11o
.xdata$x:00008585                 db    5
.xdata$x:00008586                 db  93h ; ô
.xdata$x:00008587                 db  19h
.xdata$x:00008588                 db    1
.xdata$x:00008589                 db    0
.xdata$x:0000858A                 db    0
.xdata$x:0000858B                 db    0
.xdata$x:0000858C                 dd offset __unwindtable$??0CHardLinks@@QAE@XZ
.xdata$x:00008590                 db    0
.xdata$x:00008591                 db    0
.xdata$x:00008592                 db    0
.xdata$x:00008593                 db    0
.xdata$x:00008594                 db    0
.xdata$x:00008595                 db    0
.xdata$x:00008596                 db    0
.xdata$x:00008597                 db    0
.xdata$x:00008598                 db    0
.xdata$x:00008599                 db    0
.xdata$x:0000859A                 db    0
.xdata$x:0000859B                 db    0
.xdata$x:0000859C                 db    0
.xdata$x:0000859D                 db    0
.xdata$x:0000859E                 db    0
.xdata$x:0000859F                 db    0
.xdata$x:000085A0                 db    0
.xdata$x:000085A1                 db    0
.xdata$x:000085A2                 db    0
.xdata$x:000085A3                 db    0
.xdata$x:000085A4                 db    1
.xdata$x:000085A5                 db    0
.xdata$x:000085A6                 db    0
.xdata$x:000085A7                 db    0
.xdata$x:000085A7 _xdata$x        ends
.xdata$x:000085A7
.text:000085A8 ; ===========================================================================
.text:000085A8
.text:000085A8 ; Segment type: Pure code
.text:000085A8 ; Segment permissions: Read/Execute
.text:000085A8 _text           segment para public 'CODE' use32
.text:000085A8                 assume cs:_text
.text:000085A8                 ;org 85A8h
.text:000085A8 ; COMDAT (pick any)
.text:000085A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000085A8
.text:000085A8 ; =============== S U B R O U T I N E =======================================
.text:000085A8
.text:000085A8 ; Attributes: bp-based frame
.text:000085A8
.text:000085A8 ; _DWORD __thiscall IProgress::IProgress(IProgress *__hidden this)
.text:000085A8                 public ??0IProgress@@QAE@XZ
.text:000085A8 ??0IProgress@@QAE@XZ proc near          ; CODE XREF: IArchiveExtractCallback::IArchiveExtractCallback(void)+11p
.text:000085A8                                         ; IArchiveExtractCallbackMessage::IArchiveExtractCallbackMessage(void)+11p
.text:000085A8
.text:000085A8 var_4           = dword ptr -4
.text:000085A8
.text:000085A8                 push    ebp
.text:000085A9                 mov     ebp, esp
.text:000085AB                 push    ecx
.text:000085AC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000085B3                 mov     [ebp+var_4], ecx
.text:000085B6                 mov     ecx, [ebp+var_4]
.text:000085B9                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:000085BE                 mov     eax, [ebp+var_4]
.text:000085C1                 mov     dword ptr [eax], offset ??_7IProgress@@6B@ ; const IProgress::`vftable'
.text:000085C7                 mov     eax, [ebp+var_4]
.text:000085CA                 add     esp, 4
.text:000085CD                 cmp     ebp, esp
.text:000085CF                 call    __RTC_CheckEsp
.text:000085D4                 mov     esp, ebp
.text:000085D6                 pop     ebp
.text:000085D7                 retn
.text:000085D7 ??0IProgress@@QAE@XZ endp
.text:000085D7
.text:000085D7 _text           ends
.text:000085D7
.rdata:000085D8 ; ===========================================================================
.rdata:000085D8
.rdata:000085D8 ; Segment type: Pure data
.rdata:000085D8 ; Segment permissions: Read
.rdata:000085D8 _rdata          segment dword public 'DATA' use32
.rdata:000085D8                 assume cs:_rdata
.rdata:000085D8                 ;org 85D8h
.rdata:000085D8 ; COMDAT (pick largest)
.rdata:000085D8                 dd offset ??_R4IProgress@@6B@ ; const IProgress::`RTTI Complete Object Locator'
.rdata:000085DC                 public ??_7IProgress@@6B@
.rdata:000085DC ; const IProgress::`vftable'
.rdata:000085DC ??_7IProgress@@6B@ dd offset __purecall ; DATA XREF: IProgress::IProgress(void)+19o
.rdata:000085E0                 dd offset __purecall
.rdata:000085E4                 dd offset __purecall
.rdata:000085E8                 dd offset __purecall
.rdata:000085EC                 dd offset __purecall
.rdata:000085EC _rdata          ends
.rdata:000085EC
.rdata$r:000085F0 ; ===========================================================================
.rdata$r:000085F0
.rdata$r:000085F0 ; Segment type: Pure data
.rdata$r:000085F0 ; Segment permissions: Read
.rdata$r:000085F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000085F0                 assume cs:_rdata$r
.rdata$r:000085F0                 ;org 85F0h
.rdata$r:000085F0 ; COMDAT (pick any)
.rdata$r:000085F0                 public ??_R4IProgress@@6B@
.rdata$r:000085F0 ; const IProgress::`RTTI Complete Object Locator'
.rdata$r:000085F0 ??_R4IProgress@@6B@ db    0             ; DATA XREF: .rdata:000085D8o
.rdata$r:000085F1                 db    0
.rdata$r:000085F2                 db    0
.rdata$r:000085F3                 db    0
.rdata$r:000085F4                 db    0
.rdata$r:000085F5                 db    0
.rdata$r:000085F6                 db    0
.rdata$r:000085F7                 db    0
.rdata$r:000085F8                 db    0
.rdata$r:000085F9                 db    0
.rdata$r:000085FA                 db    0
.rdata$r:000085FB                 db    0
.rdata$r:000085FC                 dd offset ??_R0?AUIProgress@@@8 ; IProgress `RTTI Type Descriptor'
.rdata$r:00008600                 dd offset ??_R3IProgress@@8 ; IProgress::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008600 _rdata$r        ends
.rdata$r:00008600
.text:00008604 ; ===========================================================================
.text:00008604
.text:00008604 ; Segment type: Pure code
.text:00008604 ; Segment permissions: Read/Execute
.text:00008604 _text           segment para public 'CODE' use32
.text:00008604                 assume cs:_text
.text:00008604                 ;org 8604h
.text:00008604 ; COMDAT (pick any)
.text:00008604                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008604
.text:00008604 ; =============== S U B R O U T I N E =======================================
.text:00008604
.text:00008604 ; Attributes: bp-based frame
.text:00008604
.text:00008604 ; public: __thiscall UString::operator wchar_t const *(void)const
.text:00008604                 public ??BUString@@QBEPB_WXZ
.text:00008604 ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+237p
.text:00008604                                         ; CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+25Fp ...
.text:00008604
.text:00008604 var_4           = dword ptr -4
.text:00008604
.text:00008604                 push    ebp
.text:00008605                 mov     ebp, esp
.text:00008607                 push    ecx
.text:00008608                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000860F                 mov     [ebp+var_4], ecx
.text:00008612                 mov     eax, [ebp+var_4]
.text:00008615                 mov     eax, [eax]
.text:00008617                 mov     esp, ebp
.text:00008619                 pop     ebp
.text:0000861A                 retn
.text:0000861A ??BUString@@QBEPB_WXZ endp
.text:0000861A
.text:0000861A ; ---------------------------------------------------------------------------
.text:0000861B                 align 4
.text:0000861B _text           ends
.text:0000861B
.text:0000861C ; ===========================================================================
.text:0000861C
.text:0000861C ; Segment type: Pure code
.text:0000861C ; Segment permissions: Read/Execute
.text:0000861C _text           segment para public 'CODE' use32
.text:0000861C                 assume cs:_text
.text:0000861C                 ;org 861Ch
.text:0000861C ; COMDAT (pick any)
.text:0000861C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000861C
.text:0000861C ; =============== S U B R O U T I N E =======================================
.text:0000861C
.text:0000861C ; Attributes: bp-based frame
.text:0000861C
.text:0000861C ; unsigned int __thiscall UString::Len(UString *__hidden this)
.text:0000861C                 public ?Len@UString@@QBEIXZ
.text:0000861C ?Len@UString@@QBEIXZ proc near          ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+EFp
.text:0000861C
.text:0000861C var_4           = dword ptr -4
.text:0000861C
.text:0000861C                 push    ebp
.text:0000861D                 mov     ebp, esp
.text:0000861F                 push    ecx
.text:00008620                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008627                 mov     [ebp+var_4], ecx
.text:0000862A                 mov     eax, [ebp+var_4]
.text:0000862D                 mov     eax, [eax+4]
.text:00008630                 mov     esp, ebp
.text:00008632                 pop     ebp
.text:00008633                 retn
.text:00008633 ?Len@UString@@QBEIXZ endp
.text:00008633
.text:00008633 _text           ends
.text:00008633
.text:00008634 ; ===========================================================================
.text:00008634
.text:00008634 ; Segment type: Pure code
.text:00008634 ; Segment permissions: Read/Execute
.text:00008634 _text           segment para public 'CODE' use32
.text:00008634                 assume cs:_text
.text:00008634                 ;org 8634h
.text:00008634 ; COMDAT (pick any)
.text:00008634                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008634
.text:00008634 ; =============== S U B R O U T I N E =======================================
.text:00008634
.text:00008634 ; Attributes: bp-based frame
.text:00008634
.text:00008634 ; bool __thiscall UString::IsEmpty(UString *__hidden this)
.text:00008634                 public ?IsEmpty@UString@@QBE_NXZ
.text:00008634 ?IsEmpty@UString@@QBE_NXZ proc near     ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+40p
.text:00008634                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+43Ep ...
.text:00008634
.text:00008634 var_4           = dword ptr -4
.text:00008634
.text:00008634                 push    ebp
.text:00008635                 mov     ebp, esp
.text:00008637                 push    ecx
.text:00008638                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000863F                 mov     [ebp+var_4], ecx
.text:00008642                 mov     eax, [ebp+var_4]
.text:00008645                 xor     ecx, ecx
.text:00008647                 cmp     dword ptr [eax+4], 0
.text:0000864B                 setz    cl
.text:0000864E                 mov     al, cl
.text:00008650                 mov     esp, ebp
.text:00008652                 pop     ebp
.text:00008653                 retn
.text:00008653 ?IsEmpty@UString@@QBE_NXZ endp
.text:00008653
.text:00008653 _text           ends
.text:00008653
.text:00008654 ; ===========================================================================
.text:00008654
.text:00008654 ; Segment type: Pure code
.text:00008654 ; Segment permissions: Read/Execute
.text:00008654 _text           segment para public 'CODE' use32
.text:00008654                 assume cs:_text
.text:00008654                 ;org 8654h
.text:00008654 ; COMDAT (pick any)
.text:00008654                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008654
.text:00008654 ; =============== S U B R O U T I N E =======================================
.text:00008654
.text:00008654 ; Attributes: bp-based frame
.text:00008654
.text:00008654 ; void __thiscall UString::Empty(UString *__hidden this)
.text:00008654                 public ?Empty@UString@@QAEXXZ
.text:00008654 ?Empty@UString@@QAEXXZ proc near        ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+7Fp
.text:00008654
.text:00008654 var_4           = dword ptr -4
.text:00008654
.text:00008654                 push    ebp
.text:00008655                 mov     ebp, esp
.text:00008657                 push    ecx
.text:00008658                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000865F                 mov     [ebp+var_4], ecx
.text:00008662                 mov     eax, [ebp+var_4]
.text:00008665                 mov     dword ptr [eax+4], 0
.text:0000866C                 mov     ecx, [ebp+var_4]
.text:0000866F                 mov     edx, [ecx]
.text:00008671                 xor     eax, eax
.text:00008673                 mov     [edx], ax
.text:00008676                 mov     esp, ebp
.text:00008678                 pop     ebp
.text:00008679                 retn
.text:00008679 ?Empty@UString@@QAEXXZ endp
.text:00008679
.text:00008679 ; ---------------------------------------------------------------------------
.text:0000867A                 align 4
.text:0000867A _text           ends
.text:0000867A
.text:0000867C ; ===========================================================================
.text:0000867C
.text:0000867C ; Segment type: Pure code
.text:0000867C ; Segment permissions: Read/Execute
.text:0000867C _text           segment para public 'CODE' use32
.text:0000867C                 assume cs:_text
.text:0000867C                 ;org 867Ch
.text:0000867C ; COMDAT (pick any)
.text:0000867C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000867C
.text:0000867C ; =============== S U B R O U T I N E =======================================
.text:0000867C
.text:0000867C ; Attributes: bp-based frame
.text:0000867C
.text:0000867C ; void __thiscall UString::Add_PathSepar(UString *__hidden this)
.text:0000867C                 public ?Add_PathSepar@UString@@QAEXXZ
.text:0000867C ?Add_PathSepar@UString@@QAEXXZ proc near
.text:0000867C                                         ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+BDp
.text:0000867C
.text:0000867C var_4           = dword ptr -4
.text:0000867C
.text:0000867C                 push    ebp
.text:0000867D                 mov     ebp, esp
.text:0000867F                 push    ecx
.text:00008680                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008687                 mov     [ebp+var_4], ecx
.text:0000868A                 push    5Ch ; '\'
.text:0000868C                 mov     ecx, [ebp+var_4]
.text:0000868F                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:00008694                 add     esp, 4
.text:00008697                 cmp     ebp, esp
.text:00008699                 call    __RTC_CheckEsp
.text:0000869E                 mov     esp, ebp
.text:000086A0                 pop     ebp
.text:000086A1                 retn
.text:000086A1 ?Add_PathSepar@UString@@QAEXXZ endp
.text:000086A1
.text:000086A1 ; ---------------------------------------------------------------------------
.text:000086A2                 align 4
.text:000086A2 _text           ends
.text:000086A2
.text:000086A4 ; ===========================================================================
.text:000086A4
.text:000086A4 ; Segment type: Pure code
.text:000086A4 ; Segment permissions: Read/Execute
.text:000086A4 _text           segment para public 'CODE' use32
.text:000086A4                 assume cs:_text
.text:000086A4                 ;org 86A4h
.text:000086A4 ; COMDAT (pick any)
.text:000086A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000086A4
.text:000086A4 ; =============== S U B R O U T I N E =======================================
.text:000086A4
.text:000086A4 ; Attributes: bp-based frame
.text:000086A4
.text:000086A4 ; public: class UString & __thiscall UString::operator+=(wchar_t)
.text:000086A4                 public ??YUString@@QAEAAV0@_W@Z
.text:000086A4 ??YUString@@QAEAAV0@_W@Z proc near      ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+D9p
.text:000086A4                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+E98p ...
.text:000086A4
.text:000086A4 var_C           = dword ptr -0Ch
.text:000086A4 var_8           = dword ptr -8
.text:000086A4 var_4           = dword ptr -4
.text:000086A4 arg_0           = word ptr  8
.text:000086A4
.text:000086A4                 push    ebp
.text:000086A5                 mov     ebp, esp
.text:000086A7                 sub     esp, 0Ch
.text:000086AA                 mov     [ebp+var_C], 0CCCCCCCCh
.text:000086B1                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000086B8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000086BF                 mov     [ebp+var_4], ecx
.text:000086C2                 mov     eax, [ebp+var_4]
.text:000086C5                 mov     ecx, [ebp+var_4]
.text:000086C8                 mov     edx, [eax+8]
.text:000086CB                 cmp     edx, [ecx+4]
.text:000086CE                 jnz     short loc_86D8
.text:000086D0                 mov     ecx, [ebp+var_4] ; this
.text:000086D3                 call    ?Grow_1@UString@@AAEXXZ ; UString::Grow_1(void)
.text:000086D8
.text:000086D8 loc_86D8:                               ; CODE XREF: UString::operator+=(wchar_t)+2Aj
.text:000086D8                 mov     eax, [ebp+var_4]
.text:000086DB                 mov     ecx, [eax+4]
.text:000086DE                 mov     [ebp+var_8], ecx
.text:000086E1                 mov     edx, [ebp+var_4]
.text:000086E4                 mov     eax, [edx]
.text:000086E6                 mov     [ebp+var_C], eax
.text:000086E9                 mov     ecx, [ebp+var_8]
.text:000086EC                 mov     edx, [ebp+var_C]
.text:000086EF                 mov     ax, [ebp+arg_0]
.text:000086F3                 mov     [edx+ecx*2], ax
.text:000086F7                 mov     ecx, [ebp+var_8]
.text:000086FA                 add     ecx, 1
.text:000086FD                 mov     [ebp+var_8], ecx
.text:00008700                 xor     edx, edx
.text:00008702                 mov     eax, [ebp+var_8]
.text:00008705                 mov     ecx, [ebp+var_C]
.text:00008708                 mov     [ecx+eax*2], dx
.text:0000870C                 mov     edx, [ebp+var_4]
.text:0000870F                 mov     eax, [ebp+var_8]
.text:00008712                 mov     [edx+4], eax
.text:00008715                 mov     eax, [ebp+var_4]
.text:00008718                 add     esp, 0Ch
.text:0000871B                 cmp     ebp, esp
.text:0000871D                 call    __RTC_CheckEsp
.text:00008722                 mov     esp, ebp
.text:00008724                 pop     ebp
.text:00008725                 retn    4
.text:00008725 ??YUString@@QAEAAV0@_W@Z endp
.text:00008725
.text:00008725 _text           ends
.text:00008725
.text:00008728 ; ===========================================================================
.text:00008728
.text:00008728 ; Segment type: Pure code
.text:00008728 ; Segment permissions: Read/Execute
.text:00008728 _text           segment para public 'CODE' use32
.text:00008728                 assume cs:_text
.text:00008728                 ;org 8728h
.text:00008728 ; COMDAT (pick any)
.text:00008728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008728
.text:00008728 ; =============== S U B R O U T I N E =======================================
.text:00008728
.text:00008728 ; Attributes: bp-based frame
.text:00008728
.text:00008728 ; public: class UString __thiscall UString::Left(unsigned int)const
.text:00008728                 public ?Left@UString@@QBE?AV1@I@Z
.text:00008728 ?Left@UString@@QBE?AV1@I@Z proc near    ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1A09p
.text:00008728
.text:00008728 var_8           = dword ptr -8
.text:00008728 var_4           = dword ptr -4
.text:00008728 arg_0           = dword ptr  8
.text:00008728 arg_4           = dword ptr  0Ch
.text:00008728
.text:00008728                 push    ebp
.text:00008729                 mov     ebp, esp
.text:0000872B                 sub     esp, 8
.text:0000872E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00008735                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000873C                 mov     [ebp+var_4], ecx
.text:0000873F                 mov     [ebp+var_8], 0
.text:00008746                 mov     eax, [ebp+var_4]
.text:00008749                 push    eax
.text:0000874A                 mov     ecx, [ebp+arg_4]
.text:0000874D                 push    ecx
.text:0000874E                 mov     ecx, [ebp+arg_0]
.text:00008751                 call    ??0UString@@AAE@IABV0@@Z ; UString::UString(uint,UString const &)
.text:00008756                 mov     edx, [ebp+var_8]
.text:00008759                 or      edx, 1
.text:0000875C                 mov     [ebp+var_8], edx
.text:0000875F                 mov     eax, [ebp+arg_0]
.text:00008762                 add     esp, 8
.text:00008765                 cmp     ebp, esp
.text:00008767                 call    __RTC_CheckEsp
.text:0000876C                 mov     esp, ebp
.text:0000876E                 pop     ebp
.text:0000876F                 retn    8
.text:0000876F ?Left@UString@@QBE?AV1@I@Z endp
.text:0000876F
.text:0000876F ; ---------------------------------------------------------------------------
.text:00008772                 align 4
.text:00008772 _text           ends
.text:00008772
.text:00008774 ; ===========================================================================
.text:00008774
.text:00008774 ; Segment type: Pure code
.text:00008774 ; Segment permissions: Read/Execute
.text:00008774 _text           segment para public 'CODE' use32
.text:00008774                 assume cs:_text
.text:00008774                 ;org 8774h
.text:00008774 ; COMDAT (pick any)
.text:00008774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008774
.text:00008774 ; =============== S U B R O U T I N E =======================================
.text:00008774
.text:00008774 ; Attributes: bp-based frame
.text:00008774
.text:00008774 ; void __thiscall UString::DeleteFrom(UString *this, unsigned int)
.text:00008774                 public ?DeleteFrom@UString@@QAEXI@Z
.text:00008774 ?DeleteFrom@UString@@QAEXI@Z proc near  ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+24BCp
.text:00008774                                         ; GetDirPrefixOf(UString const &)+9Dp
.text:00008774
.text:00008774 var_4           = dword ptr -4
.text:00008774 arg_0           = dword ptr  8
.text:00008774
.text:00008774                 push    ebp
.text:00008775                 mov     ebp, esp
.text:00008777                 push    ecx
.text:00008778                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000877F                 mov     [ebp+var_4], ecx
.text:00008782                 mov     eax, [ebp+var_4]
.text:00008785                 mov     ecx, [ebp+arg_0]
.text:00008788                 cmp     ecx, [eax+4]
.text:0000878B                 jnb     short loc_87A4
.text:0000878D                 mov     edx, [ebp+var_4]
.text:00008790                 mov     eax, [ebp+arg_0]
.text:00008793                 mov     [edx+4], eax
.text:00008796                 mov     ecx, [ebp+var_4]
.text:00008799                 mov     edx, [ecx]
.text:0000879B                 xor     eax, eax
.text:0000879D                 mov     ecx, [ebp+arg_0]
.text:000087A0                 mov     [edx+ecx*2], ax
.text:000087A4
.text:000087A4 loc_87A4:                               ; CODE XREF: UString::DeleteFrom(uint)+17j
.text:000087A4                 mov     esp, ebp
.text:000087A6                 pop     ebp
.text:000087A7                 retn    4
.text:000087A7 ?DeleteFrom@UString@@QAEXI@Z endp
.text:000087A7
.text:000087A7 ; ---------------------------------------------------------------------------
.text:000087AA                 align 4
.text:000087AA _text           ends
.text:000087AA
.text:000087AC ; ===========================================================================
.text:000087AC
.text:000087AC ; Segment type: Pure code
.text:000087AC ; Segment permissions: Read/Execute
.text:000087AC _text           segment para public 'CODE' use32
.text:000087AC                 assume cs:_text
.text:000087AC                 ;org 87ACh
.text:000087AC ; COMDAT (pick any)
.text:000087AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000087AC
.text:000087AC ; =============== S U B R O U T I N E =======================================
.text:000087AC
.text:000087AC ; Attributes: bp-based frame
.text:000087AC
.text:000087AC ; int __stdcall BoolToInt(bool)
.text:000087AC                 public ?BoolToInt@@YGH_N@Z
.text:000087AC ?BoolToInt@@YGH_N@Z proc near           ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+EEBp
.text:000087AC                                         ; CArchiveExtractCallback::PrepareOperation(int)+10Bp ...
.text:000087AC
.text:000087AC arg_0           = byte ptr  8
.text:000087AC
.text:000087AC                 push    ebp
.text:000087AD                 mov     ebp, esp
.text:000087AF                 movzx   eax, [ebp+arg_0]
.text:000087B3                 neg     eax
.text:000087B5                 sbb     eax, eax
.text:000087B7                 neg     eax
.text:000087B9                 pop     ebp
.text:000087BA                 retn    4
.text:000087BA ?BoolToInt@@YGH_N@Z endp
.text:000087BA
.text:000087BA ; ---------------------------------------------------------------------------
.text:000087BD                 align 10h
.text:000087BD _text           ends
.text:000087BD
.text:000087C0 ; ===========================================================================
.text:000087C0
.text:000087C0 ; Segment type: Pure code
.text:000087C0 ; Segment permissions: Read/Execute
.text:000087C0 _text           segment para public 'CODE' use32
.text:000087C0                 assume cs:_text
.text:000087C0                 ;org 87C0h
.text:000087C0 ; COMDAT (pick any)
.text:000087C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000087C0
.text:000087C0 ; =============== S U B R O U T I N E =======================================
.text:000087C0
.text:000087C0 ; Attributes: bp-based frame
.text:000087C0
.text:000087C0 ; _DWORD __thiscall NWindows::NFile::CReparseAttr::CReparseAttr(NWindows::NFile::CReparseAttr *__hidden this)
.text:000087C0                 public ??0CReparseAttr@NFile@NWindows@@QAE@XZ
.text:000087C0 ??0CReparseAttr@NFile@NWindows@@QAE@XZ proc near
.text:000087C0                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+529p
.text:000087C0                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+299Cp
.text:000087C0
.text:000087C0 var_10          = dword ptr -10h
.text:000087C0 var_C           = dword ptr -0Ch
.text:000087C0 var_4           = dword ptr -4
.text:000087C0
.text:000087C0                 push    ebp
.text:000087C1                 mov     ebp, esp
.text:000087C3                 push    0FFFFFFFFh
.text:000087C5                 push    offset __ehhandler$??0CReparseAttr@NFile@NWindows@@QAE@XZ
.text:000087CA                 mov     eax, large fs:0
.text:000087D0                 push    eax
.text:000087D1                 push    ecx
.text:000087D2                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000087D9                 mov     eax, dword ptr ds:___security_cookie
.text:000087DE                 xor     eax, ebp
.text:000087E0                 push    eax
.text:000087E1                 lea     eax, [ebp+var_C]
.text:000087E4                 mov     large fs:0, eax
.text:000087EA                 mov     [ebp+var_10], ecx
.text:000087ED                 mov     eax, [ebp+var_10]
.text:000087F0                 mov     dword ptr [eax], 0
.text:000087F6                 mov     ecx, [ebp+var_10]
.text:000087F9                 mov     dword ptr [ecx+4], 0
.text:00008800                 mov     ecx, [ebp+var_10]
.text:00008803                 add     ecx, 8
.text:00008806                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000880B                 mov     [ebp+var_4], 0
.text:00008812                 mov     ecx, [ebp+var_10]
.text:00008815                 add     ecx, 14h
.text:00008818                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000881D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008824                 mov     eax, [ebp+var_10]
.text:00008827                 mov     ecx, [ebp+var_C]
.text:0000882A                 mov     large fs:0, ecx
.text:00008831                 pop     ecx
.text:00008832                 add     esp, 10h
.text:00008835                 cmp     ebp, esp
.text:00008837                 call    __RTC_CheckEsp
.text:0000883C                 mov     esp, ebp
.text:0000883E                 pop     ebp
.text:0000883F                 retn
.text:0000883F ??0CReparseAttr@NFile@NWindows@@QAE@XZ endp
.text:0000883F
.text:0000883F _text           ends
.text:0000883F
.text$x:00008840 ; ===========================================================================
.text$x:00008840
.text$x:00008840 ; Segment type: Pure code
.text$x:00008840 ; Segment permissions: Read/Execute
.text$x:00008840 _text$x         segment para public 'CODE' use32
.text$x:00008840                 assume cs:_text$x
.text$x:00008840                 ;org 8840h
.text$x:00008840 ; COMDAT (pick associative to section at 87C0)
.text$x:00008840                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008840
.text$x:00008840 ; =============== S U B R O U T I N E =======================================
.text$x:00008840
.text$x:00008840
.text$x:00008840 __unwindfunclet$??0CReparseAttr@NFile@NWindows@@QAE@XZ$0 proc near
.text$x:00008840                                         ; DATA XREF: .xdata$x:0000886Co
.text$x:00008840                 mov     ecx, [ebp-10h]
.text$x:00008843                 add     ecx, 8          ; this
.text$x:00008846                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00008846 __unwindfunclet$??0CReparseAttr@NFile@NWindows@@QAE@XZ$0 endp
.text$x:00008846
.text$x:0000884B
.text$x:0000884B ; =============== S U B R O U T I N E =======================================
.text$x:0000884B
.text$x:0000884B
.text$x:0000884B __ehhandler$??0CReparseAttr@NFile@NWindows@@QAE@XZ proc near
.text$x:0000884B                                         ; DATA XREF: NWindows::NFile::CReparseAttr::CReparseAttr(void)+5o
.text$x:0000884B
.text$x:0000884B arg_4           = dword ptr  8
.text$x:0000884B
.text$x:0000884B                 mov     edx, [esp+arg_4]
.text$x:0000884F                 lea     eax, [edx+0Ch]
.text$x:00008852                 mov     ecx, [edx-8]
.text$x:00008855                 xor     ecx, eax
.text$x:00008857                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000885C                 mov     eax, offset __ehfuncinfo$??0CReparseAttr@NFile@NWindows@@QAE@XZ
.text$x:00008861                 jmp     ___CxxFrameHandler3
.text$x:00008861 __ehhandler$??0CReparseAttr@NFile@NWindows@@QAE@XZ endp
.text$x:00008861
.text$x:00008861 ; ---------------------------------------------------------------------------
.text$x:00008866                 align 4
.text$x:00008866 _text$x         ends
.text$x:00008866
.xdata$x:00008868 ; ===========================================================================
.xdata$x:00008868
.xdata$x:00008868 ; Segment type: Pure data
.xdata$x:00008868 ; Segment permissions: Read
.xdata$x:00008868 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008868                 assume cs:_xdata$x
.xdata$x:00008868                 ;org 8868h
.xdata$x:00008868 ; COMDAT (pick associative to section at 87C0)
.xdata$x:00008868 __unwindtable$??0CReparseAttr@NFile@NWindows@@QAE@XZ db 0FFh
.xdata$x:00008868                                         ; DATA XREF: .xdata$x:00008878o
.xdata$x:00008869                 db 0FFh
.xdata$x:0000886A                 db 0FFh
.xdata$x:0000886B                 db 0FFh
.xdata$x:0000886C                 dd offset __unwindfunclet$??0CReparseAttr@NFile@NWindows@@QAE@XZ$0
.xdata$x:00008870 __ehfuncinfo$??0CReparseAttr@NFile@NWindows@@QAE@XZ db  22h ; "
.xdata$x:00008870                                         ; DATA XREF: __ehhandler$??0CReparseAttr@NFile@NWindows@@QAE@XZ+11o
.xdata$x:00008871                 db    5
.xdata$x:00008872                 db  93h ; ô
.xdata$x:00008873                 db  19h
.xdata$x:00008874                 db    1
.xdata$x:00008875                 db    0
.xdata$x:00008876                 db    0
.xdata$x:00008877                 db    0
.xdata$x:00008878                 dd offset __unwindtable$??0CReparseAttr@NFile@NWindows@@QAE@XZ
.xdata$x:0000887C                 db    0
.xdata$x:0000887D                 db    0
.xdata$x:0000887E                 db    0
.xdata$x:0000887F                 db    0
.xdata$x:00008880                 db    0
.xdata$x:00008881                 db    0
.xdata$x:00008882                 db    0
.xdata$x:00008883                 db    0
.xdata$x:00008884                 db    0
.xdata$x:00008885                 db    0
.xdata$x:00008886                 db    0
.xdata$x:00008887                 db    0
.xdata$x:00008888                 db    0
.xdata$x:00008889                 db    0
.xdata$x:0000888A                 db    0
.xdata$x:0000888B                 db    0
.xdata$x:0000888C                 db    0
.xdata$x:0000888D                 db    0
.xdata$x:0000888E                 db    0
.xdata$x:0000888F                 db    0
.xdata$x:00008890                 db    1
.xdata$x:00008891                 db    0
.xdata$x:00008892                 db    0
.xdata$x:00008893                 db    0
.xdata$x:00008893 _xdata$x        ends
.xdata$x:00008893
.text:00008894 ; ===========================================================================
.text:00008894
.text:00008894 ; Segment type: Pure code
.text:00008894 ; Segment permissions: Read/Execute
.text:00008894 _text           segment para public 'CODE' use32
.text:00008894                 assume cs:_text
.text:00008894                 ;org 8894h
.text:00008894 ; COMDAT (pick any)
.text:00008894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008894
.text:00008894 ; =============== S U B R O U T I N E =======================================
.text:00008894
.text:00008894 ; Attributes: bp-based frame
.text:00008894
.text:00008894 ; bool __thiscall NWindows::NFile::CReparseAttr::IsMountPoint(NWindows::NFile::CReparseAttr *__hidden this)
.text:00008894                 public ?IsMountPoint@CReparseAttr@NFile@NWindows@@QBE_NXZ
.text:00008894 ?IsMountPoint@CReparseAttr@NFile@NWindows@@QBE_NXZ proc near
.text:00008894                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+5BEp
.text:00008894
.text:00008894 var_4           = dword ptr -4
.text:00008894
.text:00008894                 push    ebp
.text:00008895                 mov     ebp, esp
.text:00008897                 push    ecx
.text:00008898                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000889F                 mov     [ebp+var_4], ecx
.text:000088A2                 mov     eax, [ebp+var_4]
.text:000088A5                 xor     ecx, ecx
.text:000088A7                 cmp     dword ptr [eax], 0A0000003h
.text:000088AD                 setz    cl
.text:000088B0                 mov     al, cl
.text:000088B2                 mov     esp, ebp
.text:000088B4                 pop     ebp
.text:000088B5                 retn
.text:000088B5 ?IsMountPoint@CReparseAttr@NFile@NWindows@@QBE_NXZ endp
.text:000088B5
.text:000088B5 ; ---------------------------------------------------------------------------
.text:000088B6                 align 4
.text:000088B6 _text           ends
.text:000088B6
.text:000088B8 ; ===========================================================================
.text:000088B8
.text:000088B8 ; Segment type: Pure code
.text:000088B8 ; Segment permissions: Read/Execute
.text:000088B8 _text           segment para public 'CODE' use32
.text:000088B8                 assume cs:_text
.text:000088B8                 ;org 88B8h
.text:000088B8 ; COMDAT (pick any)
.text:000088B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000088B8
.text:000088B8 ; =============== S U B R O U T I N E =======================================
.text:000088B8
.text:000088B8 ; Attributes: bp-based frame
.text:000088B8
.text:000088B8 ; bool __thiscall NWindows::NFile::CReparseAttr::IsRelative(NWindows::NFile::CReparseAttr *__hidden this)
.text:000088B8                 public ?IsRelative@CReparseAttr@NFile@NWindows@@QBE_NXZ
.text:000088B8 ?IsRelative@CReparseAttr@NFile@NWindows@@QBE_NXZ proc near
.text:000088B8                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+5D8p
.text:000088B8
.text:000088B8 var_4           = dword ptr -4
.text:000088B8
.text:000088B8                 push    ebp
.text:000088B9                 mov     ebp, esp
.text:000088BB                 push    ecx
.text:000088BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000088C3                 mov     [ebp+var_4], ecx
.text:000088C6                 mov     eax, [ebp+var_4]
.text:000088C9                 xor     ecx, ecx
.text:000088CB                 cmp     dword ptr [eax+4], 1
.text:000088CF                 setz    cl
.text:000088D2                 mov     al, cl
.text:000088D4                 mov     esp, ebp
.text:000088D6                 pop     ebp
.text:000088D7                 retn
.text:000088D7 ?IsRelative@CReparseAttr@NFile@NWindows@@QBE_NXZ endp
.text:000088D7
.text:000088D7 _text           ends
.text:000088D7
.text:000088D8 ; ===========================================================================
.text:000088D8
.text:000088D8 ; Segment type: Pure code
.text:000088D8 ; Segment permissions: Read/Execute
.text:000088D8 _text           segment para public 'CODE' use32
.text:000088D8                 assume cs:_text
.text:000088D8                 ;org 88D8h
.text:000088D8 ; COMDAT (pick any)
.text:000088D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000088D8
.text:000088D8 ; =============== S U B R O U T I N E =======================================
.text:000088D8
.text:000088D8 ; Attributes: bp-based frame
.text:000088D8
.text:000088D8 ; bool __thiscall NWindows::NFile::NFind::CFileInfoBase::IsDir(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
.text:000088D8                 public ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ
.text:000088D8 ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ proc near
.text:000088D8                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+21B6p
.text:000088D8
.text:000088D8 var_4           = dword ptr -4
.text:000088D8
.text:000088D8                 push    ebp
.text:000088D9                 mov     ebp, esp
.text:000088DB                 push    ecx
.text:000088DC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000088E3                 mov     [ebp+var_4], ecx
.text:000088E6                 push    10h             ; unsigned int
.text:000088E8                 mov     ecx, [ebp+var_4] ; this
.text:000088EB                 call    ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z ; NWindows::NFile::NFind::CFileInfoBase::MatchesMask(uint)
.text:000088F0                 add     esp, 4
.text:000088F3                 cmp     ebp, esp
.text:000088F5                 call    __RTC_CheckEsp
.text:000088FA                 mov     esp, ebp
.text:000088FC                 pop     ebp
.text:000088FD                 retn
.text:000088FD ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ endp
.text:000088FD
.text:000088FD ; ---------------------------------------------------------------------------
.text:000088FE                 align 10h
.text:000088FE _text           ends
.text:000088FE
.text:00008900 ; ===========================================================================
.text:00008900
.text:00008900 ; Segment type: Pure code
.text:00008900 ; Segment permissions: Read/Execute
.text:00008900 _text           segment para public 'CODE' use32
.text:00008900                 assume cs:_text
.text:00008900                 ;org 8900h
.text:00008900 ; COMDAT (pick any)
.text:00008900                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008900
.text:00008900 ; =============== S U B R O U T I N E =======================================
.text:00008900
.text:00008900 ; Attributes: bp-based frame
.text:00008900
.text:00008900 ; bool __thiscall NWindows::NFile::NFind::CFileInfoBase::MatchesMask(NWindows::NFile::NFind::CFileInfoBase *this, unsigned int)
.text:00008900                 public ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z
.text:00008900 ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z proc near
.text:00008900                                         ; CODE XREF: NWindows::NFile::NFind::CFileInfoBase::IsDir(void)+13p
.text:00008900                                         ; NWindows::NFile::NFind::CFileInfoBase::IsReadOnly(void)+13p
.text:00008900
.text:00008900 var_4           = dword ptr -4
.text:00008900 arg_0           = dword ptr  8
.text:00008900
.text:00008900                 push    ebp
.text:00008901                 mov     ebp, esp
.text:00008903                 push    ecx
.text:00008904                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000890B                 mov     [ebp+var_4], ecx
.text:0000890E                 mov     eax, [ebp+var_4]
.text:00008911                 mov     eax, [eax+20h]
.text:00008914                 and     eax, [ebp+arg_0]
.text:00008917                 neg     eax
.text:00008919                 sbb     eax, eax
.text:0000891B                 neg     eax
.text:0000891D                 mov     esp, ebp
.text:0000891F                 pop     ebp
.text:00008920                 retn    4
.text:00008920 ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z endp
.text:00008920
.text:00008920 ; ---------------------------------------------------------------------------
.text:00008923                 align 4
.text:00008923 _text           ends
.text:00008923
.text:00008924 ; ===========================================================================
.text:00008924
.text:00008924 ; Segment type: Pure code
.text:00008924 ; Segment permissions: Read/Execute
.text:00008924 _text           segment para public 'CODE' use32
.text:00008924                 assume cs:_text
.text:00008924                 ;org 8924h
.text:00008924 ; COMDAT (pick any)
.text:00008924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008924
.text:00008924 ; =============== S U B R O U T I N E =======================================
.text:00008924
.text:00008924 ; Attributes: bp-based frame
.text:00008924
.text:00008924 ; bool __thiscall NWindows::NFile::NFind::CFileInfoBase::IsReadOnly(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
.text:00008924                 public ?IsReadOnly@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ
.text:00008924 ?IsReadOnly@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ proc near
.text:00008924                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2510p
.text:00008924
.text:00008924 var_4           = dword ptr -4
.text:00008924
.text:00008924                 push    ebp
.text:00008925                 mov     ebp, esp
.text:00008927                 push    ecx
.text:00008928                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000892F                 mov     [ebp+var_4], ecx
.text:00008932                 push    1               ; unsigned int
.text:00008934                 mov     ecx, [ebp+var_4] ; this
.text:00008937                 call    ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z ; NWindows::NFile::NFind::CFileInfoBase::MatchesMask(uint)
.text:0000893C                 add     esp, 4
.text:0000893F                 cmp     ebp, esp
.text:00008941                 call    __RTC_CheckEsp
.text:00008946                 mov     esp, ebp
.text:00008948                 pop     ebp
.text:00008949                 retn
.text:00008949 ?IsReadOnly@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ endp
.text:00008949
.text:00008949 ; ---------------------------------------------------------------------------
.text:0000894A                 align 4
.text:0000894A _text           ends
.text:0000894A
.text:0000894C ; ===========================================================================
.text:0000894C
.text:0000894C ; Segment type: Pure code
.text:0000894C ; Segment permissions: Read/Execute
.text:0000894C _text           segment para public 'CODE' use32
.text:0000894C                 assume cs:_text
.text:0000894C                 ;org 894Ch
.text:0000894C ; COMDAT (pick any)
.text:0000894C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000894C
.text:0000894C ; =============== S U B R O U T I N E =======================================
.text:0000894C
.text:0000894C ; Attributes: bp-based frame
.text:0000894C
.text:0000894C ; bool __thiscall COutFileStream::Open(COutFileStream *this, const wchar_t *, unsigned __int32)
.text:0000894C                 public ?Open@COutFileStream@@QAE_NPB_WK@Z
.text:0000894C ?Open@COutFileStream@@QAE_NPB_WK@Z proc near
.text:0000894C                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2F7Fp
.text:0000894C
.text:0000894C var_4           = dword ptr -4
.text:0000894C arg_0           = dword ptr  8
.text:0000894C arg_4           = dword ptr  0Ch
.text:0000894C
.text:0000894C                 push    ebp
.text:0000894D                 mov     ebp, esp
.text:0000894F                 push    ecx
.text:00008950                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008957                 mov     [ebp+var_4], ecx
.text:0000895A                 mov     eax, [ebp+var_4]
.text:0000895D                 mov     dword ptr [eax+18h], 0
.text:00008964                 mov     dword ptr [eax+1Ch], 0
.text:0000896B                 mov     ecx, [ebp+arg_4]
.text:0000896E                 push    ecx             ; unsigned __int32
.text:0000896F                 mov     edx, [ebp+arg_0]
.text:00008972                 push    edx             ; wchar_t *
.text:00008973                 mov     ecx, [ebp+var_4]
.text:00008976                 add     ecx, 8          ; this
.text:00008979                 call    ?Open@COutFile@NIO@NFile@NWindows@@QAE_NPB_WK@Z ; NWindows::NFile::NIO::COutFile::Open(wchar_t const *,ulong)
.text:0000897E                 add     esp, 4
.text:00008981                 cmp     ebp, esp
.text:00008983                 call    __RTC_CheckEsp
.text:00008988                 mov     esp, ebp
.text:0000898A                 pop     ebp
.text:0000898B                 retn    8
.text:0000898B ?Open@COutFileStream@@QAE_NPB_WK@Z endp
.text:0000898B
.text:0000898B ; ---------------------------------------------------------------------------
.text:0000898E                 align 10h
.text:0000898E _text           ends
.text:0000898E
.text:00008990 ; ===========================================================================
.text:00008990
.text:00008990 ; Segment type: Pure code
.text:00008990 ; Segment permissions: Read/Execute
.text:00008990 _text           segment para public 'CODE' use32
.text:00008990                 assume cs:_text
.text:00008990                 ;org 8990h
.text:00008990 ; COMDAT (pick any)
.text:00008990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008990
.text:00008990 ; =============== S U B R O U T I N E =======================================
.text:00008990
.text:00008990 ; Attributes: bp-based frame
.text:00008990
.text:00008990 ; public: __thiscall CStdOutFileStream::CStdOutFileStream(void)
.text:00008990                 public ??0CStdOutFileStream@@QAE@XZ
.text:00008990 ??0CStdOutFileStream@@QAE@XZ proc near  ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+FE7p
.text:00008990
.text:00008990 var_4           = dword ptr -4
.text:00008990
.text:00008990                 push    ebp
.text:00008991                 mov     ebp, esp
.text:00008993                 push    ecx
.text:00008994                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000899B                 mov     [ebp+var_4], ecx
.text:0000899E                 mov     ecx, [ebp+var_4] ; this
.text:000089A1                 call    ??0ISequentialOutStream@@QAE@XZ ; ISequentialOutStream::ISequentialOutStream(void)
.text:000089A6                 mov     ecx, [ebp+var_4]
.text:000089A9                 add     ecx, 4          ; this
.text:000089AC                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:000089B1                 mov     eax, [ebp+var_4]
.text:000089B4                 mov     dword ptr [eax], offset ??_7CStdOutFileStream@@6B@ ; const CStdOutFileStream::`vftable'
.text:000089BA                 mov     ecx, [ebp+var_4]
.text:000089BD                 mov     dword ptr [ecx+8], 0
.text:000089C4                 mov     dword ptr [ecx+0Ch], 0
.text:000089CB                 mov     eax, [ebp+var_4]
.text:000089CE                 add     esp, 4
.text:000089D1                 cmp     ebp, esp
.text:000089D3                 call    __RTC_CheckEsp
.text:000089D8                 mov     esp, ebp
.text:000089DA                 pop     ebp
.text:000089DB                 retn
.text:000089DB ??0CStdOutFileStream@@QAE@XZ endp
.text:000089DB
.text:000089DB _text           ends
.text:000089DB
.rdata:000089DC ; ===========================================================================
.rdata:000089DC
.rdata:000089DC ; Segment type: Pure data
.rdata:000089DC ; Segment permissions: Read
.rdata:000089DC _rdata          segment dword public 'DATA' use32
.rdata:000089DC                 assume cs:_rdata
.rdata:000089DC                 ;org 89DCh
.rdata:000089DC ; COMDAT (pick largest)
.rdata:000089DC                 dd offset ??_R4CStdOutFileStream@@6B@ ; const CStdOutFileStream::`RTTI Complete Object Locator'
.rdata:000089E0                 public ??_7CStdOutFileStream@@6B@
.rdata:000089E0 ; const CStdOutFileStream::`vftable'
.rdata:000089E0 ??_7CStdOutFileStream@@6B@ dd offset ?QueryInterface@CStdOutFileStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:000089E0                                         ; DATA XREF: CStdOutFileStream::CStdOutFileStream(void)+24o
.rdata:000089E0                                         ; CStdOutFileStream::~CStdOutFileStream(void)+11o
.rdata:000089E0                                         ; CStdOutFileStream::QueryInterface(_GUID const &,void * *)
.rdata:000089E4                 dd offset ?AddRef@CStdOutFileStream@@UAGKXZ ; CStdOutFileStream::AddRef(void)
.rdata:000089E8                 dd offset ?Release@CStdOutFileStream@@UAGKXZ ; CStdOutFileStream::Release(void)
.rdata:000089EC                 dd offset ?Write@CStdOutFileStream@@UAGJPBXIPAI@Z ; CStdOutFileStream::Write(void const *,uint,uint *)
.rdata:000089F0                 dd offset ??_ECStdOutFileStream@@UAEPAXI@Z ; CStdOutFileStream::`vector deleting destructor'(uint)
.rdata:000089F0 _rdata          ends
.rdata:000089F0
.rdata$r:000089F4 ; ===========================================================================
.rdata$r:000089F4
.rdata$r:000089F4 ; Segment type: Pure data
.rdata$r:000089F4 ; Segment permissions: Read
.rdata$r:000089F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000089F4                 assume cs:_rdata$r
.rdata$r:000089F4                 ;org 89F4h
.rdata$r:000089F4 ; COMDAT (pick any)
.rdata$r:000089F4                 public ??_R4CStdOutFileStream@@6B@
.rdata$r:000089F4 ; const CStdOutFileStream::`RTTI Complete Object Locator'
.rdata$r:000089F4 ??_R4CStdOutFileStream@@6B@ db    0     ; DATA XREF: .rdata:000089DCo
.rdata$r:000089F5                 db    0
.rdata$r:000089F6                 db    0
.rdata$r:000089F7                 db    0
.rdata$r:000089F8                 db    0
.rdata$r:000089F9                 db    0
.rdata$r:000089FA                 db    0
.rdata$r:000089FB                 db    0
.rdata$r:000089FC                 db    0
.rdata$r:000089FD                 db    0
.rdata$r:000089FE                 db    0
.rdata$r:000089FF                 db    0
.rdata$r:00008A00                 dd offset ??_R0?AVCStdOutFileStream@@@8 ; CStdOutFileStream `RTTI Type Descriptor'
.rdata$r:00008A04                 dd offset ??_R3CStdOutFileStream@@8 ; CStdOutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008A04 _rdata$r        ends
.rdata$r:00008A04
.data:00008A08 ; ===========================================================================
.data:00008A08
.data:00008A08 ; Segment type: Pure data
.data:00008A08 ; Segment permissions: Read/Write
.data:00008A08 _data           segment dword public 'DATA' use32
.data:00008A08                 assume cs:_data
.data:00008A08                 ;org 8A08h
.data:00008A08 ; COMDAT (pick any)
.data:00008A08                 public ??_R0?AVCStdOutFileStream@@@8
.data:00008A08 ; class CStdOutFileStream `RTTI Type Descriptor'
.data:00008A08 ??_R0?AVCStdOutFileStream@@@8 dd offset ??_7type_info@@6B@
.data:00008A08                                         ; DATA XREF: .rdata$r:00008A00o
.data:00008A08                                         ; .rdata$r:CStdOutFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00008A08                                         ; const type_info::`vftable'
.data:00008A0C                 align 10h
.data:00008A10 a_?avcstdoutfil db '.?AVCStdOutFileStream@@',0
.data:00008A10 _data           ends
.data:00008A10
.rdata$r:00008A28 ; ===========================================================================
.rdata$r:00008A28
.rdata$r:00008A28 ; Segment type: Pure data
.rdata$r:00008A28 ; Segment permissions: Read
.rdata$r:00008A28 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008A28                 assume cs:_rdata$r
.rdata$r:00008A28                 ;org 8A28h
.rdata$r:00008A28 ; COMDAT (pick any)
.rdata$r:00008A28                 public ??_R3CStdOutFileStream@@8
.rdata$r:00008A28 ; CStdOutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008A28 ??_R3CStdOutFileStream@@8 db    0       ; DATA XREF: .rdata$r:00008A04o
.rdata$r:00008A28                                         ; .rdata$r:00008A64o
.rdata$r:00008A29                 db    0
.rdata$r:00008A2A                 db    0
.rdata$r:00008A2B                 db    0
.rdata$r:00008A2C                 db    1
.rdata$r:00008A2D                 db    0
.rdata$r:00008A2E                 db    0
.rdata$r:00008A2F                 db    0
.rdata$r:00008A30                 db    4
.rdata$r:00008A31                 db    0
.rdata$r:00008A32                 db    0
.rdata$r:00008A33                 db    0
.rdata$r:00008A34                 dd offset ??_R2CStdOutFileStream@@8 ; CStdOutFileStream::`RTTI Base Class Array'
.rdata$r:00008A34 _rdata$r        ends
.rdata$r:00008A34
.rdata$r:00008A38 ; ===========================================================================
.rdata$r:00008A38
.rdata$r:00008A38 ; Segment type: Pure data
.rdata$r:00008A38 ; Segment permissions: Read
.rdata$r:00008A38 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008A38                 assume cs:_rdata$r
.rdata$r:00008A38                 ;org 8A38h
.rdata$r:00008A38 ; COMDAT (pick any)
.rdata$r:00008A38                 public ??_R2CStdOutFileStream@@8
.rdata$r:00008A38 ; CStdOutFileStream::`RTTI Base Class Array'
.rdata$r:00008A38 ??_R2CStdOutFileStream@@8 dd offset ??_R1A@?0A@EA@CStdOutFileStream@@8
.rdata$r:00008A38                                         ; DATA XREF: .rdata$r:00008A34o
.rdata$r:00008A38                                         ; CStdOutFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008A3C                 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008A40                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008A44                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:00008A48                 db    0
.rdata$r:00008A49                 align 4
.rdata$r:00008A49 _rdata$r        ends
.rdata$r:00008A49
.rdata$r:00008A4C ; ===========================================================================
.rdata$r:00008A4C
.rdata$r:00008A4C ; Segment type: Pure data
.rdata$r:00008A4C ; Segment permissions: Read
.rdata$r:00008A4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008A4C                 assume cs:_rdata$r
.rdata$r:00008A4C                 ;org 8A4Ch
.rdata$r:00008A4C ; COMDAT (pick any)
.rdata$r:00008A4C                 public ??_R1A@?0A@EA@CStdOutFileStream@@8
.rdata$r:00008A4C ; CStdOutFileStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00008A4C ??_R1A@?0A@EA@CStdOutFileStream@@8 dd offset ??_R0?AVCStdOutFileStream@@@8
.rdata$r:00008A4C                                         ; DATA XREF: .rdata$r:CStdOutFileStream::`RTTI Base Class Array'o
.rdata$r:00008A4C                                         ; CStdOutFileStream `RTTI Type Descriptor'
.rdata$r:00008A50                 db    3
.rdata$r:00008A51                 db    0
.rdata$r:00008A52                 db    0
.rdata$r:00008A53                 db    0
.rdata$r:00008A54                 db    0
.rdata$r:00008A55                 db    0
.rdata$r:00008A56                 db    0
.rdata$r:00008A57                 db    0
.rdata$r:00008A58                 db 0FFh
.rdata$r:00008A59                 db 0FFh
.rdata$r:00008A5A                 db 0FFh
.rdata$r:00008A5B                 db 0FFh
.rdata$r:00008A5C                 db    0
.rdata$r:00008A5D                 db    0
.rdata$r:00008A5E                 db    0
.rdata$r:00008A5F                 db    0
.rdata$r:00008A60                 db  40h ; @
.rdata$r:00008A61                 db    0
.rdata$r:00008A62                 db    0
.rdata$r:00008A63                 db    0
.rdata$r:00008A64                 dd offset ??_R3CStdOutFileStream@@8 ; CStdOutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008A64 _rdata$r        ends
.rdata$r:00008A64
.rdata$r:00008A68 ; ===========================================================================
.rdata$r:00008A68
.rdata$r:00008A68 ; Segment type: Pure data
.rdata$r:00008A68 ; Segment permissions: Read
.rdata$r:00008A68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008A68                 assume cs:_rdata$r
.rdata$r:00008A68                 ;org 8A68h
.rdata$r:00008A68 ; COMDAT (pick any)
.rdata$r:00008A68                 public ??_R1A@?0A@EA@ISequentialOutStream@@8
.rdata$r:00008A68 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00008A68 ??_R1A@?0A@EA@ISequentialOutStream@@8 dd offset ??_R0?AUISequentialOutStream@@@8
.rdata$r:00008A68                                         ; DATA XREF: .rdata$r:00008A3Co
.rdata$r:00008A68                                         ; .rdata$r:ISequentialOutStream::`RTTI Base Class Array'o ...
.rdata$r:00008A68                                         ; ISequentialOutStream `RTTI Type Descriptor'
.rdata$r:00008A6C                 db    1
.rdata$r:00008A6D                 db    0
.rdata$r:00008A6E                 db    0
.rdata$r:00008A6F                 db    0
.rdata$r:00008A70                 db    0
.rdata$r:00008A71                 db    0
.rdata$r:00008A72                 db    0
.rdata$r:00008A73                 db    0
.rdata$r:00008A74                 db 0FFh
.rdata$r:00008A75                 db 0FFh
.rdata$r:00008A76                 db 0FFh
.rdata$r:00008A77                 db 0FFh
.rdata$r:00008A78                 db    0
.rdata$r:00008A79                 db    0
.rdata$r:00008A7A                 db    0
.rdata$r:00008A7B                 db    0
.rdata$r:00008A7C                 db  40h ; @
.rdata$r:00008A7D                 db    0
.rdata$r:00008A7E                 db    0
.rdata$r:00008A7F                 db    0
.rdata$r:00008A80                 dd offset ??_R3ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008A80 _rdata$r        ends
.rdata$r:00008A80
.data:00008A84 ; ===========================================================================
.data:00008A84
.data:00008A84 ; Segment type: Pure data
.data:00008A84 ; Segment permissions: Read/Write
.data:00008A84 _data           segment dword public 'DATA' use32
.data:00008A84                 assume cs:_data
.data:00008A84                 ;org 8A84h
.data:00008A84 ; COMDAT (pick any)
.data:00008A84                 public ??_R0?AUISequentialOutStream@@@8
.data:00008A84 ; struct ISequentialOutStream `RTTI Type Descriptor'
.data:00008A84 ??_R0?AUISequentialOutStream@@@8 dd offset ??_7type_info@@6B@
.data:00008A84                                         ; DATA XREF: .rdata$r:ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00008A84                                         ; .rdata$r:00008C88o
.data:00008A84                                         ; const type_info::`vftable'
.data:00008A88                 db    0
.data:00008A89                 db    0
.data:00008A8A                 db    0
.data:00008A8B                 db    0
.data:00008A8C                 db  2Eh ; .
.data:00008A8D                 db  3Fh ; ?
.data:00008A8E                 db  41h ; A
.data:00008A8F                 db  55h ; U
.data:00008A90                 db  49h ; I
.data:00008A91                 db  53h ; S
.data:00008A92                 db  65h ; e
.data:00008A93                 db  71h ; q
.data:00008A94                 db  75h ; u
.data:00008A95                 db  65h ; e
.data:00008A96                 db  6Eh ; n
.data:00008A97                 db  74h ; t
.data:00008A98                 db  69h ; i
.data:00008A99                 db  61h ; a
.data:00008A9A                 db  6Ch ; l
.data:00008A9B                 db  4Fh ; O
.data:00008A9C                 db  75h ; u
.data:00008A9D                 db  74h ; t
.data:00008A9E                 db  53h ; S
.data:00008A9F                 db  74h ; t
.data:00008AA0                 db  72h ; r
.data:00008AA1                 db  65h ; e
.data:00008AA2                 db  61h ; a
.data:00008AA3                 db  6Dh ; m
.data:00008AA4                 db  40h ; @
.data:00008AA5                 db  40h ; @
.data:00008AA6                 db    0
.data:00008AA7                 align 4
.data:00008AA7 _data           ends
.data:00008AA7
.rdata$r:00008AA8 ; ===========================================================================
.rdata$r:00008AA8
.rdata$r:00008AA8 ; Segment type: Pure data
.rdata$r:00008AA8 ; Segment permissions: Read
.rdata$r:00008AA8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008AA8                 assume cs:_rdata$r
.rdata$r:00008AA8                 ;org 8AA8h
.rdata$r:00008AA8 ; COMDAT (pick any)
.rdata$r:00008AA8                 public ??_R3ISequentialOutStream@@8
.rdata$r:00008AA8 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008AA8 ??_R3ISequentialOutStream@@8 db    0    ; DATA XREF: .rdata$r:00008A80o
.rdata$r:00008AA8                                         ; .rdata$r:00008C8Co
.rdata$r:00008AA9                 db    0
.rdata$r:00008AAA                 db    0
.rdata$r:00008AAB                 db    0
.rdata$r:00008AAC                 db    0
.rdata$r:00008AAD                 db    0
.rdata$r:00008AAE                 db    0
.rdata$r:00008AAF                 db    0
.rdata$r:00008AB0                 db    2
.rdata$r:00008AB1                 db    0
.rdata$r:00008AB2                 db    0
.rdata$r:00008AB3                 db    0
.rdata$r:00008AB4                 dd offset ??_R2ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Array'
.rdata$r:00008AB4 _rdata$r        ends
.rdata$r:00008AB4
.rdata$r:00008AB8 ; ===========================================================================
.rdata$r:00008AB8
.rdata$r:00008AB8 ; Segment type: Pure data
.rdata$r:00008AB8 ; Segment permissions: Read
.rdata$r:00008AB8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008AB8                 assume cs:_rdata$r
.rdata$r:00008AB8                 ;org 8AB8h
.rdata$r:00008AB8 ; COMDAT (pick any)
.rdata$r:00008AB8                 public ??_R2ISequentialOutStream@@8
.rdata$r:00008AB8 ; ISequentialOutStream::`RTTI Base Class Array'
.rdata$r:00008AB8 ??_R2ISequentialOutStream@@8 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8
.rdata$r:00008AB8                                         ; DATA XREF: .rdata$r:00008AB4o
.rdata$r:00008AB8                                         ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008ABC                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008AC0                 db    0
.rdata$r:00008AC1                 align 4
.rdata$r:00008AC1 _rdata$r        ends
.rdata$r:00008AC1
.rdata$r:00008AC4 ; ===========================================================================
.rdata$r:00008AC4
.rdata$r:00008AC4 ; Segment type: Pure data
.rdata$r:00008AC4 ; Segment permissions: Read
.rdata$r:00008AC4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008AC4                 assume cs:_rdata$r
.rdata$r:00008AC4                 ;org 8AC4h
.rdata$r:00008AC4 ; COMDAT (pick any)
.rdata$r:00008AC4                 public ??_R13?0A@EA@CMyUnknownImp@@8
.rdata$r:00008AC4 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:00008AC4 ??_R13?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:00008AC4                                         ; DATA XREF: .rdata$r:00008A44o
.rdata$r:00008AC4                                         ; .rdata$r:000090B8o ...
.rdata$r:00008AC4                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:00008AC8                 db    0
.rdata$r:00008AC9                 db    0
.rdata$r:00008ACA                 db    0
.rdata$r:00008ACB                 db    0
.rdata$r:00008ACC                 db    4
.rdata$r:00008ACD                 db    0
.rdata$r:00008ACE                 db    0
.rdata$r:00008ACF                 db    0
.rdata$r:00008AD0                 db 0FFh
.rdata$r:00008AD1                 db 0FFh
.rdata$r:00008AD2                 db 0FFh
.rdata$r:00008AD3                 db 0FFh
.rdata$r:00008AD4                 db    0
.rdata$r:00008AD5                 db    0
.rdata$r:00008AD6                 db    0
.rdata$r:00008AD7                 db    0
.rdata$r:00008AD8                 db  40h ; @
.rdata$r:00008AD9                 db    0
.rdata$r:00008ADA                 db    0
.rdata$r:00008ADB                 db    0
.rdata$r:00008ADC                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008ADC _rdata$r        ends
.rdata$r:00008ADC
.text:00008AE0 ; ===========================================================================
.text:00008AE0
.text:00008AE0 ; Segment type: Pure code
.text:00008AE0 ; Segment permissions: Read/Execute
.text:00008AE0 _text           segment para public 'CODE' use32
.text:00008AE0                 assume cs:_text
.text:00008AE0                 ;org 8AE0h
.text:00008AE0 ; COMDAT (pick any)
.text:00008AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008AE0
.text:00008AE0 ; =============== S U B R O U T I N E =======================================
.text:00008AE0
.text:00008AE0 ; Attributes: bp-based frame
.text:00008AE0
.text:00008AE0 ; __int32 __stdcall CStdOutFileStream::QueryInterface(CStdOutFileStream *this, const struct _GUID *Buf1, void **)
.text:00008AE0                 public ?QueryInterface@CStdOutFileStream@@UAGJABU_GUID@@PAPAX@Z
.text:00008AE0 ?QueryInterface@CStdOutFileStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00008AE0                                         ; DATA XREF: .rdata:const CStdOutFileStream::`vftable'o
.text:00008AE0
.text:00008AE0 this            = dword ptr  8
.text:00008AE0 Buf1            = dword ptr  0Ch
.text:00008AE0 arg_8           = dword ptr  10h
.text:00008AE0
.text:00008AE0                 push    ebp
.text:00008AE1                 mov     ebp, esp
.text:00008AE3                 mov     eax, [ebp+arg_8]
.text:00008AE6                 mov     dword ptr [eax], 0
.text:00008AEC                 push    offset _IID_IUnknown ; Buf2
.text:00008AF1                 mov     ecx, [ebp+Buf1]
.text:00008AF4                 push    ecx             ; Buf1
.text:00008AF5                 call    ___@8           ; __(x,x)
.text:00008AFA                 test    eax, eax
.text:00008AFC                 jz      short loc_8B08
.text:00008AFE                 mov     edx, [ebp+arg_8]
.text:00008B01                 mov     eax, [ebp+this]
.text:00008B04                 mov     [edx], eax
.text:00008B06                 jmp     short loc_8B0F
.text:00008B08 ; ---------------------------------------------------------------------------
.text:00008B08
.text:00008B08 loc_8B08:                               ; CODE XREF: CStdOutFileStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:00008B08                 mov     eax, 80004002h
.text:00008B0D                 jmp     short loc_8B20
.text:00008B0F ; ---------------------------------------------------------------------------
.text:00008B0F
.text:00008B0F loc_8B0F:                               ; CODE XREF: CStdOutFileStream::QueryInterface(_GUID const &,void * *)+26j
.text:00008B0F                 mov     ecx, [ebp+this]
.text:00008B12                 mov     edx, [ecx+4]
.text:00008B15                 add     edx, 1
.text:00008B18                 mov     eax, [ebp+this]
.text:00008B1B                 mov     [eax+4], edx
.text:00008B1E                 xor     eax, eax
.text:00008B20
.text:00008B20 loc_8B20:                               ; CODE XREF: CStdOutFileStream::QueryInterface(_GUID const &,void * *)+2Dj
.text:00008B20                 cmp     ebp, esp
.text:00008B22                 call    __RTC_CheckEsp
.text:00008B27                 pop     ebp
.text:00008B28                 retn    0Ch
.text:00008B28 ?QueryInterface@CStdOutFileStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:00008B28
.text:00008B28 ; ---------------------------------------------------------------------------
.text:00008B2B                 align 4
.text:00008B2B _text           ends
.text:00008B2B
.text:00008B2C ; ===========================================================================
.text:00008B2C
.text:00008B2C ; Segment type: Pure code
.text:00008B2C ; Segment permissions: Read/Execute
.text:00008B2C _text           segment para public 'CODE' use32
.text:00008B2C                 assume cs:_text
.text:00008B2C                 ;org 8B2Ch
.text:00008B2C ; COMDAT (pick any)
.text:00008B2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008B2C
.text:00008B2C ; =============== S U B R O U T I N E =======================================
.text:00008B2C
.text:00008B2C ; Attributes: bp-based frame
.text:00008B2C
.text:00008B2C ; unsigned __int32 __stdcall CStdOutFileStream::AddRef(CStdOutFileStream *this)
.text:00008B2C                 public ?AddRef@CStdOutFileStream@@UAGKXZ
.text:00008B2C ?AddRef@CStdOutFileStream@@UAGKXZ proc near ; DATA XREF: .rdata:000089E4o
.text:00008B2C
.text:00008B2C var_4           = dword ptr -4
.text:00008B2C this            = dword ptr  8
.text:00008B2C
.text:00008B2C                 push    ebp
.text:00008B2D                 mov     ebp, esp
.text:00008B2F                 push    ecx
.text:00008B30                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008B37                 mov     eax, [ebp+this]
.text:00008B3A                 mov     ecx, [eax+4]
.text:00008B3D                 add     ecx, 1
.text:00008B40                 mov     [ebp+var_4], ecx
.text:00008B43                 mov     edx, [ebp+this]
.text:00008B46                 mov     eax, [ebp+var_4]
.text:00008B49                 mov     [edx+4], eax
.text:00008B4C                 mov     eax, [ebp+var_4]
.text:00008B4F                 mov     esp, ebp
.text:00008B51                 pop     ebp
.text:00008B52                 retn    4
.text:00008B52 ?AddRef@CStdOutFileStream@@UAGKXZ endp
.text:00008B52
.text:00008B52 ; ---------------------------------------------------------------------------
.text:00008B55                 align 4
.text:00008B55 _text           ends
.text:00008B55
.text:00008B58 ; ===========================================================================
.text:00008B58
.text:00008B58 ; Segment type: Pure code
.text:00008B58 ; Segment permissions: Read/Execute
.text:00008B58 _text           segment para public 'CODE' use32
.text:00008B58                 assume cs:_text
.text:00008B58                 ;org 8B58h
.text:00008B58 ; COMDAT (pick any)
.text:00008B58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008B58
.text:00008B58 ; =============== S U B R O U T I N E =======================================
.text:00008B58
.text:00008B58 ; Attributes: bp-based frame
.text:00008B58
.text:00008B58 ; unsigned __int32 __stdcall CStdOutFileStream::Release(CStdOutFileStream *this)
.text:00008B58                 public ?Release@CStdOutFileStream@@UAGKXZ
.text:00008B58 ?Release@CStdOutFileStream@@UAGKXZ proc near ; DATA XREF: .rdata:000089E8o
.text:00008B58
.text:00008B58 var_10          = dword ptr -10h
.text:00008B58 var_C           = dword ptr -0Ch
.text:00008B58 var_8           = dword ptr -8
.text:00008B58 var_4           = dword ptr -4
.text:00008B58 this            = dword ptr  8
.text:00008B58
.text:00008B58                 push    ebp
.text:00008B59                 mov     ebp, esp
.text:00008B5B                 sub     esp, 10h
.text:00008B5E                 push    esi
.text:00008B5F                 mov     eax, 0CCCCCCCCh
.text:00008B64                 mov     [ebp+var_10], eax
.text:00008B67                 mov     [ebp+var_C], eax
.text:00008B6A                 mov     [ebp+var_8], eax
.text:00008B6D                 mov     [ebp+var_4], eax
.text:00008B70                 mov     eax, [ebp+this]
.text:00008B73                 mov     ecx, [eax+4]
.text:00008B76                 sub     ecx, 1
.text:00008B79                 mov     [ebp+var_C], ecx
.text:00008B7C                 mov     edx, [ebp+this]
.text:00008B7F                 mov     eax, [ebp+var_C]
.text:00008B82                 mov     [edx+4], eax
.text:00008B85                 cmp     [ebp+var_C], 0
.text:00008B89                 jz      short loc_8B93
.text:00008B8B                 mov     ecx, [ebp+this]
.text:00008B8E                 mov     eax, [ecx+4]
.text:00008B91                 jmp     short loc_8BCB
.text:00008B93 ; ---------------------------------------------------------------------------
.text:00008B93
.text:00008B93 loc_8B93:                               ; CODE XREF: CStdOutFileStream::Release(void)+31j
.text:00008B93                 mov     edx, [ebp+this]
.text:00008B96                 mov     [ebp+var_8], edx
.text:00008B99                 mov     eax, [ebp+var_8]
.text:00008B9C                 mov     [ebp+var_4], eax
.text:00008B9F                 cmp     [ebp+var_4], 0
.text:00008BA3                 jz      short loc_8BC2
.text:00008BA5                 mov     esi, esp
.text:00008BA7                 push    1
.text:00008BA9                 mov     ecx, [ebp+var_4]
.text:00008BAC                 mov     edx, [ecx]
.text:00008BAE                 mov     ecx, [ebp+var_4]
.text:00008BB1                 mov     eax, [edx+10h]
.text:00008BB4                 call    eax
.text:00008BB6                 cmp     esi, esp
.text:00008BB8                 call    __RTC_CheckEsp
.text:00008BBD                 mov     [ebp+var_10], eax
.text:00008BC0                 jmp     short loc_8BC9
.text:00008BC2 ; ---------------------------------------------------------------------------
.text:00008BC2
.text:00008BC2 loc_8BC2:                               ; CODE XREF: CStdOutFileStream::Release(void)+4Bj
.text:00008BC2                 mov     [ebp+var_10], 0
.text:00008BC9
.text:00008BC9 loc_8BC9:                               ; CODE XREF: CStdOutFileStream::Release(void)+68j
.text:00008BC9                 xor     eax, eax
.text:00008BCB
.text:00008BCB loc_8BCB:                               ; CODE XREF: CStdOutFileStream::Release(void)+39j
.text:00008BCB                 pop     esi
.text:00008BCC                 add     esp, 10h
.text:00008BCF                 cmp     ebp, esp
.text:00008BD1                 call    __RTC_CheckEsp
.text:00008BD6                 mov     esp, ebp
.text:00008BD8                 pop     ebp
.text:00008BD9                 retn    4
.text:00008BD9 ?Release@CStdOutFileStream@@UAGKXZ endp
.text:00008BD9
.text:00008BD9 _text           ends
.text:00008BD9
.text:00008BDC ; ===========================================================================
.text:00008BDC
.text:00008BDC ; Segment type: Pure code
.text:00008BDC ; Segment permissions: Read/Execute
.text:00008BDC _text           segment para public 'CODE' use32
.text:00008BDC                 assume cs:_text
.text:00008BDC                 ;org 8BDCh
.text:00008BDC ; COMDAT (pick any)
.text:00008BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008BDC
.text:00008BDC ; =============== S U B R O U T I N E =======================================
.text:00008BDC
.text:00008BDC ; Attributes: bp-based frame
.text:00008BDC
.text:00008BDC ; public: virtual void * __thiscall CStdOutFileStream::`scalar deleting destructor'(unsigned int)
.text:00008BDC                 public ??_GCStdOutFileStream@@UAEPAXI@Z
.text:00008BDC ??_GCStdOutFileStream@@UAEPAXI@Z proc near
.text:00008BDC
.text:00008BDC var_4           = dword ptr -4
.text:00008BDC arg_0           = dword ptr  8
.text:00008BDC
.text:00008BDC                 push    ebp
.text:00008BDD                 mov     ebp, esp
.text:00008BDF                 push    ecx
.text:00008BE0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008BE7                 mov     [ebp+var_4], ecx
.text:00008BEA                 mov     ecx, [ebp+var_4] ; this
.text:00008BED                 call    ??1CStdOutFileStream@@UAE@XZ ; CStdOutFileStream::~CStdOutFileStream(void)
.text:00008BF2                 mov     eax, [ebp+arg_0]
.text:00008BF5                 and     eax, 1
.text:00008BF8                 jz      short loc_8C06
.text:00008BFA                 mov     ecx, [ebp+var_4]
.text:00008BFD                 push    ecx             ; void *
.text:00008BFE                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00008C03                 add     esp, 4
.text:00008C06
.text:00008C06 loc_8C06:                               ; CODE XREF: CStdOutFileStream::`scalar deleting destructor'(uint)+1Cj
.text:00008C06                 mov     eax, [ebp+var_4]
.text:00008C09                 add     esp, 4
.text:00008C0C                 cmp     ebp, esp
.text:00008C0E                 call    __RTC_CheckEsp
.text:00008C13                 mov     esp, ebp
.text:00008C15                 pop     ebp
.text:00008C16                 retn    4
.text:00008C16 ??_GCStdOutFileStream@@UAEPAXI@Z endp
.text:00008C16
.text:00008C16 ; ---------------------------------------------------------------------------
.text:00008C19                 align 4
.text:00008C19 _text           ends
.text:00008C19
.text:00008C1C ; ===========================================================================
.text:00008C1C
.text:00008C1C ; Segment type: Pure code
.text:00008C1C ; Segment permissions: Read/Execute
.text:00008C1C _text           segment para public 'CODE' use32
.text:00008C1C                 assume cs:_text
.text:00008C1C                 ;org 8C1Ch
.text:00008C1C ; COMDAT (pick any)
.text:00008C1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008C1C
.text:00008C1C ; =============== S U B R O U T I N E =======================================
.text:00008C1C
.text:00008C1C ; Attributes: bp-based frame
.text:00008C1C
.text:00008C1C ; _DWORD __thiscall CStdOutFileStream::~CStdOutFileStream(CStdOutFileStream *__hidden this)
.text:00008C1C                 public ??1CStdOutFileStream@@UAE@XZ
.text:00008C1C ??1CStdOutFileStream@@UAE@XZ proc near  ; CODE XREF: CStdOutFileStream::`scalar deleting destructor'(uint)+11p
.text:00008C1C
.text:00008C1C var_4           = dword ptr -4
.text:00008C1C
.text:00008C1C                 push    ebp
.text:00008C1D                 mov     ebp, esp
.text:00008C1F                 push    ecx
.text:00008C20                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008C27                 mov     [ebp+var_4], ecx
.text:00008C2A                 mov     eax, [ebp+var_4]
.text:00008C2D                 mov     dword ptr [eax], offset ??_7CStdOutFileStream@@6B@ ; const CStdOutFileStream::`vftable'
.text:00008C33                 mov     esp, ebp
.text:00008C35                 pop     ebp
.text:00008C36                 retn
.text:00008C36 ??1CStdOutFileStream@@UAE@XZ endp
.text:00008C36
.text:00008C36 ; ---------------------------------------------------------------------------
.text:00008C37                 align 4
.text:00008C37 _text           ends
.text:00008C37
.text:00008C38 ; ===========================================================================
.text:00008C38
.text:00008C38 ; Segment type: Pure code
.text:00008C38 ; Segment permissions: Read/Execute
.text:00008C38 _text           segment para public 'CODE' use32
.text:00008C38                 assume cs:_text
.text:00008C38                 ;org 8C38h
.text:00008C38 ; COMDAT (pick any)
.text:00008C38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008C38
.text:00008C38 ; =============== S U B R O U T I N E =======================================
.text:00008C38
.text:00008C38 ; Attributes: bp-based frame
.text:00008C38
.text:00008C38 ; _DWORD __thiscall ISequentialOutStream::ISequentialOutStream(ISequentialOutStream *__hidden this)
.text:00008C38                 public ??0ISequentialOutStream@@QAE@XZ
.text:00008C38 ??0ISequentialOutStream@@QAE@XZ proc near
.text:00008C38                                         ; CODE XREF: CStdOutFileStream::CStdOutFileStream(void)+11p
.text:00008C38                                         ; IOutStream::IOutStream(void)+11p
.text:00008C38
.text:00008C38 var_4           = dword ptr -4
.text:00008C38
.text:00008C38                 push    ebp
.text:00008C39                 mov     ebp, esp
.text:00008C3B                 push    ecx
.text:00008C3C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008C43                 mov     [ebp+var_4], ecx
.text:00008C46                 mov     ecx, [ebp+var_4]
.text:00008C49                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00008C4E                 mov     eax, [ebp+var_4]
.text:00008C51                 mov     dword ptr [eax], offset ??_7ISequentialOutStream@@6B@ ; const ISequentialOutStream::`vftable'
.text:00008C57                 mov     eax, [ebp+var_4]
.text:00008C5A                 add     esp, 4
.text:00008C5D                 cmp     ebp, esp
.text:00008C5F                 call    __RTC_CheckEsp
.text:00008C64                 mov     esp, ebp
.text:00008C66                 pop     ebp
.text:00008C67                 retn
.text:00008C67 ??0ISequentialOutStream@@QAE@XZ endp
.text:00008C67
.text:00008C67 _text           ends
.text:00008C67
.rdata:00008C68 ; ===========================================================================
.rdata:00008C68
.rdata:00008C68 ; Segment type: Pure data
.rdata:00008C68 ; Segment permissions: Read
.rdata:00008C68 _rdata          segment dword public 'DATA' use32
.rdata:00008C68                 assume cs:_rdata
.rdata:00008C68                 ;org 8C68h
.rdata:00008C68 ; COMDAT (pick largest)
.rdata:00008C68                 dd offset ??_R4ISequentialOutStream@@6B@ ; const ISequentialOutStream::`RTTI Complete Object Locator'
.rdata:00008C6C                 public ??_7ISequentialOutStream@@6B@
.rdata:00008C6C ; const ISequentialOutStream::`vftable'
.rdata:00008C6C ??_7ISequentialOutStream@@6B@ dd offset __purecall
.rdata:00008C6C                                         ; DATA XREF: ISequentialOutStream::ISequentialOutStream(void)+19o
.rdata:00008C70                 dd offset __purecall
.rdata:00008C74                 dd offset __purecall
.rdata:00008C78                 dd offset __purecall
.rdata:00008C78 _rdata          ends
.rdata:00008C78
.rdata$r:00008C7C ; ===========================================================================
.rdata$r:00008C7C
.rdata$r:00008C7C ; Segment type: Pure data
.rdata$r:00008C7C ; Segment permissions: Read
.rdata$r:00008C7C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008C7C                 assume cs:_rdata$r
.rdata$r:00008C7C                 ;org 8C7Ch
.rdata$r:00008C7C ; COMDAT (pick any)
.rdata$r:00008C7C                 public ??_R4ISequentialOutStream@@6B@
.rdata$r:00008C7C ; const ISequentialOutStream::`RTTI Complete Object Locator'
.rdata$r:00008C7C ??_R4ISequentialOutStream@@6B@ db    0  ; DATA XREF: .rdata:00008C68o
.rdata$r:00008C7D                 db    0
.rdata$r:00008C7E                 db    0
.rdata$r:00008C7F                 db    0
.rdata$r:00008C80                 db    0
.rdata$r:00008C81                 db    0
.rdata$r:00008C82                 db    0
.rdata$r:00008C83                 db    0
.rdata$r:00008C84                 db    0
.rdata$r:00008C85                 db    0
.rdata$r:00008C86                 db    0
.rdata$r:00008C87                 db    0
.rdata$r:00008C88                 dd offset ??_R0?AUISequentialOutStream@@@8 ; ISequentialOutStream `RTTI Type Descriptor'
.rdata$r:00008C8C                 dd offset ??_R3ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008C8C _rdata$r        ends
.rdata$r:00008C8C
.text:00008C90 ; ===========================================================================
.text:00008C90
.text:00008C90 ; Segment type: Pure code
.text:00008C90 ; Segment permissions: Read/Execute
.text:00008C90 _text           segment para public 'CODE' use32
.text:00008C90                 assume cs:_text
.text:00008C90                 ;org 8C90h
.text:00008C90 ; COMDAT (pick any)
.text:00008C90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008C90
.text:00008C90 ; =============== S U B R O U T I N E =======================================
.text:00008C90
.text:00008C90 ; Attributes: bp-based frame
.text:00008C90
.text:00008C90 ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfo::CFileInfo(NWindows::NFile::NFind::CFileInfo *__hidden this)
.text:00008C90                 public ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ
.text:00008C90 ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ proc near
.text:00008C90                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+191Ap
.text:00008C90                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+24C7p
.text:00008C90
.text:00008C90 var_4           = dword ptr -4
.text:00008C90
.text:00008C90                 push    ebp
.text:00008C91                 mov     ebp, esp
.text:00008C93                 push    ecx
.text:00008C94                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008C9B                 mov     [ebp+var_4], ecx
.text:00008C9E                 mov     ecx, [ebp+var_4] ; this
.text:00008CA1                 call    ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(void)
.text:00008CA6                 mov     ecx, [ebp+var_4]
.text:00008CA9                 add     ecx, 28h ; '('
.text:00008CAC                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00008CB1                 mov     eax, [ebp+var_4]
.text:00008CB4                 add     esp, 4
.text:00008CB7                 cmp     ebp, esp
.text:00008CB9                 call    __RTC_CheckEsp
.text:00008CBE                 mov     esp, ebp
.text:00008CC0                 pop     ebp
.text:00008CC1                 retn
.text:00008CC1 ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ endp
.text:00008CC1
.text:00008CC1 ; ---------------------------------------------------------------------------
.text:00008CC2                 align 4
.text:00008CC2 _text           ends
.text:00008CC2
.text:00008CC4 ; ===========================================================================
.text:00008CC4
.text:00008CC4 ; Segment type: Pure code
.text:00008CC4 ; Segment permissions: Read/Execute
.text:00008CC4 _text           segment para public 'CODE' use32
.text:00008CC4                 assume cs:_text
.text:00008CC4                 ;org 8CC4h
.text:00008CC4 ; COMDAT (pick any)
.text:00008CC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008CC4
.text:00008CC4 ; =============== S U B R O U T I N E =======================================
.text:00008CC4
.text:00008CC4 ; Attributes: bp-based frame
.text:00008CC4
.text:00008CC4 ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
.text:00008CC4                 public ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ
.text:00008CC4 ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ proc near
.text:00008CC4                                         ; CODE XREF: NWindows::NFile::NFind::CFileInfo::CFileInfo(void)+11p
.text:00008CC4
.text:00008CC4 var_4           = dword ptr -4
.text:00008CC4
.text:00008CC4                 push    ebp
.text:00008CC5                 mov     ebp, esp
.text:00008CC7                 push    ecx
.text:00008CC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008CCF                 mov     [ebp+var_4], ecx
.text:00008CD2                 mov     ecx, [ebp+var_4] ; this
.text:00008CD5                 call    ?ClearBase@CFileInfoBase@NFind@NFile@NWindows@@QAEXXZ ; NWindows::NFile::NFind::CFileInfoBase::ClearBase(void)
.text:00008CDA                 mov     eax, [ebp+var_4]
.text:00008CDD                 add     esp, 4
.text:00008CE0                 cmp     ebp, esp
.text:00008CE2                 call    __RTC_CheckEsp
.text:00008CE7                 mov     esp, ebp
.text:00008CE9                 pop     ebp
.text:00008CEA                 retn
.text:00008CEA ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ endp
.text:00008CEA
.text:00008CEA ; ---------------------------------------------------------------------------
.text:00008CEB                 align 4
.text:00008CEB _text           ends
.text:00008CEB
.text:00008CEC ; ===========================================================================
.text:00008CEC
.text:00008CEC ; Segment type: Pure code
.text:00008CEC ; Segment permissions: Read/Execute
.text:00008CEC _text           segment para public 'CODE' use32
.text:00008CEC                 assume cs:_text
.text:00008CEC                 ;org 8CECh
.text:00008CEC ; COMDAT (pick any)
.text:00008CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008CEC
.text:00008CEC ; =============== S U B R O U T I N E =======================================
.text:00008CEC
.text:00008CEC ; Attributes: bp-based frame
.text:00008CEC
.text:00008CEC ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfo::~CFileInfo(NWindows::NFile::NFind::CFileInfo *__hidden this)
.text:00008CEC                 public ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ
.text:00008CEC ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ proc near
.text:00008CEC                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1998p
.text:00008CEC                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1B70p ...
.text:00008CEC
.text:00008CEC var_4           = dword ptr -4
.text:00008CEC
.text:00008CEC                 push    ebp
.text:00008CED                 mov     ebp, esp
.text:00008CEF                 push    ecx
.text:00008CF0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008CF7                 mov     [ebp+var_4], ecx
.text:00008CFA                 mov     ecx, [ebp+var_4]
.text:00008CFD                 add     ecx, 28h ; '('  ; this
.text:00008D00                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00008D05                 add     esp, 4
.text:00008D08                 cmp     ebp, esp
.text:00008D0A                 call    __RTC_CheckEsp
.text:00008D0F                 mov     esp, ebp
.text:00008D11                 pop     ebp
.text:00008D12                 retn
.text:00008D12 ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ endp
.text:00008D12
.text:00008D12 ; ---------------------------------------------------------------------------
.text:00008D13                 align 4
.text:00008D13 _text           ends
.text:00008D13
.text:00008D14 ; ===========================================================================
.text:00008D14
.text:00008D14 ; Segment type: Pure code
.text:00008D14 ; Segment permissions: Read/Execute
.text:00008D14 _text           segment para public 'CODE' use32
.text:00008D14                 assume cs:_text
.text:00008D14                 ;org 8D14h
.text:00008D14 ; COMDAT (pick any)
.text:00008D14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008D14
.text:00008D14 ; =============== S U B R O U T I N E =======================================
.text:00008D14
.text:00008D14 ; Attributes: bp-based frame
.text:00008D14
.text:00008D14 ; __int32 __thiscall CArc::IsItemAnti(CArc *this, unsigned int, bool *)
.text:00008D14                 public ?IsItemAnti@CArc@@QBEJIAA_N@Z
.text:00008D14 ?IsItemAnti@CArc@@QBEJIAA_N@Z proc near ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+12B5p
.text:00008D14
.text:00008D14 var_4           = dword ptr -4
.text:00008D14 arg_0           = dword ptr  8
.text:00008D14 arg_4           = dword ptr  0Ch
.text:00008D14
.text:00008D14                 push    ebp
.text:00008D15                 mov     ebp, esp
.text:00008D17                 push    ecx
.text:00008D18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008D1F                 mov     [ebp+var_4], ecx
.text:00008D22                 mov     eax, [ebp+arg_4]
.text:00008D25                 push    eax             ; bool *
.text:00008D26                 push    15h             ; unsigned __int32
.text:00008D28                 mov     ecx, [ebp+arg_0]
.text:00008D2B                 push    ecx             ; unsigned int
.text:00008D2C                 mov     ecx, [ebp+var_4]
.text:00008D2F                 call    ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ ; CMyComPtr<IInArchive>::operator IInArchive *(void)
.text:00008D34                 push    eax             ; struct IInArchive *
.text:00008D35                 call    ?Archive_GetItemBoolProp@@YGJPAUIInArchive@@IKAA_N@Z ; Archive_GetItemBoolProp(IInArchive *,uint,ulong,bool &)
.text:00008D3A                 add     esp, 4
.text:00008D3D                 cmp     ebp, esp
.text:00008D3F                 call    __RTC_CheckEsp
.text:00008D44                 mov     esp, ebp
.text:00008D46                 pop     ebp
.text:00008D47                 retn    8
.text:00008D47 ?IsItemAnti@CArc@@QBEJIAA_N@Z endp
.text:00008D47
.text:00008D47 ; ---------------------------------------------------------------------------
.text:00008D4A                 align 4
.text:00008D4A _text           ends
.text:00008D4A
.text:00008D4C ; ===========================================================================
.text:00008D4C
.text:00008D4C ; Segment type: Pure code
.text:00008D4C ; Segment permissions: Read/Execute
.text:00008D4C _text           segment para public 'CODE' use32
.text:00008D4C                 assume cs:_text
.text:00008D4C                 ;org 8D4Ch
.text:00008D4C ; COMDAT (pick any)
.text:00008D4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008D4C
.text:00008D4C ; =============== S U B R O U T I N E =======================================
.text:00008D4C
.text:00008D4C ; Attributes: bp-based frame
.text:00008D4C
.text:00008D4C ; void __thiscall COutStreamWithHash::SetStream(COutStreamWithHash *this, struct ISequentialOutStream *)
.text:00008D4C                 public ?SetStream@COutStreamWithHash@@QAEXPAUISequentialOutStream@@@Z
.text:00008D4C ?SetStream@COutStreamWithHash@@QAEXPAUISequentialOutStream@@@Z proc near
.text:00008D4C                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+32D1p
.text:00008D4C
.text:00008D4C var_4           = dword ptr -4
.text:00008D4C arg_0           = dword ptr  8
.text:00008D4C
.text:00008D4C                 push    ebp
.text:00008D4D                 mov     ebp, esp
.text:00008D4F                 push    ecx
.text:00008D50                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008D57                 mov     [ebp+var_4], ecx
.text:00008D5A                 mov     eax, [ebp+arg_0]
.text:00008D5D                 push    eax
.text:00008D5E                 mov     ecx, [ebp+var_4]
.text:00008D61                 add     ecx, 8
.text:00008D64                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:00008D69                 add     esp, 4
.text:00008D6C                 cmp     ebp, esp
.text:00008D6E                 call    __RTC_CheckEsp
.text:00008D73                 mov     esp, ebp
.text:00008D75                 pop     ebp
.text:00008D76                 retn    4
.text:00008D76 ?SetStream@COutStreamWithHash@@QAEXPAUISequentialOutStream@@@Z endp
.text:00008D76
.text:00008D76 ; ---------------------------------------------------------------------------
.text:00008D79                 align 4
.text:00008D79 _text           ends
.text:00008D79
.text:00008D7C ; ===========================================================================
.text:00008D7C
.text:00008D7C ; Segment type: Pure code
.text:00008D7C ; Segment permissions: Read/Execute
.text:00008D7C _text           segment para public 'CODE' use32
.text:00008D7C                 assume cs:_text
.text:00008D7C                 ;org 8D7Ch
.text:00008D7C ; COMDAT (pick any)
.text:00008D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008D7C
.text:00008D7C ; =============== S U B R O U T I N E =======================================
.text:00008D7C
.text:00008D7C ; Attributes: bp-based frame
.text:00008D7C
.text:00008D7C ; void __thiscall COutStreamWithHash::ReleaseStream(COutStreamWithHash *__hidden this)
.text:00008D7C                 public ?ReleaseStream@COutStreamWithHash@@QAEXXZ
.text:00008D7C ?ReleaseStream@COutStreamWithHash@@QAEXXZ proc near
.text:00008D7C                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+7Ap
.text:00008D7C                                         ; CArchiveExtractCallback::SetOperationResult(int)+140p
.text:00008D7C
.text:00008D7C var_4           = dword ptr -4
.text:00008D7C
.text:00008D7C                 push    ebp
.text:00008D7D                 mov     ebp, esp
.text:00008D7F                 push    ecx
.text:00008D80                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008D87                 mov     [ebp+var_4], ecx
.text:00008D8A                 mov     ecx, [ebp+var_4]
.text:00008D8D                 add     ecx, 8
.text:00008D90                 call    ?Release@?$CMyComPtr@UISequentialOutStream@@@@QAEXXZ ; CMyComPtr<ISequentialOutStream>::Release(void)
.text:00008D95                 add     esp, 4
.text:00008D98                 cmp     ebp, esp
.text:00008D9A                 call    __RTC_CheckEsp
.text:00008D9F                 mov     esp, ebp
.text:00008DA1                 pop     ebp
.text:00008DA2                 retn
.text:00008DA2 ?ReleaseStream@COutStreamWithHash@@QAEXXZ endp
.text:00008DA2
.text:00008DA2 ; ---------------------------------------------------------------------------
.text:00008DA3                 align 4
.text:00008DA3 _text           ends
.text:00008DA3
.text:00008DA4 ; ===========================================================================
.text:00008DA4
.text:00008DA4 ; Segment type: Pure code
.text:00008DA4 ; Segment permissions: Read/Execute
.text:00008DA4 _text           segment para public 'CODE' use32
.text:00008DA4                 assume cs:_text
.text:00008DA4                 ;org 8DA4h
.text:00008DA4 ; COMDAT (pick any)
.text:00008DA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008DA4
.text:00008DA4 ; =============== S U B R O U T I N E =======================================
.text:00008DA4
.text:00008DA4 ; Attributes: bp-based frame
.text:00008DA4
.text:00008DA4 ; void __thiscall COutStreamWithHash::Init(COutStreamWithHash *this, bool)
.text:00008DA4                 public ?Init@COutStreamWithHash@@QAEX_N@Z
.text:00008DA4 ?Init@COutStreamWithHash@@QAEX_N@Z proc near
.text:00008DA4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+32F5p
.text:00008DA4
.text:00008DA4 var_4           = dword ptr -4
.text:00008DA4 arg_0           = byte ptr  8
.text:00008DA4
.text:00008DA4                 push    ebp
.text:00008DA5                 mov     ebp, esp
.text:00008DA7                 push    ecx
.text:00008DA8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008DAF                 mov     [ebp+var_4], ecx
.text:00008DB2                 mov     ecx, [ebp+var_4] ; this
.text:00008DB5                 call    ?InitCRC@COutStreamWithHash@@QAEXXZ ; COutStreamWithHash::InitCRC(void)
.text:00008DBA                 mov     eax, [ebp+var_4]
.text:00008DBD                 mov     dword ptr [eax+10h], 0
.text:00008DC4                 mov     dword ptr [eax+14h], 0
.text:00008DCB                 mov     ecx, [ebp+var_4]
.text:00008DCE                 mov     dl, [ebp+arg_0]
.text:00008DD1                 mov     [ecx+18h], dl
.text:00008DD4                 add     esp, 4
.text:00008DD7                 cmp     ebp, esp
.text:00008DD9                 call    __RTC_CheckEsp
.text:00008DDE                 mov     esp, ebp
.text:00008DE0                 pop     ebp
.text:00008DE1                 retn    4
.text:00008DE1 ?Init@COutStreamWithHash@@QAEX_N@Z endp
.text:00008DE1
.text:00008DE1 _text           ends
.text:00008DE1
.text:00008DE4 ; ===========================================================================
.text:00008DE4
.text:00008DE4 ; Segment type: Pure code
.text:00008DE4 ; Segment permissions: Read/Execute
.text:00008DE4 _text           segment para public 'CODE' use32
.text:00008DE4                 assume cs:_text
.text:00008DE4                 ;org 8DE4h
.text:00008DE4 ; COMDAT (pick any)
.text:00008DE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008DE4
.text:00008DE4 ; =============== S U B R O U T I N E =======================================
.text:00008DE4
.text:00008DE4 ; Attributes: bp-based frame
.text:00008DE4
.text:00008DE4 ; void __thiscall COutStreamWithHash::InitCRC(COutStreamWithHash *__hidden this)
.text:00008DE4                 public ?InitCRC@COutStreamWithHash@@QAEXXZ
.text:00008DE4 ?InitCRC@COutStreamWithHash@@QAEXXZ proc near
.text:00008DE4                                         ; CODE XREF: COutStreamWithHash::Init(bool)+11p
.text:00008DE4
.text:00008DE4 var_4           = dword ptr -4
.text:00008DE4
.text:00008DE4                 push    ebp
.text:00008DE5                 mov     ebp, esp
.text:00008DE7                 push    ecx
.text:00008DE8                 push    esi
.text:00008DE9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008DF0                 mov     [ebp+var_4], ecx
.text:00008DF3                 mov     eax, [ebp+var_4]
.text:00008DF6                 mov     ecx, [eax+1Ch]
.text:00008DF9                 mov     edx, [ebp+var_4]
.text:00008DFC                 mov     eax, [edx+1Ch]
.text:00008DFF                 mov     edx, [ecx]
.text:00008E01                 mov     esi, esp
.text:00008E03                 mov     ecx, eax
.text:00008E05                 mov     eax, [edx]
.text:00008E07                 call    eax
.text:00008E09                 cmp     esi, esp
.text:00008E0B                 call    __RTC_CheckEsp
.text:00008E10                 pop     esi
.text:00008E11                 add     esp, 4
.text:00008E14                 cmp     ebp, esp
.text:00008E16                 call    __RTC_CheckEsp
.text:00008E1B                 mov     esp, ebp
.text:00008E1D                 pop     ebp
.text:00008E1E                 retn
.text:00008E1E ?InitCRC@COutStreamWithHash@@QAEXXZ endp
.text:00008E1E
.text:00008E1E ; ---------------------------------------------------------------------------
.text:00008E1F                 align 10h
.text:00008E1F _text           ends
.text:00008E1F
.text:00008E20 ; ===========================================================================
.text:00008E20
.text:00008E20 ; Segment type: Pure code
.text:00008E20 ; Segment permissions: Read/Execute
.text:00008E20 _text           segment para public 'CODE' use32
.text:00008E20                 assume cs:_text
.text:00008E20                 ;org 8E20h
.text:00008E20 ; COMDAT (pick any)
.text:00008E20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008E20
.text:00008E20 ; =============== S U B R O U T I N E =======================================
.text:00008E20
.text:00008E20 ; Attributes: bp-based frame
.text:00008E20
.text:00008E20 ; _DWORD __thiscall CIndexToPathPair::CIndexToPathPair(CIndexToPathPair *this, unsigned int)
.text:00008E20                 public ??0CIndexToPathPair@@QAE@I@Z
.text:00008E20 ??0CIndexToPathPair@@QAE@I@Z proc near  ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1756p
.text:00008E20
.text:00008E20 var_4           = dword ptr -4
.text:00008E20 arg_0           = dword ptr  8
.text:00008E20
.text:00008E20                 push    ebp
.text:00008E21                 mov     ebp, esp
.text:00008E23                 push    ecx
.text:00008E24                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008E2B                 mov     [ebp+var_4], ecx
.text:00008E2E                 mov     eax, [ebp+var_4]
.text:00008E31                 mov     ecx, [ebp+arg_0]
.text:00008E34                 mov     [eax], ecx
.text:00008E36                 mov     ecx, [ebp+var_4]
.text:00008E39                 add     ecx, 4
.text:00008E3C                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00008E41                 mov     eax, [ebp+var_4]
.text:00008E44                 add     esp, 4
.text:00008E47                 cmp     ebp, esp
.text:00008E49                 call    __RTC_CheckEsp
.text:00008E4E                 mov     esp, ebp
.text:00008E50                 pop     ebp
.text:00008E51                 retn    4
.text:00008E51 ??0CIndexToPathPair@@QAE@I@Z endp
.text:00008E51
.text:00008E51 _text           ends
.text:00008E51
.text:00008E54 ; ===========================================================================
.text:00008E54
.text:00008E54 ; Segment type: Pure code
.text:00008E54 ; Segment permissions: Read/Execute
.text:00008E54 _text           segment para public 'CODE' use32
.text:00008E54                 assume cs:_text
.text:00008E54                 ;org 8E54h
.text:00008E54 ; COMDAT (pick any)
.text:00008E54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008E54
.text:00008E54 ; =============== S U B R O U T I N E =======================================
.text:00008E54
.text:00008E54 ; Attributes: bp-based frame
.text:00008E54
.text:00008E54 ; public: __thiscall CIndexToPathPair::CIndexToPathPair(unsigned int, class UString const &)
.text:00008E54                 public ??0CIndexToPathPair@@QAE@IABVUString@@@Z
.text:00008E54 ??0CIndexToPathPair@@QAE@IABVUString@@@Z proc near
.text:00008E54                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+30B6p
.text:00008E54
.text:00008E54 var_4           = dword ptr -4
.text:00008E54 arg_0           = dword ptr  8
.text:00008E54 arg_4           = dword ptr  0Ch
.text:00008E54
.text:00008E54                 push    ebp
.text:00008E55                 mov     ebp, esp
.text:00008E57                 push    ecx
.text:00008E58                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008E5F                 mov     [ebp+var_4], ecx
.text:00008E62                 mov     eax, [ebp+var_4]
.text:00008E65                 mov     ecx, [ebp+arg_0]
.text:00008E68                 mov     [eax], ecx
.text:00008E6A                 mov     edx, [ebp+arg_4]
.text:00008E6D                 push    edx
.text:00008E6E                 mov     ecx, [ebp+var_4]
.text:00008E71                 add     ecx, 4
.text:00008E74                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00008E79                 mov     eax, [ebp+var_4]
.text:00008E7C                 add     esp, 4
.text:00008E7F                 cmp     ebp, esp
.text:00008E81                 call    __RTC_CheckEsp
.text:00008E86                 mov     esp, ebp
.text:00008E88                 pop     ebp
.text:00008E89                 retn    8
.text:00008E89 ??0CIndexToPathPair@@QAE@IABVUString@@@Z endp
.text:00008E89
.text:00008E89 _text           ends
.text:00008E89
.text:00008E8C ; ===========================================================================
.text:00008E8C
.text:00008E8C ; Segment type: Pure code
.text:00008E8C ; Segment permissions: Read/Execute
.text:00008E8C _text           segment para public 'CODE' use32
.text:00008E8C                 assume cs:_text
.text:00008E8C                 ;org 8E8Ch
.text:00008E8C ; COMDAT (pick any)
.text:00008E8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008E8C
.text:00008E8C ; =============== S U B R O U T I N E =======================================
.text:00008E8C
.text:00008E8C ; Attributes: bp-based frame
.text:00008E8C
.text:00008E8C ; bool __stdcall IsPathSepar(wchar_t)
.text:00008E8C                 public ?IsPathSepar@@YG_N_W@Z
.text:00008E8C ?IsPathSepar@@YG_N_W@Z proc near        ; CODE XREF: GetDirPrefixOf(UString const &)+74p
.text:00008E8C                                         ; MakePath_from_2_Parts(UString const &,UString const &)+90p
.text:00008E8C
.text:00008E8C var_4           = dword ptr -4
.text:00008E8C arg_0           = word ptr  8
.text:00008E8C
.text:00008E8C                 push    ebp
.text:00008E8D                 mov     ebp, esp
.text:00008E8F                 push    ecx
.text:00008E90                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008E97                 movzx   eax, [ebp+arg_0]
.text:00008E9B                 cmp     eax, 5Ch ; '\'
.text:00008E9E                 jz      short loc_8EB2
.text:00008EA0                 movzx   ecx, [ebp+arg_0]
.text:00008EA4                 cmp     ecx, 2Fh ; '/'
.text:00008EA7                 jz      short loc_8EB2
.text:00008EA9                 mov     [ebp+var_4], 0
.text:00008EB0                 jmp     short loc_8EB9
.text:00008EB2 ; ---------------------------------------------------------------------------
.text:00008EB2
.text:00008EB2 loc_8EB2:                               ; CODE XREF: IsPathSepar(wchar_t)+12j
.text:00008EB2                                         ; IsPathSepar(wchar_t)+1Bj
.text:00008EB2                 mov     [ebp+var_4], 1
.text:00008EB9
.text:00008EB9 loc_8EB9:                               ; CODE XREF: IsPathSepar(wchar_t)+24j
.text:00008EB9                 mov     al, byte ptr [ebp+var_4]
.text:00008EBC                 mov     esp, ebp
.text:00008EBE                 pop     ebp
.text:00008EBF                 retn    4
.text:00008EBF ?IsPathSepar@@YG_N_W@Z endp
.text:00008EBF
.text:00008EBF ; ---------------------------------------------------------------------------
.text:00008EC2                 align 4
.text:00008EC2 _text           ends
.text:00008EC2
.text:00008EC4 ; ===========================================================================
.text:00008EC4
.text:00008EC4 ; Segment type: Pure code
.text:00008EC4 ; Segment permissions: Read/Execute
.text:00008EC4 _text           segment para public 'CODE' use32
.text:00008EC4                 assume cs:_text
.text:00008EC4                 ;org 8EC4h
.text:00008EC4 ; COMDAT (pick any)
.text:00008EC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008EC4
.text:00008EC4 ; =============== S U B R O U T I N E =======================================
.text:00008EC4
.text:00008EC4 ; Attributes: bp-based frame
.text:00008EC4
.text:00008EC4 ; wchar_t __thiscall UString::Back(UString *__hidden this)
.text:00008EC4                 public ?Back@UString@@QBE_WXZ
.text:00008EC4 ?Back@UString@@QBE_WXZ proc near        ; CODE XREF: GetDirPrefixOf(UString const &)+6Bp
.text:00008EC4                                         ; MakePath_from_2_Parts(UString const &,UString const &)+87p
.text:00008EC4
.text:00008EC4 var_4           = dword ptr -4
.text:00008EC4
.text:00008EC4                 push    ebp
.text:00008EC5                 mov     ebp, esp
.text:00008EC7                 push    ecx
.text:00008EC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008ECF                 mov     [ebp+var_4], ecx
.text:00008ED2                 mov     eax, [ebp+var_4]
.text:00008ED5                 mov     ecx, [eax+4]
.text:00008ED8                 mov     edx, [ebp+var_4]
.text:00008EDB                 mov     eax, [edx]
.text:00008EDD                 mov     ax, [eax+ecx*2-2]
.text:00008EE2                 mov     esp, ebp
.text:00008EE4                 pop     ebp
.text:00008EE5                 retn
.text:00008EE5 ?Back@UString@@QBE_WXZ endp
.text:00008EE5
.text:00008EE5 ; ---------------------------------------------------------------------------
.text:00008EE6                 align 4
.text:00008EE6 _text           ends
.text:00008EE6
.text:00008EE8 ; ===========================================================================
.text:00008EE8
.text:00008EE8 ; Segment type: Pure code
.text:00008EE8 ; Segment permissions: Read/Execute
.text:00008EE8 _text           segment para public 'CODE' use32
.text:00008EE8                 assume cs:_text
.text:00008EE8                 ;org 8EE8h
.text:00008EE8 ; COMDAT (pick any)
.text:00008EE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008EE8
.text:00008EE8 ; =============== S U B R O U T I N E =======================================
.text:00008EE8
.text:00008EE8 ; Attributes: bp-based frame
.text:00008EE8
.text:00008EE8 ; void __thiscall UString::DeleteBack(UString *__hidden this)
.text:00008EE8                 public ?DeleteBack@UString@@QAEXXZ
.text:00008EE8 ?DeleteBack@UString@@QAEXXZ proc near   ; CODE XREF: GetDirPrefixOf(UString const &)+83p
.text:00008EE8                                         ; MakePath_from_2_Parts(UString const &,UString const &)+B4p
.text:00008EE8
.text:00008EE8 var_8           = dword ptr -8
.text:00008EE8 var_4           = dword ptr -4
.text:00008EE8
.text:00008EE8                 push    ebp
.text:00008EE9                 mov     ebp, esp
.text:00008EEB                 sub     esp, 8
.text:00008EEE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00008EF5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008EFC                 mov     [ebp+var_4], ecx
.text:00008EFF                 mov     eax, [ebp+var_4]
.text:00008F02                 mov     ecx, [eax+4]
.text:00008F05                 sub     ecx, 1
.text:00008F08                 mov     [ebp+var_8], ecx
.text:00008F0B                 mov     edx, [ebp+var_4]
.text:00008F0E                 mov     eax, [ebp+var_8]
.text:00008F11                 mov     [edx+4], eax
.text:00008F14                 mov     ecx, [ebp+var_4]
.text:00008F17                 mov     edx, [ecx]
.text:00008F19                 xor     eax, eax
.text:00008F1B                 mov     ecx, [ebp+var_8]
.text:00008F1E                 mov     [edx+ecx*2], ax
.text:00008F22                 mov     esp, ebp
.text:00008F24                 pop     ebp
.text:00008F25                 retn
.text:00008F25 ?DeleteBack@UString@@QAEXXZ endp
.text:00008F25
.text:00008F25 ; ---------------------------------------------------------------------------
.text:00008F26                 align 4
.text:00008F26 _text           ends
.text:00008F26
.text:00008F28 ; ===========================================================================
.text:00008F28
.text:00008F28 ; Segment type: Pure code
.text:00008F28 ; Segment permissions: Read/Execute
.text:00008F28 _text           segment para public 'CODE' use32
.text:00008F28                 assume cs:_text
.text:00008F28                 ;org 8F28h
.text:00008F28 ; COMDAT (pick any)
.text:00008F28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008F28
.text:00008F28 ; =============== S U B R O U T I N E =======================================
.text:00008F28
.text:00008F28 ; Attributes: bp-based frame
.text:00008F28
.text:00008F28 ; int __stdcall operator==(int, wchar_t *Str2)
.text:00008F28                 public ??8@YG_NABVUString@@PB_W@Z
.text:00008F28 ??8@YG_NABVUString@@PB_W@Z proc near    ; CODE XREF: IsSafePath(UString const &)+B4p
.text:00008F28                                         ; IsSafePath(UString const &)+CBp
.text:00008F28
.text:00008F28 arg_0           = dword ptr  8
.text:00008F28 Str2            = dword ptr  0Ch
.text:00008F28
.text:00008F28                 push    ebp
.text:00008F29                 mov     ebp, esp
.text:00008F2B                 push    esi
.text:00008F2C                 mov     esi, esp
.text:00008F2E                 mov     eax, [ebp+Str2]
.text:00008F31                 push    eax             ; Str2
.text:00008F32                 mov     ecx, [ebp+arg_0]
.text:00008F35                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00008F3A                 push    eax             ; Str1
.text:00008F3B                 call    dword ptr ds:__imp__wcscmp
.text:00008F41                 add     esp, 8
.text:00008F44                 cmp     esi, esp
.text:00008F46                 call    __RTC_CheckEsp
.text:00008F4B                 neg     eax
.text:00008F4D                 sbb     eax, eax
.text:00008F4F                 add     eax, 1
.text:00008F52                 pop     esi
.text:00008F53                 cmp     ebp, esp
.text:00008F55                 call    __RTC_CheckEsp
.text:00008F5A                 pop     ebp
.text:00008F5B                 retn    8
.text:00008F5B ??8@YG_NABVUString@@PB_W@Z endp
.text:00008F5B
.text:00008F5B ; ---------------------------------------------------------------------------
.text:00008F5E                 align 10h
.text:00008F5E _text           ends
.text:00008F5E
.text:00008F60 ; ===========================================================================
.text:00008F60
.text:00008F60 ; Segment type: Pure code
.text:00008F60 ; Segment permissions: Read/Execute
.text:00008F60 _text           segment para public 'CODE' use32
.text:00008F60                 assume cs:_text
.text:00008F60                 ;org 8F60h
.text:00008F60 ; COMDAT (pick any)
.text:00008F60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008F60
.text:00008F60 ; =============== S U B R O U T I N E =======================================
.text:00008F60
.text:00008F60 ; Attributes: bp-based frame
.text:00008F60
.text:00008F60 ; _DWORD __thiscall NWindows::NFile::CReparseAttr::~CReparseAttr(NWindows::NFile::CReparseAttr *__hidden this)
.text:00008F60                 public ??1CReparseAttr@NFile@NWindows@@QAE@XZ
.text:00008F60 ??1CReparseAttr@NFile@NWindows@@QAE@XZ proc near
.text:00008F60                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+5F6p
.text:00008F60                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2A44p ...
.text:00008F60
.text:00008F60 var_10          = dword ptr -10h
.text:00008F60 var_C           = dword ptr -0Ch
.text:00008F60 var_4           = dword ptr -4
.text:00008F60
.text:00008F60                 push    ebp
.text:00008F61                 mov     ebp, esp
.text:00008F63                 push    0FFFFFFFFh
.text:00008F65                 push    offset __ehhandler$??1CReparseAttr@NFile@NWindows@@QAE@XZ
.text:00008F6A                 mov     eax, large fs:0
.text:00008F70                 push    eax
.text:00008F71                 push    ecx
.text:00008F72                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00008F79                 mov     eax, dword ptr ds:___security_cookie
.text:00008F7E                 xor     eax, ebp
.text:00008F80                 push    eax
.text:00008F81                 lea     eax, [ebp+var_C]
.text:00008F84                 mov     large fs:0, eax
.text:00008F8A                 mov     [ebp+var_10], ecx
.text:00008F8D                 mov     [ebp+var_4], 0
.text:00008F94                 mov     ecx, [ebp+var_10]
.text:00008F97                 add     ecx, 14h        ; this
.text:00008F9A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00008F9F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008FA6                 mov     ecx, [ebp+var_10]
.text:00008FA9                 add     ecx, 8          ; this
.text:00008FAC                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00008FB1                 mov     ecx, [ebp+var_C]
.text:00008FB4                 mov     large fs:0, ecx
.text:00008FBB                 pop     ecx
.text:00008FBC                 add     esp, 10h
.text:00008FBF                 cmp     ebp, esp
.text:00008FC1                 call    __RTC_CheckEsp
.text:00008FC6                 mov     esp, ebp
.text:00008FC8                 pop     ebp
.text:00008FC9                 retn
.text:00008FC9 ??1CReparseAttr@NFile@NWindows@@QAE@XZ endp
.text:00008FC9
.text:00008FC9 ; ---------------------------------------------------------------------------
.text:00008FCA                 align 4
.text:00008FCA _text           ends
.text:00008FCA
.text$x:00008FCC ; ===========================================================================
.text$x:00008FCC
.text$x:00008FCC ; Segment type: Pure code
.text$x:00008FCC ; Segment permissions: Read/Execute
.text$x:00008FCC _text$x         segment para public 'CODE' use32
.text$x:00008FCC                 assume cs:_text$x
.text$x:00008FCC                 ;org 8FCCh
.text$x:00008FCC ; COMDAT (pick associative to section at 8F60)
.text$x:00008FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008FCC
.text$x:00008FCC ; =============== S U B R O U T I N E =======================================
.text$x:00008FCC
.text$x:00008FCC
.text$x:00008FCC __unwindfunclet$??1CReparseAttr@NFile@NWindows@@QAE@XZ$0 proc near
.text$x:00008FCC                                         ; DATA XREF: .xdata$x:00008FF8o
.text$x:00008FCC                 mov     ecx, [ebp-10h]
.text$x:00008FCF                 add     ecx, 8          ; this
.text$x:00008FD2                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00008FD2 __unwindfunclet$??1CReparseAttr@NFile@NWindows@@QAE@XZ$0 endp
.text$x:00008FD2
.text$x:00008FD7
.text$x:00008FD7 ; =============== S U B R O U T I N E =======================================
.text$x:00008FD7
.text$x:00008FD7
.text$x:00008FD7 __ehhandler$??1CReparseAttr@NFile@NWindows@@QAE@XZ proc near
.text$x:00008FD7                                         ; DATA XREF: NWindows::NFile::CReparseAttr::~CReparseAttr(void)+5o
.text$x:00008FD7
.text$x:00008FD7 arg_4           = dword ptr  8
.text$x:00008FD7
.text$x:00008FD7                 mov     edx, [esp+arg_4]
.text$x:00008FDB                 lea     eax, [edx+0Ch]
.text$x:00008FDE                 mov     ecx, [edx-8]
.text$x:00008FE1                 xor     ecx, eax
.text$x:00008FE3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008FE8                 mov     eax, offset __ehfuncinfo$??1CReparseAttr@NFile@NWindows@@QAE@XZ
.text$x:00008FED                 jmp     ___CxxFrameHandler3
.text$x:00008FED __ehhandler$??1CReparseAttr@NFile@NWindows@@QAE@XZ endp
.text$x:00008FED
.text$x:00008FED ; ---------------------------------------------------------------------------
.text$x:00008FF2                 align 4
.text$x:00008FF2 _text$x         ends
.text$x:00008FF2
.xdata$x:00008FF4 ; ===========================================================================
.xdata$x:00008FF4
.xdata$x:00008FF4 ; Segment type: Pure data
.xdata$x:00008FF4 ; Segment permissions: Read
.xdata$x:00008FF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008FF4                 assume cs:_xdata$x
.xdata$x:00008FF4                 ;org 8FF4h
.xdata$x:00008FF4 ; COMDAT (pick associative to section at 8F60)
.xdata$x:00008FF4 __unwindtable$??1CReparseAttr@NFile@NWindows@@QAE@XZ db 0FFh
.xdata$x:00008FF4                                         ; DATA XREF: .xdata$x:00009004o
.xdata$x:00008FF5                 db 0FFh
.xdata$x:00008FF6                 db 0FFh
.xdata$x:00008FF7                 db 0FFh
.xdata$x:00008FF8                 dd offset __unwindfunclet$??1CReparseAttr@NFile@NWindows@@QAE@XZ$0
.xdata$x:00008FFC __ehfuncinfo$??1CReparseAttr@NFile@NWindows@@QAE@XZ db  22h ; "
.xdata$x:00008FFC                                         ; DATA XREF: __ehhandler$??1CReparseAttr@NFile@NWindows@@QAE@XZ+11o
.xdata$x:00008FFD                 db    5
.xdata$x:00008FFE                 db  93h ; ô
.xdata$x:00008FFF                 db  19h
.xdata$x:00009000                 db    1
.xdata$x:00009001                 db    0
.xdata$x:00009002                 db    0
.xdata$x:00009003                 db    0
.xdata$x:00009004                 dd offset __unwindtable$??1CReparseAttr@NFile@NWindows@@QAE@XZ
.xdata$x:00009008                 db    0
.xdata$x:00009009                 db    0
.xdata$x:0000900A                 db    0
.xdata$x:0000900B                 db    0
.xdata$x:0000900C                 db    0
.xdata$x:0000900D                 db    0
.xdata$x:0000900E                 db    0
.xdata$x:0000900F                 db    0
.xdata$x:00009010                 db    0
.xdata$x:00009011                 db    0
.xdata$x:00009012                 db    0
.xdata$x:00009013                 db    0
.xdata$x:00009014                 db    0
.xdata$x:00009015                 db    0
.xdata$x:00009016                 db    0
.xdata$x:00009017                 db    0
.xdata$x:00009018                 db    0
.xdata$x:00009019                 db    0
.xdata$x:0000901A                 db    0
.xdata$x:0000901B                 db    0
.xdata$x:0000901C                 db    1
.xdata$x:0000901D                 db    0
.xdata$x:0000901E                 db    0
.xdata$x:0000901F                 db    0
.xdata$x:0000901F _xdata$x        ends
.xdata$x:0000901F
.text:00009020 ; ===========================================================================
.text:00009020
.text:00009020 ; Segment type: Pure code
.text:00009020 ; Segment permissions: Read/Execute
.text:00009020 _text           segment para public 'CODE' use32
.text:00009020                 assume cs:_text
.text:00009020                 ;org 9020h
.text:00009020 ; COMDAT (pick any)
.text:00009020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009020
.text:00009020 ; =============== S U B R O U T I N E =======================================
.text:00009020
.text:00009020 ; Attributes: bp-based frame
.text:00009020
.text:00009020 ; public: __thiscall CGetProp::CGetProp(void)
.text:00009020                 public ??0CGetProp@@QAE@XZ
.text:00009020 ??0CGetProp@@QAE@XZ proc near           ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+DC6p
.text:00009020
.text:00009020 var_4           = dword ptr -4
.text:00009020
.text:00009020                 push    ebp
.text:00009021                 mov     ebp, esp
.text:00009023                 push    ecx
.text:00009024                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000902B                 mov     [ebp+var_4], ecx
.text:0000902E                 mov     ecx, [ebp+var_4] ; this
.text:00009031                 call    ??0IGetProp@@QAE@XZ ; IGetProp::IGetProp(void)
.text:00009036                 mov     ecx, [ebp+var_4]
.text:00009039                 add     ecx, 4          ; this
.text:0000903C                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:00009041                 mov     eax, [ebp+var_4]
.text:00009044                 mov     dword ptr [eax], offset ??_7CGetProp@@6B@ ; const CGetProp::`vftable'
.text:0000904A                 mov     eax, [ebp+var_4]
.text:0000904D                 add     esp, 4
.text:00009050                 cmp     ebp, esp
.text:00009052                 call    __RTC_CheckEsp
.text:00009057                 mov     esp, ebp
.text:00009059                 pop     ebp
.text:0000905A                 retn
.text:0000905A ??0CGetProp@@QAE@XZ endp
.text:0000905A
.text:0000905A ; ---------------------------------------------------------------------------
.text:0000905B                 align 4
.text:0000905B _text           ends
.text:0000905B
.rdata:0000905C ; ===========================================================================
.rdata:0000905C
.rdata:0000905C ; Segment type: Pure data
.rdata:0000905C ; Segment permissions: Read
.rdata:0000905C _rdata          segment dword public 'DATA' use32
.rdata:0000905C                 assume cs:_rdata
.rdata:0000905C                 ;org 905Ch
.rdata:0000905C ; COMDAT (pick largest)
.rdata:0000905C                 dd offset ??_R4CGetProp@@6B@ ; const CGetProp::`RTTI Complete Object Locator'
.rdata:00009060                 public ??_7CGetProp@@6B@
.rdata:00009060 ; const CGetProp::`vftable'
.rdata:00009060 ??_7CGetProp@@6B@ dd offset ?QueryInterface@CGetProp@@UAGJABU_GUID@@PAPAX@Z
.rdata:00009060                                         ; DATA XREF: CGetProp::CGetProp(void)+24o
.rdata:00009060                                         ; CGetProp::QueryInterface(_GUID const &,void * *)
.rdata:00009064                 dd offset ?AddRef@CGetProp@@UAGKXZ ; CGetProp::AddRef(void)
.rdata:00009068                 dd offset ?Release@CGetProp@@UAGKXZ ; CGetProp::Release(void)
.rdata:0000906C                 dd offset ?GetPropA@CGetProp@@UAGJKPAUtagPROPVARIANT@@@Z ; CGetProp::GetPropA(ulong,tagPROPVARIANT *)
.rdata:0000906C _rdata          ends
.rdata:0000906C
.rdata$r:00009070 ; ===========================================================================
.rdata$r:00009070
.rdata$r:00009070 ; Segment type: Pure data
.rdata$r:00009070 ; Segment permissions: Read
.rdata$r:00009070 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009070                 assume cs:_rdata$r
.rdata$r:00009070                 ;org 9070h
.rdata$r:00009070 ; COMDAT (pick any)
.rdata$r:00009070                 public ??_R4CGetProp@@6B@
.rdata$r:00009070 ; const CGetProp::`RTTI Complete Object Locator'
.rdata$r:00009070 ??_R4CGetProp@@6B@ db    0              ; DATA XREF: .rdata:0000905Co
.rdata$r:00009071                 db    0
.rdata$r:00009072                 db    0
.rdata$r:00009073                 db    0
.rdata$r:00009074                 db    0
.rdata$r:00009075                 db    0
.rdata$r:00009076                 db    0
.rdata$r:00009077                 db    0
.rdata$r:00009078                 db    0
.rdata$r:00009079                 db    0
.rdata$r:0000907A                 db    0
.rdata$r:0000907B                 db    0
.rdata$r:0000907C                 dd offset ??_R0?AVCGetProp@@@8 ; CGetProp `RTTI Type Descriptor'
.rdata$r:00009080                 dd offset ??_R3CGetProp@@8 ; CGetProp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009080 _rdata$r        ends
.rdata$r:00009080
.data:00009084 ; ===========================================================================
.data:00009084
.data:00009084 ; Segment type: Pure data
.data:00009084 ; Segment permissions: Read/Write
.data:00009084 _data           segment dword public 'DATA' use32
.data:00009084                 assume cs:_data
.data:00009084                 ;org 9084h
.data:00009084 ; COMDAT (pick any)
.data:00009084                 public ??_R0?AVCGetProp@@@8
.data:00009084 ; class CGetProp `RTTI Type Descriptor'
.data:00009084 ??_R0?AVCGetProp@@@8 dd offset ??_7type_info@@6B@
.data:00009084                                         ; DATA XREF: .rdata$r:0000907Co
.data:00009084                                         ; .rdata$r:CGetProp::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00009084                                         ; const type_info::`vftable'
.data:00009088                 db    0
.data:00009089                 db    0
.data:0000908A                 db    0
.data:0000908B                 db    0
.data:0000908C                 db  2Eh ; .
.data:0000908D                 db  3Fh ; ?
.data:0000908E                 db  41h ; A
.data:0000908F                 db  56h ; V
.data:00009090                 db  43h ; C
.data:00009091                 db  47h ; G
.data:00009092                 db  65h ; e
.data:00009093                 db  74h ; t
.data:00009094                 db  50h ; P
.data:00009095                 db  72h ; r
.data:00009096                 db  6Fh ; o
.data:00009097                 db  70h ; p
.data:00009098                 db  40h ; @
.data:00009099                 db  40h ; @
.data:0000909A                 db    0
.data:0000909B                 align 4
.data:0000909B _data           ends
.data:0000909B
.rdata$r:0000909C ; ===========================================================================
.rdata$r:0000909C
.rdata$r:0000909C ; Segment type: Pure data
.rdata$r:0000909C ; Segment permissions: Read
.rdata$r:0000909C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000909C                 assume cs:_rdata$r
.rdata$r:0000909C                 ;org 909Ch
.rdata$r:0000909C ; COMDAT (pick any)
.rdata$r:0000909C                 public ??_R3CGetProp@@8
.rdata$r:0000909C ; CGetProp::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000909C ??_R3CGetProp@@8 db    0                ; DATA XREF: .rdata$r:00009080o
.rdata$r:0000909C                                         ; .rdata$r:000090D8o
.rdata$r:0000909D                 db    0
.rdata$r:0000909E                 db    0
.rdata$r:0000909F                 db    0
.rdata$r:000090A0                 db    1
.rdata$r:000090A1                 db    0
.rdata$r:000090A2                 db    0
.rdata$r:000090A3                 db    0
.rdata$r:000090A4                 db    4
.rdata$r:000090A5                 db    0
.rdata$r:000090A6                 db    0
.rdata$r:000090A7                 db    0
.rdata$r:000090A8                 dd offset ??_R2CGetProp@@8 ; CGetProp::`RTTI Base Class Array'
.rdata$r:000090A8 _rdata$r        ends
.rdata$r:000090A8
.rdata$r:000090AC ; ===========================================================================
.rdata$r:000090AC
.rdata$r:000090AC ; Segment type: Pure data
.rdata$r:000090AC ; Segment permissions: Read
.rdata$r:000090AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000090AC                 assume cs:_rdata$r
.rdata$r:000090AC                 ;org 90ACh
.rdata$r:000090AC ; COMDAT (pick any)
.rdata$r:000090AC                 public ??_R2CGetProp@@8
.rdata$r:000090AC ; CGetProp::`RTTI Base Class Array'
.rdata$r:000090AC ??_R2CGetProp@@8 dd offset ??_R1A@?0A@EA@CGetProp@@8
.rdata$r:000090AC                                         ; DATA XREF: .rdata$r:000090A8o
.rdata$r:000090AC                                         ; CGetProp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000090B0                 dd offset ??_R1A@?0A@EA@IGetProp@@8 ; IGetProp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000090B4                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000090B8                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:000090BC                 db    0
.rdata$r:000090BD                 align 10h
.rdata$r:000090BD _rdata$r        ends
.rdata$r:000090BD
.rdata$r:000090C0 ; ===========================================================================
.rdata$r:000090C0
.rdata$r:000090C0 ; Segment type: Pure data
.rdata$r:000090C0 ; Segment permissions: Read
.rdata$r:000090C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000090C0                 assume cs:_rdata$r
.rdata$r:000090C0                 ;org 90C0h
.rdata$r:000090C0 ; COMDAT (pick any)
.rdata$r:000090C0                 public ??_R1A@?0A@EA@CGetProp@@8
.rdata$r:000090C0 ; CGetProp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000090C0 ??_R1A@?0A@EA@CGetProp@@8 dd offset ??_R0?AVCGetProp@@@8
.rdata$r:000090C0                                         ; DATA XREF: .rdata$r:CGetProp::`RTTI Base Class Array'o
.rdata$r:000090C0                                         ; CGetProp `RTTI Type Descriptor'
.rdata$r:000090C4                 db    3
.rdata$r:000090C5                 db    0
.rdata$r:000090C6                 db    0
.rdata$r:000090C7                 db    0
.rdata$r:000090C8                 db    0
.rdata$r:000090C9                 db    0
.rdata$r:000090CA                 db    0
.rdata$r:000090CB                 db    0
.rdata$r:000090CC                 db 0FFh
.rdata$r:000090CD                 db 0FFh
.rdata$r:000090CE                 db 0FFh
.rdata$r:000090CF                 db 0FFh
.rdata$r:000090D0                 db    0
.rdata$r:000090D1                 db    0
.rdata$r:000090D2                 db    0
.rdata$r:000090D3                 db    0
.rdata$r:000090D4                 db  40h ; @
.rdata$r:000090D5                 db    0
.rdata$r:000090D6                 db    0
.rdata$r:000090D7                 db    0
.rdata$r:000090D8                 dd offset ??_R3CGetProp@@8 ; CGetProp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000090D8 _rdata$r        ends
.rdata$r:000090D8
.rdata$r:000090DC ; ===========================================================================
.rdata$r:000090DC
.rdata$r:000090DC ; Segment type: Pure data
.rdata$r:000090DC ; Segment permissions: Read
.rdata$r:000090DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000090DC                 assume cs:_rdata$r
.rdata$r:000090DC                 ;org 90DCh
.rdata$r:000090DC ; COMDAT (pick any)
.rdata$r:000090DC                 public ??_R1A@?0A@EA@IGetProp@@8
.rdata$r:000090DC ; IGetProp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000090DC ??_R1A@?0A@EA@IGetProp@@8 dd offset ??_R0?AUIGetProp@@@8
.rdata$r:000090DC                                         ; DATA XREF: .rdata$r:000090B0o
.rdata$r:000090DC                                         ; .rdata$r:IGetProp::`RTTI Base Class Array'o
.rdata$r:000090DC                                         ; IGetProp `RTTI Type Descriptor'
.rdata$r:000090E0                 db    1
.rdata$r:000090E1                 db    0
.rdata$r:000090E2                 db    0
.rdata$r:000090E3                 db    0
.rdata$r:000090E4                 db    0
.rdata$r:000090E5                 db    0
.rdata$r:000090E6                 db    0
.rdata$r:000090E7                 db    0
.rdata$r:000090E8                 db 0FFh
.rdata$r:000090E9                 db 0FFh
.rdata$r:000090EA                 db 0FFh
.rdata$r:000090EB                 db 0FFh
.rdata$r:000090EC                 db    0
.rdata$r:000090ED                 db    0
.rdata$r:000090EE                 db    0
.rdata$r:000090EF                 db    0
.rdata$r:000090F0                 db  40h ; @
.rdata$r:000090F1                 db    0
.rdata$r:000090F2                 db    0
.rdata$r:000090F3                 db    0
.rdata$r:000090F4                 dd offset ??_R3IGetProp@@8 ; IGetProp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000090F4 _rdata$r        ends
.rdata$r:000090F4
.data:000090F8 ; ===========================================================================
.data:000090F8
.data:000090F8 ; Segment type: Pure data
.data:000090F8 ; Segment permissions: Read/Write
.data:000090F8 _data           segment dword public 'DATA' use32
.data:000090F8                 assume cs:_data
.data:000090F8                 ;org 90F8h
.data:000090F8 ; COMDAT (pick any)
.data:000090F8                 public ??_R0?AUIGetProp@@@8
.data:000090F8 ; struct IGetProp `RTTI Type Descriptor'
.data:000090F8 ??_R0?AUIGetProp@@@8 dd offset ??_7type_info@@6B@
.data:000090F8                                         ; DATA XREF: .rdata$r:IGetProp::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000090F8                                         ; .rdata$r:0000959Co
.data:000090F8                                         ; const type_info::`vftable'
.data:000090FC                 align 10h
.data:00009100 a_?auigetprop@@ db '.?AUIGetProp@@',0
.data:0000910F                 align 10h
.data:0000910F _data           ends
.data:0000910F
.rdata$r:00009110 ; ===========================================================================
.rdata$r:00009110
.rdata$r:00009110 ; Segment type: Pure data
.rdata$r:00009110 ; Segment permissions: Read
.rdata$r:00009110 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009110                 assume cs:_rdata$r
.rdata$r:00009110                 ;org 9110h
.rdata$r:00009110 ; COMDAT (pick any)
.rdata$r:00009110                 public ??_R3IGetProp@@8
.rdata$r:00009110 ; IGetProp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009110 ??_R3IGetProp@@8 db    0                ; DATA XREF: .rdata$r:000090F4o
.rdata$r:00009110                                         ; .rdata$r:000095A0o
.rdata$r:00009111                 db    0
.rdata$r:00009112                 db    0
.rdata$r:00009113                 db    0
.rdata$r:00009114                 db    0
.rdata$r:00009115                 db    0
.rdata$r:00009116                 db    0
.rdata$r:00009117                 db    0
.rdata$r:00009118                 db    2
.rdata$r:00009119                 db    0
.rdata$r:0000911A                 db    0
.rdata$r:0000911B                 db    0
.rdata$r:0000911C                 dd offset ??_R2IGetProp@@8 ; IGetProp::`RTTI Base Class Array'
.rdata$r:0000911C _rdata$r        ends
.rdata$r:0000911C
.rdata$r:00009120 ; ===========================================================================
.rdata$r:00009120
.rdata$r:00009120 ; Segment type: Pure data
.rdata$r:00009120 ; Segment permissions: Read
.rdata$r:00009120 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009120                 assume cs:_rdata$r
.rdata$r:00009120                 ;org 9120h
.rdata$r:00009120 ; COMDAT (pick any)
.rdata$r:00009120                 public ??_R2IGetProp@@8
.rdata$r:00009120 ; IGetProp::`RTTI Base Class Array'
.rdata$r:00009120 ??_R2IGetProp@@8 dd offset ??_R1A@?0A@EA@IGetProp@@8
.rdata$r:00009120                                         ; DATA XREF: .rdata$r:0000911Co
.rdata$r:00009120                                         ; IGetProp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009124                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009128                 db    0
.rdata$r:00009129                 align 4
.rdata$r:00009129 _rdata$r        ends
.rdata$r:00009129
.text:0000912C ; ===========================================================================
.text:0000912C
.text:0000912C ; Segment type: Pure code
.text:0000912C ; Segment permissions: Read/Execute
.text:0000912C _text           segment para public 'CODE' use32
.text:0000912C                 assume cs:_text
.text:0000912C                 ;org 912Ch
.text:0000912C ; COMDAT (pick any)
.text:0000912C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000912C
.text:0000912C ; =============== S U B R O U T I N E =======================================
.text:0000912C
.text:0000912C ; Attributes: bp-based frame
.text:0000912C
.text:0000912C ; __int32 __stdcall CGetProp::QueryInterface(CGetProp *this, const struct _GUID *Buf1, void **)
.text:0000912C                 public ?QueryInterface@CGetProp@@UAGJABU_GUID@@PAPAX@Z
.text:0000912C ?QueryInterface@CGetProp@@UAGJABU_GUID@@PAPAX@Z proc near
.text:0000912C                                         ; DATA XREF: .rdata:const CGetProp::`vftable'o
.text:0000912C
.text:0000912C this            = dword ptr  8
.text:0000912C Buf1            = dword ptr  0Ch
.text:0000912C arg_8           = dword ptr  10h
.text:0000912C
.text:0000912C                 push    ebp
.text:0000912D                 mov     ebp, esp
.text:0000912F                 mov     eax, [ebp+arg_8]
.text:00009132                 mov     dword ptr [eax], 0
.text:00009138                 push    offset _IID_IUnknown ; Buf2
.text:0000913D                 mov     ecx, [ebp+Buf1]
.text:00009140                 push    ecx             ; Buf1
.text:00009141                 call    ___@8           ; __(x,x)
.text:00009146                 test    eax, eax
.text:00009148                 jz      short loc_9154
.text:0000914A                 mov     edx, [ebp+arg_8]
.text:0000914D                 mov     eax, [ebp+this]
.text:00009150                 mov     [edx], eax
.text:00009152                 jmp     short loc_9177
.text:00009154 ; ---------------------------------------------------------------------------
.text:00009154
.text:00009154 loc_9154:                               ; CODE XREF: CGetProp::QueryInterface(_GUID const &,void * *)+1Cj
.text:00009154                 push    offset _IID_IGetProp ; Buf2
.text:00009159                 mov     ecx, [ebp+Buf1]
.text:0000915C                 push    ecx             ; Buf1
.text:0000915D                 call    ___@8           ; __(x,x)
.text:00009162                 test    eax, eax
.text:00009164                 jz      short loc_9170
.text:00009166                 mov     edx, [ebp+arg_8]
.text:00009169                 mov     eax, [ebp+this]
.text:0000916C                 mov     [edx], eax
.text:0000916E                 jmp     short loc_9177
.text:00009170 ; ---------------------------------------------------------------------------
.text:00009170
.text:00009170 loc_9170:                               ; CODE XREF: CGetProp::QueryInterface(_GUID const &,void * *)+38j
.text:00009170                 mov     eax, 80004002h
.text:00009175                 jmp     short loc_9188
.text:00009177 ; ---------------------------------------------------------------------------
.text:00009177
.text:00009177 loc_9177:                               ; CODE XREF: CGetProp::QueryInterface(_GUID const &,void * *)+26j
.text:00009177                                         ; CGetProp::QueryInterface(_GUID const &,void * *)+42j
.text:00009177                 mov     ecx, [ebp+this]
.text:0000917A                 mov     edx, [ecx+4]
.text:0000917D                 add     edx, 1
.text:00009180                 mov     eax, [ebp+this]
.text:00009183                 mov     [eax+4], edx
.text:00009186                 xor     eax, eax
.text:00009188
.text:00009188 loc_9188:                               ; CODE XREF: CGetProp::QueryInterface(_GUID const &,void * *)+49j
.text:00009188                 cmp     ebp, esp
.text:0000918A                 call    __RTC_CheckEsp
.text:0000918F                 pop     ebp
.text:00009190                 retn    0Ch
.text:00009190 ?QueryInterface@CGetProp@@UAGJABU_GUID@@PAPAX@Z endp
.text:00009190
.text:00009190 ; ---------------------------------------------------------------------------
.text:00009193                 align 4
.text:00009193 _text           ends
.text:00009193
.text:00009194 ; ===========================================================================
.text:00009194
.text:00009194 ; Segment type: Pure code
.text:00009194 ; Segment permissions: Read/Execute
.text:00009194 _text           segment para public 'CODE' use32
.text:00009194                 assume cs:_text
.text:00009194                 ;org 9194h
.text:00009194 ; COMDAT (pick any)
.text:00009194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009194
.text:00009194 ; =============== S U B R O U T I N E =======================================
.text:00009194
.text:00009194 ; Attributes: bp-based frame
.text:00009194
.text:00009194 ; unsigned __int32 __stdcall CGetProp::AddRef(CGetProp *this)
.text:00009194                 public ?AddRef@CGetProp@@UAGKXZ
.text:00009194 ?AddRef@CGetProp@@UAGKXZ proc near      ; DATA XREF: .rdata:00009064o
.text:00009194
.text:00009194 var_4           = dword ptr -4
.text:00009194 this            = dword ptr  8
.text:00009194
.text:00009194                 push    ebp
.text:00009195                 mov     ebp, esp
.text:00009197                 push    ecx
.text:00009198                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000919F                 mov     eax, [ebp+this]
.text:000091A2                 mov     ecx, [eax+4]
.text:000091A5                 add     ecx, 1
.text:000091A8                 mov     [ebp+var_4], ecx
.text:000091AB                 mov     edx, [ebp+this]
.text:000091AE                 mov     eax, [ebp+var_4]
.text:000091B1                 mov     [edx+4], eax
.text:000091B4                 mov     eax, [ebp+var_4]
.text:000091B7                 mov     esp, ebp
.text:000091B9                 pop     ebp
.text:000091BA                 retn    4
.text:000091BA ?AddRef@CGetProp@@UAGKXZ endp
.text:000091BA
.text:000091BA ; ---------------------------------------------------------------------------
.text:000091BD                 align 10h
.text:000091BD _text           ends
.text:000091BD
.text:000091C0 ; ===========================================================================
.text:000091C0
.text:000091C0 ; Segment type: Pure code
.text:000091C0 ; Segment permissions: Read/Execute
.text:000091C0 _text           segment para public 'CODE' use32
.text:000091C0                 assume cs:_text
.text:000091C0                 ;org 91C0h
.text:000091C0 ; COMDAT (pick any)
.text:000091C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000091C0
.text:000091C0 ; =============== S U B R O U T I N E =======================================
.text:000091C0
.text:000091C0 ; Attributes: bp-based frame
.text:000091C0
.text:000091C0 ; unsigned __int32 __stdcall CGetProp::Release(CGetProp *this)
.text:000091C0                 public ?Release@CGetProp@@UAGKXZ
.text:000091C0 ?Release@CGetProp@@UAGKXZ proc near     ; DATA XREF: .rdata:00009068o
.text:000091C0
.text:000091C0 var_8           = dword ptr -8
.text:000091C0 var_4           = dword ptr -4
.text:000091C0 this            = dword ptr  8
.text:000091C0
.text:000091C0                 push    ebp
.text:000091C1                 mov     ebp, esp
.text:000091C3                 sub     esp, 8
.text:000091C6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000091CD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000091D4                 mov     eax, [ebp+this]
.text:000091D7                 mov     ecx, [eax+4]
.text:000091DA                 sub     ecx, 1
.text:000091DD                 mov     [ebp+var_8], ecx
.text:000091E0                 mov     edx, [ebp+this]
.text:000091E3                 mov     eax, [ebp+var_8]
.text:000091E6                 mov     [edx+4], eax
.text:000091E9                 cmp     [ebp+var_8], 0
.text:000091ED                 jz      short loc_91F7
.text:000091EF                 mov     ecx, [ebp+this]
.text:000091F2                 mov     eax, [ecx+4]
.text:000091F5                 jmp     short loc_920B
.text:000091F7 ; ---------------------------------------------------------------------------
.text:000091F7
.text:000091F7 loc_91F7:                               ; CODE XREF: CGetProp::Release(void)+2Dj
.text:000091F7                 mov     edx, [ebp+this]
.text:000091FA                 mov     [ebp+var_4], edx
.text:000091FD                 mov     eax, [ebp+var_4]
.text:00009200                 push    eax             ; void *
.text:00009201                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00009206                 add     esp, 4
.text:00009209                 xor     eax, eax
.text:0000920B
.text:0000920B loc_920B:                               ; CODE XREF: CGetProp::Release(void)+35j
.text:0000920B                 add     esp, 8
.text:0000920E                 cmp     ebp, esp
.text:00009210                 call    __RTC_CheckEsp
.text:00009215                 mov     esp, ebp
.text:00009217                 pop     ebp
.text:00009218                 retn    4
.text:00009218 ?Release@CGetProp@@UAGKXZ endp
.text:00009218
.text:00009218 ; ---------------------------------------------------------------------------
.text:0000921B                 align 4
.text:0000921B _text           ends
.text:0000921B
.text:0000921C ; ===========================================================================
.text:0000921C
.text:0000921C ; Segment type: Pure code
.text:0000921C ; Segment permissions: Read/Execute
.text:0000921C _text           segment para public 'CODE' use32
.text:0000921C                 assume cs:_text
.text:0000921C                 ;org 921Ch
.text:0000921C ; COMDAT (pick any)
.text:0000921C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000921C
.text:0000921C ; =============== S U B R O U T I N E =======================================
.text:0000921C
.text:0000921C ; Attributes: bp-based frame
.text:0000921C
.text:0000921C ; _DWORD __thiscall CIndexToPathPair::~CIndexToPathPair(CIndexToPathPair *__hidden this)
.text:0000921C                 public ??1CIndexToPathPair@@QAE@XZ
.text:0000921C ??1CIndexToPathPair@@QAE@XZ proc near   ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1838p
.text:0000921C                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3168p ...
.text:0000921C
.text:0000921C var_4           = dword ptr -4
.text:0000921C
.text:0000921C                 push    ebp
.text:0000921D                 mov     ebp, esp
.text:0000921F                 push    ecx
.text:00009220                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009227                 mov     [ebp+var_4], ecx
.text:0000922A                 mov     ecx, [ebp+var_4]
.text:0000922D                 add     ecx, 4          ; this
.text:00009230                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00009235                 add     esp, 4
.text:00009238                 cmp     ebp, esp
.text:0000923A                 call    __RTC_CheckEsp
.text:0000923F                 mov     esp, ebp
.text:00009241                 pop     ebp
.text:00009242                 retn
.text:00009242 ??1CIndexToPathPair@@QAE@XZ endp
.text:00009242
.text:00009242 ; ---------------------------------------------------------------------------
.text:00009243                 align 4
.text:00009243 _text           ends
.text:00009243
.text:00009244 ; ===========================================================================
.text:00009244
.text:00009244 ; Segment type: Pure code
.text:00009244 ; Segment permissions: Read/Execute
.text:00009244 _text           segment para public 'CODE' use32
.text:00009244                 assume cs:_text
.text:00009244                 ;org 9244h
.text:00009244 ; COMDAT (pick any)
.text:00009244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009244
.text:00009244 ; =============== S U B R O U T I N E =======================================
.text:00009244
.text:00009244 ; Attributes: bp-based frame
.text:00009244
.text:00009244 ; public: __thiscall COutFileStream::COutFileStream(void)
.text:00009244                 public ??0COutFileStream@@QAE@XZ
.text:00009244 ??0COutFileStream@@QAE@XZ proc near     ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2EEEp
.text:00009244
.text:00009244 var_4           = dword ptr -4
.text:00009244
.text:00009244                 push    ebp
.text:00009245                 mov     ebp, esp
.text:00009247                 push    ecx
.text:00009248                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000924F                 mov     [ebp+var_4], ecx
.text:00009252                 mov     ecx, [ebp+var_4] ; this
.text:00009255                 call    ??0IOutStream@@QAE@XZ ; IOutStream::IOutStream(void)
.text:0000925A                 mov     ecx, [ebp+var_4]
.text:0000925D                 add     ecx, 4          ; this
.text:00009260                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:00009265                 mov     eax, [ebp+var_4]
.text:00009268                 mov     dword ptr [eax], offset ??_7COutFileStream@@6B@ ; const COutFileStream::`vftable'
.text:0000926E                 mov     ecx, [ebp+var_4]
.text:00009271                 add     ecx, 8          ; this
.text:00009274                 call    ??0COutFile@NIO@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NIO::COutFile::COutFile(void)
.text:00009279                 mov     eax, [ebp+var_4]
.text:0000927C                 add     esp, 4
.text:0000927F                 cmp     ebp, esp
.text:00009281                 call    __RTC_CheckEsp
.text:00009286                 mov     esp, ebp
.text:00009288                 pop     ebp
.text:00009289                 retn
.text:00009289 ??0COutFileStream@@QAE@XZ endp
.text:00009289
.text:00009289 ; ---------------------------------------------------------------------------
.text:0000928A                 align 4
.text:0000928A _text           ends
.text:0000928A
.rdata:0000928C ; ===========================================================================
.rdata:0000928C
.rdata:0000928C ; Segment type: Pure data
.rdata:0000928C ; Segment permissions: Read
.rdata:0000928C _rdata          segment dword public 'DATA' use32
.rdata:0000928C                 assume cs:_rdata
.rdata:0000928C                 ;org 928Ch
.rdata:0000928C ; COMDAT (pick largest)
.rdata:0000928C                 dd offset ??_R4COutFileStream@@6B@ ; const COutFileStream::`RTTI Complete Object Locator'
.rdata:00009290                 public ??_7COutFileStream@@6B@
.rdata:00009290 ; const COutFileStream::`vftable'
.rdata:00009290 ??_7COutFileStream@@6B@ dd offset ?QueryInterface@COutFileStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:00009290                                         ; DATA XREF: COutFileStream::COutFileStream(void)+24o
.rdata:00009290                                         ; COutFileStream::~COutFileStream(void)+11o
.rdata:00009290                                         ; COutFileStream::QueryInterface(_GUID const &,void * *)
.rdata:00009294                 dd offset ?AddRef@COutFileStream@@UAGKXZ ; COutFileStream::AddRef(void)
.rdata:00009298                 dd offset ?Release@COutFileStream@@UAGKXZ ; COutFileStream::Release(void)
.rdata:0000929C                 dd offset ?Write@COutFileStream@@UAGJPBXIPAI@Z ; COutFileStream::Write(void const *,uint,uint *)
.rdata:000092A0                 dd offset ?Seek@COutFileStream@@UAGJ_JIPA_K@Z ; COutFileStream::Seek(__int64,uint,unsigned __int64 *)
.rdata:000092A4                 dd offset ?SetSize@COutFileStream@@UAGJ_K@Z ; COutFileStream::SetSize(unsigned __int64)
.rdata:000092A8                 dd offset ??_ECOutFileStream@@UAEPAXI@Z ; COutFileStream::`vector deleting destructor'(uint)
.rdata:000092A8 _rdata          ends
.rdata:000092A8
.rdata$r:000092AC ; ===========================================================================
.rdata$r:000092AC
.rdata$r:000092AC ; Segment type: Pure data
.rdata$r:000092AC ; Segment permissions: Read
.rdata$r:000092AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000092AC                 assume cs:_rdata$r
.rdata$r:000092AC                 ;org 92ACh
.rdata$r:000092AC ; COMDAT (pick any)
.rdata$r:000092AC                 public ??_R4COutFileStream@@6B@
.rdata$r:000092AC ; const COutFileStream::`RTTI Complete Object Locator'
.rdata$r:000092AC ??_R4COutFileStream@@6B@ db    0        ; DATA XREF: .rdata:0000928Co
.rdata$r:000092AD                 db    0
.rdata$r:000092AE                 db    0
.rdata$r:000092AF                 db    0
.rdata$r:000092B0                 db    0
.rdata$r:000092B1                 db    0
.rdata$r:000092B2                 db    0
.rdata$r:000092B3                 db    0
.rdata$r:000092B4                 db    0
.rdata$r:000092B5                 db    0
.rdata$r:000092B6                 db    0
.rdata$r:000092B7                 db    0
.rdata$r:000092B8                 dd offset ??_R0?AVCOutFileStream@@@8 ; COutFileStream `RTTI Type Descriptor'
.rdata$r:000092BC                 dd offset ??_R3COutFileStream@@8 ; COutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000092BC _rdata$r        ends
.rdata$r:000092BC
.data:000092C0 ; ===========================================================================
.data:000092C0
.data:000092C0 ; Segment type: Pure data
.data:000092C0 ; Segment permissions: Read/Write
.data:000092C0 _data           segment dword public 'DATA' use32
.data:000092C0                 assume cs:_data
.data:000092C0                 ;org 92C0h
.data:000092C0 ; COMDAT (pick any)
.data:000092C0                 public ??_R0?AVCOutFileStream@@@8
.data:000092C0 ; class COutFileStream `RTTI Type Descriptor'
.data:000092C0 ??_R0?AVCOutFileStream@@@8 dd offset ??_7type_info@@6B@
.data:000092C0                                         ; DATA XREF: .rdata$r:000092B8o
.data:000092C0                                         ; .rdata$r:COutFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000092C0                                         ; const type_info::`vftable'
.data:000092C4                 align 8
.data:000092C8 a_?avcoutfilest db '.?AVCOutFileStream@@',0
.data:000092DD                 align 10h
.data:000092DD _data           ends
.data:000092DD
.rdata$r:000092E0 ; ===========================================================================
.rdata$r:000092E0
.rdata$r:000092E0 ; Segment type: Pure data
.rdata$r:000092E0 ; Segment permissions: Read
.rdata$r:000092E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000092E0                 assume cs:_rdata$r
.rdata$r:000092E0                 ;org 92E0h
.rdata$r:000092E0 ; COMDAT (pick any)
.rdata$r:000092E0                 public ??_R3COutFileStream@@8
.rdata$r:000092E0 ; COutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000092E0 ??_R3COutFileStream@@8 db    0          ; DATA XREF: .rdata$r:000092BCo
.rdata$r:000092E0                                         ; .rdata$r:00009320o
.rdata$r:000092E1                 db    0
.rdata$r:000092E2                 db    0
.rdata$r:000092E3                 db    0
.rdata$r:000092E4                 db    1
.rdata$r:000092E5                 db    0
.rdata$r:000092E6                 db    0
.rdata$r:000092E7                 db    0
.rdata$r:000092E8                 db    5
.rdata$r:000092E9                 db    0
.rdata$r:000092EA                 db    0
.rdata$r:000092EB                 db    0
.rdata$r:000092EC                 dd offset ??_R2COutFileStream@@8 ; COutFileStream::`RTTI Base Class Array'
.rdata$r:000092EC _rdata$r        ends
.rdata$r:000092EC
.rdata$r:000092F0 ; ===========================================================================
.rdata$r:000092F0
.rdata$r:000092F0 ; Segment type: Pure data
.rdata$r:000092F0 ; Segment permissions: Read
.rdata$r:000092F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000092F0                 assume cs:_rdata$r
.rdata$r:000092F0                 ;org 92F0h
.rdata$r:000092F0 ; COMDAT (pick any)
.rdata$r:000092F0                 public ??_R2COutFileStream@@8
.rdata$r:000092F0 ; COutFileStream::`RTTI Base Class Array'
.rdata$r:000092F0 ??_R2COutFileStream@@8 dd offset ??_R1A@?0A@EA@COutFileStream@@8
.rdata$r:000092F0                                         ; DATA XREF: .rdata$r:000092ECo
.rdata$r:000092F0                                         ; COutFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000092F4                 dd offset ??_R1A@?0A@EA@IOutStream@@8 ; IOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000092F8                 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000092FC                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009300                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:00009304                 db    0
.rdata$r:00009305                 align 4
.rdata$r:00009305 _rdata$r        ends
.rdata$r:00009305
.rdata$r:00009308 ; ===========================================================================
.rdata$r:00009308
.rdata$r:00009308 ; Segment type: Pure data
.rdata$r:00009308 ; Segment permissions: Read
.rdata$r:00009308 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009308                 assume cs:_rdata$r
.rdata$r:00009308                 ;org 9308h
.rdata$r:00009308 ; COMDAT (pick any)
.rdata$r:00009308                 public ??_R1A@?0A@EA@COutFileStream@@8
.rdata$r:00009308 ; COutFileStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009308 ??_R1A@?0A@EA@COutFileStream@@8 dd offset ??_R0?AVCOutFileStream@@@8
.rdata$r:00009308                                         ; DATA XREF: .rdata$r:COutFileStream::`RTTI Base Class Array'o
.rdata$r:00009308                                         ; COutFileStream `RTTI Type Descriptor'
.rdata$r:0000930C                 db    4
.rdata$r:0000930D                 db    0
.rdata$r:0000930E                 db    0
.rdata$r:0000930F                 db    0
.rdata$r:00009310                 db    0
.rdata$r:00009311                 db    0
.rdata$r:00009312                 db    0
.rdata$r:00009313                 db    0
.rdata$r:00009314                 db 0FFh
.rdata$r:00009315                 db 0FFh
.rdata$r:00009316                 db 0FFh
.rdata$r:00009317                 db 0FFh
.rdata$r:00009318                 db    0
.rdata$r:00009319                 db    0
.rdata$r:0000931A                 db    0
.rdata$r:0000931B                 db    0
.rdata$r:0000931C                 db  40h ; @
.rdata$r:0000931D                 db    0
.rdata$r:0000931E                 db    0
.rdata$r:0000931F                 db    0
.rdata$r:00009320                 dd offset ??_R3COutFileStream@@8 ; COutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009320 _rdata$r        ends
.rdata$r:00009320
.rdata$r:00009324 ; ===========================================================================
.rdata$r:00009324
.rdata$r:00009324 ; Segment type: Pure data
.rdata$r:00009324 ; Segment permissions: Read
.rdata$r:00009324 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009324                 assume cs:_rdata$r
.rdata$r:00009324                 ;org 9324h
.rdata$r:00009324 ; COMDAT (pick any)
.rdata$r:00009324                 public ??_R1A@?0A@EA@IOutStream@@8
.rdata$r:00009324 ; IOutStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009324 ??_R1A@?0A@EA@IOutStream@@8 dd offset ??_R0?AUIOutStream@@@8
.rdata$r:00009324                                         ; DATA XREF: .rdata$r:000092F4o
.rdata$r:00009324                                         ; .rdata$r:IOutStream::`RTTI Base Class Array'o
.rdata$r:00009324                                         ; IOutStream `RTTI Type Descriptor'
.rdata$r:00009328                 db    2
.rdata$r:00009329                 db    0
.rdata$r:0000932A                 db    0
.rdata$r:0000932B                 db    0
.rdata$r:0000932C                 db    0
.rdata$r:0000932D                 db    0
.rdata$r:0000932E                 db    0
.rdata$r:0000932F                 db    0
.rdata$r:00009330                 db 0FFh
.rdata$r:00009331                 db 0FFh
.rdata$r:00009332                 db 0FFh
.rdata$r:00009333                 db 0FFh
.rdata$r:00009334                 db    0
.rdata$r:00009335                 db    0
.rdata$r:00009336                 db    0
.rdata$r:00009337                 db    0
.rdata$r:00009338                 db  40h ; @
.rdata$r:00009339                 db    0
.rdata$r:0000933A                 db    0
.rdata$r:0000933B                 db    0
.rdata$r:0000933C                 dd offset ??_R3IOutStream@@8 ; IOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000933C _rdata$r        ends
.rdata$r:0000933C
.data:00009340 ; ===========================================================================
.data:00009340
.data:00009340 ; Segment type: Pure data
.data:00009340 ; Segment permissions: Read/Write
.data:00009340 _data           segment dword public 'DATA' use32
.data:00009340                 assume cs:_data
.data:00009340                 ;org 9340h
.data:00009340 ; COMDAT (pick any)
.data:00009340                 public ??_R0?AUIOutStream@@@8
.data:00009340 ; struct IOutStream `RTTI Type Descriptor'
.data:00009340 ??_R0?AUIOutStream@@@8 dd offset ??_7type_info@@6B@
.data:00009340                                         ; DATA XREF: .rdata$r:IOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00009340                                         ; .rdata$r:000095FCo
.data:00009340                                         ; const type_info::`vftable'
.data:00009344                 align 8
.data:00009348 a_?auioutstream db '.?AUIOutStream@@',0
.data:00009359                 align 4
.data:00009359 _data           ends
.data:00009359
.rdata$r:0000935C ; ===========================================================================
.rdata$r:0000935C
.rdata$r:0000935C ; Segment type: Pure data
.rdata$r:0000935C ; Segment permissions: Read
.rdata$r:0000935C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000935C                 assume cs:_rdata$r
.rdata$r:0000935C                 ;org 935Ch
.rdata$r:0000935C ; COMDAT (pick any)
.rdata$r:0000935C                 public ??_R3IOutStream@@8
.rdata$r:0000935C ; IOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000935C ??_R3IOutStream@@8 db    0              ; DATA XREF: .rdata$r:0000933Co
.rdata$r:0000935C                                         ; .rdata$r:00009600o
.rdata$r:0000935D                 db    0
.rdata$r:0000935E                 db    0
.rdata$r:0000935F                 db    0
.rdata$r:00009360                 db    0
.rdata$r:00009361                 db    0
.rdata$r:00009362                 db    0
.rdata$r:00009363                 db    0
.rdata$r:00009364                 db    3
.rdata$r:00009365                 db    0
.rdata$r:00009366                 db    0
.rdata$r:00009367                 db    0
.rdata$r:00009368                 dd offset ??_R2IOutStream@@8 ; IOutStream::`RTTI Base Class Array'
.rdata$r:00009368 _rdata$r        ends
.rdata$r:00009368
.rdata$r:0000936C ; ===========================================================================
.rdata$r:0000936C
.rdata$r:0000936C ; Segment type: Pure data
.rdata$r:0000936C ; Segment permissions: Read
.rdata$r:0000936C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000936C                 assume cs:_rdata$r
.rdata$r:0000936C                 ;org 936Ch
.rdata$r:0000936C ; COMDAT (pick any)
.rdata$r:0000936C                 public ??_R2IOutStream@@8
.rdata$r:0000936C ; IOutStream::`RTTI Base Class Array'
.rdata$r:0000936C ??_R2IOutStream@@8 dd offset ??_R1A@?0A@EA@IOutStream@@8
.rdata$r:0000936C                                         ; DATA XREF: .rdata$r:00009368o
.rdata$r:0000936C                                         ; IOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009370                 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009374                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009378                 db    0
.rdata$r:00009379                 align 4
.rdata$r:00009379 _rdata$r        ends
.rdata$r:00009379
.text:0000937C ; ===========================================================================
.text:0000937C
.text:0000937C ; Segment type: Pure code
.text:0000937C ; Segment permissions: Read/Execute
.text:0000937C _text           segment para public 'CODE' use32
.text:0000937C                 assume cs:_text
.text:0000937C                 ;org 937Ch
.text:0000937C ; COMDAT (pick any)
.text:0000937C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000937C
.text:0000937C ; =============== S U B R O U T I N E =======================================
.text:0000937C
.text:0000937C ; Attributes: bp-based frame
.text:0000937C
.text:0000937C ; __int32 __stdcall COutFileStream::QueryInterface(COutFileStream *this, const struct _GUID *Buf1, void **)
.text:0000937C                 public ?QueryInterface@COutFileStream@@UAGJABU_GUID@@PAPAX@Z
.text:0000937C ?QueryInterface@COutFileStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:0000937C                                         ; DATA XREF: .rdata:const COutFileStream::`vftable'o
.text:0000937C
.text:0000937C this            = dword ptr  8
.text:0000937C Buf1            = dword ptr  0Ch
.text:0000937C arg_8           = dword ptr  10h
.text:0000937C
.text:0000937C                 push    ebp
.text:0000937D                 mov     ebp, esp
.text:0000937F                 mov     eax, [ebp+arg_8]
.text:00009382                 mov     dword ptr [eax], 0
.text:00009388                 push    offset _IID_IUnknown ; Buf2
.text:0000938D                 mov     ecx, [ebp+Buf1]
.text:00009390                 push    ecx             ; Buf1
.text:00009391                 call    ___@8           ; __(x,x)
.text:00009396                 test    eax, eax
.text:00009398                 jz      short loc_93A4
.text:0000939A                 mov     edx, [ebp+arg_8]
.text:0000939D                 mov     eax, [ebp+this]
.text:000093A0                 mov     [edx], eax
.text:000093A2                 jmp     short loc_93C7
.text:000093A4 ; ---------------------------------------------------------------------------
.text:000093A4
.text:000093A4 loc_93A4:                               ; CODE XREF: COutFileStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:000093A4                 push    offset _IID_IOutStream ; Buf2
.text:000093A9                 mov     ecx, [ebp+Buf1]
.text:000093AC                 push    ecx             ; Buf1
.text:000093AD                 call    ___@8           ; __(x,x)
.text:000093B2                 test    eax, eax
.text:000093B4                 jz      short loc_93C0
.text:000093B6                 mov     edx, [ebp+arg_8]
.text:000093B9                 mov     eax, [ebp+this]
.text:000093BC                 mov     [edx], eax
.text:000093BE                 jmp     short loc_93C7
.text:000093C0 ; ---------------------------------------------------------------------------
.text:000093C0
.text:000093C0 loc_93C0:                               ; CODE XREF: COutFileStream::QueryInterface(_GUID const &,void * *)+38j
.text:000093C0                 mov     eax, 80004002h
.text:000093C5                 jmp     short loc_93D8
.text:000093C7 ; ---------------------------------------------------------------------------
.text:000093C7
.text:000093C7 loc_93C7:                               ; CODE XREF: COutFileStream::QueryInterface(_GUID const &,void * *)+26j
.text:000093C7                                         ; COutFileStream::QueryInterface(_GUID const &,void * *)+42j
.text:000093C7                 mov     ecx, [ebp+this]
.text:000093CA                 mov     edx, [ecx+4]
.text:000093CD                 add     edx, 1
.text:000093D0                 mov     eax, [ebp+this]
.text:000093D3                 mov     [eax+4], edx
.text:000093D6                 xor     eax, eax
.text:000093D8
.text:000093D8 loc_93D8:                               ; CODE XREF: COutFileStream::QueryInterface(_GUID const &,void * *)+49j
.text:000093D8                 cmp     ebp, esp
.text:000093DA                 call    __RTC_CheckEsp
.text:000093DF                 pop     ebp
.text:000093E0                 retn    0Ch
.text:000093E0 ?QueryInterface@COutFileStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:000093E0
.text:000093E0 ; ---------------------------------------------------------------------------
.text:000093E3                 align 4
.text:000093E3 _text           ends
.text:000093E3
.text:000093E4 ; ===========================================================================
.text:000093E4
.text:000093E4 ; Segment type: Pure code
.text:000093E4 ; Segment permissions: Read/Execute
.text:000093E4 _text           segment para public 'CODE' use32
.text:000093E4                 assume cs:_text
.text:000093E4                 ;org 93E4h
.text:000093E4 ; COMDAT (pick any)
.text:000093E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000093E4
.text:000093E4 ; =============== S U B R O U T I N E =======================================
.text:000093E4
.text:000093E4 ; Attributes: bp-based frame
.text:000093E4
.text:000093E4 ; unsigned __int32 __stdcall COutFileStream::AddRef(COutFileStream *this)
.text:000093E4                 public ?AddRef@COutFileStream@@UAGKXZ
.text:000093E4 ?AddRef@COutFileStream@@UAGKXZ proc near ; DATA XREF: .rdata:00009294o
.text:000093E4
.text:000093E4 var_4           = dword ptr -4
.text:000093E4 this            = dword ptr  8
.text:000093E4
.text:000093E4                 push    ebp
.text:000093E5                 mov     ebp, esp
.text:000093E7                 push    ecx
.text:000093E8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000093EF                 mov     eax, [ebp+this]
.text:000093F2                 mov     ecx, [eax+4]
.text:000093F5                 add     ecx, 1
.text:000093F8                 mov     [ebp+var_4], ecx
.text:000093FB                 mov     edx, [ebp+this]
.text:000093FE                 mov     eax, [ebp+var_4]
.text:00009401                 mov     [edx+4], eax
.text:00009404                 mov     eax, [ebp+var_4]
.text:00009407                 mov     esp, ebp
.text:00009409                 pop     ebp
.text:0000940A                 retn    4
.text:0000940A ?AddRef@COutFileStream@@UAGKXZ endp
.text:0000940A
.text:0000940A ; ---------------------------------------------------------------------------
.text:0000940D                 align 10h
.text:0000940D _text           ends
.text:0000940D
.text:00009410 ; ===========================================================================
.text:00009410
.text:00009410 ; Segment type: Pure code
.text:00009410 ; Segment permissions: Read/Execute
.text:00009410 _text           segment para public 'CODE' use32
.text:00009410                 assume cs:_text
.text:00009410                 ;org 9410h
.text:00009410 ; COMDAT (pick any)
.text:00009410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009410
.text:00009410 ; =============== S U B R O U T I N E =======================================
.text:00009410
.text:00009410 ; Attributes: bp-based frame
.text:00009410
.text:00009410 ; unsigned __int32 __stdcall COutFileStream::Release(COutFileStream *this)
.text:00009410                 public ?Release@COutFileStream@@UAGKXZ
.text:00009410 ?Release@COutFileStream@@UAGKXZ proc near ; DATA XREF: .rdata:00009298o
.text:00009410
.text:00009410 var_10          = dword ptr -10h
.text:00009410 var_C           = dword ptr -0Ch
.text:00009410 var_8           = dword ptr -8
.text:00009410 var_4           = dword ptr -4
.text:00009410 this            = dword ptr  8
.text:00009410
.text:00009410                 push    ebp
.text:00009411                 mov     ebp, esp
.text:00009413                 sub     esp, 10h
.text:00009416                 push    esi
.text:00009417                 mov     eax, 0CCCCCCCCh
.text:0000941C                 mov     [ebp+var_10], eax
.text:0000941F                 mov     [ebp+var_C], eax
.text:00009422                 mov     [ebp+var_8], eax
.text:00009425                 mov     [ebp+var_4], eax
.text:00009428                 mov     eax, [ebp+this]
.text:0000942B                 mov     ecx, [eax+4]
.text:0000942E                 sub     ecx, 1
.text:00009431                 mov     [ebp+var_C], ecx
.text:00009434                 mov     edx, [ebp+this]
.text:00009437                 mov     eax, [ebp+var_C]
.text:0000943A                 mov     [edx+4], eax
.text:0000943D                 cmp     [ebp+var_C], 0
.text:00009441                 jz      short loc_944B
.text:00009443                 mov     ecx, [ebp+this]
.text:00009446                 mov     eax, [ecx+4]
.text:00009449                 jmp     short loc_9483
.text:0000944B ; ---------------------------------------------------------------------------
.text:0000944B
.text:0000944B loc_944B:                               ; CODE XREF: COutFileStream::Release(void)+31j
.text:0000944B                 mov     edx, [ebp+this]
.text:0000944E                 mov     [ebp+var_8], edx
.text:00009451                 mov     eax, [ebp+var_8]
.text:00009454                 mov     [ebp+var_4], eax
.text:00009457                 cmp     [ebp+var_4], 0
.text:0000945B                 jz      short loc_947A
.text:0000945D                 mov     esi, esp
.text:0000945F                 push    1
.text:00009461                 mov     ecx, [ebp+var_4]
.text:00009464                 mov     edx, [ecx]
.text:00009466                 mov     ecx, [ebp+var_4]
.text:00009469                 mov     eax, [edx+18h]
.text:0000946C                 call    eax
.text:0000946E                 cmp     esi, esp
.text:00009470                 call    __RTC_CheckEsp
.text:00009475                 mov     [ebp+var_10], eax
.text:00009478                 jmp     short loc_9481
.text:0000947A ; ---------------------------------------------------------------------------
.text:0000947A
.text:0000947A loc_947A:                               ; CODE XREF: COutFileStream::Release(void)+4Bj
.text:0000947A                 mov     [ebp+var_10], 0
.text:00009481
.text:00009481 loc_9481:                               ; CODE XREF: COutFileStream::Release(void)+68j
.text:00009481                 xor     eax, eax
.text:00009483
.text:00009483 loc_9483:                               ; CODE XREF: COutFileStream::Release(void)+39j
.text:00009483                 pop     esi
.text:00009484                 add     esp, 10h
.text:00009487                 cmp     ebp, esp
.text:00009489                 call    __RTC_CheckEsp
.text:0000948E                 mov     esp, ebp
.text:00009490                 pop     ebp
.text:00009491                 retn    4
.text:00009491 ?Release@COutFileStream@@UAGKXZ endp
.text:00009491
.text:00009491 _text           ends
.text:00009491
.text:00009494 ; ===========================================================================
.text:00009494
.text:00009494 ; Segment type: Pure code
.text:00009494 ; Segment permissions: Read/Execute
.text:00009494 _text           segment para public 'CODE' use32
.text:00009494                 assume cs:_text
.text:00009494                 ;org 9494h
.text:00009494 ; COMDAT (pick any)
.text:00009494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009494
.text:00009494 ; =============== S U B R O U T I N E =======================================
.text:00009494
.text:00009494 ; Attributes: bp-based frame
.text:00009494
.text:00009494 ; public: virtual void * __thiscall COutFileStream::`scalar deleting destructor'(unsigned int)
.text:00009494                 public ??_GCOutFileStream@@UAEPAXI@Z
.text:00009494 ??_GCOutFileStream@@UAEPAXI@Z proc near
.text:00009494
.text:00009494 var_4           = dword ptr -4
.text:00009494 arg_0           = dword ptr  8
.text:00009494
.text:00009494                 push    ebp
.text:00009495                 mov     ebp, esp
.text:00009497                 push    ecx
.text:00009498                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000949F                 mov     [ebp+var_4], ecx
.text:000094A2                 mov     ecx, [ebp+var_4] ; this
.text:000094A5                 call    ??1COutFileStream@@UAE@XZ ; COutFileStream::~COutFileStream(void)
.text:000094AA                 mov     eax, [ebp+arg_0]
.text:000094AD                 and     eax, 1
.text:000094B0                 jz      short loc_94BE
.text:000094B2                 mov     ecx, [ebp+var_4]
.text:000094B5                 push    ecx             ; void *
.text:000094B6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000094BB                 add     esp, 4
.text:000094BE
.text:000094BE loc_94BE:                               ; CODE XREF: COutFileStream::`scalar deleting destructor'(uint)+1Cj
.text:000094BE                 mov     eax, [ebp+var_4]
.text:000094C1                 add     esp, 4
.text:000094C4                 cmp     ebp, esp
.text:000094C6                 call    __RTC_CheckEsp
.text:000094CB                 mov     esp, ebp
.text:000094CD                 pop     ebp
.text:000094CE                 retn    4
.text:000094CE ??_GCOutFileStream@@UAEPAXI@Z endp
.text:000094CE
.text:000094CE ; ---------------------------------------------------------------------------
.text:000094D1                 align 4
.text:000094D1 _text           ends
.text:000094D1
.text:000094D4 ; ===========================================================================
.text:000094D4
.text:000094D4 ; Segment type: Pure code
.text:000094D4 ; Segment permissions: Read/Execute
.text:000094D4 _text           segment para public 'CODE' use32
.text:000094D4                 assume cs:_text
.text:000094D4                 ;org 94D4h
.text:000094D4 ; COMDAT (pick any)
.text:000094D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000094D4
.text:000094D4 ; =============== S U B R O U T I N E =======================================
.text:000094D4
.text:000094D4 ; Attributes: bp-based frame
.text:000094D4
.text:000094D4 ; _DWORD __thiscall COutFileStream::~COutFileStream(COutFileStream *__hidden this)
.text:000094D4                 public ??1COutFileStream@@UAE@XZ
.text:000094D4 ??1COutFileStream@@UAE@XZ proc near     ; CODE XREF: COutFileStream::`scalar deleting destructor'(uint)+11p
.text:000094D4
.text:000094D4 var_4           = dword ptr -4
.text:000094D4
.text:000094D4                 push    ebp
.text:000094D5                 mov     ebp, esp
.text:000094D7                 push    ecx
.text:000094D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000094DF                 mov     [ebp+var_4], ecx
.text:000094E2                 mov     eax, [ebp+var_4]
.text:000094E5                 mov     dword ptr [eax], offset ??_7COutFileStream@@6B@ ; const COutFileStream::`vftable'
.text:000094EB                 mov     ecx, [ebp+var_4]
.text:000094EE                 add     ecx, 8          ; this
.text:000094F1                 call    ??1COutFile@NIO@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NIO::COutFile::~COutFile(void)
.text:000094F6                 add     esp, 4
.text:000094F9                 cmp     ebp, esp
.text:000094FB                 call    __RTC_CheckEsp
.text:00009500                 mov     esp, ebp
.text:00009502                 pop     ebp
.text:00009503                 retn
.text:00009503 ??1COutFileStream@@UAE@XZ endp
.text:00009503
.text:00009503 _text           ends
.text:00009503
.text:00009504 ; ===========================================================================
.text:00009504
.text:00009504 ; Segment type: Pure code
.text:00009504 ; Segment permissions: Read/Execute
.text:00009504 _text           segment para public 'CODE' use32
.text:00009504                 assume cs:_text
.text:00009504                 ;org 9504h
.text:00009504 ; COMDAT (pick any)
.text:00009504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009504
.text:00009504 ; =============== S U B R O U T I N E =======================================
.text:00009504
.text:00009504 ; Attributes: bp-based frame
.text:00009504
.text:00009504 ; _DWORD __thiscall NWindows::NFile::NIO::COutFile::~COutFile(NWindows::NFile::NIO::COutFile *__hidden this)
.text:00009504                 public ??1COutFile@NIO@NFile@NWindows@@QAE@XZ
.text:00009504 ??1COutFile@NIO@NFile@NWindows@@QAE@XZ proc near
.text:00009504                                         ; CODE XREF: COutFileStream::~COutFileStream(void)+1Dp
.text:00009504
.text:00009504 var_4           = dword ptr -4
.text:00009504
.text:00009504                 push    ebp
.text:00009505                 mov     ebp, esp
.text:00009507                 push    ecx
.text:00009508                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000950F                 mov     [ebp+var_4], ecx
.text:00009512                 mov     ecx, [ebp+var_4] ; this
.text:00009515                 call    ??1CFileBase@NIO@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NIO::CFileBase::~CFileBase(void)
.text:0000951A                 add     esp, 4
.text:0000951D                 cmp     ebp, esp
.text:0000951F                 call    __RTC_CheckEsp
.text:00009524                 mov     esp, ebp
.text:00009526                 pop     ebp
.text:00009527                 retn
.text:00009527 ??1COutFile@NIO@NFile@NWindows@@QAE@XZ endp
.text:00009527
.text:00009527 _text           ends
.text:00009527
.text:00009528 ; ===========================================================================
.text:00009528
.text:00009528 ; Segment type: Pure code
.text:00009528 ; Segment permissions: Read/Execute
.text:00009528 _text           segment para public 'CODE' use32
.text:00009528                 assume cs:_text
.text:00009528                 ;org 9528h
.text:00009528 ; COMDAT (pick any)
.text:00009528                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009528
.text:00009528 ; =============== S U B R O U T I N E =======================================
.text:00009528
.text:00009528 ; Attributes: bp-based frame
.text:00009528
.text:00009528 ; _DWORD __thiscall NWindows::NFile::NIO::CFileBase::~CFileBase(NWindows::NFile::NIO::CFileBase *__hidden this)
.text:00009528                 public ??1CFileBase@NIO@NFile@NWindows@@QAE@XZ
.text:00009528 ??1CFileBase@NIO@NFile@NWindows@@QAE@XZ proc near
.text:00009528                                         ; CODE XREF: NWindows::NFile::NIO::COutFile::~COutFile(void)+11p
.text:00009528
.text:00009528 var_4           = dword ptr -4
.text:00009528
.text:00009528                 push    ebp
.text:00009529                 mov     ebp, esp
.text:0000952B                 push    ecx
.text:0000952C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009533                 mov     [ebp+var_4], ecx
.text:00009536                 mov     ecx, [ebp+var_4] ; this
.text:00009539                 call    ?Close@CFileBase@NIO@NFile@NWindows@@QAE_NXZ ; NWindows::NFile::NIO::CFileBase::Close(void)
.text:0000953E                 add     esp, 4
.text:00009541                 cmp     ebp, esp
.text:00009543                 call    __RTC_CheckEsp
.text:00009548                 mov     esp, ebp
.text:0000954A                 pop     ebp
.text:0000954B                 retn
.text:0000954B ??1CFileBase@NIO@NFile@NWindows@@QAE@XZ endp
.text:0000954B
.text:0000954B _text           ends
.text:0000954B
.text:0000954C ; ===========================================================================
.text:0000954C
.text:0000954C ; Segment type: Pure code
.text:0000954C ; Segment permissions: Read/Execute
.text:0000954C _text           segment para public 'CODE' use32
.text:0000954C                 assume cs:_text
.text:0000954C                 ;org 954Ch
.text:0000954C ; COMDAT (pick any)
.text:0000954C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000954C
.text:0000954C ; =============== S U B R O U T I N E =======================================
.text:0000954C
.text:0000954C ; Attributes: bp-based frame
.text:0000954C
.text:0000954C ; _DWORD __thiscall IGetProp::IGetProp(IGetProp *__hidden this)
.text:0000954C                 public ??0IGetProp@@QAE@XZ
.text:0000954C ??0IGetProp@@QAE@XZ proc near           ; CODE XREF: CGetProp::CGetProp(void)+11p
.text:0000954C
.text:0000954C var_4           = dword ptr -4
.text:0000954C
.text:0000954C                 push    ebp
.text:0000954D                 mov     ebp, esp
.text:0000954F                 push    ecx
.text:00009550                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009557                 mov     [ebp+var_4], ecx
.text:0000955A                 mov     ecx, [ebp+var_4]
.text:0000955D                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00009562                 mov     eax, [ebp+var_4]
.text:00009565                 mov     dword ptr [eax], offset ??_7IGetProp@@6B@ ; const IGetProp::`vftable'
.text:0000956B                 mov     eax, [ebp+var_4]
.text:0000956E                 add     esp, 4
.text:00009571                 cmp     ebp, esp
.text:00009573                 call    __RTC_CheckEsp
.text:00009578                 mov     esp, ebp
.text:0000957A                 pop     ebp
.text:0000957B                 retn
.text:0000957B ??0IGetProp@@QAE@XZ endp
.text:0000957B
.text:0000957B _text           ends
.text:0000957B
.rdata:0000957C ; ===========================================================================
.rdata:0000957C
.rdata:0000957C ; Segment type: Pure data
.rdata:0000957C ; Segment permissions: Read
.rdata:0000957C _rdata          segment dword public 'DATA' use32
.rdata:0000957C                 assume cs:_rdata
.rdata:0000957C                 ;org 957Ch
.rdata:0000957C ; COMDAT (pick largest)
.rdata:0000957C                 dd offset ??_R4IGetProp@@6B@ ; const IGetProp::`RTTI Complete Object Locator'
.rdata:00009580                 public ??_7IGetProp@@6B@
.rdata:00009580 ; const IGetProp::`vftable'
.rdata:00009580 ??_7IGetProp@@6B@ dd offset __purecall  ; DATA XREF: IGetProp::IGetProp(void)+19o
.rdata:00009584                 dd offset __purecall
.rdata:00009588                 dd offset __purecall
.rdata:0000958C                 dd offset __purecall
.rdata:0000958C _rdata          ends
.rdata:0000958C
.rdata$r:00009590 ; ===========================================================================
.rdata$r:00009590
.rdata$r:00009590 ; Segment type: Pure data
.rdata$r:00009590 ; Segment permissions: Read
.rdata$r:00009590 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009590                 assume cs:_rdata$r
.rdata$r:00009590                 ;org 9590h
.rdata$r:00009590 ; COMDAT (pick any)
.rdata$r:00009590                 public ??_R4IGetProp@@6B@
.rdata$r:00009590 ; const IGetProp::`RTTI Complete Object Locator'
.rdata$r:00009590 ??_R4IGetProp@@6B@ db    0              ; DATA XREF: .rdata:0000957Co
.rdata$r:00009591                 db    0
.rdata$r:00009592                 db    0
.rdata$r:00009593                 db    0
.rdata$r:00009594                 db    0
.rdata$r:00009595                 db    0
.rdata$r:00009596                 db    0
.rdata$r:00009597                 db    0
.rdata$r:00009598                 db    0
.rdata$r:00009599                 db    0
.rdata$r:0000959A                 db    0
.rdata$r:0000959B                 db    0
.rdata$r:0000959C                 dd offset ??_R0?AUIGetProp@@@8 ; IGetProp `RTTI Type Descriptor'
.rdata$r:000095A0                 dd offset ??_R3IGetProp@@8 ; IGetProp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000095A0 _rdata$r        ends
.rdata$r:000095A0
.text:000095A4 ; ===========================================================================
.text:000095A4
.text:000095A4 ; Segment type: Pure code
.text:000095A4 ; Segment permissions: Read/Execute
.text:000095A4 _text           segment para public 'CODE' use32
.text:000095A4                 assume cs:_text
.text:000095A4                 ;org 95A4h
.text:000095A4 ; COMDAT (pick any)
.text:000095A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000095A4
.text:000095A4 ; =============== S U B R O U T I N E =======================================
.text:000095A4
.text:000095A4 ; Attributes: bp-based frame
.text:000095A4
.text:000095A4 ; _DWORD __thiscall IOutStream::IOutStream(IOutStream *__hidden this)
.text:000095A4                 public ??0IOutStream@@QAE@XZ
.text:000095A4 ??0IOutStream@@QAE@XZ proc near         ; CODE XREF: COutFileStream::COutFileStream(void)+11p
.text:000095A4
.text:000095A4 var_4           = dword ptr -4
.text:000095A4
.text:000095A4                 push    ebp
.text:000095A5                 mov     ebp, esp
.text:000095A7                 push    ecx
.text:000095A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000095AF                 mov     [ebp+var_4], ecx
.text:000095B2                 mov     ecx, [ebp+var_4] ; this
.text:000095B5                 call    ??0ISequentialOutStream@@QAE@XZ ; ISequentialOutStream::ISequentialOutStream(void)
.text:000095BA                 mov     eax, [ebp+var_4]
.text:000095BD                 mov     dword ptr [eax], offset ??_7IOutStream@@6B@ ; const IOutStream::`vftable'
.text:000095C3                 mov     eax, [ebp+var_4]
.text:000095C6                 add     esp, 4
.text:000095C9                 cmp     ebp, esp
.text:000095CB                 call    __RTC_CheckEsp
.text:000095D0                 mov     esp, ebp
.text:000095D2                 pop     ebp
.text:000095D3                 retn
.text:000095D3 ??0IOutStream@@QAE@XZ endp
.text:000095D3
.text:000095D3 _text           ends
.text:000095D3
.rdata:000095D4 ; ===========================================================================
.rdata:000095D4
.rdata:000095D4 ; Segment type: Pure data
.rdata:000095D4 ; Segment permissions: Read
.rdata:000095D4 _rdata          segment dword public 'DATA' use32
.rdata:000095D4                 assume cs:_rdata
.rdata:000095D4                 ;org 95D4h
.rdata:000095D4 ; COMDAT (pick largest)
.rdata:000095D4                 dd offset ??_R4IOutStream@@6B@ ; const IOutStream::`RTTI Complete Object Locator'
.rdata:000095D8                 public ??_7IOutStream@@6B@
.rdata:000095D8 ; const IOutStream::`vftable'
.rdata:000095D8 ??_7IOutStream@@6B@ dd offset __purecall
.rdata:000095D8                                         ; DATA XREF: IOutStream::IOutStream(void)+19o
.rdata:000095DC                 dd offset __purecall
.rdata:000095E0                 dd offset __purecall
.rdata:000095E4                 dd offset __purecall
.rdata:000095E8                 dd offset __purecall
.rdata:000095EC                 dd offset __purecall
.rdata:000095EC _rdata          ends
.rdata:000095EC
.rdata$r:000095F0 ; ===========================================================================
.rdata$r:000095F0
.rdata$r:000095F0 ; Segment type: Pure data
.rdata$r:000095F0 ; Segment permissions: Read
.rdata$r:000095F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000095F0                 assume cs:_rdata$r
.rdata$r:000095F0                 ;org 95F0h
.rdata$r:000095F0 ; COMDAT (pick any)
.rdata$r:000095F0                 public ??_R4IOutStream@@6B@
.rdata$r:000095F0 ; const IOutStream::`RTTI Complete Object Locator'
.rdata$r:000095F0 ??_R4IOutStream@@6B@ db    0            ; DATA XREF: .rdata:000095D4o
.rdata$r:000095F1                 db    0
.rdata$r:000095F2                 db    0
.rdata$r:000095F3                 db    0
.rdata$r:000095F4                 db    0
.rdata$r:000095F5                 db    0
.rdata$r:000095F6                 db    0
.rdata$r:000095F7                 db    0
.rdata$r:000095F8                 db    0
.rdata$r:000095F9                 db    0
.rdata$r:000095FA                 db    0
.rdata$r:000095FB                 db    0
.rdata$r:000095FC                 dd offset ??_R0?AUIOutStream@@@8 ; IOutStream `RTTI Type Descriptor'
.rdata$r:00009600                 dd offset ??_R3IOutStream@@8 ; IOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009600 _rdata$r        ends
.rdata$r:00009600
.text:00009604 ; ===========================================================================
.text:00009604
.text:00009604 ; Segment type: Pure code
.text:00009604 ; Segment permissions: Read/Execute
.text:00009604 _text           segment para public 'CODE' use32
.text:00009604                 assume cs:_text
.text:00009604                 ;org 9604h
.text:00009604 ; COMDAT (pick any)
.text:00009604                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009604
.text:00009604 ; =============== S U B R O U T I N E =======================================
.text:00009604
.text:00009604 ; Attributes: bp-based frame
.text:00009604
.text:00009604 ; _DWORD __thiscall NWindows::NFile::NIO::COutFile::COutFile(NWindows::NFile::NIO::COutFile *__hidden this)
.text:00009604                 public ??0COutFile@NIO@NFile@NWindows@@QAE@XZ
.text:00009604 ??0COutFile@NIO@NFile@NWindows@@QAE@XZ proc near
.text:00009604                                         ; CODE XREF: COutFileStream::COutFileStream(void)+30p
.text:00009604
.text:00009604 var_4           = dword ptr -4
.text:00009604
.text:00009604                 push    ebp
.text:00009605                 mov     ebp, esp
.text:00009607                 push    ecx
.text:00009608                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000960F                 mov     [ebp+var_4], ecx
.text:00009612                 mov     ecx, [ebp+var_4] ; this
.text:00009615                 call    ??0CFileBase@NIO@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NIO::CFileBase::CFileBase(void)
.text:0000961A                 mov     eax, [ebp+var_4]
.text:0000961D                 add     esp, 4
.text:00009620                 cmp     ebp, esp
.text:00009622                 call    __RTC_CheckEsp
.text:00009627                 mov     esp, ebp
.text:00009629                 pop     ebp
.text:0000962A                 retn
.text:0000962A ??0COutFile@NIO@NFile@NWindows@@QAE@XZ endp
.text:0000962A
.text:0000962A ; ---------------------------------------------------------------------------
.text:0000962B                 align 4
.text:0000962B _text           ends
.text:0000962B
.text:0000962C ; ===========================================================================
.text:0000962C
.text:0000962C ; Segment type: Pure code
.text:0000962C ; Segment permissions: Read/Execute
.text:0000962C _text           segment para public 'CODE' use32
.text:0000962C                 assume cs:_text
.text:0000962C                 ;org 962Ch
.text:0000962C ; COMDAT (pick any)
.text:0000962C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000962C
.text:0000962C ; =============== S U B R O U T I N E =======================================
.text:0000962C
.text:0000962C ; Attributes: bp-based frame
.text:0000962C
.text:0000962C ; _DWORD __thiscall NWindows::NFile::NIO::CFileBase::CFileBase(NWindows::NFile::NIO::CFileBase *__hidden this)
.text:0000962C                 public ??0CFileBase@NIO@NFile@NWindows@@QAE@XZ
.text:0000962C ??0CFileBase@NIO@NFile@NWindows@@QAE@XZ proc near
.text:0000962C                                         ; CODE XREF: NWindows::NFile::NIO::COutFile::COutFile(void)+11p
.text:0000962C
.text:0000962C var_4           = dword ptr -4
.text:0000962C
.text:0000962C                 push    ebp
.text:0000962D                 mov     ebp, esp
.text:0000962F                 push    ecx
.text:00009630                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009637                 mov     [ebp+var_4], ecx
.text:0000963A                 mov     eax, [ebp+var_4]
.text:0000963D                 mov     dword ptr [eax], 0FFFFFFFFh
.text:00009643                 mov     eax, [ebp+var_4]
.text:00009646                 mov     esp, ebp
.text:00009648                 pop     ebp
.text:00009649                 retn
.text:00009649 ??0CFileBase@NIO@NFile@NWindows@@QAE@XZ endp
.text:00009649
.text:00009649 ; ---------------------------------------------------------------------------
.text:0000964A                 align 4
.text:0000964A _text           ends
.text:0000964A
.text:0000964C ; ===========================================================================
.text:0000964C
.text:0000964C ; Segment type: Pure code
.text:0000964C ; Segment permissions: Read/Execute
.text:0000964C _text           segment para public 'CODE' use32
.text:0000964C                 assume cs:_text
.text:0000964C                 ;org 964Ch
.text:0000964C ; COMDAT (pick any)
.text:0000964C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000964C
.text:0000964C ; =============== S U B R O U T I N E =======================================
.text:0000964C
.text:0000964C ; Attributes: bp-based frame
.text:0000964C
.text:0000964C ; bool __thiscall COutFileStream::SetTime(COutFileStream *this, const struct _FILETIME *, const struct _FILETIME *, const struct _FILETIME *)
.text:0000964C                 public ?SetTime@COutFileStream@@QAE_NPBU_FILETIME@@00@Z
.text:0000964C ?SetTime@COutFileStream@@QAE_NPBU_FILETIME@@00@Z proc near
.text:0000964C                                         ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+239p
.text:0000964C
.text:0000964C var_4           = dword ptr -4
.text:0000964C arg_0           = dword ptr  8
.text:0000964C arg_4           = dword ptr  0Ch
.text:0000964C arg_8           = dword ptr  10h
.text:0000964C
.text:0000964C                 push    ebp
.text:0000964D                 mov     ebp, esp
.text:0000964F                 push    ecx
.text:00009650                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009657                 mov     [ebp+var_4], ecx
.text:0000965A                 mov     eax, [ebp+arg_8]
.text:0000965D                 push    eax             ; struct _FILETIME *
.text:0000965E                 mov     ecx, [ebp+arg_4]
.text:00009661                 push    ecx             ; struct _FILETIME *
.text:00009662                 mov     edx, [ebp+arg_0]
.text:00009665                 push    edx             ; struct _FILETIME *
.text:00009666                 mov     ecx, [ebp+var_4]
.text:00009669                 add     ecx, 8          ; this
.text:0000966C                 call    ?SetTime@COutFile@NIO@NFile@NWindows@@QAE_NPBU_FILETIME@@00@Z ; NWindows::NFile::NIO::COutFile::SetTime(_FILETIME const *,_FILETIME const *,_FILETIME const *)
.text:00009671                 add     esp, 4
.text:00009674                 cmp     ebp, esp
.text:00009676                 call    __RTC_CheckEsp
.text:0000967B                 mov     esp, ebp
.text:0000967D                 pop     ebp
.text:0000967E                 retn    0Ch
.text:0000967E ?SetTime@COutFileStream@@QAE_NPBU_FILETIME@@00@Z endp
.text:0000967E
.text:0000967E ; ---------------------------------------------------------------------------
.text:00009681                 align 4
.text:00009681 _text           ends
.text:00009681
.text:00009684 ; ===========================================================================
.text:00009684
.text:00009684 ; Segment type: Pure code
.text:00009684 ; Segment permissions: Read/Execute
.text:00009684 _text           segment para public 'CODE' use32
.text:00009684                 assume cs:_text
.text:00009684                 ;org 9684h
.text:00009684 ; COMDAT (pick any)
.text:00009684                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009684
.text:00009684 ; =============== S U B R O U T I N E =======================================
.text:00009684
.text:00009684 ; Attributes: bp-based frame
.text:00009684
.text:00009684 ; unsigned __int64 __thiscall COutStreamWithHash::GetSize(COutStreamWithHash *__hidden this)
.text:00009684                 public ?GetSize@COutStreamWithHash@@QBE_KXZ
.text:00009684 ?GetSize@COutStreamWithHash@@QBE_KXZ proc near
.text:00009684                                         ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+10Dp
.text:00009684
.text:00009684 var_4           = dword ptr -4
.text:00009684
.text:00009684                 push    ebp
.text:00009685                 mov     ebp, esp
.text:00009687                 push    ecx
.text:00009688                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000968F                 mov     [ebp+var_4], ecx
.text:00009692                 mov     ecx, [ebp+var_4]
.text:00009695                 mov     eax, [ecx+10h]
.text:00009698                 mov     edx, [ecx+14h]
.text:0000969B                 mov     esp, ebp
.text:0000969D                 pop     ebp
.text:0000969E                 retn
.text:0000969E ?GetSize@COutStreamWithHash@@QBE_KXZ endp
.text:0000969E
.text:0000969E ; ---------------------------------------------------------------------------
.text:0000969F                 align 10h
.text:0000969F _text           ends
.text:0000969F
.text:000096A0 ; ===========================================================================
.text:000096A0
.text:000096A0 ; Segment type: Pure code
.text:000096A0 ; Segment permissions: Read/Execute
.text:000096A0 _text           segment para public 'CODE' use32
.text:000096A0                 assume cs:_text
.text:000096A0                 ;org 96A0h
.text:000096A0 ; COMDAT (pick any)
.text:000096A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000096A0
.text:000096A0 ; =============== S U B R O U T I N E =======================================
.text:000096A0
.text:000096A0 ; Attributes: bp-based frame
.text:000096A0
.text:000096A0 ; public: unsigned int __thiscall CObjectVector<class UString>::Size(void)const
.text:000096A0                 public ?Size@?$CObjectVector@VUString@@@@QBEIXZ
.text:000096A0 ?Size@?$CObjectVector@VUString@@@@QBEIXZ proc near
.text:000096A0                                         ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+AAp
.text:000096A0                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+6A1p ...
.text:000096A0
.text:000096A0 var_4           = dword ptr -4
.text:000096A0
.text:000096A0                 push    ebp
.text:000096A1                 mov     ebp, esp
.text:000096A3                 push    ecx
.text:000096A4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000096AB                 mov     [ebp+var_4], ecx
.text:000096AE                 mov     ecx, [ebp+var_4]
.text:000096B1                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000096B6                 add     esp, 4
.text:000096B9                 cmp     ebp, esp
.text:000096BB                 call    __RTC_CheckEsp
.text:000096C0                 mov     esp, ebp
.text:000096C2                 pop     ebp
.text:000096C3                 retn
.text:000096C3 ?Size@?$CObjectVector@VUString@@@@QBEIXZ endp
.text:000096C3
.text:000096C3 _text           ends
.text:000096C3
.text:000096C4 ; ===========================================================================
.text:000096C4
.text:000096C4 ; Segment type: Pure code
.text:000096C4 ; Segment permissions: Read/Execute
.text:000096C4 _text           segment para public 'CODE' use32
.text:000096C4                 assume cs:_text
.text:000096C4                 ;org 96C4h
.text:000096C4 ; COMDAT (pick any)
.text:000096C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000096C4
.text:000096C4 ; =============== S U B R O U T I N E =======================================
.text:000096C4
.text:000096C4 ; Attributes: bp-based frame
.text:000096C4
.text:000096C4 ; public: bool __thiscall CObjectVector<class UString>::IsEmpty(void)const
.text:000096C4                 public ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ
.text:000096C4 ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ proc near
.text:000096C4                                         ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+24p
.text:000096C4                                         ; CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+B5p ...
.text:000096C4
.text:000096C4 var_4           = dword ptr -4
.text:000096C4
.text:000096C4                 push    ebp
.text:000096C5                 mov     ebp, esp
.text:000096C7                 push    ecx
.text:000096C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000096CF                 mov     [ebp+var_4], ecx
.text:000096D2                 mov     ecx, [ebp+var_4]
.text:000096D5                 call    ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ ; CRecordVector<void *>::IsEmpty(void)
.text:000096DA                 add     esp, 4
.text:000096DD                 cmp     ebp, esp
.text:000096DF                 call    __RTC_CheckEsp
.text:000096E4                 mov     esp, ebp
.text:000096E6                 pop     ebp
.text:000096E7                 retn
.text:000096E7 ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ endp
.text:000096E7
.text:000096E7 _text           ends
.text:000096E7
.text:000096E8 ; ===========================================================================
.text:000096E8
.text:000096E8 ; Segment type: Pure code
.text:000096E8 ; Segment permissions: Read/Execute
.text:000096E8 _text           segment para public 'CODE' use32
.text:000096E8                 assume cs:_text
.text:000096E8                 ;org 96E8h
.text:000096E8 ; COMDAT (pick any)
.text:000096E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000096E8
.text:000096E8 ; =============== S U B R O U T I N E =======================================
.text:000096E8
.text:000096E8 ; Attributes: bp-based frame
.text:000096E8
.text:000096E8 ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(void)
.text:000096E8                 public ??0?$CObjectVector@VUString@@@@QAE@XZ
.text:000096E8 ??0?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:000096E8                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+195p
.text:000096E8                                         ; CArchiveExtractCallback::CArchiveExtractCallback(void)+1C3p ...
.text:000096E8
.text:000096E8 var_4           = dword ptr -4
.text:000096E8
.text:000096E8                 push    ebp
.text:000096E9                 mov     ebp, esp
.text:000096EB                 push    ecx
.text:000096EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000096F3                 mov     [ebp+var_4], ecx
.text:000096F6                 mov     ecx, [ebp+var_4]
.text:000096F9                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:000096FE                 mov     eax, [ebp+var_4]
.text:00009701                 add     esp, 4
.text:00009704                 cmp     ebp, esp
.text:00009706                 call    __RTC_CheckEsp
.text:0000970B                 mov     esp, ebp
.text:0000970D                 pop     ebp
.text:0000970E                 retn
.text:0000970E ??0?$CObjectVector@VUString@@@@QAE@XZ endp
.text:0000970E
.text:0000970E ; ---------------------------------------------------------------------------
.text:0000970F                 align 10h
.text:0000970F _text           ends
.text:0000970F
.text:00009710 ; ===========================================================================
.text:00009710
.text:00009710 ; Segment type: Pure code
.text:00009710 ; Segment permissions: Read/Execute
.text:00009710 _text           segment para public 'CODE' use32
.text:00009710                 assume cs:_text
.text:00009710                 ;org 9710h
.text:00009710 ; COMDAT (pick any)
.text:00009710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009710
.text:00009710 ; =============== S U B R O U T I N E =======================================
.text:00009710
.text:00009710 ; Attributes: bp-based frame
.text:00009710
.text:00009710 ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(class CObjectVector<class UString> const &)
.text:00009710                 public ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text:00009710 ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z proc near
.text:00009710                                         ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+A6p
.text:00009710
.text:00009710 var_24          = dword ptr -24h
.text:00009710 var_20          = dword ptr -20h
.text:00009710 var_1C          = dword ptr -1Ch
.text:00009710 var_18          = dword ptr -18h
.text:00009710 var_14          = dword ptr -14h
.text:00009710 var_10          = dword ptr -10h
.text:00009710 var_C           = dword ptr -0Ch
.text:00009710 var_4           = dword ptr -4
.text:00009710 arg_0           = dword ptr  8
.text:00009710
.text:00009710                 push    ebp
.text:00009711                 mov     ebp, esp
.text:00009713                 push    0FFFFFFFFh
.text:00009715                 push    offset __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text:0000971A                 mov     eax, large fs:0
.text:00009720                 push    eax
.text:00009721                 sub     esp, 18h
.text:00009724                 mov     eax, 0CCCCCCCCh
.text:00009729                 mov     [ebp+var_24], eax
.text:0000972C                 mov     [ebp+var_20], eax
.text:0000972F                 mov     [ebp+var_1C], eax
.text:00009732                 mov     [ebp+var_18], eax
.text:00009735                 mov     [ebp+var_14], eax
.text:00009738                 mov     [ebp+var_10], eax
.text:0000973B                 mov     eax, dword ptr ds:___security_cookie
.text:00009740                 xor     eax, ebp
.text:00009742                 push    eax
.text:00009743                 lea     eax, [ebp+var_C]
.text:00009746                 mov     large fs:0, eax
.text:0000974C                 mov     [ebp+var_10], ecx
.text:0000974F                 mov     ecx, [ebp+var_10]
.text:00009752                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00009757                 mov     [ebp+var_4], 0
.text:0000975E                 mov     ecx, [ebp+arg_0]
.text:00009761                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00009766                 mov     [ebp+var_14], eax
.text:00009769                 mov     eax, [ebp+var_14]
.text:0000976C                 push    eax
.text:0000976D                 mov     ecx, [ebp+var_10]
.text:00009770                 call    ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ConstructReserve(uint)
.text:00009775                 mov     [ebp+var_18], 0
.text:0000977C                 jmp     short loc_9787
.text:0000977E ; ---------------------------------------------------------------------------
.text:0000977E
.text:0000977E loc_977E:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+CDj
.text:0000977E                 mov     ecx, [ebp+var_18]
.text:00009781                 add     ecx, 1
.text:00009784                 mov     [ebp+var_18], ecx
.text:00009787
.text:00009787 loc_9787:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+6Cj
.text:00009787                 mov     edx, [ebp+var_18]
.text:0000978A                 cmp     edx, [ebp+var_14]
.text:0000978D                 jnb     short loc_97DF
.text:0000978F                 push    0Ch             ; unsigned int
.text:00009791                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00009796                 add     esp, 4
.text:00009799                 mov     [ebp+var_20], eax
.text:0000979C                 mov     byte ptr [ebp+var_4], 1
.text:000097A0                 cmp     [ebp+var_20], 0
.text:000097A4                 jz      short loc_97C0
.text:000097A6                 mov     eax, [ebp+var_18]
.text:000097A9                 push    eax
.text:000097AA                 mov     ecx, [ebp+arg_0]
.text:000097AD                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000097B2                 push    eax
.text:000097B3                 mov     ecx, [ebp+var_20]
.text:000097B6                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000097BB                 mov     [ebp+var_24], eax
.text:000097BE                 jmp     short loc_97C7
.text:000097C0 ; ---------------------------------------------------------------------------
.text:000097C0
.text:000097C0 loc_97C0:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+94j
.text:000097C0                 mov     [ebp+var_24], 0
.text:000097C7
.text:000097C7 loc_97C7:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+AEj
.text:000097C7                 mov     ecx, [ebp+var_24]
.text:000097CA                 mov     [ebp+var_1C], ecx
.text:000097CD                 mov     byte ptr [ebp+var_4], 0
.text:000097D1                 mov     edx, [ebp+var_1C]
.text:000097D4                 push    edx
.text:000097D5                 mov     ecx, [ebp+var_10]
.text:000097D8                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:000097DD                 jmp     short loc_977E
.text:000097DF ; ---------------------------------------------------------------------------
.text:000097DF
.text:000097DF loc_97DF:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+7Dj
.text:000097DF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000097E6                 mov     eax, [ebp+var_10]
.text:000097E9                 mov     ecx, [ebp+var_C]
.text:000097EC                 mov     large fs:0, ecx
.text:000097F3                 pop     ecx
.text:000097F4                 add     esp, 24h
.text:000097F7                 cmp     ebp, esp
.text:000097F9                 call    __RTC_CheckEsp
.text:000097FE                 mov     esp, ebp
.text:00009800                 pop     ebp
.text:00009801                 retn    4
.text:00009801 ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z endp
.text:00009801
.text:00009801 _text           ends
.text:00009801
.text$x:00009804 ; ===========================================================================
.text$x:00009804
.text$x:00009804 ; Segment type: Pure code
.text$x:00009804 ; Segment permissions: Read/Execute
.text$x:00009804 _text$x         segment para public 'CODE' use32
.text$x:00009804                 assume cs:_text$x
.text$x:00009804                 ;org 9804h
.text$x:00009804 ; COMDAT (pick associative to section at 9710)
.text$x:00009804                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009804
.text$x:00009804 ; =============== S U B R O U T I N E =======================================
.text$x:00009804
.text$x:00009804
.text$x:00009804 __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0 proc near
.text$x:00009804                                         ; DATA XREF: .xdata$x:00009838o
.text$x:00009804                 mov     ecx, [ebp-10h]
.text$x:00009807                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00009807 __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0 endp
.text$x:00009807
.text$x:0000980C
.text$x:0000980C ; =============== S U B R O U T I N E =======================================
.text$x:0000980C
.text$x:0000980C
.text$x:0000980C __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1 proc near
.text$x:0000980C                                         ; DATA XREF: .xdata$x:00009840o
.text$x:0000980C                 mov     eax, [ebp-20h]
.text$x:0000980F                 push    eax             ; void *
.text$x:00009810                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00009815                 pop     ecx
.text$x:00009816                 retn
.text$x:00009816 __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1 endp
.text$x:00009816
.text$x:00009817
.text$x:00009817 ; =============== S U B R O U T I N E =======================================
.text$x:00009817
.text$x:00009817
.text$x:00009817 __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z proc near
.text$x:00009817                                         ; DATA XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+5o
.text$x:00009817
.text$x:00009817 arg_4           = dword ptr  8
.text$x:00009817
.text$x:00009817                 mov     edx, [esp+arg_4]
.text$x:0000981B                 lea     eax, [edx+0Ch]
.text$x:0000981E                 mov     ecx, [edx-1Ch]
.text$x:00009821                 xor     ecx, eax
.text$x:00009823                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009828                 mov     eax, offset __ehfuncinfo$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text$x:0000982D                 jmp     ___CxxFrameHandler3
.text$x:0000982D __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z endp
.text$x:0000982D
.text$x:0000982D ; ---------------------------------------------------------------------------
.text$x:00009832                 align 4
.text$x:00009832 _text$x         ends
.text$x:00009832
.xdata$x:00009834 ; ===========================================================================
.xdata$x:00009834
.xdata$x:00009834 ; Segment type: Pure data
.xdata$x:00009834 ; Segment permissions: Read
.xdata$x:00009834 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009834                 assume cs:_xdata$x
.xdata$x:00009834                 ;org 9834h
.xdata$x:00009834 ; COMDAT (pick associative to section at 9710)
.xdata$x:00009834 __unwindtable$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z db 0FFh
.xdata$x:00009834                                         ; DATA XREF: .xdata$x:0000984Co
.xdata$x:00009835                 db 0FFh
.xdata$x:00009836                 db 0FFh
.xdata$x:00009837                 db 0FFh
.xdata$x:00009838                 dd offset __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0
.xdata$x:0000983C                 align 10h
.xdata$x:00009840                 dd offset __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1
.xdata$x:00009844 __ehfuncinfo$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z db  22h ; "
.xdata$x:00009844                                         ; DATA XREF: __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z+11o
.xdata$x:00009845                 db    5
.xdata$x:00009846                 db  93h ; ô
.xdata$x:00009847                 db  19h
.xdata$x:00009848                 db    2
.xdata$x:00009849                 db    0
.xdata$x:0000984A                 db    0
.xdata$x:0000984B                 db    0
.xdata$x:0000984C                 dd offset __unwindtable$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.xdata$x:00009850                 db    0
.xdata$x:00009851                 db    0
.xdata$x:00009852                 db    0
.xdata$x:00009853                 db    0
.xdata$x:00009854                 db    0
.xdata$x:00009855                 db    0
.xdata$x:00009856                 db    0
.xdata$x:00009857                 db    0
.xdata$x:00009858                 db    0
.xdata$x:00009859                 db    0
.xdata$x:0000985A                 db    0
.xdata$x:0000985B                 db    0
.xdata$x:0000985C                 db    0
.xdata$x:0000985D                 db    0
.xdata$x:0000985E                 db    0
.xdata$x:0000985F                 db    0
.xdata$x:00009860                 db    0
.xdata$x:00009861                 db    0
.xdata$x:00009862                 db    0
.xdata$x:00009863                 db    0
.xdata$x:00009864                 db    1
.xdata$x:00009865                 db    0
.xdata$x:00009866                 db    0
.xdata$x:00009867                 db    0
.xdata$x:00009867 _xdata$x        ends
.xdata$x:00009867
.text:00009868 ; ===========================================================================
.text:00009868
.text:00009868 ; Segment type: Pure code
.text:00009868 ; Segment permissions: Read/Execute
.text:00009868 _text           segment para public 'CODE' use32
.text:00009868                 assume cs:_text
.text:00009868                 ;org 9868h
.text:00009868 ; COMDAT (pick any)
.text:00009868                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009868
.text:00009868 ; =============== S U B R O U T I N E =======================================
.text:00009868
.text:00009868 ; Attributes: bp-based frame
.text:00009868
.text:00009868 ; public: class CObjectVector<class UString> & __thiscall CObjectVector<class UString>::operator=(class CObjectVector<class UString> const &)
.text:00009868                 public ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text:00009868 ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z proc near
.text:00009868                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+1E2p
.text:00009868
.text:00009868 var_24          = dword ptr -24h
.text:00009868 var_20          = dword ptr -20h
.text:00009868 var_1C          = dword ptr -1Ch
.text:00009868 var_18          = dword ptr -18h
.text:00009868 var_14          = dword ptr -14h
.text:00009868 var_10          = dword ptr -10h
.text:00009868 var_C           = dword ptr -0Ch
.text:00009868 var_4           = dword ptr -4
.text:00009868 arg_0           = dword ptr  8
.text:00009868
.text:00009868                 push    ebp
.text:00009869                 mov     ebp, esp
.text:0000986B                 push    0FFFFFFFFh
.text:0000986D                 push    offset __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text:00009872                 mov     eax, large fs:0
.text:00009878                 push    eax
.text:00009879                 sub     esp, 18h
.text:0000987C                 mov     eax, 0CCCCCCCCh
.text:00009881                 mov     [ebp+var_24], eax
.text:00009884                 mov     [ebp+var_20], eax
.text:00009887                 mov     [ebp+var_1C], eax
.text:0000988A                 mov     [ebp+var_18], eax
.text:0000988D                 mov     [ebp+var_14], eax
.text:00009890                 mov     [ebp+var_10], eax
.text:00009893                 mov     eax, dword ptr ds:___security_cookie
.text:00009898                 xor     eax, ebp
.text:0000989A                 push    eax
.text:0000989B                 lea     eax, [ebp+var_C]
.text:0000989E                 mov     large fs:0, eax
.text:000098A4                 mov     [ebp+var_10], ecx
.text:000098A7                 mov     eax, [ebp+arg_0]
.text:000098AA                 cmp     eax, [ebp+var_10]
.text:000098AD                 jnz     short loc_98B7
.text:000098AF                 mov     eax, [ebp+var_10]
.text:000098B2                 jmp     loc_9949
.text:000098B7 ; ---------------------------------------------------------------------------
.text:000098B7
.text:000098B7 loc_98B7:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+45j
.text:000098B7                 mov     ecx, [ebp+var_10]
.text:000098BA                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:000098BF                 mov     ecx, [ebp+arg_0]
.text:000098C2                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000098C7                 mov     [ebp+var_14], eax
.text:000098CA                 mov     ecx, [ebp+var_14]
.text:000098CD                 push    ecx
.text:000098CE                 mov     ecx, [ebp+var_10]
.text:000098D1                 call    ?Reserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Reserve(uint)
.text:000098D6                 mov     [ebp+var_18], 0
.text:000098DD                 jmp     short loc_98E8
.text:000098DF ; ---------------------------------------------------------------------------
.text:000098DF
.text:000098DF loc_98DF:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+DCj
.text:000098DF                 mov     edx, [ebp+var_18]
.text:000098E2                 add     edx, 1
.text:000098E5                 mov     [ebp+var_18], edx
.text:000098E8
.text:000098E8 loc_98E8:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+75j
.text:000098E8                 mov     eax, [ebp+var_18]
.text:000098EB                 cmp     eax, [ebp+var_14]
.text:000098EE                 jnb     short loc_9946
.text:000098F0                 push    0Ch             ; unsigned int
.text:000098F2                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000098F7                 add     esp, 4
.text:000098FA                 mov     [ebp+var_20], eax
.text:000098FD                 mov     [ebp+var_4], 0
.text:00009904                 cmp     [ebp+var_20], 0
.text:00009908                 jz      short loc_9924
.text:0000990A                 mov     ecx, [ebp+var_18]
.text:0000990D                 push    ecx
.text:0000990E                 mov     ecx, [ebp+arg_0]
.text:00009911                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00009916                 push    eax
.text:00009917                 mov     ecx, [ebp+var_20]
.text:0000991A                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000991F                 mov     [ebp+var_24], eax
.text:00009922                 jmp     short loc_992B
.text:00009924 ; ---------------------------------------------------------------------------
.text:00009924
.text:00009924 loc_9924:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+A0j
.text:00009924                 mov     [ebp+var_24], 0
.text:0000992B
.text:0000992B loc_992B:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+BAj
.text:0000992B                 mov     edx, [ebp+var_24]
.text:0000992E                 mov     [ebp+var_1C], edx
.text:00009931                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009938                 mov     eax, [ebp+var_1C]
.text:0000993B                 push    eax
.text:0000993C                 mov     ecx, [ebp+var_10]
.text:0000993F                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00009944                 jmp     short loc_98DF
.text:00009946 ; ---------------------------------------------------------------------------
.text:00009946
.text:00009946 loc_9946:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+86j
.text:00009946                 mov     eax, [ebp+var_10]
.text:00009949
.text:00009949 loc_9949:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+4Aj
.text:00009949                 mov     ecx, [ebp+var_C]
.text:0000994C                 mov     large fs:0, ecx
.text:00009953                 pop     ecx
.text:00009954                 add     esp, 24h
.text:00009957                 cmp     ebp, esp
.text:00009959                 call    __RTC_CheckEsp
.text:0000995E                 mov     esp, ebp
.text:00009960                 pop     ebp
.text:00009961                 retn    4
.text:00009961 ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z endp
.text:00009961
.text:00009961 _text           ends
.text:00009961
.text$x:00009964 ; ===========================================================================
.text$x:00009964
.text$x:00009964 ; Segment type: Pure code
.text$x:00009964 ; Segment permissions: Read/Execute
.text$x:00009964 _text$x         segment para public 'CODE' use32
.text$x:00009964                 assume cs:_text$x
.text$x:00009964                 ;org 9964h
.text$x:00009964 ; COMDAT (pick associative to section at 9868)
.text$x:00009964                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009964
.text$x:00009964 ; =============== S U B R O U T I N E =======================================
.text$x:00009964
.text$x:00009964
.text$x:00009964 __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0 proc near
.text$x:00009964                                         ; DATA XREF: .xdata$x:00009990o
.text$x:00009964                 mov     eax, [ebp-20h]
.text$x:00009967                 push    eax             ; void *
.text$x:00009968                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000996D                 pop     ecx
.text$x:0000996E                 retn
.text$x:0000996E __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0 endp
.text$x:0000996E
.text$x:0000996F
.text$x:0000996F ; =============== S U B R O U T I N E =======================================
.text$x:0000996F
.text$x:0000996F
.text$x:0000996F __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z proc near
.text$x:0000996F                                         ; DATA XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+5o
.text$x:0000996F
.text$x:0000996F arg_4           = dword ptr  8
.text$x:0000996F
.text$x:0000996F                 mov     edx, [esp+arg_4]
.text$x:00009973                 lea     eax, [edx+0Ch]
.text$x:00009976                 mov     ecx, [edx-1Ch]
.text$x:00009979                 xor     ecx, eax
.text$x:0000997B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009980                 mov     eax, offset __ehfuncinfo$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text$x:00009985                 jmp     ___CxxFrameHandler3
.text$x:00009985 __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z endp
.text$x:00009985
.text$x:00009985 ; ---------------------------------------------------------------------------
.text$x:0000998A                 align 4
.text$x:0000998A _text$x         ends
.text$x:0000998A
.xdata$x:0000998C ; ===========================================================================
.xdata$x:0000998C
.xdata$x:0000998C ; Segment type: Pure data
.xdata$x:0000998C ; Segment permissions: Read
.xdata$x:0000998C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000998C                 assume cs:_xdata$x
.xdata$x:0000998C                 ;org 998Ch
.xdata$x:0000998C ; COMDAT (pick associative to section at 9868)
.xdata$x:0000998C __unwindtable$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z db 0FFh
.xdata$x:0000998C                                         ; DATA XREF: .xdata$x:0000999Co
.xdata$x:0000998D                 db 0FFh
.xdata$x:0000998E                 db 0FFh
.xdata$x:0000998F                 db 0FFh
.xdata$x:00009990                 dd offset __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0
.xdata$x:00009994 __ehfuncinfo$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z db  22h ; "
.xdata$x:00009994                                         ; DATA XREF: __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z+11o
.xdata$x:00009995                 db    5
.xdata$x:00009996                 db  93h ; ô
.xdata$x:00009997                 db  19h
.xdata$x:00009998                 db    1
.xdata$x:00009999                 db    0
.xdata$x:0000999A                 db    0
.xdata$x:0000999B                 db    0
.xdata$x:0000999C                 dd offset __unwindtable$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.xdata$x:000099A0                 db    0
.xdata$x:000099A1                 db    0
.xdata$x:000099A2                 db    0
.xdata$x:000099A3                 db    0
.xdata$x:000099A4                 db    0
.xdata$x:000099A5                 db    0
.xdata$x:000099A6                 db    0
.xdata$x:000099A7                 db    0
.xdata$x:000099A8                 db    0
.xdata$x:000099A9                 db    0
.xdata$x:000099AA                 db    0
.xdata$x:000099AB                 db    0
.xdata$x:000099AC                 db    0
.xdata$x:000099AD                 db    0
.xdata$x:000099AE                 db    0
.xdata$x:000099AF                 db    0
.xdata$x:000099B0                 db    0
.xdata$x:000099B1                 db    0
.xdata$x:000099B2                 db    0
.xdata$x:000099B3                 db    0
.xdata$x:000099B4                 db    1
.xdata$x:000099B5                 db    0
.xdata$x:000099B6                 db    0
.xdata$x:000099B7                 db    0
.xdata$x:000099B7 _xdata$x        ends
.xdata$x:000099B7
.text:000099B8 ; ===========================================================================
.text:000099B8
.text:000099B8 ; Segment type: Pure code
.text:000099B8 ; Segment permissions: Read/Execute
.text:000099B8 _text           segment para public 'CODE' use32
.text:000099B8                 assume cs:_text
.text:000099B8                 ;org 99B8h
.text:000099B8 ; COMDAT (pick any)
.text:000099B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000099B8
.text:000099B8 ; =============== S U B R O U T I N E =======================================
.text:000099B8
.text:000099B8 ; Attributes: bp-based frame
.text:000099B8
.text:000099B8 ; public: class UString const & __thiscall CObjectVector<class UString>::operator[](unsigned int)const
.text:000099B8                 public ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z
.text:000099B8 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z proc near
.text:000099B8                                         ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+35p
.text:000099B8                                         ; CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+C9p ...
.text:000099B8
.text:000099B8 var_4           = dword ptr -4
.text:000099B8 arg_0           = dword ptr  8
.text:000099B8
.text:000099B8                 push    ebp
.text:000099B9                 mov     ebp, esp
.text:000099BB                 push    ecx
.text:000099BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000099C3                 mov     [ebp+var_4], ecx
.text:000099C6                 mov     eax, [ebp+arg_0]
.text:000099C9                 push    eax
.text:000099CA                 mov     ecx, [ebp+var_4]
.text:000099CD                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000099D2                 mov     eax, [eax]
.text:000099D4                 add     esp, 4
.text:000099D7                 cmp     ebp, esp
.text:000099D9                 call    __RTC_CheckEsp
.text:000099DE                 mov     esp, ebp
.text:000099E0                 pop     ebp
.text:000099E1                 retn    4
.text:000099E1 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z endp
.text:000099E1
.text:000099E1 _text           ends
.text:000099E1
.text:000099E4 ; ===========================================================================
.text:000099E4
.text:000099E4 ; Segment type: Pure code
.text:000099E4 ; Segment permissions: Read/Execute
.text:000099E4 _text           segment para public 'CODE' use32
.text:000099E4                 assume cs:_text
.text:000099E4                 ;org 99E4h
.text:000099E4 ; COMDAT (pick any)
.text:000099E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000099E4
.text:000099E4 ; =============== S U B R O U T I N E =======================================
.text:000099E4
.text:000099E4 ; Attributes: bp-based frame
.text:000099E4
.text:000099E4 ; public: class UString & __thiscall CObjectVector<class UString>::operator[](unsigned int)
.text:000099E4                 public ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z
.text:000099E4 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z proc near
.text:000099E4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+733p
.text:000099E4                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+75Fp ...
.text:000099E4
.text:000099E4 var_4           = dword ptr -4
.text:000099E4 arg_0           = dword ptr  8
.text:000099E4
.text:000099E4                 push    ebp
.text:000099E5                 mov     ebp, esp
.text:000099E7                 push    ecx
.text:000099E8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000099EF                 mov     [ebp+var_4], ecx
.text:000099F2                 mov     eax, [ebp+arg_0]
.text:000099F5                 push    eax
.text:000099F6                 mov     ecx, [ebp+var_4]
.text:000099F9                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000099FE                 mov     eax, [eax]
.text:00009A00                 add     esp, 4
.text:00009A03                 cmp     ebp, esp
.text:00009A05                 call    __RTC_CheckEsp
.text:00009A0A                 mov     esp, ebp
.text:00009A0C                 pop     ebp
.text:00009A0D                 retn    4
.text:00009A0D ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z endp
.text:00009A0D
.text:00009A0D _text           ends
.text:00009A0D
.text:00009A10 ; ===========================================================================
.text:00009A10
.text:00009A10 ; Segment type: Pure code
.text:00009A10 ; Segment permissions: Read/Execute
.text:00009A10 _text           segment para public 'CODE' use32
.text:00009A10                 assume cs:_text
.text:00009A10                 ;org 9A10h
.text:00009A10 ; COMDAT (pick any)
.text:00009A10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009A10
.text:00009A10 ; =============== S U B R O U T I N E =======================================
.text:00009A10
.text:00009A10 ; Attributes: bp-based frame
.text:00009A10
.text:00009A10 ; public: class UString & __thiscall CObjectVector<class UString>::Back(void)
.text:00009A10                 public ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ
.text:00009A10 ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ proc near
.text:00009A10                                         ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+CCp
.text:00009A10                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+142Fp
.text:00009A10
.text:00009A10 var_4           = dword ptr -4
.text:00009A10
.text:00009A10                 push    ebp
.text:00009A11                 mov     ebp, esp
.text:00009A13                 push    ecx
.text:00009A14                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009A1B                 mov     [ebp+var_4], ecx
.text:00009A1E                 mov     ecx, [ebp+var_4]
.text:00009A21                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00009A26                 sub     eax, 1
.text:00009A29                 push    eax
.text:00009A2A                 mov     ecx, [ebp+var_4]
.text:00009A2D                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00009A32                 add     esp, 4
.text:00009A35                 cmp     ebp, esp
.text:00009A37                 call    __RTC_CheckEsp
.text:00009A3C                 mov     esp, ebp
.text:00009A3E                 pop     ebp
.text:00009A3F                 retn
.text:00009A3F ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ endp
.text:00009A3F
.text:00009A3F _text           ends
.text:00009A3F
.text:00009A40 ; ===========================================================================
.text:00009A40
.text:00009A40 ; Segment type: Pure code
.text:00009A40 ; Segment permissions: Read/Execute
.text:00009A40 _text           segment para public 'CODE' use32
.text:00009A40                 assume cs:_text
.text:00009A40                 ;org 9A40h
.text:00009A40 ; COMDAT (pick any)
.text:00009A40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009A40
.text:00009A40 ; =============== S U B R O U T I N E =======================================
.text:00009A40
.text:00009A40 ; Attributes: bp-based frame
.text:00009A40
.text:00009A40 ; public: unsigned int __thiscall CObjectVector<class UString>::Add(class UString const &)
.text:00009A40                 public ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00009A40 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text:00009A40                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+155Dp
.text:00009A40
.text:00009A40 var_1C          = dword ptr -1Ch
.text:00009A40 var_18          = dword ptr -18h
.text:00009A40 var_14          = dword ptr -14h
.text:00009A40 var_10          = dword ptr -10h
.text:00009A40 var_C           = dword ptr -0Ch
.text:00009A40 var_4           = dword ptr -4
.text:00009A40 arg_0           = dword ptr  8
.text:00009A40
.text:00009A40                 push    ebp
.text:00009A41                 mov     ebp, esp
.text:00009A43                 push    0FFFFFFFFh
.text:00009A45                 push    offset __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00009A4A                 mov     eax, large fs:0
.text:00009A50                 push    eax
.text:00009A51                 sub     esp, 10h
.text:00009A54                 mov     eax, 0CCCCCCCCh
.text:00009A59                 mov     [ebp+var_1C], eax
.text:00009A5C                 mov     [ebp+var_18], eax
.text:00009A5F                 mov     [ebp+var_14], eax
.text:00009A62                 mov     [ebp+var_10], eax
.text:00009A65                 mov     eax, dword ptr ds:___security_cookie
.text:00009A6A                 xor     eax, ebp
.text:00009A6C                 push    eax
.text:00009A6D                 lea     eax, [ebp+var_C]
.text:00009A70                 mov     large fs:0, eax
.text:00009A76                 mov     [ebp+var_10], ecx
.text:00009A79                 push    0Ch             ; unsigned int
.text:00009A7B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00009A80                 add     esp, 4
.text:00009A83                 mov     [ebp+var_18], eax
.text:00009A86                 mov     [ebp+var_4], 0
.text:00009A8D                 cmp     [ebp+var_18], 0
.text:00009A91                 jz      short loc_9AA4
.text:00009A93                 mov     eax, [ebp+arg_0]
.text:00009A96                 push    eax
.text:00009A97                 mov     ecx, [ebp+var_18]
.text:00009A9A                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00009A9F                 mov     [ebp+var_1C], eax
.text:00009AA2                 jmp     short loc_9AAB
.text:00009AA4 ; ---------------------------------------------------------------------------
.text:00009AA4
.text:00009AA4 loc_9AA4:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+51j
.text:00009AA4                 mov     [ebp+var_1C], 0
.text:00009AAB
.text:00009AAB loc_9AAB:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+62j
.text:00009AAB                 mov     ecx, [ebp+var_1C]
.text:00009AAE                 mov     [ebp+var_14], ecx
.text:00009AB1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009AB8                 mov     edx, [ebp+var_14]
.text:00009ABB                 push    edx
.text:00009ABC                 mov     ecx, [ebp+var_10]
.text:00009ABF                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00009AC4                 mov     ecx, [ebp+var_C]
.text:00009AC7                 mov     large fs:0, ecx
.text:00009ACE                 pop     ecx
.text:00009ACF                 add     esp, 1Ch
.text:00009AD2                 cmp     ebp, esp
.text:00009AD4                 call    __RTC_CheckEsp
.text:00009AD9                 mov     esp, ebp
.text:00009ADB                 pop     ebp
.text:00009ADC                 retn    4
.text:00009ADC ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text:00009ADC
.text:00009ADC ; ---------------------------------------------------------------------------
.text:00009ADF                 align 10h
.text:00009ADF _text           ends
.text:00009ADF
.text$x:00009AE0 ; ===========================================================================
.text$x:00009AE0
.text$x:00009AE0 ; Segment type: Pure code
.text$x:00009AE0 ; Segment permissions: Read/Execute
.text$x:00009AE0 _text$x         segment para public 'CODE' use32
.text$x:00009AE0                 assume cs:_text$x
.text$x:00009AE0                 ;org 9AE0h
.text$x:00009AE0 ; COMDAT (pick associative to section at 9A40)
.text$x:00009AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009AE0
.text$x:00009AE0 ; =============== S U B R O U T I N E =======================================
.text$x:00009AE0
.text$x:00009AE0
.text$x:00009AE0 __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 proc near
.text$x:00009AE0                                         ; DATA XREF: .xdata$x:00009B0Co
.text$x:00009AE0                 mov     eax, [ebp-18h]
.text$x:00009AE3                 push    eax             ; void *
.text$x:00009AE4                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00009AE9                 pop     ecx
.text$x:00009AEA                 retn
.text$x:00009AEA __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 endp
.text$x:00009AEA
.text$x:00009AEB
.text$x:00009AEB ; =============== S U B R O U T I N E =======================================
.text$x:00009AEB
.text$x:00009AEB
.text$x:00009AEB __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text$x:00009AEB                                         ; DATA XREF: CObjectVector<UString>::Add(UString const &)+5o
.text$x:00009AEB
.text$x:00009AEB arg_4           = dword ptr  8
.text$x:00009AEB
.text$x:00009AEB                 mov     edx, [esp+arg_4]
.text$x:00009AEF                 lea     eax, [edx+0Ch]
.text$x:00009AF2                 mov     ecx, [edx-14h]
.text$x:00009AF5                 xor     ecx, eax
.text$x:00009AF7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009AFC                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text$x:00009B01                 jmp     ___CxxFrameHandler3
.text$x:00009B01 __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text$x:00009B01
.text$x:00009B01 ; ---------------------------------------------------------------------------
.text$x:00009B06                 align 4
.text$x:00009B06 _text$x         ends
.text$x:00009B06
.xdata$x:00009B08 ; ===========================================================================
.xdata$x:00009B08
.xdata$x:00009B08 ; Segment type: Pure data
.xdata$x:00009B08 ; Segment permissions: Read
.xdata$x:00009B08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B08                 assume cs:_xdata$x
.xdata$x:00009B08                 ;org 9B08h
.xdata$x:00009B08 ; COMDAT (pick associative to section at 9A40)
.xdata$x:00009B08 __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db 0FFh
.xdata$x:00009B08                                         ; DATA XREF: .xdata$x:00009B18o
.xdata$x:00009B09                 db 0FFh
.xdata$x:00009B0A                 db 0FFh
.xdata$x:00009B0B                 db 0FFh
.xdata$x:00009B0C                 dd offset __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0
.xdata$x:00009B10 __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db  22h ; "
.xdata$x:00009B10                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z+11o
.xdata$x:00009B11                 db    5
.xdata$x:00009B12                 db  93h ; ô
.xdata$x:00009B13                 db  19h
.xdata$x:00009B14                 db    1
.xdata$x:00009B15                 db    0
.xdata$x:00009B16                 db    0
.xdata$x:00009B17                 db    0
.xdata$x:00009B18                 dd offset __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.xdata$x:00009B1C                 db    0
.xdata$x:00009B1D                 db    0
.xdata$x:00009B1E                 db    0
.xdata$x:00009B1F                 db    0
.xdata$x:00009B20                 db    0
.xdata$x:00009B21                 db    0
.xdata$x:00009B22                 db    0
.xdata$x:00009B23                 db    0
.xdata$x:00009B24                 db    0
.xdata$x:00009B25                 db    0
.xdata$x:00009B26                 db    0
.xdata$x:00009B27                 db    0
.xdata$x:00009B28                 db    0
.xdata$x:00009B29                 db    0
.xdata$x:00009B2A                 db    0
.xdata$x:00009B2B                 db    0
.xdata$x:00009B2C                 db    0
.xdata$x:00009B2D                 db    0
.xdata$x:00009B2E                 db    0
.xdata$x:00009B2F                 db    0
.xdata$x:00009B30                 db    1
.xdata$x:00009B31                 db    0
.xdata$x:00009B32                 db    0
.xdata$x:00009B33                 db    0
.xdata$x:00009B33 _xdata$x        ends
.xdata$x:00009B33
.text:00009B34 ; ===========================================================================
.text:00009B34
.text:00009B34 ; Segment type: Pure code
.text:00009B34 ; Segment permissions: Read/Execute
.text:00009B34 _text           segment para public 'CODE' use32
.text:00009B34                 assume cs:_text
.text:00009B34                 ;org 9B34h
.text:00009B34 ; COMDAT (pick any)
.text:00009B34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009B34
.text:00009B34 ; =============== S U B R O U T I N E =======================================
.text:00009B34
.text:00009B34 ; Attributes: bp-based frame
.text:00009B34
.text:00009B34 ; public: class UString & __thiscall CObjectVector<class UString>::AddNew(void)
.text:00009B34                 public ?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ
.text:00009B34 ?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ proc near
.text:00009B34                                         ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+C4p
.text:00009B34                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+13DFp ...
.text:00009B34
.text:00009B34 var_20          = dword ptr -20h
.text:00009B34 var_1C          = dword ptr -1Ch
.text:00009B34 var_18          = dword ptr -18h
.text:00009B34 var_14          = dword ptr -14h
.text:00009B34 var_10          = dword ptr -10h
.text:00009B34 var_C           = dword ptr -0Ch
.text:00009B34 var_4           = dword ptr -4
.text:00009B34
.text:00009B34                 push    ebp
.text:00009B35                 mov     ebp, esp
.text:00009B37                 push    0FFFFFFFFh
.text:00009B39                 push    offset __ehhandler$?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ
.text:00009B3E                 mov     eax, large fs:0
.text:00009B44                 push    eax
.text:00009B45                 sub     esp, 14h
.text:00009B48                 mov     eax, 0CCCCCCCCh
.text:00009B4D                 mov     [ebp+var_20], eax
.text:00009B50                 mov     [ebp+var_1C], eax
.text:00009B53                 mov     [ebp+var_18], eax
.text:00009B56                 mov     [ebp+var_14], eax
.text:00009B59                 mov     [ebp+var_10], eax
.text:00009B5C                 mov     eax, dword ptr ds:___security_cookie
.text:00009B61                 xor     eax, ebp
.text:00009B63                 push    eax
.text:00009B64                 lea     eax, [ebp+var_C]
.text:00009B67                 mov     large fs:0, eax
.text:00009B6D                 mov     [ebp+var_10], ecx
.text:00009B70                 push    0Ch             ; unsigned int
.text:00009B72                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00009B77                 add     esp, 4
.text:00009B7A                 mov     [ebp+var_1C], eax
.text:00009B7D                 mov     [ebp+var_4], 0
.text:00009B84                 cmp     [ebp+var_1C], 0
.text:00009B88                 jz      short loc_9B97
.text:00009B8A                 mov     ecx, [ebp+var_1C]
.text:00009B8D                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00009B92                 mov     [ebp+var_20], eax
.text:00009B95                 jmp     short loc_9B9E
.text:00009B97 ; ---------------------------------------------------------------------------
.text:00009B97
.text:00009B97 loc_9B97:                               ; CODE XREF: CObjectVector<UString>::AddNew(void)+54j
.text:00009B97                 mov     [ebp+var_20], 0
.text:00009B9E
.text:00009B9E loc_9B9E:                               ; CODE XREF: CObjectVector<UString>::AddNew(void)+61j
.text:00009B9E                 mov     eax, [ebp+var_20]
.text:00009BA1                 mov     [ebp+var_18], eax
.text:00009BA4                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009BAB                 mov     ecx, [ebp+var_18]
.text:00009BAE                 mov     [ebp+var_14], ecx
.text:00009BB1                 mov     edx, [ebp+var_14]
.text:00009BB4                 push    edx
.text:00009BB5                 mov     ecx, [ebp+var_10]
.text:00009BB8                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00009BBD                 mov     eax, [ebp+var_14]
.text:00009BC0                 mov     ecx, [ebp+var_C]
.text:00009BC3                 mov     large fs:0, ecx
.text:00009BCA                 pop     ecx
.text:00009BCB                 add     esp, 20h
.text:00009BCE                 cmp     ebp, esp
.text:00009BD0                 call    __RTC_CheckEsp
.text:00009BD5                 mov     esp, ebp
.text:00009BD7                 pop     ebp
.text:00009BD8                 retn
.text:00009BD8 ?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ endp
.text:00009BD8
.text:00009BD8 ; ---------------------------------------------------------------------------
.text:00009BD9                 align 4
.text:00009BD9 _text           ends
.text:00009BD9
.text$x:00009BDC ; ===========================================================================
.text$x:00009BDC
.text$x:00009BDC ; Segment type: Pure code
.text$x:00009BDC ; Segment permissions: Read/Execute
.text$x:00009BDC _text$x         segment para public 'CODE' use32
.text$x:00009BDC                 assume cs:_text$x
.text$x:00009BDC                 ;org 9BDCh
.text$x:00009BDC ; COMDAT (pick associative to section at 9B34)
.text$x:00009BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009BDC
.text$x:00009BDC ; =============== S U B R O U T I N E =======================================
.text$x:00009BDC
.text$x:00009BDC
.text$x:00009BDC __unwindfunclet$?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ$0 proc near
.text$x:00009BDC                                         ; DATA XREF: .xdata$x:00009C08o
.text$x:00009BDC                 mov     eax, [ebp-1Ch]
.text$x:00009BDF                 push    eax             ; void *
.text$x:00009BE0                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00009BE5                 pop     ecx
.text$x:00009BE6                 retn
.text$x:00009BE6 __unwindfunclet$?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ$0 endp
.text$x:00009BE6
.text$x:00009BE7
.text$x:00009BE7 ; =============== S U B R O U T I N E =======================================
.text$x:00009BE7
.text$x:00009BE7
.text$x:00009BE7 __ehhandler$?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ proc near
.text$x:00009BE7                                         ; DATA XREF: CObjectVector<UString>::AddNew(void)+5o
.text$x:00009BE7
.text$x:00009BE7 arg_4           = dword ptr  8
.text$x:00009BE7
.text$x:00009BE7                 mov     edx, [esp+arg_4]
.text$x:00009BEB                 lea     eax, [edx+0Ch]
.text$x:00009BEE                 mov     ecx, [edx-18h]
.text$x:00009BF1                 xor     ecx, eax
.text$x:00009BF3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009BF8                 mov     eax, offset __ehfuncinfo$?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ
.text$x:00009BFD                 jmp     ___CxxFrameHandler3
.text$x:00009BFD __ehhandler$?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ endp
.text$x:00009BFD
.text$x:00009BFD ; ---------------------------------------------------------------------------
.text$x:00009C02                 align 4
.text$x:00009C02 _text$x         ends
.text$x:00009C02
.xdata$x:00009C04 ; ===========================================================================
.xdata$x:00009C04
.xdata$x:00009C04 ; Segment type: Pure data
.xdata$x:00009C04 ; Segment permissions: Read
.xdata$x:00009C04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009C04                 assume cs:_xdata$x
.xdata$x:00009C04                 ;org 9C04h
.xdata$x:00009C04 ; COMDAT (pick associative to section at 9B34)
.xdata$x:00009C04 __unwindtable$?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ db 0FFh
.xdata$x:00009C04                                         ; DATA XREF: .xdata$x:00009C14o
.xdata$x:00009C05                 db 0FFh
.xdata$x:00009C06                 db 0FFh
.xdata$x:00009C07                 db 0FFh
.xdata$x:00009C08                 dd offset __unwindfunclet$?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ$0
.xdata$x:00009C0C __ehfuncinfo$?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ db  22h ; "
.xdata$x:00009C0C                                         ; DATA XREF: __ehhandler$?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ+11o
.xdata$x:00009C0D                 db    5
.xdata$x:00009C0E                 db  93h ; ô
.xdata$x:00009C0F                 db  19h
.xdata$x:00009C10                 db    1
.xdata$x:00009C11                 db    0
.xdata$x:00009C12                 db    0
.xdata$x:00009C13                 db    0
.xdata$x:00009C14                 dd offset __unwindtable$?AddNew@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ
.xdata$x:00009C18                 db    0
.xdata$x:00009C19                 db    0
.xdata$x:00009C1A                 db    0
.xdata$x:00009C1B                 db    0
.xdata$x:00009C1C                 db    0
.xdata$x:00009C1D                 db    0
.xdata$x:00009C1E                 db    0
.xdata$x:00009C1F                 db    0
.xdata$x:00009C20                 db    0
.xdata$x:00009C21                 db    0
.xdata$x:00009C22                 db    0
.xdata$x:00009C23                 db    0
.xdata$x:00009C24                 db    0
.xdata$x:00009C25                 db    0
.xdata$x:00009C26                 db    0
.xdata$x:00009C27                 db    0
.xdata$x:00009C28                 db    0
.xdata$x:00009C29                 db    0
.xdata$x:00009C2A                 db    0
.xdata$x:00009C2B                 db    0
.xdata$x:00009C2C                 db    1
.xdata$x:00009C2D                 db    0
.xdata$x:00009C2E                 db    0
.xdata$x:00009C2F                 db    0
.xdata$x:00009C2F _xdata$x        ends
.xdata$x:00009C2F
.text:00009C30 ; ===========================================================================
.text:00009C30
.text:00009C30 ; Segment type: Pure code
.text:00009C30 ; Segment permissions: Read/Execute
.text:00009C30 _text           segment para public 'CODE' use32
.text:00009C30                 assume cs:_text
.text:00009C30                 ;org 9C30h
.text:00009C30 ; COMDAT (pick any)
.text:00009C30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009C30
.text:00009C30 ; =============== S U B R O U T I N E =======================================
.text:00009C30
.text:00009C30 ; Attributes: bp-based frame
.text:00009C30
.text:00009C30 ; public: __thiscall CObjectVector<class UString>::~CObjectVector<class UString>(void)
.text:00009C30                 public ??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00009C30 ??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00009C30                                         ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+11Cp
.text:00009C30                                         ; CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+136p ...
.text:00009C30
.text:00009C30 var_20          = dword ptr -20h
.text:00009C30 var_1C          = dword ptr -1Ch
.text:00009C30 var_18          = dword ptr -18h
.text:00009C30 var_14          = dword ptr -14h
.text:00009C30 var_10          = dword ptr -10h
.text:00009C30 var_C           = dword ptr -0Ch
.text:00009C30 var_4           = dword ptr -4
.text:00009C30
.text:00009C30                 push    ebp
.text:00009C31                 mov     ebp, esp
.text:00009C33                 push    0FFFFFFFFh
.text:00009C35                 push    offset __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00009C3A                 mov     eax, large fs:0
.text:00009C40                 push    eax
.text:00009C41                 sub     esp, 14h
.text:00009C44                 mov     eax, 0CCCCCCCCh
.text:00009C49                 mov     [ebp+var_20], eax
.text:00009C4C                 mov     [ebp+var_1C], eax
.text:00009C4F                 mov     [ebp+var_18], eax
.text:00009C52                 mov     [ebp+var_14], eax
.text:00009C55                 mov     [ebp+var_10], eax
.text:00009C58                 mov     eax, dword ptr ds:___security_cookie
.text:00009C5D                 xor     eax, ebp
.text:00009C5F                 push    eax
.text:00009C60                 lea     eax, [ebp+var_C]
.text:00009C63                 mov     large fs:0, eax
.text:00009C69                 mov     [ebp+var_10], ecx
.text:00009C6C                 mov     [ebp+var_4], 0
.text:00009C73                 mov     ecx, [ebp+var_10]
.text:00009C76                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00009C7B                 mov     [ebp+var_14], eax
.text:00009C7E
.text:00009C7E loc_9C7E:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void):loc_9CC0j
.text:00009C7E                 cmp     [ebp+var_14], 0
.text:00009C82                 jz      short loc_9CC2
.text:00009C84                 mov     eax, [ebp+var_14]
.text:00009C87                 sub     eax, 1
.text:00009C8A                 mov     [ebp+var_14], eax
.text:00009C8D                 mov     ecx, [ebp+var_14]
.text:00009C90                 push    ecx
.text:00009C91                 mov     ecx, [ebp+var_10]
.text:00009C94                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00009C99                 mov     edx, [eax]
.text:00009C9B                 mov     [ebp+var_1C], edx
.text:00009C9E                 mov     eax, [ebp+var_1C]
.text:00009CA1                 mov     [ebp+var_18], eax
.text:00009CA4                 cmp     [ebp+var_18], 0
.text:00009CA8                 jz      short loc_9CB9
.text:00009CAA                 push    1
.text:00009CAC                 mov     ecx, [ebp+var_18]
.text:00009CAF                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00009CB4                 mov     [ebp+var_20], eax
.text:00009CB7                 jmp     short loc_9CC0
.text:00009CB9 ; ---------------------------------------------------------------------------
.text:00009CB9
.text:00009CB9 loc_9CB9:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+78j
.text:00009CB9                 mov     [ebp+var_20], 0
.text:00009CC0
.text:00009CC0 loc_9CC0:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+87j
.text:00009CC0                 jmp     short loc_9C7E
.text:00009CC2 ; ---------------------------------------------------------------------------
.text:00009CC2
.text:00009CC2 loc_9CC2:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+52j
.text:00009CC2                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009CC9                 mov     ecx, [ebp+var_10]
.text:00009CCC                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00009CD1                 mov     ecx, [ebp+var_C]
.text:00009CD4                 mov     large fs:0, ecx
.text:00009CDB                 pop     ecx
.text:00009CDC                 add     esp, 20h
.text:00009CDF                 cmp     ebp, esp
.text:00009CE1                 call    __RTC_CheckEsp
.text:00009CE6                 mov     esp, ebp
.text:00009CE8                 pop     ebp
.text:00009CE9                 retn
.text:00009CE9 ??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text:00009CE9
.text:00009CE9 ; ---------------------------------------------------------------------------
.text:00009CEA                 align 4
.text:00009CEA _text           ends
.text:00009CEA
.text$x:00009CEC ; ===========================================================================
.text$x:00009CEC
.text$x:00009CEC ; Segment type: Pure code
.text$x:00009CEC ; Segment permissions: Read/Execute
.text$x:00009CEC _text$x         segment para public 'CODE' use32
.text$x:00009CEC                 assume cs:_text$x
.text$x:00009CEC                 ;org 9CECh
.text$x:00009CEC ; COMDAT (pick associative to section at 9C30)
.text$x:00009CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009CEC
.text$x:00009CEC ; =============== S U B R O U T I N E =======================================
.text$x:00009CEC
.text$x:00009CEC
.text$x:00009CEC __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 proc near
.text$x:00009CEC                                         ; DATA XREF: .xdata$x:00009D14o
.text$x:00009CEC                 mov     ecx, [ebp-10h]
.text$x:00009CEF                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00009CEF __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 endp
.text$x:00009CEF
.text$x:00009CF4
.text$x:00009CF4 ; =============== S U B R O U T I N E =======================================
.text$x:00009CF4
.text$x:00009CF4
.text$x:00009CF4 __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text$x:00009CF4                                         ; DATA XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+5o
.text$x:00009CF4
.text$x:00009CF4 arg_4           = dword ptr  8
.text$x:00009CF4
.text$x:00009CF4                 mov     edx, [esp+arg_4]
.text$x:00009CF8                 lea     eax, [edx+0Ch]
.text$x:00009CFB                 mov     ecx, [edx-18h]
.text$x:00009CFE                 xor     ecx, eax
.text$x:00009D00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009D05                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ
.text$x:00009D0A                 jmp     ___CxxFrameHandler3
.text$x:00009D0A __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text$x:00009D0A
.text$x:00009D0A ; ---------------------------------------------------------------------------
.text$x:00009D0F                 align 10h
.text$x:00009D0F _text$x         ends
.text$x:00009D0F
.xdata$x:00009D10 ; ===========================================================================
.xdata$x:00009D10
.xdata$x:00009D10 ; Segment type: Pure data
.xdata$x:00009D10 ; Segment permissions: Read
.xdata$x:00009D10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009D10                 assume cs:_xdata$x
.xdata$x:00009D10                 ;org 9D10h
.xdata$x:00009D10 ; COMDAT (pick associative to section at 9C30)
.xdata$x:00009D10 __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ db 0FFh
.xdata$x:00009D10                                         ; DATA XREF: .xdata$x:00009D20o
.xdata$x:00009D11                 db 0FFh
.xdata$x:00009D12                 db 0FFh
.xdata$x:00009D13                 db 0FFh
.xdata$x:00009D14                 dd offset __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0
.xdata$x:00009D18 __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ db  22h ; "
.xdata$x:00009D18                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ+11o
.xdata$x:00009D19                 db    5
.xdata$x:00009D1A                 db  93h ; ô
.xdata$x:00009D1B                 db  19h
.xdata$x:00009D1C                 db    1
.xdata$x:00009D1D                 db    0
.xdata$x:00009D1E                 db    0
.xdata$x:00009D1F                 db    0
.xdata$x:00009D20                 dd offset __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ
.xdata$x:00009D24                 db    0
.xdata$x:00009D25                 db    0
.xdata$x:00009D26                 db    0
.xdata$x:00009D27                 db    0
.xdata$x:00009D28                 db    0
.xdata$x:00009D29                 db    0
.xdata$x:00009D2A                 db    0
.xdata$x:00009D2B                 db    0
.xdata$x:00009D2C                 db    0
.xdata$x:00009D2D                 db    0
.xdata$x:00009D2E                 db    0
.xdata$x:00009D2F                 db    0
.xdata$x:00009D30                 db    0
.xdata$x:00009D31                 db    0
.xdata$x:00009D32                 db    0
.xdata$x:00009D33                 db    0
.xdata$x:00009D34                 db    0
.xdata$x:00009D35                 db    0
.xdata$x:00009D36                 db    0
.xdata$x:00009D37                 db    0
.xdata$x:00009D38                 db    1
.xdata$x:00009D39                 db    0
.xdata$x:00009D3A                 db    0
.xdata$x:00009D3B                 db    0
.xdata$x:00009D3B _xdata$x        ends
.xdata$x:00009D3B
.text:00009D3C ; ===========================================================================
.text:00009D3C
.text:00009D3C ; Segment type: Pure code
.text:00009D3C ; Segment permissions: Read/Execute
.text:00009D3C _text           segment para public 'CODE' use32
.text:00009D3C                 assume cs:_text
.text:00009D3C                 ;org 9D3Ch
.text:00009D3C ; COMDAT (pick any)
.text:00009D3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009D3C
.text:00009D3C ; =============== S U B R O U T I N E =======================================
.text:00009D3C
.text:00009D3C ; Attributes: bp-based frame
.text:00009D3C
.text:00009D3C ; public: void __thiscall CObjectVector<class UString>::Clear(void)
.text:00009D3C                 public ?Clear@?$CObjectVector@VUString@@@@QAEXXZ
.text:00009D3C ?Clear@?$CObjectVector@VUString@@@@QAEXXZ proc near
.text:00009D3C                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+27p
.text:00009D3C                                         ; CHardLinks::Clear(void)+1Cp ...
.text:00009D3C
.text:00009D3C var_14          = dword ptr -14h
.text:00009D3C var_10          = dword ptr -10h
.text:00009D3C var_C           = dword ptr -0Ch
.text:00009D3C var_8           = dword ptr -8
.text:00009D3C var_4           = dword ptr -4
.text:00009D3C
.text:00009D3C                 push    ebp
.text:00009D3D                 mov     ebp, esp
.text:00009D3F                 sub     esp, 14h
.text:00009D42                 mov     eax, 0CCCCCCCCh
.text:00009D47                 mov     [ebp+var_14], eax
.text:00009D4A                 mov     [ebp+var_10], eax
.text:00009D4D                 mov     [ebp+var_C], eax
.text:00009D50                 mov     [ebp+var_8], eax
.text:00009D53                 mov     [ebp+var_4], eax
.text:00009D56                 mov     [ebp+var_4], ecx
.text:00009D59                 mov     ecx, [ebp+var_4]
.text:00009D5C                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00009D61                 mov     [ebp+var_8], eax
.text:00009D64
.text:00009D64 loc_9D64:                               ; CODE XREF: CObjectVector<UString>::Clear(void):loc_9DA6j
.text:00009D64                 cmp     [ebp+var_8], 0
.text:00009D68                 jz      short loc_9DA8
.text:00009D6A                 mov     eax, [ebp+var_8]
.text:00009D6D                 sub     eax, 1
.text:00009D70                 mov     [ebp+var_8], eax
.text:00009D73                 mov     ecx, [ebp+var_8]
.text:00009D76                 push    ecx
.text:00009D77                 mov     ecx, [ebp+var_4]
.text:00009D7A                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00009D7F                 mov     edx, [eax]
.text:00009D81                 mov     [ebp+var_10], edx
.text:00009D84                 mov     eax, [ebp+var_10]
.text:00009D87                 mov     [ebp+var_C], eax
.text:00009D8A                 cmp     [ebp+var_C], 0
.text:00009D8E                 jz      short loc_9D9F
.text:00009D90                 push    1
.text:00009D92                 mov     ecx, [ebp+var_C]
.text:00009D95                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00009D9A                 mov     [ebp+var_14], eax
.text:00009D9D                 jmp     short loc_9DA6
.text:00009D9F ; ---------------------------------------------------------------------------
.text:00009D9F
.text:00009D9F loc_9D9F:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+52j
.text:00009D9F                 mov     [ebp+var_14], 0
.text:00009DA6
.text:00009DA6 loc_9DA6:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+61j
.text:00009DA6                 jmp     short loc_9D64
.text:00009DA8 ; ---------------------------------------------------------------------------
.text:00009DA8
.text:00009DA8 loc_9DA8:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+2Cj
.text:00009DA8                 mov     ecx, [ebp+var_4]
.text:00009DAB                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00009DB0                 add     esp, 14h
.text:00009DB3                 cmp     ebp, esp
.text:00009DB5                 call    __RTC_CheckEsp
.text:00009DBA                 mov     esp, ebp
.text:00009DBC                 pop     ebp
.text:00009DBD                 retn
.text:00009DBD ?Clear@?$CObjectVector@VUString@@@@QAEXXZ endp
.text:00009DBD
.text:00009DBD ; ---------------------------------------------------------------------------
.text:00009DBE                 align 10h
.text:00009DBE _text           ends
.text:00009DBE
.text:00009DC0 ; ===========================================================================
.text:00009DC0
.text:00009DC0 ; Segment type: Pure code
.text:00009DC0 ; Segment permissions: Read/Execute
.text:00009DC0 _text           segment para public 'CODE' use32
.text:00009DC0                 assume cs:_text
.text:00009DC0                 ;org 9DC0h
.text:00009DC0 ; COMDAT (pick any)
.text:00009DC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009DC0
.text:00009DC0 ; =============== S U B R O U T I N E =======================================
.text:00009DC0
.text:00009DC0 ; Attributes: bp-based frame
.text:00009DC0
.text:00009DC0 ; public: void __thiscall CObjectVector<class UString>::DeleteFrontal(unsigned int)
.text:00009DC0                 public ?DeleteFrontal@?$CObjectVector@VUString@@@@QAEXI@Z
.text:00009DC0 ?DeleteFrontal@?$CObjectVector@VUString@@@@QAEXI@Z proc near
.text:00009DC0                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+7D7p
.text:00009DC0                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+A08p ...
.text:00009DC0
.text:00009DC0 var_14          = dword ptr -14h
.text:00009DC0 var_10          = dword ptr -10h
.text:00009DC0 var_C           = dword ptr -0Ch
.text:00009DC0 var_8           = dword ptr -8
.text:00009DC0 var_4           = dword ptr -4
.text:00009DC0 arg_0           = dword ptr  8
.text:00009DC0
.text:00009DC0                 push    ebp
.text:00009DC1                 mov     ebp, esp
.text:00009DC3                 sub     esp, 14h
.text:00009DC6                 mov     eax, 0CCCCCCCCh
.text:00009DCB                 mov     [ebp+var_14], eax
.text:00009DCE                 mov     [ebp+var_10], eax
.text:00009DD1                 mov     [ebp+var_C], eax
.text:00009DD4                 mov     [ebp+var_8], eax
.text:00009DD7                 mov     [ebp+var_4], eax
.text:00009DDA                 mov     [ebp+var_4], ecx
.text:00009DDD                 mov     [ebp+var_8], 0
.text:00009DE4                 jmp     short loc_9DEF
.text:00009DE6 ; ---------------------------------------------------------------------------
.text:00009DE6
.text:00009DE6 loc_9DE6:                               ; CODE XREF: CObjectVector<UString>::DeleteFrontal(uint):loc_9E2Aj
.text:00009DE6                 mov     eax, [ebp+var_8]
.text:00009DE9                 add     eax, 1
.text:00009DEC                 mov     [ebp+var_8], eax
.text:00009DEF
.text:00009DEF loc_9DEF:                               ; CODE XREF: CObjectVector<UString>::DeleteFrontal(uint)+24j
.text:00009DEF                 mov     ecx, [ebp+var_8]
.text:00009DF2                 cmp     ecx, [ebp+arg_0]
.text:00009DF5                 jnb     short loc_9E2C
.text:00009DF7                 mov     edx, [ebp+var_8]
.text:00009DFA                 push    edx
.text:00009DFB                 mov     ecx, [ebp+var_4]
.text:00009DFE                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00009E03                 mov     eax, [eax]
.text:00009E05                 mov     [ebp+var_10], eax
.text:00009E08                 mov     ecx, [ebp+var_10]
.text:00009E0B                 mov     [ebp+var_C], ecx
.text:00009E0E                 cmp     [ebp+var_C], 0
.text:00009E12                 jz      short loc_9E23
.text:00009E14                 push    1
.text:00009E16                 mov     ecx, [ebp+var_C]
.text:00009E19                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00009E1E                 mov     [ebp+var_14], eax
.text:00009E21                 jmp     short loc_9E2A
.text:00009E23 ; ---------------------------------------------------------------------------
.text:00009E23
.text:00009E23 loc_9E23:                               ; CODE XREF: CObjectVector<UString>::DeleteFrontal(uint)+52j
.text:00009E23                 mov     [ebp+var_14], 0
.text:00009E2A
.text:00009E2A loc_9E2A:                               ; CODE XREF: CObjectVector<UString>::DeleteFrontal(uint)+61j
.text:00009E2A                 jmp     short loc_9DE6
.text:00009E2C ; ---------------------------------------------------------------------------
.text:00009E2C
.text:00009E2C loc_9E2C:                               ; CODE XREF: CObjectVector<UString>::DeleteFrontal(uint)+35j
.text:00009E2C                 mov     edx, [ebp+arg_0]
.text:00009E2F                 push    edx
.text:00009E30                 mov     ecx, [ebp+var_4]
.text:00009E33                 call    ?DeleteFrontal@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::DeleteFrontal(uint)
.text:00009E38                 add     esp, 14h
.text:00009E3B                 cmp     ebp, esp
.text:00009E3D                 call    __RTC_CheckEsp
.text:00009E42                 mov     esp, ebp
.text:00009E44                 pop     ebp
.text:00009E45                 retn    4
.text:00009E45 ?DeleteFrontal@?$CObjectVector@VUString@@@@QAEXI@Z endp
.text:00009E45
.text:00009E45 _text           ends
.text:00009E45
.text:00009E48 ; ===========================================================================
.text:00009E48
.text:00009E48 ; Segment type: Pure code
.text:00009E48 ; Segment permissions: Read/Execute
.text:00009E48 _text           segment para public 'CODE' use32
.text:00009E48                 assume cs:_text
.text:00009E48                 ;org 9E48h
.text:00009E48 ; COMDAT (pick any)
.text:00009E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009E48
.text:00009E48 ; =============== S U B R O U T I N E =======================================
.text:00009E48
.text:00009E48 ; Attributes: bp-based frame
.text:00009E48
.text:00009E48 ; public: void __thiscall CObjectVector<class UString>::DeleteBack(void)
.text:00009E48                 public ?DeleteBack@?$CObjectVector@VUString@@@@QAEXXZ
.text:00009E48 ?DeleteBack@?$CObjectVector@VUString@@@@QAEXXZ proc near
.text:00009E48                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+14EBp
.text:00009E48
.text:00009E48 var_10          = dword ptr -10h
.text:00009E48 var_C           = dword ptr -0Ch
.text:00009E48 var_8           = dword ptr -8
.text:00009E48 var_4           = dword ptr -4
.text:00009E48
.text:00009E48                 push    ebp
.text:00009E49                 mov     ebp, esp
.text:00009E4B                 sub     esp, 10h
.text:00009E4E                 mov     eax, 0CCCCCCCCh
.text:00009E53                 mov     [ebp+var_10], eax
.text:00009E56                 mov     [ebp+var_C], eax
.text:00009E59                 mov     [ebp+var_8], eax
.text:00009E5C                 mov     [ebp+var_4], eax
.text:00009E5F                 mov     [ebp+var_4], ecx
.text:00009E62                 mov     ecx, [ebp+var_4]
.text:00009E65                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00009E6A                 sub     eax, 1
.text:00009E6D                 push    eax
.text:00009E6E                 mov     ecx, [ebp+var_4]
.text:00009E71                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00009E76                 mov     eax, [eax]
.text:00009E78                 mov     [ebp+var_C], eax
.text:00009E7B                 mov     ecx, [ebp+var_C]
.text:00009E7E                 mov     [ebp+var_8], ecx
.text:00009E81                 cmp     [ebp+var_8], 0
.text:00009E85                 jz      short loc_9E96
.text:00009E87                 push    1
.text:00009E89                 mov     ecx, [ebp+var_8]
.text:00009E8C                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00009E91                 mov     [ebp+var_10], eax
.text:00009E94                 jmp     short loc_9E9D
.text:00009E96 ; ---------------------------------------------------------------------------
.text:00009E96
.text:00009E96 loc_9E96:                               ; CODE XREF: CObjectVector<UString>::DeleteBack(void)+3Dj
.text:00009E96                 mov     [ebp+var_10], 0
.text:00009E9D
.text:00009E9D loc_9E9D:                               ; CODE XREF: CObjectVector<UString>::DeleteBack(void)+4Cj
.text:00009E9D                 mov     ecx, [ebp+var_4]
.text:00009EA0                 call    ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::DeleteBack(void)
.text:00009EA5                 add     esp, 10h
.text:00009EA8                 cmp     ebp, esp
.text:00009EAA                 call    __RTC_CheckEsp
.text:00009EAF                 mov     esp, ebp
.text:00009EB1                 pop     ebp
.text:00009EB2                 retn
.text:00009EB2 ?DeleteBack@?$CObjectVector@VUString@@@@QAEXXZ endp
.text:00009EB2
.text:00009EB2 ; ---------------------------------------------------------------------------
.text:00009EB3                 align 4
.text:00009EB3 _text           ends
.text:00009EB3
.text:00009EB4 ; ===========================================================================
.text:00009EB4
.text:00009EB4 ; Segment type: Pure code
.text:00009EB4 ; Segment permissions: Read/Execute
.text:00009EB4 _text           segment para public 'CODE' use32
.text:00009EB4                 assume cs:_text
.text:00009EB4                 ;org 9EB4h
.text:00009EB4 ; COMDAT (pick any)
.text:00009EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009EB4
.text:00009EB4 ; =============== S U B R O U T I N E =======================================
.text:00009EB4
.text:00009EB4 ; Attributes: bp-based frame
.text:00009EB4
.text:00009EB4 ; public: __thiscall CMyComPtr<struct ICompressProgressInfo>::CMyComPtr<struct ICompressProgressInfo>(void)
.text:00009EB4                 public ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ
.text:00009EB4 ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ proc near
.text:00009EB4                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+B7p
.text:00009EB4                                         ; CArchiveExtractCallback::CArchiveExtractCallback(void)+1B1p
.text:00009EB4
.text:00009EB4 var_4           = dword ptr -4
.text:00009EB4
.text:00009EB4                 push    ebp
.text:00009EB5                 mov     ebp, esp
.text:00009EB7                 push    ecx
.text:00009EB8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009EBF                 mov     [ebp+var_4], ecx
.text:00009EC2                 mov     eax, [ebp+var_4]
.text:00009EC5                 mov     dword ptr [eax], 0
.text:00009ECB                 mov     eax, [ebp+var_4]
.text:00009ECE                 mov     esp, ebp
.text:00009ED0                 pop     ebp
.text:00009ED1                 retn
.text:00009ED1 ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ endp
.text:00009ED1
.text:00009ED1 ; ---------------------------------------------------------------------------
.text:00009ED2                 align 4
.text:00009ED2 _text           ends
.text:00009ED2
.text:00009ED4 ; ===========================================================================
.text:00009ED4
.text:00009ED4 ; Segment type: Pure code
.text:00009ED4 ; Segment permissions: Read/Execute
.text:00009ED4 _text           segment para public 'CODE' use32
.text:00009ED4                 assume cs:_text
.text:00009ED4                 ;org 9ED4h
.text:00009ED4 ; COMDAT (pick any)
.text:00009ED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009ED4
.text:00009ED4 ; =============== S U B R O U T I N E =======================================
.text:00009ED4
.text:00009ED4 ; Attributes: bp-based frame
.text:00009ED4
.text:00009ED4 ; public: __thiscall CMyComPtr<struct ICompressProgressInfo>::~CMyComPtr<struct ICompressProgressInfo>(void)
.text:00009ED4                 public ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ
.text:00009ED4 ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ proc near
.text:00009ED4                                         ; CODE XREF: __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$1+6j
.text:00009ED4                                         ; __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$14+9j ...
.text:00009ED4
.text:00009ED4 var_4           = dword ptr -4
.text:00009ED4
.text:00009ED4                 push    ebp
.text:00009ED5                 mov     ebp, esp
.text:00009ED7                 push    ecx
.text:00009ED8                 push    esi
.text:00009ED9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009EE0                 mov     [ebp+var_4], ecx
.text:00009EE3                 mov     eax, [ebp+var_4]
.text:00009EE6                 cmp     dword ptr [eax], 0
.text:00009EE9                 jz      short loc_9F06
.text:00009EEB                 mov     ecx, [ebp+var_4]
.text:00009EEE                 mov     edx, [ecx]
.text:00009EF0                 mov     eax, [ebp+var_4]
.text:00009EF3                 mov     ecx, [eax]
.text:00009EF5                 mov     edx, [edx]
.text:00009EF7                 mov     esi, esp
.text:00009EF9                 push    ecx
.text:00009EFA                 mov     eax, [edx+8]
.text:00009EFD                 call    eax
.text:00009EFF                 cmp     esi, esp
.text:00009F01                 call    __RTC_CheckEsp
.text:00009F06
.text:00009F06 loc_9F06:                               ; CODE XREF: CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)+15j
.text:00009F06                 pop     esi
.text:00009F07                 add     esp, 4
.text:00009F0A                 cmp     ebp, esp
.text:00009F0C                 call    __RTC_CheckEsp
.text:00009F11                 mov     esp, ebp
.text:00009F13                 pop     ebp
.text:00009F14                 retn
.text:00009F14 ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ endp
.text:00009F14
.text:00009F14 ; ---------------------------------------------------------------------------
.text:00009F15                 align 4
.text:00009F15 _text           ends
.text:00009F15
.text:00009F18 ; ===========================================================================
.text:00009F18
.text:00009F18 ; Segment type: Pure code
.text:00009F18 ; Segment permissions: Read/Execute
.text:00009F18 _text           segment para public 'CODE' use32
.text:00009F18                 assume cs:_text
.text:00009F18                 ;org 9F18h
.text:00009F18 ; COMDAT (pick any)
.text:00009F18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009F18
.text:00009F18 ; =============== S U B R O U T I N E =======================================
.text:00009F18
.text:00009F18 ; Attributes: bp-based frame
.text:00009F18
.text:00009F18 ; public: void __thiscall CMyComPtr<struct ICompressProgressInfo>::Release(void)
.text:00009F18                 public ?Release@?$CMyComPtr@UICompressProgressInfo@@@@QAEXXZ
.text:00009F18 ?Release@?$CMyComPtr@UICompressProgressInfo@@@@QAEXXZ proc near
.text:00009F18                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+E4p
.text:00009F18
.text:00009F18 var_4           = dword ptr -4
.text:00009F18
.text:00009F18                 push    ebp
.text:00009F19                 mov     ebp, esp
.text:00009F1B                 push    ecx
.text:00009F1C                 push    esi
.text:00009F1D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009F24                 mov     [ebp+var_4], ecx
.text:00009F27                 mov     eax, [ebp+var_4]
.text:00009F2A                 cmp     dword ptr [eax], 0
.text:00009F2D                 jz      short loc_9F53
.text:00009F2F                 mov     ecx, [ebp+var_4]
.text:00009F32                 mov     edx, [ecx]
.text:00009F34                 mov     eax, [ebp+var_4]
.text:00009F37                 mov     ecx, [eax]
.text:00009F39                 mov     edx, [edx]
.text:00009F3B                 mov     esi, esp
.text:00009F3D                 push    ecx
.text:00009F3E                 mov     eax, [edx+8]
.text:00009F41                 call    eax
.text:00009F43                 cmp     esi, esp
.text:00009F45                 call    __RTC_CheckEsp
.text:00009F4A                 mov     ecx, [ebp+var_4]
.text:00009F4D                 mov     dword ptr [ecx], 0
.text:00009F53
.text:00009F53 loc_9F53:                               ; CODE XREF: CMyComPtr<ICompressProgressInfo>::Release(void)+15j
.text:00009F53                 pop     esi
.text:00009F54                 add     esp, 4
.text:00009F57                 cmp     ebp, esp
.text:00009F59                 call    __RTC_CheckEsp
.text:00009F5E                 mov     esp, ebp
.text:00009F60                 pop     ebp
.text:00009F61                 retn
.text:00009F61 ?Release@?$CMyComPtr@UICompressProgressInfo@@@@QAEXXZ endp
.text:00009F61
.text:00009F61 ; ---------------------------------------------------------------------------
.text:00009F62                 align 4
.text:00009F62 _text           ends
.text:00009F62
.text:00009F64 ; ===========================================================================
.text:00009F64
.text:00009F64 ; Segment type: Pure code
.text:00009F64 ; Segment permissions: Read/Execute
.text:00009F64 _text           segment para public 'CODE' use32
.text:00009F64                 assume cs:_text
.text:00009F64                 ;org 9F64h
.text:00009F64 ; COMDAT (pick any)
.text:00009F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009F64
.text:00009F64 ; =============== S U B R O U T I N E =======================================
.text:00009F64
.text:00009F64 ; Attributes: bp-based frame
.text:00009F64
.text:00009F64 ; public: struct ICompressProgressInfo * * __thiscall CMyComPtr<struct ICompressProgressInfo>::operator&(void)
.text:00009F64                 public ??I?$CMyComPtr@UICompressProgressInfo@@@@QAEPAPAUICompressProgressInfo@@XZ
.text:00009F64 ??I?$CMyComPtr@UICompressProgressInfo@@@@QAEPAPAUICompressProgressInfo@@XZ proc near
.text:00009F64                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+EFp
.text:00009F64
.text:00009F64 var_4           = dword ptr -4
.text:00009F64
.text:00009F64                 push    ebp
.text:00009F65                 mov     ebp, esp
.text:00009F67                 push    ecx
.text:00009F68                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009F6F                 mov     [ebp+var_4], ecx
.text:00009F72                 mov     eax, [ebp+var_4]
.text:00009F75                 mov     esp, ebp
.text:00009F77                 pop     ebp
.text:00009F78                 retn
.text:00009F78 ??I?$CMyComPtr@UICompressProgressInfo@@@@QAEPAPAUICompressProgressInfo@@XZ endp
.text:00009F78
.text:00009F78 ; ---------------------------------------------------------------------------
.text:00009F79                 align 4
.text:00009F79 _text           ends
.text:00009F79
.text:00009F7C ; ===========================================================================
.text:00009F7C
.text:00009F7C ; Segment type: Pure code
.text:00009F7C ; Segment permissions: Read/Execute
.text:00009F7C _text           segment para public 'CODE' use32
.text:00009F7C                 assume cs:_text
.text:00009F7C                 ;org 9F7Ch
.text:00009F7C ; COMDAT (pick any)
.text:00009F7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009F7C
.text:00009F7C ; =============== S U B R O U T I N E =======================================
.text:00009F7C
.text:00009F7C ; Attributes: bp-based frame
.text:00009F7C
.text:00009F7C ; public: struct ICompressProgressInfo * __thiscall CMyComPtr<struct ICompressProgressInfo>::operator->(void)const
.text:00009F7C                 public ??C?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ
.text:00009F7C ??C?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ proc near
.text:00009F7C                                         ; CODE XREF: CArchiveExtractCallback::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+4Dp
.text:00009F7C
.text:00009F7C var_4           = dword ptr -4
.text:00009F7C
.text:00009F7C                 push    ebp
.text:00009F7D                 mov     ebp, esp
.text:00009F7F                 push    ecx
.text:00009F80                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009F87                 mov     [ebp+var_4], ecx
.text:00009F8A                 mov     eax, [ebp+var_4]
.text:00009F8D                 mov     eax, [eax]
.text:00009F8F                 mov     esp, ebp
.text:00009F91                 pop     ebp
.text:00009F92                 retn
.text:00009F92 ??C?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ endp
.text:00009F92
.text:00009F92 ; ---------------------------------------------------------------------------
.text:00009F93                 align 4
.text:00009F93 _text           ends
.text:00009F93
.text:00009F94 ; ===========================================================================
.text:00009F94
.text:00009F94 ; Segment type: Pure code
.text:00009F94 ; Segment permissions: Read/Execute
.text:00009F94 _text           segment para public 'CODE' use32
.text:00009F94                 assume cs:_text
.text:00009F94                 ;org 9F94h
.text:00009F94 ; COMDAT (pick any)
.text:00009F94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009F94
.text:00009F94 ; =============== S U B R O U T I N E =======================================
.text:00009F94
.text:00009F94 ; Attributes: bp-based frame
.text:00009F94
.text:00009F94 ; public: struct ICompressProgressInfo * __thiscall CMyComPtr<struct ICompressProgressInfo>::operator=(struct ICompressProgressInfo *)
.text:00009F94                 public ??4?$CMyComPtr@UICompressProgressInfo@@@@QAEPAUICompressProgressInfo@@PAU1@@Z
.text:00009F94 ??4?$CMyComPtr@UICompressProgressInfo@@@@QAEPAUICompressProgressInfo@@PAU1@@Z proc near
.text:00009F94                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+256p
.text:00009F94
.text:00009F94 var_4           = dword ptr -4
.text:00009F94 arg_0           = dword ptr  8
.text:00009F94
.text:00009F94                 push    ebp
.text:00009F95                 mov     ebp, esp
.text:00009F97                 push    ecx
.text:00009F98                 push    esi
.text:00009F99                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009FA0                 mov     [ebp+var_4], ecx
.text:00009FA3                 cmp     [ebp+arg_0], 0
.text:00009FA7                 jz      short loc_9FC0
.text:00009FA9                 mov     eax, [ebp+arg_0]
.text:00009FAC                 mov     ecx, [eax]
.text:00009FAE                 mov     esi, esp
.text:00009FB0                 mov     edx, [ebp+arg_0]
.text:00009FB3                 push    edx
.text:00009FB4                 mov     eax, [ecx+4]
.text:00009FB7                 call    eax
.text:00009FB9                 cmp     esi, esp
.text:00009FBB                 call    __RTC_CheckEsp
.text:00009FC0
.text:00009FC0 loc_9FC0:                               ; CODE XREF: CMyComPtr<ICompressProgressInfo>::operator=(ICompressProgressInfo *)+13j
.text:00009FC0                 mov     ecx, [ebp+var_4]
.text:00009FC3                 cmp     dword ptr [ecx], 0
.text:00009FC6                 jz      short loc_9FE3
.text:00009FC8                 mov     edx, [ebp+var_4]
.text:00009FCB                 mov     eax, [edx]
.text:00009FCD                 mov     ecx, [ebp+var_4]
.text:00009FD0                 mov     edx, [ecx]
.text:00009FD2                 mov     eax, [eax]
.text:00009FD4                 mov     esi, esp
.text:00009FD6                 push    edx
.text:00009FD7                 mov     ecx, [eax+8]
.text:00009FDA                 call    ecx
.text:00009FDC                 cmp     esi, esp
.text:00009FDE                 call    __RTC_CheckEsp
.text:00009FE3
.text:00009FE3 loc_9FE3:                               ; CODE XREF: CMyComPtr<ICompressProgressInfo>::operator=(ICompressProgressInfo *)+32j
.text:00009FE3                 mov     edx, [ebp+var_4]
.text:00009FE6                 mov     eax, [ebp+arg_0]
.text:00009FE9                 mov     [edx], eax
.text:00009FEB                 mov     eax, [ebp+arg_0]
.text:00009FEE                 pop     esi
.text:00009FEF                 add     esp, 4
.text:00009FF2                 cmp     ebp, esp
.text:00009FF4                 call    __RTC_CheckEsp
.text:00009FF9                 mov     esp, ebp
.text:00009FFB                 pop     ebp
.text:00009FFC                 retn    4
.text:00009FFC ??4?$CMyComPtr@UICompressProgressInfo@@@@QAEPAUICompressProgressInfo@@PAU1@@Z endp
.text:00009FFC
.text:00009FFC ; ---------------------------------------------------------------------------
.text:00009FFF                 align 10h
.text:00009FFF _text           ends
.text:00009FFF
.text:0000A000 ; ===========================================================================
.text:0000A000
.text:0000A000 ; Segment type: Pure code
.text:0000A000 ; Segment permissions: Read/Execute
.text:0000A000 _text           segment para public 'CODE' use32
.text:0000A000                 assume cs:_text
.text:0000A000                 ;org 0A000h
.text:0000A000 ; COMDAT (pick any)
.text:0000A000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A000
.text:0000A000 ; =============== S U B R O U T I N E =======================================
.text:0000A000
.text:0000A000 ; Attributes: bp-based frame
.text:0000A000
.text:0000A000 ; public: __thiscall CMyComPtr<struct IInArchive>::operator struct IInArchive *(void)const
.text:0000A000                 public ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ
.text:0000A000 ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ proc near
.text:0000A000                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+52p
.text:0000A000                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+F5p ...
.text:0000A000
.text:0000A000 var_4           = dword ptr -4
.text:0000A000
.text:0000A000                 push    ebp
.text:0000A001                 mov     ebp, esp
.text:0000A003                 push    ecx
.text:0000A004                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A00B                 mov     [ebp+var_4], ecx
.text:0000A00E                 mov     eax, [ebp+var_4]
.text:0000A011                 mov     eax, [eax]
.text:0000A013                 mov     esp, ebp
.text:0000A015                 pop     ebp
.text:0000A016                 retn
.text:0000A016 ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ endp
.text:0000A016
.text:0000A016 ; ---------------------------------------------------------------------------
.text:0000A017                 align 4
.text:0000A017 _text           ends
.text:0000A017
.text:0000A018 ; ===========================================================================
.text:0000A018
.text:0000A018 ; Segment type: Pure code
.text:0000A018 ; Segment permissions: Read/Execute
.text:0000A018 _text           segment para public 'CODE' use32
.text:0000A018                 assume cs:_text
.text:0000A018                 ;org 0A018h
.text:0000A018 ; COMDAT (pick any)
.text:0000A018                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A018
.text:0000A018 ; =============== S U B R O U T I N E =======================================
.text:0000A018
.text:0000A018 ; Attributes: bp-based frame
.text:0000A018
.text:0000A018 ; public: struct IInArchive * __thiscall CMyComPtr<struct IInArchive>::operator->(void)const
.text:0000A018                 public ??C?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ
.text:0000A018 ??C?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ proc near
.text:0000A018                                         ; CODE XREF: CArchiveExtractCallback::GetTime(int,ulong,_FILETIME &,bool &)+56p
.text:0000A018                                         ; CGetProp::GetPropA(ulong,tagPROPVARIANT *)+12p
.text:0000A018
.text:0000A018 var_4           = dword ptr -4
.text:0000A018
.text:0000A018                 push    ebp
.text:0000A019                 mov     ebp, esp
.text:0000A01B                 push    ecx
.text:0000A01C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A023                 mov     [ebp+var_4], ecx
.text:0000A026                 mov     eax, [ebp+var_4]
.text:0000A029                 mov     eax, [eax]
.text:0000A02B                 mov     esp, ebp
.text:0000A02D                 pop     ebp
.text:0000A02E                 retn
.text:0000A02E ??C?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ endp
.text:0000A02E
.text:0000A02E ; ---------------------------------------------------------------------------
.text:0000A02F                 align 10h
.text:0000A02F _text           ends
.text:0000A02F
.text:0000A030 ; ===========================================================================
.text:0000A030
.text:0000A030 ; Segment type: Pure code
.text:0000A030 ; Segment permissions: Read/Execute
.text:0000A030 _text           segment para public 'CODE' use32
.text:0000A030                 assume cs:_text
.text:0000A030                 ;org 0A030h
.text:0000A030 ; COMDAT (pick any)
.text:0000A030                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A030
.text:0000A030 ; =============== S U B R O U T I N E =======================================
.text:0000A030
.text:0000A030 ; Attributes: bp-based frame
.text:0000A030
.text:0000A030 ; public: __thiscall CMyComPtr<struct IArchiveGetRawProps>::operator struct IArchiveGetRawProps *(void)const
.text:0000A030                 public ??B?$CMyComPtr@UIArchiveGetRawProps@@@@QBEPAUIArchiveGetRawProps@@XZ
.text:0000A030 ??B?$CMyComPtr@UIArchiveGetRawProps@@@@QBEPAUIArchiveGetRawProps@@XZ proc near
.text:0000A030                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+461p
.text:0000A030                                         ; CArchiveExtractCallback::SetOperationResult(int)+2B1p
.text:0000A030
.text:0000A030 var_4           = dword ptr -4
.text:0000A030
.text:0000A030                 push    ebp
.text:0000A031                 mov     ebp, esp
.text:0000A033                 push    ecx
.text:0000A034                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A03B                 mov     [ebp+var_4], ecx
.text:0000A03E                 mov     eax, [ebp+var_4]
.text:0000A041                 mov     eax, [eax]
.text:0000A043                 mov     esp, ebp
.text:0000A045                 pop     ebp
.text:0000A046                 retn
.text:0000A046 ??B?$CMyComPtr@UIArchiveGetRawProps@@@@QBEPAUIArchiveGetRawProps@@XZ endp
.text:0000A046
.text:0000A046 ; ---------------------------------------------------------------------------
.text:0000A047                 align 4
.text:0000A047 _text           ends
.text:0000A047
.text:0000A048 ; ===========================================================================
.text:0000A048
.text:0000A048 ; Segment type: Pure code
.text:0000A048 ; Segment permissions: Read/Execute
.text:0000A048 _text           segment para public 'CODE' use32
.text:0000A048                 assume cs:_text
.text:0000A048                 ;org 0A048h
.text:0000A048 ; COMDAT (pick any)
.text:0000A048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A048
.text:0000A048 ; =============== S U B R O U T I N E =======================================
.text:0000A048
.text:0000A048 ; Attributes: bp-based frame
.text:0000A048
.text:0000A048 ; public: struct IArchiveGetRawProps * __thiscall CMyComPtr<struct IArchiveGetRawProps>::operator->(void)const
.text:0000A048                 public ??C?$CMyComPtr@UIArchiveGetRawProps@@@@QBEPAUIArchiveGetRawProps@@XZ
.text:0000A048 ??C?$CMyComPtr@UIArchiveGetRawProps@@@@QBEPAUIArchiveGetRawProps@@XZ proc near
.text:0000A048                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+482p
.text:0000A048                                         ; CArchiveExtractCallback::SetOperationResult(int)+2CCp
.text:0000A048
.text:0000A048 var_4           = dword ptr -4
.text:0000A048
.text:0000A048                 push    ebp
.text:0000A049                 mov     ebp, esp
.text:0000A04B                 push    ecx
.text:0000A04C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A053                 mov     [ebp+var_4], ecx
.text:0000A056                 mov     eax, [ebp+var_4]
.text:0000A059                 mov     eax, [eax]
.text:0000A05B                 mov     esp, ebp
.text:0000A05D                 pop     ebp
.text:0000A05E                 retn
.text:0000A05E ??C?$CMyComPtr@UIArchiveGetRawProps@@@@QBEPAUIArchiveGetRawProps@@XZ endp
.text:0000A05E
.text:0000A05E ; ---------------------------------------------------------------------------
.text:0000A05F                 align 10h
.text:0000A05F _text           ends
.text:0000A05F
.text:0000A060 ; ===========================================================================
.text:0000A060
.text:0000A060 ; Segment type: Pure code
.text:0000A060 ; Segment permissions: Read/Execute
.text:0000A060 _text           segment para public 'CODE' use32
.text:0000A060                 assume cs:_text
.text:0000A060                 ;org 0A060h
.text:0000A060 ; COMDAT (pick any)
.text:0000A060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A060
.text:0000A060 ; =============== S U B R O U T I N E =======================================
.text:0000A060
.text:0000A060 ; Attributes: bp-based frame
.text:0000A060
.text:0000A060 ; public: __thiscall CRecordVector<unsigned int>::CRecordVector<unsigned int>(void)
.text:0000A060                 public ??0?$CRecordVector@I@@QAE@XZ
.text:0000A060 ??0?$CRecordVector@I@@QAE@XZ proc near  ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+1D5p
.text:0000A060
.text:0000A060 var_4           = dword ptr -4
.text:0000A060
.text:0000A060                 push    ebp
.text:0000A061                 mov     ebp, esp
.text:0000A063                 push    ecx
.text:0000A064                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A06B                 mov     [ebp+var_4], ecx
.text:0000A06E                 mov     eax, [ebp+var_4]
.text:0000A071                 mov     dword ptr [eax], 0
.text:0000A077                 mov     ecx, [ebp+var_4]
.text:0000A07A                 mov     dword ptr [ecx+4], 0
.text:0000A081                 mov     edx, [ebp+var_4]
.text:0000A084                 mov     dword ptr [edx+8], 0
.text:0000A08B                 mov     eax, [ebp+var_4]
.text:0000A08E                 mov     esp, ebp
.text:0000A090                 pop     ebp
.text:0000A091                 retn
.text:0000A091 ??0?$CRecordVector@I@@QAE@XZ endp
.text:0000A091
.text:0000A091 ; ---------------------------------------------------------------------------
.text:0000A092                 align 4
.text:0000A092 _text           ends
.text:0000A092
.text:0000A094 ; ===========================================================================
.text:0000A094
.text:0000A094 ; Segment type: Pure code
.text:0000A094 ; Segment permissions: Read/Execute
.text:0000A094 _text           segment para public 'CODE' use32
.text:0000A094                 assume cs:_text
.text:0000A094                 ;org 0A094h
.text:0000A094 ; COMDAT (pick any)
.text:0000A094                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A094
.text:0000A094 ; =============== S U B R O U T I N E =======================================
.text:0000A094
.text:0000A094 ; Attributes: bp-based frame
.text:0000A094
.text:0000A094 ; public: unsigned int __thiscall CRecordVector<unsigned int>::Size(void)const
.text:0000A094                 public ?Size@?$CRecordVector@I@@QBEIXZ
.text:0000A094 ?Size@?$CRecordVector@I@@QBEIXZ proc near
.text:0000A094                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+6Fp
.text:0000A094
.text:0000A094 var_4           = dword ptr -4
.text:0000A094
.text:0000A094                 push    ebp
.text:0000A095                 mov     ebp, esp
.text:0000A097                 push    ecx
.text:0000A098                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A09F                 mov     [ebp+var_4], ecx
.text:0000A0A2                 mov     eax, [ebp+var_4]
.text:0000A0A5                 mov     eax, [eax+4]
.text:0000A0A8                 mov     esp, ebp
.text:0000A0AA                 pop     ebp
.text:0000A0AB                 retn
.text:0000A0AB ?Size@?$CRecordVector@I@@QBEIXZ endp
.text:0000A0AB
.text:0000A0AB _text           ends
.text:0000A0AB
.text:0000A0AC ; ===========================================================================
.text:0000A0AC
.text:0000A0AC ; Segment type: Pure code
.text:0000A0AC ; Segment permissions: Read/Execute
.text:0000A0AC _text           segment para public 'CODE' use32
.text:0000A0AC                 assume cs:_text
.text:0000A0AC                 ;org 0A0ACh
.text:0000A0AC ; COMDAT (pick any)
.text:0000A0AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A0AC
.text:0000A0AC ; =============== S U B R O U T I N E =======================================
.text:0000A0AC
.text:0000A0AC ; Attributes: bp-based frame
.text:0000A0AC
.text:0000A0AC ; public: __thiscall CRecordVector<unsigned int>::~CRecordVector<unsigned int>(void)
.text:0000A0AC                 public ??1?$CRecordVector@I@@QAE@XZ
.text:0000A0AC ??1?$CRecordVector@I@@QAE@XZ proc near  ; CODE XREF: __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$16+9j
.text:0000A0AC                                         ; CArchiveExtractCallback::~CArchiveExtractCallback(void)+61p ...
.text:0000A0AC
.text:0000A0AC var_8           = dword ptr -8
.text:0000A0AC var_4           = dword ptr -4
.text:0000A0AC
.text:0000A0AC                 push    ebp
.text:0000A0AD                 mov     ebp, esp
.text:0000A0AF                 sub     esp, 8
.text:0000A0B2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000A0B9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A0C0                 mov     [ebp+var_4], ecx
.text:0000A0C3                 mov     eax, [ebp+var_4]
.text:0000A0C6                 mov     ecx, [eax]
.text:0000A0C8                 mov     [ebp+var_8], ecx
.text:0000A0CB                 mov     edx, [ebp+var_8]
.text:0000A0CE                 push    edx             ; void *
.text:0000A0CF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000A0D4                 add     esp, 4
.text:0000A0D7                 add     esp, 8
.text:0000A0DA                 cmp     ebp, esp
.text:0000A0DC                 call    __RTC_CheckEsp
.text:0000A0E1                 mov     esp, ebp
.text:0000A0E3                 pop     ebp
.text:0000A0E4                 retn
.text:0000A0E4 ??1?$CRecordVector@I@@QAE@XZ endp
.text:0000A0E4
.text:0000A0E4 ; ---------------------------------------------------------------------------
.text:0000A0E5                 align 4
.text:0000A0E5 _text           ends
.text:0000A0E5
.text:0000A0E8 ; ===========================================================================
.text:0000A0E8
.text:0000A0E8 ; Segment type: Pure code
.text:0000A0E8 ; Segment permissions: Read/Execute
.text:0000A0E8 _text           segment para public 'CODE' use32
.text:0000A0E8                 assume cs:_text
.text:0000A0E8                 ;org 0A0E8h
.text:0000A0E8 ; COMDAT (pick any)
.text:0000A0E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A0E8
.text:0000A0E8 ; =============== S U B R O U T I N E =======================================
.text:0000A0E8
.text:0000A0E8 ; Attributes: bp-based frame
.text:0000A0E8
.text:0000A0E8 ; public: void __thiscall CRecordVector<unsigned int>::Clear(void)
.text:0000A0E8                 public ?Clear@?$CRecordVector@I@@QAEXXZ
.text:0000A0E8 ?Clear@?$CRecordVector@I@@QAEXXZ proc near
.text:0000A0E8                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+35p
.text:0000A0E8
.text:0000A0E8 var_4           = dword ptr -4
.text:0000A0E8
.text:0000A0E8                 push    ebp
.text:0000A0E9                 mov     ebp, esp
.text:0000A0EB                 push    ecx
.text:0000A0EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A0F3                 mov     [ebp+var_4], ecx
.text:0000A0F6                 mov     eax, [ebp+var_4]
.text:0000A0F9                 mov     dword ptr [eax+4], 0
.text:0000A100                 mov     esp, ebp
.text:0000A102                 pop     ebp
.text:0000A103                 retn
.text:0000A103 ?Clear@?$CRecordVector@I@@QAEXXZ endp
.text:0000A103
.text:0000A103 _text           ends
.text:0000A103
.text:0000A104 ; ===========================================================================
.text:0000A104
.text:0000A104 ; Segment type: Pure code
.text:0000A104 ; Segment permissions: Read/Execute
.text:0000A104 _text           segment para public 'CODE' use32
.text:0000A104                 assume cs:_text
.text:0000A104                 ;org 0A104h
.text:0000A104 ; COMDAT (pick any)
.text:0000A104                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A104
.text:0000A104 ; =============== S U B R O U T I N E =======================================
.text:0000A104
.text:0000A104 ; Attributes: bp-based frame
.text:0000A104
.text:0000A104 ; public: unsigned int __thiscall CRecordVector<unsigned int>::Add(unsigned int)
.text:0000A104                 public ?Add@?$CRecordVector@I@@QAEII@Z
.text:0000A104 ?Add@?$CRecordVector@I@@QAEII@Z proc near
.text:0000A104                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+156Fp
.text:0000A104
.text:0000A104 var_8           = dword ptr -8
.text:0000A104 var_4           = dword ptr -4
.text:0000A104 arg_0           = dword ptr  8
.text:0000A104
.text:0000A104                 push    ebp
.text:0000A105                 mov     ebp, esp
.text:0000A107                 sub     esp, 8
.text:0000A10A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000A111                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A118                 mov     [ebp+var_4], ecx
.text:0000A11B                 mov     ecx, [ebp+var_4]
.text:0000A11E                 call    ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ ; CRecordVector<uint>::ReserveOnePosition(void)
.text:0000A123                 mov     eax, [ebp+var_4]
.text:0000A126                 mov     ecx, [eax+4]
.text:0000A129                 mov     edx, [ebp+var_4]
.text:0000A12C                 mov     eax, [edx]
.text:0000A12E                 mov     edx, [ebp+arg_0]
.text:0000A131                 mov     [eax+ecx*4], edx
.text:0000A134                 mov     eax, [ebp+var_4]
.text:0000A137                 mov     ecx, [eax+4]
.text:0000A13A                 mov     [ebp+var_8], ecx
.text:0000A13D                 mov     edx, [ebp+var_4]
.text:0000A140                 mov     eax, [edx+4]
.text:0000A143                 add     eax, 1
.text:0000A146                 mov     ecx, [ebp+var_4]
.text:0000A149                 mov     [ecx+4], eax
.text:0000A14C                 mov     eax, [ebp+var_8]
.text:0000A14F                 add     esp, 8
.text:0000A152                 cmp     ebp, esp
.text:0000A154                 call    __RTC_CheckEsp
.text:0000A159                 mov     esp, ebp
.text:0000A15B                 pop     ebp
.text:0000A15C                 retn    4
.text:0000A15C ?Add@?$CRecordVector@I@@QAEII@Z endp
.text:0000A15C
.text:0000A15C ; ---------------------------------------------------------------------------
.text:0000A15F                 align 10h
.text:0000A15F _text           ends
.text:0000A15F
.text:0000A160 ; ===========================================================================
.text:0000A160
.text:0000A160 ; Segment type: Pure code
.text:0000A160 ; Segment permissions: Read/Execute
.text:0000A160 _text           segment para public 'CODE' use32
.text:0000A160                 assume cs:_text
.text:0000A160                 ;org 0A160h
.text:0000A160 ; COMDAT (pick any)
.text:0000A160                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A160
.text:0000A160 ; =============== S U B R O U T I N E =======================================
.text:0000A160
.text:0000A160 ; Attributes: bp-based frame
.text:0000A160
.text:0000A160 ; public: unsigned int const & __thiscall CRecordVector<unsigned int>::operator[](unsigned int)const
.text:0000A160                 public ??A?$CRecordVector@I@@QBEABII@Z
.text:0000A160 ??A?$CRecordVector@I@@QBEABII@Z proc near
.text:0000A160                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+D0p
.text:0000A160
.text:0000A160 var_4           = dword ptr -4
.text:0000A160 arg_0           = dword ptr  8
.text:0000A160
.text:0000A160                 push    ebp
.text:0000A161                 mov     ebp, esp
.text:0000A163                 push    ecx
.text:0000A164                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A16B                 mov     [ebp+var_4], ecx
.text:0000A16E                 mov     eax, [ebp+var_4]
.text:0000A171                 mov     ecx, [eax]
.text:0000A173                 mov     edx, [ebp+arg_0]
.text:0000A176                 lea     eax, [ecx+edx*4]
.text:0000A179                 mov     esp, ebp
.text:0000A17B                 pop     ebp
.text:0000A17C                 retn    4
.text:0000A17C ??A?$CRecordVector@I@@QBEABII@Z endp
.text:0000A17C
.text:0000A17C ; ---------------------------------------------------------------------------
.text:0000A17F                 align 10h
.text:0000A17F _text           ends
.text:0000A17F
.text:0000A180 ; ===========================================================================
.text:0000A180
.text:0000A180 ; Segment type: Pure code
.text:0000A180 ; Segment permissions: Read/Execute
.text:0000A180 _text           segment para public 'CODE' use32
.text:0000A180                 assume cs:_text
.text:0000A180                 ;org 0A180h
.text:0000A180 ; COMDAT (pick any)
.text:0000A180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A180
.text:0000A180 ; =============== S U B R O U T I N E =======================================
.text:0000A180
.text:0000A180 ; Attributes: bp-based frame
.text:0000A180
.text:0000A180 ; public: unsigned int & __thiscall CRecordVector<unsigned int>::operator[](unsigned int)
.text:0000A180                 public ??A?$CRecordVector@I@@QAEAAII@Z
.text:0000A180 ??A?$CRecordVector@I@@QAEAAII@Z proc near
.text:0000A180                                         ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+113p
.text:0000A180
.text:0000A180 var_4           = dword ptr -4
.text:0000A180 arg_0           = dword ptr  8
.text:0000A180
.text:0000A180                 push    ebp
.text:0000A181                 mov     ebp, esp
.text:0000A183                 push    ecx
.text:0000A184                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A18B                 mov     [ebp+var_4], ecx
.text:0000A18E                 mov     eax, [ebp+var_4]
.text:0000A191                 mov     ecx, [eax]
.text:0000A193                 mov     edx, [ebp+arg_0]
.text:0000A196                 lea     eax, [ecx+edx*4]
.text:0000A199                 mov     esp, ebp
.text:0000A19B                 pop     ebp
.text:0000A19C                 retn    4
.text:0000A19C ??A?$CRecordVector@I@@QAEAAII@Z endp
.text:0000A19C
.text:0000A19C ; ---------------------------------------------------------------------------
.text:0000A19F                 align 10h
.text:0000A19F _text           ends
.text:0000A19F
.text:0000A1A0 ; ===========================================================================
.text:0000A1A0
.text:0000A1A0 ; Segment type: Pure code
.text:0000A1A0 ; Segment permissions: Read/Execute
.text:0000A1A0 _text           segment para public 'CODE' use32
.text:0000A1A0                 assume cs:_text
.text:0000A1A0                 ;org 0A1A0h
.text:0000A1A0 ; COMDAT (pick any)
.text:0000A1A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A1A0
.text:0000A1A0 ; =============== S U B R O U T I N E =======================================
.text:0000A1A0
.text:0000A1A0 ; Attributes: bp-based frame
.text:0000A1A0
.text:0000A1A0 ; public: __thiscall CBuffer<unsigned char>::CBuffer<unsigned char>(void)
.text:0000A1A0                 public ??0?$CBuffer@E@@QAE@XZ
.text:0000A1A0 ??0?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2941p
.text:0000A1A0
.text:0000A1A0 var_4           = dword ptr -4
.text:0000A1A0
.text:0000A1A0                 push    ebp
.text:0000A1A1                 mov     ebp, esp
.text:0000A1A3                 push    ecx
.text:0000A1A4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A1AB                 mov     [ebp+var_4], ecx
.text:0000A1AE                 mov     eax, [ebp+var_4]
.text:0000A1B1                 mov     dword ptr [eax], 0
.text:0000A1B7                 mov     ecx, [ebp+var_4]
.text:0000A1BA                 mov     dword ptr [ecx+4], 0
.text:0000A1C1                 mov     eax, [ebp+var_4]
.text:0000A1C4                 mov     esp, ebp
.text:0000A1C6                 pop     ebp
.text:0000A1C7                 retn
.text:0000A1C7 ??0?$CBuffer@E@@QAE@XZ endp
.text:0000A1C7
.text:0000A1C7 _text           ends
.text:0000A1C7
.text:0000A1C8 ; ===========================================================================
.text:0000A1C8
.text:0000A1C8 ; Segment type: Pure code
.text:0000A1C8 ; Segment permissions: Read/Execute
.text:0000A1C8 _text           segment para public 'CODE' use32
.text:0000A1C8                 assume cs:_text
.text:0000A1C8                 ;org 0A1C8h
.text:0000A1C8 ; COMDAT (pick any)
.text:0000A1C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A1C8
.text:0000A1C8 ; =============== S U B R O U T I N E =======================================
.text:0000A1C8
.text:0000A1C8 ; Attributes: bp-based frame
.text:0000A1C8
.text:0000A1C8 ; public: __thiscall CBuffer<unsigned char>::~CBuffer<unsigned char>(void)
.text:0000A1C8                 public ??1?$CBuffer@E@@QAE@XZ
.text:0000A1C8 ??1?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2A53p
.text:0000A1C8                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2B84p ...
.text:0000A1C8
.text:0000A1C8 var_8           = dword ptr -8
.text:0000A1C8 var_4           = dword ptr -4
.text:0000A1C8
.text:0000A1C8                 push    ebp
.text:0000A1C9                 mov     ebp, esp
.text:0000A1CB                 sub     esp, 8
.text:0000A1CE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000A1D5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A1DC                 mov     [ebp+var_4], ecx
.text:0000A1DF                 mov     eax, [ebp+var_4]
.text:0000A1E2                 mov     ecx, [eax]
.text:0000A1E4                 mov     [ebp+var_8], ecx
.text:0000A1E7                 mov     edx, [ebp+var_8]
.text:0000A1EA                 push    edx             ; void *
.text:0000A1EB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000A1F0                 add     esp, 4
.text:0000A1F3                 add     esp, 8
.text:0000A1F6                 cmp     ebp, esp
.text:0000A1F8                 call    __RTC_CheckEsp
.text:0000A1FD                 mov     esp, ebp
.text:0000A1FF                 pop     ebp
.text:0000A200                 retn
.text:0000A200 ??1?$CBuffer@E@@QAE@XZ endp
.text:0000A200
.text:0000A200 ; ---------------------------------------------------------------------------
.text:0000A201                 align 4
.text:0000A201 _text           ends
.text:0000A201
.text:0000A204 ; ===========================================================================
.text:0000A204
.text:0000A204 ; Segment type: Pure code
.text:0000A204 ; Segment permissions: Read/Execute
.text:0000A204 _text           segment para public 'CODE' use32
.text:0000A204                 assume cs:_text
.text:0000A204                 ;org 0A204h
.text:0000A204 ; COMDAT (pick any)
.text:0000A204                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A204
.text:0000A204 ; =============== S U B R O U T I N E =======================================
.text:0000A204
.text:0000A204 ; Attributes: bp-based frame
.text:0000A204
.text:0000A204 ; public: __thiscall CBuffer<unsigned char>::operator unsigned char *(void)
.text:0000A204                 public ??B?$CBuffer@E@@QAEPAEXZ
.text:0000A204 ??B?$CBuffer@E@@QAEPAEXZ proc near      ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+29C2p
.text:0000A204                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2AD6p
.text:0000A204
.text:0000A204 var_4           = dword ptr -4
.text:0000A204
.text:0000A204                 push    ebp
.text:0000A205                 mov     ebp, esp
.text:0000A207                 push    ecx
.text:0000A208                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A20F                 mov     [ebp+var_4], ecx
.text:0000A212                 mov     eax, [ebp+var_4]
.text:0000A215                 mov     eax, [eax]
.text:0000A217                 mov     esp, ebp
.text:0000A219                 pop     ebp
.text:0000A21A                 retn
.text:0000A21A ??B?$CBuffer@E@@QAEPAEXZ endp
.text:0000A21A
.text:0000A21A ; ---------------------------------------------------------------------------
.text:0000A21B                 align 4
.text:0000A21B _text           ends
.text:0000A21B
.text:0000A21C ; ===========================================================================
.text:0000A21C
.text:0000A21C ; Segment type: Pure code
.text:0000A21C ; Segment permissions: Read/Execute
.text:0000A21C _text           segment para public 'CODE' use32
.text:0000A21C                 assume cs:_text
.text:0000A21C                 ;org 0A21Ch
.text:0000A21C ; COMDAT (pick any)
.text:0000A21C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A21C
.text:0000A21C ; =============== S U B R O U T I N E =======================================
.text:0000A21C
.text:0000A21C ; Attributes: bp-based frame
.text:0000A21C
.text:0000A21C ; public: unsigned int __thiscall CBuffer<unsigned char>::Size(void)const
.text:0000A21C                 public ?Size@?$CBuffer@E@@QBEIXZ
.text:0000A21C ?Size@?$CBuffer@E@@QBEIXZ proc near     ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+29B1p
.text:0000A21C                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2AC5p
.text:0000A21C
.text:0000A21C var_4           = dword ptr -4
.text:0000A21C
.text:0000A21C                 push    ebp
.text:0000A21D                 mov     ebp, esp
.text:0000A21F                 push    ecx
.text:0000A220                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A227                 mov     [ebp+var_4], ecx
.text:0000A22A                 mov     eax, [ebp+var_4]
.text:0000A22D                 mov     eax, [eax+4]
.text:0000A230                 mov     esp, ebp
.text:0000A232                 pop     ebp
.text:0000A233                 retn
.text:0000A233 ?Size@?$CBuffer@E@@QBEIXZ endp
.text:0000A233
.text:0000A233 _text           ends
.text:0000A233
.text:0000A234 ; ===========================================================================
.text:0000A234
.text:0000A234 ; Segment type: Pure code
.text:0000A234 ; Segment permissions: Read/Execute
.text:0000A234 _text           segment para public 'CODE' use32
.text:0000A234                 assume cs:_text
.text:0000A234                 ;org 0A234h
.text:0000A234 ; COMDAT (pick any)
.text:0000A234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A234
.text:0000A234 ; =============== S U B R O U T I N E =======================================
.text:0000A234
.text:0000A234 ; Attributes: bp-based frame
.text:0000A234
.text:0000A234 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::CMyComPtr<struct ISequentialOutStream>(void)
.text:0000A234                 public ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:0000A234 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:0000A234                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+171p
.text:0000A234                                         ; CArchiveExtractCallback::CArchiveExtractCallback(void)+183p ...
.text:0000A234
.text:0000A234 var_4           = dword ptr -4
.text:0000A234
.text:0000A234                 push    ebp
.text:0000A235                 mov     ebp, esp
.text:0000A237                 push    ecx
.text:0000A238                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A23F                 mov     [ebp+var_4], ecx
.text:0000A242                 mov     eax, [ebp+var_4]
.text:0000A245                 mov     dword ptr [eax], 0
.text:0000A24B                 mov     eax, [ebp+var_4]
.text:0000A24E                 mov     esp, ebp
.text:0000A250                 pop     ebp
.text:0000A251                 retn
.text:0000A251 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:0000A251
.text:0000A251 ; ---------------------------------------------------------------------------
.text:0000A252                 align 4
.text:0000A252 _text           ends
.text:0000A252
.text:0000A254 ; ===========================================================================
.text:0000A254
.text:0000A254 ; Segment type: Pure code
.text:0000A254 ; Segment permissions: Read/Execute
.text:0000A254 _text           segment para public 'CODE' use32
.text:0000A254                 assume cs:_text
.text:0000A254                 ;org 0A254h
.text:0000A254 ; COMDAT (pick any)
.text:0000A254                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A254
.text:0000A254 ; =============== S U B R O U T I N E =======================================
.text:0000A254
.text:0000A254 ; Attributes: bp-based frame
.text:0000A254
.text:0000A254 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::CMyComPtr<struct ISequentialOutStream>(struct ISequentialOutStream *)
.text:0000A254                 public ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@PAUISequentialOutStream@@@Z
.text:0000A254 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@PAUISequentialOutStream@@@Z proc near
.text:0000A254                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2F40p
.text:0000A254
.text:0000A254 var_4           = dword ptr -4
.text:0000A254 arg_0           = dword ptr  8
.text:0000A254
.text:0000A254                 push    ebp
.text:0000A255                 mov     ebp, esp
.text:0000A257                 push    ecx
.text:0000A258                 push    esi
.text:0000A259                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A260                 mov     [ebp+var_4], ecx
.text:0000A263                 mov     eax, [ebp+var_4]
.text:0000A266                 mov     ecx, [ebp+arg_0]
.text:0000A269                 mov     [eax], ecx
.text:0000A26B                 cmp     [ebp+arg_0], 0
.text:0000A26F                 jz      short loc_A288
.text:0000A271                 mov     edx, [ebp+arg_0]
.text:0000A274                 mov     eax, [edx]
.text:0000A276                 mov     esi, esp
.text:0000A278                 mov     ecx, [ebp+arg_0]
.text:0000A27B                 push    ecx
.text:0000A27C                 mov     edx, [eax+4]
.text:0000A27F                 call    edx
.text:0000A281                 cmp     esi, esp
.text:0000A283                 call    __RTC_CheckEsp
.text:0000A288
.text:0000A288 loc_A288:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(ISequentialOutStream *)+1Bj
.text:0000A288                 mov     eax, [ebp+var_4]
.text:0000A28B                 pop     esi
.text:0000A28C                 add     esp, 4
.text:0000A28F                 cmp     ebp, esp
.text:0000A291                 call    __RTC_CheckEsp
.text:0000A296                 mov     esp, ebp
.text:0000A298                 pop     ebp
.text:0000A299                 retn    4
.text:0000A299 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@PAUISequentialOutStream@@@Z endp
.text:0000A299
.text:0000A299 _text           ends
.text:0000A299
.text:0000A29C ; ===========================================================================
.text:0000A29C
.text:0000A29C ; Segment type: Pure code
.text:0000A29C ; Segment permissions: Read/Execute
.text:0000A29C _text           segment para public 'CODE' use32
.text:0000A29C                 assume cs:_text
.text:0000A29C                 ;org 0A29Ch
.text:0000A29C ; COMDAT (pick any)
.text:0000A29C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A29C
.text:0000A29C ; =============== S U B R O U T I N E =======================================
.text:0000A29C
.text:0000A29C ; Attributes: bp-based frame
.text:0000A29C
.text:0000A29C ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::~CMyComPtr<struct ISequentialOutStream>(void)
.text:0000A29C                 public ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:0000A29C ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:0000A29C                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+10AAp
.text:0000A29C                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1127p ...
.text:0000A29C
.text:0000A29C var_4           = dword ptr -4
.text:0000A29C
.text:0000A29C                 push    ebp
.text:0000A29D                 mov     ebp, esp
.text:0000A29F                 push    ecx
.text:0000A2A0                 push    esi
.text:0000A2A1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A2A8                 mov     [ebp+var_4], ecx
.text:0000A2AB                 mov     eax, [ebp+var_4]
.text:0000A2AE                 cmp     dword ptr [eax], 0
.text:0000A2B1                 jz      short loc_A2CE
.text:0000A2B3                 mov     ecx, [ebp+var_4]
.text:0000A2B6                 mov     edx, [ecx]
.text:0000A2B8                 mov     eax, [ebp+var_4]
.text:0000A2BB                 mov     ecx, [eax]
.text:0000A2BD                 mov     edx, [edx]
.text:0000A2BF                 mov     esi, esp
.text:0000A2C1                 push    ecx
.text:0000A2C2                 mov     eax, [edx+8]
.text:0000A2C5                 call    eax
.text:0000A2C7                 cmp     esi, esp
.text:0000A2C9                 call    __RTC_CheckEsp
.text:0000A2CE
.text:0000A2CE loc_A2CE:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)+15j
.text:0000A2CE                 pop     esi
.text:0000A2CF                 add     esp, 4
.text:0000A2D2                 cmp     ebp, esp
.text:0000A2D4                 call    __RTC_CheckEsp
.text:0000A2D9                 mov     esp, ebp
.text:0000A2DB                 pop     ebp
.text:0000A2DC                 retn
.text:0000A2DC ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:0000A2DC
.text:0000A2DC ; ---------------------------------------------------------------------------
.text:0000A2DD                 align 10h
.text:0000A2DD _text           ends
.text:0000A2DD
.text:0000A2E0 ; ===========================================================================
.text:0000A2E0
.text:0000A2E0 ; Segment type: Pure code
.text:0000A2E0 ; Segment permissions: Read/Execute
.text:0000A2E0 _text           segment para public 'CODE' use32
.text:0000A2E0                 assume cs:_text
.text:0000A2E0                 ;org 0A2E0h
.text:0000A2E0 ; COMDAT (pick any)
.text:0000A2E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A2E0
.text:0000A2E0 ; =============== S U B R O U T I N E =======================================
.text:0000A2E0
.text:0000A2E0 ; Attributes: bp-based frame
.text:0000A2E0
.text:0000A2E0 ; public: void __thiscall CMyComPtr<struct ISequentialOutStream>::Release(void)
.text:0000A2E0                 public ?Release@?$CMyComPtr@UISequentialOutStream@@@@QAEXXZ
.text:0000A2E0 ?Release@?$CMyComPtr@UISequentialOutStream@@@@QAEXXZ proc near
.text:0000A2E0                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+92p
.text:0000A2E0                                         ; CArchiveExtractCallback::SetOperationResult(int)+294p ...
.text:0000A2E0
.text:0000A2E0 var_4           = dword ptr -4
.text:0000A2E0
.text:0000A2E0                 push    ebp
.text:0000A2E1                 mov     ebp, esp
.text:0000A2E3                 push    ecx
.text:0000A2E4                 push    esi
.text:0000A2E5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A2EC                 mov     [ebp+var_4], ecx
.text:0000A2EF                 mov     eax, [ebp+var_4]
.text:0000A2F2                 cmp     dword ptr [eax], 0
.text:0000A2F5                 jz      short loc_A31B
.text:0000A2F7                 mov     ecx, [ebp+var_4]
.text:0000A2FA                 mov     edx, [ecx]
.text:0000A2FC                 mov     eax, [ebp+var_4]
.text:0000A2FF                 mov     ecx, [eax]
.text:0000A301                 mov     edx, [edx]
.text:0000A303                 mov     esi, esp
.text:0000A305                 push    ecx
.text:0000A306                 mov     eax, [edx+8]
.text:0000A309                 call    eax
.text:0000A30B                 cmp     esi, esp
.text:0000A30D                 call    __RTC_CheckEsp
.text:0000A312                 mov     ecx, [ebp+var_4]
.text:0000A315                 mov     dword ptr [ecx], 0
.text:0000A31B
.text:0000A31B loc_A31B:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::Release(void)+15j
.text:0000A31B                 pop     esi
.text:0000A31C                 add     esp, 4
.text:0000A31F                 cmp     ebp, esp
.text:0000A321                 call    __RTC_CheckEsp
.text:0000A326                 mov     esp, ebp
.text:0000A328                 pop     ebp
.text:0000A329                 retn
.text:0000A329 ?Release@?$CMyComPtr@UISequentialOutStream@@@@QAEXXZ endp
.text:0000A329
.text:0000A329 ; ---------------------------------------------------------------------------
.text:0000A32A                 align 4
.text:0000A32A _text           ends
.text:0000A32A
.text:0000A32C ; ===========================================================================
.text:0000A32C
.text:0000A32C ; Segment type: Pure code
.text:0000A32C ; Segment permissions: Read/Execute
.text:0000A32C _text           segment para public 'CODE' use32
.text:0000A32C                 assume cs:_text
.text:0000A32C                 ;org 0A32Ch
.text:0000A32C ; COMDAT (pick any)
.text:0000A32C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A32C
.text:0000A32C ; =============== S U B R O U T I N E =======================================
.text:0000A32C
.text:0000A32C ; Attributes: bp-based frame
.text:0000A32C
.text:0000A32C ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::operator struct ISequentialOutStream *(void)const
.text:0000A32C                 public ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ
.text:0000A32C ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ proc near
.text:0000A32C                                         ; CODE XREF: COutStreamWithHash::Write(void const *,uint,uint *)+22p
.text:0000A32C                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+5Dp ...
.text:0000A32C
.text:0000A32C var_4           = dword ptr -4
.text:0000A32C
.text:0000A32C                 push    ebp
.text:0000A32D                 mov     ebp, esp
.text:0000A32F                 push    ecx
.text:0000A330                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A337                 mov     [ebp+var_4], ecx
.text:0000A33A                 mov     eax, [ebp+var_4]
.text:0000A33D                 mov     eax, [eax]
.text:0000A33F                 mov     esp, ebp
.text:0000A341                 pop     ebp
.text:0000A342                 retn
.text:0000A342 ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ endp
.text:0000A342
.text:0000A342 ; ---------------------------------------------------------------------------
.text:0000A343                 align 4
.text:0000A343 _text           ends
.text:0000A343
.text:0000A344 ; ===========================================================================
.text:0000A344
.text:0000A344 ; Segment type: Pure code
.text:0000A344 ; Segment permissions: Read/Execute
.text:0000A344 _text           segment para public 'CODE' use32
.text:0000A344                 assume cs:_text
.text:0000A344                 ;org 0A344h
.text:0000A344 ; COMDAT (pick any)
.text:0000A344                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A344
.text:0000A344 ; =============== S U B R O U T I N E =======================================
.text:0000A344
.text:0000A344 ; Attributes: bp-based frame
.text:0000A344
.text:0000A344 ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::operator->(void)const
.text:0000A344                 public ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ
.text:0000A344 ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ proc near
.text:0000A344                                         ; CODE XREF: COutStreamWithHash::Write(void const *,uint,uint *)+31p
.text:0000A344
.text:0000A344 var_4           = dword ptr -4
.text:0000A344
.text:0000A344                 push    ebp
.text:0000A345                 mov     ebp, esp
.text:0000A347                 push    ecx
.text:0000A348                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A34F                 mov     [ebp+var_4], ecx
.text:0000A352                 mov     eax, [ebp+var_4]
.text:0000A355                 mov     eax, [eax]
.text:0000A357                 mov     esp, ebp
.text:0000A359                 pop     ebp
.text:0000A35A                 retn
.text:0000A35A ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ endp
.text:0000A35A
.text:0000A35A ; ---------------------------------------------------------------------------
.text:0000A35B                 align 4
.text:0000A35B _text           ends
.text:0000A35B
.text:0000A35C ; ===========================================================================
.text:0000A35C
.text:0000A35C ; Segment type: Pure code
.text:0000A35C ; Segment permissions: Read/Execute
.text:0000A35C _text           segment para public 'CODE' use32
.text:0000A35C                 assume cs:_text
.text:0000A35C                 ;org 0A35Ch
.text:0000A35C ; COMDAT (pick any)
.text:0000A35C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A35C
.text:0000A35C ; =============== S U B R O U T I N E =======================================
.text:0000A35C
.text:0000A35C ; Attributes: bp-based frame
.text:0000A35C
.text:0000A35C ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::operator=(struct ISequentialOutStream *)
.text:0000A35C                 public ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z
.text:0000A35C ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z proc near
.text:0000A35C                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1027p
.text:0000A35C                                         ; COutStreamWithHash::SetStream(ISequentialOutStream *)+18p ...
.text:0000A35C
.text:0000A35C var_4           = dword ptr -4
.text:0000A35C arg_0           = dword ptr  8
.text:0000A35C
.text:0000A35C                 push    ebp
.text:0000A35D                 mov     ebp, esp
.text:0000A35F                 push    ecx
.text:0000A360                 push    esi
.text:0000A361                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A368                 mov     [ebp+var_4], ecx
.text:0000A36B                 cmp     [ebp+arg_0], 0
.text:0000A36F                 jz      short loc_A388
.text:0000A371                 mov     eax, [ebp+arg_0]
.text:0000A374                 mov     ecx, [eax]
.text:0000A376                 mov     esi, esp
.text:0000A378                 mov     edx, [ebp+arg_0]
.text:0000A37B                 push    edx
.text:0000A37C                 mov     eax, [ecx+4]
.text:0000A37F                 call    eax
.text:0000A381                 cmp     esi, esp
.text:0000A383                 call    __RTC_CheckEsp
.text:0000A388
.text:0000A388 loc_A388:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)+13j
.text:0000A388                 mov     ecx, [ebp+var_4]
.text:0000A38B                 cmp     dword ptr [ecx], 0
.text:0000A38E                 jz      short loc_A3AB
.text:0000A390                 mov     edx, [ebp+var_4]
.text:0000A393                 mov     eax, [edx]
.text:0000A395                 mov     ecx, [ebp+var_4]
.text:0000A398                 mov     edx, [ecx]
.text:0000A39A                 mov     eax, [eax]
.text:0000A39C                 mov     esi, esp
.text:0000A39E                 push    edx
.text:0000A39F                 mov     ecx, [eax+8]
.text:0000A3A2                 call    ecx
.text:0000A3A4                 cmp     esi, esp
.text:0000A3A6                 call    __RTC_CheckEsp
.text:0000A3AB
.text:0000A3AB loc_A3AB:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)+32j
.text:0000A3AB                 mov     edx, [ebp+var_4]
.text:0000A3AE                 mov     eax, [ebp+arg_0]
.text:0000A3B1                 mov     [edx], eax
.text:0000A3B3                 mov     eax, [ebp+arg_0]
.text:0000A3B6                 pop     esi
.text:0000A3B7                 add     esp, 4
.text:0000A3BA                 cmp     ebp, esp
.text:0000A3BC                 call    __RTC_CheckEsp
.text:0000A3C1                 mov     esp, ebp
.text:0000A3C3                 pop     ebp
.text:0000A3C4                 retn    4
.text:0000A3C4 ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z endp
.text:0000A3C4
.text:0000A3C4 ; ---------------------------------------------------------------------------
.text:0000A3C7                 align 4
.text:0000A3C7 _text           ends
.text:0000A3C7
.text:0000A3C8 ; ===========================================================================
.text:0000A3C8
.text:0000A3C8 ; Segment type: Pure code
.text:0000A3C8 ; Segment permissions: Read/Execute
.text:0000A3C8 _text           segment para public 'CODE' use32
.text:0000A3C8                 assume cs:_text
.text:0000A3C8                 ;org 0A3C8h
.text:0000A3C8 ; COMDAT (pick any)
.text:0000A3C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A3C8
.text:0000A3C8 ; =============== S U B R O U T I N E =======================================
.text:0000A3C8
.text:0000A3C8 ; Attributes: bp-based frame
.text:0000A3C8
.text:0000A3C8 ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::operator=(class CMyComPtr<struct ISequentialOutStream> const &)
.text:0000A3C8                 public ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z
.text:0000A3C8 ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z proc near
.text:0000A3C8                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3241p
.text:0000A3C8                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3264p ...
.text:0000A3C8
.text:0000A3C8 var_4           = dword ptr -4
.text:0000A3C8 arg_0           = dword ptr  8
.text:0000A3C8
.text:0000A3C8                 push    ebp
.text:0000A3C9                 mov     ebp, esp
.text:0000A3CB                 push    ecx
.text:0000A3CC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A3D3                 mov     [ebp+var_4], ecx
.text:0000A3D6                 mov     eax, [ebp+arg_0]
.text:0000A3D9                 mov     ecx, [eax]
.text:0000A3DB                 push    ecx
.text:0000A3DC                 mov     ecx, [ebp+var_4]
.text:0000A3DF                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:0000A3E4                 add     esp, 4
.text:0000A3E7                 cmp     ebp, esp
.text:0000A3E9                 call    __RTC_CheckEsp
.text:0000A3EE                 mov     esp, ebp
.text:0000A3F0                 pop     ebp
.text:0000A3F1                 retn    4
.text:0000A3F1 ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z endp
.text:0000A3F1
.text:0000A3F1 _text           ends
.text:0000A3F1
.text:0000A3F4 ; ===========================================================================
.text:0000A3F4
.text:0000A3F4 ; Segment type: Pure code
.text:0000A3F4 ; Segment permissions: Read/Execute
.text:0000A3F4 _text           segment para public 'CODE' use32
.text:0000A3F4                 assume cs:_text
.text:0000A3F4                 ;org 0A3F4h
.text:0000A3F4 ; COMDAT (pick any)
.text:0000A3F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A3F4
.text:0000A3F4 ; =============== S U B R O U T I N E =======================================
.text:0000A3F4
.text:0000A3F4 ; Attributes: bp-based frame
.text:0000A3F4
.text:0000A3F4 ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::Detach(void)
.text:0000A3F4                 public ?Detach@?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@XZ
.text:0000A3F4 ?Detach@?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@XZ proc near
.text:0000A3F4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3324p
.text:0000A3F4
.text:0000A3F4 var_8           = dword ptr -8
.text:0000A3F4 var_4           = dword ptr -4
.text:0000A3F4
.text:0000A3F4                 push    ebp
.text:0000A3F5                 mov     ebp, esp
.text:0000A3F7                 sub     esp, 8
.text:0000A3FA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000A401                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A408                 mov     [ebp+var_4], ecx
.text:0000A40B                 mov     eax, [ebp+var_4]
.text:0000A40E                 mov     ecx, [eax]
.text:0000A410                 mov     [ebp+var_8], ecx
.text:0000A413                 mov     edx, [ebp+var_4]
.text:0000A416                 mov     dword ptr [edx], 0
.text:0000A41C                 mov     eax, [ebp+var_8]
.text:0000A41F                 mov     esp, ebp
.text:0000A421                 pop     ebp
.text:0000A422                 retn
.text:0000A422 ?Detach@?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@XZ endp
.text:0000A422
.text:0000A422 ; ---------------------------------------------------------------------------
.text:0000A423                 align 4
.text:0000A423 _text           ends
.text:0000A423
.text:0000A424 ; ===========================================================================
.text:0000A424
.text:0000A424 ; Segment type: Pure code
.text:0000A424 ; Segment permissions: Read/Execute
.text:0000A424 _text           segment para public 'CODE' use32
.text:0000A424                 assume cs:_text
.text:0000A424                 ;org 0A424h
.text:0000A424 ; COMDAT (pick any)
.text:0000A424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A424
.text:0000A424 ; =============== S U B R O U T I N E =======================================
.text:0000A424
.text:0000A424 ; Attributes: bp-based frame
.text:0000A424
.text:0000A424 ; public: __thiscall CRecordVector<struct CHardLinkNode>::CRecordVector<struct CHardLinkNode>(void)
.text:0000A424                 public ??0?$CRecordVector@UCHardLinkNode@@@@QAE@XZ
.text:0000A424 ??0?$CRecordVector@UCHardLinkNode@@@@QAE@XZ proc near
.text:0000A424                                         ; CODE XREF: CHardLinks::CHardLinks(void)+30p
.text:0000A424
.text:0000A424 var_4           = dword ptr -4
.text:0000A424
.text:0000A424                 push    ebp
.text:0000A425                 mov     ebp, esp
.text:0000A427                 push    ecx
.text:0000A428                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A42F                 mov     [ebp+var_4], ecx
.text:0000A432                 mov     eax, [ebp+var_4]
.text:0000A435                 mov     dword ptr [eax], 0
.text:0000A43B                 mov     ecx, [ebp+var_4]
.text:0000A43E                 mov     dword ptr [ecx+4], 0
.text:0000A445                 mov     edx, [ebp+var_4]
.text:0000A448                 mov     dword ptr [edx+8], 0
.text:0000A44F                 mov     eax, [ebp+var_4]
.text:0000A452                 mov     esp, ebp
.text:0000A454                 pop     ebp
.text:0000A455                 retn
.text:0000A455 ??0?$CRecordVector@UCHardLinkNode@@@@QAE@XZ endp
.text:0000A455
.text:0000A455 ; ---------------------------------------------------------------------------
.text:0000A456                 align 4
.text:0000A456 _text           ends
.text:0000A456
.text:0000A458 ; ===========================================================================
.text:0000A458
.text:0000A458 ; Segment type: Pure code
.text:0000A458 ; Segment permissions: Read/Execute
.text:0000A458 _text           segment para public 'CODE' use32
.text:0000A458                 assume cs:_text
.text:0000A458                 ;org 0A458h
.text:0000A458 ; COMDAT (pick any)
.text:0000A458                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A458
.text:0000A458 ; =============== S U B R O U T I N E =======================================
.text:0000A458
.text:0000A458 ; Attributes: bp-based frame
.text:0000A458
.text:0000A458 ; public: unsigned int __thiscall CRecordVector<struct CHardLinkNode>::Size(void)const
.text:0000A458                 public ?Size@?$CRecordVector@UCHardLinkNode@@@@QBEIXZ
.text:0000A458 ?Size@?$CRecordVector@UCHardLinkNode@@@@QBEIXZ proc near
.text:0000A458                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+198p
.text:0000A458                                         ; CHardLinks::PrepareLinks(void)+1Fp
.text:0000A458
.text:0000A458 var_4           = dword ptr -4
.text:0000A458
.text:0000A458                 push    ebp
.text:0000A459                 mov     ebp, esp
.text:0000A45B                 push    ecx
.text:0000A45C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A463                 mov     [ebp+var_4], ecx
.text:0000A466                 mov     eax, [ebp+var_4]
.text:0000A469                 mov     eax, [eax+4]
.text:0000A46C                 mov     esp, ebp
.text:0000A46E                 pop     ebp
.text:0000A46F                 retn
.text:0000A46F ?Size@?$CRecordVector@UCHardLinkNode@@@@QBEIXZ endp
.text:0000A46F
.text:0000A46F _text           ends
.text:0000A46F
.text:0000A470 ; ===========================================================================
.text:0000A470
.text:0000A470 ; Segment type: Pure code
.text:0000A470 ; Segment permissions: Read/Execute
.text:0000A470 _text           segment para public 'CODE' use32
.text:0000A470                 assume cs:_text
.text:0000A470                 ;org 0A470h
.text:0000A470 ; COMDAT (pick any)
.text:0000A470                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A470
.text:0000A470 ; =============== S U B R O U T I N E =======================================
.text:0000A470
.text:0000A470 ; Attributes: bp-based frame
.text:0000A470
.text:0000A470 ; public: bool __thiscall CRecordVector<struct CHardLinkNode>::IsEmpty(void)const
.text:0000A470                 public ?IsEmpty@?$CRecordVector@UCHardLinkNode@@@@QBE_NXZ
.text:0000A470 ?IsEmpty@?$CRecordVector@UCHardLinkNode@@@@QBE_NXZ proc near
.text:0000A470                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2C3Cp
.text:0000A470
.text:0000A470 var_4           = dword ptr -4
.text:0000A470
.text:0000A470                 push    ebp
.text:0000A471                 mov     ebp, esp
.text:0000A473                 push    ecx
.text:0000A474                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A47B                 mov     [ebp+var_4], ecx
.text:0000A47E                 mov     eax, [ebp+var_4]
.text:0000A481                 xor     ecx, ecx
.text:0000A483                 cmp     dword ptr [eax+4], 0
.text:0000A487                 setz    cl
.text:0000A48A                 mov     al, cl
.text:0000A48C                 mov     esp, ebp
.text:0000A48E                 pop     ebp
.text:0000A48F                 retn
.text:0000A48F ?IsEmpty@?$CRecordVector@UCHardLinkNode@@@@QBE_NXZ endp
.text:0000A48F
.text:0000A48F _text           ends
.text:0000A48F
.text:0000A490 ; ===========================================================================
.text:0000A490
.text:0000A490 ; Segment type: Pure code
.text:0000A490 ; Segment permissions: Read/Execute
.text:0000A490 _text           segment para public 'CODE' use32
.text:0000A490                 assume cs:_text
.text:0000A490                 ;org 0A490h
.text:0000A490 ; COMDAT (pick any)
.text:0000A490                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A490
.text:0000A490 ; =============== S U B R O U T I N E =======================================
.text:0000A490
.text:0000A490 ; Attributes: bp-based frame
.text:0000A490
.text:0000A490 ; public: __thiscall CRecordVector<struct CHardLinkNode>::~CRecordVector<struct CHardLinkNode>(void)
.text:0000A490                 public ??1?$CRecordVector@UCHardLinkNode@@@@QAE@XZ
.text:0000A490 ??1?$CRecordVector@UCHardLinkNode@@@@QAE@XZ proc near
.text:0000A490                                         ; CODE XREF: CHardLinks::~CHardLinks(void)+49p
.text:0000A490                                         ; __unwindfunclet$??1CHardLinks@@QAE@XZ$0+3j ...
.text:0000A490
.text:0000A490 var_8           = dword ptr -8
.text:0000A490 var_4           = dword ptr -4
.text:0000A490
.text:0000A490                 push    ebp
.text:0000A491                 mov     ebp, esp
.text:0000A493                 sub     esp, 8
.text:0000A496                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000A49D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A4A4                 mov     [ebp+var_4], ecx
.text:0000A4A7                 mov     eax, [ebp+var_4]
.text:0000A4AA                 mov     ecx, [eax]
.text:0000A4AC                 mov     [ebp+var_8], ecx
.text:0000A4AF                 mov     edx, [ebp+var_8]
.text:0000A4B2                 push    edx             ; void *
.text:0000A4B3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000A4B8                 add     esp, 4
.text:0000A4BB                 add     esp, 8
.text:0000A4BE                 cmp     ebp, esp
.text:0000A4C0                 call    __RTC_CheckEsp
.text:0000A4C5                 mov     esp, ebp
.text:0000A4C7                 pop     ebp
.text:0000A4C8                 retn
.text:0000A4C8 ??1?$CRecordVector@UCHardLinkNode@@@@QAE@XZ endp
.text:0000A4C8
.text:0000A4C8 ; ---------------------------------------------------------------------------
.text:0000A4C9                 align 4
.text:0000A4C9 _text           ends
.text:0000A4C9
.text:0000A4CC ; ===========================================================================
.text:0000A4CC
.text:0000A4CC ; Segment type: Pure code
.text:0000A4CC ; Segment permissions: Read/Execute
.text:0000A4CC _text           segment para public 'CODE' use32
.text:0000A4CC                 assume cs:_text
.text:0000A4CC                 ;org 0A4CCh
.text:0000A4CC ; COMDAT (pick any)
.text:0000A4CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A4CC
.text:0000A4CC ; =============== S U B R O U T I N E =======================================
.text:0000A4CC
.text:0000A4CC ; Attributes: bp-based frame
.text:0000A4CC
.text:0000A4CC ; public: void __thiscall CRecordVector<struct CHardLinkNode>::Clear(void)
.text:0000A4CC                 public ?Clear@?$CRecordVector@UCHardLinkNode@@@@QAEXXZ
.text:0000A4CC ?Clear@?$CRecordVector@UCHardLinkNode@@@@QAEXXZ proc near
.text:0000A4CC                                         ; CODE XREF: CHardLinks::Clear(void)+11p
.text:0000A4CC
.text:0000A4CC var_4           = dword ptr -4
.text:0000A4CC
.text:0000A4CC                 push    ebp
.text:0000A4CD                 mov     ebp, esp
.text:0000A4CF                 push    ecx
.text:0000A4D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A4D7                 mov     [ebp+var_4], ecx
.text:0000A4DA                 mov     eax, [ebp+var_4]
.text:0000A4DD                 mov     dword ptr [eax+4], 0
.text:0000A4E4                 mov     esp, ebp
.text:0000A4E6                 pop     ebp
.text:0000A4E7                 retn
.text:0000A4E7 ?Clear@?$CRecordVector@UCHardLinkNode@@@@QAEXXZ endp
.text:0000A4E7
.text:0000A4E7 _text           ends
.text:0000A4E7
.text:0000A4E8 ; ===========================================================================
.text:0000A4E8
.text:0000A4E8 ; Segment type: Pure code
.text:0000A4E8 ; Segment permissions: Read/Execute
.text:0000A4E8 _text           segment para public 'CODE' use32
.text:0000A4E8                 assume cs:_text
.text:0000A4E8                 ;org 0A4E8h
.text:0000A4E8 ; COMDAT (pick any)
.text:0000A4E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A4E8
.text:0000A4E8 ; =============== S U B R O U T I N E =======================================
.text:0000A4E8
.text:0000A4E8 ; Attributes: bp-based frame
.text:0000A4E8
.text:0000A4E8 ; public: void __thiscall CRecordVector<struct CHardLinkNode>::DeleteFrom(unsigned int)
.text:0000A4E8                 public ?DeleteFrom@?$CRecordVector@UCHardLinkNode@@@@QAEXI@Z
.text:0000A4E8 ?DeleteFrom@?$CRecordVector@UCHardLinkNode@@@@QAEXI@Z proc near
.text:0000A4E8                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+238p
.text:0000A4E8
.text:0000A4E8 var_4           = dword ptr -4
.text:0000A4E8 arg_0           = dword ptr  8
.text:0000A4E8
.text:0000A4E8                 push    ebp
.text:0000A4E9                 mov     ebp, esp
.text:0000A4EB                 push    ecx
.text:0000A4EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A4F3                 mov     [ebp+var_4], ecx
.text:0000A4F6                 mov     eax, [ebp+var_4]
.text:0000A4F9                 mov     ecx, [ebp+arg_0]
.text:0000A4FC                 mov     [eax+4], ecx
.text:0000A4FF                 mov     esp, ebp
.text:0000A501                 pop     ebp
.text:0000A502                 retn    4
.text:0000A502 ?DeleteFrom@?$CRecordVector@UCHardLinkNode@@@@QAEXI@Z endp
.text:0000A502
.text:0000A502 ; ---------------------------------------------------------------------------
.text:0000A505                 align 4
.text:0000A505 _text           ends
.text:0000A505
.text:0000A508 ; ===========================================================================
.text:0000A508
.text:0000A508 ; Segment type: Pure code
.text:0000A508 ; Segment permissions: Read/Execute
.text:0000A508 _text           segment para public 'CODE' use32
.text:0000A508                 assume cs:_text
.text:0000A508                 ;org 0A508h
.text:0000A508 ; COMDAT (pick any)
.text:0000A508                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A508
.text:0000A508 ; =============== S U B R O U T I N E =======================================
.text:0000A508
.text:0000A508 ; Attributes: bp-based frame
.text:0000A508
.text:0000A508 ; public: unsigned int __thiscall CRecordVector<struct CHardLinkNode>::Add(struct CHardLinkNode)
.text:0000A508                 public ?Add@?$CRecordVector@UCHardLinkNode@@@@QAEIUCHardLinkNode@@@Z
.text:0000A508 ?Add@?$CRecordVector@UCHardLinkNode@@@@QAEIUCHardLinkNode@@@Z proc near
.text:0000A508                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+163p
.text:0000A508
.text:0000A508 var_14          = dword ptr -14h
.text:0000A508 var_10          = dword ptr -10h
.text:0000A508 var_C           = dword ptr -0Ch
.text:0000A508 var_8           = dword ptr -8
.text:0000A508 var_4           = dword ptr -4
.text:0000A508 arg_0           = dword ptr  8
.text:0000A508 arg_4           = dword ptr  0Ch
.text:0000A508 arg_8           = dword ptr  10h
.text:0000A508 arg_C           = dword ptr  14h
.text:0000A508
.text:0000A508                 push    ebp
.text:0000A509                 mov     ebp, esp
.text:0000A50B                 sub     esp, 14h
.text:0000A50E                 mov     eax, 0CCCCCCCCh
.text:0000A513                 mov     [ebp+var_14], eax
.text:0000A516                 mov     [ebp+var_10], eax
.text:0000A519                 mov     [ebp+var_C], eax
.text:0000A51C                 mov     [ebp+var_8], eax
.text:0000A51F                 mov     [ebp+var_4], eax
.text:0000A522                 mov     [ebp+var_4], ecx
.text:0000A525                 mov     ecx, [ebp+var_4]
.text:0000A528                 call    ?ReserveOnePosition@?$CRecordVector@UCHardLinkNode@@@@AAEXXZ ; CRecordVector<CHardLinkNode>::ReserveOnePosition(void)
.text:0000A52D                 mov     eax, [ebp+var_4]
.text:0000A530                 mov     ecx, [eax+4]
.text:0000A533                 shl     ecx, 4
.text:0000A536                 mov     edx, [ebp+var_4]
.text:0000A539                 mov     eax, [edx]
.text:0000A53B                 add     eax, ecx
.text:0000A53D                 mov     ecx, [ebp+arg_0]
.text:0000A540                 mov     [eax], ecx
.text:0000A542                 mov     edx, [ebp+arg_4]
.text:0000A545                 mov     [eax+4], edx
.text:0000A548                 mov     ecx, [ebp+arg_8]
.text:0000A54B                 mov     [eax+8], ecx
.text:0000A54E                 mov     edx, [ebp+arg_C]
.text:0000A551                 mov     [eax+0Ch], edx
.text:0000A554                 mov     eax, [ebp+var_4]
.text:0000A557                 mov     ecx, [eax+4]
.text:0000A55A                 mov     [ebp+var_14], ecx
.text:0000A55D                 mov     edx, [ebp+var_4]
.text:0000A560                 mov     eax, [edx+4]
.text:0000A563                 add     eax, 1
.text:0000A566                 mov     ecx, [ebp+var_4]
.text:0000A569                 mov     [ecx+4], eax
.text:0000A56C                 mov     eax, [ebp+var_14]
.text:0000A56F                 push    edx
.text:0000A570                 mov     ecx, ebp
.text:0000A572                 push    eax
.text:0000A573                 lea     edx, $LN5_1
.text:0000A579                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000A57E                 pop     eax
.text:0000A57F                 pop     edx
.text:0000A580                 add     esp, 14h
.text:0000A583                 cmp     ebp, esp
.text:0000A585                 call    __RTC_CheckEsp
.text:0000A58A                 mov     esp, ebp
.text:0000A58C                 pop     ebp
.text:0000A58D                 retn    10h
.text:0000A58D ?Add@?$CRecordVector@UCHardLinkNode@@@@QAEIUCHardLinkNode@@@Z endp
.text:0000A58D
.text:0000A58D ; ---------------------------------------------------------------------------
.text:0000A590 $LN5_1          dd 1                    ; DATA XREF: CRecordVector<CHardLinkNode>::Add(CHardLinkNode)+6Bo
.text:0000A594                 dd offset $LN4_3
.text:0000A598 $LN4_3          dd 0FFFFFFF4h, 4        ; DATA XREF: .text:0000A594o
.text:0000A5A0                 dd offset $LN3_0        ; "_$ArrayPad"
.text:0000A5A4 $LN3_0          db '_$ArrayPad',0       ; DATA XREF: .text:0000A5A0o
.text:0000A5AF                 align 10h
.text:0000A5AF _text           ends
.text:0000A5AF
.text:0000A5B0 ; ===========================================================================
.text:0000A5B0
.text:0000A5B0 ; Segment type: Pure code
.text:0000A5B0 ; Segment permissions: Read/Execute
.text:0000A5B0 _text           segment para public 'CODE' use32
.text:0000A5B0                 assume cs:_text
.text:0000A5B0                 ;org 0A5B0h
.text:0000A5B0 ; COMDAT (pick any)
.text:0000A5B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A5B0
.text:0000A5B0 ; =============== S U B R O U T I N E =======================================
.text:0000A5B0
.text:0000A5B0 ; Attributes: bp-based frame
.text:0000A5B0
.text:0000A5B0 ; public: struct CHardLinkNode & __thiscall CRecordVector<struct CHardLinkNode>::operator[](unsigned int)
.text:0000A5B0                 public ??A?$CRecordVector@UCHardLinkNode@@@@QAEAAUCHardLinkNode@@I@Z
.text:0000A5B0 ??A?$CRecordVector@UCHardLinkNode@@@@QAEAAUCHardLinkNode@@I@Z proc near
.text:0000A5B0                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+1B0p
.text:0000A5B0                                         ; CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+1BDp ...
.text:0000A5B0
.text:0000A5B0 var_4           = dword ptr -4
.text:0000A5B0 arg_0           = dword ptr  8
.text:0000A5B0
.text:0000A5B0                 push    ebp
.text:0000A5B1                 mov     ebp, esp
.text:0000A5B3                 push    ecx
.text:0000A5B4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A5BB                 mov     [ebp+var_4], ecx
.text:0000A5BE                 mov     eax, [ebp+arg_0]
.text:0000A5C1                 shl     eax, 4
.text:0000A5C4                 mov     ecx, [ebp+var_4]
.text:0000A5C7                 add     eax, [ecx]
.text:0000A5C9                 mov     esp, ebp
.text:0000A5CB                 pop     ebp
.text:0000A5CC                 retn    4
.text:0000A5CC ??A?$CRecordVector@UCHardLinkNode@@@@QAEAAUCHardLinkNode@@I@Z endp
.text:0000A5CC
.text:0000A5CC ; ---------------------------------------------------------------------------
.text:0000A5CF                 align 10h
.text:0000A5CF _text           ends
.text:0000A5CF
.text:0000A5D0 ; ===========================================================================
.text:0000A5D0
.text:0000A5D0 ; Segment type: Pure code
.text:0000A5D0 ; Segment permissions: Read/Execute
.text:0000A5D0 _text           segment para public 'CODE' use32
.text:0000A5D0                 assume cs:_text
.text:0000A5D0                 ;org 0A5D0h
.text:0000A5D0 ; COMDAT (pick any)
.text:0000A5D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A5D0
.text:0000A5D0 ; =============== S U B R O U T I N E =======================================
.text:0000A5D0
.text:0000A5D0 ; Attributes: bp-based frame
.text:0000A5D0
.text:0000A5D0 ; int __stdcall CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode *)
.text:0000A5D0                 public ?FindInSorted2@?$CRecordVector@UCHardLinkNode@@@@QBEHABUCHardLinkNode@@@Z
.text:0000A5D0 ?FindInSorted2@?$CRecordVector@UCHardLinkNode@@@@QBEHABUCHardLinkNode@@@Z proc near
.text:0000A5D0                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2D0Dp
.text:0000A5D0
.text:0000A5D0 var_4           = dword ptr -4
.text:0000A5D0 arg_0           = dword ptr  8
.text:0000A5D0
.text:0000A5D0                 push    ebp
.text:0000A5D1                 mov     ebp, esp
.text:0000A5D3                 push    ecx
.text:0000A5D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A5DB                 mov     [ebp+var_4], ecx
.text:0000A5DE                 mov     eax, [ebp+var_4]
.text:0000A5E1                 mov     ecx, [eax+4]
.text:0000A5E4                 push    ecx             ; int
.text:0000A5E5                 push    0               ; int
.text:0000A5E7                 mov     edx, [ebp+arg_0]
.text:0000A5EA                 push    edx             ; CHardLinkNode *
.text:0000A5EB                 mov     ecx, [ebp+var_4]
.text:0000A5EE                 call    ?FindInSorted2@?$CRecordVector@UCHardLinkNode@@@@QBEHABUCHardLinkNode@@II@Z ; CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode const &,uint,uint)
.text:0000A5F3                 add     esp, 4
.text:0000A5F6                 cmp     ebp, esp
.text:0000A5F8                 call    __RTC_CheckEsp
.text:0000A5FD                 mov     esp, ebp
.text:0000A5FF                 pop     ebp
.text:0000A600                 retn    4
.text:0000A600 ?FindInSorted2@?$CRecordVector@UCHardLinkNode@@@@QBEHABUCHardLinkNode@@@Z endp
.text:0000A600
.text:0000A600 ; ---------------------------------------------------------------------------
.text:0000A603                 align 4
.text:0000A603 _text           ends
.text:0000A603
.text:0000A604 ; ===========================================================================
.text:0000A604
.text:0000A604 ; Segment type: Pure code
.text:0000A604 ; Segment permissions: Read/Execute
.text:0000A604 _text           segment para public 'CODE' use32
.text:0000A604                 assume cs:_text
.text:0000A604                 ;org 0A604h
.text:0000A604 ; COMDAT (pick any)
.text:0000A604                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A604
.text:0000A604 ; =============== S U B R O U T I N E =======================================
.text:0000A604
.text:0000A604 ; Attributes: bp-based frame
.text:0000A604
.text:0000A604 ; public: void __thiscall CRecordVector<struct CHardLinkNode>::Sort2(void)
.text:0000A604                 public ?Sort2@?$CRecordVector@UCHardLinkNode@@@@QAEXXZ
.text:0000A604 ?Sort2@?$CRecordVector@UCHardLinkNode@@@@QAEXXZ proc near
.text:0000A604                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+170p
.text:0000A604
.text:0000A604 var_2C          = byte ptr -2Ch
.text:0000A604 var_28          = dword ptr -28h
.text:0000A604 var_24          = dword ptr -24h
.text:0000A604 var_20          = dword ptr -20h
.text:0000A604 var_1C          = dword ptr -1Ch
.text:0000A604 var_14          = dword ptr -14h
.text:0000A604 var_10          = dword ptr -10h
.text:0000A604 var_C           = dword ptr -0Ch
.text:0000A604 var_8           = dword ptr -8
.text:0000A604 var_4           = dword ptr -4
.text:0000A604
.text:0000A604                 push    ebp
.text:0000A605                 mov     ebp, esp
.text:0000A607                 sub     esp, 2Ch
.text:0000A60A                 push    edi
.text:0000A60B                 push    ecx
.text:0000A60C                 lea     edi, [ebp+var_2C]
.text:0000A60F                 mov     ecx, 0Bh
.text:0000A614                 mov     eax, 0CCCCCCCCh
.text:0000A619                 rep stosd
.text:0000A61B                 pop     ecx
.text:0000A61C                 mov     eax, dword ptr ds:___security_cookie
.text:0000A621                 xor     eax, ebp
.text:0000A623                 mov     [ebp+var_4], eax
.text:0000A626                 mov     [ebp+var_8], ecx
.text:0000A629                 mov     eax, [ebp+var_8]
.text:0000A62C                 mov     ecx, [eax+4]
.text:0000A62F                 mov     [ebp+var_C], ecx
.text:0000A632                 cmp     [ebp+var_C], 1
.text:0000A636                 ja      short loc_A63D
.text:0000A638                 jmp     loc_A6EF
.text:0000A63D ; ---------------------------------------------------------------------------
.text:0000A63D
.text:0000A63D loc_A63D:                               ; CODE XREF: CRecordVector<CHardLinkNode>::Sort2(void)+32j
.text:0000A63D                 mov     ecx, [ebp+var_8]
.text:0000A640                 call    ?Front@?$CRecordVector@UCHardLinkNode@@@@QAEAAUCHardLinkNode@@XZ ; CRecordVector<CHardLinkNode>::Front(void)
.text:0000A645                 sub     eax, 10h
.text:0000A648                 mov     [ebp+var_10], eax
.text:0000A64B                 mov     edx, [ebp+var_C]
.text:0000A64E                 shr     edx, 1
.text:0000A650                 mov     [ebp+var_14], edx
.text:0000A653
.text:0000A653 loc_A653:                               ; CODE XREF: CRecordVector<CHardLinkNode>::Sort2(void)+69j
.text:0000A653                 mov     eax, [ebp+var_C]
.text:0000A656                 push    eax
.text:0000A657                 mov     ecx, [ebp+var_14]
.text:0000A65A                 push    ecx
.text:0000A65B                 mov     edx, [ebp+var_10]
.text:0000A65E                 push    edx
.text:0000A65F                 call    ?SortRefDown2@?$CRecordVector@UCHardLinkNode@@@@SGXPAUCHardLinkNode@@II@Z ; CRecordVector<CHardLinkNode>::SortRefDown2(CHardLinkNode *,uint,uint)
.text:0000A664                 mov     eax, [ebp+var_14]
.text:0000A667                 sub     eax, 1
.text:0000A66A                 mov     [ebp+var_14], eax
.text:0000A66D                 jnz     short loc_A653
.text:0000A66F
.text:0000A66F loc_A66F:                               ; CODE XREF: CRecordVector<CHardLinkNode>::Sort2(void)+E9j
.text:0000A66F                 mov     ecx, [ebp+var_C]
.text:0000A672                 shl     ecx, 4
.text:0000A675                 add     ecx, [ebp+var_10]
.text:0000A678                 mov     edx, [ecx]
.text:0000A67A                 mov     [ebp+var_28], edx
.text:0000A67D                 mov     eax, [ecx+4]
.text:0000A680                 mov     [ebp+var_24], eax
.text:0000A683                 mov     edx, [ecx+8]
.text:0000A686                 mov     [ebp+var_20], edx
.text:0000A689                 mov     eax, [ecx+0Ch]
.text:0000A68C                 mov     [ebp+var_1C], eax
.text:0000A68F                 mov     ecx, [ebp+var_10]
.text:0000A692                 add     ecx, 10h
.text:0000A695                 mov     edx, [ebp+var_C]
.text:0000A698                 shl     edx, 4
.text:0000A69B                 add     edx, [ebp+var_10]
.text:0000A69E                 mov     eax, [ecx]
.text:0000A6A0                 mov     [edx], eax
.text:0000A6A2                 mov     eax, [ecx+4]
.text:0000A6A5                 mov     [edx+4], eax
.text:0000A6A8                 mov     eax, [ecx+8]
.text:0000A6AB                 mov     [edx+8], eax
.text:0000A6AE                 mov     ecx, [ecx+0Ch]
.text:0000A6B1                 mov     [edx+0Ch], ecx
.text:0000A6B4                 mov     edx, [ebp+var_C]
.text:0000A6B7                 sub     edx, 1
.text:0000A6BA                 mov     [ebp+var_C], edx
.text:0000A6BD                 mov     eax, [ebp+var_10]
.text:0000A6C0                 add     eax, 10h
.text:0000A6C3                 mov     ecx, [ebp+var_28]
.text:0000A6C6                 mov     [eax], ecx
.text:0000A6C8                 mov     edx, [ebp+var_24]
.text:0000A6CB                 mov     [eax+4], edx
.text:0000A6CE                 mov     ecx, [ebp+var_20]
.text:0000A6D1                 mov     [eax+8], ecx
.text:0000A6D4                 mov     edx, [ebp+var_1C]
.text:0000A6D7                 mov     [eax+0Ch], edx
.text:0000A6DA                 mov     eax, [ebp+var_C]
.text:0000A6DD                 push    eax
.text:0000A6DE                 push    1
.text:0000A6E0                 mov     ecx, [ebp+var_10]
.text:0000A6E3                 push    ecx
.text:0000A6E4                 call    ?SortRefDown2@?$CRecordVector@UCHardLinkNode@@@@SGXPAUCHardLinkNode@@II@Z ; CRecordVector<CHardLinkNode>::SortRefDown2(CHardLinkNode *,uint,uint)
.text:0000A6E9                 cmp     [ebp+var_C], 1
.text:0000A6ED                 ja      short loc_A66F
.text:0000A6EF
.text:0000A6EF loc_A6EF:                               ; CODE XREF: CRecordVector<CHardLinkNode>::Sort2(void)+34j
.text:0000A6EF                 push    edx
.text:0000A6F0                 mov     ecx, ebp
.text:0000A6F2                 push    eax
.text:0000A6F3                 lea     edx, $LN12_5
.text:0000A6F9                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000A6FE                 pop     eax
.text:0000A6FF                 pop     edx
.text:0000A700                 pop     edi
.text:0000A701                 mov     ecx, [ebp+var_4]
.text:0000A704                 xor     ecx, ebp
.text:0000A706                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:0000A70B                 add     esp, 2Ch
.text:0000A70E                 cmp     ebp, esp
.text:0000A710                 call    __RTC_CheckEsp
.text:0000A715                 mov     esp, ebp
.text:0000A717                 pop     ebp
.text:0000A718                 retn
.text:0000A718 ?Sort2@?$CRecordVector@UCHardLinkNode@@@@QAEXXZ endp
.text:0000A718
.text:0000A718 ; ---------------------------------------------------------------------------
.text:0000A719                 align 4
.text:0000A71C $LN12_5         dd 1                    ; DATA XREF: CRecordVector<CHardLinkNode>::Sort2(void)+EFo
.text:0000A720                 dd offset $LN11_6
.text:0000A724 $LN11_6         dd 0FFFFFFD8h, 10h      ; DATA XREF: .text:0000A720o
.text:0000A72C                 dd offset $LN10_6       ; "temp"
.text:0000A730 $LN10_6         db 'temp',0             ; DATA XREF: .text:0000A72Co
.text:0000A735                 align 4
.text:0000A735 _text           ends
.text:0000A735
.text:0000A738 ; ===========================================================================
.text:0000A738
.text:0000A738 ; Segment type: Pure code
.text:0000A738 ; Segment permissions: Read/Execute
.text:0000A738 _text           segment para public 'CODE' use32
.text:0000A738                 assume cs:_text
.text:0000A738                 ;org 0A738h
.text:0000A738 ; COMDAT (pick any)
.text:0000A738                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A738
.text:0000A738 ; =============== S U B R O U T I N E =======================================
.text:0000A738
.text:0000A738 ; Attributes: bp-based frame
.text:0000A738
.text:0000A738 ; public: __thiscall CMyComPtr<struct IFolderArchiveExtractCallback>::CMyComPtr<struct IFolderArchiveExtractCallback>(void)
.text:0000A738                 public ??0?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAE@XZ
.text:0000A738 ??0?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAE@XZ proc near
.text:0000A738                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+A5p
.text:0000A738
.text:0000A738 var_4           = dword ptr -4
.text:0000A738
.text:0000A738                 push    ebp
.text:0000A739                 mov     ebp, esp
.text:0000A73B                 push    ecx
.text:0000A73C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A743                 mov     [ebp+var_4], ecx
.text:0000A746                 mov     eax, [ebp+var_4]
.text:0000A749                 mov     dword ptr [eax], 0
.text:0000A74F                 mov     eax, [ebp+var_4]
.text:0000A752                 mov     esp, ebp
.text:0000A754                 pop     ebp
.text:0000A755                 retn
.text:0000A755 ??0?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAE@XZ endp
.text:0000A755
.text:0000A755 ; ---------------------------------------------------------------------------
.text:0000A756                 align 4
.text:0000A756 _text           ends
.text:0000A756
.text:0000A758 ; ===========================================================================
.text:0000A758
.text:0000A758 ; Segment type: Pure code
.text:0000A758 ; Segment permissions: Read/Execute
.text:0000A758 _text           segment para public 'CODE' use32
.text:0000A758                 assume cs:_text
.text:0000A758                 ;org 0A758h
.text:0000A758 ; COMDAT (pick any)
.text:0000A758                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A758
.text:0000A758 ; =============== S U B R O U T I N E =======================================
.text:0000A758
.text:0000A758 ; Attributes: bp-based frame
.text:0000A758
.text:0000A758 ; public: __thiscall CMyComPtr<struct IFolderArchiveExtractCallback>::~CMyComPtr<struct IFolderArchiveExtractCallback>(void)
.text:0000A758                 public ??1?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAE@XZ
.text:0000A758 ??1?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAE@XZ proc near
.text:0000A758                                         ; CODE XREF: __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$0+6j
.text:0000A758                                         ; CArchiveExtractCallback::~CArchiveExtractCallback(void)+166p ...
.text:0000A758
.text:0000A758 var_4           = dword ptr -4
.text:0000A758
.text:0000A758                 push    ebp
.text:0000A759                 mov     ebp, esp
.text:0000A75B                 push    ecx
.text:0000A75C                 push    esi
.text:0000A75D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A764                 mov     [ebp+var_4], ecx
.text:0000A767                 mov     eax, [ebp+var_4]
.text:0000A76A                 cmp     dword ptr [eax], 0
.text:0000A76D                 jz      short loc_A78A
.text:0000A76F                 mov     ecx, [ebp+var_4]
.text:0000A772                 mov     edx, [ecx]
.text:0000A774                 mov     eax, [ebp+var_4]
.text:0000A777                 mov     ecx, [eax]
.text:0000A779                 mov     edx, [edx]
.text:0000A77B                 mov     esi, esp
.text:0000A77D                 push    ecx
.text:0000A77E                 mov     eax, [edx+8]
.text:0000A781                 call    eax
.text:0000A783                 cmp     esi, esp
.text:0000A785                 call    __RTC_CheckEsp
.text:0000A78A
.text:0000A78A loc_A78A:                               ; CODE XREF: CMyComPtr<IFolderArchiveExtractCallback>::~CMyComPtr<IFolderArchiveExtractCallback>(void)+15j
.text:0000A78A                 pop     esi
.text:0000A78B                 add     esp, 4
.text:0000A78E                 cmp     ebp, esp
.text:0000A790                 call    __RTC_CheckEsp
.text:0000A795                 mov     esp, ebp
.text:0000A797                 pop     ebp
.text:0000A798                 retn
.text:0000A798 ??1?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAE@XZ endp
.text:0000A798
.text:0000A798 ; ---------------------------------------------------------------------------
.text:0000A799                 align 4
.text:0000A799 _text           ends
.text:0000A799
.text:0000A79C ; ===========================================================================
.text:0000A79C
.text:0000A79C ; Segment type: Pure code
.text:0000A79C ; Segment permissions: Read/Execute
.text:0000A79C _text           segment para public 'CODE' use32
.text:0000A79C                 assume cs:_text
.text:0000A79C                 ;org 0A79Ch
.text:0000A79C ; COMDAT (pick any)
.text:0000A79C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A79C
.text:0000A79C ; =============== S U B R O U T I N E =======================================
.text:0000A79C
.text:0000A79C ; Attributes: bp-based frame
.text:0000A79C
.text:0000A79C ; public: __thiscall CMyComPtr<struct IFolderArchiveExtractCallback>::operator struct IFolderArchiveExtractCallback *(void)const
.text:0000A79C                 public ??B?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ
.text:0000A79C ??B?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ proc near
.text:0000A79C                                         ; CODE XREF: CArchiveExtractCallback::SetTotal(unsigned __int64)+7Ap
.text:0000A79C
.text:0000A79C var_4           = dword ptr -4
.text:0000A79C
.text:0000A79C                 push    ebp
.text:0000A79D                 mov     ebp, esp
.text:0000A79F                 push    ecx
.text:0000A7A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A7A7                 mov     [ebp+var_4], ecx
.text:0000A7AA                 mov     eax, [ebp+var_4]
.text:0000A7AD                 mov     eax, [eax]
.text:0000A7AF                 mov     esp, ebp
.text:0000A7B1                 pop     ebp
.text:0000A7B2                 retn
.text:0000A7B2 ??B?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ endp
.text:0000A7B2
.text:0000A7B2 ; ---------------------------------------------------------------------------
.text:0000A7B3                 align 4
.text:0000A7B3 _text           ends
.text:0000A7B3
.text:0000A7B4 ; ===========================================================================
.text:0000A7B4
.text:0000A7B4 ; Segment type: Pure code
.text:0000A7B4 ; Segment permissions: Read/Execute
.text:0000A7B4 _text           segment para public 'CODE' use32
.text:0000A7B4                 assume cs:_text
.text:0000A7B4                 ;org 0A7B4h
.text:0000A7B4 ; COMDAT (pick any)
.text:0000A7B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A7B4
.text:0000A7B4 ; =============== S U B R O U T I N E =======================================
.text:0000A7B4
.text:0000A7B4 ; Attributes: bp-based frame
.text:0000A7B4
.text:0000A7B4 ; public: struct IFolderArchiveExtractCallback * __thiscall CMyComPtr<struct IFolderArchiveExtractCallback>::operator->(void)const
.text:0000A7B4                 public ??C?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ
.text:0000A7B4 ??C?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ proc near
.text:0000A7B4                                         ; CODE XREF: CArchiveExtractCallback::SetTotal(unsigned __int64)+8Ep
.text:0000A7B4                                         ; CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)+EBp ...
.text:0000A7B4
.text:0000A7B4 var_4           = dword ptr -4
.text:0000A7B4
.text:0000A7B4                 push    ebp
.text:0000A7B5                 mov     ebp, esp
.text:0000A7B7                 push    ecx
.text:0000A7B8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A7BF                 mov     [ebp+var_4], ecx
.text:0000A7C2                 mov     eax, [ebp+var_4]
.text:0000A7C5                 mov     eax, [eax]
.text:0000A7C7                 mov     esp, ebp
.text:0000A7C9                 pop     ebp
.text:0000A7CA                 retn
.text:0000A7CA ??C?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEPAUIFolderArchiveExtractCallback@@XZ endp
.text:0000A7CA
.text:0000A7CA ; ---------------------------------------------------------------------------
.text:0000A7CB                 align 4
.text:0000A7CB _text           ends
.text:0000A7CB
.text:0000A7CC ; ===========================================================================
.text:0000A7CC
.text:0000A7CC ; Segment type: Pure code
.text:0000A7CC ; Segment permissions: Read/Execute
.text:0000A7CC _text           segment para public 'CODE' use32
.text:0000A7CC                 assume cs:_text
.text:0000A7CC                 ;org 0A7CCh
.text:0000A7CC ; COMDAT (pick any)
.text:0000A7CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A7CC
.text:0000A7CC ; =============== S U B R O U T I N E =======================================
.text:0000A7CC
.text:0000A7CC ; Attributes: bp-based frame
.text:0000A7CC
.text:0000A7CC ; public: struct IFolderArchiveExtractCallback * __thiscall CMyComPtr<struct IFolderArchiveExtractCallback>::operator=(struct IFolderArchiveExtractCallback *)
.text:0000A7CC                 public ??4?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAEPAUIFolderArchiveExtractCallback@@PAU1@@Z
.text:0000A7CC ??4?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAEPAUIFolderArchiveExtractCallback@@PAU1@@Z proc near
.text:0000A7CC                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+D9p
.text:0000A7CC
.text:0000A7CC var_4           = dword ptr -4
.text:0000A7CC arg_0           = dword ptr  8
.text:0000A7CC
.text:0000A7CC                 push    ebp
.text:0000A7CD                 mov     ebp, esp
.text:0000A7CF                 push    ecx
.text:0000A7D0                 push    esi
.text:0000A7D1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A7D8                 mov     [ebp+var_4], ecx
.text:0000A7DB                 cmp     [ebp+arg_0], 0
.text:0000A7DF                 jz      short loc_A7F8
.text:0000A7E1                 mov     eax, [ebp+arg_0]
.text:0000A7E4                 mov     ecx, [eax]
.text:0000A7E6                 mov     esi, esp
.text:0000A7E8                 mov     edx, [ebp+arg_0]
.text:0000A7EB                 push    edx
.text:0000A7EC                 mov     eax, [ecx+4]
.text:0000A7EF                 call    eax
.text:0000A7F1                 cmp     esi, esp
.text:0000A7F3                 call    __RTC_CheckEsp
.text:0000A7F8
.text:0000A7F8 loc_A7F8:                               ; CODE XREF: CMyComPtr<IFolderArchiveExtractCallback>::operator=(IFolderArchiveExtractCallback *)+13j
.text:0000A7F8                 mov     ecx, [ebp+var_4]
.text:0000A7FB                 cmp     dword ptr [ecx], 0
.text:0000A7FE                 jz      short loc_A81B
.text:0000A800                 mov     edx, [ebp+var_4]
.text:0000A803                 mov     eax, [edx]
.text:0000A805                 mov     ecx, [ebp+var_4]
.text:0000A808                 mov     edx, [ecx]
.text:0000A80A                 mov     eax, [eax]
.text:0000A80C                 mov     esi, esp
.text:0000A80E                 push    edx
.text:0000A80F                 mov     ecx, [eax+8]
.text:0000A812                 call    ecx
.text:0000A814                 cmp     esi, esp
.text:0000A816                 call    __RTC_CheckEsp
.text:0000A81B
.text:0000A81B loc_A81B:                               ; CODE XREF: CMyComPtr<IFolderArchiveExtractCallback>::operator=(IFolderArchiveExtractCallback *)+32j
.text:0000A81B                 mov     edx, [ebp+var_4]
.text:0000A81E                 mov     eax, [ebp+arg_0]
.text:0000A821                 mov     [edx], eax
.text:0000A823                 mov     eax, [ebp+arg_0]
.text:0000A826                 pop     esi
.text:0000A827                 add     esp, 4
.text:0000A82A                 cmp     ebp, esp
.text:0000A82C                 call    __RTC_CheckEsp
.text:0000A831                 mov     esp, ebp
.text:0000A833                 pop     ebp
.text:0000A834                 retn    4
.text:0000A834 ??4?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QAEPAUIFolderArchiveExtractCallback@@PAU1@@Z endp
.text:0000A834
.text:0000A834 ; ---------------------------------------------------------------------------
.text:0000A837                 align 4
.text:0000A837 _text           ends
.text:0000A837
.text:0000A838 ; ===========================================================================
.text:0000A838
.text:0000A838 ; Segment type: Pure code
.text:0000A838 ; Segment permissions: Read/Execute
.text:0000A838 _text           segment para public 'CODE' use32
.text:0000A838                 assume cs:_text
.text:0000A838                 ;org 0A838h
.text:0000A838 ; COMDAT (pick any)
.text:0000A838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A838
.text:0000A838 ; =============== S U B R O U T I N E =======================================
.text:0000A838
.text:0000A838 ; Attributes: bp-based frame
.text:0000A838
.text:0000A838 ; public: bool __thiscall CMyComPtr<struct IFolderArchiveExtractCallback>::operator!(void)const
.text:0000A838                 public ??7?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBE_NXZ
.text:0000A838 ??7?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBE_NXZ proc near
.text:0000A838                                         ; CODE XREF: CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)+48p
.text:0000A838
.text:0000A838 var_4           = dword ptr -4
.text:0000A838
.text:0000A838                 push    ebp
.text:0000A839                 mov     ebp, esp
.text:0000A83B                 push    ecx
.text:0000A83C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A843                 mov     [ebp+var_4], ecx
.text:0000A846                 mov     eax, [ebp+var_4]
.text:0000A849                 xor     ecx, ecx
.text:0000A84B                 cmp     dword ptr [eax], 0
.text:0000A84E                 setz    cl
.text:0000A851                 mov     al, cl
.text:0000A853                 mov     esp, ebp
.text:0000A855                 pop     ebp
.text:0000A856                 retn
.text:0000A856 ??7?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBE_NXZ endp
.text:0000A856
.text:0000A856 ; ---------------------------------------------------------------------------
.text:0000A857                 align 4
.text:0000A857 _text           ends
.text:0000A857
.text:0000A858 ; ===========================================================================
.text:0000A858
.text:0000A858 ; Segment type: Pure code
.text:0000A858 ; Segment permissions: Read/Execute
.text:0000A858 _text           segment para public 'CODE' use32
.text:0000A858                 assume cs:_text
.text:0000A858                 ;org 0A858h
.text:0000A858 ; COMDAT (pick any)
.text:0000A858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A858
.text:0000A858 ; =============== S U B R O U T I N E =======================================
.text:0000A858
.text:0000A858 ; Attributes: bp-based frame
.text:0000A858
.text:0000A858 ; public: __thiscall CMyComPtr<struct ICryptoGetTextPassword>::CMyComPtr<struct ICryptoGetTextPassword>(void)
.text:0000A858                 public ??0?$CMyComPtr@UICryptoGetTextPassword@@@@QAE@XZ
.text:0000A858 ??0?$CMyComPtr@UICryptoGetTextPassword@@@@QAE@XZ proc near
.text:0000A858                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+C6p
.text:0000A858
.text:0000A858 var_4           = dword ptr -4
.text:0000A858
.text:0000A858                 push    ebp
.text:0000A859                 mov     ebp, esp
.text:0000A85B                 push    ecx
.text:0000A85C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A863                 mov     [ebp+var_4], ecx
.text:0000A866                 mov     eax, [ebp+var_4]
.text:0000A869                 mov     dword ptr [eax], 0
.text:0000A86F                 mov     eax, [ebp+var_4]
.text:0000A872                 mov     esp, ebp
.text:0000A874                 pop     ebp
.text:0000A875                 retn
.text:0000A875 ??0?$CMyComPtr@UICryptoGetTextPassword@@@@QAE@XZ endp
.text:0000A875
.text:0000A875 ; ---------------------------------------------------------------------------
.text:0000A876                 align 4
.text:0000A876 _text           ends
.text:0000A876
.text:0000A878 ; ===========================================================================
.text:0000A878
.text:0000A878 ; Segment type: Pure code
.text:0000A878 ; Segment permissions: Read/Execute
.text:0000A878 _text           segment para public 'CODE' use32
.text:0000A878                 assume cs:_text
.text:0000A878                 ;org 0A878h
.text:0000A878 ; COMDAT (pick any)
.text:0000A878                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A878
.text:0000A878 ; =============== S U B R O U T I N E =======================================
.text:0000A878
.text:0000A878 ; Attributes: bp-based frame
.text:0000A878
.text:0000A878 ; public: __thiscall CMyComPtr<struct ICryptoGetTextPassword>::~CMyComPtr<struct ICryptoGetTextPassword>(void)
.text:0000A878                 public ??1?$CMyComPtr@UICryptoGetTextPassword@@@@QAE@XZ
.text:0000A878 ??1?$CMyComPtr@UICryptoGetTextPassword@@@@QAE@XZ proc near
.text:0000A878                                         ; CODE XREF: __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$2+6j
.text:0000A878                                         ; CArchiveExtractCallback::~CArchiveExtractCallback(void)+145p ...
.text:0000A878
.text:0000A878 var_4           = dword ptr -4
.text:0000A878
.text:0000A878                 push    ebp
.text:0000A879                 mov     ebp, esp
.text:0000A87B                 push    ecx
.text:0000A87C                 push    esi
.text:0000A87D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A884                 mov     [ebp+var_4], ecx
.text:0000A887                 mov     eax, [ebp+var_4]
.text:0000A88A                 cmp     dword ptr [eax], 0
.text:0000A88D                 jz      short loc_A8AA
.text:0000A88F                 mov     ecx, [ebp+var_4]
.text:0000A892                 mov     edx, [ecx]
.text:0000A894                 mov     eax, [ebp+var_4]
.text:0000A897                 mov     ecx, [eax]
.text:0000A899                 mov     edx, [edx]
.text:0000A89B                 mov     esi, esp
.text:0000A89D                 push    ecx
.text:0000A89E                 mov     eax, [edx+8]
.text:0000A8A1                 call    eax
.text:0000A8A3                 cmp     esi, esp
.text:0000A8A5                 call    __RTC_CheckEsp
.text:0000A8AA
.text:0000A8AA loc_A8AA:                               ; CODE XREF: CMyComPtr<ICryptoGetTextPassword>::~CMyComPtr<ICryptoGetTextPassword>(void)+15j
.text:0000A8AA                 pop     esi
.text:0000A8AB                 add     esp, 4
.text:0000A8AE                 cmp     ebp, esp
.text:0000A8B0                 call    __RTC_CheckEsp
.text:0000A8B5                 mov     esp, ebp
.text:0000A8B7                 pop     ebp
.text:0000A8B8                 retn
.text:0000A8B8 ??1?$CMyComPtr@UICryptoGetTextPassword@@@@QAE@XZ endp
.text:0000A8B8
.text:0000A8B8 ; ---------------------------------------------------------------------------
.text:0000A8B9                 align 4
.text:0000A8B9 _text           ends
.text:0000A8B9
.text:0000A8BC ; ===========================================================================
.text:0000A8BC
.text:0000A8BC ; Segment type: Pure code
.text:0000A8BC ; Segment permissions: Read/Execute
.text:0000A8BC _text           segment para public 'CODE' use32
.text:0000A8BC                 assume cs:_text
.text:0000A8BC                 ;org 0A8BCh
.text:0000A8BC ; COMDAT (pick any)
.text:0000A8BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A8BC
.text:0000A8BC ; =============== S U B R O U T I N E =======================================
.text:0000A8BC
.text:0000A8BC ; Attributes: bp-based frame
.text:0000A8BC
.text:0000A8BC ; public: struct ICryptoGetTextPassword * * __thiscall CMyComPtr<struct ICryptoGetTextPassword>::operator&(void)
.text:0000A8BC                 public ??I?$CMyComPtr@UICryptoGetTextPassword@@@@QAEPAPAUICryptoGetTextPassword@@XZ
.text:0000A8BC ??I?$CMyComPtr@UICryptoGetTextPassword@@@@QAEPAPAUICryptoGetTextPassword@@XZ proc near
.text:0000A8BC                                         ; CODE XREF: CArchiveExtractCallback::CryptoGetTextPassword(wchar_t * *)+69p
.text:0000A8BC
.text:0000A8BC var_4           = dword ptr -4
.text:0000A8BC
.text:0000A8BC                 push    ebp
.text:0000A8BD                 mov     ebp, esp
.text:0000A8BF                 push    ecx
.text:0000A8C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A8C7                 mov     [ebp+var_4], ecx
.text:0000A8CA                 mov     eax, [ebp+var_4]
.text:0000A8CD                 mov     esp, ebp
.text:0000A8CF                 pop     ebp
.text:0000A8D0                 retn
.text:0000A8D0 ??I?$CMyComPtr@UICryptoGetTextPassword@@@@QAEPAPAUICryptoGetTextPassword@@XZ endp
.text:0000A8D0
.text:0000A8D0 ; ---------------------------------------------------------------------------
.text:0000A8D1                 align 4
.text:0000A8D1 _text           ends
.text:0000A8D1
.text:0000A8D4 ; ===========================================================================
.text:0000A8D4
.text:0000A8D4 ; Segment type: Pure code
.text:0000A8D4 ; Segment permissions: Read/Execute
.text:0000A8D4 _text           segment para public 'CODE' use32
.text:0000A8D4                 assume cs:_text
.text:0000A8D4                 ;org 0A8D4h
.text:0000A8D4 ; COMDAT (pick any)
.text:0000A8D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A8D4
.text:0000A8D4 ; =============== S U B R O U T I N E =======================================
.text:0000A8D4
.text:0000A8D4 ; Attributes: bp-based frame
.text:0000A8D4
.text:0000A8D4 ; public: struct ICryptoGetTextPassword * __thiscall CMyComPtr<struct ICryptoGetTextPassword>::operator->(void)const
.text:0000A8D4                 public ??C?$CMyComPtr@UICryptoGetTextPassword@@@@QBEPAUICryptoGetTextPassword@@XZ
.text:0000A8D4 ??C?$CMyComPtr@UICryptoGetTextPassword@@@@QBEPAUICryptoGetTextPassword@@XZ proc near
.text:0000A8D4                                         ; CODE XREF: CArchiveExtractCallback::CryptoGetTextPassword(wchar_t * *)+99p
.text:0000A8D4
.text:0000A8D4 var_4           = dword ptr -4
.text:0000A8D4
.text:0000A8D4                 push    ebp
.text:0000A8D5                 mov     ebp, esp
.text:0000A8D7                 push    ecx
.text:0000A8D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A8DF                 mov     [ebp+var_4], ecx
.text:0000A8E2                 mov     eax, [ebp+var_4]
.text:0000A8E5                 mov     eax, [eax]
.text:0000A8E7                 mov     esp, ebp
.text:0000A8E9                 pop     ebp
.text:0000A8EA                 retn
.text:0000A8EA ??C?$CMyComPtr@UICryptoGetTextPassword@@@@QBEPAUICryptoGetTextPassword@@XZ endp
.text:0000A8EA
.text:0000A8EA ; ---------------------------------------------------------------------------
.text:0000A8EB                 align 4
.text:0000A8EB _text           ends
.text:0000A8EB
.text:0000A8EC ; ===========================================================================
.text:0000A8EC
.text:0000A8EC ; Segment type: Pure code
.text:0000A8EC ; Segment permissions: Read/Execute
.text:0000A8EC _text           segment para public 'CODE' use32
.text:0000A8EC                 assume cs:_text
.text:0000A8EC                 ;org 0A8ECh
.text:0000A8EC ; COMDAT (pick any)
.text:0000A8EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A8EC
.text:0000A8EC ; =============== S U B R O U T I N E =======================================
.text:0000A8EC
.text:0000A8EC ; Attributes: bp-based frame
.text:0000A8EC
.text:0000A8EC ; public: bool __thiscall CMyComPtr<struct ICryptoGetTextPassword>::operator!(void)const
.text:0000A8EC                 public ??7?$CMyComPtr@UICryptoGetTextPassword@@@@QBE_NXZ
.text:0000A8EC ??7?$CMyComPtr@UICryptoGetTextPassword@@@@QBE_NXZ proc near
.text:0000A8EC                                         ; CODE XREF: CArchiveExtractCallback::CryptoGetTextPassword(wchar_t * *)+53p
.text:0000A8EC
.text:0000A8EC var_4           = dword ptr -4
.text:0000A8EC
.text:0000A8EC                 push    ebp
.text:0000A8ED                 mov     ebp, esp
.text:0000A8EF                 push    ecx
.text:0000A8F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A8F7                 mov     [ebp+var_4], ecx
.text:0000A8FA                 mov     eax, [ebp+var_4]
.text:0000A8FD                 xor     ecx, ecx
.text:0000A8FF                 cmp     dword ptr [eax], 0
.text:0000A902                 setz    cl
.text:0000A905                 mov     al, cl
.text:0000A907                 mov     esp, ebp
.text:0000A909                 pop     ebp
.text:0000A90A                 retn
.text:0000A90A ??7?$CMyComPtr@UICryptoGetTextPassword@@@@QBE_NXZ endp
.text:0000A90A
.text:0000A90A ; ---------------------------------------------------------------------------
.text:0000A90B                 align 4
.text:0000A90B _text           ends
.text:0000A90B
.text:0000A90C ; ===========================================================================
.text:0000A90C
.text:0000A90C ; Segment type: Pure code
.text:0000A90C ; Segment permissions: Read/Execute
.text:0000A90C _text           segment para public 'CODE' use32
.text:0000A90C                 assume cs:_text
.text:0000A90C                 ;org 0A90Ch
.text:0000A90C ; COMDAT (pick any)
.text:0000A90C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A90C
.text:0000A90C ; =============== S U B R O U T I N E =======================================
.text:0000A90C
.text:0000A90C ; Attributes: bp-based frame
.text:0000A90C
.text:0000A90C ; public: __thiscall CMyComPtr<struct IArchiveExtractCallbackMessage>::CMyComPtr<struct IArchiveExtractCallbackMessage>(void)
.text:0000A90C                 public ??0?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAE@XZ
.text:0000A90C ??0?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAE@XZ proc near
.text:0000A90C                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+D5p
.text:0000A90C
.text:0000A90C var_4           = dword ptr -4
.text:0000A90C
.text:0000A90C                 push    ebp
.text:0000A90D                 mov     ebp, esp
.text:0000A90F                 push    ecx
.text:0000A910                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A917                 mov     [ebp+var_4], ecx
.text:0000A91A                 mov     eax, [ebp+var_4]
.text:0000A91D                 mov     dword ptr [eax], 0
.text:0000A923                 mov     eax, [ebp+var_4]
.text:0000A926                 mov     esp, ebp
.text:0000A928                 pop     ebp
.text:0000A929                 retn
.text:0000A929 ??0?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAE@XZ endp
.text:0000A929
.text:0000A929 ; ---------------------------------------------------------------------------
.text:0000A92A                 align 4
.text:0000A92A _text           ends
.text:0000A92A
.text:0000A92C ; ===========================================================================
.text:0000A92C
.text:0000A92C ; Segment type: Pure code
.text:0000A92C ; Segment permissions: Read/Execute
.text:0000A92C _text           segment para public 'CODE' use32
.text:0000A92C                 assume cs:_text
.text:0000A92C                 ;org 0A92Ch
.text:0000A92C ; COMDAT (pick any)
.text:0000A92C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A92C
.text:0000A92C ; =============== S U B R O U T I N E =======================================
.text:0000A92C
.text:0000A92C ; Attributes: bp-based frame
.text:0000A92C
.text:0000A92C ; public: __thiscall CMyComPtr<struct IArchiveExtractCallbackMessage>::~CMyComPtr<struct IArchiveExtractCallbackMessage>(void)
.text:0000A92C                 public ??1?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAE@XZ
.text:0000A92C ??1?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAE@XZ proc near
.text:0000A92C                                         ; CODE XREF: __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$3+6j
.text:0000A92C                                         ; CArchiveExtractCallback::~CArchiveExtractCallback(void)+136p ...
.text:0000A92C
.text:0000A92C var_4           = dword ptr -4
.text:0000A92C
.text:0000A92C                 push    ebp
.text:0000A92D                 mov     ebp, esp
.text:0000A92F                 push    ecx
.text:0000A930                 push    esi
.text:0000A931                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A938                 mov     [ebp+var_4], ecx
.text:0000A93B                 mov     eax, [ebp+var_4]
.text:0000A93E                 cmp     dword ptr [eax], 0
.text:0000A941                 jz      short loc_A95E
.text:0000A943                 mov     ecx, [ebp+var_4]
.text:0000A946                 mov     edx, [ecx]
.text:0000A948                 mov     eax, [ebp+var_4]
.text:0000A94B                 mov     ecx, [eax]
.text:0000A94D                 mov     edx, [edx]
.text:0000A94F                 mov     esi, esp
.text:0000A951                 push    ecx
.text:0000A952                 mov     eax, [edx+8]
.text:0000A955                 call    eax
.text:0000A957                 cmp     esi, esp
.text:0000A959                 call    __RTC_CheckEsp
.text:0000A95E
.text:0000A95E loc_A95E:                               ; CODE XREF: CMyComPtr<IArchiveExtractCallbackMessage>::~CMyComPtr<IArchiveExtractCallbackMessage>(void)+15j
.text:0000A95E                 pop     esi
.text:0000A95F                 add     esp, 4
.text:0000A962                 cmp     ebp, esp
.text:0000A964                 call    __RTC_CheckEsp
.text:0000A969                 mov     esp, ebp
.text:0000A96B                 pop     ebp
.text:0000A96C                 retn
.text:0000A96C ??1?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAE@XZ endp
.text:0000A96C
.text:0000A96C ; ---------------------------------------------------------------------------
.text:0000A96D                 align 10h
.text:0000A96D _text           ends
.text:0000A96D
.text:0000A970 ; ===========================================================================
.text:0000A970
.text:0000A970 ; Segment type: Pure code
.text:0000A970 ; Segment permissions: Read/Execute
.text:0000A970 _text           segment para public 'CODE' use32
.text:0000A970                 assume cs:_text
.text:0000A970                 ;org 0A970h
.text:0000A970 ; COMDAT (pick any)
.text:0000A970                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A970
.text:0000A970 ; =============== S U B R O U T I N E =======================================
.text:0000A970
.text:0000A970 ; Attributes: bp-based frame
.text:0000A970
.text:0000A970 ; public: struct IArchiveExtractCallbackMessage * * __thiscall CMyComPtr<struct IArchiveExtractCallbackMessage>::operator&(void)
.text:0000A970                 public ??I?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAEPAPAUIArchiveExtractCallbackMessage@@XZ
.text:0000A970 ??I?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAEPAPAUIArchiveExtractCallbackMessage@@XZ proc near
.text:0000A970                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+10Bp
.text:0000A970
.text:0000A970 var_4           = dword ptr -4
.text:0000A970
.text:0000A970                 push    ebp
.text:0000A971                 mov     ebp, esp
.text:0000A973                 push    ecx
.text:0000A974                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A97B                 mov     [ebp+var_4], ecx
.text:0000A97E                 mov     eax, [ebp+var_4]
.text:0000A981                 mov     esp, ebp
.text:0000A983                 pop     ebp
.text:0000A984                 retn
.text:0000A984 ??I?$CMyComPtr@UIArchiveExtractCallbackMessage@@@@QAEPAPAUIArchiveExtractCallbackMessage@@XZ endp
.text:0000A984
.text:0000A984 ; ---------------------------------------------------------------------------
.text:0000A985                 align 4
.text:0000A985 _text           ends
.text:0000A985
.text:0000A988 ; ===========================================================================
.text:0000A988
.text:0000A988 ; Segment type: Pure code
.text:0000A988 ; Segment permissions: Read/Execute
.text:0000A988 _text           segment para public 'CODE' use32
.text:0000A988                 assume cs:_text
.text:0000A988                 ;org 0A988h
.text:0000A988 ; COMDAT (pick any)
.text:0000A988                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A988
.text:0000A988 ; =============== S U B R O U T I N E =======================================
.text:0000A988
.text:0000A988 ; Attributes: bp-based frame
.text:0000A988
.text:0000A988 ; public: __thiscall CMyComPtr<struct IFolderArchiveExtractCallback2>::CMyComPtr<struct IFolderArchiveExtractCallback2>(void)
.text:0000A988                 public ??0?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAE@XZ
.text:0000A988 ??0?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAE@XZ proc near
.text:0000A988                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+E4p
.text:0000A988
.text:0000A988 var_4           = dword ptr -4
.text:0000A988
.text:0000A988                 push    ebp
.text:0000A989                 mov     ebp, esp
.text:0000A98B                 push    ecx
.text:0000A98C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A993                 mov     [ebp+var_4], ecx
.text:0000A996                 mov     eax, [ebp+var_4]
.text:0000A999                 mov     dword ptr [eax], 0
.text:0000A99F                 mov     eax, [ebp+var_4]
.text:0000A9A2                 mov     esp, ebp
.text:0000A9A4                 pop     ebp
.text:0000A9A5                 retn
.text:0000A9A5 ??0?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAE@XZ endp
.text:0000A9A5
.text:0000A9A5 ; ---------------------------------------------------------------------------
.text:0000A9A6                 align 4
.text:0000A9A6 _text           ends
.text:0000A9A6
.text:0000A9A8 ; ===========================================================================
.text:0000A9A8
.text:0000A9A8 ; Segment type: Pure code
.text:0000A9A8 ; Segment permissions: Read/Execute
.text:0000A9A8 _text           segment para public 'CODE' use32
.text:0000A9A8                 assume cs:_text
.text:0000A9A8                 ;org 0A9A8h
.text:0000A9A8 ; COMDAT (pick any)
.text:0000A9A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A9A8
.text:0000A9A8 ; =============== S U B R O U T I N E =======================================
.text:0000A9A8
.text:0000A9A8 ; Attributes: bp-based frame
.text:0000A9A8
.text:0000A9A8 ; public: __thiscall CMyComPtr<struct IFolderArchiveExtractCallback2>::~CMyComPtr<struct IFolderArchiveExtractCallback2>(void)
.text:0000A9A8                 public ??1?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAE@XZ
.text:0000A9A8 ??1?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAE@XZ proc near
.text:0000A9A8                                         ; CODE XREF: __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$4+6j
.text:0000A9A8                                         ; CArchiveExtractCallback::~CArchiveExtractCallback(void)+127p ...
.text:0000A9A8
.text:0000A9A8 var_4           = dword ptr -4
.text:0000A9A8
.text:0000A9A8                 push    ebp
.text:0000A9A9                 mov     ebp, esp
.text:0000A9AB                 push    ecx
.text:0000A9AC                 push    esi
.text:0000A9AD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A9B4                 mov     [ebp+var_4], ecx
.text:0000A9B7                 mov     eax, [ebp+var_4]
.text:0000A9BA                 cmp     dword ptr [eax], 0
.text:0000A9BD                 jz      short loc_A9DA
.text:0000A9BF                 mov     ecx, [ebp+var_4]
.text:0000A9C2                 mov     edx, [ecx]
.text:0000A9C4                 mov     eax, [ebp+var_4]
.text:0000A9C7                 mov     ecx, [eax]
.text:0000A9C9                 mov     edx, [edx]
.text:0000A9CB                 mov     esi, esp
.text:0000A9CD                 push    ecx
.text:0000A9CE                 mov     eax, [edx+8]
.text:0000A9D1                 call    eax
.text:0000A9D3                 cmp     esi, esp
.text:0000A9D5                 call    __RTC_CheckEsp
.text:0000A9DA
.text:0000A9DA loc_A9DA:                               ; CODE XREF: CMyComPtr<IFolderArchiveExtractCallback2>::~CMyComPtr<IFolderArchiveExtractCallback2>(void)+15j
.text:0000A9DA                 pop     esi
.text:0000A9DB                 add     esp, 4
.text:0000A9DE                 cmp     ebp, esp
.text:0000A9E0                 call    __RTC_CheckEsp
.text:0000A9E5                 mov     esp, ebp
.text:0000A9E7                 pop     ebp
.text:0000A9E8                 retn
.text:0000A9E8 ??1?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAE@XZ endp
.text:0000A9E8
.text:0000A9E8 ; ---------------------------------------------------------------------------
.text:0000A9E9                 align 4
.text:0000A9E9 _text           ends
.text:0000A9E9
.text:0000A9EC ; ===========================================================================
.text:0000A9EC
.text:0000A9EC ; Segment type: Pure code
.text:0000A9EC ; Segment permissions: Read/Execute
.text:0000A9EC _text           segment para public 'CODE' use32
.text:0000A9EC                 assume cs:_text
.text:0000A9EC                 ;org 0A9ECh
.text:0000A9EC ; COMDAT (pick any)
.text:0000A9EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A9EC
.text:0000A9EC ; =============== S U B R O U T I N E =======================================
.text:0000A9EC
.text:0000A9EC ; Attributes: bp-based frame
.text:0000A9EC
.text:0000A9EC ; public: __thiscall CMyComPtr<struct IFolderArchiveExtractCallback2>::operator struct IFolderArchiveExtractCallback2 *(void)const
.text:0000A9EC                 public ??B?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QBEPAUIFolderArchiveExtractCallback2@@XZ
.text:0000A9EC ??B?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QBEPAUIFolderArchiveExtractCallback2@@XZ proc near
.text:0000A9EC                                         ; CODE XREF: CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+2Dp
.text:0000A9EC
.text:0000A9EC var_4           = dword ptr -4
.text:0000A9EC
.text:0000A9EC                 push    ebp
.text:0000A9ED                 mov     ebp, esp
.text:0000A9EF                 push    ecx
.text:0000A9F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A9F7                 mov     [ebp+var_4], ecx
.text:0000A9FA                 mov     eax, [ebp+var_4]
.text:0000A9FD                 mov     eax, [eax]
.text:0000A9FF                 mov     esp, ebp
.text:0000AA01                 pop     ebp
.text:0000AA02                 retn
.text:0000AA02 ??B?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QBEPAUIFolderArchiveExtractCallback2@@XZ endp
.text:0000AA02
.text:0000AA02 ; ---------------------------------------------------------------------------
.text:0000AA03                 align 4
.text:0000AA03 _text           ends
.text:0000AA03
.text:0000AA04 ; ===========================================================================
.text:0000AA04
.text:0000AA04 ; Segment type: Pure code
.text:0000AA04 ; Segment permissions: Read/Execute
.text:0000AA04 _text           segment para public 'CODE' use32
.text:0000AA04                 assume cs:_text
.text:0000AA04                 ;org 0AA04h
.text:0000AA04 ; COMDAT (pick any)
.text:0000AA04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AA04
.text:0000AA04 ; =============== S U B R O U T I N E =======================================
.text:0000AA04
.text:0000AA04 ; Attributes: bp-based frame
.text:0000AA04
.text:0000AA04 ; public: struct IFolderArchiveExtractCallback2 * * __thiscall CMyComPtr<struct IFolderArchiveExtractCallback2>::operator&(void)
.text:0000AA04                 public ??I?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAEPAPAUIFolderArchiveExtractCallback2@@XZ
.text:0000AA04 ??I?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAEPAPAUIFolderArchiveExtractCallback2@@XZ proc near
.text:0000AA04                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+127p
.text:0000AA04
.text:0000AA04 var_4           = dword ptr -4
.text:0000AA04
.text:0000AA04                 push    ebp
.text:0000AA05                 mov     ebp, esp
.text:0000AA07                 push    ecx
.text:0000AA08                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AA0F                 mov     [ebp+var_4], ecx
.text:0000AA12                 mov     eax, [ebp+var_4]
.text:0000AA15                 mov     esp, ebp
.text:0000AA17                 pop     ebp
.text:0000AA18                 retn
.text:0000AA18 ??I?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QAEPAPAUIFolderArchiveExtractCallback2@@XZ endp
.text:0000AA18
.text:0000AA18 ; ---------------------------------------------------------------------------
.text:0000AA19                 align 4
.text:0000AA19 _text           ends
.text:0000AA19
.text:0000AA1C ; ===========================================================================
.text:0000AA1C
.text:0000AA1C ; Segment type: Pure code
.text:0000AA1C ; Segment permissions: Read/Execute
.text:0000AA1C _text           segment para public 'CODE' use32
.text:0000AA1C                 assume cs:_text
.text:0000AA1C                 ;org 0AA1Ch
.text:0000AA1C ; COMDAT (pick any)
.text:0000AA1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AA1C
.text:0000AA1C ; =============== S U B R O U T I N E =======================================
.text:0000AA1C
.text:0000AA1C ; Attributes: bp-based frame
.text:0000AA1C
.text:0000AA1C ; public: struct IFolderArchiveExtractCallback2 * __thiscall CMyComPtr<struct IFolderArchiveExtractCallback2>::operator->(void)const
.text:0000AA1C                 public ??C?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QBEPAUIFolderArchiveExtractCallback2@@XZ
.text:0000AA1C ??C?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QBEPAUIFolderArchiveExtractCallback2@@XZ proc near
.text:0000AA1C                                         ; CODE XREF: CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+155p
.text:0000AA1C
.text:0000AA1C var_4           = dword ptr -4
.text:0000AA1C
.text:0000AA1C                 push    ebp
.text:0000AA1D                 mov     ebp, esp
.text:0000AA1F                 push    ecx
.text:0000AA20                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AA27                 mov     [ebp+var_4], ecx
.text:0000AA2A                 mov     eax, [ebp+var_4]
.text:0000AA2D                 mov     eax, [eax]
.text:0000AA2F                 mov     esp, ebp
.text:0000AA31                 pop     ebp
.text:0000AA32                 retn
.text:0000AA32 ??C?$CMyComPtr@UIFolderArchiveExtractCallback2@@@@QBEPAUIFolderArchiveExtractCallback2@@XZ endp
.text:0000AA32
.text:0000AA32 ; ---------------------------------------------------------------------------
.text:0000AA33                 align 4
.text:0000AA33 _text           ends
.text:0000AA33
.text:0000AA34 ; ===========================================================================
.text:0000AA34
.text:0000AA34 ; Segment type: Pure code
.text:0000AA34 ; Segment permissions: Read/Execute
.text:0000AA34 _text           segment para public 'CODE' use32
.text:0000AA34                 assume cs:_text
.text:0000AA34                 ;org 0AA34h
.text:0000AA34 ; COMDAT (pick any)
.text:0000AA34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AA34
.text:0000AA34 ; =============== S U B R O U T I N E =======================================
.text:0000AA34
.text:0000AA34 ; Attributes: bp-based frame
.text:0000AA34
.text:0000AA34 ; public: __thiscall CMyComPtr<struct IFolderExtractToStreamCallback>::CMyComPtr<struct IFolderExtractToStreamCallback>(void)
.text:0000AA34                 public ??0?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAE@XZ
.text:0000AA34 ??0?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAE@XZ proc near
.text:0000AA34                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+111p
.text:0000AA34
.text:0000AA34 var_4           = dword ptr -4
.text:0000AA34
.text:0000AA34                 push    ebp
.text:0000AA35                 mov     ebp, esp
.text:0000AA37                 push    ecx
.text:0000AA38                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AA3F                 mov     [ebp+var_4], ecx
.text:0000AA42                 mov     eax, [ebp+var_4]
.text:0000AA45                 mov     dword ptr [eax], 0
.text:0000AA4B                 mov     eax, [ebp+var_4]
.text:0000AA4E                 mov     esp, ebp
.text:0000AA50                 pop     ebp
.text:0000AA51                 retn
.text:0000AA51 ??0?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAE@XZ endp
.text:0000AA51
.text:0000AA51 ; ---------------------------------------------------------------------------
.text:0000AA52                 align 4
.text:0000AA52 _text           ends
.text:0000AA52
.text:0000AA54 ; ===========================================================================
.text:0000AA54
.text:0000AA54 ; Segment type: Pure code
.text:0000AA54 ; Segment permissions: Read/Execute
.text:0000AA54 _text           segment para public 'CODE' use32
.text:0000AA54                 assume cs:_text
.text:0000AA54                 ;org 0AA54h
.text:0000AA54 ; COMDAT (pick any)
.text:0000AA54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AA54
.text:0000AA54 ; =============== S U B R O U T I N E =======================================
.text:0000AA54
.text:0000AA54 ; Attributes: bp-based frame
.text:0000AA54
.text:0000AA54 ; public: __thiscall CMyComPtr<struct IFolderExtractToStreamCallback>::~CMyComPtr<struct IFolderExtractToStreamCallback>(void)
.text:0000AA54                 public ??1?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAE@XZ
.text:0000AA54 ??1?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAE@XZ proc near
.text:0000AA54                                         ; CODE XREF: __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$7+6j
.text:0000AA54                                         ; CArchiveExtractCallback::~CArchiveExtractCallback(void)+FAp ...
.text:0000AA54
.text:0000AA54 var_4           = dword ptr -4
.text:0000AA54
.text:0000AA54                 push    ebp
.text:0000AA55                 mov     ebp, esp
.text:0000AA57                 push    ecx
.text:0000AA58                 push    esi
.text:0000AA59                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AA60                 mov     [ebp+var_4], ecx
.text:0000AA63                 mov     eax, [ebp+var_4]
.text:0000AA66                 cmp     dword ptr [eax], 0
.text:0000AA69                 jz      short loc_AA86
.text:0000AA6B                 mov     ecx, [ebp+var_4]
.text:0000AA6E                 mov     edx, [ecx]
.text:0000AA70                 mov     eax, [ebp+var_4]
.text:0000AA73                 mov     ecx, [eax]
.text:0000AA75                 mov     edx, [edx]
.text:0000AA77                 mov     esi, esp
.text:0000AA79                 push    ecx
.text:0000AA7A                 mov     eax, [edx+8]
.text:0000AA7D                 call    eax
.text:0000AA7F                 cmp     esi, esp
.text:0000AA81                 call    __RTC_CheckEsp
.text:0000AA86
.text:0000AA86 loc_AA86:                               ; CODE XREF: CMyComPtr<IFolderExtractToStreamCallback>::~CMyComPtr<IFolderExtractToStreamCallback>(void)+15j
.text:0000AA86                 pop     esi
.text:0000AA87                 add     esp, 4
.text:0000AA8A                 cmp     ebp, esp
.text:0000AA8C                 call    __RTC_CheckEsp
.text:0000AA91                 mov     esp, ebp
.text:0000AA93                 pop     ebp
.text:0000AA94                 retn
.text:0000AA94 ??1?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAE@XZ endp
.text:0000AA94
.text:0000AA94 ; ---------------------------------------------------------------------------
.text:0000AA95                 align 4
.text:0000AA95 _text           ends
.text:0000AA95
.text:0000AA98 ; ===========================================================================
.text:0000AA98
.text:0000AA98 ; Segment type: Pure code
.text:0000AA98 ; Segment permissions: Read/Execute
.text:0000AA98 _text           segment para public 'CODE' use32
.text:0000AA98                 assume cs:_text
.text:0000AA98                 ;org 0AA98h
.text:0000AA98 ; COMDAT (pick any)
.text:0000AA98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AA98
.text:0000AA98 ; =============== S U B R O U T I N E =======================================
.text:0000AA98
.text:0000AA98 ; Attributes: bp-based frame
.text:0000AA98
.text:0000AA98 ; public: void __thiscall CMyComPtr<struct IFolderExtractToStreamCallback>::Release(void)
.text:0000AA98                 public ?Release@?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAEXXZ
.text:0000AA98 ?Release@?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAEXXZ proc near
.text:0000AA98                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+1AFp
.text:0000AA98
.text:0000AA98 var_4           = dword ptr -4
.text:0000AA98
.text:0000AA98                 push    ebp
.text:0000AA99                 mov     ebp, esp
.text:0000AA9B                 push    ecx
.text:0000AA9C                 push    esi
.text:0000AA9D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AAA4                 mov     [ebp+var_4], ecx
.text:0000AAA7                 mov     eax, [ebp+var_4]
.text:0000AAAA                 cmp     dword ptr [eax], 0
.text:0000AAAD                 jz      short loc_AAD3
.text:0000AAAF                 mov     ecx, [ebp+var_4]
.text:0000AAB2                 mov     edx, [ecx]
.text:0000AAB4                 mov     eax, [ebp+var_4]
.text:0000AAB7                 mov     ecx, [eax]
.text:0000AAB9                 mov     edx, [edx]
.text:0000AABB                 mov     esi, esp
.text:0000AABD                 push    ecx
.text:0000AABE                 mov     eax, [edx+8]
.text:0000AAC1                 call    eax
.text:0000AAC3                 cmp     esi, esp
.text:0000AAC5                 call    __RTC_CheckEsp
.text:0000AACA                 mov     ecx, [ebp+var_4]
.text:0000AACD                 mov     dword ptr [ecx], 0
.text:0000AAD3
.text:0000AAD3 loc_AAD3:                               ; CODE XREF: CMyComPtr<IFolderExtractToStreamCallback>::Release(void)+15j
.text:0000AAD3                 pop     esi
.text:0000AAD4                 add     esp, 4
.text:0000AAD7                 cmp     ebp, esp
.text:0000AAD9                 call    __RTC_CheckEsp
.text:0000AADE                 mov     esp, ebp
.text:0000AAE0                 pop     ebp
.text:0000AAE1                 retn
.text:0000AAE1 ?Release@?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAEXXZ endp
.text:0000AAE1
.text:0000AAE1 ; ---------------------------------------------------------------------------
.text:0000AAE2                 align 4
.text:0000AAE2 _text           ends
.text:0000AAE2
.text:0000AAE4 ; ===========================================================================
.text:0000AAE4
.text:0000AAE4 ; Segment type: Pure code
.text:0000AAE4 ; Segment permissions: Read/Execute
.text:0000AAE4 _text           segment para public 'CODE' use32
.text:0000AAE4                 assume cs:_text
.text:0000AAE4                 ;org 0AAE4h
.text:0000AAE4 ; COMDAT (pick any)
.text:0000AAE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AAE4
.text:0000AAE4 ; =============== S U B R O U T I N E =======================================
.text:0000AAE4
.text:0000AAE4 ; Attributes: bp-based frame
.text:0000AAE4
.text:0000AAE4 ; public: __thiscall CMyComPtr<struct IFolderExtractToStreamCallback>::operator struct IFolderExtractToStreamCallback *(void)const
.text:0000AAE4                 public ??B?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ
.text:0000AAE4 ??B?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ proc near
.text:0000AAE4                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+15Fp
.text:0000AAE4                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+D5Fp ...
.text:0000AAE4
.text:0000AAE4 var_4           = dword ptr -4
.text:0000AAE4
.text:0000AAE4                 push    ebp
.text:0000AAE5                 mov     ebp, esp
.text:0000AAE7                 push    ecx
.text:0000AAE8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AAEF                 mov     [ebp+var_4], ecx
.text:0000AAF2                 mov     eax, [ebp+var_4]
.text:0000AAF5                 mov     eax, [eax]
.text:0000AAF7                 mov     esp, ebp
.text:0000AAF9                 pop     ebp
.text:0000AAFA                 retn
.text:0000AAFA ??B?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ endp
.text:0000AAFA
.text:0000AAFA ; ---------------------------------------------------------------------------
.text:0000AAFB                 align 4
.text:0000AAFB _text           ends
.text:0000AAFB
.text:0000AAFC ; ===========================================================================
.text:0000AAFC
.text:0000AAFC ; Segment type: Pure code
.text:0000AAFC ; Segment permissions: Read/Execute
.text:0000AAFC _text           segment para public 'CODE' use32
.text:0000AAFC                 assume cs:_text
.text:0000AAFC                 ;org 0AAFCh
.text:0000AAFC ; COMDAT (pick any)
.text:0000AAFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AAFC
.text:0000AAFC ; =============== S U B R O U T I N E =======================================
.text:0000AAFC
.text:0000AAFC ; Attributes: bp-based frame
.text:0000AAFC
.text:0000AAFC ; public: struct IFolderExtractToStreamCallback * * __thiscall CMyComPtr<struct IFolderExtractToStreamCallback>::operator&(void)
.text:0000AAFC                 public ??I?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAEPAPAUIFolderExtractToStreamCallback@@XZ
.text:0000AAFC ??I?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAEPAPAUIFolderExtractToStreamCallback@@XZ proc near
.text:0000AAFC                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+143p
.text:0000AAFC
.text:0000AAFC var_4           = dword ptr -4
.text:0000AAFC
.text:0000AAFC                 push    ebp
.text:0000AAFD                 mov     ebp, esp
.text:0000AAFF                 push    ecx
.text:0000AB00                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AB07                 mov     [ebp+var_4], ecx
.text:0000AB0A                 mov     eax, [ebp+var_4]
.text:0000AB0D                 mov     esp, ebp
.text:0000AB0F                 pop     ebp
.text:0000AB10                 retn
.text:0000AB10 ??I?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QAEPAPAUIFolderExtractToStreamCallback@@XZ endp
.text:0000AB10
.text:0000AB10 ; ---------------------------------------------------------------------------
.text:0000AB11                 align 4
.text:0000AB11 _text           ends
.text:0000AB11
.text:0000AB14 ; ===========================================================================
.text:0000AB14
.text:0000AB14 ; Segment type: Pure code
.text:0000AB14 ; Segment permissions: Read/Execute
.text:0000AB14 _text           segment para public 'CODE' use32
.text:0000AB14                 assume cs:_text
.text:0000AB14                 ;org 0AB14h
.text:0000AB14 ; COMDAT (pick any)
.text:0000AB14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AB14
.text:0000AB14 ; =============== S U B R O U T I N E =======================================
.text:0000AB14
.text:0000AB14 ; Attributes: bp-based frame
.text:0000AB14
.text:0000AB14 ; public: struct IFolderExtractToStreamCallback * __thiscall CMyComPtr<struct IFolderExtractToStreamCallback>::operator->(void)const
.text:0000AB14                 public ??C?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ
.text:0000AB14 ??C?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ proc near
.text:0000AB14                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+175p
.text:0000AB14                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+EB8p ...
.text:0000AB14
.text:0000AB14 var_4           = dword ptr -4
.text:0000AB14
.text:0000AB14                 push    ebp
.text:0000AB15                 mov     ebp, esp
.text:0000AB17                 push    ecx
.text:0000AB18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AB1F                 mov     [ebp+var_4], ecx
.text:0000AB22                 mov     eax, [ebp+var_4]
.text:0000AB25                 mov     eax, [eax]
.text:0000AB27                 mov     esp, ebp
.text:0000AB29                 pop     ebp
.text:0000AB2A                 retn
.text:0000AB2A ??C?$CMyComPtr@UIFolderExtractToStreamCallback@@@@QBEPAUIFolderExtractToStreamCallback@@XZ endp
.text:0000AB2A
.text:0000AB2A ; ---------------------------------------------------------------------------
.text:0000AB2B                 align 4
.text:0000AB2B _text           ends
.text:0000AB2B
.text:0000AB2C ; ===========================================================================
.text:0000AB2C
.text:0000AB2C ; Segment type: Pure code
.text:0000AB2C ; Segment permissions: Read/Execute
.text:0000AB2C _text           segment para public 'CODE' use32
.text:0000AB2C                 assume cs:_text
.text:0000AB2C                 ;org 0AB2Ch
.text:0000AB2C ; COMDAT (pick any)
.text:0000AB2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AB2C
.text:0000AB2C ; =============== S U B R O U T I N E =======================================
.text:0000AB2C
.text:0000AB2C ; Attributes: bp-based frame
.text:0000AB2C
.text:0000AB2C ; public: __thiscall CMyComPtr<struct IGetProp>::CMyComPtr<struct IGetProp>(void)
.text:0000AB2C                 public ??0?$CMyComPtr@UIGetProp@@@@QAE@XZ
.text:0000AB2C ??0?$CMyComPtr@UIGetProp@@@@QAE@XZ proc near
.text:0000AB2C                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+120p
.text:0000AB2C
.text:0000AB2C var_4           = dword ptr -4
.text:0000AB2C
.text:0000AB2C                 push    ebp
.text:0000AB2D                 mov     ebp, esp
.text:0000AB2F                 push    ecx
.text:0000AB30                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AB37                 mov     [ebp+var_4], ecx
.text:0000AB3A                 mov     eax, [ebp+var_4]
.text:0000AB3D                 mov     dword ptr [eax], 0
.text:0000AB43                 mov     eax, [ebp+var_4]
.text:0000AB46                 mov     esp, ebp
.text:0000AB48                 pop     ebp
.text:0000AB49                 retn
.text:0000AB49 ??0?$CMyComPtr@UIGetProp@@@@QAE@XZ endp
.text:0000AB49
.text:0000AB49 ; ---------------------------------------------------------------------------
.text:0000AB4A                 align 4
.text:0000AB4A _text           ends
.text:0000AB4A
.text:0000AB4C ; ===========================================================================
.text:0000AB4C
.text:0000AB4C ; Segment type: Pure code
.text:0000AB4C ; Segment permissions: Read/Execute
.text:0000AB4C _text           segment para public 'CODE' use32
.text:0000AB4C                 assume cs:_text
.text:0000AB4C                 ;org 0AB4Ch
.text:0000AB4C ; COMDAT (pick any)
.text:0000AB4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AB4C
.text:0000AB4C ; =============== S U B R O U T I N E =======================================
.text:0000AB4C
.text:0000AB4C ; Attributes: bp-based frame
.text:0000AB4C
.text:0000AB4C ; public: __thiscall CMyComPtr<struct IGetProp>::~CMyComPtr<struct IGetProp>(void)
.text:0000AB4C                 public ??1?$CMyComPtr@UIGetProp@@@@QAE@XZ
.text:0000AB4C ??1?$CMyComPtr@UIGetProp@@@@QAE@XZ proc near
.text:0000AB4C                                         ; CODE XREF: __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$8+6j
.text:0000AB4C                                         ; CArchiveExtractCallback::~CArchiveExtractCallback(void)+EBp ...
.text:0000AB4C
.text:0000AB4C var_4           = dword ptr -4
.text:0000AB4C
.text:0000AB4C                 push    ebp
.text:0000AB4D                 mov     ebp, esp
.text:0000AB4F                 push    ecx
.text:0000AB50                 push    esi
.text:0000AB51                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AB58                 mov     [ebp+var_4], ecx
.text:0000AB5B                 mov     eax, [ebp+var_4]
.text:0000AB5E                 cmp     dword ptr [eax], 0
.text:0000AB61                 jz      short loc_AB7E
.text:0000AB63                 mov     ecx, [ebp+var_4]
.text:0000AB66                 mov     edx, [ecx]
.text:0000AB68                 mov     eax, [ebp+var_4]
.text:0000AB6B                 mov     ecx, [eax]
.text:0000AB6D                 mov     edx, [edx]
.text:0000AB6F                 mov     esi, esp
.text:0000AB71                 push    ecx
.text:0000AB72                 mov     eax, [edx+8]
.text:0000AB75                 call    eax
.text:0000AB77                 cmp     esi, esp
.text:0000AB79                 call    __RTC_CheckEsp
.text:0000AB7E
.text:0000AB7E loc_AB7E:                               ; CODE XREF: CMyComPtr<IGetProp>::~CMyComPtr<IGetProp>(void)+15j
.text:0000AB7E                 pop     esi
.text:0000AB7F                 add     esp, 4
.text:0000AB82                 cmp     ebp, esp
.text:0000AB84                 call    __RTC_CheckEsp
.text:0000AB89                 mov     esp, ebp
.text:0000AB8B                 pop     ebp
.text:0000AB8C                 retn
.text:0000AB8C ??1?$CMyComPtr@UIGetProp@@@@QAE@XZ endp
.text:0000AB8C
.text:0000AB8C ; ---------------------------------------------------------------------------
.text:0000AB8D                 align 10h
.text:0000AB8D _text           ends
.text:0000AB8D
.text:0000AB90 ; ===========================================================================
.text:0000AB90
.text:0000AB90 ; Segment type: Pure code
.text:0000AB90 ; Segment permissions: Read/Execute
.text:0000AB90 _text           segment para public 'CODE' use32
.text:0000AB90                 assume cs:_text
.text:0000AB90                 ;org 0AB90h
.text:0000AB90 ; COMDAT (pick any)
.text:0000AB90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AB90
.text:0000AB90 ; =============== S U B R O U T I N E =======================================
.text:0000AB90
.text:0000AB90 ; Attributes: bp-based frame
.text:0000AB90
.text:0000AB90 ; public: __thiscall CMyComPtr<struct IGetProp>::operator struct IGetProp *(void)const
.text:0000AB90                 public ??B?$CMyComPtr@UIGetProp@@@@QBEPAUIGetProp@@XZ
.text:0000AB90 ??B?$CMyComPtr@UIGetProp@@@@QBEPAUIGetProp@@XZ proc near
.text:0000AB90                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+ED5p
.text:0000AB90
.text:0000AB90 var_4           = dword ptr -4
.text:0000AB90
.text:0000AB90                 push    ebp
.text:0000AB91                 mov     ebp, esp
.text:0000AB93                 push    ecx
.text:0000AB94                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AB9B                 mov     [ebp+var_4], ecx
.text:0000AB9E                 mov     eax, [ebp+var_4]
.text:0000ABA1                 mov     eax, [eax]
.text:0000ABA3                 mov     esp, ebp
.text:0000ABA5                 pop     ebp
.text:0000ABA6                 retn
.text:0000ABA6 ??B?$CMyComPtr@UIGetProp@@@@QBEPAUIGetProp@@XZ endp
.text:0000ABA6
.text:0000ABA6 ; ---------------------------------------------------------------------------
.text:0000ABA7                 align 4
.text:0000ABA7 _text           ends
.text:0000ABA7
.text:0000ABA8 ; ===========================================================================
.text:0000ABA8
.text:0000ABA8 ; Segment type: Pure code
.text:0000ABA8 ; Segment permissions: Read/Execute
.text:0000ABA8 _text           segment para public 'CODE' use32
.text:0000ABA8                 assume cs:_text
.text:0000ABA8                 ;org 0ABA8h
.text:0000ABA8 ; COMDAT (pick any)
.text:0000ABA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000ABA8
.text:0000ABA8 ; =============== S U B R O U T I N E =======================================
.text:0000ABA8
.text:0000ABA8 ; Attributes: bp-based frame
.text:0000ABA8
.text:0000ABA8 ; public: struct IGetProp * __thiscall CMyComPtr<struct IGetProp>::operator=(struct IGetProp *)
.text:0000ABA8                 public ??4?$CMyComPtr@UIGetProp@@@@QAEPAUIGetProp@@PAU1@@Z
.text:0000ABA8 ??4?$CMyComPtr@UIGetProp@@@@QAEPAUIGetProp@@PAU1@@Z proc near
.text:0000ABA8                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+E12p
.text:0000ABA8
.text:0000ABA8 var_4           = dword ptr -4
.text:0000ABA8 arg_0           = dword ptr  8
.text:0000ABA8
.text:0000ABA8                 push    ebp
.text:0000ABA9                 mov     ebp, esp
.text:0000ABAB                 push    ecx
.text:0000ABAC                 push    esi
.text:0000ABAD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000ABB4                 mov     [ebp+var_4], ecx
.text:0000ABB7                 cmp     [ebp+arg_0], 0
.text:0000ABBB                 jz      short loc_ABD4
.text:0000ABBD                 mov     eax, [ebp+arg_0]
.text:0000ABC0                 mov     ecx, [eax]
.text:0000ABC2                 mov     esi, esp
.text:0000ABC4                 mov     edx, [ebp+arg_0]
.text:0000ABC7                 push    edx
.text:0000ABC8                 mov     eax, [ecx+4]
.text:0000ABCB                 call    eax
.text:0000ABCD                 cmp     esi, esp
.text:0000ABCF                 call    __RTC_CheckEsp
.text:0000ABD4
.text:0000ABD4 loc_ABD4:                               ; CODE XREF: CMyComPtr<IGetProp>::operator=(IGetProp *)+13j
.text:0000ABD4                 mov     ecx, [ebp+var_4]
.text:0000ABD7                 cmp     dword ptr [ecx], 0
.text:0000ABDA                 jz      short loc_ABF7
.text:0000ABDC                 mov     edx, [ebp+var_4]
.text:0000ABDF                 mov     eax, [edx]
.text:0000ABE1                 mov     ecx, [ebp+var_4]
.text:0000ABE4                 mov     edx, [ecx]
.text:0000ABE6                 mov     eax, [eax]
.text:0000ABE8                 mov     esi, esp
.text:0000ABEA                 push    edx
.text:0000ABEB                 mov     ecx, [eax+8]
.text:0000ABEE                 call    ecx
.text:0000ABF0                 cmp     esi, esp
.text:0000ABF2                 call    __RTC_CheckEsp
.text:0000ABF7
.text:0000ABF7 loc_ABF7:                               ; CODE XREF: CMyComPtr<IGetProp>::operator=(IGetProp *)+32j
.text:0000ABF7                 mov     edx, [ebp+var_4]
.text:0000ABFA                 mov     eax, [ebp+arg_0]
.text:0000ABFD                 mov     [edx], eax
.text:0000ABFF                 mov     eax, [ebp+arg_0]
.text:0000AC02                 pop     esi
.text:0000AC03                 add     esp, 4
.text:0000AC06                 cmp     ebp, esp
.text:0000AC08                 call    __RTC_CheckEsp
.text:0000AC0D                 mov     esp, ebp
.text:0000AC0F                 pop     ebp
.text:0000AC10                 retn    4
.text:0000AC10 ??4?$CMyComPtr@UIGetProp@@@@QAEPAUIGetProp@@PAU1@@Z endp
.text:0000AC10
.text:0000AC10 ; ---------------------------------------------------------------------------
.text:0000AC13                 align 4
.text:0000AC13 _text           ends
.text:0000AC13
.text:0000AC14 ; ===========================================================================
.text:0000AC14
.text:0000AC14 ; Segment type: Pure code
.text:0000AC14 ; Segment permissions: Read/Execute
.text:0000AC14 _text           segment para public 'CODE' use32
.text:0000AC14                 assume cs:_text
.text:0000AC14                 ;org 0AC14h
.text:0000AC14 ; COMDAT (pick any)
.text:0000AC14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AC14
.text:0000AC14 ; =============== S U B R O U T I N E =======================================
.text:0000AC14
.text:0000AC14 ; Attributes: bp-based frame
.text:0000AC14
.text:0000AC14 ; public: bool __thiscall CMyComPtr<struct IGetProp>::operator!(void)const
.text:0000AC14                 public ??7?$CMyComPtr@UIGetProp@@@@QBE_NXZ
.text:0000AC14 ??7?$CMyComPtr@UIGetProp@@@@QBE_NXZ proc near
.text:0000AC14                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+D7Dp
.text:0000AC14
.text:0000AC14 var_4           = dword ptr -4
.text:0000AC14
.text:0000AC14                 push    ebp
.text:0000AC15                 mov     ebp, esp
.text:0000AC17                 push    ecx
.text:0000AC18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AC1F                 mov     [ebp+var_4], ecx
.text:0000AC22                 mov     eax, [ebp+var_4]
.text:0000AC25                 xor     ecx, ecx
.text:0000AC27                 cmp     dword ptr [eax], 0
.text:0000AC2A                 setz    cl
.text:0000AC2D                 mov     al, cl
.text:0000AC2F                 mov     esp, ebp
.text:0000AC31                 pop     ebp
.text:0000AC32                 retn
.text:0000AC32 ??7?$CMyComPtr@UIGetProp@@@@QBE_NXZ endp
.text:0000AC32
.text:0000AC32 ; ---------------------------------------------------------------------------
.text:0000AC33                 align 4
.text:0000AC33 _text           ends
.text:0000AC33
.text:0000AC34 ; ===========================================================================
.text:0000AC34
.text:0000AC34 ; Segment type: Pure code
.text:0000AC34 ; Segment permissions: Read/Execute
.text:0000AC34 _text           segment para public 'CODE' use32
.text:0000AC34                 assume cs:_text
.text:0000AC34                 ;org 0AC34h
.text:0000AC34 ; COMDAT (pick any)
.text:0000AC34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AC34
.text:0000AC34 ; =============== S U B R O U T I N E =======================================
.text:0000AC34
.text:0000AC34 ; Attributes: bp-based frame
.text:0000AC34
.text:0000AC34 ; public: unsigned int __thiscall CObjectVector<struct CIndexToPathPair>::Size(void)const
.text:0000AC34                 public ?Size@?$CObjectVector@UCIndexToPathPair@@@@QBEIXZ
.text:0000AC34 ?Size@?$CObjectVector@UCIndexToPathPair@@@@QBEIXZ proc near
.text:0000AC34                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+30CEp
.text:0000AC34                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3115p ...
.text:0000AC34
.text:0000AC34 var_4           = dword ptr -4
.text:0000AC34
.text:0000AC34                 push    ebp
.text:0000AC35                 mov     ebp, esp
.text:0000AC37                 push    ecx
.text:0000AC38                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AC3F                 mov     [ebp+var_4], ecx
.text:0000AC42                 mov     ecx, [ebp+var_4]
.text:0000AC45                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000AC4A                 add     esp, 4
.text:0000AC4D                 cmp     ebp, esp
.text:0000AC4F                 call    __RTC_CheckEsp
.text:0000AC54                 mov     esp, ebp
.text:0000AC56                 pop     ebp
.text:0000AC57                 retn
.text:0000AC57 ?Size@?$CObjectVector@UCIndexToPathPair@@@@QBEIXZ endp
.text:0000AC57
.text:0000AC57 _text           ends
.text:0000AC57
.text:0000AC58 ; ===========================================================================
.text:0000AC58
.text:0000AC58 ; Segment type: Pure code
.text:0000AC58 ; Segment permissions: Read/Execute
.text:0000AC58 _text           segment para public 'CODE' use32
.text:0000AC58                 assume cs:_text
.text:0000AC58                 ;org 0AC58h
.text:0000AC58 ; COMDAT (pick any)
.text:0000AC58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AC58
.text:0000AC58 ; =============== S U B R O U T I N E =======================================
.text:0000AC58
.text:0000AC58 ; Attributes: bp-based frame
.text:0000AC58
.text:0000AC58 ; public: __thiscall CObjectVector<struct CIndexToPathPair>::CObjectVector<struct CIndexToPathPair>(void)
.text:0000AC58                 public ??0?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ
.text:0000AC58 ??0?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ proc near
.text:0000AC58                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+1F9p
.text:0000AC58
.text:0000AC58 var_4           = dword ptr -4
.text:0000AC58
.text:0000AC58                 push    ebp
.text:0000AC59                 mov     ebp, esp
.text:0000AC5B                 push    ecx
.text:0000AC5C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AC63                 mov     [ebp+var_4], ecx
.text:0000AC66                 mov     ecx, [ebp+var_4]
.text:0000AC69                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000AC6E                 mov     eax, [ebp+var_4]
.text:0000AC71                 add     esp, 4
.text:0000AC74                 cmp     ebp, esp
.text:0000AC76                 call    __RTC_CheckEsp
.text:0000AC7B                 mov     esp, ebp
.text:0000AC7D                 pop     ebp
.text:0000AC7E                 retn
.text:0000AC7E ??0?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ endp
.text:0000AC7E
.text:0000AC7E ; ---------------------------------------------------------------------------
.text:0000AC7F                 align 10h
.text:0000AC7F _text           ends
.text:0000AC7F
.text:0000AC80 ; ===========================================================================
.text:0000AC80
.text:0000AC80 ; Segment type: Pure code
.text:0000AC80 ; Segment permissions: Read/Execute
.text:0000AC80 _text           segment para public 'CODE' use32
.text:0000AC80                 assume cs:_text
.text:0000AC80                 ;org 0AC80h
.text:0000AC80 ; COMDAT (pick any)
.text:0000AC80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AC80
.text:0000AC80 ; =============== S U B R O U T I N E =======================================
.text:0000AC80
.text:0000AC80 ; Attributes: bp-based frame
.text:0000AC80
.text:0000AC80 ; public: struct CIndexToPathPair & __thiscall CObjectVector<struct CIndexToPathPair>::operator[](unsigned int)
.text:0000AC80                 public ??A?$CObjectVector@UCIndexToPathPair@@@@QAEAAUCIndexToPathPair@@I@Z
.text:0000AC80 ??A?$CObjectVector@UCIndexToPathPair@@@@QAEAAUCIndexToPathPair@@I@Z proc near
.text:0000AC80                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+17A9p
.text:0000AC80                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+313Ep ...
.text:0000AC80
.text:0000AC80 var_4           = dword ptr -4
.text:0000AC80 arg_0           = dword ptr  8
.text:0000AC80
.text:0000AC80                 push    ebp
.text:0000AC81                 mov     ebp, esp
.text:0000AC83                 push    ecx
.text:0000AC84                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AC8B                 mov     [ebp+var_4], ecx
.text:0000AC8E                 mov     eax, [ebp+arg_0]
.text:0000AC91                 push    eax
.text:0000AC92                 mov     ecx, [ebp+var_4]
.text:0000AC95                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000AC9A                 mov     eax, [eax]
.text:0000AC9C                 add     esp, 4
.text:0000AC9F                 cmp     ebp, esp
.text:0000ACA1                 call    __RTC_CheckEsp
.text:0000ACA6                 mov     esp, ebp
.text:0000ACA8                 pop     ebp
.text:0000ACA9                 retn    4
.text:0000ACA9 ??A?$CObjectVector@UCIndexToPathPair@@@@QAEAAUCIndexToPathPair@@I@Z endp
.text:0000ACA9
.text:0000ACA9 _text           ends
.text:0000ACA9
.text:0000ACAC ; ===========================================================================
.text:0000ACAC
.text:0000ACAC ; Segment type: Pure code
.text:0000ACAC ; Segment permissions: Read/Execute
.text:0000ACAC _text           segment para public 'CODE' use32
.text:0000ACAC                 assume cs:_text
.text:0000ACAC                 ;org 0ACACh
.text:0000ACAC ; COMDAT (pick any)
.text:0000ACAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000ACAC
.text:0000ACAC ; =============== S U B R O U T I N E =======================================
.text:0000ACAC
.text:0000ACAC ; Attributes: bp-based frame
.text:0000ACAC
.text:0000ACAC ; public: __thiscall CObjectVector<struct CIndexToPathPair>::~CObjectVector<struct CIndexToPathPair>(void)
.text:0000ACAC                 public ??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ
.text:0000ACAC ??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ proc near
.text:0000ACAC                                         ; CODE XREF: __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$18+9j
.text:0000ACAC                                         ; CArchiveExtractCallback::~CArchiveExtractCallback(void)+3Dp
.text:0000ACAC
.text:0000ACAC var_20          = dword ptr -20h
.text:0000ACAC var_1C          = dword ptr -1Ch
.text:0000ACAC var_18          = dword ptr -18h
.text:0000ACAC var_14          = dword ptr -14h
.text:0000ACAC var_10          = dword ptr -10h
.text:0000ACAC var_C           = dword ptr -0Ch
.text:0000ACAC var_4           = dword ptr -4
.text:0000ACAC
.text:0000ACAC                 push    ebp
.text:0000ACAD                 mov     ebp, esp
.text:0000ACAF                 push    0FFFFFFFFh
.text:0000ACB1                 push    offset __ehhandler$??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ
.text:0000ACB6                 mov     eax, large fs:0
.text:0000ACBC                 push    eax
.text:0000ACBD                 sub     esp, 14h
.text:0000ACC0                 mov     eax, 0CCCCCCCCh
.text:0000ACC5                 mov     [ebp+var_20], eax
.text:0000ACC8                 mov     [ebp+var_1C], eax
.text:0000ACCB                 mov     [ebp+var_18], eax
.text:0000ACCE                 mov     [ebp+var_14], eax
.text:0000ACD1                 mov     [ebp+var_10], eax
.text:0000ACD4                 mov     eax, dword ptr ds:___security_cookie
.text:0000ACD9                 xor     eax, ebp
.text:0000ACDB                 push    eax
.text:0000ACDC                 lea     eax, [ebp+var_C]
.text:0000ACDF                 mov     large fs:0, eax
.text:0000ACE5                 mov     [ebp+var_10], ecx
.text:0000ACE8                 mov     [ebp+var_4], 0
.text:0000ACEF                 mov     ecx, [ebp+var_10]
.text:0000ACF2                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000ACF7                 mov     [ebp+var_14], eax
.text:0000ACFA
.text:0000ACFA loc_ACFA:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::~CObjectVector<CIndexToPathPair>(void):loc_AD3Cj
.text:0000ACFA                 cmp     [ebp+var_14], 0
.text:0000ACFE                 jz      short loc_AD3E
.text:0000AD00                 mov     eax, [ebp+var_14]
.text:0000AD03                 sub     eax, 1
.text:0000AD06                 mov     [ebp+var_14], eax
.text:0000AD09                 mov     ecx, [ebp+var_14]
.text:0000AD0C                 push    ecx
.text:0000AD0D                 mov     ecx, [ebp+var_10]
.text:0000AD10                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000AD15                 mov     edx, [eax]
.text:0000AD17                 mov     [ebp+var_1C], edx
.text:0000AD1A                 mov     eax, [ebp+var_1C]
.text:0000AD1D                 mov     [ebp+var_18], eax
.text:0000AD20                 cmp     [ebp+var_18], 0
.text:0000AD24                 jz      short loc_AD35
.text:0000AD26                 push    1
.text:0000AD28                 mov     ecx, [ebp+var_18]
.text:0000AD2B                 call    ??_GCIndexToPathPair@@QAEPAXI@Z ; CIndexToPathPair::`scalar deleting destructor'(uint)
.text:0000AD30                 mov     [ebp+var_20], eax
.text:0000AD33                 jmp     short loc_AD3C
.text:0000AD35 ; ---------------------------------------------------------------------------
.text:0000AD35
.text:0000AD35 loc_AD35:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::~CObjectVector<CIndexToPathPair>(void)+78j
.text:0000AD35                 mov     [ebp+var_20], 0
.text:0000AD3C
.text:0000AD3C loc_AD3C:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::~CObjectVector<CIndexToPathPair>(void)+87j
.text:0000AD3C                 jmp     short loc_ACFA
.text:0000AD3E ; ---------------------------------------------------------------------------
.text:0000AD3E
.text:0000AD3E loc_AD3E:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::~CObjectVector<CIndexToPathPair>(void)+52j
.text:0000AD3E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000AD45                 mov     ecx, [ebp+var_10]
.text:0000AD48                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000AD4D                 mov     ecx, [ebp+var_C]
.text:0000AD50                 mov     large fs:0, ecx
.text:0000AD57                 pop     ecx
.text:0000AD58                 add     esp, 20h
.text:0000AD5B                 cmp     ebp, esp
.text:0000AD5D                 call    __RTC_CheckEsp
.text:0000AD62                 mov     esp, ebp
.text:0000AD64                 pop     ebp
.text:0000AD65                 retn
.text:0000AD65 ??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ endp
.text:0000AD65
.text:0000AD65 ; ---------------------------------------------------------------------------
.text:0000AD66                 align 4
.text:0000AD66 _text           ends
.text:0000AD66
.text$x:0000AD68 ; ===========================================================================
.text$x:0000AD68
.text$x:0000AD68 ; Segment type: Pure code
.text$x:0000AD68 ; Segment permissions: Read/Execute
.text$x:0000AD68 _text$x         segment para public 'CODE' use32
.text$x:0000AD68                 assume cs:_text$x
.text$x:0000AD68                 ;org 0AD68h
.text$x:0000AD68 ; COMDAT (pick associative to section at ACAC)
.text$x:0000AD68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AD68
.text$x:0000AD68 ; =============== S U B R O U T I N E =======================================
.text$x:0000AD68
.text$x:0000AD68
.text$x:0000AD68 __unwindfunclet$??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ$0 proc near
.text$x:0000AD68                                         ; DATA XREF: .xdata$x:0000AD90o
.text$x:0000AD68                 mov     ecx, [ebp-10h]
.text$x:0000AD6B                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000AD6B __unwindfunclet$??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ$0 endp
.text$x:0000AD6B
.text$x:0000AD70
.text$x:0000AD70 ; =============== S U B R O U T I N E =======================================
.text$x:0000AD70
.text$x:0000AD70
.text$x:0000AD70 __ehhandler$??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ proc near
.text$x:0000AD70                                         ; DATA XREF: CObjectVector<CIndexToPathPair>::~CObjectVector<CIndexToPathPair>(void)+5o
.text$x:0000AD70
.text$x:0000AD70 arg_4           = dword ptr  8
.text$x:0000AD70
.text$x:0000AD70                 mov     edx, [esp+arg_4]
.text$x:0000AD74                 lea     eax, [edx+0Ch]
.text$x:0000AD77                 mov     ecx, [edx-18h]
.text$x:0000AD7A                 xor     ecx, eax
.text$x:0000AD7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AD81                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ
.text$x:0000AD86                 jmp     ___CxxFrameHandler3
.text$x:0000AD86 __ehhandler$??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ endp
.text$x:0000AD86
.text$x:0000AD86 ; ---------------------------------------------------------------------------
.text$x:0000AD8B                 align 4
.text$x:0000AD8B _text$x         ends
.text$x:0000AD8B
.xdata$x:0000AD8C ; ===========================================================================
.xdata$x:0000AD8C
.xdata$x:0000AD8C ; Segment type: Pure data
.xdata$x:0000AD8C ; Segment permissions: Read
.xdata$x:0000AD8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AD8C                 assume cs:_xdata$x
.xdata$x:0000AD8C                 ;org 0AD8Ch
.xdata$x:0000AD8C ; COMDAT (pick associative to section at ACAC)
.xdata$x:0000AD8C __unwindtable$??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ db 0FFh
.xdata$x:0000AD8C                                         ; DATA XREF: .xdata$x:0000AD9Co
.xdata$x:0000AD8D                 db 0FFh
.xdata$x:0000AD8E                 db 0FFh
.xdata$x:0000AD8F                 db 0FFh
.xdata$x:0000AD90                 dd offset __unwindfunclet$??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ$0
.xdata$x:0000AD94 __ehfuncinfo$??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ db  22h ; "
.xdata$x:0000AD94                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ+11o
.xdata$x:0000AD95                 db    5
.xdata$x:0000AD96                 db  93h ; ô
.xdata$x:0000AD97                 db  19h
.xdata$x:0000AD98                 db    1
.xdata$x:0000AD99                 db    0
.xdata$x:0000AD9A                 db    0
.xdata$x:0000AD9B                 db    0
.xdata$x:0000AD9C                 dd offset __unwindtable$??1?$CObjectVector@UCIndexToPathPair@@@@QAE@XZ
.xdata$x:0000ADA0                 db    0
.xdata$x:0000ADA1                 db    0
.xdata$x:0000ADA2                 db    0
.xdata$x:0000ADA3                 db    0
.xdata$x:0000ADA4                 db    0
.xdata$x:0000ADA5                 db    0
.xdata$x:0000ADA6                 db    0
.xdata$x:0000ADA7                 db    0
.xdata$x:0000ADA8                 db    0
.xdata$x:0000ADA9                 db    0
.xdata$x:0000ADAA                 db    0
.xdata$x:0000ADAB                 db    0
.xdata$x:0000ADAC                 db    0
.xdata$x:0000ADAD                 db    0
.xdata$x:0000ADAE                 db    0
.xdata$x:0000ADAF                 db    0
.xdata$x:0000ADB0                 db    0
.xdata$x:0000ADB1                 db    0
.xdata$x:0000ADB2                 db    0
.xdata$x:0000ADB3                 db    0
.xdata$x:0000ADB4                 db    1
.xdata$x:0000ADB5                 db    0
.xdata$x:0000ADB6                 db    0
.xdata$x:0000ADB7                 db    0
.xdata$x:0000ADB7 _xdata$x        ends
.xdata$x:0000ADB7
.text:0000ADB8 ; ===========================================================================
.text:0000ADB8
.text:0000ADB8 ; Segment type: Pure code
.text:0000ADB8 ; Segment permissions: Read/Execute
.text:0000ADB8 _text           segment para public 'CODE' use32
.text:0000ADB8                 assume cs:_text
.text:0000ADB8                 ;org 0ADB8h
.text:0000ADB8 ; COMDAT (pick any)
.text:0000ADB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000ADB8
.text:0000ADB8 ; =============== S U B R O U T I N E =======================================
.text:0000ADB8
.text:0000ADB8 ; Attributes: bp-based frame
.text:0000ADB8
.text:0000ADB8 ; public: void __thiscall CObjectVector<struct CIndexToPathPair>::Clear(void)
.text:0000ADB8                 public ?Clear@?$CObjectVector@UCIndexToPathPair@@@@QAEXXZ
.text:0000ADB8 ?Clear@?$CObjectVector@UCIndexToPathPair@@@@QAEXXZ proc near
.text:0000ADB8                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+51p
.text:0000ADB8
.text:0000ADB8 var_14          = dword ptr -14h
.text:0000ADB8 var_10          = dword ptr -10h
.text:0000ADB8 var_C           = dword ptr -0Ch
.text:0000ADB8 var_8           = dword ptr -8
.text:0000ADB8 var_4           = dword ptr -4
.text:0000ADB8
.text:0000ADB8                 push    ebp
.text:0000ADB9                 mov     ebp, esp
.text:0000ADBB                 sub     esp, 14h
.text:0000ADBE                 mov     eax, 0CCCCCCCCh
.text:0000ADC3                 mov     [ebp+var_14], eax
.text:0000ADC6                 mov     [ebp+var_10], eax
.text:0000ADC9                 mov     [ebp+var_C], eax
.text:0000ADCC                 mov     [ebp+var_8], eax
.text:0000ADCF                 mov     [ebp+var_4], eax
.text:0000ADD2                 mov     [ebp+var_4], ecx
.text:0000ADD5                 mov     ecx, [ebp+var_4]
.text:0000ADD8                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000ADDD                 mov     [ebp+var_8], eax
.text:0000ADE0
.text:0000ADE0 loc_ADE0:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::Clear(void):loc_AE22j
.text:0000ADE0                 cmp     [ebp+var_8], 0
.text:0000ADE4                 jz      short loc_AE24
.text:0000ADE6                 mov     eax, [ebp+var_8]
.text:0000ADE9                 sub     eax, 1
.text:0000ADEC                 mov     [ebp+var_8], eax
.text:0000ADEF                 mov     ecx, [ebp+var_8]
.text:0000ADF2                 push    ecx
.text:0000ADF3                 mov     ecx, [ebp+var_4]
.text:0000ADF6                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000ADFB                 mov     edx, [eax]
.text:0000ADFD                 mov     [ebp+var_10], edx
.text:0000AE00                 mov     eax, [ebp+var_10]
.text:0000AE03                 mov     [ebp+var_C], eax
.text:0000AE06                 cmp     [ebp+var_C], 0
.text:0000AE0A                 jz      short loc_AE1B
.text:0000AE0C                 push    1
.text:0000AE0E                 mov     ecx, [ebp+var_C]
.text:0000AE11                 call    ??_GCIndexToPathPair@@QAEPAXI@Z ; CIndexToPathPair::`scalar deleting destructor'(uint)
.text:0000AE16                 mov     [ebp+var_14], eax
.text:0000AE19                 jmp     short loc_AE22
.text:0000AE1B ; ---------------------------------------------------------------------------
.text:0000AE1B
.text:0000AE1B loc_AE1B:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::Clear(void)+52j
.text:0000AE1B                 mov     [ebp+var_14], 0
.text:0000AE22
.text:0000AE22 loc_AE22:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::Clear(void)+61j
.text:0000AE22                 jmp     short loc_ADE0
.text:0000AE24 ; ---------------------------------------------------------------------------
.text:0000AE24
.text:0000AE24 loc_AE24:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::Clear(void)+2Cj
.text:0000AE24                 mov     ecx, [ebp+var_4]
.text:0000AE27                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:0000AE2C                 add     esp, 14h
.text:0000AE2F                 cmp     ebp, esp
.text:0000AE31                 call    __RTC_CheckEsp
.text:0000AE36                 mov     esp, ebp
.text:0000AE38                 pop     ebp
.text:0000AE39                 retn
.text:0000AE39 ?Clear@?$CObjectVector@UCIndexToPathPair@@@@QAEXXZ endp
.text:0000AE39
.text:0000AE39 ; ---------------------------------------------------------------------------
.text:0000AE3A                 align 4
.text:0000AE3A _text           ends
.text:0000AE3A
.text:0000AE3C ; ===========================================================================
.text:0000AE3C
.text:0000AE3C ; Segment type: Pure code
.text:0000AE3C ; Segment permissions: Read/Execute
.text:0000AE3C _text           segment para public 'CODE' use32
.text:0000AE3C                 assume cs:_text
.text:0000AE3C                 ;org 0AE3Ch
.text:0000AE3C ; COMDAT (pick any)
.text:0000AE3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AE3C
.text:0000AE3C ; =============== S U B R O U T I N E =======================================
.text:0000AE3C
.text:0000AE3C ; Attributes: bp-based frame
.text:0000AE3C
.text:0000AE3C ; int __stdcall CObjectVector<CIndexToPathPair>::FindInSorted(CIndexToPathPair *)
.text:0000AE3C                 public ?FindInSorted@?$CObjectVector@UCIndexToPathPair@@@@QBEHABUCIndexToPathPair@@@Z
.text:0000AE3C ?FindInSorted@?$CObjectVector@UCIndexToPathPair@@@@QBEHABUCIndexToPathPair@@@Z proc near
.text:0000AE3C                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1775p
.text:0000AE3C
.text:0000AE3C var_18          = dword ptr -18h
.text:0000AE3C var_14          = dword ptr -14h
.text:0000AE3C var_10          = dword ptr -10h
.text:0000AE3C var_C           = dword ptr -0Ch
.text:0000AE3C var_8           = dword ptr -8
.text:0000AE3C var_4           = dword ptr -4
.text:0000AE3C arg_0           = dword ptr  8
.text:0000AE3C
.text:0000AE3C                 push    ebp
.text:0000AE3D                 mov     ebp, esp
.text:0000AE3F                 sub     esp, 18h
.text:0000AE42                 mov     eax, 0CCCCCCCCh
.text:0000AE47                 mov     [ebp+var_18], eax
.text:0000AE4A                 mov     [ebp+var_14], eax
.text:0000AE4D                 mov     [ebp+var_10], eax
.text:0000AE50                 mov     [ebp+var_C], eax
.text:0000AE53                 mov     [ebp+var_8], eax
.text:0000AE56                 mov     [ebp+var_4], eax
.text:0000AE59                 mov     [ebp+var_4], ecx
.text:0000AE5C                 mov     [ebp+var_8], 0
.text:0000AE63                 mov     ecx, [ebp+var_4]
.text:0000AE66                 call    ?Size@?$CObjectVector@UCIndexToPathPair@@@@QBEIXZ ; CObjectVector<CIndexToPathPair>::Size(void)
.text:0000AE6B                 mov     [ebp+var_C], eax
.text:0000AE6E
.text:0000AE6E loc_AE6E:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::FindInSorted(CIndexToPathPair const &):loc_AEC1j
.text:0000AE6E                 mov     eax, [ebp+var_8]
.text:0000AE71                 cmp     eax, [ebp+var_C]
.text:0000AE74                 jz      short loc_AEC3
.text:0000AE76                 mov     ecx, [ebp+var_8]
.text:0000AE79                 add     ecx, [ebp+var_C]
.text:0000AE7C                 shr     ecx, 1
.text:0000AE7E                 mov     [ebp+var_10], ecx
.text:0000AE81                 mov     edx, [ebp+var_10]
.text:0000AE84                 push    edx
.text:0000AE85                 mov     ecx, [ebp+var_4]
.text:0000AE88                 call    ??A?$CObjectVector@UCIndexToPathPair@@@@QBEABUCIndexToPathPair@@I@Z ; CObjectVector<CIndexToPathPair>::operator[](uint)
.text:0000AE8D                 mov     [ebp+var_14], eax
.text:0000AE90                 mov     eax, [ebp+var_14]
.text:0000AE93                 push    eax             ; struct CIndexToPathPair *
.text:0000AE94                 mov     ecx, [ebp+arg_0] ; this
.text:0000AE97                 call    ?Compare@CIndexToPathPair@@QBEHABU1@@Z ; CIndexToPathPair::Compare(CIndexToPathPair const &)
.text:0000AE9C                 mov     [ebp+var_18], eax
.text:0000AE9F                 cmp     [ebp+var_18], 0
.text:0000AEA3                 jnz     short loc_AEAA
.text:0000AEA5                 mov     eax, [ebp+var_10]
.text:0000AEA8                 jmp     short loc_AEC6
.text:0000AEAA ; ---------------------------------------------------------------------------
.text:0000AEAA
.text:0000AEAA loc_AEAA:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::FindInSorted(CIndexToPathPair const &)+67j
.text:0000AEAA                 cmp     [ebp+var_18], 0
.text:0000AEAE                 jge     short loc_AEB8
.text:0000AEB0                 mov     ecx, [ebp+var_10]
.text:0000AEB3                 mov     [ebp+var_C], ecx
.text:0000AEB6                 jmp     short loc_AEC1
.text:0000AEB8 ; ---------------------------------------------------------------------------
.text:0000AEB8
.text:0000AEB8 loc_AEB8:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::FindInSorted(CIndexToPathPair const &)+72j
.text:0000AEB8                 mov     edx, [ebp+var_10]
.text:0000AEBB                 add     edx, 1
.text:0000AEBE                 mov     [ebp+var_8], edx
.text:0000AEC1
.text:0000AEC1 loc_AEC1:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::FindInSorted(CIndexToPathPair const &)+7Aj
.text:0000AEC1                 jmp     short loc_AE6E
.text:0000AEC3 ; ---------------------------------------------------------------------------
.text:0000AEC3
.text:0000AEC3 loc_AEC3:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::FindInSorted(CIndexToPathPair const &)+38j
.text:0000AEC3                 or      eax, 0FFFFFFFFh
.text:0000AEC6
.text:0000AEC6 loc_AEC6:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::FindInSorted(CIndexToPathPair const &)+6Cj
.text:0000AEC6                 add     esp, 18h
.text:0000AEC9                 cmp     ebp, esp
.text:0000AECB                 call    __RTC_CheckEsp
.text:0000AED0                 mov     esp, ebp
.text:0000AED2                 pop     ebp
.text:0000AED3                 retn    4
.text:0000AED3 ?FindInSorted@?$CObjectVector@UCIndexToPathPair@@@@QBEHABUCIndexToPathPair@@@Z endp
.text:0000AED3
.text:0000AED3 ; ---------------------------------------------------------------------------
.text:0000AED6                 align 4
.text:0000AED6 _text           ends
.text:0000AED6
.text:0000AED8 ; ===========================================================================
.text:0000AED8
.text:0000AED8 ; Segment type: Pure code
.text:0000AED8 ; Segment permissions: Read/Execute
.text:0000AED8 _text           segment para public 'CODE' use32
.text:0000AED8                 assume cs:_text
.text:0000AED8                 ;org 0AED8h
.text:0000AED8 ; COMDAT (pick any)
.text:0000AED8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AED8
.text:0000AED8 ; =============== S U B R O U T I N E =======================================
.text:0000AED8
.text:0000AED8 ; Attributes: bp-based frame
.text:0000AED8
.text:0000AED8 ; int __thiscall CIndexToPathPair::Compare(CIndexToPathPair *this, const struct CIndexToPathPair *)
.text:0000AED8                 public ?Compare@CIndexToPathPair@@QBEHABU1@@Z
.text:0000AED8 ?Compare@CIndexToPathPair@@QBEHABU1@@Z proc near
.text:0000AED8                                         ; CODE XREF: CObjectVector<CIndexToPathPair>::FindInSorted(CIndexToPathPair const &)+5Bp
.text:0000AED8                                         ; CObjectVector<CIndexToPathPair>::AddToUniqueSorted(CIndexToPathPair const &)+5Bp
.text:0000AED8
.text:0000AED8 var_4           = dword ptr -4
.text:0000AED8 arg_0           = dword ptr  8
.text:0000AED8
.text:0000AED8                 push    ebp
.text:0000AED9                 mov     ebp, esp
.text:0000AEDB                 push    ecx
.text:0000AEDC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AEE3                 mov     [ebp+var_4], ecx
.text:0000AEE6                 mov     eax, [ebp+arg_0]
.text:0000AEE9                 mov     ecx, [eax]
.text:0000AEEB                 push    ecx
.text:0000AEEC                 mov     edx, [ebp+var_4]
.text:0000AEEF                 mov     eax, [edx]
.text:0000AEF1                 push    eax
.text:0000AEF2                 call    ??$MyCompare@I@@YGHII@Z ; MyCompare<uint>(uint,uint)
.text:0000AEF7                 add     esp, 4
.text:0000AEFA                 cmp     ebp, esp
.text:0000AEFC                 call    __RTC_CheckEsp
.text:0000AF01                 mov     esp, ebp
.text:0000AF03                 pop     ebp
.text:0000AF04                 retn    4
.text:0000AF04 ?Compare@CIndexToPathPair@@QBEHABU1@@Z endp
.text:0000AF04
.text:0000AF04 ; ---------------------------------------------------------------------------
.text:0000AF07                 align 4
.text:0000AF07 _text           ends
.text:0000AF07
.text:0000AF08 ; ===========================================================================
.text:0000AF08
.text:0000AF08 ; Segment type: Pure code
.text:0000AF08 ; Segment permissions: Read/Execute
.text:0000AF08 _text           segment para public 'CODE' use32
.text:0000AF08                 assume cs:_text
.text:0000AF08                 ;org 0AF08h
.text:0000AF08 ; COMDAT (pick any)
.text:0000AF08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AF08
.text:0000AF08 ; =============== S U B R O U T I N E =======================================
.text:0000AF08
.text:0000AF08 ; Attributes: bp-based frame
.text:0000AF08
.text:0000AF08 ; int __stdcall CObjectVector<CIndexToPathPair>::AddToUniqueSorted(CIndexToPathPair *)
.text:0000AF08                 public ?AddToUniqueSorted@?$CObjectVector@UCIndexToPathPair@@@@QAEIABUCIndexToPathPair@@@Z
.text:0000AF08 ?AddToUniqueSorted@?$CObjectVector@UCIndexToPathPair@@@@QAEIABUCIndexToPathPair@@@Z proc near
.text:0000AF08                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+30F5p
.text:0000AF08
.text:0000AF08 var_18          = dword ptr -18h
.text:0000AF08 var_14          = dword ptr -14h
.text:0000AF08 var_10          = dword ptr -10h
.text:0000AF08 var_C           = dword ptr -0Ch
.text:0000AF08 var_8           = dword ptr -8
.text:0000AF08 var_4           = dword ptr -4
.text:0000AF08 arg_0           = dword ptr  8
.text:0000AF08
.text:0000AF08                 push    ebp
.text:0000AF09                 mov     ebp, esp
.text:0000AF0B                 sub     esp, 18h
.text:0000AF0E                 mov     eax, 0CCCCCCCCh
.text:0000AF13                 mov     [ebp+var_18], eax
.text:0000AF16                 mov     [ebp+var_14], eax
.text:0000AF19                 mov     [ebp+var_10], eax
.text:0000AF1C                 mov     [ebp+var_C], eax
.text:0000AF1F                 mov     [ebp+var_8], eax
.text:0000AF22                 mov     [ebp+var_4], eax
.text:0000AF25                 mov     [ebp+var_4], ecx
.text:0000AF28                 mov     [ebp+var_8], 0
.text:0000AF2F                 mov     ecx, [ebp+var_4]
.text:0000AF32                 call    ?Size@?$CObjectVector@UCIndexToPathPair@@@@QBEIXZ ; CObjectVector<CIndexToPathPair>::Size(void)
.text:0000AF37                 mov     [ebp+var_C], eax
.text:0000AF3A
.text:0000AF3A loc_AF3A:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::AddToUniqueSorted(CIndexToPathPair const &):loc_AF8Dj
.text:0000AF3A                 mov     eax, [ebp+var_8]
.text:0000AF3D                 cmp     eax, [ebp+var_C]
.text:0000AF40                 jz      short loc_AF8F
.text:0000AF42                 mov     ecx, [ebp+var_8]
.text:0000AF45                 add     ecx, [ebp+var_C]
.text:0000AF48                 shr     ecx, 1
.text:0000AF4A                 mov     [ebp+var_10], ecx
.text:0000AF4D                 mov     edx, [ebp+var_10]
.text:0000AF50                 push    edx
.text:0000AF51                 mov     ecx, [ebp+var_4]
.text:0000AF54                 call    ??A?$CObjectVector@UCIndexToPathPair@@@@QAEAAUCIndexToPathPair@@I@Z ; CObjectVector<CIndexToPathPair>::operator[](uint)
.text:0000AF59                 mov     [ebp+var_14], eax
.text:0000AF5C                 mov     eax, [ebp+var_14]
.text:0000AF5F                 push    eax             ; struct CIndexToPathPair *
.text:0000AF60                 mov     ecx, [ebp+arg_0] ; this
.text:0000AF63                 call    ?Compare@CIndexToPathPair@@QBEHABU1@@Z ; CIndexToPathPair::Compare(CIndexToPathPair const &)
.text:0000AF68                 mov     [ebp+var_18], eax
.text:0000AF6B                 cmp     [ebp+var_18], 0
.text:0000AF6F                 jnz     short loc_AF76
.text:0000AF71                 mov     eax, [ebp+var_10]
.text:0000AF74                 jmp     short loc_AFA2
.text:0000AF76 ; ---------------------------------------------------------------------------
.text:0000AF76
.text:0000AF76 loc_AF76:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::AddToUniqueSorted(CIndexToPathPair const &)+67j
.text:0000AF76                 cmp     [ebp+var_18], 0
.text:0000AF7A                 jge     short loc_AF84
.text:0000AF7C                 mov     ecx, [ebp+var_10]
.text:0000AF7F                 mov     [ebp+var_C], ecx
.text:0000AF82                 jmp     short loc_AF8D
.text:0000AF84 ; ---------------------------------------------------------------------------
.text:0000AF84
.text:0000AF84 loc_AF84:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::AddToUniqueSorted(CIndexToPathPair const &)+72j
.text:0000AF84                 mov     edx, [ebp+var_10]
.text:0000AF87                 add     edx, 1
.text:0000AF8A                 mov     [ebp+var_8], edx
.text:0000AF8D
.text:0000AF8D loc_AF8D:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::AddToUniqueSorted(CIndexToPathPair const &)+7Aj
.text:0000AF8D                 jmp     short loc_AF3A
.text:0000AF8F ; ---------------------------------------------------------------------------
.text:0000AF8F
.text:0000AF8F loc_AF8F:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::AddToUniqueSorted(CIndexToPathPair const &)+38j
.text:0000AF8F                 mov     eax, [ebp+arg_0]
.text:0000AF92                 push    eax
.text:0000AF93                 mov     ecx, [ebp+var_C]
.text:0000AF96                 push    ecx
.text:0000AF97                 mov     ecx, [ebp+var_4]
.text:0000AF9A                 call    ?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z ; CObjectVector<CIndexToPathPair>::Insert(uint,CIndexToPathPair const &)
.text:0000AF9F                 mov     eax, [ebp+var_C]
.text:0000AFA2
.text:0000AFA2 loc_AFA2:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::AddToUniqueSorted(CIndexToPathPair const &)+6Cj
.text:0000AFA2                 add     esp, 18h
.text:0000AFA5                 cmp     ebp, esp
.text:0000AFA7                 call    __RTC_CheckEsp
.text:0000AFAC                 mov     esp, ebp
.text:0000AFAE                 pop     ebp
.text:0000AFAF                 retn    4
.text:0000AFAF ?AddToUniqueSorted@?$CObjectVector@UCIndexToPathPair@@@@QAEIABUCIndexToPathPair@@@Z endp
.text:0000AFAF
.text:0000AFAF ; ---------------------------------------------------------------------------
.text:0000AFB2                 align 4
.text:0000AFB2 _text           ends
.text:0000AFB2
.text:0000AFB4 ; ===========================================================================
.text:0000AFB4
.text:0000AFB4 ; Segment type: Pure code
.text:0000AFB4 ; Segment permissions: Read/Execute
.text:0000AFB4 _text           segment para public 'CODE' use32
.text:0000AFB4                 assume cs:_text
.text:0000AFB4                 ;org 0AFB4h
.text:0000AFB4 ; COMDAT (pick any)
.text:0000AFB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AFB4
.text:0000AFB4 ; =============== S U B R O U T I N E =======================================
.text:0000AFB4
.text:0000AFB4 ; Attributes: bp-based frame
.text:0000AFB4
.text:0000AFB4 ; public: __thiscall CRecordVector<struct CExtrRefSortPair>::CRecordVector<struct CExtrRefSortPair>(void)
.text:0000AFB4                 public ??0?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ
.text:0000AFB4 ??0?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ proc near
.text:0000AFB4                                         ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+43p
.text:0000AFB4
.text:0000AFB4 var_4           = dword ptr -4
.text:0000AFB4
.text:0000AFB4                 push    ebp
.text:0000AFB5                 mov     ebp, esp
.text:0000AFB7                 push    ecx
.text:0000AFB8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AFBF                 mov     [ebp+var_4], ecx
.text:0000AFC2                 mov     eax, [ebp+var_4]
.text:0000AFC5                 mov     dword ptr [eax], 0
.text:0000AFCB                 mov     ecx, [ebp+var_4]
.text:0000AFCE                 mov     dword ptr [ecx+4], 0
.text:0000AFD5                 mov     edx, [ebp+var_4]
.text:0000AFD8                 mov     dword ptr [edx+8], 0
.text:0000AFDF                 mov     eax, [ebp+var_4]
.text:0000AFE2                 mov     esp, ebp
.text:0000AFE4                 pop     ebp
.text:0000AFE5                 retn
.text:0000AFE5 ??0?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ endp
.text:0000AFE5
.text:0000AFE5 ; ---------------------------------------------------------------------------
.text:0000AFE6                 align 4
.text:0000AFE6 _text           ends
.text:0000AFE6
.text:0000AFE8 ; ===========================================================================
.text:0000AFE8
.text:0000AFE8 ; Segment type: Pure code
.text:0000AFE8 ; Segment permissions: Read/Execute
.text:0000AFE8 _text           segment para public 'CODE' use32
.text:0000AFE8                 assume cs:_text
.text:0000AFE8                 ;org 0AFE8h
.text:0000AFE8 ; COMDAT (pick any)
.text:0000AFE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AFE8
.text:0000AFE8 ; =============== S U B R O U T I N E =======================================
.text:0000AFE8
.text:0000AFE8 ; Attributes: bp-based frame
.text:0000AFE8
.text:0000AFE8 ; public: unsigned int __thiscall CRecordVector<struct CExtrRefSortPair>::Size(void)const
.text:0000AFE8                 public ?Size@?$CRecordVector@UCExtrRefSortPair@@@@QBEIXZ
.text:0000AFE8 ?Size@?$CRecordVector@UCExtrRefSortPair@@@@QBEIXZ proc near
.text:0000AFE8                                         ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+E6p
.text:0000AFE8
.text:0000AFE8 var_4           = dword ptr -4
.text:0000AFE8
.text:0000AFE8                 push    ebp
.text:0000AFE9                 mov     ebp, esp
.text:0000AFEB                 push    ecx
.text:0000AFEC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AFF3                 mov     [ebp+var_4], ecx
.text:0000AFF6                 mov     eax, [ebp+var_4]
.text:0000AFF9                 mov     eax, [eax+4]
.text:0000AFFC                 mov     esp, ebp
.text:0000AFFE                 pop     ebp
.text:0000AFFF                 retn
.text:0000AFFF ?Size@?$CRecordVector@UCExtrRefSortPair@@@@QBEIXZ endp
.text:0000AFFF
.text:0000AFFF _text           ends
.text:0000AFFF
.text:0000B000 ; ===========================================================================
.text:0000B000
.text:0000B000 ; Segment type: Pure code
.text:0000B000 ; Segment permissions: Read/Execute
.text:0000B000 _text           segment para public 'CODE' use32
.text:0000B000                 assume cs:_text
.text:0000B000                 ;org 0B000h
.text:0000B000 ; COMDAT (pick any)
.text:0000B000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B000
.text:0000B000 ; =============== S U B R O U T I N E =======================================
.text:0000B000
.text:0000B000 ; Attributes: bp-based frame
.text:0000B000
.text:0000B000 ; public: void __thiscall CRecordVector<struct CExtrRefSortPair>::ClearAndSetSize(unsigned int)
.text:0000B000                 public ?ClearAndSetSize@?$CRecordVector@UCExtrRefSortPair@@@@QAEXI@Z
.text:0000B000 ?ClearAndSetSize@?$CRecordVector@UCExtrRefSortPair@@@@QAEXI@Z proc near
.text:0000B000                                         ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+61p
.text:0000B000
.text:0000B000 var_4           = dword ptr -4
.text:0000B000 arg_0           = dword ptr  8
.text:0000B000
.text:0000B000                 push    ebp
.text:0000B001                 mov     ebp, esp
.text:0000B003                 push    ecx
.text:0000B004                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B00B                 mov     [ebp+var_4], ecx
.text:0000B00E                 mov     eax, [ebp+arg_0]
.text:0000B011                 push    eax
.text:0000B012                 mov     ecx, [ebp+var_4]
.text:0000B015                 call    ?ClearAndReserve@?$CRecordVector@UCExtrRefSortPair@@@@QAEXI@Z ; CRecordVector<CExtrRefSortPair>::ClearAndReserve(uint)
.text:0000B01A                 mov     ecx, [ebp+var_4]
.text:0000B01D                 mov     edx, [ebp+arg_0]
.text:0000B020                 mov     [ecx+4], edx
.text:0000B023                 add     esp, 4
.text:0000B026                 cmp     ebp, esp
.text:0000B028                 call    __RTC_CheckEsp
.text:0000B02D                 mov     esp, ebp
.text:0000B02F                 pop     ebp
.text:0000B030                 retn    4
.text:0000B030 ?ClearAndSetSize@?$CRecordVector@UCExtrRefSortPair@@@@QAEXI@Z endp
.text:0000B030
.text:0000B030 ; ---------------------------------------------------------------------------
.text:0000B033                 align 4
.text:0000B033 _text           ends
.text:0000B033
.text:0000B034 ; ===========================================================================
.text:0000B034
.text:0000B034 ; Segment type: Pure code
.text:0000B034 ; Segment permissions: Read/Execute
.text:0000B034 _text           segment para public 'CODE' use32
.text:0000B034                 assume cs:_text
.text:0000B034                 ;org 0B034h
.text:0000B034 ; COMDAT (pick any)
.text:0000B034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B034
.text:0000B034 ; =============== S U B R O U T I N E =======================================
.text:0000B034
.text:0000B034 ; Attributes: bp-based frame
.text:0000B034
.text:0000B034 ; public: __thiscall CRecordVector<struct CExtrRefSortPair>::~CRecordVector<struct CExtrRefSortPair>(void)
.text:0000B034                 public ??1?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ
.text:0000B034 ??1?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ proc near
.text:0000B034                                         ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+158p
.text:0000B034                                         ; CArchiveExtractCallback::SetDirsTimes(void)+1A3p ...
.text:0000B034
.text:0000B034 var_8           = dword ptr -8
.text:0000B034 var_4           = dword ptr -4
.text:0000B034
.text:0000B034                 push    ebp
.text:0000B035                 mov     ebp, esp
.text:0000B037                 sub     esp, 8
.text:0000B03A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000B041                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B048                 mov     [ebp+var_4], ecx
.text:0000B04B                 mov     eax, [ebp+var_4]
.text:0000B04E                 mov     ecx, [eax]
.text:0000B050                 mov     [ebp+var_8], ecx
.text:0000B053                 mov     edx, [ebp+var_8]
.text:0000B056                 push    edx             ; void *
.text:0000B057                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B05C                 add     esp, 4
.text:0000B05F                 add     esp, 8
.text:0000B062                 cmp     ebp, esp
.text:0000B064                 call    __RTC_CheckEsp
.text:0000B069                 mov     esp, ebp
.text:0000B06B                 pop     ebp
.text:0000B06C                 retn
.text:0000B06C ??1?$CRecordVector@UCExtrRefSortPair@@@@QAE@XZ endp
.text:0000B06C
.text:0000B06C ; ---------------------------------------------------------------------------
.text:0000B06D                 align 10h
.text:0000B06D _text           ends
.text:0000B06D
.text:0000B070 ; ===========================================================================
.text:0000B070
.text:0000B070 ; Segment type: Pure code
.text:0000B070 ; Segment permissions: Read/Execute
.text:0000B070 _text           segment para public 'CODE' use32
.text:0000B070                 assume cs:_text
.text:0000B070                 ;org 0B070h
.text:0000B070 ; COMDAT (pick any)
.text:0000B070                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B070
.text:0000B070 ; =============== S U B R O U T I N E =======================================
.text:0000B070
.text:0000B070 ; Attributes: bp-based frame
.text:0000B070
.text:0000B070 ; public: struct CExtrRefSortPair & __thiscall CRecordVector<struct CExtrRefSortPair>::operator[](unsigned int)
.text:0000B070                 public ??A?$CRecordVector@UCExtrRefSortPair@@@@QAEAAUCExtrRefSortPair@@I@Z
.text:0000B070 ??A?$CRecordVector@UCExtrRefSortPair@@@@QAEAAUCExtrRefSortPair@@I@Z proc near
.text:0000B070                                         ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+92p
.text:0000B070                                         ; CArchiveExtractCallback::SetDirsTimes(void)+FBp
.text:0000B070
.text:0000B070 var_4           = dword ptr -4
.text:0000B070 arg_0           = dword ptr  8
.text:0000B070
.text:0000B070                 push    ebp
.text:0000B071                 mov     ebp, esp
.text:0000B073                 push    ecx
.text:0000B074                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B07B                 mov     [ebp+var_4], ecx
.text:0000B07E                 mov     eax, [ebp+var_4]
.text:0000B081                 mov     ecx, [eax]
.text:0000B083                 mov     edx, [ebp+arg_0]
.text:0000B086                 lea     eax, [ecx+edx*8]
.text:0000B089                 mov     esp, ebp
.text:0000B08B                 pop     ebp
.text:0000B08C                 retn    4
.text:0000B08C ??A?$CRecordVector@UCExtrRefSortPair@@@@QAEAAUCExtrRefSortPair@@I@Z endp
.text:0000B08C
.text:0000B08C ; ---------------------------------------------------------------------------
.text:0000B08F                 align 10h
.text:0000B08F _text           ends
.text:0000B08F
.text:0000B090 ; ===========================================================================
.text:0000B090
.text:0000B090 ; Segment type: Pure code
.text:0000B090 ; Segment permissions: Read/Execute
.text:0000B090 _text           segment para public 'CODE' use32
.text:0000B090                 assume cs:_text
.text:0000B090                 ;org 0B090h
.text:0000B090 ; COMDAT (pick any)
.text:0000B090                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B090
.text:0000B090 ; =============== S U B R O U T I N E =======================================
.text:0000B090
.text:0000B090 ; Attributes: bp-based frame
.text:0000B090
.text:0000B090 ; public: void __thiscall CRecordVector<struct CExtrRefSortPair>::Sort2(void)
.text:0000B090                 public ?Sort2@?$CRecordVector@UCExtrRefSortPair@@@@QAEXXZ
.text:0000B090 ?Sort2@?$CRecordVector@UCExtrRefSortPair@@@@QAEXXZ proc near
.text:0000B090                                         ; CODE XREF: CArchiveExtractCallback::SetDirsTimes(void)+CCp
.text:0000B090
.text:0000B090 var_20          = dword ptr -20h
.text:0000B090 var_1C          = dword ptr -1Ch
.text:0000B090 var_18          = dword ptr -18h
.text:0000B090 var_14          = dword ptr -14h
.text:0000B090 var_10          = dword ptr -10h
.text:0000B090 var_C           = dword ptr -0Ch
.text:0000B090 var_8           = dword ptr -8
.text:0000B090 var_4           = dword ptr -4
.text:0000B090
.text:0000B090                 push    ebp
.text:0000B091                 mov     ebp, esp
.text:0000B093                 sub     esp, 20h
.text:0000B096                 push    esi
.text:0000B097                 mov     eax, 0CCCCCCCCh
.text:0000B09C                 mov     [ebp+var_20], eax
.text:0000B09F                 mov     [ebp+var_1C], eax
.text:0000B0A2                 mov     [ebp+var_18], eax
.text:0000B0A5                 mov     [ebp+var_14], eax
.text:0000B0A8                 mov     [ebp+var_10], eax
.text:0000B0AB                 mov     [ebp+var_C], eax
.text:0000B0AE                 mov     [ebp+var_8], eax
.text:0000B0B1                 mov     [ebp+var_4], eax
.text:0000B0B4                 mov     [ebp+var_4], ecx
.text:0000B0B7                 mov     eax, [ebp+var_4]
.text:0000B0BA                 mov     ecx, [eax+4]
.text:0000B0BD                 mov     [ebp+var_8], ecx
.text:0000B0C0                 cmp     [ebp+var_8], 1
.text:0000B0C4                 ja      short loc_B0CB
.text:0000B0C6                 jmp     loc_B153
.text:0000B0CB ; ---------------------------------------------------------------------------
.text:0000B0CB
.text:0000B0CB loc_B0CB:                               ; CODE XREF: CRecordVector<CExtrRefSortPair>::Sort2(void)+34j
.text:0000B0CB                 mov     ecx, [ebp+var_4]
.text:0000B0CE                 call    ?Front@?$CRecordVector@UCExtrRefSortPair@@@@QAEAAUCExtrRefSortPair@@XZ ; CRecordVector<CExtrRefSortPair>::Front(void)
.text:0000B0D3                 sub     eax, 8
.text:0000B0D6                 mov     [ebp+var_C], eax
.text:0000B0D9                 mov     edx, [ebp+var_8]
.text:0000B0DC                 shr     edx, 1
.text:0000B0DE                 mov     [ebp+var_10], edx
.text:0000B0E1
.text:0000B0E1 loc_B0E1:                               ; CODE XREF: CRecordVector<CExtrRefSortPair>::Sort2(void)+6Bj
.text:0000B0E1                 mov     eax, [ebp+var_8]
.text:0000B0E4                 push    eax
.text:0000B0E5                 mov     ecx, [ebp+var_10]
.text:0000B0E8                 push    ecx
.text:0000B0E9                 mov     edx, [ebp+var_C]
.text:0000B0EC                 push    edx
.text:0000B0ED                 call    ?SortRefDown2@?$CRecordVector@UCExtrRefSortPair@@@@SGXPAUCExtrRefSortPair@@II@Z ; CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)
.text:0000B0F2                 mov     eax, [ebp+var_10]
.text:0000B0F5                 sub     eax, 1
.text:0000B0F8                 mov     [ebp+var_10], eax
.text:0000B0FB                 jnz     short loc_B0E1
.text:0000B0FD
.text:0000B0FD loc_B0FD:                               ; CODE XREF: CRecordVector<CExtrRefSortPair>::Sort2(void)+C1j
.text:0000B0FD                 mov     ecx, [ebp+var_8]
.text:0000B100                 mov     edx, [ebp+var_C]
.text:0000B103                 mov     eax, [edx+ecx*8]
.text:0000B106                 mov     ecx, [edx+ecx*8+4]
.text:0000B10A                 mov     [ebp+var_1C], eax
.text:0000B10D                 mov     [ebp+var_18], ecx
.text:0000B110                 mov     edx, [ebp+var_C]
.text:0000B113                 mov     eax, [edx+8]
.text:0000B116                 mov     ecx, [edx+0Ch]
.text:0000B119                 mov     edx, [ebp+var_8]
.text:0000B11C                 mov     esi, [ebp+var_C]
.text:0000B11F                 mov     [esi+edx*8], eax
.text:0000B122                 mov     [esi+edx*8+4], ecx
.text:0000B126                 mov     eax, [ebp+var_8]
.text:0000B129                 sub     eax, 1
.text:0000B12C                 mov     [ebp+var_8], eax
.text:0000B12F                 mov     ecx, [ebp+var_C]
.text:0000B132                 mov     edx, [ebp+var_1C]
.text:0000B135                 mov     [ecx+8], edx
.text:0000B138                 mov     eax, [ebp+var_18]
.text:0000B13B                 mov     [ecx+0Ch], eax
.text:0000B13E                 mov     ecx, [ebp+var_8]
.text:0000B141                 push    ecx
.text:0000B142                 push    1
.text:0000B144                 mov     edx, [ebp+var_C]
.text:0000B147                 push    edx
.text:0000B148                 call    ?SortRefDown2@?$CRecordVector@UCExtrRefSortPair@@@@SGXPAUCExtrRefSortPair@@II@Z ; CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)
.text:0000B14D                 cmp     [ebp+var_8], 1
.text:0000B151                 ja      short loc_B0FD
.text:0000B153
.text:0000B153 loc_B153:                               ; CODE XREF: CRecordVector<CExtrRefSortPair>::Sort2(void)+36j
.text:0000B153                 push    edx
.text:0000B154                 mov     ecx, ebp
.text:0000B156                 push    eax
.text:0000B157                 lea     edx, $LN12_6
.text:0000B15D                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000B162                 pop     eax
.text:0000B163                 pop     edx
.text:0000B164                 pop     esi
.text:0000B165                 add     esp, 20h
.text:0000B168                 cmp     ebp, esp
.text:0000B16A                 call    __RTC_CheckEsp
.text:0000B16F                 mov     esp, ebp
.text:0000B171                 pop     ebp
.text:0000B172                 retn
.text:0000B172 ?Sort2@?$CRecordVector@UCExtrRefSortPair@@@@QAEXXZ endp
.text:0000B172
.text:0000B172 ; ---------------------------------------------------------------------------
.text:0000B173                 align 4
.text:0000B174 $LN12_6         dd 1                    ; DATA XREF: CRecordVector<CExtrRefSortPair>::Sort2(void)+C7o
.text:0000B178                 dd offset $LN11_7
.text:0000B17C $LN11_7         dd 0FFFFFFE4h, 8        ; DATA XREF: .text:0000B178o
.text:0000B184                 dd offset $LN10_7       ; "temp"
.text:0000B188 $LN10_7         db 'temp',0             ; DATA XREF: .text:0000B184o
.text:0000B18D                 align 10h
.text:0000B18D _text           ends
.text:0000B18D
.text:0000B190 ; ===========================================================================
.text:0000B190
.text:0000B190 ; Segment type: Pure code
.text:0000B190 ; Segment permissions: Read/Execute
.text:0000B190 _text           segment para public 'CODE' use32
.text:0000B190                 assume cs:_text
.text:0000B190                 ;org 0B190h
.text:0000B190 ; COMDAT (pick any)
.text:0000B190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B190
.text:0000B190 ; =============== S U B R O U T I N E =======================================
.text:0000B190
.text:0000B190 ; Attributes: bp-based frame
.text:0000B190
.text:0000B190 ; public: void * __thiscall UString::`scalar deleting destructor'(unsigned int)
.text:0000B190                 public ??_GUString@@QAEPAXI@Z
.text:0000B190 ??_GUString@@QAEPAXI@Z proc near        ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+7Fp
.text:0000B190                                         ; CObjectVector<UString>::Clear(void)+59p ...
.text:0000B190
.text:0000B190 var_4           = dword ptr -4
.text:0000B190 arg_0           = dword ptr  8
.text:0000B190
.text:0000B190                 push    ebp
.text:0000B191                 mov     ebp, esp
.text:0000B193                 push    ecx
.text:0000B194                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B19B                 mov     [ebp+var_4], ecx
.text:0000B19E                 mov     ecx, [ebp+var_4] ; this
.text:0000B1A1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000B1A6                 mov     eax, [ebp+arg_0]
.text:0000B1A9                 and     eax, 1
.text:0000B1AC                 jz      short loc_B1BA
.text:0000B1AE                 mov     ecx, [ebp+var_4]
.text:0000B1B1                 push    ecx             ; void *
.text:0000B1B2                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B1B7                 add     esp, 4
.text:0000B1BA
.text:0000B1BA loc_B1BA:                               ; CODE XREF: UString::`scalar deleting destructor'(uint)+1Cj
.text:0000B1BA                 mov     eax, [ebp+var_4]
.text:0000B1BD                 add     esp, 4
.text:0000B1C0                 cmp     ebp, esp
.text:0000B1C2                 call    __RTC_CheckEsp
.text:0000B1C7                 mov     esp, ebp
.text:0000B1C9                 pop     ebp
.text:0000B1CA                 retn    4
.text:0000B1CA ??_GUString@@QAEPAXI@Z endp
.text:0000B1CA
.text:0000B1CA ; ---------------------------------------------------------------------------
.text:0000B1CD                 align 10h
.text:0000B1CD _text           ends
.text:0000B1CD
.text:0000B1D0 ; ===========================================================================
.text:0000B1D0
.text:0000B1D0 ; Segment type: Pure code
.text:0000B1D0 ; Segment permissions: Read/Execute
.text:0000B1D0 _text           segment para public 'CODE' use32
.text:0000B1D0                 assume cs:_text
.text:0000B1D0                 ;org 0B1D0h
.text:0000B1D0 ; COMDAT (pick any)
.text:0000B1D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B1D0
.text:0000B1D0 ; =============== S U B R O U T I N E =======================================
.text:0000B1D0
.text:0000B1D0 ; Attributes: bp-based frame
.text:0000B1D0
.text:0000B1D0 ; public: void * __thiscall CIndexToPathPair::`scalar deleting destructor'(unsigned int)
.text:0000B1D0                 public ??_GCIndexToPathPair@@QAEPAXI@Z
.text:0000B1D0 ??_GCIndexToPathPair@@QAEPAXI@Z proc near
.text:0000B1D0                                         ; CODE XREF: CObjectVector<CIndexToPathPair>::~CObjectVector<CIndexToPathPair>(void)+7Fp
.text:0000B1D0                                         ; CObjectVector<CIndexToPathPair>::Clear(void)+59p
.text:0000B1D0
.text:0000B1D0 var_4           = dword ptr -4
.text:0000B1D0 arg_0           = dword ptr  8
.text:0000B1D0
.text:0000B1D0                 push    ebp
.text:0000B1D1                 mov     ebp, esp
.text:0000B1D3                 push    ecx
.text:0000B1D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B1DB                 mov     [ebp+var_4], ecx
.text:0000B1DE                 mov     ecx, [ebp+var_4] ; this
.text:0000B1E1                 call    ??1CIndexToPathPair@@QAE@XZ ; CIndexToPathPair::~CIndexToPathPair(void)
.text:0000B1E6                 mov     eax, [ebp+arg_0]
.text:0000B1E9                 and     eax, 1
.text:0000B1EC                 jz      short loc_B1FA
.text:0000B1EE                 mov     ecx, [ebp+var_4]
.text:0000B1F1                 push    ecx             ; void *
.text:0000B1F2                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B1F7                 add     esp, 4
.text:0000B1FA
.text:0000B1FA loc_B1FA:                               ; CODE XREF: CIndexToPathPair::`scalar deleting destructor'(uint)+1Cj
.text:0000B1FA                 mov     eax, [ebp+var_4]
.text:0000B1FD                 add     esp, 4
.text:0000B200                 cmp     ebp, esp
.text:0000B202                 call    __RTC_CheckEsp
.text:0000B207                 mov     esp, ebp
.text:0000B209                 pop     ebp
.text:0000B20A                 retn    4
.text:0000B20A ??_GCIndexToPathPair@@QAEPAXI@Z endp
.text:0000B20A
.text:0000B20A ; ---------------------------------------------------------------------------
.text:0000B20D                 align 10h
.text:0000B20D _text           ends
.text:0000B20D
.text:0000B210 ; ===========================================================================
.text:0000B210
.text:0000B210 ; Segment type: Pure code
.text:0000B210 ; Segment permissions: Read/Execute
.text:0000B210 _text           segment para public 'CODE' use32
.text:0000B210                 assume cs:_text
.text:0000B210                 ;org 0B210h
.text:0000B210 ; COMDAT (pick any)
.text:0000B210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B210
.text:0000B210 ; =============== S U B R O U T I N E =======================================
.text:0000B210
.text:0000B210 ; Attributes: bp-based frame
.text:0000B210
.text:0000B210 ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000B210                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:0000B210 ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:0000B210                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(void)+11p
.text:0000B210                                         ; CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+42p ...
.text:0000B210
.text:0000B210 var_4           = dword ptr -4
.text:0000B210
.text:0000B210                 push    ebp
.text:0000B211                 mov     ebp, esp
.text:0000B213                 push    ecx
.text:0000B214                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B21B                 mov     [ebp+var_4], ecx
.text:0000B21E                 mov     eax, [ebp+var_4]
.text:0000B221                 mov     dword ptr [eax], 0
.text:0000B227                 mov     ecx, [ebp+var_4]
.text:0000B22A                 mov     dword ptr [ecx+4], 0
.text:0000B231                 mov     edx, [ebp+var_4]
.text:0000B234                 mov     dword ptr [edx+8], 0
.text:0000B23B                 mov     eax, [ebp+var_4]
.text:0000B23E                 mov     esp, ebp
.text:0000B240                 pop     ebp
.text:0000B241                 retn
.text:0000B241 ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:0000B241
.text:0000B241 ; ---------------------------------------------------------------------------
.text:0000B242                 align 4
.text:0000B242 _text           ends
.text:0000B242
.text:0000B244 ; ===========================================================================
.text:0000B244
.text:0000B244 ; Segment type: Pure code
.text:0000B244 ; Segment permissions: Read/Execute
.text:0000B244 _text           segment para public 'CODE' use32
.text:0000B244                 assume cs:_text
.text:0000B244                 ;org 0B244h
.text:0000B244 ; COMDAT (pick any)
.text:0000B244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B244
.text:0000B244 ; =============== S U B R O U T I N E =======================================
.text:0000B244
.text:0000B244 ; Attributes: bp-based frame
.text:0000B244
.text:0000B244 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:0000B244                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:0000B244 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:0000B244                                         ; CODE XREF: CObjectVector<UString>::Size(void)+11p
.text:0000B244                                         ; CObjectVector<UString>::Back(void)+11p ...
.text:0000B244
.text:0000B244 var_4           = dword ptr -4
.text:0000B244
.text:0000B244                 push    ebp
.text:0000B245                 mov     ebp, esp
.text:0000B247                 push    ecx
.text:0000B248                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B24F                 mov     [ebp+var_4], ecx
.text:0000B252                 mov     eax, [ebp+var_4]
.text:0000B255                 mov     eax, [eax+4]
.text:0000B258                 mov     esp, ebp
.text:0000B25A                 pop     ebp
.text:0000B25B                 retn
.text:0000B25B ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:0000B25B
.text:0000B25B _text           ends
.text:0000B25B
.text:0000B25C ; ===========================================================================
.text:0000B25C
.text:0000B25C ; Segment type: Pure code
.text:0000B25C ; Segment permissions: Read/Execute
.text:0000B25C _text           segment para public 'CODE' use32
.text:0000B25C                 assume cs:_text
.text:0000B25C                 ;org 0B25Ch
.text:0000B25C ; COMDAT (pick any)
.text:0000B25C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B25C
.text:0000B25C ; =============== S U B R O U T I N E =======================================
.text:0000B25C
.text:0000B25C ; Attributes: bp-based frame
.text:0000B25C
.text:0000B25C ; public: bool __thiscall CRecordVector<void *>::IsEmpty(void)const
.text:0000B25C                 public ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ
.text:0000B25C ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ proc near
.text:0000B25C                                         ; CODE XREF: CObjectVector<UString>::IsEmpty(void)+11p
.text:0000B25C
.text:0000B25C var_4           = dword ptr -4
.text:0000B25C
.text:0000B25C                 push    ebp
.text:0000B25D                 mov     ebp, esp
.text:0000B25F                 push    ecx
.text:0000B260                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B267                 mov     [ebp+var_4], ecx
.text:0000B26A                 mov     eax, [ebp+var_4]
.text:0000B26D                 xor     ecx, ecx
.text:0000B26F                 cmp     dword ptr [eax+4], 0
.text:0000B273                 setz    cl
.text:0000B276                 mov     al, cl
.text:0000B278                 mov     esp, ebp
.text:0000B27A                 pop     ebp
.text:0000B27B                 retn
.text:0000B27B ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ endp
.text:0000B27B
.text:0000B27B _text           ends
.text:0000B27B
.text:0000B27C ; ===========================================================================
.text:0000B27C
.text:0000B27C ; Segment type: Pure code
.text:0000B27C ; Segment permissions: Read/Execute
.text:0000B27C _text           segment para public 'CODE' use32
.text:0000B27C                 assume cs:_text
.text:0000B27C                 ;org 0B27Ch
.text:0000B27C ; COMDAT (pick any)
.text:0000B27C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B27C
.text:0000B27C ; =============== S U B R O U T I N E =======================================
.text:0000B27C
.text:0000B27C ; Attributes: bp-based frame
.text:0000B27C
.text:0000B27C ; public: void __thiscall CRecordVector<void *>::ConstructReserve(unsigned int)
.text:0000B27C                 public ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z
.text:0000B27C ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:0000B27C                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+60p
.text:0000B27C
.text:0000B27C var_8           = dword ptr -8
.text:0000B27C var_4           = dword ptr -4
.text:0000B27C arg_0           = dword ptr  8
.text:0000B27C
.text:0000B27C                 push    ebp
.text:0000B27D                 mov     ebp, esp
.text:0000B27F                 sub     esp, 8
.text:0000B282                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000B289                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B290                 mov     [ebp+var_4], ecx
.text:0000B293                 cmp     [ebp+arg_0], 0
.text:0000B297                 jz      short loc_B2C9
.text:0000B299                 xor     ecx, ecx
.text:0000B29B                 mov     eax, [ebp+arg_0]
.text:0000B29E                 mov     edx, 4
.text:0000B2A3                 mul     edx
.text:0000B2A5                 seto    cl
.text:0000B2A8                 neg     ecx
.text:0000B2AA                 or      ecx, eax
.text:0000B2AC                 push    ecx             ; unsigned int
.text:0000B2AD                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000B2B2                 add     esp, 4
.text:0000B2B5                 mov     [ebp+var_8], eax
.text:0000B2B8                 mov     eax, [ebp+var_4]
.text:0000B2BB                 mov     ecx, [ebp+var_8]
.text:0000B2BE                 mov     [eax], ecx
.text:0000B2C0                 mov     edx, [ebp+var_4]
.text:0000B2C3                 mov     eax, [ebp+arg_0]
.text:0000B2C6                 mov     [edx+8], eax
.text:0000B2C9
.text:0000B2C9 loc_B2C9:                               ; CODE XREF: CRecordVector<void *>::ConstructReserve(uint)+1Bj
.text:0000B2C9                 add     esp, 8
.text:0000B2CC                 cmp     ebp, esp
.text:0000B2CE                 call    __RTC_CheckEsp
.text:0000B2D3                 mov     esp, ebp
.text:0000B2D5                 pop     ebp
.text:0000B2D6                 retn    4
.text:0000B2D6 ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:0000B2D6
.text:0000B2D6 ; ---------------------------------------------------------------------------
.text:0000B2D9                 align 4
.text:0000B2D9 _text           ends
.text:0000B2D9
.text:0000B2DC ; ===========================================================================
.text:0000B2DC
.text:0000B2DC ; Segment type: Pure code
.text:0000B2DC ; Segment permissions: Read/Execute
.text:0000B2DC _text           segment para public 'CODE' use32
.text:0000B2DC                 assume cs:_text
.text:0000B2DC                 ;org 0B2DCh
.text:0000B2DC ; COMDAT (pick any)
.text:0000B2DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B2DC
.text:0000B2DC ; =============== S U B R O U T I N E =======================================
.text:0000B2DC
.text:0000B2DC ; Attributes: bp-based frame
.text:0000B2DC
.text:0000B2DC ; public: void __thiscall CRecordVector<void *>::Reserve(unsigned int)
.text:0000B2DC                 public ?Reserve@?$CRecordVector@PAX@@QAEXI@Z
.text:0000B2DC ?Reserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:0000B2DC                                         ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+69p
.text:0000B2DC
.text:0000B2DC var_10          = dword ptr -10h
.text:0000B2DC var_C           = dword ptr -0Ch
.text:0000B2DC Dst             = dword ptr -8
.text:0000B2DC var_4           = dword ptr -4
.text:0000B2DC arg_0           = dword ptr  8
.text:0000B2DC
.text:0000B2DC                 push    ebp
.text:0000B2DD                 mov     ebp, esp
.text:0000B2DF                 sub     esp, 10h
.text:0000B2E2                 mov     eax, 0CCCCCCCCh
.text:0000B2E7                 mov     [ebp+var_10], eax
.text:0000B2EA                 mov     [ebp+var_C], eax
.text:0000B2ED                 mov     [ebp+Dst], eax
.text:0000B2F0                 mov     [ebp+var_4], eax
.text:0000B2F3                 mov     [ebp+var_4], ecx
.text:0000B2F6                 mov     eax, [ebp+var_4]
.text:0000B2F9                 mov     ecx, [ebp+arg_0]
.text:0000B2FC                 cmp     ecx, [eax+8]
.text:0000B2FF                 jbe     short loc_B370
.text:0000B301                 xor     ecx, ecx
.text:0000B303                 mov     eax, [ebp+arg_0]
.text:0000B306                 mov     edx, 4
.text:0000B30B                 mul     edx
.text:0000B30D                 seto    cl
.text:0000B310                 neg     ecx
.text:0000B312                 or      ecx, eax
.text:0000B314                 push    ecx             ; unsigned int
.text:0000B315                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000B31A                 add     esp, 4
.text:0000B31D                 mov     [ebp+var_C], eax
.text:0000B320                 mov     eax, [ebp+var_C]
.text:0000B323                 mov     [ebp+Dst], eax
.text:0000B326                 mov     ecx, [ebp+var_4]
.text:0000B329                 cmp     dword ptr [ecx+4], 0
.text:0000B32D                 jz      short loc_B34B
.text:0000B32F                 mov     edx, [ebp+var_4]
.text:0000B332                 mov     eax, [edx+4]
.text:0000B335                 shl     eax, 2
.text:0000B338                 push    eax             ; Size
.text:0000B339                 mov     ecx, [ebp+var_4]
.text:0000B33C                 mov     edx, [ecx]
.text:0000B33E                 push    edx             ; Src
.text:0000B33F                 mov     eax, [ebp+Dst]
.text:0000B342                 push    eax             ; Dst
.text:0000B343                 call    _memcpy
.text:0000B348                 add     esp, 0Ch
.text:0000B34B
.text:0000B34B loc_B34B:                               ; CODE XREF: CRecordVector<void *>::Reserve(uint)+51j
.text:0000B34B                 mov     ecx, [ebp+var_4]
.text:0000B34E                 mov     edx, [ecx]
.text:0000B350                 mov     [ebp+var_10], edx
.text:0000B353                 mov     eax, [ebp+var_10]
.text:0000B356                 push    eax             ; void *
.text:0000B357                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B35C                 add     esp, 4
.text:0000B35F                 mov     ecx, [ebp+var_4]
.text:0000B362                 mov     edx, [ebp+Dst]
.text:0000B365                 mov     [ecx], edx
.text:0000B367                 mov     eax, [ebp+var_4]
.text:0000B36A                 mov     ecx, [ebp+arg_0]
.text:0000B36D                 mov     [eax+8], ecx
.text:0000B370
.text:0000B370 loc_B370:                               ; CODE XREF: CRecordVector<void *>::Reserve(uint)+23j
.text:0000B370                 add     esp, 10h
.text:0000B373                 cmp     ebp, esp
.text:0000B375                 call    __RTC_CheckEsp
.text:0000B37A                 mov     esp, ebp
.text:0000B37C                 pop     ebp
.text:0000B37D                 retn    4
.text:0000B37D ?Reserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:0000B37D
.text:0000B37D _text           ends
.text:0000B37D
.text:0000B380 ; ===========================================================================
.text:0000B380
.text:0000B380 ; Segment type: Pure code
.text:0000B380 ; Segment permissions: Read/Execute
.text:0000B380 _text           segment para public 'CODE' use32
.text:0000B380                 assume cs:_text
.text:0000B380                 ;org 0B380h
.text:0000B380 ; COMDAT (pick any)
.text:0000B380                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B380
.text:0000B380 ; =============== S U B R O U T I N E =======================================
.text:0000B380
.text:0000B380 ; Attributes: bp-based frame
.text:0000B380
.text:0000B380 ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000B380                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:0000B380 ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:0000B380                                         ; CODE XREF: __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0+3j
.text:0000B380                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+9Cp ...
.text:0000B380
.text:0000B380 var_8           = dword ptr -8
.text:0000B380 var_4           = dword ptr -4
.text:0000B380
.text:0000B380                 push    ebp
.text:0000B381                 mov     ebp, esp
.text:0000B383                 sub     esp, 8
.text:0000B386                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000B38D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B394                 mov     [ebp+var_4], ecx
.text:0000B397                 mov     eax, [ebp+var_4]
.text:0000B39A                 mov     ecx, [eax]
.text:0000B39C                 mov     [ebp+var_8], ecx
.text:0000B39F                 mov     edx, [ebp+var_8]
.text:0000B3A2                 push    edx             ; void *
.text:0000B3A3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B3A8                 add     esp, 4
.text:0000B3AB                 add     esp, 8
.text:0000B3AE                 cmp     ebp, esp
.text:0000B3B0                 call    __RTC_CheckEsp
.text:0000B3B5                 mov     esp, ebp
.text:0000B3B7                 pop     ebp
.text:0000B3B8                 retn
.text:0000B3B8 ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:0000B3B8
.text:0000B3B8 ; ---------------------------------------------------------------------------
.text:0000B3B9                 align 4
.text:0000B3B9 _text           ends
.text:0000B3B9
.text:0000B3BC ; ===========================================================================
.text:0000B3BC
.text:0000B3BC ; Segment type: Pure code
.text:0000B3BC ; Segment permissions: Read/Execute
.text:0000B3BC _text           segment para public 'CODE' use32
.text:0000B3BC                 assume cs:_text
.text:0000B3BC                 ;org 0B3BCh
.text:0000B3BC ; COMDAT (pick any)
.text:0000B3BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B3BC
.text:0000B3BC ; =============== S U B R O U T I N E =======================================
.text:0000B3BC
.text:0000B3BC ; Attributes: bp-based frame
.text:0000B3BC
.text:0000B3BC ; public: void __thiscall CRecordVector<void *>::Clear(void)
.text:0000B3BC                 public ?Clear@?$CRecordVector@PAX@@QAEXXZ
.text:0000B3BC ?Clear@?$CRecordVector@PAX@@QAEXXZ proc near
.text:0000B3BC                                         ; CODE XREF: CObjectVector<UString>::Clear(void)+6Fp
.text:0000B3BC                                         ; CObjectVector<CIndexToPathPair>::Clear(void)+6Fp
.text:0000B3BC
.text:0000B3BC var_4           = dword ptr -4
.text:0000B3BC
.text:0000B3BC                 push    ebp
.text:0000B3BD                 mov     ebp, esp
.text:0000B3BF                 push    ecx
.text:0000B3C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B3C7                 mov     [ebp+var_4], ecx
.text:0000B3CA                 mov     eax, [ebp+var_4]
.text:0000B3CD                 mov     dword ptr [eax+4], 0
.text:0000B3D4                 mov     esp, ebp
.text:0000B3D6                 pop     ebp
.text:0000B3D7                 retn
.text:0000B3D7 ?Clear@?$CRecordVector@PAX@@QAEXXZ endp
.text:0000B3D7
.text:0000B3D7 _text           ends
.text:0000B3D7
.text:0000B3D8 ; ===========================================================================
.text:0000B3D8
.text:0000B3D8 ; Segment type: Pure code
.text:0000B3D8 ; Segment permissions: Read/Execute
.text:0000B3D8 _text           segment para public 'CODE' use32
.text:0000B3D8                 assume cs:_text
.text:0000B3D8                 ;org 0B3D8h
.text:0000B3D8 ; COMDAT (pick any)
.text:0000B3D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B3D8
.text:0000B3D8 ; =============== S U B R O U T I N E =======================================
.text:0000B3D8
.text:0000B3D8 ; Attributes: bp-based frame
.text:0000B3D8
.text:0000B3D8 ; public: void __thiscall CRecordVector<void *>::DeleteBack(void)
.text:0000B3D8                 public ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ
.text:0000B3D8 ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ proc near
.text:0000B3D8                                         ; CODE XREF: CObjectVector<UString>::DeleteBack(void)+58p
.text:0000B3D8
.text:0000B3D8 var_4           = dword ptr -4
.text:0000B3D8
.text:0000B3D8                 push    ebp
.text:0000B3D9                 mov     ebp, esp
.text:0000B3DB                 push    ecx
.text:0000B3DC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B3E3                 mov     [ebp+var_4], ecx
.text:0000B3E6                 mov     eax, [ebp+var_4]
.text:0000B3E9                 mov     ecx, [eax+4]
.text:0000B3EC                 sub     ecx, 1
.text:0000B3EF                 mov     edx, [ebp+var_4]
.text:0000B3F2                 mov     [edx+4], ecx
.text:0000B3F5                 mov     esp, ebp
.text:0000B3F7                 pop     ebp
.text:0000B3F8                 retn
.text:0000B3F8 ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ endp
.text:0000B3F8
.text:0000B3F8 ; ---------------------------------------------------------------------------
.text:0000B3F9                 align 4
.text:0000B3F9 _text           ends
.text:0000B3F9
.text:0000B3FC ; ===========================================================================
.text:0000B3FC
.text:0000B3FC ; Segment type: Pure code
.text:0000B3FC ; Segment permissions: Read/Execute
.text:0000B3FC _text           segment para public 'CODE' use32
.text:0000B3FC                 assume cs:_text
.text:0000B3FC                 ;org 0B3FCh
.text:0000B3FC ; COMDAT (pick any)
.text:0000B3FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B3FC
.text:0000B3FC ; =============== S U B R O U T I N E =======================================
.text:0000B3FC
.text:0000B3FC ; Attributes: bp-based frame
.text:0000B3FC
.text:0000B3FC ; public: void __thiscall CRecordVector<void *>::DeleteFrontal(unsigned int)
.text:0000B3FC                 public ?DeleteFrontal@?$CRecordVector@PAX@@QAEXI@Z
.text:0000B3FC ?DeleteFrontal@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:0000B3FC                                         ; CODE XREF: CObjectVector<UString>::DeleteFrontal(uint)+73p
.text:0000B3FC
.text:0000B3FC var_4           = dword ptr -4
.text:0000B3FC arg_0           = dword ptr  8
.text:0000B3FC
.text:0000B3FC                 push    ebp
.text:0000B3FD                 mov     ebp, esp
.text:0000B3FF                 push    ecx
.text:0000B400                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B407                 mov     [ebp+var_4], ecx
.text:0000B40A                 cmp     [ebp+arg_0], 0
.text:0000B40E                 jz      short loc_B42D
.text:0000B410                 mov     eax, [ebp+arg_0]
.text:0000B413                 push    eax
.text:0000B414                 push    0
.text:0000B416                 mov     ecx, [ebp+var_4]
.text:0000B419                 call    ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z ; CRecordVector<void *>::MoveItems(uint,uint)
.text:0000B41E                 mov     ecx, [ebp+var_4]
.text:0000B421                 mov     edx, [ecx+4]
.text:0000B424                 sub     edx, [ebp+arg_0]
.text:0000B427                 mov     eax, [ebp+var_4]
.text:0000B42A                 mov     [eax+4], edx
.text:0000B42D
.text:0000B42D loc_B42D:                               ; CODE XREF: CRecordVector<void *>::DeleteFrontal(uint)+12j
.text:0000B42D                 add     esp, 4
.text:0000B430                 cmp     ebp, esp
.text:0000B432                 call    __RTC_CheckEsp
.text:0000B437                 mov     esp, ebp
.text:0000B439                 pop     ebp
.text:0000B43A                 retn    4
.text:0000B43A ?DeleteFrontal@?$CRecordVector@PAX@@QAEXI@Z endp
.text:0000B43A
.text:0000B43A ; ---------------------------------------------------------------------------
.text:0000B43D                 align 10h
.text:0000B43D _text           ends
.text:0000B43D
.text:0000B440 ; ===========================================================================
.text:0000B440
.text:0000B440 ; Segment type: Pure code
.text:0000B440 ; Segment permissions: Read/Execute
.text:0000B440 _text           segment para public 'CODE' use32
.text:0000B440                 assume cs:_text
.text:0000B440                 ;org 0B440h
.text:0000B440 ; COMDAT (pick any)
.text:0000B440                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B440
.text:0000B440 ; =============== S U B R O U T I N E =======================================
.text:0000B440
.text:0000B440 ; Attributes: bp-based frame
.text:0000B440
.text:0000B440 ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:0000B440                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:0000B440 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:0000B440                                         ; CODE XREF: CObjectVector<UString>::Add(UString const &)+7Fp
.text:0000B440                                         ; CObjectVector<UString>::AddNew(void)+84p
.text:0000B440
.text:0000B440 var_8           = dword ptr -8
.text:0000B440 var_4           = dword ptr -4
.text:0000B440 arg_0           = dword ptr  8
.text:0000B440
.text:0000B440                 push    ebp
.text:0000B441                 mov     ebp, esp
.text:0000B443                 sub     esp, 8
.text:0000B446                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000B44D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B454                 mov     [ebp+var_4], ecx
.text:0000B457                 mov     ecx, [ebp+var_4]
.text:0000B45A                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:0000B45F                 mov     eax, [ebp+var_4]
.text:0000B462                 mov     ecx, [eax+4]
.text:0000B465                 mov     edx, [ebp+var_4]
.text:0000B468                 mov     eax, [edx]
.text:0000B46A                 mov     edx, [ebp+arg_0]
.text:0000B46D                 mov     [eax+ecx*4], edx
.text:0000B470                 mov     eax, [ebp+var_4]
.text:0000B473                 mov     ecx, [eax+4]
.text:0000B476                 mov     [ebp+var_8], ecx
.text:0000B479                 mov     edx, [ebp+var_4]
.text:0000B47C                 mov     eax, [edx+4]
.text:0000B47F                 add     eax, 1
.text:0000B482                 mov     ecx, [ebp+var_4]
.text:0000B485                 mov     [ecx+4], eax
.text:0000B488                 mov     eax, [ebp+var_8]
.text:0000B48B                 add     esp, 8
.text:0000B48E                 cmp     ebp, esp
.text:0000B490                 call    __RTC_CheckEsp
.text:0000B495                 mov     esp, ebp
.text:0000B497                 pop     ebp
.text:0000B498                 retn    4
.text:0000B498 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:0000B498
.text:0000B498 ; ---------------------------------------------------------------------------
.text:0000B49B                 align 4
.text:0000B49B _text           ends
.text:0000B49B
.text:0000B49C ; ===========================================================================
.text:0000B49C
.text:0000B49C ; Segment type: Pure code
.text:0000B49C ; Segment permissions: Read/Execute
.text:0000B49C _text           segment para public 'CODE' use32
.text:0000B49C                 assume cs:_text
.text:0000B49C                 ;org 0B49Ch
.text:0000B49C ; COMDAT (pick any)
.text:0000B49C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B49C
.text:0000B49C ; =============== S U B R O U T I N E =======================================
.text:0000B49C
.text:0000B49C ; Attributes: bp-based frame
.text:0000B49C
.text:0000B49C ; public: void __thiscall CRecordVector<void *>::AddInReserved(void * const)
.text:0000B49C                 public ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z
.text:0000B49C ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z proc near
.text:0000B49C                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+C8p
.text:0000B49C                                         ; CObjectVector<UString>::operator=(CObjectVector<UString> const &)+D7p
.text:0000B49C
.text:0000B49C var_4           = dword ptr -4
.text:0000B49C arg_0           = dword ptr  8
.text:0000B49C
.text:0000B49C                 push    ebp
.text:0000B49D                 mov     ebp, esp
.text:0000B49F                 push    ecx
.text:0000B4A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B4A7                 mov     [ebp+var_4], ecx
.text:0000B4AA                 mov     eax, [ebp+var_4]
.text:0000B4AD                 mov     ecx, [eax+4]
.text:0000B4B0                 mov     edx, [ebp+var_4]
.text:0000B4B3                 mov     eax, [edx]
.text:0000B4B5                 mov     edx, [ebp+arg_0]
.text:0000B4B8                 mov     [eax+ecx*4], edx
.text:0000B4BB                 mov     eax, [ebp+var_4]
.text:0000B4BE                 mov     ecx, [eax+4]
.text:0000B4C1                 add     ecx, 1
.text:0000B4C4                 mov     edx, [ebp+var_4]
.text:0000B4C7                 mov     [edx+4], ecx
.text:0000B4CA                 mov     esp, ebp
.text:0000B4CC                 pop     ebp
.text:0000B4CD                 retn    4
.text:0000B4CD ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z endp
.text:0000B4CD
.text:0000B4CD _text           ends
.text:0000B4CD
.text:0000B4D0 ; ===========================================================================
.text:0000B4D0
.text:0000B4D0 ; Segment type: Pure code
.text:0000B4D0 ; Segment permissions: Read/Execute
.text:0000B4D0 _text           segment para public 'CODE' use32
.text:0000B4D0                 assume cs:_text
.text:0000B4D0                 ;org 0B4D0h
.text:0000B4D0 ; COMDAT (pick any)
.text:0000B4D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B4D0
.text:0000B4D0 ; =============== S U B R O U T I N E =======================================
.text:0000B4D0
.text:0000B4D0 ; Attributes: bp-based frame
.text:0000B4D0
.text:0000B4D0 ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:0000B4D0                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:0000B4D0 ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:0000B4D0                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:0000B4D0                                         ; CObjectVector<CIndexToPathPair>::operator[](uint)+15p
.text:0000B4D0
.text:0000B4D0 var_4           = dword ptr -4
.text:0000B4D0 arg_0           = dword ptr  8
.text:0000B4D0
.text:0000B4D0                 push    ebp
.text:0000B4D1                 mov     ebp, esp
.text:0000B4D3                 push    ecx
.text:0000B4D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B4DB                 mov     [ebp+var_4], ecx
.text:0000B4DE                 mov     eax, [ebp+var_4]
.text:0000B4E1                 mov     ecx, [eax]
.text:0000B4E3                 mov     edx, [ebp+arg_0]
.text:0000B4E6                 lea     eax, [ecx+edx*4]
.text:0000B4E9                 mov     esp, ebp
.text:0000B4EB                 pop     ebp
.text:0000B4EC                 retn    4
.text:0000B4EC ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:0000B4EC
.text:0000B4EC ; ---------------------------------------------------------------------------
.text:0000B4EF                 align 10h
.text:0000B4EF _text           ends
.text:0000B4EF
.text:0000B4F0 ; ===========================================================================
.text:0000B4F0
.text:0000B4F0 ; Segment type: Pure code
.text:0000B4F0 ; Segment permissions: Read/Execute
.text:0000B4F0 _text           segment para public 'CODE' use32
.text:0000B4F0                 assume cs:_text
.text:0000B4F0                 ;org 0B4F0h
.text:0000B4F0 ; COMDAT (pick any)
.text:0000B4F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B4F0
.text:0000B4F0 ; =============== S U B R O U T I N E =======================================
.text:0000B4F0
.text:0000B4F0 ; Attributes: bp-based frame
.text:0000B4F0
.text:0000B4F0 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:0000B4F0                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:0000B4F0 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:0000B4F0                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:0000B4F0                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+64p ...
.text:0000B4F0
.text:0000B4F0 var_4           = dword ptr -4
.text:0000B4F0 arg_0           = dword ptr  8
.text:0000B4F0
.text:0000B4F0                 push    ebp
.text:0000B4F1                 mov     ebp, esp
.text:0000B4F3                 push    ecx
.text:0000B4F4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B4FB                 mov     [ebp+var_4], ecx
.text:0000B4FE                 mov     eax, [ebp+var_4]
.text:0000B501                 mov     ecx, [eax]
.text:0000B503                 mov     edx, [ebp+arg_0]
.text:0000B506                 lea     eax, [ecx+edx*4]
.text:0000B509                 mov     esp, ebp
.text:0000B50B                 pop     ebp
.text:0000B50C                 retn    4
.text:0000B50C ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:0000B50C
.text:0000B50C ; ---------------------------------------------------------------------------
.text:0000B50F                 align 10h
.text:0000B50F _text           ends
.text:0000B50F
.text:0000B510 ; ===========================================================================
.text:0000B510
.text:0000B510 ; Segment type: Pure code
.text:0000B510 ; Segment permissions: Read/Execute
.text:0000B510 _text           segment para public 'CODE' use32
.text:0000B510                 assume cs:_text
.text:0000B510                 ;org 0B510h
.text:0000B510 ; COMDAT (pick any)
.text:0000B510                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B510
.text:0000B510 ; =============== S U B R O U T I N E =======================================
.text:0000B510
.text:0000B510 ; Attributes: bp-based frame
.text:0000B510
.text:0000B510 ; private: void __thiscall CRecordVector<unsigned int>::ReserveOnePosition(void)
.text:0000B510                 public ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ
.text:0000B510 ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ proc near
.text:0000B510                                         ; CODE XREF: CRecordVector<uint>::Add(uint)+1Ap
.text:0000B510
.text:0000B510 var_14          = dword ptr -14h
.text:0000B510 var_10          = dword ptr -10h
.text:0000B510 Dst             = dword ptr -0Ch
.text:0000B510 var_8           = dword ptr -8
.text:0000B510 var_4           = dword ptr -4
.text:0000B510
.text:0000B510                 push    ebp
.text:0000B511                 mov     ebp, esp
.text:0000B513                 sub     esp, 14h
.text:0000B516                 mov     eax, 0CCCCCCCCh
.text:0000B51B                 mov     [ebp+var_14], eax
.text:0000B51E                 mov     [ebp+var_10], eax
.text:0000B521                 mov     [ebp+Dst], eax
.text:0000B524                 mov     [ebp+var_8], eax
.text:0000B527                 mov     [ebp+var_4], eax
.text:0000B52A                 mov     [ebp+var_4], ecx
.text:0000B52D                 mov     eax, [ebp+var_4]
.text:0000B530                 mov     ecx, [ebp+var_4]
.text:0000B533                 mov     edx, [eax+4]
.text:0000B536                 cmp     edx, [ecx+8]
.text:0000B539                 jnz     loc_B5C4
.text:0000B53F                 mov     eax, [ebp+var_4]
.text:0000B542                 mov     ecx, [eax+8]
.text:0000B545                 shr     ecx, 2
.text:0000B548                 mov     edx, [ebp+var_4]
.text:0000B54B                 mov     eax, [edx+8]
.text:0000B54E                 lea     ecx, [eax+ecx+1]
.text:0000B552                 mov     [ebp+var_8], ecx
.text:0000B555                 xor     ecx, ecx
.text:0000B557                 mov     eax, [ebp+var_8]
.text:0000B55A                 mov     edx, 4
.text:0000B55F                 mul     edx
.text:0000B561                 seto    cl
.text:0000B564                 neg     ecx
.text:0000B566                 or      ecx, eax
.text:0000B568                 push    ecx             ; unsigned int
.text:0000B569                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000B56E                 add     esp, 4
.text:0000B571                 mov     [ebp+var_10], eax
.text:0000B574                 mov     eax, [ebp+var_10]
.text:0000B577                 mov     [ebp+Dst], eax
.text:0000B57A                 mov     ecx, [ebp+var_4]
.text:0000B57D                 cmp     dword ptr [ecx+4], 0
.text:0000B581                 jz      short loc_B59F
.text:0000B583                 mov     edx, [ebp+var_4]
.text:0000B586                 mov     eax, [edx+4]
.text:0000B589                 shl     eax, 2
.text:0000B58C                 push    eax             ; Size
.text:0000B58D                 mov     ecx, [ebp+var_4]
.text:0000B590                 mov     edx, [ecx]
.text:0000B592                 push    edx             ; Src
.text:0000B593                 mov     eax, [ebp+Dst]
.text:0000B596                 push    eax             ; Dst
.text:0000B597                 call    _memcpy
.text:0000B59C                 add     esp, 0Ch
.text:0000B59F
.text:0000B59F loc_B59F:                               ; CODE XREF: CRecordVector<uint>::ReserveOnePosition(void)+71j
.text:0000B59F                 mov     ecx, [ebp+var_4]
.text:0000B5A2                 mov     edx, [ecx]
.text:0000B5A4                 mov     [ebp+var_14], edx
.text:0000B5A7                 mov     eax, [ebp+var_14]
.text:0000B5AA                 push    eax             ; void *
.text:0000B5AB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B5B0                 add     esp, 4
.text:0000B5B3                 mov     ecx, [ebp+var_4]
.text:0000B5B6                 mov     edx, [ebp+Dst]
.text:0000B5B9                 mov     [ecx], edx
.text:0000B5BB                 mov     eax, [ebp+var_4]
.text:0000B5BE                 mov     ecx, [ebp+var_8]
.text:0000B5C1                 mov     [eax+8], ecx
.text:0000B5C4
.text:0000B5C4 loc_B5C4:                               ; CODE XREF: CRecordVector<uint>::ReserveOnePosition(void)+29j
.text:0000B5C4                 add     esp, 14h
.text:0000B5C7                 cmp     ebp, esp
.text:0000B5C9                 call    __RTC_CheckEsp
.text:0000B5CE                 mov     esp, ebp
.text:0000B5D0                 pop     ebp
.text:0000B5D1                 retn
.text:0000B5D1 ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ endp
.text:0000B5D1
.text:0000B5D1 ; ---------------------------------------------------------------------------
.text:0000B5D2                 align 4
.text:0000B5D2 _text           ends
.text:0000B5D2
.text:0000B5D4 ; ===========================================================================
.text:0000B5D4
.text:0000B5D4 ; Segment type: Pure code
.text:0000B5D4 ; Segment permissions: Read/Execute
.text:0000B5D4 _text           segment para public 'CODE' use32
.text:0000B5D4                 assume cs:_text
.text:0000B5D4                 ;org 0B5D4h
.text:0000B5D4 ; COMDAT (pick any)
.text:0000B5D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B5D4
.text:0000B5D4 ; =============== S U B R O U T I N E =======================================
.text:0000B5D4
.text:0000B5D4 ; Attributes: bp-based frame
.text:0000B5D4
.text:0000B5D4 ; private: void __thiscall CRecordVector<struct CHardLinkNode>::ReserveOnePosition(void)
.text:0000B5D4                 public ?ReserveOnePosition@?$CRecordVector@UCHardLinkNode@@@@AAEXXZ
.text:0000B5D4 ?ReserveOnePosition@?$CRecordVector@UCHardLinkNode@@@@AAEXXZ proc near
.text:0000B5D4                                         ; CODE XREF: CRecordVector<CHardLinkNode>::Add(CHardLinkNode)+20p
.text:0000B5D4
.text:0000B5D4 var_14          = dword ptr -14h
.text:0000B5D4 var_10          = dword ptr -10h
.text:0000B5D4 Dst             = dword ptr -0Ch
.text:0000B5D4 var_8           = dword ptr -8
.text:0000B5D4 var_4           = dword ptr -4
.text:0000B5D4
.text:0000B5D4                 push    ebp
.text:0000B5D5                 mov     ebp, esp
.text:0000B5D7                 sub     esp, 14h
.text:0000B5DA                 mov     eax, 0CCCCCCCCh
.text:0000B5DF                 mov     [ebp+var_14], eax
.text:0000B5E2                 mov     [ebp+var_10], eax
.text:0000B5E5                 mov     [ebp+Dst], eax
.text:0000B5E8                 mov     [ebp+var_8], eax
.text:0000B5EB                 mov     [ebp+var_4], eax
.text:0000B5EE                 mov     [ebp+var_4], ecx
.text:0000B5F1                 mov     eax, [ebp+var_4]
.text:0000B5F4                 mov     ecx, [ebp+var_4]
.text:0000B5F7                 mov     edx, [eax+4]
.text:0000B5FA                 cmp     edx, [ecx+8]
.text:0000B5FD                 jnz     loc_B688
.text:0000B603                 mov     eax, [ebp+var_4]
.text:0000B606                 mov     ecx, [eax+8]
.text:0000B609                 shr     ecx, 2
.text:0000B60C                 mov     edx, [ebp+var_4]
.text:0000B60F                 mov     eax, [edx+8]
.text:0000B612                 lea     ecx, [eax+ecx+1]
.text:0000B616                 mov     [ebp+var_8], ecx
.text:0000B619                 xor     ecx, ecx
.text:0000B61B                 mov     eax, [ebp+var_8]
.text:0000B61E                 mov     edx, 10h
.text:0000B623                 mul     edx
.text:0000B625                 seto    cl
.text:0000B628                 neg     ecx
.text:0000B62A                 or      ecx, eax
.text:0000B62C                 push    ecx             ; unsigned int
.text:0000B62D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000B632                 add     esp, 4
.text:0000B635                 mov     [ebp+var_10], eax
.text:0000B638                 mov     eax, [ebp+var_10]
.text:0000B63B                 mov     [ebp+Dst], eax
.text:0000B63E                 mov     ecx, [ebp+var_4]
.text:0000B641                 cmp     dword ptr [ecx+4], 0
.text:0000B645                 jz      short loc_B663
.text:0000B647                 mov     edx, [ebp+var_4]
.text:0000B64A                 mov     eax, [edx+4]
.text:0000B64D                 shl     eax, 4
.text:0000B650                 push    eax             ; Size
.text:0000B651                 mov     ecx, [ebp+var_4]
.text:0000B654                 mov     edx, [ecx]
.text:0000B656                 push    edx             ; Src
.text:0000B657                 mov     eax, [ebp+Dst]
.text:0000B65A                 push    eax             ; Dst
.text:0000B65B                 call    _memcpy
.text:0000B660                 add     esp, 0Ch
.text:0000B663
.text:0000B663 loc_B663:                               ; CODE XREF: CRecordVector<CHardLinkNode>::ReserveOnePosition(void)+71j
.text:0000B663                 mov     ecx, [ebp+var_4]
.text:0000B666                 mov     edx, [ecx]
.text:0000B668                 mov     [ebp+var_14], edx
.text:0000B66B                 mov     eax, [ebp+var_14]
.text:0000B66E                 push    eax             ; void *
.text:0000B66F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B674                 add     esp, 4
.text:0000B677                 mov     ecx, [ebp+var_4]
.text:0000B67A                 mov     edx, [ebp+Dst]
.text:0000B67D                 mov     [ecx], edx
.text:0000B67F                 mov     eax, [ebp+var_4]
.text:0000B682                 mov     ecx, [ebp+var_8]
.text:0000B685                 mov     [eax+8], ecx
.text:0000B688
.text:0000B688 loc_B688:                               ; CODE XREF: CRecordVector<CHardLinkNode>::ReserveOnePosition(void)+29j
.text:0000B688                 add     esp, 14h
.text:0000B68B                 cmp     ebp, esp
.text:0000B68D                 call    __RTC_CheckEsp
.text:0000B692                 mov     esp, ebp
.text:0000B694                 pop     ebp
.text:0000B695                 retn
.text:0000B695 ?ReserveOnePosition@?$CRecordVector@UCHardLinkNode@@@@AAEXXZ endp
.text:0000B695
.text:0000B695 ; ---------------------------------------------------------------------------
.text:0000B696                 align 4
.text:0000B696 _text           ends
.text:0000B696
.text:0000B698 ; ===========================================================================
.text:0000B698
.text:0000B698 ; Segment type: Pure code
.text:0000B698 ; Segment permissions: Read/Execute
.text:0000B698 _text           segment para public 'CODE' use32
.text:0000B698                 assume cs:_text
.text:0000B698                 ;org 0B698h
.text:0000B698 ; COMDAT (pick any)
.text:0000B698                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B698
.text:0000B698 ; =============== S U B R O U T I N E =======================================
.text:0000B698
.text:0000B698 ; Attributes: bp-based frame
.text:0000B698
.text:0000B698 ; public: struct CHardLinkNode & __thiscall CRecordVector<struct CHardLinkNode>::Front(void)
.text:0000B698                 public ?Front@?$CRecordVector@UCHardLinkNode@@@@QAEAAUCHardLinkNode@@XZ
.text:0000B698 ?Front@?$CRecordVector@UCHardLinkNode@@@@QAEAAUCHardLinkNode@@XZ proc near
.text:0000B698                                         ; CODE XREF: CRecordVector<CHardLinkNode>::Sort2(void)+3Cp
.text:0000B698
.text:0000B698 var_4           = dword ptr -4
.text:0000B698
.text:0000B698                 push    ebp
.text:0000B699                 mov     ebp, esp
.text:0000B69B                 push    ecx
.text:0000B69C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B6A3                 mov     [ebp+var_4], ecx
.text:0000B6A6                 mov     eax, [ebp+var_4]
.text:0000B6A9                 mov     eax, [eax]
.text:0000B6AB                 mov     esp, ebp
.text:0000B6AD                 pop     ebp
.text:0000B6AE                 retn
.text:0000B6AE ?Front@?$CRecordVector@UCHardLinkNode@@@@QAEAAUCHardLinkNode@@XZ endp
.text:0000B6AE
.text:0000B6AE ; ---------------------------------------------------------------------------
.text:0000B6AF                 align 10h
.text:0000B6AF _text           ends
.text:0000B6AF
.text:0000B6B0 ; ===========================================================================
.text:0000B6B0
.text:0000B6B0 ; Segment type: Pure code
.text:0000B6B0 ; Segment permissions: Read/Execute
.text:0000B6B0 _text           segment para public 'CODE' use32
.text:0000B6B0                 assume cs:_text
.text:0000B6B0                 ;org 0B6B0h
.text:0000B6B0 ; COMDAT (pick any)
.text:0000B6B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B6B0
.text:0000B6B0 ; =============== S U B R O U T I N E =======================================
.text:0000B6B0
.text:0000B6B0 ; Attributes: bp-based frame
.text:0000B6B0
.text:0000B6B0 ; int __stdcall CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode *, int, int)
.text:0000B6B0                 public ?FindInSorted2@?$CRecordVector@UCHardLinkNode@@@@QBEHABUCHardLinkNode@@II@Z
.text:0000B6B0 ?FindInSorted2@?$CRecordVector@UCHardLinkNode@@@@QBEHABUCHardLinkNode@@II@Z proc near
.text:0000B6B0                                         ; CODE XREF: CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode const &)+1Ep
.text:0000B6B0
.text:0000B6B0 var_10          = dword ptr -10h
.text:0000B6B0 var_C           = dword ptr -0Ch
.text:0000B6B0 var_8           = dword ptr -8
.text:0000B6B0 var_4           = dword ptr -4
.text:0000B6B0 arg_0           = dword ptr  8
.text:0000B6B0 arg_4           = dword ptr  0Ch
.text:0000B6B0 arg_8           = dword ptr  10h
.text:0000B6B0
.text:0000B6B0                 push    ebp
.text:0000B6B1                 mov     ebp, esp
.text:0000B6B3                 sub     esp, 10h
.text:0000B6B6                 mov     eax, 0CCCCCCCCh
.text:0000B6BB                 mov     [ebp+var_10], eax
.text:0000B6BE                 mov     [ebp+var_C], eax
.text:0000B6C1                 mov     [ebp+var_8], eax
.text:0000B6C4                 mov     [ebp+var_4], eax
.text:0000B6C7                 mov     [ebp+var_4], ecx
.text:0000B6CA
.text:0000B6CA loc_B6CA:                               ; CODE XREF: CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode const &,uint,uint):loc_B71Dj
.text:0000B6CA                 mov     eax, [ebp+arg_4]
.text:0000B6CD                 cmp     eax, [ebp+arg_8]
.text:0000B6D0                 jz      short loc_B71F
.text:0000B6D2                 mov     ecx, [ebp+arg_4]
.text:0000B6D5                 add     ecx, [ebp+arg_8]
.text:0000B6D8                 shr     ecx, 1
.text:0000B6DA                 mov     [ebp+var_8], ecx
.text:0000B6DD                 mov     edx, [ebp+var_8]
.text:0000B6E0                 push    edx
.text:0000B6E1                 mov     ecx, [ebp+var_4]
.text:0000B6E4                 call    ??A?$CRecordVector@UCHardLinkNode@@@@QBEABUCHardLinkNode@@I@Z ; CRecordVector<CHardLinkNode>::operator[](uint)
.text:0000B6E9                 mov     [ebp+var_C], eax
.text:0000B6EC                 mov     eax, [ebp+var_C]
.text:0000B6EF                 push    eax             ; struct CHardLinkNode *
.text:0000B6F0                 mov     ecx, [ebp+arg_0] ; this
.text:0000B6F3                 call    ?Compare@CHardLinkNode@@QBEHABU1@@Z ; CHardLinkNode::Compare(CHardLinkNode const &)
.text:0000B6F8                 mov     [ebp+var_10], eax
.text:0000B6FB                 cmp     [ebp+var_10], 0
.text:0000B6FF                 jnz     short loc_B706
.text:0000B701                 mov     eax, [ebp+var_8]
.text:0000B704                 jmp     short loc_B722
.text:0000B706 ; ---------------------------------------------------------------------------
.text:0000B706
.text:0000B706 loc_B706:                               ; CODE XREF: CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode const &,uint,uint)+4Fj
.text:0000B706                 cmp     [ebp+var_10], 0
.text:0000B70A                 jge     short loc_B714
.text:0000B70C                 mov     ecx, [ebp+var_8]
.text:0000B70F                 mov     [ebp+arg_8], ecx
.text:0000B712                 jmp     short loc_B71D
.text:0000B714 ; ---------------------------------------------------------------------------
.text:0000B714
.text:0000B714 loc_B714:                               ; CODE XREF: CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode const &,uint,uint)+5Aj
.text:0000B714                 mov     edx, [ebp+var_8]
.text:0000B717                 add     edx, 1
.text:0000B71A                 mov     [ebp+arg_4], edx
.text:0000B71D
.text:0000B71D loc_B71D:                               ; CODE XREF: CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode const &,uint,uint)+62j
.text:0000B71D                 jmp     short loc_B6CA
.text:0000B71F ; ---------------------------------------------------------------------------
.text:0000B71F
.text:0000B71F loc_B71F:                               ; CODE XREF: CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode const &,uint,uint)+20j
.text:0000B71F                 or      eax, 0FFFFFFFFh
.text:0000B722
.text:0000B722 loc_B722:                               ; CODE XREF: CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode const &,uint,uint)+54j
.text:0000B722                 add     esp, 10h
.text:0000B725                 cmp     ebp, esp
.text:0000B727                 call    __RTC_CheckEsp
.text:0000B72C                 mov     esp, ebp
.text:0000B72E                 pop     ebp
.text:0000B72F                 retn    0Ch
.text:0000B72F ?FindInSorted2@?$CRecordVector@UCHardLinkNode@@@@QBEHABUCHardLinkNode@@II@Z endp
.text:0000B72F
.text:0000B72F ; ---------------------------------------------------------------------------
.text:0000B732                 align 4
.text:0000B732 _text           ends
.text:0000B732
.text:0000B734 ; ===========================================================================
.text:0000B734
.text:0000B734 ; Segment type: Pure code
.text:0000B734 ; Segment permissions: Read/Execute
.text:0000B734 _text           segment para public 'CODE' use32
.text:0000B734                 assume cs:_text
.text:0000B734                 ;org 0B734h
.text:0000B734 ; COMDAT (pick any)
.text:0000B734                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B734
.text:0000B734 ; =============== S U B R O U T I N E =======================================
.text:0000B734
.text:0000B734 ; Attributes: bp-based frame
.text:0000B734
.text:0000B734 ; public: static void __stdcall CRecordVector<struct CHardLinkNode>::SortRefDown2(struct CHardLinkNode *, unsigned int, unsigned int)
.text:0000B734                 public ?SortRefDown2@?$CRecordVector@UCHardLinkNode@@@@SGXPAUCHardLinkNode@@II@Z
.text:0000B734 ?SortRefDown2@?$CRecordVector@UCHardLinkNode@@@@SGXPAUCHardLinkNode@@II@Z proc near
.text:0000B734                                         ; CODE XREF: CRecordVector<CHardLinkNode>::Sort2(void)+5Bp
.text:0000B734                                         ; CRecordVector<CHardLinkNode>::Sort2(void)+E0p
.text:0000B734
.text:0000B734 var_20          = dword ptr -20h
.text:0000B734 var_1C          = dword ptr -1Ch
.text:0000B734 var_18          = dword ptr -18h
.text:0000B734 var_14          = dword ptr -14h
.text:0000B734 var_10          = dword ptr -10h
.text:0000B734 var_C           = dword ptr -0Ch
.text:0000B734 var_8           = dword ptr -8
.text:0000B734 var_4           = dword ptr -4
.text:0000B734 arg_0           = dword ptr  8
.text:0000B734 arg_4           = dword ptr  0Ch
.text:0000B734 arg_8           = dword ptr  10h
.text:0000B734
.text:0000B734                 push    ebp
.text:0000B735                 mov     ebp, esp
.text:0000B737                 sub     esp, 20h
.text:0000B73A                 mov     eax, 0CCCCCCCCh
.text:0000B73F                 mov     [ebp+var_20], eax
.text:0000B742                 mov     [ebp+var_1C], eax
.text:0000B745                 mov     [ebp+var_18], eax
.text:0000B748                 mov     [ebp+var_14], eax
.text:0000B74B                 mov     [ebp+var_10], eax
.text:0000B74E                 mov     [ebp+var_C], eax
.text:0000B751                 mov     [ebp+var_8], eax
.text:0000B754                 mov     [ebp+var_4], eax
.text:0000B757                 mov     eax, dword ptr ds:___security_cookie
.text:0000B75C                 xor     eax, ebp
.text:0000B75E                 mov     [ebp+var_4], eax
.text:0000B761                 mov     eax, [ebp+arg_4]
.text:0000B764                 shl     eax, 4
.text:0000B767                 add     eax, [ebp+arg_0]
.text:0000B76A                 mov     ecx, [eax]
.text:0000B76C                 mov     [ebp+var_18], ecx
.text:0000B76F                 mov     edx, [eax+4]
.text:0000B772                 mov     [ebp+var_14], edx
.text:0000B775                 mov     ecx, [eax+8]
.text:0000B778                 mov     [ebp+var_10], ecx
.text:0000B77B                 mov     edx, [eax+0Ch]
.text:0000B77E                 mov     [ebp+var_C], edx
.text:0000B781
.text:0000B781 loc_B781:                               ; CODE XREF: CRecordVector<CHardLinkNode>::SortRefDown2(CHardLinkNode *,uint,uint)+D5j
.text:0000B781                 mov     eax, [ebp+arg_4]
.text:0000B784                 shl     eax, 1
.text:0000B786                 mov     [ebp+var_20], eax
.text:0000B789                 mov     ecx, [ebp+var_20]
.text:0000B78C                 cmp     ecx, [ebp+arg_8]
.text:0000B78F                 jbe     short loc_B793
.text:0000B791                 jmp     short loc_B80E
.text:0000B793 ; ---------------------------------------------------------------------------
.text:0000B793
.text:0000B793 loc_B793:                               ; CODE XREF: CRecordVector<CHardLinkNode>::SortRefDown2(CHardLinkNode *,uint,uint)+5Bj
.text:0000B793                 mov     edx, [ebp+var_20]
.text:0000B796                 cmp     edx, [ebp+arg_8]
.text:0000B799                 jnb     short loc_B7C3
.text:0000B79B                 mov     eax, [ebp+var_20]
.text:0000B79E                 shl     eax, 4
.text:0000B7A1                 add     eax, [ebp+arg_0]
.text:0000B7A4                 push    eax             ; struct CHardLinkNode *
.text:0000B7A5                 mov     ecx, [ebp+var_20]
.text:0000B7A8                 add     ecx, 1
.text:0000B7AB                 shl     ecx, 4
.text:0000B7AE                 add     ecx, [ebp+arg_0] ; this
.text:0000B7B1                 call    ?Compare@CHardLinkNode@@QBEHABU1@@Z ; CHardLinkNode::Compare(CHardLinkNode const &)
.text:0000B7B6                 test    eax, eax
.text:0000B7B8                 jle     short loc_B7C3
.text:0000B7BA                 mov     ecx, [ebp+var_20]
.text:0000B7BD                 add     ecx, 1
.text:0000B7C0                 mov     [ebp+var_20], ecx
.text:0000B7C3
.text:0000B7C3 loc_B7C3:                               ; CODE XREF: CRecordVector<CHardLinkNode>::SortRefDown2(CHardLinkNode *,uint,uint)+65j
.text:0000B7C3                                         ; CRecordVector<CHardLinkNode>::SortRefDown2(CHardLinkNode *,uint,uint)+84j
.text:0000B7C3                 mov     edx, [ebp+var_20]
.text:0000B7C6                 shl     edx, 4
.text:0000B7C9                 add     edx, [ebp+arg_0]
.text:0000B7CC                 push    edx             ; struct CHardLinkNode *
.text:0000B7CD                 lea     ecx, [ebp+var_18] ; this
.text:0000B7D0                 call    ?Compare@CHardLinkNode@@QBEHABU1@@Z ; CHardLinkNode::Compare(CHardLinkNode const &)
.text:0000B7D5                 test    eax, eax
.text:0000B7D7                 jl      short loc_B7DB
.text:0000B7D9                 jmp     short loc_B80E
.text:0000B7DB ; ---------------------------------------------------------------------------
.text:0000B7DB
.text:0000B7DB loc_B7DB:                               ; CODE XREF: CRecordVector<CHardLinkNode>::SortRefDown2(CHardLinkNode *,uint,uint)+A3j
.text:0000B7DB                 mov     eax, [ebp+var_20]
.text:0000B7DE                 shl     eax, 4
.text:0000B7E1                 add     eax, [ebp+arg_0]
.text:0000B7E4                 mov     ecx, [ebp+arg_4]
.text:0000B7E7                 shl     ecx, 4
.text:0000B7EA                 add     ecx, [ebp+arg_0]
.text:0000B7ED                 mov     edx, [eax]
.text:0000B7EF                 mov     [ecx], edx
.text:0000B7F1                 mov     edx, [eax+4]
.text:0000B7F4                 mov     [ecx+4], edx
.text:0000B7F7                 mov     edx, [eax+8]
.text:0000B7FA                 mov     [ecx+8], edx
.text:0000B7FD                 mov     eax, [eax+0Ch]
.text:0000B800                 mov     [ecx+0Ch], eax
.text:0000B803                 mov     ecx, [ebp+var_20]
.text:0000B806                 mov     [ebp+arg_4], ecx
.text:0000B809                 jmp     loc_B781
.text:0000B80E ; ---------------------------------------------------------------------------
.text:0000B80E
.text:0000B80E loc_B80E:                               ; CODE XREF: CRecordVector<CHardLinkNode>::SortRefDown2(CHardLinkNode *,uint,uint)+5Dj
.text:0000B80E                                         ; CRecordVector<CHardLinkNode>::SortRefDown2(CHardLinkNode *,uint,uint)+A5j
.text:0000B80E                 mov     edx, [ebp+arg_4]
.text:0000B811                 shl     edx, 4
.text:0000B814                 add     edx, [ebp+arg_0]
.text:0000B817                 mov     eax, [ebp+var_18]
.text:0000B81A                 mov     [edx], eax
.text:0000B81C                 mov     ecx, [ebp+var_14]
.text:0000B81F                 mov     [edx+4], ecx
.text:0000B822                 mov     eax, [ebp+var_10]
.text:0000B825                 mov     [edx+8], eax
.text:0000B828                 mov     ecx, [ebp+var_C]
.text:0000B82B                 mov     [edx+0Ch], ecx
.text:0000B82E                 push    edx
.text:0000B82F                 mov     ecx, ebp
.text:0000B831                 push    eax
.text:0000B832                 lea     edx, $LN10_8
.text:0000B838                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000B83D                 pop     eax
.text:0000B83E                 pop     edx
.text:0000B83F                 mov     ecx, [ebp+var_4]
.text:0000B842                 xor     ecx, ebp
.text:0000B844                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:0000B849                 add     esp, 20h
.text:0000B84C                 cmp     ebp, esp
.text:0000B84E                 call    __RTC_CheckEsp
.text:0000B853                 mov     esp, ebp
.text:0000B855                 pop     ebp
.text:0000B856                 retn    0Ch
.text:0000B856 ?SortRefDown2@?$CRecordVector@UCHardLinkNode@@@@SGXPAUCHardLinkNode@@II@Z endp
.text:0000B856
.text:0000B856 ; ---------------------------------------------------------------------------
.text:0000B859                 align 4
.text:0000B85C $LN10_8         dd 1                    ; DATA XREF: CRecordVector<CHardLinkNode>::SortRefDown2(CHardLinkNode *,uint,uint)+FEo
.text:0000B860                 dd offset $LN9_4
.text:0000B864 $LN9_4          dd 0FFFFFFE8h, 10h      ; DATA XREF: .text:0000B860o
.text:0000B86C                 dd offset $LN8_7        ; "temp"
.text:0000B870 $LN8_7          db 'temp',0             ; DATA XREF: .text:0000B86Co
.text:0000B875                 align 4
.text:0000B875 _text           ends
.text:0000B875
.text:0000B878 ; ===========================================================================
.text:0000B878
.text:0000B878 ; Segment type: Pure code
.text:0000B878 ; Segment permissions: Read/Execute
.text:0000B878 _text           segment para public 'CODE' use32
.text:0000B878                 assume cs:_text
.text:0000B878                 ;org 0B878h
.text:0000B878 ; COMDAT (pick any)
.text:0000B878                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B878
.text:0000B878 ; =============== S U B R O U T I N E =======================================
.text:0000B878
.text:0000B878 ; Attributes: bp-based frame
.text:0000B878
.text:0000B878 ; public: struct CIndexToPathPair const & __thiscall CObjectVector<struct CIndexToPathPair>::operator[](unsigned int)const
.text:0000B878                 public ??A?$CObjectVector@UCIndexToPathPair@@@@QBEABUCIndexToPathPair@@I@Z
.text:0000B878 ??A?$CObjectVector@UCIndexToPathPair@@@@QBEABUCIndexToPathPair@@I@Z proc near
.text:0000B878                                         ; CODE XREF: CObjectVector<CIndexToPathPair>::FindInSorted(CIndexToPathPair const &)+4Cp
.text:0000B878
.text:0000B878 var_4           = dword ptr -4
.text:0000B878 arg_0           = dword ptr  8
.text:0000B878
.text:0000B878                 push    ebp
.text:0000B879                 mov     ebp, esp
.text:0000B87B                 push    ecx
.text:0000B87C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B883                 mov     [ebp+var_4], ecx
.text:0000B886                 mov     eax, [ebp+arg_0]
.text:0000B889                 push    eax
.text:0000B88A                 mov     ecx, [ebp+var_4]
.text:0000B88D                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000B892                 mov     eax, [eax]
.text:0000B894                 add     esp, 4
.text:0000B897                 cmp     ebp, esp
.text:0000B899                 call    __RTC_CheckEsp
.text:0000B89E                 mov     esp, ebp
.text:0000B8A0                 pop     ebp
.text:0000B8A1                 retn    4
.text:0000B8A1 ??A?$CObjectVector@UCIndexToPathPair@@@@QBEABUCIndexToPathPair@@I@Z endp
.text:0000B8A1
.text:0000B8A1 _text           ends
.text:0000B8A1
.text:0000B8A4 ; ===========================================================================
.text:0000B8A4
.text:0000B8A4 ; Segment type: Pure code
.text:0000B8A4 ; Segment permissions: Read/Execute
.text:0000B8A4 _text           segment para public 'CODE' use32
.text:0000B8A4                 assume cs:_text
.text:0000B8A4                 ;org 0B8A4h
.text:0000B8A4 ; COMDAT (pick any)
.text:0000B8A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B8A4
.text:0000B8A4 ; =============== S U B R O U T I N E =======================================
.text:0000B8A4
.text:0000B8A4 ; Attributes: bp-based frame
.text:0000B8A4
.text:0000B8A4 ; public: void __thiscall CObjectVector<struct CIndexToPathPair>::Insert(unsigned int, struct CIndexToPathPair const &)
.text:0000B8A4                 public ?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z
.text:0000B8A4 ?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z proc near
.text:0000B8A4                                         ; CODE XREF: CObjectVector<CIndexToPathPair>::AddToUniqueSorted(CIndexToPathPair const &)+92p
.text:0000B8A4
.text:0000B8A4 var_1C          = dword ptr -1Ch
.text:0000B8A4 var_18          = dword ptr -18h
.text:0000B8A4 var_14          = dword ptr -14h
.text:0000B8A4 var_10          = dword ptr -10h
.text:0000B8A4 var_C           = dword ptr -0Ch
.text:0000B8A4 var_4           = dword ptr -4
.text:0000B8A4 arg_0           = dword ptr  8
.text:0000B8A4 arg_4           = dword ptr  0Ch
.text:0000B8A4
.text:0000B8A4                 push    ebp
.text:0000B8A5                 mov     ebp, esp
.text:0000B8A7                 push    0FFFFFFFFh
.text:0000B8A9                 push    offset __ehhandler$?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z
.text:0000B8AE                 mov     eax, large fs:0
.text:0000B8B4                 push    eax
.text:0000B8B5                 sub     esp, 10h
.text:0000B8B8                 mov     eax, 0CCCCCCCCh
.text:0000B8BD                 mov     [ebp+var_1C], eax
.text:0000B8C0                 mov     [ebp+var_18], eax
.text:0000B8C3                 mov     [ebp+var_14], eax
.text:0000B8C6                 mov     [ebp+var_10], eax
.text:0000B8C9                 mov     eax, dword ptr ds:___security_cookie
.text:0000B8CE                 xor     eax, ebp
.text:0000B8D0                 push    eax
.text:0000B8D1                 lea     eax, [ebp+var_C]
.text:0000B8D4                 mov     large fs:0, eax
.text:0000B8DA                 mov     [ebp+var_10], ecx
.text:0000B8DD                 push    10h             ; unsigned int
.text:0000B8DF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000B8E4                 add     esp, 4
.text:0000B8E7                 mov     [ebp+var_18], eax
.text:0000B8EA                 mov     [ebp+var_4], 0
.text:0000B8F1                 cmp     [ebp+var_18], 0
.text:0000B8F5                 jz      short loc_B908
.text:0000B8F7                 mov     eax, [ebp+arg_4]
.text:0000B8FA                 push    eax
.text:0000B8FB                 mov     ecx, [ebp+var_18]
.text:0000B8FE                 call    ??0CIndexToPathPair@@QAE@ABU0@@Z ; CIndexToPathPair::CIndexToPathPair(CIndexToPathPair const &)
.text:0000B903                 mov     [ebp+var_1C], eax
.text:0000B906                 jmp     short loc_B90F
.text:0000B908 ; ---------------------------------------------------------------------------
.text:0000B908
.text:0000B908 loc_B908:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::Insert(uint,CIndexToPathPair const &)+51j
.text:0000B908                 mov     [ebp+var_1C], 0
.text:0000B90F
.text:0000B90F loc_B90F:                               ; CODE XREF: CObjectVector<CIndexToPathPair>::Insert(uint,CIndexToPathPair const &)+62j
.text:0000B90F                 mov     ecx, [ebp+var_1C]
.text:0000B912                 mov     [ebp+var_14], ecx
.text:0000B915                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000B91C                 mov     edx, [ebp+var_14]
.text:0000B91F                 push    edx
.text:0000B920                 mov     eax, [ebp+arg_0]
.text:0000B923                 push    eax
.text:0000B924                 mov     ecx, [ebp+var_10]
.text:0000B927                 call    ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z ; CRecordVector<void *>::Insert(uint,void * const)
.text:0000B92C                 mov     ecx, [ebp+var_C]
.text:0000B92F                 mov     large fs:0, ecx
.text:0000B936                 pop     ecx
.text:0000B937                 add     esp, 1Ch
.text:0000B93A                 cmp     ebp, esp
.text:0000B93C                 call    __RTC_CheckEsp
.text:0000B941                 mov     esp, ebp
.text:0000B943                 pop     ebp
.text:0000B944                 retn    8
.text:0000B944 ?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z endp
.text:0000B944
.text:0000B944 ; ---------------------------------------------------------------------------
.text:0000B947                 align 4
.text:0000B947 _text           ends
.text:0000B947
.text$x:0000B948 ; ===========================================================================
.text$x:0000B948
.text$x:0000B948 ; Segment type: Pure code
.text$x:0000B948 ; Segment permissions: Read/Execute
.text$x:0000B948 _text$x         segment para public 'CODE' use32
.text$x:0000B948                 assume cs:_text$x
.text$x:0000B948                 ;org 0B948h
.text$x:0000B948 ; COMDAT (pick associative to section at B8A4)
.text$x:0000B948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B948
.text$x:0000B948 ; =============== S U B R O U T I N E =======================================
.text$x:0000B948
.text$x:0000B948
.text$x:0000B948 __unwindfunclet$?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z$0 proc near
.text$x:0000B948                                         ; DATA XREF: .xdata$x:0000B974o
.text$x:0000B948                 mov     eax, [ebp-18h]
.text$x:0000B94B                 push    eax             ; void *
.text$x:0000B94C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000B951                 pop     ecx
.text$x:0000B952                 retn
.text$x:0000B952 __unwindfunclet$?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z$0 endp
.text$x:0000B952
.text$x:0000B953
.text$x:0000B953 ; =============== S U B R O U T I N E =======================================
.text$x:0000B953
.text$x:0000B953
.text$x:0000B953 __ehhandler$?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z proc near
.text$x:0000B953                                         ; DATA XREF: CObjectVector<CIndexToPathPair>::Insert(uint,CIndexToPathPair const &)+5o
.text$x:0000B953
.text$x:0000B953 arg_4           = dword ptr  8
.text$x:0000B953
.text$x:0000B953                 mov     edx, [esp+arg_4]
.text$x:0000B957                 lea     eax, [edx+0Ch]
.text$x:0000B95A                 mov     ecx, [edx-14h]
.text$x:0000B95D                 xor     ecx, eax
.text$x:0000B95F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B964                 mov     eax, offset __ehfuncinfo$?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z
.text$x:0000B969                 jmp     ___CxxFrameHandler3
.text$x:0000B969 __ehhandler$?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z endp
.text$x:0000B969
.text$x:0000B969 ; ---------------------------------------------------------------------------
.text$x:0000B96E                 align 10h
.text$x:0000B96E _text$x         ends
.text$x:0000B96E
.xdata$x:0000B970 ; ===========================================================================
.xdata$x:0000B970
.xdata$x:0000B970 ; Segment type: Pure data
.xdata$x:0000B970 ; Segment permissions: Read
.xdata$x:0000B970 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B970                 assume cs:_xdata$x
.xdata$x:0000B970                 ;org 0B970h
.xdata$x:0000B970 ; COMDAT (pick associative to section at B8A4)
.xdata$x:0000B970 __unwindtable$?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z db 0FFh
.xdata$x:0000B970                                         ; DATA XREF: .xdata$x:0000B980o
.xdata$x:0000B971                 db 0FFh
.xdata$x:0000B972                 db 0FFh
.xdata$x:0000B973                 db 0FFh
.xdata$x:0000B974                 dd offset __unwindfunclet$?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z$0
.xdata$x:0000B978 __ehfuncinfo$?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z db  22h ; "
.xdata$x:0000B978                                         ; DATA XREF: __ehhandler$?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z+11o
.xdata$x:0000B979                 db    5
.xdata$x:0000B97A                 db  93h ; ô
.xdata$x:0000B97B                 db  19h
.xdata$x:0000B97C                 db    1
.xdata$x:0000B97D                 db    0
.xdata$x:0000B97E                 db    0
.xdata$x:0000B97F                 db    0
.xdata$x:0000B980                 dd offset __unwindtable$?Insert@?$CObjectVector@UCIndexToPathPair@@@@QAEXIABUCIndexToPathPair@@@Z
.xdata$x:0000B984                 db    0
.xdata$x:0000B985                 db    0
.xdata$x:0000B986                 db    0
.xdata$x:0000B987                 db    0
.xdata$x:0000B988                 db    0
.xdata$x:0000B989                 db    0
.xdata$x:0000B98A                 db    0
.xdata$x:0000B98B                 db    0
.xdata$x:0000B98C                 db    0
.xdata$x:0000B98D                 db    0
.xdata$x:0000B98E                 db    0
.xdata$x:0000B98F                 db    0
.xdata$x:0000B990                 db    0
.xdata$x:0000B991                 db    0
.xdata$x:0000B992                 db    0
.xdata$x:0000B993                 db    0
.xdata$x:0000B994                 db    0
.xdata$x:0000B995                 db    0
.xdata$x:0000B996                 db    0
.xdata$x:0000B997                 db    0
.xdata$x:0000B998                 db    1
.xdata$x:0000B999                 db    0
.xdata$x:0000B99A                 db    0
.xdata$x:0000B99B                 db    0
.xdata$x:0000B99B _xdata$x        ends
.xdata$x:0000B99B
.text:0000B99C ; ===========================================================================
.text:0000B99C
.text:0000B99C ; Segment type: Pure code
.text:0000B99C ; Segment permissions: Read/Execute
.text:0000B99C _text           segment para public 'CODE' use32
.text:0000B99C                 assume cs:_text
.text:0000B99C                 ;org 0B99Ch
.text:0000B99C ; COMDAT (pick any)
.text:0000B99C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B99C
.text:0000B99C ; =============== S U B R O U T I N E =======================================
.text:0000B99C
.text:0000B99C ; Attributes: bp-based frame
.text:0000B99C
.text:0000B99C ; public: void __thiscall CRecordVector<struct CExtrRefSortPair>::ClearAndReserve(unsigned int)
.text:0000B99C                 public ?ClearAndReserve@?$CRecordVector@UCExtrRefSortPair@@@@QAEXI@Z
.text:0000B99C ?ClearAndReserve@?$CRecordVector@UCExtrRefSortPair@@@@QAEXI@Z proc near
.text:0000B99C                                         ; CODE XREF: CRecordVector<CExtrRefSortPair>::ClearAndSetSize(uint)+15p
.text:0000B99C
.text:0000B99C var_C           = dword ptr -0Ch
.text:0000B99C var_8           = dword ptr -8
.text:0000B99C var_4           = dword ptr -4
.text:0000B99C arg_0           = dword ptr  8
.text:0000B99C
.text:0000B99C                 push    ebp
.text:0000B99D                 mov     ebp, esp
.text:0000B99F                 sub     esp, 0Ch
.text:0000B9A2                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000B9A9                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000B9B0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B9B7                 mov     [ebp+var_4], ecx
.text:0000B9BA                 mov     ecx, [ebp+var_4]
.text:0000B9BD                 call    ?Clear@?$CRecordVector@UCExtrRefSortPair@@@@QAEXXZ ; CRecordVector<CExtrRefSortPair>::Clear(void)
.text:0000B9C2                 mov     eax, [ebp+var_4]
.text:0000B9C5                 mov     ecx, [ebp+arg_0]
.text:0000B9C8                 cmp     ecx, [eax+8]
.text:0000B9CB                 jbe     short loc_BA24
.text:0000B9CD                 mov     edx, [ebp+var_4]
.text:0000B9D0                 mov     eax, [edx]
.text:0000B9D2                 mov     [ebp+var_8], eax
.text:0000B9D5                 mov     ecx, [ebp+var_8]
.text:0000B9D8                 push    ecx             ; void *
.text:0000B9D9                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B9DE                 add     esp, 4
.text:0000B9E1                 mov     edx, [ebp+var_4]
.text:0000B9E4                 mov     dword ptr [edx], 0
.text:0000B9EA                 mov     eax, [ebp+var_4]
.text:0000B9ED                 mov     dword ptr [eax+8], 0
.text:0000B9F4                 xor     ecx, ecx
.text:0000B9F6                 mov     eax, [ebp+arg_0]
.text:0000B9F9                 mov     edx, 8
.text:0000B9FE                 mul     edx
.text:0000BA00                 seto    cl
.text:0000BA03                 neg     ecx
.text:0000BA05                 or      ecx, eax
.text:0000BA07                 push    ecx             ; unsigned int
.text:0000BA08                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000BA0D                 add     esp, 4
.text:0000BA10                 mov     [ebp+var_C], eax
.text:0000BA13                 mov     eax, [ebp+var_4]
.text:0000BA16                 mov     ecx, [ebp+var_C]
.text:0000BA19                 mov     [eax], ecx
.text:0000BA1B                 mov     edx, [ebp+var_4]
.text:0000BA1E                 mov     eax, [ebp+arg_0]
.text:0000BA21                 mov     [edx+8], eax
.text:0000BA24
.text:0000BA24 loc_BA24:                               ; CODE XREF: CRecordVector<CExtrRefSortPair>::ClearAndReserve(uint)+2Fj
.text:0000BA24                 add     esp, 0Ch
.text:0000BA27                 cmp     ebp, esp
.text:0000BA29                 call    __RTC_CheckEsp
.text:0000BA2E                 mov     esp, ebp
.text:0000BA30                 pop     ebp
.text:0000BA31                 retn    4
.text:0000BA31 ?ClearAndReserve@?$CRecordVector@UCExtrRefSortPair@@@@QAEXI@Z endp
.text:0000BA31
.text:0000BA31 _text           ends
.text:0000BA31
.text:0000BA34 ; ===========================================================================
.text:0000BA34
.text:0000BA34 ; Segment type: Pure code
.text:0000BA34 ; Segment permissions: Read/Execute
.text:0000BA34 _text           segment para public 'CODE' use32
.text:0000BA34                 assume cs:_text
.text:0000BA34                 ;org 0BA34h
.text:0000BA34 ; COMDAT (pick any)
.text:0000BA34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BA34
.text:0000BA34 ; =============== S U B R O U T I N E =======================================
.text:0000BA34
.text:0000BA34 ; Attributes: bp-based frame
.text:0000BA34
.text:0000BA34 ; public: struct CExtrRefSortPair & __thiscall CRecordVector<struct CExtrRefSortPair>::Front(void)
.text:0000BA34                 public ?Front@?$CRecordVector@UCExtrRefSortPair@@@@QAEAAUCExtrRefSortPair@@XZ
.text:0000BA34 ?Front@?$CRecordVector@UCExtrRefSortPair@@@@QAEAAUCExtrRefSortPair@@XZ proc near
.text:0000BA34                                         ; CODE XREF: CRecordVector<CExtrRefSortPair>::Sort2(void)+3Ep
.text:0000BA34
.text:0000BA34 var_4           = dword ptr -4
.text:0000BA34
.text:0000BA34                 push    ebp
.text:0000BA35                 mov     ebp, esp
.text:0000BA37                 push    ecx
.text:0000BA38                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BA3F                 mov     [ebp+var_4], ecx
.text:0000BA42                 mov     eax, [ebp+var_4]
.text:0000BA45                 mov     eax, [eax]
.text:0000BA47                 mov     esp, ebp
.text:0000BA49                 pop     ebp
.text:0000BA4A                 retn
.text:0000BA4A ?Front@?$CRecordVector@UCExtrRefSortPair@@@@QAEAAUCExtrRefSortPair@@XZ endp
.text:0000BA4A
.text:0000BA4A ; ---------------------------------------------------------------------------
.text:0000BA4B                 align 4
.text:0000BA4B _text           ends
.text:0000BA4B
.text:0000BA4C ; ===========================================================================
.text:0000BA4C
.text:0000BA4C ; Segment type: Pure code
.text:0000BA4C ; Segment permissions: Read/Execute
.text:0000BA4C _text           segment para public 'CODE' use32
.text:0000BA4C                 assume cs:_text
.text:0000BA4C                 ;org 0BA4Ch
.text:0000BA4C ; COMDAT (pick any)
.text:0000BA4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BA4C
.text:0000BA4C ; =============== S U B R O U T I N E =======================================
.text:0000BA4C
.text:0000BA4C ; Attributes: bp-based frame
.text:0000BA4C
.text:0000BA4C ; public: static void __stdcall CRecordVector<struct CExtrRefSortPair>::SortRefDown2(struct CExtrRefSortPair *, unsigned int, unsigned int)
.text:0000BA4C                 public ?SortRefDown2@?$CRecordVector@UCExtrRefSortPair@@@@SGXPAUCExtrRefSortPair@@II@Z
.text:0000BA4C ?SortRefDown2@?$CRecordVector@UCExtrRefSortPair@@@@SGXPAUCExtrRefSortPair@@II@Z proc near
.text:0000BA4C                                         ; CODE XREF: CRecordVector<CExtrRefSortPair>::Sort2(void)+5Dp
.text:0000BA4C                                         ; CRecordVector<CExtrRefSortPair>::Sort2(void)+B8p
.text:0000BA4C
.text:0000BA4C var_14          = dword ptr -14h
.text:0000BA4C var_10          = dword ptr -10h
.text:0000BA4C var_C           = dword ptr -0Ch
.text:0000BA4C var_8           = dword ptr -8
.text:0000BA4C var_4           = dword ptr -4
.text:0000BA4C arg_0           = dword ptr  8
.text:0000BA4C arg_4           = dword ptr  0Ch
.text:0000BA4C arg_8           = dword ptr  10h
.text:0000BA4C
.text:0000BA4C                 push    ebp
.text:0000BA4D                 mov     ebp, esp
.text:0000BA4F                 sub     esp, 14h
.text:0000BA52                 push    esi
.text:0000BA53                 mov     eax, 0CCCCCCCCh
.text:0000BA58                 mov     [ebp+var_14], eax
.text:0000BA5B                 mov     [ebp+var_10], eax
.text:0000BA5E                 mov     [ebp+var_C], eax
.text:0000BA61                 mov     [ebp+var_8], eax
.text:0000BA64                 mov     [ebp+var_4], eax
.text:0000BA67                 mov     eax, [ebp+arg_4]
.text:0000BA6A                 mov     ecx, [ebp+arg_0]
.text:0000BA6D                 mov     edx, [ecx+eax*8]
.text:0000BA70                 mov     eax, [ecx+eax*8+4]
.text:0000BA74                 mov     [ebp+var_C], edx
.text:0000BA77                 mov     [ebp+var_8], eax
.text:0000BA7A
.text:0000BA7A loc_BA7A:                               ; CODE XREF: CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)+A6j
.text:0000BA7A                 mov     ecx, [ebp+arg_4]
.text:0000BA7D                 shl     ecx, 1
.text:0000BA7F                 mov     [ebp+var_14], ecx
.text:0000BA82                 mov     edx, [ebp+var_14]
.text:0000BA85                 cmp     edx, [ebp+arg_8]
.text:0000BA88                 jbe     short loc_BA8C
.text:0000BA8A                 jmp     short loc_BAF4
.text:0000BA8C ; ---------------------------------------------------------------------------
.text:0000BA8C
.text:0000BA8C loc_BA8C:                               ; CODE XREF: CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)+3Cj
.text:0000BA8C                 mov     eax, [ebp+var_14]
.text:0000BA8F                 cmp     eax, [ebp+arg_8]
.text:0000BA92                 jnb     short loc_BABA
.text:0000BA94                 mov     ecx, [ebp+var_14]
.text:0000BA97                 mov     edx, [ebp+arg_0]
.text:0000BA9A                 lea     eax, [edx+ecx*8]
.text:0000BA9D                 push    eax             ; struct CExtrRefSortPair *
.text:0000BA9E                 mov     ecx, [ebp+var_14]
.text:0000BAA1                 mov     edx, [ebp+arg_0]
.text:0000BAA4                 lea     ecx, [edx+ecx*8+8] ; this
.text:0000BAA8                 call    ?Compare@CExtrRefSortPair@@QBEHABU1@@Z ; CExtrRefSortPair::Compare(CExtrRefSortPair const &)
.text:0000BAAD                 test    eax, eax
.text:0000BAAF                 jle     short loc_BABA
.text:0000BAB1                 mov     eax, [ebp+var_14]
.text:0000BAB4                 add     eax, 1
.text:0000BAB7                 mov     [ebp+var_14], eax
.text:0000BABA
.text:0000BABA loc_BABA:                               ; CODE XREF: CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)+46j
.text:0000BABA                                         ; CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)+63j
.text:0000BABA                 mov     ecx, [ebp+var_14]
.text:0000BABD                 mov     edx, [ebp+arg_0]
.text:0000BAC0                 lea     eax, [edx+ecx*8]
.text:0000BAC3                 push    eax             ; struct CExtrRefSortPair *
.text:0000BAC4                 lea     ecx, [ebp+var_C] ; this
.text:0000BAC7                 call    ?Compare@CExtrRefSortPair@@QBEHABU1@@Z ; CExtrRefSortPair::Compare(CExtrRefSortPair const &)
.text:0000BACC                 test    eax, eax
.text:0000BACE                 jl      short loc_BAD2
.text:0000BAD0                 jmp     short loc_BAF4
.text:0000BAD2 ; ---------------------------------------------------------------------------
.text:0000BAD2
.text:0000BAD2 loc_BAD2:                               ; CODE XREF: CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)+82j
.text:0000BAD2                 mov     ecx, [ebp+var_14]
.text:0000BAD5                 mov     edx, [ebp+arg_0]
.text:0000BAD8                 mov     eax, [edx+ecx*8]
.text:0000BADB                 mov     ecx, [edx+ecx*8+4]
.text:0000BADF                 mov     edx, [ebp+arg_4]
.text:0000BAE2                 mov     esi, [ebp+arg_0]
.text:0000BAE5                 mov     [esi+edx*8], eax
.text:0000BAE8                 mov     [esi+edx*8+4], ecx
.text:0000BAEC                 mov     eax, [ebp+var_14]
.text:0000BAEF                 mov     [ebp+arg_4], eax
.text:0000BAF2                 jmp     short loc_BA7A
.text:0000BAF4 ; ---------------------------------------------------------------------------
.text:0000BAF4
.text:0000BAF4 loc_BAF4:                               ; CODE XREF: CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)+3Ej
.text:0000BAF4                                         ; CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)+84j
.text:0000BAF4                 mov     ecx, [ebp+arg_4]
.text:0000BAF7                 mov     edx, [ebp+arg_0]
.text:0000BAFA                 mov     eax, [ebp+var_C]
.text:0000BAFD                 mov     [edx+ecx*8], eax
.text:0000BB00                 mov     eax, [ebp+var_8]
.text:0000BB03                 mov     [edx+ecx*8+4], eax
.text:0000BB07                 push    edx
.text:0000BB08                 mov     ecx, ebp
.text:0000BB0A                 push    eax
.text:0000BB0B                 lea     edx, $LN10_9
.text:0000BB11                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000BB16                 pop     eax
.text:0000BB17                 pop     edx
.text:0000BB18                 pop     esi
.text:0000BB19                 add     esp, 14h
.text:0000BB1C                 cmp     ebp, esp
.text:0000BB1E                 call    __RTC_CheckEsp
.text:0000BB23                 mov     esp, ebp
.text:0000BB25                 pop     ebp
.text:0000BB26                 retn    0Ch
.text:0000BB26 ?SortRefDown2@?$CRecordVector@UCExtrRefSortPair@@@@SGXPAUCExtrRefSortPair@@II@Z endp
.text:0000BB26
.text:0000BB26 ; ---------------------------------------------------------------------------
.text:0000BB29                 align 4
.text:0000BB2C $LN10_9         dd 1                    ; DATA XREF: CRecordVector<CExtrRefSortPair>::SortRefDown2(CExtrRefSortPair *,uint,uint)+BFo
.text:0000BB30                 dd offset $LN9_5
.text:0000BB34 $LN9_5          dd 0FFFFFFF4h, 8        ; DATA XREF: .text:0000BB30o
.text:0000BB3C                 dd offset $LN8_8        ; "temp"
.text:0000BB40 $LN8_8          db 'temp',0             ; DATA XREF: .text:0000BB3Co
.text:0000BB45                 align 4
.text:0000BB45 _text           ends
.text:0000BB45
.text:0000BB48 ; ===========================================================================
.text:0000BB48
.text:0000BB48 ; Segment type: Pure code
.text:0000BB48 ; Segment permissions: Read/Execute
.text:0000BB48 _text           segment para public 'CODE' use32
.text:0000BB48                 assume cs:_text
.text:0000BB48                 ;org 0BB48h
.text:0000BB48 ; COMDAT (pick any)
.text:0000BB48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BB48
.text:0000BB48 ; =============== S U B R O U T I N E =======================================
.text:0000BB48
.text:0000BB48 ; Attributes: bp-based frame
.text:0000BB48
.text:0000BB48 ; public: __thiscall CIndexToPathPair::CIndexToPathPair(struct CIndexToPathPair const &)
.text:0000BB48                 public ??0CIndexToPathPair@@QAE@ABU0@@Z
.text:0000BB48 ??0CIndexToPathPair@@QAE@ABU0@@Z proc near
.text:0000BB48                                         ; CODE XREF: CObjectVector<CIndexToPathPair>::Insert(uint,CIndexToPathPair const &)+5Ap
.text:0000BB48
.text:0000BB48 var_4           = dword ptr -4
.text:0000BB48 arg_0           = dword ptr  8
.text:0000BB48
.text:0000BB48                 push    ebp
.text:0000BB49                 mov     ebp, esp
.text:0000BB4B                 push    ecx
.text:0000BB4C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BB53                 mov     [ebp+var_4], ecx
.text:0000BB56                 mov     eax, [ebp+var_4]
.text:0000BB59                 mov     ecx, [ebp+arg_0]
.text:0000BB5C                 mov     edx, [ecx]
.text:0000BB5E                 mov     [eax], edx
.text:0000BB60                 mov     eax, [ebp+arg_0]
.text:0000BB63                 add     eax, 4
.text:0000BB66                 push    eax
.text:0000BB67                 mov     ecx, [ebp+var_4]
.text:0000BB6A                 add     ecx, 4
.text:0000BB6D                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000BB72                 mov     eax, [ebp+var_4]
.text:0000BB75                 add     esp, 4
.text:0000BB78                 cmp     ebp, esp
.text:0000BB7A                 call    __RTC_CheckEsp
.text:0000BB7F                 mov     esp, ebp
.text:0000BB81                 pop     ebp
.text:0000BB82                 retn    4
.text:0000BB82 ??0CIndexToPathPair@@QAE@ABU0@@Z endp
.text:0000BB82
.text:0000BB82 ; ---------------------------------------------------------------------------
.text:0000BB85                 align 4
.text:0000BB85 _text           ends
.text:0000BB85
.text:0000BB88 ; ===========================================================================
.text:0000BB88
.text:0000BB88 ; Segment type: Pure code
.text:0000BB88 ; Segment permissions: Read/Execute
.text:0000BB88 _text           segment para public 'CODE' use32
.text:0000BB88                 assume cs:_text
.text:0000BB88                 ;org 0BB88h
.text:0000BB88 ; COMDAT (pick any)
.text:0000BB88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BB88
.text:0000BB88 ; =============== S U B R O U T I N E =======================================
.text:0000BB88
.text:0000BB88 ; Attributes: bp-based frame
.text:0000BB88
.text:0000BB88 ; private: void __thiscall CRecordVector<void *>::MoveItems(unsigned int, unsigned int)
.text:0000BB88                 public ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z
.text:0000BB88 ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z proc near
.text:0000BB88                                         ; CODE XREF: CRecordVector<void *>::DeleteFrontal(uint)+1Dp
.text:0000BB88                                         ; CRecordVector<void *>::Insert(uint,void * const)+24p
.text:0000BB88
.text:0000BB88 var_4           = dword ptr -4
.text:0000BB88 arg_0           = dword ptr  8
.text:0000BB88 arg_4           = dword ptr  0Ch
.text:0000BB88
.text:0000BB88                 push    ebp
.text:0000BB89                 mov     ebp, esp
.text:0000BB8B                 push    ecx
.text:0000BB8C                 push    esi
.text:0000BB8D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BB94                 mov     [ebp+var_4], ecx
.text:0000BB97                 mov     eax, [ebp+var_4]
.text:0000BB9A                 mov     ecx, [eax+4]
.text:0000BB9D                 sub     ecx, [ebp+arg_4]
.text:0000BBA0                 shl     ecx, 2
.text:0000BBA3                 mov     esi, esp
.text:0000BBA5                 push    ecx             ; Size
.text:0000BBA6                 mov     edx, [ebp+var_4]
.text:0000BBA9                 mov     eax, [edx]
.text:0000BBAB                 mov     ecx, [ebp+arg_4]
.text:0000BBAE                 lea     edx, [eax+ecx*4]
.text:0000BBB1                 push    edx             ; Src
.text:0000BBB2                 mov     eax, [ebp+var_4]
.text:0000BBB5                 mov     ecx, [eax]
.text:0000BBB7                 mov     edx, [ebp+arg_0]
.text:0000BBBA                 lea     eax, [ecx+edx*4]
.text:0000BBBD                 push    eax             ; Dst
.text:0000BBBE                 call    dword ptr ds:__imp__memmove
.text:0000BBC4                 add     esp, 0Ch
.text:0000BBC7                 cmp     esi, esp
.text:0000BBC9                 call    __RTC_CheckEsp
.text:0000BBCE                 pop     esi
.text:0000BBCF                 add     esp, 4
.text:0000BBD2                 cmp     ebp, esp
.text:0000BBD4                 call    __RTC_CheckEsp
.text:0000BBD9                 mov     esp, ebp
.text:0000BBDB                 pop     ebp
.text:0000BBDC                 retn    8
.text:0000BBDC ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z endp
.text:0000BBDC
.text:0000BBDC ; ---------------------------------------------------------------------------
.text:0000BBDF                 align 10h
.text:0000BBDF _text           ends
.text:0000BBDF
.text:0000BBE0 ; ===========================================================================
.text:0000BBE0
.text:0000BBE0 ; Segment type: Pure code
.text:0000BBE0 ; Segment permissions: Read/Execute
.text:0000BBE0 _text           segment para public 'CODE' use32
.text:0000BBE0                 assume cs:_text
.text:0000BBE0                 ;org 0BBE0h
.text:0000BBE0 ; COMDAT (pick any)
.text:0000BBE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BBE0
.text:0000BBE0 ; =============== S U B R O U T I N E =======================================
.text:0000BBE0
.text:0000BBE0 ; Attributes: bp-based frame
.text:0000BBE0
.text:0000BBE0 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:0000BBE0                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:0000BBE0 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:0000BBE0                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:0000BBE0                                         ; CRecordVector<void *>::Insert(uint,void * const)+11p
.text:0000BBE0
.text:0000BBE0 var_14          = dword ptr -14h
.text:0000BBE0 var_10          = dword ptr -10h
.text:0000BBE0 Dst             = dword ptr -0Ch
.text:0000BBE0 var_8           = dword ptr -8
.text:0000BBE0 var_4           = dword ptr -4
.text:0000BBE0
.text:0000BBE0                 push    ebp
.text:0000BBE1                 mov     ebp, esp
.text:0000BBE3                 sub     esp, 14h
.text:0000BBE6                 mov     eax, 0CCCCCCCCh
.text:0000BBEB                 mov     [ebp+var_14], eax
.text:0000BBEE                 mov     [ebp+var_10], eax
.text:0000BBF1                 mov     [ebp+Dst], eax
.text:0000BBF4                 mov     [ebp+var_8], eax
.text:0000BBF7                 mov     [ebp+var_4], eax
.text:0000BBFA                 mov     [ebp+var_4], ecx
.text:0000BBFD                 mov     eax, [ebp+var_4]
.text:0000BC00                 mov     ecx, [ebp+var_4]
.text:0000BC03                 mov     edx, [eax+4]
.text:0000BC06                 cmp     edx, [ecx+8]
.text:0000BC09                 jnz     loc_BC94
.text:0000BC0F                 mov     eax, [ebp+var_4]
.text:0000BC12                 mov     ecx, [eax+8]
.text:0000BC15                 shr     ecx, 2
.text:0000BC18                 mov     edx, [ebp+var_4]
.text:0000BC1B                 mov     eax, [edx+8]
.text:0000BC1E                 lea     ecx, [eax+ecx+1]
.text:0000BC22                 mov     [ebp+var_8], ecx
.text:0000BC25                 xor     ecx, ecx
.text:0000BC27                 mov     eax, [ebp+var_8]
.text:0000BC2A                 mov     edx, 4
.text:0000BC2F                 mul     edx
.text:0000BC31                 seto    cl
.text:0000BC34                 neg     ecx
.text:0000BC36                 or      ecx, eax
.text:0000BC38                 push    ecx             ; unsigned int
.text:0000BC39                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000BC3E                 add     esp, 4
.text:0000BC41                 mov     [ebp+var_10], eax
.text:0000BC44                 mov     eax, [ebp+var_10]
.text:0000BC47                 mov     [ebp+Dst], eax
.text:0000BC4A                 mov     ecx, [ebp+var_4]
.text:0000BC4D                 cmp     dword ptr [ecx+4], 0
.text:0000BC51                 jz      short loc_BC6F
.text:0000BC53                 mov     edx, [ebp+var_4]
.text:0000BC56                 mov     eax, [edx+4]
.text:0000BC59                 shl     eax, 2
.text:0000BC5C                 push    eax             ; Size
.text:0000BC5D                 mov     ecx, [ebp+var_4]
.text:0000BC60                 mov     edx, [ecx]
.text:0000BC62                 push    edx             ; Src
.text:0000BC63                 mov     eax, [ebp+Dst]
.text:0000BC66                 push    eax             ; Dst
.text:0000BC67                 call    _memcpy
.text:0000BC6C                 add     esp, 0Ch
.text:0000BC6F
.text:0000BC6F loc_BC6F:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:0000BC6F                 mov     ecx, [ebp+var_4]
.text:0000BC72                 mov     edx, [ecx]
.text:0000BC74                 mov     [ebp+var_14], edx
.text:0000BC77                 mov     eax, [ebp+var_14]
.text:0000BC7A                 push    eax             ; void *
.text:0000BC7B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000BC80                 add     esp, 4
.text:0000BC83                 mov     ecx, [ebp+var_4]
.text:0000BC86                 mov     edx, [ebp+Dst]
.text:0000BC89                 mov     [ecx], edx
.text:0000BC8B                 mov     eax, [ebp+var_4]
.text:0000BC8E                 mov     ecx, [ebp+var_8]
.text:0000BC91                 mov     [eax+8], ecx
.text:0000BC94
.text:0000BC94 loc_BC94:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:0000BC94                 add     esp, 14h
.text:0000BC97                 cmp     ebp, esp
.text:0000BC99                 call    __RTC_CheckEsp
.text:0000BC9E                 mov     esp, ebp
.text:0000BCA0                 pop     ebp
.text:0000BCA1                 retn
.text:0000BCA1 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:0000BCA1
.text:0000BCA1 ; ---------------------------------------------------------------------------
.text:0000BCA2                 align 4
.text:0000BCA2 _text           ends
.text:0000BCA2
.text:0000BCA4 ; ===========================================================================
.text:0000BCA4
.text:0000BCA4 ; Segment type: Pure code
.text:0000BCA4 ; Segment permissions: Read/Execute
.text:0000BCA4 _text           segment para public 'CODE' use32
.text:0000BCA4                 assume cs:_text
.text:0000BCA4                 ;org 0BCA4h
.text:0000BCA4 ; COMDAT (pick any)
.text:0000BCA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BCA4
.text:0000BCA4 ; =============== S U B R O U T I N E =======================================
.text:0000BCA4
.text:0000BCA4 ; Attributes: bp-based frame
.text:0000BCA4
.text:0000BCA4 ; public: void __thiscall CRecordVector<void *>::Insert(unsigned int, void * const)
.text:0000BCA4                 public ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z
.text:0000BCA4 ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z proc near
.text:0000BCA4                                         ; CODE XREF: CObjectVector<CIndexToPathPair>::Insert(uint,CIndexToPathPair const &)+83p
.text:0000BCA4
.text:0000BCA4 var_4           = dword ptr -4
.text:0000BCA4 arg_0           = dword ptr  8
.text:0000BCA4 arg_4           = dword ptr  0Ch
.text:0000BCA4
.text:0000BCA4                 push    ebp
.text:0000BCA5                 mov     ebp, esp
.text:0000BCA7                 push    ecx
.text:0000BCA8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BCAF                 mov     [ebp+var_4], ecx
.text:0000BCB2                 mov     ecx, [ebp+var_4]
.text:0000BCB5                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:0000BCBA                 mov     eax, [ebp+arg_0]
.text:0000BCBD                 push    eax
.text:0000BCBE                 mov     ecx, [ebp+arg_0]
.text:0000BCC1                 add     ecx, 1
.text:0000BCC4                 push    ecx
.text:0000BCC5                 mov     ecx, [ebp+var_4]
.text:0000BCC8                 call    ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z ; CRecordVector<void *>::MoveItems(uint,uint)
.text:0000BCCD                 mov     edx, [ebp+var_4]
.text:0000BCD0                 mov     eax, [edx]
.text:0000BCD2                 mov     ecx, [ebp+arg_0]
.text:0000BCD5                 mov     edx, [ebp+arg_4]
.text:0000BCD8                 mov     [eax+ecx*4], edx
.text:0000BCDB                 mov     eax, [ebp+var_4]
.text:0000BCDE                 mov     ecx, [eax+4]
.text:0000BCE1                 add     ecx, 1
.text:0000BCE4                 mov     edx, [ebp+var_4]
.text:0000BCE7                 mov     [edx+4], ecx
.text:0000BCEA                 add     esp, 4
.text:0000BCED                 cmp     ebp, esp
.text:0000BCEF                 call    __RTC_CheckEsp
.text:0000BCF4                 mov     esp, ebp
.text:0000BCF6                 pop     ebp
.text:0000BCF7                 retn    8
.text:0000BCF7 ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z endp
.text:0000BCF7
.text:0000BCF7 ; ---------------------------------------------------------------------------
.text:0000BCFA                 align 4
.text:0000BCFA _text           ends
.text:0000BCFA
.text:0000BCFC ; ===========================================================================
.text:0000BCFC
.text:0000BCFC ; Segment type: Pure code
.text:0000BCFC ; Segment permissions: Read/Execute
.text:0000BCFC _text           segment para public 'CODE' use32
.text:0000BCFC                 assume cs:_text
.text:0000BCFC                 ;org 0BCFCh
.text:0000BCFC ; COMDAT (pick any)
.text:0000BCFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BCFC
.text:0000BCFC ; =============== S U B R O U T I N E =======================================
.text:0000BCFC
.text:0000BCFC ; Attributes: bp-based frame
.text:0000BCFC
.text:0000BCFC ; public: struct CHardLinkNode const & __thiscall CRecordVector<struct CHardLinkNode>::operator[](unsigned int)const
.text:0000BCFC                 public ??A?$CRecordVector@UCHardLinkNode@@@@QBEABUCHardLinkNode@@I@Z
.text:0000BCFC ??A?$CRecordVector@UCHardLinkNode@@@@QBEABUCHardLinkNode@@I@Z proc near
.text:0000BCFC                                         ; CODE XREF: CRecordVector<CHardLinkNode>::FindInSorted2(CHardLinkNode const &,uint,uint)+34p
.text:0000BCFC
.text:0000BCFC var_4           = dword ptr -4
.text:0000BCFC arg_0           = dword ptr  8
.text:0000BCFC
.text:0000BCFC                 push    ebp
.text:0000BCFD                 mov     ebp, esp
.text:0000BCFF                 push    ecx
.text:0000BD00                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BD07                 mov     [ebp+var_4], ecx
.text:0000BD0A                 mov     eax, [ebp+arg_0]
.text:0000BD0D                 shl     eax, 4
.text:0000BD10                 mov     ecx, [ebp+var_4]
.text:0000BD13                 add     eax, [ecx]
.text:0000BD15                 mov     esp, ebp
.text:0000BD17                 pop     ebp
.text:0000BD18                 retn    4
.text:0000BD18 ??A?$CRecordVector@UCHardLinkNode@@@@QBEABUCHardLinkNode@@I@Z endp
.text:0000BD18
.text:0000BD18 ; ---------------------------------------------------------------------------
.text:0000BD1B                 align 4
.text:0000BD1B _text           ends
.text:0000BD1B
.text:0000BD1C ; ===========================================================================
.text:0000BD1C
.text:0000BD1C ; Segment type: Pure code
.text:0000BD1C ; Segment permissions: Read/Execute
.text:0000BD1C _text           segment para public 'CODE' use32
.text:0000BD1C                 assume cs:_text
.text:0000BD1C                 ;org 0BD1Ch
.text:0000BD1C ; COMDAT (pick any)
.text:0000BD1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BD1C
.text:0000BD1C ; =============== S U B R O U T I N E =======================================
.text:0000BD1C
.text:0000BD1C ; Attributes: bp-based frame
.text:0000BD1C
.text:0000BD1C ; public: void __thiscall CRecordVector<struct CExtrRefSortPair>::Clear(void)
.text:0000BD1C                 public ?Clear@?$CRecordVector@UCExtrRefSortPair@@@@QAEXXZ
.text:0000BD1C ?Clear@?$CRecordVector@UCExtrRefSortPair@@@@QAEXXZ proc near
.text:0000BD1C                                         ; CODE XREF: CRecordVector<CExtrRefSortPair>::ClearAndReserve(uint)+21p
.text:0000BD1C
.text:0000BD1C var_4           = dword ptr -4
.text:0000BD1C
.text:0000BD1C                 push    ebp
.text:0000BD1D                 mov     ebp, esp
.text:0000BD1F                 push    ecx
.text:0000BD20                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BD27                 mov     [ebp+var_4], ecx
.text:0000BD2A                 mov     eax, [ebp+var_4]
.text:0000BD2D                 mov     dword ptr [eax+4], 0
.text:0000BD34                 mov     esp, ebp
.text:0000BD36                 pop     ebp
.text:0000BD37                 retn
.text:0000BD37 ?Clear@?$CRecordVector@UCExtrRefSortPair@@@@QAEXXZ endp
.text:0000BD37
.text:0000BD37 _text           ends
.text:0000BD37
.text:0000BD38 ; ===========================================================================
.text:0000BD38
.text:0000BD38 ; Segment type: Pure code
.text:0000BD38 ; Segment permissions: Read/Execute
.text:0000BD38 _text           segment para public 'CODE' use32
.text:0000BD38                 assume cs:_text
.text:0000BD38                 ;org 0BD38h
.text:0000BD38 ; COMDAT (pick any)
.text:0000BD38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BD38
.text:0000BD38 ; =============== S U B R O U T I N E =======================================
.text:0000BD38
.text:0000BD38 ; Attributes: bp-based frame
.text:0000BD38
.text:0000BD38 ; int __stdcall MyCompare<unsigned int>(unsigned int, unsigned int)
.text:0000BD38                 public ??$MyCompare@I@@YGHII@Z
.text:0000BD38 ??$MyCompare@I@@YGHII@Z proc near       ; CODE XREF: CExtrRefSortPair::Compare(CExtrRefSortPair const &)+23p
.text:0000BD38                                         ; CExtrRefSortPair::Compare(CExtrRefSortPair const &)+42p ...
.text:0000BD38
.text:0000BD38 var_4           = dword ptr -4
.text:0000BD38 arg_0           = dword ptr  8
.text:0000BD38 arg_4           = dword ptr  0Ch
.text:0000BD38
.text:0000BD38                 push    ebp
.text:0000BD39                 mov     ebp, esp
.text:0000BD3B                 push    ecx
.text:0000BD3C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BD43                 mov     eax, [ebp+arg_0]
.text:0000BD46                 cmp     eax, [ebp+arg_4]
.text:0000BD49                 jnb     short loc_BD54
.text:0000BD4B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000BD52                 jmp     short loc_BD62
.text:0000BD54 ; ---------------------------------------------------------------------------
.text:0000BD54
.text:0000BD54 loc_BD54:                               ; CODE XREF: MyCompare<uint>(uint,uint)+11j
.text:0000BD54                 mov     ecx, [ebp+arg_0]
.text:0000BD57                 xor     edx, edx
.text:0000BD59                 cmp     ecx, [ebp+arg_4]
.text:0000BD5C                 setnz   dl
.text:0000BD5F                 mov     [ebp+var_4], edx
.text:0000BD62
.text:0000BD62 loc_BD62:                               ; CODE XREF: MyCompare<uint>(uint,uint)+1Aj
.text:0000BD62                 mov     eax, [ebp+var_4]
.text:0000BD65                 mov     esp, ebp
.text:0000BD67                 pop     ebp
.text:0000BD68                 retn    8
.text:0000BD68 ??$MyCompare@I@@YGHII@Z endp
.text:0000BD68
.text:0000BD68 ; ---------------------------------------------------------------------------
.text:0000BD6B                 align 4
.text:0000BD6B _text           ends
.text:0000BD6B
.text:0000BD6C ; ===========================================================================
.text:0000BD6C
.text:0000BD6C ; Segment type: Pure code
.text:0000BD6C ; Segment permissions: Read/Execute
.text:0000BD6C _text           segment para public 'CODE' use32
.text:0000BD6C                 assume cs:_text
.text:0000BD6C                 ;org 0BD6Ch
.text:0000BD6C ; COMDAT (pick any)
.text:0000BD6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BD6C
.text:0000BD6C ; =============== S U B R O U T I N E =======================================
.text:0000BD6C
.text:0000BD6C ; Attributes: bp-based frame
.text:0000BD6C
.text:0000BD6C ; int __stdcall MyCompare<unsigned __int64>(unsigned __int64, unsigned __int64)
.text:0000BD6C                 public ??$MyCompare@_K@@YGH_K0@Z
.text:0000BD6C ??$MyCompare@_K@@YGH_K0@Z proc near     ; CODE XREF: CHardLinkNode::Compare(CHardLinkNode const &)+8Fp
.text:0000BD6C
.text:0000BD6C var_8           = dword ptr -8
.text:0000BD6C var_4           = dword ptr -4
.text:0000BD6C arg_0           = dword ptr  8
.text:0000BD6C arg_4           = dword ptr  0Ch
.text:0000BD6C arg_8           = dword ptr  10h
.text:0000BD6C arg_C           = dword ptr  14h
.text:0000BD6C
.text:0000BD6C                 push    ebp
.text:0000BD6D                 mov     ebp, esp
.text:0000BD6F                 sub     esp, 8
.text:0000BD72                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000BD79                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BD80                 mov     eax, [ebp+arg_4]
.text:0000BD83                 cmp     eax, [ebp+arg_C]
.text:0000BD86                 ja      short loc_BD9B
.text:0000BD88                 jb      short loc_BD92
.text:0000BD8A                 mov     ecx, [ebp+arg_0]
.text:0000BD8D                 cmp     ecx, [ebp+arg_8]
.text:0000BD90                 jnb     short loc_BD9B
.text:0000BD92
.text:0000BD92 loc_BD92:                               ; CODE XREF: MyCompare<unsigned __int64>(unsigned __int64,unsigned __int64)+1Cj
.text:0000BD92                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000BD99                 jmp     short loc_BDC1
.text:0000BD9B ; ---------------------------------------------------------------------------
.text:0000BD9B
.text:0000BD9B loc_BD9B:                               ; CODE XREF: MyCompare<unsigned __int64>(unsigned __int64,unsigned __int64)+1Aj
.text:0000BD9B                                         ; MyCompare<unsigned __int64>(unsigned __int64,unsigned __int64)+24j
.text:0000BD9B                 mov     edx, [ebp+arg_0]
.text:0000BD9E                 cmp     edx, [ebp+arg_8]
.text:0000BDA1                 jnz     short loc_BDB4
.text:0000BDA3                 mov     eax, [ebp+arg_4]
.text:0000BDA6                 cmp     eax, [ebp+arg_C]
.text:0000BDA9                 jnz     short loc_BDB4
.text:0000BDAB                 mov     [ebp+var_8], 0
.text:0000BDB2                 jmp     short loc_BDBB
.text:0000BDB4 ; ---------------------------------------------------------------------------
.text:0000BDB4
.text:0000BDB4 loc_BDB4:                               ; CODE XREF: MyCompare<unsigned __int64>(unsigned __int64,unsigned __int64)+35j
.text:0000BDB4                                         ; MyCompare<unsigned __int64>(unsigned __int64,unsigned __int64)+3Dj
.text:0000BDB4                 mov     [ebp+var_8], 1
.text:0000BDBB
.text:0000BDBB loc_BDBB:                               ; CODE XREF: MyCompare<unsigned __int64>(unsigned __int64,unsigned __int64)+46j
.text:0000BDBB                 mov     ecx, [ebp+var_8]
.text:0000BDBE                 mov     [ebp+var_4], ecx
.text:0000BDC1
.text:0000BDC1 loc_BDC1:                               ; CODE XREF: MyCompare<unsigned __int64>(unsigned __int64,unsigned __int64)+2Dj
.text:0000BDC1                 mov     eax, [ebp+var_4]
.text:0000BDC4                 mov     esp, ebp
.text:0000BDC6                 pop     ebp
.text:0000BDC7                 retn    10h
.text:0000BDC7 ??$MyCompare@_K@@YGH_K0@Z endp
.text:0000BDC7
.text:0000BDC7 ; ---------------------------------------------------------------------------
.text:0000BDCA                 align 4
.text:0000BDCA _text           ends
.text:0000BDCA
.text:0000BDCC ; ===========================================================================
.text:0000BDCC
.text:0000BDCC ; Segment type: Pure code
.text:0000BDCC ; Segment permissions: Read/Execute
.text:0000BDCC _text           segment para public 'CODE' use32
.text:0000BDCC                 assume cs:_text
.text:0000BDCC                 ;org 0BDCCh
.text:0000BDCC ; COMDAT (pick any)
.text:0000BDCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BDCC
.text:0000BDCC ; =============== S U B R O U T I N E =======================================
.text:0000BDCC
.text:0000BDCC ; Attributes: bp-based frame
.text:0000BDCC
.text:0000BDCC ; public: long __thiscall CMyComPtr<struct IFolderArchiveExtractCallback>::QueryInterface<struct ICompressProgressInfo>(struct _GUID const &, struct ICompressProgressInfo * *)const
.text:0000BDCC                 public ??$QueryInterface@UICompressProgressInfo@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUICompressProgressInfo@@@Z
.text:0000BDCC ??$QueryInterface@UICompressProgressInfo@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUICompressProgressInfo@@@Z proc near
.text:0000BDCC                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+100p
.text:0000BDCC
.text:0000BDCC var_4           = dword ptr -4
.text:0000BDCC arg_0           = dword ptr  8
.text:0000BDCC arg_4           = dword ptr  0Ch
.text:0000BDCC
.text:0000BDCC                 push    ebp
.text:0000BDCD                 mov     ebp, esp
.text:0000BDCF                 push    ecx
.text:0000BDD0                 push    esi
.text:0000BDD1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BDD8                 mov     [ebp+var_4], ecx
.text:0000BDDB                 mov     esi, esp
.text:0000BDDD                 mov     eax, [ebp+arg_4]
.text:0000BDE0                 push    eax
.text:0000BDE1                 mov     ecx, [ebp+arg_0]
.text:0000BDE4                 push    ecx
.text:0000BDE5                 mov     edx, [ebp+var_4]
.text:0000BDE8                 mov     eax, [edx]
.text:0000BDEA                 mov     ecx, [ebp+var_4]
.text:0000BDED                 mov     edx, [ecx]
.text:0000BDEF                 mov     eax, [eax]
.text:0000BDF1                 push    edx
.text:0000BDF2                 mov     ecx, [eax]
.text:0000BDF4                 call    ecx
.text:0000BDF6                 cmp     esi, esp
.text:0000BDF8                 call    __RTC_CheckEsp
.text:0000BDFD                 pop     esi
.text:0000BDFE                 add     esp, 4
.text:0000BE01                 cmp     ebp, esp
.text:0000BE03                 call    __RTC_CheckEsp
.text:0000BE08                 mov     esp, ebp
.text:0000BE0A                 pop     ebp
.text:0000BE0B                 retn    8
.text:0000BE0B ??$QueryInterface@UICompressProgressInfo@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUICompressProgressInfo@@@Z endp
.text:0000BE0B
.text:0000BE0B ; ---------------------------------------------------------------------------
.text:0000BE0E                 align 10h
.text:0000BE0E _text           ends
.text:0000BE0E
.text:0000BE10 ; ===========================================================================
.text:0000BE10
.text:0000BE10 ; Segment type: Pure code
.text:0000BE10 ; Segment permissions: Read/Execute
.text:0000BE10 _text           segment para public 'CODE' use32
.text:0000BE10                 assume cs:_text
.text:0000BE10                 ;org 0BE10h
.text:0000BE10 ; COMDAT (pick any)
.text:0000BE10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BE10
.text:0000BE10 ; =============== S U B R O U T I N E =======================================
.text:0000BE10
.text:0000BE10 ; Attributes: bp-based frame
.text:0000BE10
.text:0000BE10 ; public: long __thiscall CMyComPtr<struct IFolderArchiveExtractCallback>::QueryInterface<struct IArchiveExtractCallbackMessage>(struct _GUID const &, struct IArchiveExtractCallbackMessage * *)const
.text:0000BE10                 public ??$QueryInterface@UIArchiveExtractCallbackMessage@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIArchiveExtractCallbackMessage@@@Z
.text:0000BE10 ??$QueryInterface@UIArchiveExtractCallbackMessage@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIArchiveExtractCallbackMessage@@@Z proc near
.text:0000BE10                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+11Cp
.text:0000BE10
.text:0000BE10 var_4           = dword ptr -4
.text:0000BE10 arg_0           = dword ptr  8
.text:0000BE10 arg_4           = dword ptr  0Ch
.text:0000BE10
.text:0000BE10                 push    ebp
.text:0000BE11                 mov     ebp, esp
.text:0000BE13                 push    ecx
.text:0000BE14                 push    esi
.text:0000BE15                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BE1C                 mov     [ebp+var_4], ecx
.text:0000BE1F                 mov     esi, esp
.text:0000BE21                 mov     eax, [ebp+arg_4]
.text:0000BE24                 push    eax
.text:0000BE25                 mov     ecx, [ebp+arg_0]
.text:0000BE28                 push    ecx
.text:0000BE29                 mov     edx, [ebp+var_4]
.text:0000BE2C                 mov     eax, [edx]
.text:0000BE2E                 mov     ecx, [ebp+var_4]
.text:0000BE31                 mov     edx, [ecx]
.text:0000BE33                 mov     eax, [eax]
.text:0000BE35                 push    edx
.text:0000BE36                 mov     ecx, [eax]
.text:0000BE38                 call    ecx
.text:0000BE3A                 cmp     esi, esp
.text:0000BE3C                 call    __RTC_CheckEsp
.text:0000BE41                 pop     esi
.text:0000BE42                 add     esp, 4
.text:0000BE45                 cmp     ebp, esp
.text:0000BE47                 call    __RTC_CheckEsp
.text:0000BE4C                 mov     esp, ebp
.text:0000BE4E                 pop     ebp
.text:0000BE4F                 retn    8
.text:0000BE4F ??$QueryInterface@UIArchiveExtractCallbackMessage@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIArchiveExtractCallbackMessage@@@Z endp
.text:0000BE4F
.text:0000BE4F ; ---------------------------------------------------------------------------
.text:0000BE52                 align 4
.text:0000BE52 _text           ends
.text:0000BE52
.text:0000BE54 ; ===========================================================================
.text:0000BE54
.text:0000BE54 ; Segment type: Pure code
.text:0000BE54 ; Segment permissions: Read/Execute
.text:0000BE54 _text           segment para public 'CODE' use32
.text:0000BE54                 assume cs:_text
.text:0000BE54                 ;org 0BE54h
.text:0000BE54 ; COMDAT (pick any)
.text:0000BE54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BE54
.text:0000BE54 ; =============== S U B R O U T I N E =======================================
.text:0000BE54
.text:0000BE54 ; Attributes: bp-based frame
.text:0000BE54
.text:0000BE54 ; public: long __thiscall CMyComPtr<struct IFolderArchiveExtractCallback>::QueryInterface<struct IFolderArchiveExtractCallback2>(struct _GUID const &, struct IFolderArchiveExtractCallback2 * *)const
.text:0000BE54                 public ??$QueryInterface@UIFolderArchiveExtractCallback2@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIFolderArchiveExtractCallback2@@@Z
.text:0000BE54 ??$QueryInterface@UIFolderArchiveExtractCallback2@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIFolderArchiveExtractCallback2@@@Z proc near
.text:0000BE54                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+138p
.text:0000BE54
.text:0000BE54 var_4           = dword ptr -4
.text:0000BE54 arg_0           = dword ptr  8
.text:0000BE54 arg_4           = dword ptr  0Ch
.text:0000BE54
.text:0000BE54                 push    ebp
.text:0000BE55                 mov     ebp, esp
.text:0000BE57                 push    ecx
.text:0000BE58                 push    esi
.text:0000BE59                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BE60                 mov     [ebp+var_4], ecx
.text:0000BE63                 mov     esi, esp
.text:0000BE65                 mov     eax, [ebp+arg_4]
.text:0000BE68                 push    eax
.text:0000BE69                 mov     ecx, [ebp+arg_0]
.text:0000BE6C                 push    ecx
.text:0000BE6D                 mov     edx, [ebp+var_4]
.text:0000BE70                 mov     eax, [edx]
.text:0000BE72                 mov     ecx, [ebp+var_4]
.text:0000BE75                 mov     edx, [ecx]
.text:0000BE77                 mov     eax, [eax]
.text:0000BE79                 push    edx
.text:0000BE7A                 mov     ecx, [eax]
.text:0000BE7C                 call    ecx
.text:0000BE7E                 cmp     esi, esp
.text:0000BE80                 call    __RTC_CheckEsp
.text:0000BE85                 pop     esi
.text:0000BE86                 add     esp, 4
.text:0000BE89                 cmp     ebp, esp
.text:0000BE8B                 call    __RTC_CheckEsp
.text:0000BE90                 mov     esp, ebp
.text:0000BE92                 pop     ebp
.text:0000BE93                 retn    8
.text:0000BE93 ??$QueryInterface@UIFolderArchiveExtractCallback2@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIFolderArchiveExtractCallback2@@@Z endp
.text:0000BE93
.text:0000BE93 ; ---------------------------------------------------------------------------
.text:0000BE96                 align 4
.text:0000BE96 _text           ends
.text:0000BE96
.text:0000BE98 ; ===========================================================================
.text:0000BE98
.text:0000BE98 ; Segment type: Pure code
.text:0000BE98 ; Segment permissions: Read/Execute
.text:0000BE98 _text           segment para public 'CODE' use32
.text:0000BE98                 assume cs:_text
.text:0000BE98                 ;org 0BE98h
.text:0000BE98 ; COMDAT (pick any)
.text:0000BE98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BE98
.text:0000BE98 ; =============== S U B R O U T I N E =======================================
.text:0000BE98
.text:0000BE98 ; Attributes: bp-based frame
.text:0000BE98
.text:0000BE98 ; public: long __thiscall CMyComPtr<struct IFolderArchiveExtractCallback>::QueryInterface<struct IFolderExtractToStreamCallback>(struct _GUID const &, struct IFolderExtractToStreamCallback * *)const
.text:0000BE98                 public ??$QueryInterface@UIFolderExtractToStreamCallback@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIFolderExtractToStreamCallback@@@Z
.text:0000BE98 ??$QueryInterface@UIFolderExtractToStreamCallback@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIFolderExtractToStreamCallback@@@Z proc near
.text:0000BE98                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+154p
.text:0000BE98
.text:0000BE98 var_4           = dword ptr -4
.text:0000BE98 arg_0           = dword ptr  8
.text:0000BE98 arg_4           = dword ptr  0Ch
.text:0000BE98
.text:0000BE98                 push    ebp
.text:0000BE99                 mov     ebp, esp
.text:0000BE9B                 push    ecx
.text:0000BE9C                 push    esi
.text:0000BE9D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BEA4                 mov     [ebp+var_4], ecx
.text:0000BEA7                 mov     esi, esp
.text:0000BEA9                 mov     eax, [ebp+arg_4]
.text:0000BEAC                 push    eax
.text:0000BEAD                 mov     ecx, [ebp+arg_0]
.text:0000BEB0                 push    ecx
.text:0000BEB1                 mov     edx, [ebp+var_4]
.text:0000BEB4                 mov     eax, [edx]
.text:0000BEB6                 mov     ecx, [ebp+var_4]
.text:0000BEB9                 mov     edx, [ecx]
.text:0000BEBB                 mov     eax, [eax]
.text:0000BEBD                 push    edx
.text:0000BEBE                 mov     ecx, [eax]
.text:0000BEC0                 call    ecx
.text:0000BEC2                 cmp     esi, esp
.text:0000BEC4                 call    __RTC_CheckEsp
.text:0000BEC9                 pop     esi
.text:0000BECA                 add     esp, 4
.text:0000BECD                 cmp     ebp, esp
.text:0000BECF                 call    __RTC_CheckEsp
.text:0000BED4                 mov     esp, ebp
.text:0000BED6                 pop     ebp
.text:0000BED7                 retn    8
.text:0000BED7 ??$QueryInterface@UIFolderExtractToStreamCallback@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUIFolderExtractToStreamCallback@@@Z endp
.text:0000BED7
.text:0000BED7 ; ---------------------------------------------------------------------------
.text:0000BEDA                 align 4
.text:0000BEDA _text           ends
.text:0000BEDA
.text:0000BEDC ; ===========================================================================
.text:0000BEDC
.text:0000BEDC ; Segment type: Pure code
.text:0000BEDC ; Segment permissions: Read/Execute
.text:0000BEDC _text           segment para public 'CODE' use32
.text:0000BEDC                 assume cs:_text
.text:0000BEDC                 ;org 0BEDCh
.text:0000BEDC ; COMDAT (pick any)
.text:0000BEDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BEDC
.text:0000BEDC ; =============== S U B R O U T I N E =======================================
.text:0000BEDC
.text:0000BEDC ; Attributes: bp-based frame
.text:0000BEDC
.text:0000BEDC ; public: long __thiscall CMyComPtr<struct IFolderArchiveExtractCallback>::QueryInterface<struct ICryptoGetTextPassword>(struct _GUID const &, struct ICryptoGetTextPassword * *)const
.text:0000BEDC                 public ??$QueryInterface@UICryptoGetTextPassword@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUICryptoGetTextPassword@@@Z
.text:0000BEDC ??$QueryInterface@UICryptoGetTextPassword@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUICryptoGetTextPassword@@@Z proc near
.text:0000BEDC                                         ; CODE XREF: CArchiveExtractCallback::CryptoGetTextPassword(wchar_t * *)+80p
.text:0000BEDC
.text:0000BEDC var_4           = dword ptr -4
.text:0000BEDC arg_0           = dword ptr  8
.text:0000BEDC arg_4           = dword ptr  0Ch
.text:0000BEDC
.text:0000BEDC                 push    ebp
.text:0000BEDD                 mov     ebp, esp
.text:0000BEDF                 push    ecx
.text:0000BEE0                 push    esi
.text:0000BEE1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BEE8                 mov     [ebp+var_4], ecx
.text:0000BEEB                 mov     esi, esp
.text:0000BEED                 mov     eax, [ebp+arg_4]
.text:0000BEF0                 push    eax
.text:0000BEF1                 mov     ecx, [ebp+arg_0]
.text:0000BEF4                 push    ecx
.text:0000BEF5                 mov     edx, [ebp+var_4]
.text:0000BEF8                 mov     eax, [edx]
.text:0000BEFA                 mov     ecx, [ebp+var_4]
.text:0000BEFD                 mov     edx, [ecx]
.text:0000BEFF                 mov     eax, [eax]
.text:0000BF01                 push    edx
.text:0000BF02                 mov     ecx, [eax]
.text:0000BF04                 call    ecx
.text:0000BF06                 cmp     esi, esp
.text:0000BF08                 call    __RTC_CheckEsp
.text:0000BF0D                 pop     esi
.text:0000BF0E                 add     esp, 4
.text:0000BF11                 cmp     ebp, esp
.text:0000BF13                 call    __RTC_CheckEsp
.text:0000BF18                 mov     esp, ebp
.text:0000BF1A                 pop     ebp
.text:0000BF1B                 retn    8
.text:0000BF1B ??$QueryInterface@UICryptoGetTextPassword@@@?$CMyComPtr@UIFolderArchiveExtractCallback@@@@QBEJABU_GUID@@PAPAUICryptoGetTextPassword@@@Z endp
.text:0000BF1B
.text:0000BF1B ; ---------------------------------------------------------------------------
.text:0000BF1E                 align 10h
.text:0000BF1E _text           ends
.text:0000BF1E
.text:0000BF20 ; ===========================================================================
.text:0000BF20
.text:0000BF20 ; Segment type: Pure code
.text:0000BF20 ; Segment permissions: Read/Execute
.text:0000BF20 _text           segment para public 'CODE' use32
.text:0000BF20                 assume cs:_text
.text:0000BF20                 ;org 0BF20h
.text:0000BF20 ; COMDAT (pick any)
.text:0000BF20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF20
.text:0000BF20 ; =============== S U B R O U T I N E =======================================
.text:0000BF20
.text:0000BF20
.text:0000BF20 ; [thunk]:public: virtual unsigned long __stdcall CArchiveExtractCallback::Release`adjustor{4}' (void)
.text:0000BF20                 public ?Release@CArchiveExtractCallback@@W3AGKXZ
.text:0000BF20 ?Release@CArchiveExtractCallback@@W3AGKXZ proc near
.text:0000BF20                                         ; DATA XREF: .rdata:00007590o
.text:0000BF20
.text:0000BF20 arg_0           = dword ptr  4
.text:0000BF20
.text:0000BF20                 sub     [esp+arg_0], 4
.text:0000BF25                 jmp     ?Release@CArchiveExtractCallback@@UAGKXZ ; CArchiveExtractCallback::Release(void)
.text:0000BF25 ?Release@CArchiveExtractCallback@@W3AGKXZ endp
.text:0000BF25
.text:0000BF25 ; ---------------------------------------------------------------------------
.text:0000BF2A                 align 4
.text:0000BF2A _text           ends
.text:0000BF2A
.text:0000BF2C ; ===========================================================================
.text:0000BF2C
.text:0000BF2C ; Segment type: Pure code
.text:0000BF2C ; Segment permissions: Read/Execute
.text:0000BF2C _text           segment para public 'CODE' use32
.text:0000BF2C                 assume cs:_text
.text:0000BF2C                 ;org 0BF2Ch
.text:0000BF2C ; COMDAT (pick any)
.text:0000BF2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF2C
.text:0000BF2C ; =============== S U B R O U T I N E =======================================
.text:0000BF2C
.text:0000BF2C
.text:0000BF2C ; [thunk]:public: virtual unsigned long __stdcall CArchiveExtractCallback::Release`adjustor{8}' (void)
.text:0000BF2C                 public ?Release@CArchiveExtractCallback@@W7AGKXZ
.text:0000BF2C ?Release@CArchiveExtractCallback@@W7AGKXZ proc near
.text:0000BF2C                                         ; DATA XREF: .rdata:0000757Co
.text:0000BF2C
.text:0000BF2C arg_0           = dword ptr  4
.text:0000BF2C
.text:0000BF2C                 sub     [esp+arg_0], 8
.text:0000BF31                 jmp     ?Release@CArchiveExtractCallback@@UAGKXZ ; CArchiveExtractCallback::Release(void)
.text:0000BF31 ?Release@CArchiveExtractCallback@@W7AGKXZ endp
.text:0000BF31
.text:0000BF31 ; ---------------------------------------------------------------------------
.text:0000BF36                 align 4
.text:0000BF36 _text           ends
.text:0000BF36
.text:0000BF38 ; ===========================================================================
.text:0000BF38
.text:0000BF38 ; Segment type: Pure code
.text:0000BF38 ; Segment permissions: Read/Execute
.text:0000BF38 _text           segment para public 'CODE' use32
.text:0000BF38                 assume cs:_text
.text:0000BF38                 ;org 0BF38h
.text:0000BF38 ; COMDAT (pick any)
.text:0000BF38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF38
.text:0000BF38 ; =============== S U B R O U T I N E =======================================
.text:0000BF38
.text:0000BF38
.text:0000BF38 ; [thunk]:public: virtual long __stdcall CArchiveExtractCallback::SetTotal`adjustor{4}' (unsigned __int64)
.text:0000BF38                 public ?SetTotal@CArchiveExtractCallback@@W3AGJ_K@Z
.text:0000BF38 ?SetTotal@CArchiveExtractCallback@@W3AGJ_K@Z proc near
.text:0000BF38                                         ; DATA XREF: .rdata:00007594o
.text:0000BF38
.text:0000BF38 arg_0           = dword ptr  4
.text:0000BF38
.text:0000BF38                 sub     [esp+arg_0], 4
.text:0000BF3D                 jmp     ?SetTotal@CArchiveExtractCallback@@UAGJ_K@Z ; CArchiveExtractCallback::SetTotal(unsigned __int64)
.text:0000BF3D ?SetTotal@CArchiveExtractCallback@@W3AGJ_K@Z endp
.text:0000BF3D
.text:0000BF3D ; ---------------------------------------------------------------------------
.text:0000BF42                 align 4
.text:0000BF42 _text           ends
.text:0000BF42
.text:0000BF44 ; ===========================================================================
.text:0000BF44
.text:0000BF44 ; Segment type: Pure code
.text:0000BF44 ; Segment permissions: Read/Execute
.text:0000BF44 _text           segment para public 'CODE' use32
.text:0000BF44                 assume cs:_text
.text:0000BF44                 ;org 0BF44h
.text:0000BF44 ; COMDAT (pick any)
.text:0000BF44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF44
.text:0000BF44 ; =============== S U B R O U T I N E =======================================
.text:0000BF44
.text:0000BF44
.text:0000BF44 ; [thunk]:public: virtual unsigned long __stdcall CArchiveExtractCallback::Release`adjustor{12}' (void)
.text:0000BF44                 public ?Release@CArchiveExtractCallback@@WM@AGKXZ
.text:0000BF44 ?Release@CArchiveExtractCallback@@WM@AGKXZ proc near
.text:0000BF44                                         ; DATA XREF: .rdata:00007568o
.text:0000BF44
.text:0000BF44 arg_0           = dword ptr  4
.text:0000BF44
.text:0000BF44                 sub     [esp+arg_0], 0Ch
.text:0000BF49                 jmp     ?Release@CArchiveExtractCallback@@UAGKXZ ; CArchiveExtractCallback::Release(void)
.text:0000BF49 ?Release@CArchiveExtractCallback@@WM@AGKXZ endp
.text:0000BF49
.text:0000BF49 ; ---------------------------------------------------------------------------
.text:0000BF4E                 align 10h
.text:0000BF4E _text           ends
.text:0000BF4E
.text:0000BF50 ; ===========================================================================
.text:0000BF50
.text:0000BF50 ; Segment type: Pure code
.text:0000BF50 ; Segment permissions: Read/Execute
.text:0000BF50 _text           segment para public 'CODE' use32
.text:0000BF50                 assume cs:_text
.text:0000BF50                 ;org 0BF50h
.text:0000BF50 ; COMDAT (pick any)
.text:0000BF50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF50
.text:0000BF50 ; =============== S U B R O U T I N E =======================================
.text:0000BF50
.text:0000BF50
.text:0000BF50 ; [thunk]:public: virtual unsigned long __stdcall CArchiveExtractCallback::AddRef`adjustor{4}' (void)
.text:0000BF50                 public ?AddRef@CArchiveExtractCallback@@W3AGKXZ
.text:0000BF50 ?AddRef@CArchiveExtractCallback@@W3AGKXZ proc near
.text:0000BF50                                         ; DATA XREF: .rdata:0000758Co
.text:0000BF50
.text:0000BF50 arg_0           = dword ptr  4
.text:0000BF50
.text:0000BF50                 sub     [esp+arg_0], 4
.text:0000BF55                 jmp     ?AddRef@CArchiveExtractCallback@@UAGKXZ ; CArchiveExtractCallback::AddRef(void)
.text:0000BF55 ?AddRef@CArchiveExtractCallback@@W3AGKXZ endp
.text:0000BF55
.text:0000BF55 ; ---------------------------------------------------------------------------
.text:0000BF5A                 align 4
.text:0000BF5A _text           ends
.text:0000BF5A
.text:0000BF5C ; ===========================================================================
.text:0000BF5C
.text:0000BF5C ; Segment type: Pure code
.text:0000BF5C ; Segment permissions: Read/Execute
.text:0000BF5C _text           segment para public 'CODE' use32
.text:0000BF5C                 assume cs:_text
.text:0000BF5C                 ;org 0BF5Ch
.text:0000BF5C ; COMDAT (pick any)
.text:0000BF5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF5C
.text:0000BF5C ; =============== S U B R O U T I N E =======================================
.text:0000BF5C
.text:0000BF5C
.text:0000BF5C ; [thunk]:public: virtual unsigned long __stdcall CArchiveExtractCallback::AddRef`adjustor{8}' (void)
.text:0000BF5C                 public ?AddRef@CArchiveExtractCallback@@W7AGKXZ
.text:0000BF5C ?AddRef@CArchiveExtractCallback@@W7AGKXZ proc near
.text:0000BF5C                                         ; DATA XREF: .rdata:00007578o
.text:0000BF5C
.text:0000BF5C arg_0           = dword ptr  4
.text:0000BF5C
.text:0000BF5C                 sub     [esp+arg_0], 8
.text:0000BF61                 jmp     ?AddRef@CArchiveExtractCallback@@UAGKXZ ; CArchiveExtractCallback::AddRef(void)
.text:0000BF61 ?AddRef@CArchiveExtractCallback@@W7AGKXZ endp
.text:0000BF61
.text:0000BF61 ; ---------------------------------------------------------------------------
.text:0000BF66                 align 4
.text:0000BF66 _text           ends
.text:0000BF66
.text:0000BF68 ; ===========================================================================
.text:0000BF68
.text:0000BF68 ; Segment type: Pure code
.text:0000BF68 ; Segment permissions: Read/Execute
.text:0000BF68 _text           segment para public 'CODE' use32
.text:0000BF68                 assume cs:_text
.text:0000BF68                 ;org 0BF68h
.text:0000BF68 ; COMDAT (pick any)
.text:0000BF68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF68
.text:0000BF68 ; =============== S U B R O U T I N E =======================================
.text:0000BF68
.text:0000BF68
.text:0000BF68 ; [thunk]:public: virtual long __stdcall CArchiveExtractCallback::QueryInterface`adjustor{4}' (struct _GUID const &, void * *)
.text:0000BF68                 public ?QueryInterface@CArchiveExtractCallback@@W3AGJABU_GUID@@PAPAX@Z
.text:0000BF68 ?QueryInterface@CArchiveExtractCallback@@W3AGJABU_GUID@@PAPAX@Z proc near
.text:0000BF68                                         ; DATA XREF: .rdata:const CArchiveExtractCallback::`vftable'{for `IArchiveExtractCallbackMessage'}o
.text:0000BF68
.text:0000BF68 arg_0           = dword ptr  4
.text:0000BF68
.text:0000BF68                 sub     [esp+arg_0], 4
.text:0000BF6D                 jmp     ?QueryInterface@CArchiveExtractCallback@@UAGJABU_GUID@@PAPAX@Z ; CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)
.text:0000BF6D ?QueryInterface@CArchiveExtractCallback@@W3AGJABU_GUID@@PAPAX@Z endp
.text:0000BF6D
.text:0000BF6D ; ---------------------------------------------------------------------------
.text:0000BF72                 align 4
.text:0000BF72 _text           ends
.text:0000BF72
.text:0000BF74 ; ===========================================================================
.text:0000BF74
.text:0000BF74 ; Segment type: Pure code
.text:0000BF74 ; Segment permissions: Read/Execute
.text:0000BF74 _text           segment para public 'CODE' use32
.text:0000BF74                 assume cs:_text
.text:0000BF74                 ;org 0BF74h
.text:0000BF74 ; COMDAT (pick any)
.text:0000BF74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF74
.text:0000BF74 ; =============== S U B R O U T I N E =======================================
.text:0000BF74
.text:0000BF74
.text:0000BF74 ; [thunk]:public: virtual unsigned long __stdcall CArchiveExtractCallback::AddRef`adjustor{12}' (void)
.text:0000BF74                 public ?AddRef@CArchiveExtractCallback@@WM@AGKXZ
.text:0000BF74 ?AddRef@CArchiveExtractCallback@@WM@AGKXZ proc near
.text:0000BF74                                         ; DATA XREF: .rdata:00007564o
.text:0000BF74
.text:0000BF74 arg_0           = dword ptr  4
.text:0000BF74
.text:0000BF74                 sub     [esp+arg_0], 0Ch
.text:0000BF79                 jmp     ?AddRef@CArchiveExtractCallback@@UAGKXZ ; CArchiveExtractCallback::AddRef(void)
.text:0000BF79 ?AddRef@CArchiveExtractCallback@@WM@AGKXZ endp
.text:0000BF79
.text:0000BF79 ; ---------------------------------------------------------------------------
.text:0000BF7E                 align 10h
.text:0000BF7E _text           ends
.text:0000BF7E
.text:0000BF80 ; ===========================================================================
.text:0000BF80
.text:0000BF80 ; Segment type: Pure code
.text:0000BF80 ; Segment permissions: Read/Execute
.text:0000BF80 _text           segment para public 'CODE' use32
.text:0000BF80                 assume cs:_text
.text:0000BF80                 ;org 0BF80h
.text:0000BF80 ; COMDAT (pick any)
.text:0000BF80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF80
.text:0000BF80 ; =============== S U B R O U T I N E =======================================
.text:0000BF80
.text:0000BF80
.text:0000BF80 ; [thunk]:public: virtual long __stdcall CArchiveExtractCallback::QueryInterface`adjustor{8}' (struct _GUID const &, void * *)
.text:0000BF80                 public ?QueryInterface@CArchiveExtractCallback@@W7AGJABU_GUID@@PAPAX@Z
.text:0000BF80 ?QueryInterface@CArchiveExtractCallback@@W7AGJABU_GUID@@PAPAX@Z proc near
.text:0000BF80                                         ; DATA XREF: .rdata:const CArchiveExtractCallback::`vftable'{for `ICryptoGetTextPassword'}o
.text:0000BF80
.text:0000BF80 arg_0           = dword ptr  4
.text:0000BF80
.text:0000BF80                 sub     [esp+arg_0], 8
.text:0000BF85                 jmp     ?QueryInterface@CArchiveExtractCallback@@UAGJABU_GUID@@PAPAX@Z ; CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)
.text:0000BF85 ?QueryInterface@CArchiveExtractCallback@@W7AGJABU_GUID@@PAPAX@Z endp
.text:0000BF85
.text:0000BF85 ; ---------------------------------------------------------------------------
.text:0000BF8A                 align 4
.text:0000BF8A _text           ends
.text:0000BF8A
.text:0000BF8C ; ===========================================================================
.text:0000BF8C
.text:0000BF8C ; Segment type: Pure code
.text:0000BF8C ; Segment permissions: Read/Execute
.text:0000BF8C _text           segment para public 'CODE' use32
.text:0000BF8C                 assume cs:_text
.text:0000BF8C                 ;org 0BF8Ch
.text:0000BF8C ; COMDAT (pick any)
.text:0000BF8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF8C
.text:0000BF8C ; =============== S U B R O U T I N E =======================================
.text:0000BF8C
.text:0000BF8C
.text:0000BF8C ; [thunk]:public: virtual long __stdcall CArchiveExtractCallback::QueryInterface`adjustor{12}' (struct _GUID const &, void * *)
.text:0000BF8C                 public ?QueryInterface@CArchiveExtractCallback@@WM@AGJABU_GUID@@PAPAX@Z
.text:0000BF8C ?QueryInterface@CArchiveExtractCallback@@WM@AGJABU_GUID@@PAPAX@Z proc near
.text:0000BF8C                                         ; DATA XREF: .rdata:const CArchiveExtractCallback::`vftable'{for `ICompressProgressInfo'}o
.text:0000BF8C
.text:0000BF8C arg_0           = dword ptr  4
.text:0000BF8C
.text:0000BF8C                 sub     [esp+arg_0], 0Ch
.text:0000BF91                 jmp     ?QueryInterface@CArchiveExtractCallback@@UAGJABU_GUID@@PAPAX@Z ; CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)
.text:0000BF91 ?QueryInterface@CArchiveExtractCallback@@WM@AGJABU_GUID@@PAPAX@Z endp
.text:0000BF91
.text:0000BF91 ; ---------------------------------------------------------------------------
.text:0000BF96                 align 4
.text:0000BF96 _text           ends
.text:0000BF96
.text:0000BF98 ; ===========================================================================
.text:0000BF98
.text:0000BF98 ; Segment type: Pure code
.text:0000BF98 ; Segment permissions: Read/Execute
.text:0000BF98 _text           segment para public 'CODE' use32
.text:0000BF98                 assume cs:_text
.text:0000BF98                 ;org 0BF98h
.text:0000BF98 ; COMDAT (pick any)
.text:0000BF98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF98
.text:0000BF98 ; =============== S U B R O U T I N E =======================================
.text:0000BF98
.text:0000BF98
.text:0000BF98 ; [thunk]:public: virtual long __stdcall CArchiveExtractCallback::SetCompleted`adjustor{4}' (unsigned __int64 const *)
.text:0000BF98                 public ?SetCompleted@CArchiveExtractCallback@@W3AGJPB_K@Z
.text:0000BF98 ?SetCompleted@CArchiveExtractCallback@@W3AGJPB_K@Z proc near
.text:0000BF98                                         ; DATA XREF: .rdata:00007598o
.text:0000BF98
.text:0000BF98 arg_0           = dword ptr  4
.text:0000BF98
.text:0000BF98                 sub     [esp+arg_0], 4
.text:0000BF9D                 jmp     ?SetCompleted@CArchiveExtractCallback@@UAGJPB_K@Z ; CArchiveExtractCallback::SetCompleted(unsigned __int64 const *)
.text:0000BF9D ?SetCompleted@CArchiveExtractCallback@@W3AGJPB_K@Z endp
.text:0000BF9D
.text:0000BF9D _text           ends
.text:0000BF9D
UNDEF:0000BFB0 ; ===========================================================================
UNDEF:0000BFB0
UNDEF:0000BFB0 ; Segment type: Externs
UNDEF:0000BFB0 ; UNDEF
UNDEF:0000BFB0                 extrn __RTC_CheckEsp:near
UNDEF:0000BFB0                                         ; CODE XREF: COutStreamWithHash::Write(void const *,uint,uint *)+57p
UNDEF:0000BFB0                                         ; COutStreamWithHash::Write(void const *,uint,uint *)+89p ...
UNDEF:0000BFB4                 extrn __RTC_Shutdown:near
UNDEF:0000BFB4                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:0000BFB8                 extrn __RTC_InitBase:near
UNDEF:0000BFB8                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:0000BFBC ; DWORD __stdcall GetLastError()
UNDEF:0000BFBC                 extrn __imp__GetLastError@0:near
UNDEF:0000BFBC                                         ; CODE XREF: InitLocalPrivileges(void)+F5p
UNDEF:0000BFBC                                         ; CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)+3Dp
UNDEF:0000BFBC                                         ; DATA XREF: ...
UNDEF:0000BFC0 ; BOOL __stdcall LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
UNDEF:0000BFC0                 extrn __imp__LookupPrivilegeValueA@12:near
UNDEF:0000BFC0                                         ; CODE XREF: InitLocalPrivileges(void)+9Fp
UNDEF:0000BFC0                                         ; DATA XREF: InitLocalPrivileges(void)+9Fr
UNDEF:0000BFC4 ; HANDLE __stdcall GetCurrentProcess()
UNDEF:0000BFC4                 extrn __imp__GetCurrentProcess@0:near
UNDEF:0000BFC4                                         ; CODE XREF: InitLocalPrivileges(void)+4Cp
UNDEF:0000BFC4                                         ; DATA XREF: InitLocalPrivileges(void)+4Cr
UNDEF:0000BFC8                 extrn ___security_cookie:near
UNDEF:0000BFC8                                         ; DATA XREF: InitLocalPrivileges(void)+25r
UNDEF:0000BFC8                                         ; CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+19r ...
UNDEF:0000BFCC                 extrn ___CxxFrameHandler3:near
UNDEF:0000BFCC                                         ; CODE XREF: __ehhandler$?InitLocalPrivileges@@YG_NXZ+20j
UNDEF:0000BFCC                                         ; __ehhandler$?Archive_Get_HardLinkNode@@YGJPAUIInArchive@@IAAUCHardLinkNode@@AA_N@Z+16j ...
UNDEF:0000BFD0 ; __fastcall __security_check_cookie(x)
UNDEF:0000BFD0                 extrn @__security_check_cookie@4:near
UNDEF:0000BFD0                                         ; CODE XREF: InitLocalPrivileges(void)+141p
UNDEF:0000BFD0                                         ; CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+265p ...
UNDEF:0000BFD4 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:0000BFD4                 extrn @_RTC_CheckStackVars@8:near
UNDEF:0000BFD4                                         ; CODE XREF: InitLocalPrivileges(void)+128p
UNDEF:0000BFD4                                         ; CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+257p ...
UNDEF:0000BFD8 ; BOOL __stdcall CloseHandle(HANDLE hObject)
UNDEF:0000BFD8                 extrn __imp__CloseHandle@4:near
UNDEF:0000BFD8                                         ; CODE XREF: NWindows::NSecurity::CAccessToken::Close(void)+2Cp
UNDEF:0000BFD8                                         ; DATA XREF: NWindows::NSecurity::CAccessToken::Close(void)+2Cr
UNDEF:0000BFDC ; BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
UNDEF:0000BFDC                 extrn __imp__OpenProcessToken@12:near
UNDEF:0000BFDC                                         ; CODE XREF: NWindows::NSecurity::CAccessToken::OpenProcessToken(void *,ulong)+25p
UNDEF:0000BFDC                                         ; DATA XREF: NWindows::NSecurity::CAccessToken::OpenProcessToken(void *,ulong)+25r
UNDEF:0000BFE0 ; BOOL __stdcall AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
UNDEF:0000BFE0                 extrn __imp__AdjustTokenPrivileges@24:near
UNDEF:0000BFE0                                         ; CODE XREF: NWindows::NSecurity::CAccessToken::AdjustPrivileges(bool,_TOKEN_PRIVILEGES *,ulong,_TOKEN_PRIVILEGES *,ulong *)+32p
UNDEF:0000BFE0                                         ; DATA XREF: NWindows::NSecurity::CAccessToken::AdjustPrivileges(bool,_TOKEN_PRIVILEGES *,ulong,_TOKEN_PRIVILEGES *,ulong *)+32r
UNDEF:0000BFE4 ; __int32 __stdcall Archive_IsItem_AltStream(struct IInArchive *, unsigned int, bool *)
UNDEF:0000BFE4                 extrn ?Archive_IsItem_AltStream@@YGJPAUIInArchive@@IAA_N@Z:near
UNDEF:0000BFE4                                         ; CODE XREF: CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)+126p
UNDEF:0000BFE8 ; __int32 __thiscall NWindows::NCOM::CPropVariant::Clear(NWindows::NCOM::CPropVariant *__hidden this)
UNDEF:0000BFE8                 extrn ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ:near
UNDEF:0000BFE8                                         ; CODE XREF: NWindows::NCOM::CPropVariant::~CPropVariant(void)+11p
UNDEF:0000BFEC ; __stdcall _CxxThrowException(x, x)
UNDEF:0000BFEC                 extrn __CxxThrowException@8:near
UNDEF:0000BFEC                                         ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+99p
UNDEF:0000BFF0 ; const type_info::`vftable'
UNDEF:0000BFF0                 extrn ??_7type_info@@6B@:near
UNDEF:0000BFF0                                         ; DATA XREF: .data:int `RTTI Type Descriptor'o
UNDEF:0000BFF0                                         ; .data:CArchiveExtractCallback `RTTI Type Descriptor'o ...
UNDEF:0000BFF4 ; void __cdecl operator delete(void *)
UNDEF:0000BFF4                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$??0CArchiveExtractCallback@@QAE@XZ$19+4p
UNDEF:0000BFF4                                         ; __unwindfunclet$?GetStream@CArchiveExtractCallback@@UAGJIPAPAUISequentialOutStream@@H@Z$11+7p ...
UNDEF:0000BFF8 ; _DWORD __thiscall CLocalProgress::CLocalProgress(CLocalProgress *__hidden this)
UNDEF:0000BFF8                 extrn ??0CLocalProgress@@QAE@XZ:near
UNDEF:0000BFF8                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+21Cp
UNDEF:0000BFFC ; void *__cdecl operator new(unsigned int)
UNDEF:0000BFFC                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+204p
UNDEF:0000BFFC                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+D99p ...
UNDEF:0000C000 ; public: __thiscall UString::UString(void)
UNDEF:0000C000                 extrn ??0UString@@QAE@XZ:near
UNDEF:0000C000                                         ; CODE XREF: CArchiveExtractCallback::CArchiveExtractCallback(void)+F3p
UNDEF:0000C000                                         ; CArchiveExtractCallback::CArchiveExtractCallback(void)+102p ...
UNDEF:0000C004                 extrn __purecall:near   ; DATA XREF: .rdata:const ICryptoGetTextPassword::`vftable'o
UNDEF:0000C004                                         ; .rdata:00007AC0o ...
UNDEF:0000C008                 extrn _IID_ICompressProgressInfo:near
UNDEF:0000C008                                         ; DATA XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+F5o
UNDEF:0000C008                                         ; CArchiveExtractCallback::QueryInterface(_GUID const &,void * *):loc_7D5Fo
UNDEF:0000C00C                 extrn _IID_ICryptoGetTextPassword:near
UNDEF:0000C00C                                         ; DATA XREF: CArchiveExtractCallback::CryptoGetTextPassword(wchar_t * *)+75o
UNDEF:0000C00C                                         ; CArchiveExtractCallback::QueryInterface(_GUID const &,void * *):loc_7D2Bo
UNDEF:0000C010                 extrn _IID_IArchiveExtractCallbackMessage:near
UNDEF:0000C010                                         ; DATA XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+111o
UNDEF:0000C010                                         ; CArchiveExtractCallback::QueryInterface(_GUID const &,void * *):loc_7CF7o
UNDEF:0000C014 ; const IID IID_IUnknown
UNDEF:0000C014                 extrn _IID_IUnknown:near
UNDEF:0000C014                                         ; DATA XREF: CArchiveExtractCallback::QueryInterface(_GUID const &,void * *)+20o
UNDEF:0000C014                                         ; CStdOutFileStream::QueryInterface(_GUID const &,void * *)+Co ...
UNDEF:0000C018 ; int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
UNDEF:0000C018                 extrn _memcmp:near      ; CODE XREF: IsEqualGUID(x,x)+Dp
UNDEF:0000C01C ; bool NWindows::NFile::NDir::MyGetFullPathName(NWindows::NFile::NDir *__hidden this, const wchar_t *, struct UString *)
UNDEF:0000C01C                 extrn ?MyGetFullPathName@NDir@NFile@NWindows@@YG_NPB_WAAVUString@@@Z:near
UNDEF:0000C01C                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+265p
UNDEF:0000C020 ; void NWindows::NFile::NName::NormalizeDirPathPrefix(NWindows::NFile::NName *__hidden this, struct UString *)
UNDEF:0000C020                 extrn ?NormalizeDirPathPrefix@NName@NFile@NWindows@@YGXAAVUString@@@Z:near
UNDEF:0000C020                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+250p
UNDEF:0000C020                                         ; CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+271p
UNDEF:0000C024 ; bool NWindows::NFile::NName::IsAltPathPrefix(NWindows::NFile::NName *__hidden this, const wchar_t *)
UNDEF:0000C024                 extrn ?IsAltPathPrefix@NName@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000C024                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+23Dp
UNDEF:0000C028 ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:0000C028                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:0000C028                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+21Dp
UNDEF:0000C028                                         ; CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+22Cp ...
UNDEF:0000C02C ; void __thiscall CLocalProgress::Init(CLocalProgress *__hidden this, struct IProgress *, bool)
UNDEF:0000C02C                 extrn ?Init@CLocalProgress@@QAEXPAUIProgress@@_N@Z:near
UNDEF:0000C02C                                         ; CODE XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+1C3p
UNDEF:0000C030                 extrn _IID_IFolderExtractToStreamCallback:near
UNDEF:0000C030                                         ; DATA XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+149o
UNDEF:0000C034                 extrn _IID_IFolderArchiveExtractCallback2:near
UNDEF:0000C034                                         ; DATA XREF: CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)+12Do
UNDEF:0000C038                 extrn __aulldiv:near    ; CODE XREF: MyMultDiv64(unsigned __int64,unsigned __int64,unsigned __int64)+52p
UNDEF:0000C03C                 extrn __allmul:near     ; CODE XREF: MyMultDiv64(unsigned __int64,unsigned __int64,unsigned __int64)+43p
UNDEF:0000C040                 extrn __aullshr:near    ; CODE XREF: NormalizeVals(unsigned __int64 &,unsigned __int64 &)+4Dp
UNDEF:0000C040                                         ; NormalizeVals(unsigned __int64 &,unsigned __int64 &)+64p
UNDEF:0000C044 ; bool NWindows::NFile::NDir::CreateDir(NWindows::NFile::NDir *__hidden this, const wchar_t *)
UNDEF:0000C044                 extrn ?CreateDir@NDir@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000C044                                         ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+119p
UNDEF:0000C048 ; public: class UString & __thiscall UString::operator+=(class UString const &)
UNDEF:0000C048                 extrn ??YUString@@QAEAAV0@ABV0@@Z:near
UNDEF:0000C048                                         ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+D8p
UNDEF:0000C048                                         ; AddPathToMessage(UString &,UString const &)+17p ...
UNDEF:0000C04C ; bool NWindows::NFile::NName::IsDrivePath2(NWindows::NFile::NName *__hidden this, const wchar_t *)
UNDEF:0000C04C                 extrn ?IsDrivePath2@NName@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000C04C                                         ; CODE XREF: CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+5Bp
UNDEF:0000C04C                                         ; CArchiveExtractCallback::CreateComplexDirectory(CObjectVector<UString> const &,UString &)+102p
UNDEF:0000C050 ; void __thiscall UString::Grow_1(UString *__hidden this)
UNDEF:0000C050                 extrn ?Grow_1@UString@@AAEXXZ:near
UNDEF:0000C050                                         ; CODE XREF: UString::operator+=(wchar_t)+2Fp
UNDEF:0000C054 ; __int32 __thiscall CArc::GetItemSize(CArc *__hidden this, unsigned int, unsigned __int64 *, bool *)
UNDEF:0000C054                 extrn ?GetItemSize@CArc@@QBEJIAA_KAA_N@Z:near
UNDEF:0000C054                                         ; CODE XREF: CArchiveExtractCallback::GetUnpackSize(void)+31p
UNDEF:0000C058 ; void __thiscall UString::AddAscii(UString *__hidden this, const char *)
UNDEF:0000C058                 extrn ?AddAscii@UString@@QAEXPBD@Z:near
UNDEF:0000C058                                         ; CODE XREF: CArchiveExtractCallback::SendMessageError(char const *,UString const &)+5Cp
UNDEF:0000C058                                         ; AddPathToMessage(UString &,UString const &)+Bp ...
UNDEF:0000C05C ; struct UString __stdcall __high NWindows::NError::MyFormatMessage(unsigned __int32)
UNDEF:0000C05C                 extrn ?MyFormatMessage@NError@NWindows@@YG?AVUString@@K@Z:near
UNDEF:0000C05C                                         ; CODE XREF: CArchiveExtractCallback::SendMessageError_with_LastError(char const *,UString const &)+83p
UNDEF:0000C060 ; public: bool __thiscall NWildcard::CCensorNode::CheckPathVect(class CObjectVector<class UString> const &, bool, bool &)const
UNDEF:0000C060                 extrn ?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z:near
UNDEF:0000C060                                         ; CODE XREF: CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+57p
UNDEF:0000C060                                         ; CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)+FAp
UNDEF:0000C064 ; bool NWindows::NFile::NIO::SetReparseData(NWindows::NFile::NIO *__hidden this, const wchar_t *, bool, const void *, unsigned __int32)
UNDEF:0000C064                 extrn ?SetReparseData@NIO@NFile@NWindows@@YG_NPB_W_NPBXK@Z:near
UNDEF:0000C064                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2B12p
UNDEF:0000C068 ; bool __stdcall NWindows::NFile::FillLinkData(class CBuffer<unsigned char> &, wchar_t const *, bool)
UNDEF:0000C068                 extrn ?FillLinkData@NFile@NWindows@@YG_NAAV?$CBuffer@E@@PB_W_N@Z:near
UNDEF:0000C068                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+297Cp
UNDEF:0000C06C ; bool NWindows::NFile::NDir::MyCreateHardLink(NWindows::NFile::NDir *__hidden this, const wchar_t *, const wchar_t *)
UNDEF:0000C06C                 extrn ?MyCreateHardLink@NDir@NFile@NWindows@@YG_NPB_W0@Z:near
UNDEF:0000C06C                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2869p
UNDEF:0000C06C                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2DBBp
UNDEF:0000C070 ; bool NWindows::NFile::NName::GetFullPath(NWindows::NFile::NName *__hidden this, const wchar_t *, const wchar_t *, struct UString *)
UNDEF:0000C070                 extrn ?GetFullPath@NName@NFile@NWindows@@YG_NPB_W0AAVUString@@@Z:near
UNDEF:0000C070                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2745p
UNDEF:0000C074 ; bool NWindows::NFile::NDir::SetFileAttrib(NWindows::NFile::NDir *__hidden this, const wchar_t *, unsigned __int32)
UNDEF:0000C074                 extrn ?SetFileAttrib@NDir@NFile@NWindows@@YG_NPB_WK@Z:near
UNDEF:0000C074                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2548p
UNDEF:0000C074                                         ; CArchiveExtractCallback::SetOperationResult(int)+4E7p
UNDEF:0000C078 ; int NWindows::NFile::NName::FindAltStreamColon(NWindows::NFile::NName *__hidden this, const wchar_t *)
UNDEF:0000C078                 extrn ?FindAltStreamColon@NName@NFile@NWindows@@YGHPB_W@Z:near
UNDEF:0000C078                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2445p
UNDEF:0000C07C ; bool NWindows::NFile::NDir::DeleteFileAlways(NWindows::NFile::NDir *__hidden this, const wchar_t *)
UNDEF:0000C07C                 extrn ?DeleteFileAlways@NDir@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000C07C                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2322p
UNDEF:0000C080 ; bool NWindows::NFile::NDir::MyMoveFile(NWindows::NFile::NDir *__hidden this, const wchar_t *, const wchar_t *)
UNDEF:0000C080                 extrn ?MyMoveFile@NDir@NFile@NWindows@@YG_NPB_W0@Z:near
UNDEF:0000C080                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+2070p
UNDEF:0000C084 ; bool __stdcall AutoRenamePath(struct UString *)
UNDEF:0000C084                 extrn ?AutoRenamePath@@YG_NAAVUString@@@Z:near
UNDEF:0000C084                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1DD9p
UNDEF:0000C084                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1F1Bp
UNDEF:0000C088 ; class UString __stdcall operator+(class UString const &, class UString const &)
UNDEF:0000C088                 extrn ??H@YG?AVUString@@ABV0@0@Z:near
UNDEF:0000C088                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1A39p
UNDEF:0000C08C ; int __thiscall UString::ReverseFind_PathSepar(UString *__hidden this)
UNDEF:0000C08C                 extrn ?ReverseFind_PathSepar@UString@@QBEHXZ:near
UNDEF:0000C08C                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+19E7p
UNDEF:0000C08C                                         ; GetDirPrefixOf(UString const &)+8Bp
UNDEF:0000C090 ; bool __thiscall NWindows::NFile::NFind::CFileInfo::Find(NWindows::NFile::NFind::CFileInfo *__hidden this, const wchar_t *)
UNDEF:0000C090                 extrn ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z:near
UNDEF:0000C090                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1947p
UNDEF:0000C090                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+24F4p
UNDEF:0000C094 ; bool NWindows::NFile::NDir::RemoveDir(NWindows::NFile::NDir *__hidden this, const wchar_t *)
UNDEF:0000C094                 extrn ?RemoveDir@NDir@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000C094                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1891p
UNDEF:0000C094                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+21E8p
UNDEF:0000C098 ; bool NWindows::NFile::NName::IsAbsolutePath(NWindows::NFile::NName *__hidden this, const wchar_t *)
UNDEF:0000C098                 extrn ?IsAbsolutePath@NName@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000C098                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+16C7p
UNDEF:0000C09C ; bool NWindows::NFile::NDir::SetDirTime(NWindows::NFile::NDir *__hidden this, const wchar_t *, const struct _FILETIME *, const struct _FILETIME *, const struct _FILETIME *)
UNDEF:0000C09C                 extrn ?SetDirTime@NDir@NFile@NWindows@@YG_NPB_WPBU_FILETIME@@11@Z:near
UNDEF:0000C09C                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1676p
UNDEF:0000C09C                                         ; CArchiveExtractCallback::SetDirsTimes(void)+2E5p
UNDEF:0000C0A0 ; unsigned int __stdcall NWildcard::GetNumPrefixParts_if_DrivePath(class CObjectVector<class UString> &)
UNDEF:0000C0A0                 extrn ?GetNumPrefixParts_if_DrivePath@NWildcard@@YGIAAV?$CObjectVector@VUString@@@@@Z:near
UNDEF:0000C0A0                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+13F4p
UNDEF:0000C0A4 ; void __stdcall Correct_AltStream_Name(struct UString *)
UNDEF:0000C0A4                 extrn ?Correct_AltStream_Name@@YGXAAVUString@@@Z:near
UNDEF:0000C0A4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1363p
UNDEF:0000C0A4                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1808p
UNDEF:0000C0A8 ; public: __thiscall UString::UString(class UString const &)
UNDEF:0000C0A8                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:0000C0A8                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+134Dp
UNDEF:0000C0A8                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1697p ...
UNDEF:0000C0AC ; void __stdcall Correct_FsPath(bool, class CObjectVector<class UString> &, bool)
UNDEF:0000C0AC                 extrn ?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z:near
UNDEF:0000C0AC                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+1327p
UNDEF:0000C0B0 ; __int32 __stdcall Archive_GetItemBoolProp(struct IInArchive *, unsigned int, unsigned __int32, bool *)
UNDEF:0000C0B0                 extrn ?Archive_GetItemBoolProp@@YGJPAUIInArchive@@IKAA_N@Z:near
UNDEF:0000C0B0                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+846p
UNDEF:0000C0B0                                         ; CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+EBp ...
UNDEF:0000C0B4 ; class UString __stdcall MakePathFromParts(class CObjectVector<class UString> const &)
UNDEF:0000C0B4                 extrn ?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z:near
UNDEF:0000C0B4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+7EAp
UNDEF:0000C0B4                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+E40p ...
UNDEF:0000C0B8 ; int __stdcall CompareFileNames(const wchar_t *, const wchar_t *)
UNDEF:0000C0B8                 extrn ?CompareFileNames@@YGHPB_W0@Z:near
UNDEF:0000C0B8                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+789p
UNDEF:0000C0B8                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+C17p
UNDEF:0000C0BC ; void __stdcall SplitPathToParts(class UString const &, class CObjectVector<class UString> &)
UNDEF:0000C0BC                 extrn ?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z:near
UNDEF:0000C0BC                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+6D9p
UNDEF:0000C0BC                                         ; IsSafePath(UString const &)+5Cp
UNDEF:0000C0C0 ; void __thiscall UString::DeleteFrontal(UString *__hidden this, unsigned int)
UNDEF:0000C0C0                 extrn ?DeleteFrontal@UString@@QAEXI@Z:near
UNDEF:0000C0C0                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+668p
UNDEF:0000C0C4 ; unsigned int NWindows::NFile::NName::GetRootPrefixSize(NWindows::NFile::NName *__hidden this, const wchar_t *)
UNDEF:0000C0C4                 extrn ?GetRootPrefixSize@NName@NFile@NWindows@@YGIPB_W@Z:near
UNDEF:0000C0C4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+644p
UNDEF:0000C0C8 ; void __thiscall UString::Replace(UString *__hidden this, wchar_t, wchar_t)
UNDEF:0000C0C8                 extrn ?Replace@UString@@QAEX_W0@Z:near
UNDEF:0000C0C8                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+62Ap
UNDEF:0000C0CC ; struct UString __thiscall __high NWindows::NFile::CReparseAttr::GetPath()
UNDEF:0000C0CC                 extrn ?GetPath@CReparseAttr@NFile@NWindows@@QBE?AVUString@@XZ:near
UNDEF:0000C0CC                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+57Fp
UNDEF:0000C0D0 ; bool __thiscall NWindows::NFile::CReparseAttr::Parse(NWindows::NFile::CReparseAttr *__hidden this, const unsigned __int8 *, unsigned int)
UNDEF:0000C0D0                 extrn ?Parse@CReparseAttr@NFile@NWindows@@QAE_NPBEI@Z:near
UNDEF:0000C0D0                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+54Cp
UNDEF:0000C0D0                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+29E1p
UNDEF:0000C0D4 ; void __thiscall UString::SetFromBstr(UString *__hidden this, wchar_t *)
UNDEF:0000C0D4                 extrn ?SetFromBstr@UString@@QAEXPA_W@Z:near
UNDEF:0000C0D4                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+307p
UNDEF:0000C0D4                                         ; CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+3E6p
UNDEF:0000C0D8 ; __int32 __thiscall CArc::GetItem(CArc *__hidden this, unsigned int, struct CReadArcItem *)
UNDEF:0000C0D8                 extrn ?GetItem@CArc@@QBEJIAAUCReadArcItem@@@Z:near
UNDEF:0000C0D8                                         ; CODE XREF: CArchiveExtractCallback::GetStream(uint,ISequentialOutStream * *,int)+17Ap
UNDEF:0000C0D8                                         ; CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+7Dp
UNDEF:0000C0DC ; private: __thiscall UString::UString(unsigned int, class UString const &)
UNDEF:0000C0DC                 extrn ??0UString@@AAE@IABV0@@Z:near
UNDEF:0000C0DC                                         ; CODE XREF: UString::Left(uint)+29p
UNDEF:0000C0E0 ; bool __thiscall NWindows::NFile::NIO::COutFile::Open(NWindows::NFile::NIO::COutFile *__hidden this, const wchar_t *, unsigned __int32)
UNDEF:0000C0E0                 extrn ?Open@COutFile@NIO@NFile@NWindows@@QAE_NPB_WK@Z:near
UNDEF:0000C0E0                                         ; CODE XREF: COutFileStream::Open(wchar_t const *,ulong)+2Dp
UNDEF:0000C0E4 ; public: virtual long __stdcall CStdOutFileStream::Write(void const *, unsigned int, unsigned int *)
UNDEF:0000C0E4                 extrn ?Write@CStdOutFileStream@@UAGJPBXIPAI@Z:near
UNDEF:0000C0E4                                         ; DATA XREF: .rdata:000089ECo
UNDEF:0000C0E8 ; public: virtual void * __thiscall CStdOutFileStream::`scalar deleting destructor'(unsigned int)
UNDEF:0000C0E8                 extrn ??_GCStdOutFileStream@@UAEPAXI@Z_0:near
UNDEF:0000C0EC ; public: virtual void * __thiscall CStdOutFileStream::`vector deleting destructor'(unsigned int)
UNDEF:0000C0EC                 extrn ??_ECStdOutFileStream@@UAEPAXI@Z:near ; weak
UNDEF:0000C0EC                                         ; DATA XREF: .rdata:000089F0o
UNDEF:0000C0F0 ; void __thiscall NWindows::NFile::NFind::CFileInfoBase::ClearBase(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
UNDEF:0000C0F0                 extrn ?ClearBase@CFileInfoBase@NFind@NFile@NWindows@@QAEXXZ:near
UNDEF:0000C0F0                                         ; CODE XREF: NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(void)+11p
UNDEF:0000C0F4 ; int __cdecl _wcscmp(const wchar_t *Str1, const wchar_t *Str2)
UNDEF:0000C0F4                 extrn __imp__wcscmp:near
UNDEF:0000C0F4                                         ; CODE XREF: operator==(UString const &,wchar_t const *)+13p
UNDEF:0000C0F4                                         ; DATA XREF: operator==(UString const &,wchar_t const *)+13r
UNDEF:0000C0F8 ; bool NWindows::NFile::NName::IsDriveRootPath_SuperAllowed(NWindows::NFile::NName *__hidden this, const wchar_t *)
UNDEF:0000C0F8                 extrn ?IsDriveRootPath_SuperAllowed@NName@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000C0F8                                         ; CODE XREF: MakePath_from_2_Parts(UString const &,UString const &)+A5p
UNDEF:0000C0FC                 extrn _IID_IGetProp:near
UNDEF:0000C0FC                                         ; DATA XREF: CGetProp::QueryInterface(_GUID const &,void * *):loc_9154o
UNDEF:0000C100 ; public: virtual long __stdcall COutFileStream::Write(void const *, unsigned int, unsigned int *)
UNDEF:0000C100                 extrn ?Write@COutFileStream@@UAGJPBXIPAI@Z:near
UNDEF:0000C100                                         ; DATA XREF: .rdata:0000929Co
UNDEF:0000C104 ; public: virtual long __stdcall COutFileStream::Seek(__int64, unsigned int, unsigned __int64 *)
UNDEF:0000C104                 extrn ?Seek@COutFileStream@@UAGJ_JIPA_K@Z:near
UNDEF:0000C104                                         ; DATA XREF: .rdata:000092A0o
UNDEF:0000C108 ; public: virtual long __stdcall COutFileStream::SetSize(unsigned __int64)
UNDEF:0000C108                 extrn ?SetSize@COutFileStream@@UAGJ_K@Z:near
UNDEF:0000C108                                         ; DATA XREF: .rdata:000092A4o
UNDEF:0000C10C ; public: virtual void * __thiscall COutFileStream::`scalar deleting destructor'(unsigned int)
UNDEF:0000C10C                 extrn ??_GCOutFileStream@@UAEPAXI@Z_0:near
UNDEF:0000C110 ; public: virtual void * __thiscall COutFileStream::`vector deleting destructor'(unsigned int)
UNDEF:0000C110                 extrn ??_ECOutFileStream@@UAEPAXI@Z:near ; weak
UNDEF:0000C110                                         ; DATA XREF: .rdata:000092A8o
UNDEF:0000C114                 extrn _IID_IOutStream:near
UNDEF:0000C114                                         ; DATA XREF: COutFileStream::QueryInterface(_GUID const &,void * *):loc_93A4o
UNDEF:0000C118 ; bool __thiscall NWindows::NFile::NIO::CFileBase::Close(NWindows::NFile::NIO::CFileBase *__hidden this)
UNDEF:0000C118                 extrn ?Close@CFileBase@NIO@NFile@NWindows@@QAE_NXZ:near
UNDEF:0000C118                                         ; CODE XREF: NWindows::NFile::NIO::CFileBase::~CFileBase(void)+11p
UNDEF:0000C11C ; BOOL __stdcall SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
UNDEF:0000C11C                 extrn __imp__SetFileSecurityW@12:near
UNDEF:0000C11C                                         ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+37Fp
UNDEF:0000C11C                                         ; DATA XREF: CArchiveExtractCallback::SetOperationResult(int)+37Fr
UNDEF:0000C120 ; bool __stdcall CheckNtSecure(const unsigned __int8 *, unsigned int)
UNDEF:0000C120                 extrn ?CheckNtSecure@@YG_NPBEI@Z:near
UNDEF:0000C120                                         ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+330p
UNDEF:0000C124 ; __int32 __thiscall COutFileStream::Close(COutFileStream *__hidden this)
UNDEF:0000C124                 extrn ?Close@COutFileStream@@QAEJXZ:near
UNDEF:0000C124                                         ; CODE XREF: CArchiveExtractCallback::SetOperationResult(int)+26Fp
UNDEF:0000C128 ; bool __thiscall NWindows::NFile::NIO::COutFile::SetTime(NWindows::NFile::NIO::COutFile *__hidden this, const struct _FILETIME *, const struct _FILETIME *, const struct _FILETIME *)
UNDEF:0000C128                 extrn ?SetTime@COutFile@NIO@NFile@NWindows@@QAE_NPBU_FILETIME@@00@Z:near
UNDEF:0000C128                                         ; CODE XREF: COutFileStream::SetTime(_FILETIME const *,_FILETIME const *,_FILETIME const *)+20p
UNDEF:0000C12C ; void __stdcall ConvertUInt32ToString(unsigned int, wchar_t *)
UNDEF:0000C12C                 extrn ?ConvertUInt32ToString@@YGXIPA_W@Z:near
UNDEF:0000C12C                                         ; CODE XREF: CArchiveExtractCallback::ReportExtractResult(uint,uint,int)+144p
UNDEF:0000C130 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000C130                 extrn _memcpy:near      ; CODE XREF: CRecordVector<void *>::Reserve(uint)+67p
UNDEF:0000C130                                         ; CRecordVector<uint>::ReserveOnePosition(void)+87p ...
UNDEF:0000C134 ; void *__cdecl _memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000C134                 extrn __imp__memmove:near
UNDEF:0000C134                                         ; CODE XREF: CRecordVector<void *>::MoveItems(uint,uint)+36p
UNDEF:0000C134                                         ; DATA XREF: CRecordVector<void *>::MoveItems(uint,uint)+36r
UNDEF:0000C134
UNDEF:0000C134
UNDEF:0000C134                 end