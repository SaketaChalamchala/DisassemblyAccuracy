.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 004FED3A2AB09118476C9D4D5E8EF811
.rdata:00000000 ; Input CRC32 : 29C3B417
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\HashCalc.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG71081        db 'CRC32',0            ; DATA XREF: .data:_k_DefaultHashMethodo
.rdata:00000006                 align 4
.rdata:00000008 ; char _SG71263[]
.rdata:00000008 $SG71263        dd offset $SG71453+0Ah  ; DATA XREF: CHashBundle::SetMethods(CObjectVector<UString> const &):loc_1A6o
.rdata:00000008                                         ; "rror"
.rdata:0000000C $SG71297        db 'Can',27h,'t create hasher',0
.rdata:0000000C                                         ; DATA XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+403o
.rdata:00000020 $SG71453        db 'Scanning error',0   ; DATA XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+1BAo
.rdata:00000020                                         ; .rdata:$SG71263o
.rdata:0000002F                 align 10h
.rdata:0000002F _rdata          ends
.rdata:0000002F
.data:00000030 ; ===========================================================================
.data:00000030
.data:00000030 ; Segment type: Pure data
.data:00000030 ; Segment permissions: Read/Write
.data:00000030 _data           segment dword public 'DATA' use32
.data:00000030                 assume cs:_data
.data:00000030                 ;org 30h
.data:00000030 ; char *k_DefaultHashMethod
.data:00000030 _k_DefaultHashMethod dd offset $SG71081 ; DATA XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+6Fr
.data:00000030                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+163r
.data:00000030 _data           ends                    ; "CRC32"
.data:00000030
.text:00000034 ; ===========================================================================
.text:00000034
.text:00000034 ; Segment type: Pure code
.text:00000034 ; Segment permissions: Read/Execute
.text:00000034 _text           segment para public 'CODE' use32
.text:00000034                 assume cs:_text
.text:00000034                 ;org 34h
.text:00000034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000034
.text:00000034 ; =============== S U B R O U T I N E =======================================
.text:00000034
.text:00000034 ; Attributes: bp-based frame
.text:00000034
.text:00000034 ; public: long __thiscall CHashBundle::SetMethods(class CObjectVector<class UString> const &)
.text:00000034                 public ?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z
.text:00000034 ?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z proc near
.text:00000034                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+25Bp
.text:00000034
.text:00000034 var_128         = dword ptr -128h
.text:00000034 var_124         = dword ptr -124h
.text:00000034 var_120         = dword ptr -120h
.text:00000034 var_11C         = dword ptr -11Ch
.text:00000034 var_118         = dword ptr -118h
.text:00000034 var_114         = dword ptr -114h
.text:00000034 var_110         = dword ptr -110h
.text:00000034 var_10C         = dword ptr -10Ch
.text:00000034 var_108         = dword ptr -108h
.text:00000034 var_104         = dword ptr -104h
.text:00000034 Size            = dword ptr -100h
.text:00000034 var_FC          = dword ptr -0FCh
.text:00000034 var_F4          = byte ptr -0F4h
.text:00000034 var_EC          = dword ptr -0ECh
.text:00000034 var_E8          = dword ptr -0E8h
.text:00000034 var_E0          = byte ptr -0E0h
.text:00000034 var_CC          = byte ptr -0CCh
.text:00000034 var_C4          = dword ptr -0C4h
.text:00000034 var_BC          = qword ptr -0BCh
.text:00000034 var_B0          = dword ptr -0B0h
.text:00000034 var_AC          = dword ptr -0ACh
.text:00000034 var_A4          = byte ptr -0A4h
.text:00000034 var_94          = dword ptr -94h
.text:00000034 var_8C          = byte ptr -8Ch
.text:00000034 var_80          = dword ptr -80h
.text:00000034 var_64          = dword ptr -64h
.text:00000034 var_5C          = byte ptr -5Ch
.text:00000034 var_48          = byte ptr -48h
.text:00000034 var_34          = byte ptr -34h
.text:00000034 var_20          = byte ptr -20h
.text:00000034 var_10          = dword ptr -10h
.text:00000034 var_C           = dword ptr -0Ch
.text:00000034 var_4           = dword ptr -4
.text:00000034 arg_0           = dword ptr  8
.text:00000034
.text:00000034                 push    ebp
.text:00000035                 mov     ebp, esp
.text:00000037                 push    0FFFFFFFFh
.text:00000039                 push    offset __ehhandler$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z
.text:0000003E                 mov     eax, large fs:0
.text:00000044                 push    eax
.text:00000045                 sub     esp, 11Ch
.text:0000004B                 push    esi
.text:0000004C                 push    edi
.text:0000004D                 push    ecx
.text:0000004E                 lea     edi, [ebp+var_128]
.text:00000054                 mov     ecx, 47h ; 'G'
.text:00000059                 mov     eax, 0CCCCCCCCh
.text:0000005E                 rep stosd
.text:00000060                 pop     ecx
.text:00000061                 mov     eax, dword ptr ds:___security_cookie
.text:00000066                 xor     eax, ebp
.text:00000068                 push    eax
.text:00000069                 lea     eax, [ebp+var_C]
.text:0000006C                 mov     large fs:0, eax
.text:00000072                 mov     [ebp+var_10], ecx
.text:00000075                 mov     eax, [ebp+arg_0]
.text:00000078                 push    eax
.text:00000079                 lea     ecx, [ebp+var_20]
.text:0000007C                 call    ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z ; CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)
.text:00000081                 mov     [ebp+var_4], 0
.text:00000088                 lea     ecx, [ebp+var_20]
.text:0000008B                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:00000090                 movzx   ecx, al
.text:00000093                 test    ecx, ecx
.text:00000095                 jz      short loc_CA
.text:00000097                 lea     ecx, [ebp+var_34]
.text:0000009A                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000009F                 mov     byte ptr [ebp+var_4], 1
.text:000000A3                 mov     edx, ds:_k_DefaultHashMethod
.text:000000A9                 push    edx             ; char *
.text:000000AA                 lea     ecx, [ebp+var_34] ; this
.text:000000AD                 call    ?SetFromAscii@UString@@QAEXPBD@Z ; UString::SetFromAscii(char const *)
.text:000000B2                 lea     eax, [ebp+var_34]
.text:000000B5                 push    eax
.text:000000B6                 lea     ecx, [ebp+var_20]
.text:000000B9                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:000000BE                 mov     byte ptr [ebp+var_4], 0
.text:000000C2                 lea     ecx, [ebp+var_34] ; this
.text:000000C5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000000CA
.text:000000CA loc_CA:                                 ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+61j
.text:000000CA                 lea     ecx, [ebp+var_48]
.text:000000CD                 call    ??0?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::CRecordVector<unsigned __int64>(void)
.text:000000D2                 mov     byte ptr [ebp+var_4], 2
.text:000000D6                 lea     ecx, [ebp+var_5C]
.text:000000D9                 call    ??0?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ ; CObjectVector<COneMethodInfo>::CObjectVector<COneMethodInfo>(void)
.text:000000DE                 mov     byte ptr [ebp+var_4], 3
.text:000000E2                 mov     [ebp+var_64], 0
.text:000000E9                 jmp     short loc_F4
.text:000000EB ; ---------------------------------------------------------------------------
.text:000000EB
.text:000000EB loc_EB:                                 ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+31Aj
.text:000000EB                 mov     ecx, [ebp+var_64]
.text:000000EE                 add     ecx, 1
.text:000000F1                 mov     [ebp+var_64], ecx
.text:000000F4
.text:000000F4 loc_F4:                                 ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+B5j
.text:000000F4                 lea     ecx, [ebp+var_20]
.text:000000F7                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000000FC                 cmp     [ebp+var_64], eax
.text:000000FF                 jnb     loc_353
.text:00000105                 lea     ecx, [ebp+var_8C]
.text:0000010B                 call    ??0COneMethodInfo@@QAE@XZ ; COneMethodInfo::COneMethodInfo(void)
.text:00000110                 mov     byte ptr [ebp+var_4], 4
.text:00000114                 mov     edx, [ebp+var_64]
.text:00000117                 push    edx
.text:00000118                 lea     ecx, [ebp+var_20]
.text:0000011B                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000120                 push    eax             ; struct UString *
.text:00000121                 lea     ecx, [ebp+var_8C] ; this
.text:00000127                 call    ?ParseMethodFromString@COneMethodInfo@@QAEJABVUString@@@Z ; COneMethodInfo::ParseMethodFromString(UString const &)
.text:0000012C                 mov     [ebp+var_94], eax
.text:00000132                 cmp     [ebp+var_94], 0
.text:00000139                 jz      short loc_188
.text:0000013B                 mov     eax, [ebp+var_94]
.text:00000141                 mov     [ebp+var_10C], eax
.text:00000147                 mov     byte ptr [ebp+var_4], 3
.text:0000014B                 lea     ecx, [ebp+var_8C] ; this
.text:00000151                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00000156                 mov     byte ptr [ebp+var_4], 2
.text:0000015A                 lea     ecx, [ebp+var_5C]
.text:0000015D                 call    ??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ ; CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)
.text:00000162                 mov     byte ptr [ebp+var_4], 0
.text:00000166                 lea     ecx, [ebp+var_48]
.text:00000169                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:0000016E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000175                 lea     ecx, [ebp+var_20]
.text:00000178                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:0000017D                 mov     eax, [ebp+var_10C]
.text:00000183                 jmp     loc_6C7
.text:00000188 ; ---------------------------------------------------------------------------
.text:00000188
.text:00000188 loc_188:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+105j
.text:00000188                 lea     ecx, [ebp+var_80] ; this
.text:0000018B                 call    ?IsEmpty@AString@@QBE_NXZ ; AString::IsEmpty(void)
.text:00000190                 movzx   ecx, al
.text:00000193                 test    ecx, ecx
.text:00000195                 jz      short loc_1A6
.text:00000197                 mov     edx, ds:_k_DefaultHashMethod
.text:0000019D                 push    edx
.text:0000019E                 lea     ecx, [ebp+var_80]
.text:000001A1                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:000001A6
.text:000001A6 loc_1A6:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+161j
.text:000001A6                 push    offset $SG71263 ; Str2
.text:000001AB                 lea     eax, [ebp+var_80]
.text:000001AE                 push    eax             ; int
.text:000001AF                 call    ??8@YG_NABVAString@@PBD@Z ; operator==(AString const &,char const *)
.text:000001B4                 movzx   ecx, al
.text:000001B7                 test    ecx, ecx
.text:000001B9                 jz      loc_295
.text:000001BF                 lea     ecx, [ebp+var_A4]
.text:000001C5                 call    ??0?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::CRecordVector<unsigned __int64>(void)
.text:000001CA                 mov     byte ptr [ebp+var_4], 5
.text:000001CE                 lea     edx, [ebp+var_A4]
.text:000001D4                 push    edx
.text:000001D5                 call    ?GetHashMethods@@YGXAAV?$CRecordVector@_K@@@Z ; GetHashMethods(CRecordVector<unsigned __int64> &)
.text:000001DA                 lea     ecx, [ebp+var_5C]
.text:000001DD                 call    ?Clear@?$CObjectVector@VCOneMethodInfo@@@@QAEXXZ ; CObjectVector<COneMethodInfo>::Clear(void)
.text:000001E2                 lea     ecx, [ebp+var_48]
.text:000001E5                 call    ?Clear@?$CRecordVector@_K@@QAEXXZ ; CRecordVector<unsigned __int64>::Clear(void)
.text:000001EA                 mov     [ebp+var_AC], 0
.text:000001F4                 jmp     short loc_205
.text:000001F6 ; ---------------------------------------------------------------------------
.text:000001F6
.text:000001F6 loc_1F6:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &):loc_26Bj
.text:000001F6                 mov     eax, [ebp+var_AC]
.text:000001FC                 add     eax, 1
.text:000001FF                 mov     [ebp+var_AC], eax
.text:00000205
.text:00000205 loc_205:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+1C0j
.text:00000205                 lea     ecx, [ebp+var_A4]
.text:0000020B                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:00000210                 cmp     [ebp+var_AC], eax
.text:00000216                 jnb     short loc_26D
.text:00000218                 mov     ecx, [ebp+var_AC]
.text:0000021E                 push    ecx
.text:0000021F                 lea     ecx, [ebp+var_A4]
.text:00000225                 call    ??A?$CRecordVector@_K@@QAEAA_KI@Z ; CRecordVector<unsigned __int64>::operator[](uint)
.text:0000022A                 mov     edx, [eax+4]
.text:0000022D                 push    edx
.text:0000022E                 mov     eax, [eax]
.text:00000230                 push    eax
.text:00000231                 lea     ecx, [ebp+var_48]
.text:00000234                 call    ?AddToUniqueSorted@?$CRecordVector@_K@@QAEI_K@Z ; CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)
.text:00000239                 mov     [ebp+var_B0], eax
.text:0000023F                 lea     ecx, [ebp+var_48]
.text:00000242                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:00000247                 mov     esi, eax
.text:00000249                 lea     ecx, [ebp+var_5C]
.text:0000024C                 call    ?Size@?$CObjectVector@VCOneMethodInfo@@@@QBEIXZ ; CObjectVector<COneMethodInfo>::Size(void)
.text:00000251                 cmp     esi, eax
.text:00000253                 jz      short loc_26B
.text:00000255                 lea     ecx, [ebp+var_8C]
.text:0000025B                 push    ecx
.text:0000025C                 mov     edx, [ebp+var_B0]
.text:00000262                 push    edx
.text:00000263                 lea     ecx, [ebp+var_5C]
.text:00000266                 call    ?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z ; CObjectVector<COneMethodInfo>::Insert(uint,COneMethodInfo const &)
.text:0000026B
.text:0000026B loc_26B:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+21Fj
.text:0000026B                 jmp     short loc_1F6
.text:0000026D ; ---------------------------------------------------------------------------
.text:0000026D
.text:0000026D loc_26D:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+1E2j
.text:0000026D                 mov     byte ptr [ebp+var_4], 4
.text:00000271                 lea     ecx, [ebp+var_A4]
.text:00000277                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:0000027C                 mov     byte ptr [ebp+var_4], 3
.text:00000280                 lea     ecx, [ebp+var_8C] ; this
.text:00000286                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:0000028B                 jmp     loc_353
.text:00000290 ; ---------------------------------------------------------------------------
.text:00000290                 jmp     loc_33F
.text:00000295 ; ---------------------------------------------------------------------------
.text:00000295
.text:00000295 loc_295:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+185j
.text:00000295                 lea     eax, [ebp+var_BC]
.text:0000029B                 push    eax             ; unsigned __int64 *
.text:0000029C                 lea     ecx, [ebp+var_80]
.text:0000029F                 push    ecx             ; struct AString *
.text:000002A0                 call    ?FindHashMethod@@YG_NABVAString@@AA_K@Z ; FindHashMethod(AString const &,unsigned __int64 &)
.text:000002A5                 movzx   edx, al
.text:000002A8                 test    edx, edx
.text:000002AA                 jnz     short loc_2F7
.text:000002AC                 mov     [ebp+var_110], 80004001h
.text:000002B6                 mov     byte ptr [ebp+var_4], 3
.text:000002BA                 lea     ecx, [ebp+var_8C] ; this
.text:000002C0                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000002C5                 mov     byte ptr [ebp+var_4], 2
.text:000002C9                 lea     ecx, [ebp+var_5C]
.text:000002CC                 call    ??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ ; CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)
.text:000002D1                 mov     byte ptr [ebp+var_4], 0
.text:000002D5                 lea     ecx, [ebp+var_48]
.text:000002D8                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:000002DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000002E4                 lea     ecx, [ebp+var_20]
.text:000002E7                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000002EC                 mov     eax, [ebp+var_110]
.text:000002F2                 jmp     loc_6C7
.text:000002F7 ; ---------------------------------------------------------------------------
.text:000002F7
.text:000002F7 loc_2F7:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+276j
.text:000002F7                 mov     eax, dword ptr [ebp+var_BC+4]
.text:000002FD                 push    eax
.text:000002FE                 mov     ecx, dword ptr [ebp+var_BC]
.text:00000304                 push    ecx
.text:00000305                 lea     ecx, [ebp+var_48]
.text:00000308                 call    ?AddToUniqueSorted@?$CRecordVector@_K@@QAEI_K@Z ; CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)
.text:0000030D                 mov     [ebp+var_C4], eax
.text:00000313                 lea     ecx, [ebp+var_48]
.text:00000316                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:0000031B                 mov     esi, eax
.text:0000031D                 lea     ecx, [ebp+var_5C]
.text:00000320                 call    ?Size@?$CObjectVector@VCOneMethodInfo@@@@QBEIXZ ; CObjectVector<COneMethodInfo>::Size(void)
.text:00000325                 cmp     esi, eax
.text:00000327                 jz      short loc_33F
.text:00000329                 lea     edx, [ebp+var_8C]
.text:0000032F                 push    edx
.text:00000330                 mov     eax, [ebp+var_C4]
.text:00000336                 push    eax
.text:00000337                 lea     ecx, [ebp+var_5C]
.text:0000033A                 call    ?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z ; CObjectVector<COneMethodInfo>::Insert(uint,COneMethodInfo const &)
.text:0000033F
.text:0000033F loc_33F:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+25Cj
.text:0000033F                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+2F3j
.text:0000033F                 mov     byte ptr [ebp+var_4], 3
.text:00000343                 lea     ecx, [ebp+var_8C] ; this
.text:00000349                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:0000034E                 jmp     loc_EB
.text:00000353 ; ---------------------------------------------------------------------------
.text:00000353
.text:00000353 loc_353:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+CBj
.text:00000353                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+257j
.text:00000353                 mov     [ebp+var_64], 0
.text:0000035A                 jmp     short loc_365
.text:0000035C ; ---------------------------------------------------------------------------
.text:0000035C
.text:0000035C loc_35C:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+657j
.text:0000035C                 mov     ecx, [ebp+var_64]
.text:0000035F                 add     ecx, 1
.text:00000362                 mov     [ebp+var_64], ecx
.text:00000365
.text:00000365 loc_365:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+326j
.text:00000365                 lea     ecx, [ebp+var_48]
.text:00000368                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:0000036D                 cmp     [ebp+var_64], eax
.text:00000370                 jnb     loc_690
.text:00000376                 lea     ecx, [ebp+var_CC]
.text:0000037C                 call    ??0?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::CMyComPtr<IHasher>(void)
.text:00000381                 mov     byte ptr [ebp+var_4], 6
.text:00000385                 lea     ecx, [ebp+var_E0]
.text:0000038B                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:00000390                 mov     byte ptr [ebp+var_4], 7
.text:00000394                 lea     edx, [ebp+var_CC]
.text:0000039A                 push    edx
.text:0000039B                 lea     eax, [ebp+var_E0]
.text:000003A1                 push    eax
.text:000003A2                 mov     ecx, [ebp+var_64]
.text:000003A5                 push    ecx
.text:000003A6                 lea     ecx, [ebp+var_48]
.text:000003A9                 call    ??A?$CRecordVector@_K@@QAEAA_KI@Z ; CRecordVector<unsigned __int64>::operator[](uint)
.text:000003AE                 mov     edx, [eax+4]
.text:000003B1                 push    edx
.text:000003B2                 mov     eax, [eax]
.text:000003B4                 push    eax
.text:000003B5                 call    ?CreateHasher@@YGJ_KAAVAString@@AAV?$CMyComPtr@UIHasher@@@@@Z ; CreateHasher(unsigned __int64,AString &,CMyComPtr<IHasher> &)
.text:000003BA                 mov     [ebp+var_E8], eax
.text:000003C0                 cmp     [ebp+var_E8], 0
.text:000003C7                 jz      short loc_425
.text:000003C9                 mov     ecx, [ebp+var_E8]
.text:000003CF                 mov     [ebp+var_114], ecx
.text:000003D5                 mov     byte ptr [ebp+var_4], 6
.text:000003D9                 lea     ecx, [ebp+var_E0] ; this
.text:000003DF                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000003E4                 mov     byte ptr [ebp+var_4], 3
.text:000003E8                 lea     ecx, [ebp+var_CC]
.text:000003EE                 call    ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text:000003F3                 mov     byte ptr [ebp+var_4], 2
.text:000003F7                 lea     ecx, [ebp+var_5C]
.text:000003FA                 call    ??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ ; CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)
.text:000003FF                 mov     byte ptr [ebp+var_4], 0
.text:00000403                 lea     ecx, [ebp+var_48]
.text:00000406                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:0000040B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000412                 lea     ecx, [ebp+var_20]
.text:00000415                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:0000041A                 mov     eax, [ebp+var_114]
.text:00000420                 jmp     loc_6C7
.text:00000425 ; ---------------------------------------------------------------------------
.text:00000425
.text:00000425 loc_425:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+393j
.text:00000425                 lea     ecx, [ebp+var_CC]
.text:0000042B                 call    ??7?$CMyComPtr@UIHasher@@@@QBE_NXZ ; CMyComPtr<IHasher>::operator!(void)
.text:00000430                 movzx   edx, al
.text:00000433                 test    edx, edx
.text:00000435                 jz      short loc_452
.text:00000437                 mov     [ebp+var_118], offset $SG71297 ; "Can't create hasher"
.text:00000441                 push    offset __TI2PAD
.text:00000446                 lea     eax, [ebp+var_118]
.text:0000044C                 push    eax
.text:0000044D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00000452 ; ---------------------------------------------------------------------------
.text:00000452
.text:00000452 loc_452:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+401j
.text:00000452                 mov     ecx, [ebp+var_64]
.text:00000455                 push    ecx
.text:00000456                 lea     ecx, [ebp+var_5C]
.text:00000459                 call    ??A?$CObjectVector@VCOneMethodInfo@@@@QAEAAVCOneMethodInfo@@I@Z ; CObjectVector<COneMethodInfo>::operator[](uint)
.text:0000045E                 mov     [ebp+var_EC], eax
.text:00000464                 lea     ecx, [ebp+var_F4]
.text:0000046A                 call    ??0?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::CMyComPtr<ICompressSetCoderProperties>(void)
.text:0000046F                 mov     byte ptr [ebp+var_4], 8
.text:00000473                 lea     ecx, [ebp+var_F4]
.text:00000479                 call    ??I?$CMyComPtr@UICompressSetCoderProperties@@@@QAEPAPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator&(void)
.text:0000047E                 push    eax
.text:0000047F                 push    offset _IID_ICompressSetCoderProperties
.text:00000484                 lea     ecx, [ebp+var_CC]
.text:0000048A                 call    ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIHasher@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z ; CMyComPtr<IHasher>::QueryInterface<ICompressSetCoderProperties>(_GUID const &,ICompressSetCoderProperties * *)
.text:0000048F                 lea     ecx, [ebp+var_F4]
.text:00000495                 call    ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator ICompressSetCoderProperties *(void)
.text:0000049A                 test    eax, eax
.text:0000049C                 jz      loc_535
.text:000004A2                 push    0               ; unsigned __int64 *
.text:000004A4                 lea     ecx, [ebp+var_F4]
.text:000004AA                 call    ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator ICompressSetCoderProperties *(void)
.text:000004AF                 push    eax             ; struct ICompressSetCoderProperties *
.text:000004B0                 mov     ecx, [ebp+var_EC] ; this
.text:000004B6                 call    ?SetCoderProps@CProps@@QBEJPAUICompressSetCoderProperties@@PB_K@Z ; CProps::SetCoderProps(ICompressSetCoderProperties *,unsigned __int64 const *)
.text:000004BB                 mov     [ebp+var_FC], eax
.text:000004C1                 cmp     [ebp+var_FC], 0
.text:000004C8                 jz      short loc_535
.text:000004CA                 mov     edx, [ebp+var_FC]
.text:000004D0                 mov     [ebp+var_11C], edx
.text:000004D6                 mov     byte ptr [ebp+var_4], 7
.text:000004DA                 lea     ecx, [ebp+var_F4]
.text:000004E0                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:000004E5                 mov     byte ptr [ebp+var_4], 6
.text:000004E9                 lea     ecx, [ebp+var_E0] ; this
.text:000004EF                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000004F4                 mov     byte ptr [ebp+var_4], 3
.text:000004F8                 lea     ecx, [ebp+var_CC]
.text:000004FE                 call    ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text:00000503                 mov     byte ptr [ebp+var_4], 2
.text:00000507                 lea     ecx, [ebp+var_5C]
.text:0000050A                 call    ??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ ; CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)
.text:0000050F                 mov     byte ptr [ebp+var_4], 0
.text:00000513                 lea     ecx, [ebp+var_48]
.text:00000516                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:0000051B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000522                 lea     ecx, [ebp+var_20]
.text:00000525                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:0000052A                 mov     eax, [ebp+var_11C]
.text:00000530                 jmp     loc_6C7
.text:00000535 ; ---------------------------------------------------------------------------
.text:00000535
.text:00000535 loc_535:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+468j
.text:00000535                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+494j
.text:00000535                 mov     byte ptr [ebp+var_4], 7
.text:00000539                 lea     ecx, [ebp+var_F4]
.text:0000053F                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00000544                 lea     ecx, [ebp+var_CC]
.text:0000054A                 call    ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ ; CMyComPtr<IHasher>::operator->(void)
.text:0000054F                 mov     [ebp+var_128], eax
.text:00000555                 mov     eax, [ebp+var_128]
.text:0000055B                 mov     ecx, [eax]
.text:0000055D                 mov     esi, esp
.text:0000055F                 mov     edx, [ebp+var_128]
.text:00000565                 push    edx
.text:00000566                 mov     eax, [ecx+18h]
.text:00000569                 call    eax
.text:0000056B                 cmp     esi, esp
.text:0000056D                 call    __RTC_CheckEsp
.text:00000572                 mov     [ebp+Size], eax
.text:00000578                 cmp     [ebp+Size], 40h ; '@'
.text:0000057F                 jbe     short loc_5DB
.text:00000581                 mov     [ebp+var_120], 80004001h
.text:0000058B                 mov     byte ptr [ebp+var_4], 6
.text:0000058F                 lea     ecx, [ebp+var_E0] ; this
.text:00000595                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000059A                 mov     byte ptr [ebp+var_4], 3
.text:0000059E                 lea     ecx, [ebp+var_CC]
.text:000005A4                 call    ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text:000005A9                 mov     byte ptr [ebp+var_4], 2
.text:000005AD                 lea     ecx, [ebp+var_5C]
.text:000005B0                 call    ??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ ; CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)
.text:000005B5                 mov     byte ptr [ebp+var_4], 0
.text:000005B9                 lea     ecx, [ebp+var_48]
.text:000005BC                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:000005C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000005C8                 lea     ecx, [ebp+var_20]
.text:000005CB                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000005D0                 mov     eax, [ebp+var_120]
.text:000005D6                 jmp     loc_6C7
.text:000005DB ; ---------------------------------------------------------------------------
.text:000005DB
.text:000005DB loc_5DB:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+54Bj
.text:000005DB                 mov     ecx, [ebp+var_10]
.text:000005DE                 add     ecx, 4
.text:000005E1                 call    ?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ ; CObjectVector<CHasherState>::AddNew(void)
.text:000005E6                 mov     [ebp+var_104], eax
.text:000005EC                 lea     ecx, [ebp+var_CC]
.text:000005F2                 push    ecx
.text:000005F3                 mov     ecx, [ebp+var_104]
.text:000005F9                 call    ??4?$CMyComPtr@UIHasher@@@@QAEPAUIHasher@@ABV0@@Z ; CMyComPtr<IHasher>::operator=(CMyComPtr<IHasher> const &)
.text:000005FE                 lea     edx, [ebp+var_E0]
.text:00000604                 push    edx
.text:00000605                 mov     ecx, [ebp+var_104]
.text:0000060B                 add     ecx, 4
.text:0000060E                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:00000613                 mov     eax, [ebp+var_104]
.text:00000619                 mov     ecx, [ebp+Size]
.text:0000061F                 mov     [eax+10h], ecx
.text:00000622                 mov     [ebp+var_108], 0
.text:0000062C                 jmp     short loc_63D
.text:0000062E ; ---------------------------------------------------------------------------
.text:0000062E
.text:0000062E loc_62E:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+637j
.text:0000062E                 mov     edx, [ebp+var_108]
.text:00000634                 add     edx, 1
.text:00000637                 mov     [ebp+var_108], edx
.text:0000063D
.text:0000063D loc_63D:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+5F8j
.text:0000063D                 cmp     [ebp+var_108], 4
.text:00000644                 jnb     short loc_66D
.text:00000646                 mov     eax, [ebp+Size]
.text:0000064C                 push    eax             ; Size
.text:0000064D                 push    0               ; Val
.text:0000064F                 mov     ecx, [ebp+var_108]
.text:00000655                 shl     ecx, 6
.text:00000658                 mov     edx, [ebp+var_104]
.text:0000065E                 lea     eax, [edx+ecx+14h]
.text:00000662                 push    eax             ; Dst
.text:00000663                 call    _memset
.text:00000668                 add     esp, 0Ch
.text:0000066B                 jmp     short loc_62E
.text:0000066D ; ---------------------------------------------------------------------------
.text:0000066D
.text:0000066D loc_66D:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+610j
.text:0000066D                 mov     byte ptr [ebp+var_4], 6
.text:00000671                 lea     ecx, [ebp+var_E0] ; this
.text:00000677                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000067C                 mov     byte ptr [ebp+var_4], 3
.text:00000680                 lea     ecx, [ebp+var_CC]
.text:00000686                 call    ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text:0000068B                 jmp     loc_35C
.text:00000690 ; ---------------------------------------------------------------------------
.text:00000690
.text:00000690 loc_690:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+33Cj
.text:00000690                 mov     [ebp+var_124], 0
.text:0000069A                 mov     byte ptr [ebp+var_4], 2
.text:0000069E                 lea     ecx, [ebp+var_5C]
.text:000006A1                 call    ??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ ; CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)
.text:000006A6                 mov     byte ptr [ebp+var_4], 0
.text:000006AA                 lea     ecx, [ebp+var_48]
.text:000006AD                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:000006B2                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000006B9                 lea     ecx, [ebp+var_20]
.text:000006BC                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000006C1                 mov     eax, [ebp+var_124]
.text:000006C7
.text:000006C7 loc_6C7:                                ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+14Fj
.text:000006C7                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+2BEj ...
.text:000006C7                 push    edx
.text:000006C8                 mov     ecx, ebp
.text:000006CA                 push    eax
.text:000006CB                 lea     edx, $LN49
.text:000006D1                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000006D6                 pop     eax
.text:000006D7                 pop     edx
.text:000006D8                 mov     ecx, [ebp+var_C]
.text:000006DB                 mov     large fs:0, ecx
.text:000006E2                 pop     ecx
.text:000006E3                 pop     edi
.text:000006E4                 pop     esi
.text:000006E5                 add     esp, 128h
.text:000006EB                 cmp     ebp, esp
.text:000006ED                 call    __RTC_CheckEsp
.text:000006F2                 mov     esp, ebp
.text:000006F4                 pop     ebp
.text:000006F5                 retn    4
.text:000006F5 ?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z endp
.text:000006F5
.text:000006F5 ; ---------------------------------------------------------------------------
.text:000006F8 $LN49           dd 0Ah                  ; DATA XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+697o
.text:000006FC                 dd offset $LN48
.text:00000700 $LN48           dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:000006FCo
.text:00000708                 dd offset $LN37         ; "names"
.text:0000070C                 db 0CCh
.text:0000070D                 db 3 dup(0FFh)
.text:00000710                 dd 0Ch
.text:00000714                 dd offset $LN38         ; "s"
.text:00000718                 dd 0FFFFFFB8h, 0Ch
.text:00000720                 dd offset $LN39         ; "ids"
.text:00000724                 dd 0FFFFFFA4h, 0Ch
.text:0000072C                 dd offset $LN40         ; "methods"
.text:00000730                 dd 0FFFFFF74h, 24h
.text:00000738                 dd offset $LN41         ; "m"
.text:0000073C                 dd 0FFFFFF5Ch, 0Ch
.text:00000744                 dd offset $LN42         ; "tempMethods"
.text:00000748                 dd 0FFFFFF44h, 8
.text:00000750                 dd offset $LN43         ; "id"
.text:00000754                 dd 0FFFFFF34h, 4
.text:0000075C                 dd offset $LN44         ; "hasher"
.text:00000760                 dd 0FFFFFF20h, 0Ch
.text:00000768                 dd offset $LN45         ; "name"
.text:0000076C                 dd 0FFFFFF0Ch, 4
.text:00000774                 dd offset $LN46
.text:00000778 $LN46           dd 706373h              ; DATA XREF: .text:00000774o
.text:0000077C $LN45           db 'name',0             ; DATA XREF: .text:00000768o
.text:00000781 $LN44           db 'hasher',0           ; DATA XREF: .text:0000075Co
.text:00000788 $LN43           db 'id',0               ; DATA XREF: .text:00000750o
.text:0000078B $LN42           db 'tempMethods',0      ; DATA XREF: .text:00000744o
.text:00000797 $LN41           db 'm',0                ; DATA XREF: .text:00000738o
.text:00000799 $LN40           db 'methods',0          ; DATA XREF: .text:0000072Co
.text:000007A1 $LN39           db 'ids',0              ; DATA XREF: .text:00000720o
.text:000007A5 $LN38           db 's',0                ; DATA XREF: .text:00000714o
.text:000007A7 $LN37           db 'names',0            ; DATA XREF: .text:00000708o
.text:000007AD                 db 7 dup(0CCh)
.text:000007B4
.text:000007B4 ; =============== S U B R O U T I N E =======================================
.text:000007B4
.text:000007B4 ; Attributes: bp-based frame
.text:000007B4
.text:000007B4 ; void __thiscall CHashBundle::InitForNewFile(CHashBundle *__hidden this)
.text:000007B4                 public ?InitForNewFile@CHashBundle@@UAEXXZ
.text:000007B4 ?InitForNewFile@CHashBundle@@UAEXXZ proc near
.text:000007B4                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+86Cp
.text:000007B4                                         ; DATA XREF: .rdata:const CHashBundle::`vftable'o
.text:000007B4
.text:000007B4 var_10          = dword ptr -10h
.text:000007B4 var_C           = dword ptr -0Ch
.text:000007B4 var_8           = dword ptr -8
.text:000007B4 var_4           = dword ptr -4
.text:000007B4
.text:000007B4                 push    ebp
.text:000007B5                 mov     ebp, esp
.text:000007B7                 sub     esp, 10h
.text:000007BA                 push    esi
.text:000007BB                 mov     eax, 0CCCCCCCCh
.text:000007C0                 mov     [ebp+var_10], eax
.text:000007C3                 mov     [ebp+var_C], eax
.text:000007C6                 mov     [ebp+var_8], eax
.text:000007C9                 mov     [ebp+var_4], eax
.text:000007CC                 mov     [ebp+var_4], ecx
.text:000007CF                 mov     eax, [ebp+var_4]
.text:000007D2                 mov     dword ptr [eax+40h], 0
.text:000007D9                 mov     dword ptr [eax+44h], 0
.text:000007E0                 mov     [ebp+var_8], 0
.text:000007E7                 jmp     short loc_7F2
.text:000007E9 ; ---------------------------------------------------------------------------
.text:000007E9
.text:000007E9 loc_7E9:                                ; CODE XREF: CHashBundle::InitForNewFile(void)+9Aj
.text:000007E9                 mov     ecx, [ebp+var_8]
.text:000007EC                 add     ecx, 1
.text:000007EF                 mov     [ebp+var_8], ecx
.text:000007F2
.text:000007F2 loc_7F2:                                ; CODE XREF: CHashBundle::InitForNewFile(void)+33j
.text:000007F2                 mov     ecx, [ebp+var_4]
.text:000007F5                 add     ecx, 4
.text:000007F8                 call    ?Size@?$CObjectVector@UCHasherState@@@@QBEIXZ ; CObjectVector<CHasherState>::Size(void)
.text:000007FD                 cmp     [ebp+var_8], eax
.text:00000800                 jnb     short loc_850
.text:00000802                 mov     edx, [ebp+var_8]
.text:00000805                 push    edx
.text:00000806                 mov     ecx, [ebp+var_4]
.text:00000809                 add     ecx, 4
.text:0000080C                 call    ??A?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@I@Z ; CObjectVector<CHasherState>::operator[](uint)
.text:00000811                 mov     [ebp+var_C], eax
.text:00000814                 mov     ecx, [ebp+var_C]
.text:00000817                 call    ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ ; CMyComPtr<IHasher>::operator->(void)
.text:0000081C                 mov     [ebp+var_10], eax
.text:0000081F                 mov     eax, [ebp+var_10]
.text:00000822                 mov     ecx, [eax]
.text:00000824                 mov     esi, esp
.text:00000826                 mov     edx, [ebp+var_10]
.text:00000829                 push    edx
.text:0000082A                 mov     eax, [ecx+0Ch]
.text:0000082D                 call    eax
.text:0000082F                 cmp     esi, esp
.text:00000831                 call    __RTC_CheckEsp
.text:00000836                 mov     ecx, [ebp+var_C]
.text:00000839                 mov     edx, [ecx+10h]
.text:0000083C                 push    edx             ; Size
.text:0000083D                 push    0               ; Val
.text:0000083F                 mov     eax, [ebp+var_C]
.text:00000842                 add     eax, 14h
.text:00000845                 push    eax             ; Dst
.text:00000846                 call    _memset
.text:0000084B                 add     esp, 0Ch
.text:0000084E                 jmp     short loc_7E9
.text:00000850 ; ---------------------------------------------------------------------------
.text:00000850
.text:00000850 loc_850:                                ; CODE XREF: CHashBundle::InitForNewFile(void)+4Cj
.text:00000850                 pop     esi
.text:00000851                 add     esp, 10h
.text:00000854                 cmp     ebp, esp
.text:00000856                 call    __RTC_CheckEsp
.text:0000085B                 mov     esp, ebp
.text:0000085D                 pop     ebp
.text:0000085E                 retn
.text:0000085E ?InitForNewFile@CHashBundle@@UAEXXZ endp
.text:0000085E
.text:0000085E ; ---------------------------------------------------------------------------
.text:0000085F                 db 5 dup(0CCh)
.text:00000864
.text:00000864 ; =============== S U B R O U T I N E =======================================
.text:00000864
.text:00000864 ; Attributes: bp-based frame
.text:00000864
.text:00000864 ; void __thiscall CHashBundle::Update(CHashBundle *this, const void *, unsigned int)
.text:00000864                 public ?Update@CHashBundle@@UAEXPBXI@Z
.text:00000864 ?Update@CHashBundle@@UAEXPBXI@Z proc near
.text:00000864                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+A1Bp
.text:00000864                                         ; DATA XREF: .rdata:00002668o
.text:00000864
.text:00000864 var_C           = dword ptr -0Ch
.text:00000864 var_8           = dword ptr -8
.text:00000864 var_4           = dword ptr -4
.text:00000864 arg_0           = dword ptr  8
.text:00000864 arg_4           = dword ptr  0Ch
.text:00000864
.text:00000864                 push    ebp
.text:00000865                 mov     ebp, esp
.text:00000867                 sub     esp, 0Ch
.text:0000086A                 push    esi
.text:0000086B                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000872                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000879                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000880                 mov     [ebp+var_4], ecx
.text:00000883                 mov     eax, [ebp+arg_4]
.text:00000886                 xor     ecx, ecx
.text:00000888                 mov     edx, [ebp+var_4]
.text:0000088B                 add     eax, [edx+40h]
.text:0000088E                 adc     ecx, [edx+44h]
.text:00000891                 mov     edx, [ebp+var_4]
.text:00000894                 mov     [edx+40h], eax
.text:00000897                 mov     [edx+44h], ecx
.text:0000089A                 mov     [ebp+var_8], 0
.text:000008A1                 jmp     short loc_8AC
.text:000008A3 ; ---------------------------------------------------------------------------
.text:000008A3
.text:000008A3 loc_8A3:                                ; CODE XREF: CHashBundle::Update(void const *,uint)+90j
.text:000008A3                 mov     eax, [ebp+var_8]
.text:000008A6                 add     eax, 1
.text:000008A9                 mov     [ebp+var_8], eax
.text:000008AC
.text:000008AC loc_8AC:                                ; CODE XREF: CHashBundle::Update(void const *,uint)+3Dj
.text:000008AC                 mov     ecx, [ebp+var_4]
.text:000008AF                 add     ecx, 4
.text:000008B2                 call    ?Size@?$CObjectVector@UCHasherState@@@@QBEIXZ ; CObjectVector<CHasherState>::Size(void)
.text:000008B7                 cmp     [ebp+var_8], eax
.text:000008BA                 jnb     short loc_8F6
.text:000008BC                 mov     ecx, [ebp+var_8]
.text:000008BF                 push    ecx
.text:000008C0                 mov     ecx, [ebp+var_4]
.text:000008C3                 add     ecx, 4
.text:000008C6                 call    ??A?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@I@Z ; CObjectVector<CHasherState>::operator[](uint)
.text:000008CB                 mov     ecx, eax
.text:000008CD                 call    ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ ; CMyComPtr<IHasher>::operator->(void)
.text:000008D2                 mov     [ebp+var_C], eax
.text:000008D5                 mov     esi, esp
.text:000008D7                 mov     edx, [ebp+arg_4]
.text:000008DA                 push    edx
.text:000008DB                 mov     eax, [ebp+arg_0]
.text:000008DE                 push    eax
.text:000008DF                 mov     ecx, [ebp+var_C]
.text:000008E2                 push    ecx
.text:000008E3                 mov     edx, [ebp+var_C]
.text:000008E6                 mov     eax, [edx]
.text:000008E8                 mov     ecx, [eax+10h]
.text:000008EB                 call    ecx
.text:000008ED                 cmp     esi, esp
.text:000008EF                 call    __RTC_CheckEsp
.text:000008F4                 jmp     short loc_8A3
.text:000008F6 ; ---------------------------------------------------------------------------
.text:000008F6
.text:000008F6 loc_8F6:                                ; CODE XREF: CHashBundle::Update(void const *,uint)+56j
.text:000008F6                 pop     esi
.text:000008F7                 add     esp, 0Ch
.text:000008FA                 cmp     ebp, esp
.text:000008FC                 call    __RTC_CheckEsp
.text:00000901                 mov     esp, ebp
.text:00000903                 pop     ebp
.text:00000904                 retn    8
.text:00000904 ?Update@CHashBundle@@UAEXPBXI@Z endp
.text:00000904
.text:00000904 ; ---------------------------------------------------------------------------
.text:00000907                 db 0Dh dup(0CCh)
.text:00000914
.text:00000914 ; =============== S U B R O U T I N E =======================================
.text:00000914
.text:00000914 ; Attributes: bp-based frame
.text:00000914
.text:00000914 ; void __thiscall CHashBundle::SetSize(CHashBundle *this, unsigned __int64)
.text:00000914                 public ?SetSize@CHashBundle@@UAEX_K@Z
.text:00000914 ?SetSize@CHashBundle@@UAEX_K@Z proc near ; DATA XREF: .rdata:0000266Co
.text:00000914
.text:00000914 var_4           = dword ptr -4
.text:00000914 arg_0           = qword ptr  8
.text:00000914
.text:00000914                 push    ebp
.text:00000915                 mov     ebp, esp
.text:00000917                 push    ecx
.text:00000918                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000091F                 mov     [ebp+var_4], ecx
.text:00000922                 mov     eax, [ebp+var_4]
.text:00000925                 mov     ecx, dword ptr [ebp+arg_0]
.text:00000928                 mov     [eax+40h], ecx
.text:0000092B                 mov     edx, dword ptr [ebp+arg_0+4]
.text:0000092E                 mov     [eax+44h], edx
.text:00000931                 mov     esp, ebp
.text:00000933                 pop     ebp
.text:00000934                 retn    8
.text:00000934 ?SetSize@CHashBundle@@UAEX_K@Z endp
.text:00000934
.text:00000934 ; ---------------------------------------------------------------------------
.text:00000937                 db 0Dh dup(0CCh)
.text:00000944
.text:00000944 ; =============== S U B R O U T I N E =======================================
.text:00000944
.text:00000944 ; Attributes: bp-based frame
.text:00000944
.text:00000944 ; void __thiscall CHashBundle::Final(CHashBundle *this, bool, bool, const struct UString *)
.text:00000944                 public ?Final@CHashBundle@@UAEX_N0ABVUString@@@Z
.text:00000944 ?Final@CHashBundle@@UAEX_N0ABVUString@@@Z proc near
.text:00000944                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+A82p
.text:00000944                                         ; DATA XREF: .rdata:00002670o
.text:00000944
.text:00000944 var_9C          = dword ptr -9Ch
.text:00000944 var_98          = dword ptr -98h
.text:00000944 var_94          = dword ptr -94h
.text:00000944 var_90          = dword ptr -90h
.text:00000944 var_8C          = dword ptr -8Ch
.text:00000944 var_88          = dword ptr -88h
.text:00000944 var_80          = byte ptr -80h
.text:00000944 var_38          = byte ptr -38h
.text:00000944 var_37          = byte ptr -37h
.text:00000944 var_30          = word ptr -30h
.text:00000944 var_2C          = dword ptr -2Ch
.text:00000944 var_28          = dword ptr -28h
.text:00000944 var_24          = dword ptr -24h
.text:00000944 Dst             = byte ptr -1Ch
.text:00000944 var_8           = dword ptr -8
.text:00000944 var_4           = dword ptr -4
.text:00000944 arg_0           = byte ptr  8
.text:00000944 arg_4           = byte ptr  0Ch
.text:00000944 arg_8           = dword ptr  10h
.text:00000944
.text:00000944                 push    ebp
.text:00000945                 mov     ebp, esp
.text:00000947                 sub     esp, 9Ch
.text:0000094D                 push    esi
.text:0000094E                 push    edi
.text:0000094F                 push    ecx
.text:00000950                 lea     edi, [ebp+var_9C]
.text:00000956                 mov     ecx, 27h ; '''
.text:0000095B                 mov     eax, 0CCCCCCCCh
.text:00000960                 rep stosd
.text:00000962                 pop     ecx
.text:00000963                 mov     eax, dword ptr ds:___security_cookie
.text:00000968                 xor     eax, ebp
.text:0000096A                 mov     [ebp+var_4], eax
.text:0000096D                 mov     [ebp+var_8], ecx
.text:00000970                 movzx   eax, [ebp+arg_0]
.text:00000974                 test    eax, eax
.text:00000976                 jz      short loc_992
.text:00000978                 mov     ecx, [ebp+var_8]
.text:0000097B                 mov     edx, [ecx+10h]
.text:0000097E                 add     edx, 1
.text:00000981                 mov     eax, [ecx+14h]
.text:00000984                 adc     eax, 0
.text:00000987                 mov     ecx, [ebp+var_8]
.text:0000098A                 mov     [ecx+10h], edx
.text:0000098D                 mov     [ecx+14h], eax
.text:00000990                 jmp     short loc_A02
.text:00000992 ; ---------------------------------------------------------------------------
.text:00000992
.text:00000992 loc_992:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+32j
.text:00000992                 movzx   edx, [ebp+arg_4]
.text:00000996                 test    edx, edx
.text:00000998                 jz      short loc_9CF
.text:0000099A                 mov     eax, [ebp+var_8]
.text:0000099D                 mov     ecx, [eax+20h]
.text:000009A0                 add     ecx, 1
.text:000009A3                 mov     edx, [eax+24h]
.text:000009A6                 adc     edx, 0
.text:000009A9                 mov     eax, [ebp+var_8]
.text:000009AC                 mov     [eax+20h], ecx
.text:000009AF                 mov     [eax+24h], edx
.text:000009B2                 mov     ecx, [ebp+var_8]
.text:000009B5                 mov     edx, [ebp+var_8]
.text:000009B8                 mov     eax, [ecx+30h]
.text:000009BB                 add     eax, [edx+40h]
.text:000009BE                 mov     ecx, [ecx+34h]
.text:000009C1                 adc     ecx, [edx+44h]
.text:000009C4                 mov     edx, [ebp+var_8]
.text:000009C7                 mov     [edx+30h], eax
.text:000009CA                 mov     [edx+34h], ecx
.text:000009CD                 jmp     short loc_A02
.text:000009CF ; ---------------------------------------------------------------------------
.text:000009CF
.text:000009CF loc_9CF:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+54j
.text:000009CF                 mov     eax, [ebp+var_8]
.text:000009D2                 mov     ecx, [eax+18h]
.text:000009D5                 add     ecx, 1
.text:000009D8                 mov     edx, [eax+1Ch]
.text:000009DB                 adc     edx, 0
.text:000009DE                 mov     eax, [ebp+var_8]
.text:000009E1                 mov     [eax+18h], ecx
.text:000009E4                 mov     [eax+1Ch], edx
.text:000009E7                 mov     ecx, [ebp+var_8]
.text:000009EA                 mov     edx, [ebp+var_8]
.text:000009ED                 mov     eax, [ecx+28h]
.text:000009F0                 add     eax, [edx+40h]
.text:000009F3                 mov     ecx, [ecx+2Ch]
.text:000009F6                 adc     ecx, [edx+44h]
.text:000009F9                 mov     edx, [ebp+var_8]
.text:000009FC                 mov     [edx+28h], eax
.text:000009FF                 mov     [edx+2Ch], ecx
.text:00000A02
.text:00000A02 loc_A02:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+4Cj
.text:00000A02                                         ; CHashBundle::Final(bool,bool,UString const &)+89j
.text:00000A02                 push    10h             ; Size
.text:00000A04                 push    0               ; Val
.text:00000A06                 lea     eax, [ebp+Dst]
.text:00000A09                 push    eax             ; Dst
.text:00000A0A                 call    _memset
.text:00000A0F                 add     esp, 0Ch
.text:00000A12                 movzx   ecx, [ebp+arg_0]
.text:00000A16                 test    ecx, ecx
.text:00000A18                 jz      short loc_A1E
.text:00000A1A                 mov     [ebp+Dst], 1
.text:00000A1E
.text:00000A1E loc_A1E:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+D4j
.text:00000A1E                 mov     [ebp+var_24], 0
.text:00000A25                 jmp     short loc_A30
.text:00000A27 ; ---------------------------------------------------------------------------
.text:00000A27
.text:00000A27 loc_A27:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+2EFj
.text:00000A27                 mov     edx, [ebp+var_24]
.text:00000A2A                 add     edx, 1
.text:00000A2D                 mov     [ebp+var_24], edx
.text:00000A30
.text:00000A30 loc_A30:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+E1j
.text:00000A30                 mov     ecx, [ebp+var_8]
.text:00000A33                 add     ecx, 4
.text:00000A36                 call    ?Size@?$CObjectVector@UCHasherState@@@@QBEIXZ ; CObjectVector<CHasherState>::Size(void)
.text:00000A3B                 cmp     [ebp+var_24], eax
.text:00000A3E                 jnb     loc_C38
.text:00000A44                 mov     eax, [ebp+var_24]
.text:00000A47                 push    eax
.text:00000A48                 mov     ecx, [ebp+var_8]
.text:00000A4B                 add     ecx, 4
.text:00000A4E                 call    ??A?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@I@Z ; CObjectVector<CHasherState>::operator[](uint)
.text:00000A53                 mov     [ebp+var_28], eax
.text:00000A56                 movzx   ecx, [ebp+arg_0]
.text:00000A5A                 test    ecx, ecx
.text:00000A5C                 jnz     short loc_AB2
.text:00000A5E                 mov     ecx, [ebp+var_28]
.text:00000A61                 call    ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ ; CMyComPtr<IHasher>::operator->(void)
.text:00000A66                 mov     [ebp+var_88], eax
.text:00000A6C                 mov     edx, [ebp+var_28]
.text:00000A6F                 add     edx, 14h
.text:00000A72                 mov     esi, esp
.text:00000A74                 push    edx
.text:00000A75                 mov     eax, [ebp+var_88]
.text:00000A7B                 push    eax
.text:00000A7C                 mov     ecx, [ebp+var_88]
.text:00000A82                 mov     edx, [ecx]
.text:00000A84                 mov     eax, [edx+14h]
.text:00000A87                 call    eax
.text:00000A89                 cmp     esi, esp
.text:00000A8B                 call    __RTC_CheckEsp
.text:00000A90                 movzx   ecx, [ebp+arg_4]
.text:00000A94                 test    ecx, ecx
.text:00000A96                 jnz     short loc_AB2
.text:00000A98                 mov     edx, [ebp+var_28]
.text:00000A9B                 mov     eax, [edx+10h]
.text:00000A9E                 push    eax
.text:00000A9F                 mov     ecx, [ebp+var_28]
.text:00000AA2                 add     ecx, 14h
.text:00000AA5                 push    ecx
.text:00000AA6                 mov     edx, [ebp+var_28]
.text:00000AA9                 add     edx, 54h ; 'T'
.text:00000AAC                 push    edx
.text:00000AAD                 call    ?AddDigests@@YGXPAEPBEI@Z ; AddDigests(uchar *,uchar const *,uint)
.text:00000AB2
.text:00000AB2 loc_AB2:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+118j
.text:00000AB2                                         ; CHashBundle::Final(bool,bool,UString const &)+152j
.text:00000AB2                 mov     ecx, [ebp+var_28]
.text:00000AB5                 call    ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ ; CMyComPtr<IHasher>::operator->(void)
.text:00000ABA                 mov     [ebp+var_8C], eax
.text:00000AC0                 mov     eax, [ebp+var_8C]
.text:00000AC6                 mov     ecx, [eax]
.text:00000AC8                 mov     esi, esp
.text:00000ACA                 mov     edx, [ebp+var_8C]
.text:00000AD0                 push    edx
.text:00000AD1                 mov     eax, [ecx+0Ch]
.text:00000AD4                 call    eax
.text:00000AD6                 cmp     esi, esp
.text:00000AD8                 call    __RTC_CheckEsp
.text:00000ADD                 mov     ecx, [ebp+var_28]
.text:00000AE0                 call    ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ ; CMyComPtr<IHasher>::operator->(void)
.text:00000AE5                 mov     [ebp+var_90], eax
.text:00000AEB                 mov     esi, esp
.text:00000AED                 push    10h
.text:00000AEF                 lea     ecx, [ebp+Dst]
.text:00000AF2                 push    ecx
.text:00000AF3                 mov     edx, [ebp+var_90]
.text:00000AF9                 push    edx
.text:00000AFA                 mov     eax, [ebp+var_90]
.text:00000B00                 mov     ecx, [eax]
.text:00000B02                 mov     edx, [ecx+10h]
.text:00000B05                 call    edx
.text:00000B07                 cmp     esi, esp
.text:00000B09                 call    __RTC_CheckEsp
.text:00000B0E                 mov     ecx, [ebp+var_28]
.text:00000B11                 call    ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ ; CMyComPtr<IHasher>::operator->(void)
.text:00000B16                 mov     [ebp+var_94], eax
.text:00000B1C                 mov     esi, esp
.text:00000B1E                 mov     eax, [ebp+var_28]
.text:00000B21                 mov     ecx, [eax+10h]
.text:00000B24                 push    ecx
.text:00000B25                 mov     edx, [ebp+var_28]
.text:00000B28                 add     edx, 14h
.text:00000B2B                 push    edx
.text:00000B2C                 mov     eax, [ebp+var_94]
.text:00000B32                 push    eax
.text:00000B33                 mov     ecx, [ebp+var_94]
.text:00000B39                 mov     edx, [ecx]
.text:00000B3B                 mov     eax, [edx+10h]
.text:00000B3E                 call    eax
.text:00000B40                 cmp     esi, esp
.text:00000B42                 call    __RTC_CheckEsp
.text:00000B47                 mov     [ebp+var_2C], 0
.text:00000B4E                 jmp     short loc_B59
.text:00000B50 ; ---------------------------------------------------------------------------
.text:00000B50
.text:00000B50 loc_B50:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+283j
.text:00000B50                 mov     ecx, [ebp+var_2C]
.text:00000B53                 add     ecx, 1
.text:00000B56                 mov     [ebp+var_2C], ecx
.text:00000B59
.text:00000B59 loc_B59:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+20Aj
.text:00000B59                 mov     ecx, [ebp+arg_8] ; this
.text:00000B5C                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00000B61                 cmp     [ebp+var_2C], eax
.text:00000B64                 jnb     short loc_BC9
.text:00000B66                 mov     ecx, [ebp+arg_8]
.text:00000B69                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000B6E                 mov     edx, [ebp+var_2C]
.text:00000B71                 mov     ax, [eax+edx*2]
.text:00000B75                 mov     [ebp+var_30], ax
.text:00000B79                 movzx   ecx, [ebp+var_30]
.text:00000B7D                 and     ecx, 0FFh
.text:00000B83                 mov     [ebp+var_38], cl
.text:00000B86                 movzx   edx, [ebp+var_30]
.text:00000B8A                 sar     edx, 8
.text:00000B8D                 and     edx, 0FFh
.text:00000B93                 mov     [ebp+var_37], dl
.text:00000B96                 mov     ecx, [ebp+var_28]
.text:00000B99                 call    ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ ; CMyComPtr<IHasher>::operator->(void)
.text:00000B9E                 mov     [ebp+var_98], eax
.text:00000BA4                 mov     esi, esp
.text:00000BA6                 push    2
.text:00000BA8                 lea     eax, [ebp+var_38]
.text:00000BAB                 push    eax
.text:00000BAC                 mov     ecx, [ebp+var_98]
.text:00000BB2                 push    ecx
.text:00000BB3                 mov     edx, [ebp+var_98]
.text:00000BB9                 mov     eax, [edx]
.text:00000BBB                 mov     ecx, [eax+10h]
.text:00000BBE                 call    ecx
.text:00000BC0                 cmp     esi, esp
.text:00000BC2                 call    __RTC_CheckEsp
.text:00000BC7                 jmp     short loc_B50
.text:00000BC9 ; ---------------------------------------------------------------------------
.text:00000BC9
.text:00000BC9 loc_BC9:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+220j
.text:00000BC9                 mov     ecx, [ebp+var_28]
.text:00000BCC                 call    ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ ; CMyComPtr<IHasher>::operator->(void)
.text:00000BD1                 mov     [ebp+var_9C], eax
.text:00000BD7                 mov     esi, esp
.text:00000BD9                 lea     edx, [ebp+var_80]
.text:00000BDC                 push    edx
.text:00000BDD                 mov     eax, [ebp+var_9C]
.text:00000BE3                 push    eax
.text:00000BE4                 mov     ecx, [ebp+var_9C]
.text:00000BEA                 mov     edx, [ecx]
.text:00000BEC                 mov     eax, [edx+14h]
.text:00000BEF                 call    eax
.text:00000BF1                 cmp     esi, esp
.text:00000BF3                 call    __RTC_CheckEsp
.text:00000BF8                 movzx   ecx, [ebp+arg_4]
.text:00000BFC                 test    ecx, ecx
.text:00000BFE                 jnz     short loc_C1A
.text:00000C00                 mov     edx, [ebp+var_28]
.text:00000C03                 mov     eax, [edx+10h]
.text:00000C06                 push    eax
.text:00000C07                 lea     ecx, [ebp+var_80]
.text:00000C0A                 push    ecx
.text:00000C0B                 mov     edx, [ebp+var_28]
.text:00000C0E                 add     edx, 94h ; ''
.text:00000C14                 push    edx
.text:00000C15                 call    ?AddDigests@@YGXPAEPBEI@Z ; AddDigests(uchar *,uchar const *,uint)
.text:00000C1A
.text:00000C1A loc_C1A:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+2BAj
.text:00000C1A                 mov     eax, [ebp+var_28]
.text:00000C1D                 mov     ecx, [eax+10h]
.text:00000C20                 push    ecx
.text:00000C21                 lea     edx, [ebp+var_80]
.text:00000C24                 push    edx
.text:00000C25                 mov     eax, [ebp+var_28]
.text:00000C28                 add     eax, 0D4h ; '+'
.text:00000C2D                 push    eax
.text:00000C2E                 call    ?AddDigests@@YGXPAEPBEI@Z ; AddDigests(uchar *,uchar const *,uint)
.text:00000C33                 jmp     loc_A27
.text:00000C38 ; ---------------------------------------------------------------------------
.text:00000C38
.text:00000C38 loc_C38:                                ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+FAj
.text:00000C38                 push    edx
.text:00000C39                 mov     ecx, ebp
.text:00000C3B                 push    eax
.text:00000C3C                 lea     edx, $LN21
.text:00000C42                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000C47                 pop     eax
.text:00000C48                 pop     edx
.text:00000C49                 pop     edi
.text:00000C4A                 pop     esi
.text:00000C4B                 mov     ecx, [ebp+var_4]
.text:00000C4E                 xor     ecx, ebp
.text:00000C50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00000C55                 add     esp, 9Ch
.text:00000C5B                 cmp     ebp, esp
.text:00000C5D                 call    __RTC_CheckEsp
.text:00000C62                 mov     esp, ebp
.text:00000C64                 pop     ebp
.text:00000C65                 retn    0Ch
.text:00000C65 ?Final@CHashBundle@@UAEX_N0ABVUString@@@Z endp
.text:00000C65
.text:00000C65 ; ---------------------------------------------------------------------------
.text:00000C68 $LN21           dd 3                    ; DATA XREF: CHashBundle::Final(bool,bool,UString const &)+2F8o
.text:00000C6C                 dd offset $LN20
.text:00000C70 $LN20           dd 0FFFFFFE4h, 10h      ; DATA XREF: .text:00000C6Co
.text:00000C78                 dd offset $LN17         ; "pre"
.text:00000C7C                 dd 0FFFFFFC8h, 2
.text:00000C84                 dd offset $LN18         ; "temp"
.text:00000C88                 dd 0FFFFFF80h, 40h
.text:00000C90                 dd offset $LN19         ; "tempDigest"
.text:00000C94 $LN19           db 'tempDigest',0       ; DATA XREF: .text:00000C90o
.text:00000C9F $LN18           db 'temp',0             ; DATA XREF: .text:00000C84o
.text:00000CA4 $LN17           db 'pre',0              ; DATA XREF: .text:00000C78o
.text:00000CA8                 db 0Ch dup(0CCh)
.text:00000CB4
.text:00000CB4 ; =============== S U B R O U T I N E =======================================
.text:00000CB4
.text:00000CB4 ; Attributes: bp-based frame
.text:00000CB4
.text:00000CB4 ; void __stdcall AddDigests(unsigned char *, unsigned char const *, unsigned int)
.text:00000CB4 ?AddDigests@@YGXPAEPBEI@Z proc near     ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+169p
.text:00000CB4                                         ; CHashBundle::Final(bool,bool,UString const &)+2D1p ...
.text:00000CB4
.text:00000CB4 var_8           = dword ptr -8
.text:00000CB4 var_4           = dword ptr -4
.text:00000CB4 arg_0           = dword ptr  8
.text:00000CB4 arg_4           = dword ptr  0Ch
.text:00000CB4 arg_8           = dword ptr  10h
.text:00000CB4
.text:00000CB4                 push    ebp
.text:00000CB5                 mov     ebp, esp
.text:00000CB7                 sub     esp, 8
.text:00000CBA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000CC1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000CC8                 mov     [ebp+var_4], 0
.text:00000CCF                 mov     [ebp+var_8], 0
.text:00000CD6                 jmp     short loc_CE1
.text:00000CD8 ; ---------------------------------------------------------------------------
.text:00000CD8
.text:00000CD8 loc_CD8:                                ; CODE XREF: AddDigests(uchar *,uchar const *,uint)+63j
.text:00000CD8                 mov     eax, [ebp+var_8]
.text:00000CDB                 add     eax, 1
.text:00000CDE                 mov     [ebp+var_8], eax
.text:00000CE1
.text:00000CE1 loc_CE1:                                ; CODE XREF: AddDigests(uchar *,uchar const *,uint)+22j
.text:00000CE1                 mov     ecx, [ebp+var_8]
.text:00000CE4                 cmp     ecx, [ebp+arg_8]
.text:00000CE7                 jnb     short loc_D19
.text:00000CE9                 mov     edx, [ebp+arg_0]
.text:00000CEC                 add     edx, [ebp+var_8]
.text:00000CEF                 movzx   eax, byte ptr [edx]
.text:00000CF2                 mov     ecx, [ebp+arg_4]
.text:00000CF5                 add     ecx, [ebp+var_8]
.text:00000CF8                 movzx   edx, byte ptr [ecx]
.text:00000CFB                 add     edx, [ebp+var_4]
.text:00000CFE                 add     edx, eax
.text:00000D00                 mov     [ebp+var_4], edx
.text:00000D03                 mov     eax, [ebp+arg_0]
.text:00000D06                 add     eax, [ebp+var_8]
.text:00000D09                 mov     cl, byte ptr [ebp+var_4]
.text:00000D0C                 mov     [eax], cl
.text:00000D0E                 mov     edx, [ebp+var_4]
.text:00000D11                 shr     edx, 8
.text:00000D14                 mov     [ebp+var_4], edx
.text:00000D17                 jmp     short loc_CD8
.text:00000D19 ; ---------------------------------------------------------------------------
.text:00000D19
.text:00000D19 loc_D19:                                ; CODE XREF: AddDigests(uchar *,uchar const *,uint)+33j
.text:00000D19                 mov     esp, ebp
.text:00000D1B                 pop     ebp
.text:00000D1C                 retn    0Ch
.text:00000D1C ?AddDigests@@YGXPAEPBEI@Z endp
.text:00000D1C
.text:00000D1C ; ---------------------------------------------------------------------------
.text:00000D1F                 db 5 dup(0CCh)
.text:00000D24
.text:00000D24 ; =============== S U B R O U T I N E =======================================
.text:00000D24
.text:00000D24 ; Attributes: bp-based frame
.text:00000D24
.text:00000D24 ; __int32 __stdcall HashCalc(const struct NWildcard::CCensor *, const struct CHashOptions *, struct AString *, struct IHashCallbackUI *)
.text:00000D24                 public ?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z
.text:00000D24 ?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z proc near
.text:00000D24
.text:00000D24 var_28C         = dword ptr -28Ch
.text:00000D24 var_288         = dword ptr -288h
.text:00000D24 var_284         = dword ptr -284h
.text:00000D24 var_280         = dword ptr -280h
.text:00000D24 var_27C         = dword ptr -27Ch
.text:00000D24 var_278         = dword ptr -278h
.text:00000D24 var_274         = dword ptr -274h
.text:00000D24 var_270         = dword ptr -270h
.text:00000D24 var_26C         = dword ptr -26Ch
.text:00000D24 var_268         = dword ptr -268h
.text:00000D24 var_264         = dword ptr -264h
.text:00000D24 var_260         = dword ptr -260h
.text:00000D24 var_25C         = dword ptr -25Ch
.text:00000D24 var_258         = dword ptr -258h
.text:00000D24 var_254         = byte ptr -254h
.text:00000D24 var_248         = dword ptr -248h
.text:00000D24 var_244         = dword ptr -244h
.text:00000D24 var_240         = dword ptr -240h
.text:00000D24 var_23C         = dword ptr -23Ch
.text:00000D24 var_238         = dword ptr -238h
.text:00000D24 var_234         = dword ptr -234h
.text:00000D24 var_230         = dword ptr -230h
.text:00000D24 var_22C         = dword ptr -22Ch
.text:00000D24 var_228         = dword ptr -228h
.text:00000D24 var_224         = dword ptr -224h
.text:00000D24 var_220         = dword ptr -220h
.text:00000D24 var_21C         = byte ptr -21Ch
.text:00000D24 var_210         = dword ptr -210h
.text:00000D24 var_20C         = dword ptr -20Ch
.text:00000D24 var_208         = dword ptr -208h
.text:00000D24 var_204         = dword ptr -204h
.text:00000D24 var_1FC         = dword ptr -1FCh
.text:00000D24 var_1F4         = dword ptr -1F4h
.text:00000D24 var_1F0         = dword ptr -1F0h
.text:00000D24 var_1EC         = dword ptr -1ECh
.text:00000D24 var_1E8         = dword ptr -1E8h
.text:00000D24 var_1E4         = dword ptr -1E4h
.text:00000D24 var_1E0         = dword ptr -1E0h
.text:00000D24 var_1D8         = byte ptr -1D8h
.text:00000D24 var_1C8         = dword ptr -1C8h
.text:00000D24 var_1C4         = dword ptr -1C4h
.text:00000D24 var_1BE         = byte ptr -1BEh
.text:00000D24 var_1BD         = byte ptr -1BDh
.text:00000D24 var_1B8         = byte ptr -1B8h
.text:00000D24 var_1A4         = byte ptr -1A4h
.text:00000D24 var_19C         = dword ptr -19Ch
.text:00000D24 var_194         = dword ptr -194h
.text:00000D24 var_190         = dword ptr -190h
.text:00000D24 var_184         = byte ptr -184h
.text:00000D24 var_17C         = dword ptr -17Ch
.text:00000D24 var_178         = dword ptr -178h
.text:00000D24 var_174         = dword ptr -174h
.text:00000D24 var_170         = dword ptr -170h
.text:00000D24 var_168         = byte ptr -168h
.text:00000D24 var_130         = dword ptr -130h
.text:00000D24 var_12C         = dword ptr -12Ch
.text:00000D24 var_11C         = dword ptr -11Ch
.text:00000D24 var_118         = dword ptr -118h
.text:00000D24 var_114         = dword ptr -114h
.text:00000D24 var_110         = dword ptr -110h
.text:00000D24 var_108         = dword ptr -108h
.text:00000D24 var_104         = dword ptr -104h
.text:00000D24 var_100         = dword ptr -100h
.text:00000D24 var_FC          = dword ptr -0FCh
.text:00000D24 var_F8          = dword ptr -0F8h
.text:00000D24 var_F4          = dword ptr -0F4h
.text:00000D24 var_F0          = dword ptr -0F0h
.text:00000D24 var_EC          = dword ptr -0ECh
.text:00000D24 var_CC          = dword ptr -0CCh
.text:00000D24 var_B0          = byte ptr -0B0h
.text:00000D24 var_8C          = byte ptr -8Ch
.text:00000D24 var_7F          = byte ptr -7Fh
.text:00000D24 var_78          = byte ptr -78h
.text:00000D24 var_50          = dword ptr -50h
.text:00000D24 var_4C          = dword ptr -4Ch
.text:00000D24 var_18          = dword ptr -18h
.text:00000D24 var_C           = dword ptr -0Ch
.text:00000D24 var_4           = dword ptr -4
.text:00000D24 arg_0           = dword ptr  8
.text:00000D24 arg_4           = dword ptr  0Ch
.text:00000D24 arg_8           = dword ptr  10h
.text:00000D24 arg_C           = dword ptr  14h
.text:00000D24
.text:00000D24                 push    ebp
.text:00000D25                 mov     ebp, esp
.text:00000D27                 push    0FFFFFFFFh
.text:00000D29                 push    offset __ehhandler$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z
.text:00000D2E                 mov     eax, large fs:0
.text:00000D34                 push    eax
.text:00000D35                 sub     esp, 280h
.text:00000D3B                 push    esi
.text:00000D3C                 push    edi
.text:00000D3D                 lea     edi, [ebp+var_28C]
.text:00000D43                 mov     ecx, 0A0h ; ''
.text:00000D48                 mov     eax, 0CCCCCCCCh
.text:00000D4D                 rep stosd
.text:00000D4F                 mov     eax, dword ptr ds:___security_cookie
.text:00000D54                 xor     eax, ebp
.text:00000D56                 push    eax
.text:00000D57                 lea     eax, [ebp+var_C]
.text:00000D5A                 mov     large fs:0, eax
.text:00000D60                 lea     ecx, [ebp+var_B0] ; this
.text:00000D66                 call    ??0CDirItems@@QAE@XZ ; CDirItems::CDirItems(void)
.text:00000D6B                 mov     [ebp+var_4], 0
.text:00000D72                 mov     eax, [ebp+arg_C]
.text:00000D75                 mov     [ebp+var_18], eax
.text:00000D78                 mov     ecx, [ebp+arg_4]
.text:00000D7B                 movzx   edx, byte ptr [ecx+0Dh]
.text:00000D7F                 test    edx, edx
.text:00000D81                 jz      loc_E1E
.text:00000D87                 lea     ecx, [ebp+var_108]
.text:00000D8D                 call    ??0CDirItem@@QAE@XZ ; CDirItem::CDirItem(void)
.text:00000D92                 mov     byte ptr [ebp+var_4], 1
.text:00000D96                 mov     [ebp+var_108], 0FFFFFFFFh
.text:00000DA0                 mov     [ebp+var_104], 0FFFFFFFFh
.text:00000DAA                 mov     [ebp+var_CC], 0
.text:00000DB4                 mov     [ebp+var_F0], 0
.text:00000DBE                 mov     [ebp+var_EC], 0
.text:00000DC8                 mov     eax, [ebp+var_F0]
.text:00000DCE                 mov     [ebp+var_F8], eax
.text:00000DD4                 mov     ecx, [ebp+var_EC]
.text:00000DDA                 mov     [ebp+var_F4], ecx
.text:00000DE0                 mov     edx, [ebp+var_F8]
.text:00000DE6                 mov     [ebp+var_100], edx
.text:00000DEC                 mov     eax, [ebp+var_F4]
.text:00000DF2                 mov     [ebp+var_FC], eax
.text:00000DF8                 lea     ecx, [ebp+var_108]
.text:00000DFE                 push    ecx
.text:00000DFF                 lea     ecx, [ebp+var_8C]
.text:00000E05                 call    ?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z ; CObjectVector<CDirItem>::Add(CDirItem const &)
.text:00000E0A                 mov     byte ptr [ebp+var_4], 0
.text:00000E0E                 lea     ecx, [ebp+var_108] ; this
.text:00000E14                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00000E19                 jmp     loc_F66
.text:00000E1E ; ---------------------------------------------------------------------------
.text:00000E1E
.text:00000E1E loc_E1E:                                ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+5Dj
.text:00000E1E                 mov     edx, [ebp+arg_C]
.text:00000E21                 mov     eax, [edx]
.text:00000E23                 mov     esi, esp
.text:00000E25                 mov     ecx, [ebp+arg_C]
.text:00000E28                 mov     edx, [eax+8]
.text:00000E2B                 call    edx
.text:00000E2D                 cmp     esi, esp
.text:00000E2F                 call    __RTC_CheckEsp
.text:00000E34                 mov     [ebp+var_110], eax
.text:00000E3A                 cmp     [ebp+var_110], 0
.text:00000E41                 jz      short loc_E6C
.text:00000E43                 mov     eax, [ebp+var_110]
.text:00000E49                 mov     [ebp+var_210], eax
.text:00000E4F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000E56                 lea     ecx, [ebp+var_B0] ; this
.text:00000E5C                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00000E61                 mov     eax, [ebp+var_210]
.text:00000E67                 jmp     loc_1964
.text:00000E6C ; ---------------------------------------------------------------------------
.text:00000E6C
.text:00000E6C loc_E6C:                                ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+11Dj
.text:00000E6C                 mov     ecx, [ebp+arg_4]
.text:00000E6F                 mov     dl, [ecx+0Eh]
.text:00000E72                 mov     [ebp+var_7F], dl
.text:00000E75                 lea     eax, [ebp+var_B0]
.text:00000E7B                 push    eax
.text:00000E7C                 lea     ecx, [ebp+var_21C]
.text:00000E82                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000E87                 mov     [ebp+var_274], eax
.text:00000E8D                 mov     ecx, [ebp+var_274]
.text:00000E93                 mov     [ebp+var_278], ecx
.text:00000E99                 mov     byte ptr [ebp+var_4], 2
.text:00000E9D                 mov     edx, [ebp+var_278]
.text:00000EA3                 push    edx
.text:00000EA4                 mov     eax, [ebp+arg_4]
.text:00000EA7                 mov     ecx, [eax+10h]
.text:00000EAA                 push    ecx
.text:00000EAB                 mov     edx, [ebp+arg_0]
.text:00000EAE                 push    edx
.text:00000EAF                 call    ?EnumerateItems@@YGJABVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAVCDirItems@@@Z ; EnumerateItems(NWildcard::CCensor const &,NWildcard::ECensorPathMode,UString const &,CDirItems &)
.text:00000EB4                 mov     [ebp+var_114], eax
.text:00000EBA                 mov     byte ptr [ebp+var_4], 0
.text:00000EBE                 lea     ecx, [ebp+var_21C] ; this
.text:00000EC4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000EC9                 cmp     [ebp+var_114], 0
.text:00000ED0                 jz      short loc_F14
.text:00000ED2                 cmp     [ebp+var_114], 80004004h
.text:00000EDC                 jz      short loc_EEB
.text:00000EDE                 push    offset $SG71453 ; "Scanning error"
.text:00000EE3                 mov     ecx, [ebp+arg_8]
.text:00000EE6                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:00000EEB
.text:00000EEB loc_EEB:                                ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+1B8j
.text:00000EEB                 mov     eax, [ebp+var_114]
.text:00000EF1                 mov     [ebp+var_220], eax
.text:00000EF7                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000EFE                 lea     ecx, [ebp+var_B0] ; this
.text:00000F04                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00000F09                 mov     eax, [ebp+var_220]
.text:00000F0F                 jmp     loc_1964
.text:00000F14 ; ---------------------------------------------------------------------------
.text:00000F14
.text:00000F14 loc_F14:                                ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+1ACj
.text:00000F14                 mov     esi, esp
.text:00000F16                 lea     ecx, [ebp+var_78]
.text:00000F19                 push    ecx
.text:00000F1A                 mov     edx, [ebp+arg_C]
.text:00000F1D                 mov     eax, [edx]
.text:00000F1F                 mov     ecx, [ebp+arg_C]
.text:00000F22                 mov     edx, [eax+0Ch]
.text:00000F25                 call    edx
.text:00000F27                 cmp     esi, esp
.text:00000F29                 call    __RTC_CheckEsp
.text:00000F2E                 mov     [ebp+var_118], eax
.text:00000F34                 cmp     [ebp+var_118], 0
.text:00000F3B                 jz      short loc_F66
.text:00000F3D                 mov     eax, [ebp+var_118]
.text:00000F43                 mov     [ebp+var_224], eax
.text:00000F49                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000F50                 lea     ecx, [ebp+var_B0] ; this
.text:00000F56                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00000F5B                 mov     eax, [ebp+var_224]
.text:00000F61                 jmp     loc_1964
.text:00000F66 ; ---------------------------------------------------------------------------
.text:00000F66
.text:00000F66 loc_F66:                                ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+F5j
.text:00000F66                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+217j
.text:00000F66                 lea     ecx, [ebp+var_168]
.text:00000F6C                 call    ??0CHashBundle@@QAE@XZ ; CHashBundle::CHashBundle(void)
.text:00000F71                 mov     byte ptr [ebp+var_4], 3
.text:00000F75                 mov     ecx, [ebp+arg_4]
.text:00000F78                 push    ecx
.text:00000F79                 lea     ecx, [ebp+var_168]
.text:00000F7F                 call    ?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z ; CHashBundle::SetMethods(CObjectVector<UString> const &)
.text:00000F84                 mov     [ebp+var_170], eax
.text:00000F8A                 cmp     [ebp+var_170], 0
.text:00000F91                 jz      short loc_FCB
.text:00000F93                 mov     edx, [ebp+var_170]
.text:00000F99                 mov     [ebp+var_228], edx
.text:00000F9F                 mov     byte ptr [ebp+var_4], 0
.text:00000FA3                 lea     ecx, [ebp+var_168] ; this
.text:00000FA9                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:00000FAE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000FB5                 lea     ecx, [ebp+var_B0] ; this
.text:00000FBB                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00000FC0                 mov     eax, [ebp+var_228]
.text:00000FC6                 jmp     loc_1964
.text:00000FCB ; ---------------------------------------------------------------------------
.text:00000FCB
.text:00000FCB loc_FCB:                                ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+26Dj
.text:00000FCB                 lea     ecx, [ebp+var_168] ; this
.text:00000FD1                 call    ?Init@CHashBundle@@QAEXXZ ; CHashBundle::Init(void)
.text:00000FD6                 mov     eax, [ebp+var_50]
.text:00000FD9                 mov     [ebp+var_130], eax
.text:00000FDF                 mov     ecx, [ebp+var_4C]
.text:00000FE2                 mov     [ebp+var_12C], ecx
.text:00000FE8                 mov     edx, [ebp+arg_4]
.text:00000FEB                 movzx   eax, byte ptr [edx+0Dh]
.text:00000FEF                 test    eax, eax
.text:00000FF1                 jz      short loc_1056
.text:00000FF3                 mov     esi, esp
.text:00000FF5                 push    0
.text:00000FF7                 push    1
.text:00000FF9                 mov     ecx, [ebp+arg_C]
.text:00000FFC                 mov     edx, [ecx]
.text:00000FFE                 mov     ecx, [ebp+arg_C]
.text:00001001                 mov     eax, [edx+10h]
.text:00001004                 call    eax
.text:00001006                 cmp     esi, esp
.text:00001008                 call    __RTC_CheckEsp
.text:0000100D                 mov     [ebp+var_174], eax
.text:00001013                 cmp     [ebp+var_174], 0
.text:0000101A                 jz      short loc_1054
.text:0000101C                 mov     ecx, [ebp+var_174]
.text:00001022                 mov     [ebp+var_22C], ecx
.text:00001028                 mov     byte ptr [ebp+var_4], 0
.text:0000102C                 lea     ecx, [ebp+var_168] ; this
.text:00001032                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:00001037                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000103E                 lea     ecx, [ebp+var_B0] ; this
.text:00001044                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00001049                 mov     eax, [ebp+var_22C]
.text:0000104F                 jmp     loc_1964
.text:00001054 ; ---------------------------------------------------------------------------
.text:00001054
.text:00001054 loc_1054:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+2F6j
.text:00001054                 jmp     short loc_10BD
.text:00001056 ; ---------------------------------------------------------------------------
.text:00001056
.text:00001056 loc_1056:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+2CDj
.text:00001056                 lea     ecx, [ebp+var_78] ; this
.text:00001059                 call    ?GetTotalBytes@CDirItemsStat@@QBE_KXZ ; CDirItemsStat::GetTotalBytes(void)
.text:0000105E                 mov     esi, esp
.text:00001060                 push    edx
.text:00001061                 push    eax
.text:00001062                 mov     edx, [ebp+arg_C]
.text:00001065                 mov     eax, [edx]
.text:00001067                 mov     ecx, [ebp+arg_C]
.text:0000106A                 mov     edx, [eax+14h]
.text:0000106D                 call    edx
.text:0000106F                 cmp     esi, esp
.text:00001071                 call    __RTC_CheckEsp
.text:00001076                 mov     [ebp+var_178], eax
.text:0000107C                 cmp     [ebp+var_178], 0
.text:00001083                 jz      short loc_10BD
.text:00001085                 mov     eax, [ebp+var_178]
.text:0000108B                 mov     [ebp+var_230], eax
.text:00001091                 mov     byte ptr [ebp+var_4], 0
.text:00001095                 lea     ecx, [ebp+var_168] ; this
.text:0000109B                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:000010A0                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000010A7                 lea     ecx, [ebp+var_B0] ; this
.text:000010AD                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:000010B2                 mov     eax, [ebp+var_230]
.text:000010B8                 jmp     loc_1964
.text:000010BD ; ---------------------------------------------------------------------------
.text:000010BD
.text:000010BD loc_10BD:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *):loc_1054j
.text:000010BD                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+35Fj
.text:000010BD                 mov     [ebp+var_17C], 8000h
.text:000010C7                 lea     ecx, [ebp+var_184] ; this
.text:000010CD                 call    ??0CHashMidBuf@@QAE@XZ ; CHashMidBuf::CHashMidBuf(void)
.text:000010D2                 mov     byte ptr [ebp+var_4], 4
.text:000010D6                 push    8000h           ; unsigned int
.text:000010DB                 lea     ecx, [ebp+var_184] ; this
.text:000010E1                 call    ?Alloc@CHashMidBuf@@QAE_NI@Z ; CHashMidBuf::Alloc(uint)
.text:000010E6                 movzx   ecx, al
.text:000010E9                 test    ecx, ecx
.text:000010EB                 jnz     short loc_1132
.text:000010ED                 mov     [ebp+var_234], 8007000Eh
.text:000010F7                 mov     byte ptr [ebp+var_4], 3
.text:000010FB                 lea     ecx, [ebp+var_184] ; this
.text:00001101                 call    ??1CHashMidBuf@@QAE@XZ ; CHashMidBuf::~CHashMidBuf(void)
.text:00001106                 mov     byte ptr [ebp+var_4], 0
.text:0000110A                 lea     ecx, [ebp+var_168] ; this
.text:00001110                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:00001115                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000111C                 lea     ecx, [ebp+var_B0] ; this
.text:00001122                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00001127                 mov     eax, [ebp+var_234]
.text:0000112D                 jmp     loc_1964
.text:00001132 ; ---------------------------------------------------------------------------
.text:00001132
.text:00001132 loc_1132:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+3C7j
.text:00001132                 mov     [ebp+var_194], 0
.text:0000113C                 mov     [ebp+var_190], 0
.text:00001146                 mov     esi, esp
.text:00001148                 lea     edx, [ebp+var_168]
.text:0000114E                 push    edx
.text:0000114F                 mov     eax, [ebp+arg_C]
.text:00001152                 mov     edx, [eax]
.text:00001154                 mov     ecx, [ebp+arg_C]
.text:00001157                 mov     eax, [edx+20h]
.text:0000115A                 call    eax
.text:0000115C                 cmp     esi, esp
.text:0000115E                 call    __RTC_CheckEsp
.text:00001163                 mov     [ebp+var_19C], eax
.text:00001169                 cmp     [ebp+var_19C], 0
.text:00001170                 jz      short loc_11B9
.text:00001172                 mov     ecx, [ebp+var_19C]
.text:00001178                 mov     [ebp+var_238], ecx
.text:0000117E                 mov     byte ptr [ebp+var_4], 3
.text:00001182                 lea     ecx, [ebp+var_184] ; this
.text:00001188                 call    ??1CHashMidBuf@@QAE@XZ ; CHashMidBuf::~CHashMidBuf(void)
.text:0000118D                 mov     byte ptr [ebp+var_4], 0
.text:00001191                 lea     ecx, [ebp+var_168] ; this
.text:00001197                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:0000119C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000011A3                 lea     ecx, [ebp+var_B0] ; this
.text:000011A9                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:000011AE                 mov     eax, [ebp+var_238]
.text:000011B4                 jmp     loc_1964
.text:000011B9 ; ---------------------------------------------------------------------------
.text:000011B9
.text:000011B9 loc_11B9:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+44Cj
.text:000011B9                 mov     [ebp+var_11C], 0
.text:000011C3                 jmp     short loc_11D4
.text:000011C5 ; ---------------------------------------------------------------------------
.text:000011C5
.text:000011C5 loc_11C5:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+7A0j
.text:000011C5                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+BE2j
.text:000011C5                 mov     edx, [ebp+var_11C]
.text:000011CB                 add     edx, 1
.text:000011CE                 mov     [ebp+var_11C], edx
.text:000011D4
.text:000011D4 loc_11D4:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+49Fj
.text:000011D4                 lea     ecx, [ebp+var_8C]
.text:000011DA                 call    ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ ; CObjectVector<CDirItem>::Size(void)
.text:000011DF                 cmp     [ebp+var_11C], eax
.text:000011E5                 jnb     loc_190B
.text:000011EB                 lea     ecx, [ebp+var_1A4]
.text:000011F1                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(void)
.text:000011F6                 mov     byte ptr [ebp+var_4], 5
.text:000011FA                 lea     ecx, [ebp+var_1B8]
.text:00001200                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00001205                 mov     byte ptr [ebp+var_4], 6
.text:00001209                 mov     [ebp+var_1BD], 0
.text:00001210                 mov     [ebp+var_1BE], 0
.text:00001217                 mov     eax, [ebp+arg_4]
.text:0000121A                 movzx   ecx, byte ptr [eax+0Dh]
.text:0000121E                 test    ecx, ecx
.text:00001220                 jz      short loc_1283
.text:00001222                 push    8               ; unsigned int
.text:00001224                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001229                 add     esp, 4
.text:0000122C                 mov     [ebp+var_240], eax
.text:00001232                 mov     byte ptr [ebp+var_4], 7
.text:00001236                 cmp     [ebp+var_240], 0
.text:0000123D                 jz      short loc_1252
.text:0000123F                 mov     ecx, [ebp+var_240]
.text:00001245                 call    ??0CStdInFileStream@@QAE@XZ ; CStdInFileStream::CStdInFileStream(void)
.text:0000124A                 mov     [ebp+var_27C], eax
.text:00001250                 jmp     short loc_125C
.text:00001252 ; ---------------------------------------------------------------------------
.text:00001252
.text:00001252 loc_1252:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+519j
.text:00001252                 mov     [ebp+var_27C], 0
.text:0000125C
.text:0000125C loc_125C:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+52Cj
.text:0000125C                 mov     edx, [ebp+var_27C]
.text:00001262                 mov     [ebp+var_23C], edx
.text:00001268                 mov     byte ptr [ebp+var_4], 6
.text:0000126C                 mov     eax, [ebp+var_23C]
.text:00001272                 push    eax
.text:00001273                 lea     ecx, [ebp+var_1A4]
.text:00001279                 call    ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z ; CMyComPtr<ISequentialInStream>::operator=(ISequentialInStream *)
.text:0000127E                 jmp     loc_14D8
.text:00001283 ; ---------------------------------------------------------------------------
.text:00001283
.text:00001283 loc_1283:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+4FCj
.text:00001283                 push    58h ; 'X'       ; unsigned int
.text:00001285                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000128A                 add     esp, 4
.text:0000128D                 mov     [ebp+var_248], eax
.text:00001293                 mov     byte ptr [ebp+var_4], 8
.text:00001297                 cmp     [ebp+var_248], 0
.text:0000129E                 jz      short loc_12B3
.text:000012A0                 mov     ecx, [ebp+var_248] ; this
.text:000012A6                 call    ??0CInFileStream@@QAE@XZ ; CInFileStream::CInFileStream(void)
.text:000012AB                 mov     [ebp+var_280], eax
.text:000012B1                 jmp     short loc_12BD
.text:000012B3 ; ---------------------------------------------------------------------------
.text:000012B3
.text:000012B3 loc_12B3:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+57Aj
.text:000012B3                 mov     [ebp+var_280], 0
.text:000012BD
.text:000012BD loc_12BD:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+58Dj
.text:000012BD                 mov     ecx, [ebp+var_280]
.text:000012C3                 mov     [ebp+var_244], ecx
.text:000012C9                 mov     byte ptr [ebp+var_4], 6
.text:000012CD                 mov     edx, [ebp+var_244]
.text:000012D3                 mov     [ebp+var_1C4], edx
.text:000012D9                 mov     eax, [ebp+var_1C4]
.text:000012DF                 push    eax
.text:000012E0                 lea     ecx, [ebp+var_1A4]
.text:000012E6                 call    ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z ; CMyComPtr<ISequentialInStream>::operator=(ISequentialInStream *)
.text:000012EB                 mov     ecx, [ebp+var_11C]
.text:000012F1                 push    ecx
.text:000012F2                 lea     ecx, [ebp+var_8C]
.text:000012F8                 call    ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z ; CObjectVector<CDirItem>::operator[](uint)
.text:000012FD                 mov     [ebp+var_1C8], eax
.text:00001303                 mov     ecx, [ebp+var_1C8] ; this
.text:00001309                 call    ?IsDir@CDirItem@@QBE_NXZ ; CDirItem::IsDir(void)
.text:0000130E                 mov     [ebp+var_1BD], al
.text:00001314                 mov     edx, [ebp+var_1C8]
.text:0000131A                 mov     al, [edx+4Ch]
.text:0000131D                 mov     [ebp+var_1BE], al
.text:00001323                 mov     ecx, [ebp+var_11C]
.text:00001329                 push    ecx
.text:0000132A                 lea     edx, [ebp+var_254]
.text:00001330                 push    edx
.text:00001331                 lea     ecx, [ebp+var_B0]
.text:00001337                 call    ?GetLogPath@CDirItems@@QBE?AVUString@@I@Z ; CDirItems::GetLogPath(uint)
.text:0000133C                 mov     [ebp+var_284], eax
.text:00001342                 mov     eax, [ebp+var_284]
.text:00001348                 mov     [ebp+var_288], eax
.text:0000134E                 mov     byte ptr [ebp+var_4], 9
.text:00001352                 mov     ecx, [ebp+var_288]
.text:00001358                 push    ecx
.text:00001359                 lea     ecx, [ebp+var_1B8]
.text:0000135F                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00001364                 mov     byte ptr [ebp+var_4], 6
.text:00001368                 lea     ecx, [ebp+var_254] ; this
.text:0000136E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001373                 movzx   edx, [ebp+var_1BD]
.text:0000137A                 test    edx, edx
.text:0000137C                 jnz     loc_14D8
.text:00001382                 mov     eax, [ebp+var_11C]
.text:00001388                 push    eax
.text:00001389                 lea     ecx, [ebp+var_1D8]
.text:0000138F                 push    ecx
.text:00001390                 lea     ecx, [ebp+var_B0]
.text:00001396                 call    ?GetPhyPath@CDirItems@@QBE?AVUString@@I@Z ; CDirItems::GetPhyPath(uint)
.text:0000139B                 mov     byte ptr [ebp+var_4], 0Ah
.text:0000139F                 mov     edx, [ebp+arg_4]
.text:000013A2                 movzx   eax, byte ptr [edx+0Ch]
.text:000013A6                 push    eax             ; bool
.text:000013A7                 lea     ecx, [ebp+var_1D8]
.text:000013AD                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000013B2                 push    eax             ; wchar_t *
.text:000013B3                 mov     ecx, [ebp+var_1C4] ; this
.text:000013B9                 call    ?OpenShared@CInFileStream@@QAE_NPB_W_N@Z ; CInFileStream::OpenShared(wchar_t const *,bool)
.text:000013BE                 movzx   ecx, al
.text:000013C1                 test    ecx, ecx
.text:000013C3                 jnz     loc_14C9
.text:000013C9                 mov     esi, esp
.text:000013CB                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text:000013D1                 cmp     esi, esp
.text:000013D3                 call    __RTC_CheckEsp
.text:000013D8                 mov     esi, esp
.text:000013DA                 push    eax
.text:000013DB                 lea     edx, [ebp+var_1D8]
.text:000013E1                 push    edx
.text:000013E2                 mov     eax, [ebp+arg_C]
.text:000013E5                 mov     edx, [eax]
.text:000013E7                 mov     ecx, [ebp+arg_C]
.text:000013EA                 mov     eax, [edx+28h]
.text:000013ED                 call    eax
.text:000013EF                 cmp     esi, esp
.text:000013F1                 call    __RTC_CheckEsp
.text:000013F6                 mov     [ebp+var_1E0], eax
.text:000013FC                 mov     ecx, [ebp+var_130]
.text:00001402                 add     ecx, 1
.text:00001405                 mov     edx, [ebp+var_12C]
.text:0000140B                 adc     edx, 0
.text:0000140E                 mov     [ebp+var_130], ecx
.text:00001414                 mov     [ebp+var_12C], edx
.text:0000141A                 cmp     [ebp+var_1E0], 1
.text:00001421                 jz      short loc_1497
.text:00001423                 mov     eax, [ebp+var_1E0]
.text:00001429                 mov     [ebp+var_258], eax
.text:0000142F                 mov     byte ptr [ebp+var_4], 6
.text:00001433                 lea     ecx, [ebp+var_1D8] ; this
.text:00001439                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000143E                 mov     byte ptr [ebp+var_4], 5
.text:00001442                 lea     ecx, [ebp+var_1B8] ; this
.text:00001448                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000144D                 mov     byte ptr [ebp+var_4], 4
.text:00001451                 lea     ecx, [ebp+var_1A4]
.text:00001457                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:0000145C                 mov     byte ptr [ebp+var_4], 3
.text:00001460                 lea     ecx, [ebp+var_184] ; this
.text:00001466                 call    ??1CHashMidBuf@@QAE@XZ ; CHashMidBuf::~CHashMidBuf(void)
.text:0000146B                 mov     byte ptr [ebp+var_4], 0
.text:0000146F                 lea     ecx, [ebp+var_168] ; this
.text:00001475                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:0000147A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001481                 lea     ecx, [ebp+var_B0] ; this
.text:00001487                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:0000148C                 mov     eax, [ebp+var_258]
.text:00001492                 jmp     loc_1964
.text:00001497 ; ---------------------------------------------------------------------------
.text:00001497
.text:00001497 loc_1497:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+6FDj
.text:00001497                 mov     byte ptr [ebp+var_4], 6
.text:0000149B                 lea     ecx, [ebp+var_1D8] ; this
.text:000014A1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000014A6                 mov     byte ptr [ebp+var_4], 5
.text:000014AA                 lea     ecx, [ebp+var_1B8] ; this
.text:000014B0                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000014B5                 mov     byte ptr [ebp+var_4], 4
.text:000014B9                 lea     ecx, [ebp+var_1A4]
.text:000014BF                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000014C4                 jmp     loc_11C5
.text:000014C9 ; ---------------------------------------------------------------------------
.text:000014C9
.text:000014C9 loc_14C9:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+69Fj
.text:000014C9                 mov     byte ptr [ebp+var_4], 6
.text:000014CD                 lea     ecx, [ebp+var_1D8] ; this
.text:000014D3                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000014D8
.text:000014D8 loc_14D8:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+55Aj
.text:000014D8                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+658j
.text:000014D8                 mov     esi, esp
.text:000014DA                 movzx   ecx, [ebp+var_1BD]
.text:000014E1                 push    ecx
.text:000014E2                 lea     ecx, [ebp+var_1B8]
.text:000014E8                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000014ED                 push    eax
.text:000014EE                 mov     edx, [ebp+arg_C]
.text:000014F1                 mov     eax, [edx]
.text:000014F3                 mov     ecx, [ebp+arg_C]
.text:000014F6                 mov     edx, [eax+24h]
.text:000014F9                 call    edx
.text:000014FB                 cmp     esi, esp
.text:000014FD                 call    __RTC_CheckEsp
.text:00001502                 mov     [ebp+var_1E4], eax
.text:00001508                 cmp     [ebp+var_1E4], 0
.text:0000150F                 jz      short loc_1576
.text:00001511                 mov     eax, [ebp+var_1E4]
.text:00001517                 mov     [ebp+var_25C], eax
.text:0000151D                 mov     byte ptr [ebp+var_4], 5
.text:00001521                 lea     ecx, [ebp+var_1B8] ; this
.text:00001527                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000152C                 mov     byte ptr [ebp+var_4], 4
.text:00001530                 lea     ecx, [ebp+var_1A4]
.text:00001536                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:0000153B                 mov     byte ptr [ebp+var_4], 3
.text:0000153F                 lea     ecx, [ebp+var_184] ; this
.text:00001545                 call    ??1CHashMidBuf@@QAE@XZ ; CHashMidBuf::~CHashMidBuf(void)
.text:0000154A                 mov     byte ptr [ebp+var_4], 0
.text:0000154E                 lea     ecx, [ebp+var_168] ; this
.text:00001554                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:00001559                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001560                 lea     ecx, [ebp+var_B0] ; this
.text:00001566                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:0000156B                 mov     eax, [ebp+var_25C]
.text:00001571                 jmp     loc_1964
.text:00001576 ; ---------------------------------------------------------------------------
.text:00001576
.text:00001576 loc_1576:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+7EBj
.text:00001576                 mov     [ebp+var_1EC], 0
.text:00001580                 mov     [ebp+var_1E8], 0
.text:0000158A                 lea     ecx, [ebp+var_168] ; this
.text:00001590                 call    ?InitForNewFile@CHashBundle@@UAEXXZ ; CHashBundle::InitForNewFile(void)
.text:00001595                 movzx   ecx, [ebp+var_1BD]
.text:0000159C                 test    ecx, ecx
.text:0000159E                 jnz     loc_1789
.text:000015A4                 mov     [ebp+var_1F0], 0
.text:000015AE                 jmp     short loc_15BF
.text:000015B0 ; ---------------------------------------------------------------------------
.text:000015B0
.text:000015B0 loc_15B0:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+A60j
.text:000015B0                 mov     edx, [ebp+var_1F0]
.text:000015B6                 add     edx, 1
.text:000015B9                 mov     [ebp+var_1F0], edx
.text:000015BF
.text:000015BF loc_15BF:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+88Aj
.text:000015BF                 mov     eax, [ebp+var_1F0]
.text:000015C5                 and     eax, 0FFh
.text:000015CA                 jnz     loc_1661
.text:000015D0                 mov     esi, esp
.text:000015D2                 lea     ecx, [ebp+var_194]
.text:000015D8                 push    ecx
.text:000015D9                 mov     edx, [ebp+arg_C]
.text:000015DC                 mov     eax, [edx]
.text:000015DE                 mov     ecx, [ebp+arg_C]
.text:000015E1                 mov     edx, [eax+18h]
.text:000015E4                 call    edx
.text:000015E6                 cmp     esi, esp
.text:000015E8                 call    __RTC_CheckEsp
.text:000015ED                 mov     [ebp+var_1F4], eax
.text:000015F3                 cmp     [ebp+var_1F4], 0
.text:000015FA                 jz      short loc_1661
.text:000015FC                 mov     eax, [ebp+var_1F4]
.text:00001602                 mov     [ebp+var_260], eax
.text:00001608                 mov     byte ptr [ebp+var_4], 5
.text:0000160C                 lea     ecx, [ebp+var_1B8] ; this
.text:00001612                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001617                 mov     byte ptr [ebp+var_4], 4
.text:0000161B                 lea     ecx, [ebp+var_1A4]
.text:00001621                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001626                 mov     byte ptr [ebp+var_4], 3
.text:0000162A                 lea     ecx, [ebp+var_184] ; this
.text:00001630                 call    ??1CHashMidBuf@@QAE@XZ ; CHashMidBuf::~CHashMidBuf(void)
.text:00001635                 mov     byte ptr [ebp+var_4], 0
.text:00001639                 lea     ecx, [ebp+var_168] ; this
.text:0000163F                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:00001644                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000164B                 lea     ecx, [ebp+var_B0] ; this
.text:00001651                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00001656                 mov     eax, [ebp+var_260]
.text:0000165C                 jmp     loc_1964
.text:00001661 ; ---------------------------------------------------------------------------
.text:00001661
.text:00001661 loc_1661:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+8A6j
.text:00001661                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+8D6j
.text:00001661                 lea     ecx, [ebp+var_1A4]
.text:00001667                 call    ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator->(void)
.text:0000166C                 mov     [ebp+var_28C], eax
.text:00001672                 mov     esi, esp
.text:00001674                 lea     ecx, [ebp+var_1FC]
.text:0000167A                 push    ecx
.text:0000167B                 push    8000h
.text:00001680                 lea     ecx, [ebp+var_184]
.text:00001686                 call    ??BCHashMidBuf@@QAEPAXXZ ; CHashMidBuf::operator void *(void)
.text:0000168B                 push    eax
.text:0000168C                 mov     edx, [ebp+var_28C]
.text:00001692                 push    edx
.text:00001693                 mov     eax, [ebp+var_28C]
.text:00001699                 mov     ecx, [eax]
.text:0000169B                 mov     edx, [ecx+0Ch]
.text:0000169E                 call    edx
.text:000016A0                 cmp     esi, esp
.text:000016A2                 call    __RTC_CheckEsp
.text:000016A7                 mov     [ebp+var_204], eax
.text:000016AD                 cmp     [ebp+var_204], 0
.text:000016B4                 jz      short loc_171B
.text:000016B6                 mov     eax, [ebp+var_204]
.text:000016BC                 mov     [ebp+var_264], eax
.text:000016C2                 mov     byte ptr [ebp+var_4], 5
.text:000016C6                 lea     ecx, [ebp+var_1B8] ; this
.text:000016CC                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000016D1                 mov     byte ptr [ebp+var_4], 4
.text:000016D5                 lea     ecx, [ebp+var_1A4]
.text:000016DB                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000016E0                 mov     byte ptr [ebp+var_4], 3
.text:000016E4                 lea     ecx, [ebp+var_184] ; this
.text:000016EA                 call    ??1CHashMidBuf@@QAE@XZ ; CHashMidBuf::~CHashMidBuf(void)
.text:000016EF                 mov     byte ptr [ebp+var_4], 0
.text:000016F3                 lea     ecx, [ebp+var_168] ; this
.text:000016F9                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:000016FE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001705                 lea     ecx, [ebp+var_B0] ; this
.text:0000170B                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00001710                 mov     eax, [ebp+var_264]
.text:00001716                 jmp     loc_1964
.text:0000171B ; ---------------------------------------------------------------------------
.text:0000171B
.text:0000171B loc_171B:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+990j
.text:0000171B                 cmp     [ebp+var_1FC], 0
.text:00001722                 jnz     short loc_1726
.text:00001724                 jmp     short loc_1789
.text:00001726 ; ---------------------------------------------------------------------------
.text:00001726
.text:00001726 loc_1726:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+9FEj
.text:00001726                 mov     ecx, [ebp+var_1FC]
.text:0000172C                 push    ecx             ; unsigned int
.text:0000172D                 lea     ecx, [ebp+var_184]
.text:00001733                 call    ??BCHashMidBuf@@QAEPAXXZ ; CHashMidBuf::operator void *(void)
.text:00001738                 push    eax             ; void *
.text:00001739                 lea     ecx, [ebp+var_168] ; this
.text:0000173F                 call    ?Update@CHashBundle@@UAEXPBXI@Z ; CHashBundle::Update(void const *,uint)
.text:00001744                 mov     edx, [ebp+var_1FC]
.text:0000174A                 xor     eax, eax
.text:0000174C                 add     edx, [ebp+var_1EC]
.text:00001752                 adc     eax, [ebp+var_1E8]
.text:00001758                 mov     [ebp+var_1EC], edx
.text:0000175E                 mov     [ebp+var_1E8], eax
.text:00001764                 mov     ecx, [ebp+var_1FC]
.text:0000176A                 xor     edx, edx
.text:0000176C                 add     ecx, [ebp+var_194]
.text:00001772                 adc     edx, [ebp+var_190]
.text:00001778                 mov     [ebp+var_194], ecx
.text:0000177E                 mov     [ebp+var_190], edx
.text:00001784                 jmp     loc_15B0
.text:00001789 ; ---------------------------------------------------------------------------
.text:00001789
.text:00001789 loc_1789:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+87Aj
.text:00001789                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+A00j
.text:00001789                 lea     eax, [ebp+var_1B8]
.text:0000178F                 push    eax             ; struct UString *
.text:00001790                 movzx   ecx, [ebp+var_1BE]
.text:00001797                 push    ecx             ; bool
.text:00001798                 movzx   edx, [ebp+var_1BD]
.text:0000179F                 push    edx             ; bool
.text:000017A0                 lea     ecx, [ebp+var_168] ; this
.text:000017A6                 call    ?Final@CHashBundle@@UAEX_N0ABVUString@@@Z ; CHashBundle::Final(bool,bool,UString const &)
.text:000017AB                 movzx   eax, [ebp+var_1BD]
.text:000017B2                 test    eax, eax
.text:000017B4                 setz    cl
.text:000017B7                 mov     esi, esp
.text:000017B9                 movzx   edx, cl
.text:000017BC                 push    edx
.text:000017BD                 lea     eax, [ebp+var_168]
.text:000017C3                 push    eax
.text:000017C4                 mov     ecx, [ebp+var_1E8]
.text:000017CA                 push    ecx
.text:000017CB                 mov     edx, [ebp+var_1EC]
.text:000017D1                 push    edx
.text:000017D2                 mov     eax, [ebp+arg_C]
.text:000017D5                 mov     edx, [eax]
.text:000017D7                 mov     ecx, [ebp+arg_C]
.text:000017DA                 mov     eax, [edx+2Ch]
.text:000017DD                 call    eax
.text:000017DF                 cmp     esi, esp
.text:000017E1                 call    __RTC_CheckEsp
.text:000017E6                 mov     [ebp+var_208], eax
.text:000017EC                 cmp     [ebp+var_208], 0
.text:000017F3                 jz      short loc_185A
.text:000017F5                 mov     ecx, [ebp+var_208]
.text:000017FB                 mov     [ebp+var_268], ecx
.text:00001801                 mov     byte ptr [ebp+var_4], 5
.text:00001805                 lea     ecx, [ebp+var_1B8] ; this
.text:0000180B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001810                 mov     byte ptr [ebp+var_4], 4
.text:00001814                 lea     ecx, [ebp+var_1A4]
.text:0000181A                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:0000181F                 mov     byte ptr [ebp+var_4], 3
.text:00001823                 lea     ecx, [ebp+var_184] ; this
.text:00001829                 call    ??1CHashMidBuf@@QAE@XZ ; CHashMidBuf::~CHashMidBuf(void)
.text:0000182E                 mov     byte ptr [ebp+var_4], 0
.text:00001832                 lea     ecx, [ebp+var_168] ; this
.text:00001838                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:0000183D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001844                 lea     ecx, [ebp+var_B0] ; this
.text:0000184A                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:0000184F                 mov     eax, [ebp+var_268]
.text:00001855                 jmp     loc_1964
.text:0000185A ; ---------------------------------------------------------------------------
.text:0000185A
.text:0000185A loc_185A:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+ACFj
.text:0000185A                 mov     esi, esp
.text:0000185C                 lea     edx, [ebp+var_194]
.text:00001862                 push    edx
.text:00001863                 mov     eax, [ebp+arg_C]
.text:00001866                 mov     edx, [eax]
.text:00001868                 mov     ecx, [ebp+arg_C]
.text:0000186B                 mov     eax, [edx+18h]
.text:0000186E                 call    eax
.text:00001870                 cmp     esi, esp
.text:00001872                 call    __RTC_CheckEsp
.text:00001877                 mov     [ebp+var_20C], eax
.text:0000187D                 cmp     [ebp+var_20C], 0
.text:00001884                 jz      short loc_18E8
.text:00001886                 mov     ecx, [ebp+var_20C]
.text:0000188C                 mov     [ebp+var_26C], ecx
.text:00001892                 mov     byte ptr [ebp+var_4], 5
.text:00001896                 lea     ecx, [ebp+var_1B8] ; this
.text:0000189C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000018A1                 mov     byte ptr [ebp+var_4], 4
.text:000018A5                 lea     ecx, [ebp+var_1A4]
.text:000018AB                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000018B0                 mov     byte ptr [ebp+var_4], 3
.text:000018B4                 lea     ecx, [ebp+var_184] ; this
.text:000018BA                 call    ??1CHashMidBuf@@QAE@XZ ; CHashMidBuf::~CHashMidBuf(void)
.text:000018BF                 mov     byte ptr [ebp+var_4], 0
.text:000018C3                 lea     ecx, [ebp+var_168] ; this
.text:000018C9                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:000018CE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000018D5                 lea     ecx, [ebp+var_B0] ; this
.text:000018DB                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:000018E0                 mov     eax, [ebp+var_26C]
.text:000018E6                 jmp     short loc_1964
.text:000018E8 ; ---------------------------------------------------------------------------
.text:000018E8
.text:000018E8 loc_18E8:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+B60j
.text:000018E8                 mov     byte ptr [ebp+var_4], 5
.text:000018EC                 lea     ecx, [ebp+var_1B8] ; this
.text:000018F2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000018F7                 mov     byte ptr [ebp+var_4], 4
.text:000018FB                 lea     ecx, [ebp+var_1A4]
.text:00001901                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001906                 jmp     loc_11C5
.text:0000190B ; ---------------------------------------------------------------------------
.text:0000190B
.text:0000190B loc_190B:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+4C1j
.text:0000190B                 mov     esi, esp
.text:0000190D                 lea     edx, [ebp+var_168]
.text:00001913                 push    edx
.text:00001914                 mov     eax, [ebp+arg_C]
.text:00001917                 mov     edx, [eax]
.text:00001919                 mov     ecx, [ebp+arg_C]
.text:0000191C                 mov     eax, [edx+30h]
.text:0000191F                 call    eax
.text:00001921                 cmp     esi, esp
.text:00001923                 call    __RTC_CheckEsp
.text:00001928                 mov     [ebp+var_270], eax
.text:0000192E                 mov     byte ptr [ebp+var_4], 3
.text:00001932                 lea     ecx, [ebp+var_184] ; this
.text:00001938                 call    ??1CHashMidBuf@@QAE@XZ ; CHashMidBuf::~CHashMidBuf(void)
.text:0000193D                 mov     byte ptr [ebp+var_4], 0
.text:00001941                 lea     ecx, [ebp+var_168] ; this
.text:00001947                 call    ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text:0000194C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001953                 lea     ecx, [ebp+var_B0] ; this
.text:00001959                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:0000195E                 mov     eax, [ebp+var_270]
.text:00001964
.text:00001964 loc_1964:                               ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+143j
.text:00001964                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+1EBj ...
.text:00001964                 push    edx
.text:00001965                 mov     ecx, ebp
.text:00001967                 push    eax
.text:00001968                 lea     edx, $LN61
.text:0000196E                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001973                 pop     eax
.text:00001974                 pop     edx
.text:00001975                 mov     ecx, [ebp+var_C]
.text:00001978                 mov     large fs:0, ecx
.text:0000197F                 pop     ecx
.text:00001980                 pop     edi
.text:00001981                 pop     esi
.text:00001982                 add     esp, 28Ch
.text:00001988                 cmp     ebp, esp
.text:0000198A                 call    __RTC_CheckEsp
.text:0000198F                 mov     esp, ebp
.text:00001991                 pop     ebp
.text:00001992                 retn    10h
.text:00001992 ?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z endp ; sp-analysis failed
.text:00001992
.text:00001992 ; ---------------------------------------------------------------------------
.text:00001995                 align 4
.text:00001998 $LN61           dd 9                    ; DATA XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+C44o
.text:0000199C                 dd offset $LN60
.text:000019A0 $LN60           dd 0FFFFFF50h, 0A0h     ; DATA XREF: .text:0000199Co
.text:000019A8                 dd offset $LN50         ; "dirItems"
.text:000019AC                 dd 0FFFFFEF8h, 50h
.text:000019B4                 dd offset $LN51         ; "di"
.text:000019B8                 dd 0FFFFFE98h, 48h
.text:000019C0                 dd offset $LN52         ; "hb"
.text:000019C4                 dd 0FFFFFE7Ch, 4
.text:000019CC                 dd offset $LN53         ; "buf"
.text:000019D0                 dd 0FFFFFE6Ch, 8
.text:000019D8                 dd offset $LN54         ; "completeValue"
.text:000019DC                 dd 0FFFFFE5Ch, 4
.text:000019E4                 dd offset $LN55         ; "inStream"
.text:000019E8                 dd 0FFFFFE48h, 0Ch
.text:000019F0                 dd offset $LN56         ; "path"
.text:000019F4                 dd 0FFFFFE28h, 0Ch
.text:000019FC                 dd offset $LN57         ; "phyPath"
.text:00001A00                 dd 0FFFFFE04h, 4
.text:00001A08                 dd offset $LN58         ; "size"
.text:00001A0C $LN58           db 'size',0             ; DATA XREF: .text:00001A08o
.text:00001A11 $LN57           db 'phyPath',0          ; DATA XREF: .text:000019FCo
.text:00001A19 $LN56           db 'path',0             ; DATA XREF: .text:000019F0o
.text:00001A1E $LN55           db 'inStream',0         ; DATA XREF: .text:000019E4o
.text:00001A27 $LN54           db 'completeValue',0    ; DATA XREF: .text:000019D8o
.text:00001A35 $LN53           db 'buf',0              ; DATA XREF: .text:000019CCo
.text:00001A39 $LN52           db 'hb',0               ; DATA XREF: .text:000019C0o
.text:00001A3C $LN51           db 'di',0               ; DATA XREF: .text:000019B4o
.text:00001A3F $LN50           db 'dirItems',0         ; DATA XREF: .text:000019A8o
.text:00001A48                 db 0Ch dup(0CCh)
.text:00001A54
.text:00001A54 ; =============== S U B R O U T I N E =======================================
.text:00001A54
.text:00001A54 ; Attributes: bp-based frame
.text:00001A54
.text:00001A54 ; void __stdcall AddHashHexToString(char *, const unsigned __int8 *, unsigned int)
.text:00001A54                 public ?AddHashHexToString@@YGXPADPBEI@Z
.text:00001A54 ?AddHashHexToString@@YGXPADPBEI@Z proc near
.text:00001A54
.text:00001A54 var_10          = dword ptr -10h
.text:00001A54 var_C           = dword ptr -0Ch
.text:00001A54 var_8           = dword ptr -8
.text:00001A54 var_4           = dword ptr -4
.text:00001A54 arg_0           = dword ptr  8
.text:00001A54 arg_4           = dword ptr  0Ch
.text:00001A54 arg_8           = dword ptr  10h
.text:00001A54
.text:00001A54                 push    ebp
.text:00001A55                 mov     ebp, esp
.text:00001A57                 sub     esp, 10h
.text:00001A5A                 mov     eax, 0CCCCCCCCh
.text:00001A5F                 mov     [ebp+var_10], eax
.text:00001A62                 mov     [ebp+var_C], eax
.text:00001A65                 mov     [ebp+var_8], eax
.text:00001A68                 mov     [ebp+var_4], eax
.text:00001A6B                 mov     eax, [ebp+arg_8]
.text:00001A6E                 mov     ecx, [ebp+arg_0]
.text:00001A71                 mov     byte ptr [ecx+eax*2], 0
.text:00001A75                 cmp     [ebp+arg_4], 0
.text:00001A79                 jnz     short loc_1AAF
.text:00001A7B                 mov     [ebp+var_4], 0
.text:00001A82                 jmp     short loc_1A8D
.text:00001A84 ; ---------------------------------------------------------------------------
.text:00001A84
.text:00001A84 loc_1A84:                               ; CODE XREF: AddHashHexToString(char *,uchar const *,uint)+57j
.text:00001A84                 mov     edx, [ebp+var_4]
.text:00001A87                 add     edx, 1
.text:00001A8A                 mov     [ebp+var_4], edx
.text:00001A8D
.text:00001A8D loc_1A8D:                               ; CODE XREF: AddHashHexToString(char *,uchar const *,uint)+2Ej
.text:00001A8D                 mov     eax, [ebp+var_4]
.text:00001A90                 cmp     eax, [ebp+arg_8]
.text:00001A93                 jnb     short loc_1AAD
.text:00001A95                 mov     ecx, [ebp+arg_0]
.text:00001A98                 mov     byte ptr [ecx], 20h ; ' '
.text:00001A9B                 mov     edx, [ebp+arg_0]
.text:00001A9E                 mov     byte ptr [edx+1], 20h ; ' '
.text:00001AA2                 mov     eax, [ebp+arg_0]
.text:00001AA5                 add     eax, 2
.text:00001AA8                 mov     [ebp+arg_0], eax
.text:00001AAB                 jmp     short loc_1A84
.text:00001AAD ; ---------------------------------------------------------------------------
.text:00001AAD
.text:00001AAD loc_1AAD:                               ; CODE XREF: AddHashHexToString(char *,uchar const *,uint)+3Fj
.text:00001AAD                 jmp     short loc_1B27
.text:00001AAF ; ---------------------------------------------------------------------------
.text:00001AAF
.text:00001AAF loc_1AAF:                               ; CODE XREF: AddHashHexToString(char *,uchar const *,uint)+25j
.text:00001AAF                 mov     [ebp+var_8], 2
.text:00001AB6                 cmp     [ebp+arg_8], 8
.text:00001ABA                 ja      short loc_1AD0
.text:00001ABC                 mov     [ebp+var_8], 0FFFFFFFEh
.text:00001AC3                 mov     ecx, [ebp+arg_8]
.text:00001AC6                 mov     edx, [ebp+arg_0]
.text:00001AC9                 lea     eax, [edx+ecx*2-2]
.text:00001ACD                 mov     [ebp+arg_0], eax
.text:00001AD0
.text:00001AD0 loc_1AD0:                               ; CODE XREF: AddHashHexToString(char *,uchar const *,uint)+66j
.text:00001AD0                 mov     [ebp+var_C], 0
.text:00001AD7                 jmp     short loc_1AE2
.text:00001AD9 ; ---------------------------------------------------------------------------
.text:00001AD9
.text:00001AD9 loc_1AD9:                               ; CODE XREF: AddHashHexToString(char *,uchar const *,uint)+D1j
.text:00001AD9                 mov     ecx, [ebp+var_C]
.text:00001ADC                 add     ecx, 1
.text:00001ADF                 mov     [ebp+var_C], ecx
.text:00001AE2
.text:00001AE2 loc_1AE2:                               ; CODE XREF: AddHashHexToString(char *,uchar const *,uint)+83j
.text:00001AE2                 mov     edx, [ebp+var_C]
.text:00001AE5                 cmp     edx, [ebp+arg_8]
.text:00001AE8                 jnb     short loc_1B27
.text:00001AEA                 mov     eax, [ebp+arg_4]
.text:00001AED                 add     eax, [ebp+var_C]
.text:00001AF0                 movzx   ecx, byte ptr [eax]
.text:00001AF3                 mov     [ebp+var_10], ecx
.text:00001AF6                 mov     edx, [ebp+var_10]
.text:00001AF9                 shr     edx, 4
.text:00001AFC                 and     edx, 0Fh
.text:00001AFF                 push    edx
.text:00001B00                 call    ?GetHex@@YGDI@Z ; GetHex(uint)
.text:00001B05                 mov     ecx, [ebp+arg_0]
.text:00001B08                 mov     [ecx], al
.text:00001B0A                 mov     edx, [ebp+var_10]
.text:00001B0D                 and     edx, 0Fh
.text:00001B10                 push    edx
.text:00001B11                 call    ?GetHex@@YGDI@Z ; GetHex(uint)
.text:00001B16                 mov     ecx, [ebp+arg_0]
.text:00001B19                 mov     [ecx+1], al
.text:00001B1C                 mov     edx, [ebp+arg_0]
.text:00001B1F                 add     edx, [ebp+var_8]
.text:00001B22                 mov     [ebp+arg_0], edx
.text:00001B25                 jmp     short loc_1AD9
.text:00001B27 ; ---------------------------------------------------------------------------
.text:00001B27
.text:00001B27 loc_1B27:                               ; CODE XREF: AddHashHexToString(char *,uchar const *,uint):loc_1AADj
.text:00001B27                                         ; AddHashHexToString(char *,uchar const *,uint)+94j
.text:00001B27                 add     esp, 10h
.text:00001B2A                 cmp     ebp, esp
.text:00001B2C                 call    __RTC_CheckEsp
.text:00001B31                 mov     esp, ebp
.text:00001B33                 pop     ebp
.text:00001B34                 retn    0Ch
.text:00001B34 ?AddHashHexToString@@YGXPADPBEI@Z endp
.text:00001B34
.text:00001B34 ; ---------------------------------------------------------------------------
.text:00001B37                 db 0Dh dup(0CCh)
.text:00001B44
.text:00001B44 ; =============== S U B R O U T I N E =======================================
.text:00001B44
.text:00001B44 ; Attributes: bp-based frame
.text:00001B44
.text:00001B44 ; char __stdcall GetHex(unsigned int)
.text:00001B44 ?GetHex@@YGDI@Z proc near               ; CODE XREF: AddHashHexToString(char *,uchar const *,uint)+ACp
.text:00001B44                                         ; AddHashHexToString(char *,uchar const *,uint)+BDp
.text:00001B44
.text:00001B44 var_4           = dword ptr -4
.text:00001B44 arg_0           = dword ptr  8
.text:00001B44
.text:00001B44                 push    ebp
.text:00001B45                 mov     ebp, esp
.text:00001B47                 push    ecx
.text:00001B48                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001B4F                 cmp     [ebp+arg_0], 0Ah
.text:00001B53                 jnb     short loc_1B60
.text:00001B55                 mov     eax, [ebp+arg_0]
.text:00001B58                 add     eax, 30h ; '0'
.text:00001B5B                 mov     [ebp+var_4], eax
.text:00001B5E                 jmp     short loc_1B69
.text:00001B60 ; ---------------------------------------------------------------------------
.text:00001B60
.text:00001B60 loc_1B60:                               ; CODE XREF: GetHex(uint)+Fj
.text:00001B60                 mov     ecx, [ebp+arg_0]
.text:00001B63                 add     ecx, 37h ; '7'
.text:00001B66                 mov     [ebp+var_4], ecx
.text:00001B69
.text:00001B69 loc_1B69:                               ; CODE XREF: GetHex(uint)+1Aj
.text:00001B69                 mov     al, byte ptr [ebp+var_4]
.text:00001B6C                 mov     esp, ebp
.text:00001B6E                 pop     ebp
.text:00001B6F                 retn    4
.text:00001B6F ?GetHex@@YGDI@Z endp
.text:00001B6F
.text:00001B6F ; ---------------------------------------------------------------------------
.text:00001B72                 align 4
.text:00001B72 _text           ends
.text:00001B72
.text$x:00001B74 ; ===========================================================================
.text$x:00001B74
.text$x:00001B74 ; Segment type: Pure code
.text$x:00001B74 ; Segment permissions: Read/Execute
.text$x:00001B74 _text$x         segment para public 'CODE' use32
.text$x:00001B74                 assume cs:_text$x
.text$x:00001B74                 ;org 1B74h
.text$x:00001B74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001B74
.text$x:00001B74 ; =============== S U B R O U T I N E =======================================
.text$x:00001B74
.text$x:00001B74
.text$x:00001B74 __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$0 proc near
.text$x:00001B74                                         ; DATA XREF: .xdata$x:00001CC0o
.text$x:00001B74                 lea     ecx, [ebp-20h]
.text$x:00001B77                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00001B77 __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$0 endp
.text$x:00001B77
.text$x:00001B7C
.text$x:00001B7C ; =============== S U B R O U T I N E =======================================
.text$x:00001B7C
.text$x:00001B7C
.text$x:00001B7C __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$1 proc near
.text$x:00001B7C                                         ; DATA XREF: .xdata$x:00001CC8o
.text$x:00001B7C                 lea     ecx, [ebp-34h]  ; this
.text$x:00001B7F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001B7F __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$1 endp
.text$x:00001B7F
.text$x:00001B84
.text$x:00001B84 ; =============== S U B R O U T I N E =======================================
.text$x:00001B84
.text$x:00001B84
.text$x:00001B84 __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$2 proc near
.text$x:00001B84                                         ; DATA XREF: .xdata$x:00001CD0o
.text$x:00001B84                 lea     ecx, [ebp-48h]
.text$x:00001B87                 jmp     ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text$x:00001B87 __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$2 endp
.text$x:00001B87
.text$x:00001B8C
.text$x:00001B8C ; =============== S U B R O U T I N E =======================================
.text$x:00001B8C
.text$x:00001B8C
.text$x:00001B8C __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$3 proc near
.text$x:00001B8C                                         ; DATA XREF: .xdata$x:00001CD8o
.text$x:00001B8C                 lea     ecx, [ebp-5Ch]
.text$x:00001B8F                 jmp     ??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ ; CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)
.text$x:00001B8F __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$3 endp
.text$x:00001B8F
.text$x:00001B94
.text$x:00001B94 ; =============== S U B R O U T I N E =======================================
.text$x:00001B94
.text$x:00001B94
.text$x:00001B94 __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$4 proc near
.text$x:00001B94                                         ; DATA XREF: .xdata$x:00001CE0o
.text$x:00001B94                 lea     ecx, [ebp-8Ch]  ; this
.text$x:00001B9A                 jmp     ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text$x:00001B9A __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$4 endp
.text$x:00001B9A
.text$x:00001B9F
.text$x:00001B9F ; =============== S U B R O U T I N E =======================================
.text$x:00001B9F
.text$x:00001B9F
.text$x:00001B9F __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$5 proc near
.text$x:00001B9F                                         ; DATA XREF: .xdata$x:00001CE8o
.text$x:00001B9F                 lea     ecx, [ebp-0A4h]
.text$x:00001BA5                 jmp     ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text$x:00001BA5 __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$5 endp
.text$x:00001BA5
.text$x:00001BAA
.text$x:00001BAA ; =============== S U B R O U T I N E =======================================
.text$x:00001BAA
.text$x:00001BAA
.text$x:00001BAA __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$6 proc near
.text$x:00001BAA                                         ; DATA XREF: .xdata$x:00001CF0o
.text$x:00001BAA                 lea     ecx, [ebp-0CCh]
.text$x:00001BB0                 jmp     ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text$x:00001BB0 __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$6 endp
.text$x:00001BB0
.text$x:00001BB5
.text$x:00001BB5 ; =============== S U B R O U T I N E =======================================
.text$x:00001BB5
.text$x:00001BB5
.text$x:00001BB5 __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$7 proc near
.text$x:00001BB5                                         ; DATA XREF: .xdata$x:00001CF8o
.text$x:00001BB5                 lea     ecx, [ebp-0E0h] ; this
.text$x:00001BBB                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00001BBB __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$7 endp
.text$x:00001BBB
.text$x:00001BC0
.text$x:00001BC0 ; =============== S U B R O U T I N E =======================================
.text$x:00001BC0
.text$x:00001BC0
.text$x:00001BC0 __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$8 proc near
.text$x:00001BC0                                         ; DATA XREF: .xdata$x:00001D00o
.text$x:00001BC0                 lea     ecx, [ebp-0F4h]
.text$x:00001BC6                 jmp     ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text$x:00001BC6 __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$8 endp
.text$x:00001BC6
.text$x:00001BCB
.text$x:00001BCB ; =============== S U B R O U T I N E =======================================
.text$x:00001BCB
.text$x:00001BCB
.text$x:00001BCB __ehhandler$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z proc near
.text$x:00001BCB                                         ; DATA XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+5o
.text$x:00001BCB
.text$x:00001BCB arg_4           = dword ptr  8
.text$x:00001BCB
.text$x:00001BCB                 mov     edx, [esp+arg_4]
.text$x:00001BCF                 lea     eax, [edx+0Ch]
.text$x:00001BD2                 mov     ecx, [edx-128h]
.text$x:00001BD8                 xor     ecx, eax
.text$x:00001BDA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001BDF                 mov     eax, offset __ehfuncinfo$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z
.text$x:00001BE4                 jmp     ___CxxFrameHandler3
.text$x:00001BE4 __ehhandler$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z endp
.text$x:00001BE4
.text$x:00001BE9
.text$x:00001BE9 ; =============== S U B R O U T I N E =======================================
.text$x:00001BE9
.text$x:00001BE9
.text$x:00001BE9 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$0 proc near
.text$x:00001BE9                                         ; DATA XREF: .xdata$x:00001D2Co
.text$x:00001BE9                 lea     ecx, [ebp-0B0h] ; this
.text$x:00001BEF                 jmp     ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text$x:00001BEF __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$0 endp
.text$x:00001BEF
.text$x:00001BF4
.text$x:00001BF4 ; =============== S U B R O U T I N E =======================================
.text$x:00001BF4
.text$x:00001BF4
.text$x:00001BF4 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$1 proc near
.text$x:00001BF4                                         ; DATA XREF: .xdata$x:00001D34o
.text$x:00001BF4                 lea     ecx, [ebp-108h] ; this
.text$x:00001BFA                 jmp     ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text$x:00001BFA __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$1 endp
.text$x:00001BFA
.text$x:00001BFF
.text$x:00001BFF ; =============== S U B R O U T I N E =======================================
.text$x:00001BFF
.text$x:00001BFF
.text$x:00001BFF __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$2 proc near
.text$x:00001BFF                                         ; DATA XREF: .xdata$x:00001D3Co
.text$x:00001BFF                 lea     ecx, [ebp-21Ch] ; this
.text$x:00001C05                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001C05 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$2 endp
.text$x:00001C05
.text$x:00001C0A
.text$x:00001C0A ; =============== S U B R O U T I N E =======================================
.text$x:00001C0A
.text$x:00001C0A
.text$x:00001C0A __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$3 proc near
.text$x:00001C0A                                         ; DATA XREF: .xdata$x:00001D44o
.text$x:00001C0A                 lea     ecx, [ebp-168h] ; this
.text$x:00001C10                 jmp     ??1CHashBundle@@QAE@XZ ; CHashBundle::~CHashBundle(void)
.text$x:00001C10 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$3 endp
.text$x:00001C10
.text$x:00001C15
.text$x:00001C15 ; =============== S U B R O U T I N E =======================================
.text$x:00001C15
.text$x:00001C15
.text$x:00001C15 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$4 proc near
.text$x:00001C15                                         ; DATA XREF: .xdata$x:00001D4Co
.text$x:00001C15                 lea     ecx, [ebp-184h] ; this
.text$x:00001C1B                 jmp     ??1CHashMidBuf@@QAE@XZ ; CHashMidBuf::~CHashMidBuf(void)
.text$x:00001C1B __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$4 endp
.text$x:00001C1B
.text$x:00001C20
.text$x:00001C20 ; =============== S U B R O U T I N E =======================================
.text$x:00001C20
.text$x:00001C20
.text$x:00001C20 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$5 proc near
.text$x:00001C20                                         ; DATA XREF: .xdata$x:00001D54o
.text$x:00001C20                 lea     ecx, [ebp-1A4h]
.text$x:00001C26                 jmp     ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text$x:00001C26 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$5 endp
.text$x:00001C26
.text$x:00001C2B
.text$x:00001C2B ; =============== S U B R O U T I N E =======================================
.text$x:00001C2B
.text$x:00001C2B
.text$x:00001C2B __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$6 proc near
.text$x:00001C2B                                         ; DATA XREF: .xdata$x:00001D5Co
.text$x:00001C2B                 lea     ecx, [ebp-1B8h] ; this
.text$x:00001C31                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001C31 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$6 endp
.text$x:00001C31
.text$x:00001C36
.text$x:00001C36 ; =============== S U B R O U T I N E =======================================
.text$x:00001C36
.text$x:00001C36
.text$x:00001C36 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$7 proc near
.text$x:00001C36                                         ; DATA XREF: .xdata$x:00001D64o
.text$x:00001C36                 mov     eax, [ebp-240h]
.text$x:00001C3C                 push    eax             ; void *
.text$x:00001C3D                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001C42                 pop     ecx
.text$x:00001C43                 retn
.text$x:00001C43 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$7 endp
.text$x:00001C43
.text$x:00001C44
.text$x:00001C44 ; =============== S U B R O U T I N E =======================================
.text$x:00001C44
.text$x:00001C44
.text$x:00001C44 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$8 proc near
.text$x:00001C44                                         ; DATA XREF: .xdata$x:00001D6Co
.text$x:00001C44                 mov     eax, [ebp-248h]
.text$x:00001C4A                 push    eax             ; void *
.text$x:00001C4B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001C50                 pop     ecx
.text$x:00001C51                 retn
.text$x:00001C51 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$8 endp
.text$x:00001C51
.text$x:00001C52
.text$x:00001C52 ; =============== S U B R O U T I N E =======================================
.text$x:00001C52
.text$x:00001C52
.text$x:00001C52 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$9 proc near
.text$x:00001C52                                         ; DATA XREF: .xdata$x:00001D74o
.text$x:00001C52                 lea     ecx, [ebp-254h] ; this
.text$x:00001C58                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001C58 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$9 endp
.text$x:00001C58
.text$x:00001C5D
.text$x:00001C5D ; =============== S U B R O U T I N E =======================================
.text$x:00001C5D
.text$x:00001C5D
.text$x:00001C5D __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$10 proc near
.text$x:00001C5D                                         ; DATA XREF: .xdata$x:00001D7Co
.text$x:00001C5D                 lea     ecx, [ebp-1D8h] ; this
.text$x:00001C63                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001C63 __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$10 endp
.text$x:00001C63
.text$x:00001C68
.text$x:00001C68 ; =============== S U B R O U T I N E =======================================
.text$x:00001C68
.text$x:00001C68
.text$x:00001C68 __ehhandler$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z proc near
.text$x:00001C68                                         ; DATA XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+5o
.text$x:00001C68
.text$x:00001C68 arg_4           = dword ptr  8
.text$x:00001C68
.text$x:00001C68                 mov     edx, [esp+arg_4]
.text$x:00001C6C                 lea     eax, [edx+0Ch]
.text$x:00001C6F                 mov     ecx, [edx-28Ch]
.text$x:00001C75                 xor     ecx, eax
.text$x:00001C77                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C7C                 mov     eax, offset __ehfuncinfo$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z
.text$x:00001C81                 jmp     ___CxxFrameHandler3
.text$x:00001C81 __ehhandler$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z endp
.text$x:00001C81
.text$x:00001C81 ; ---------------------------------------------------------------------------
.text$x:00001C86                 align 4
.text$x:00001C86 _text$x         ends
.text$x:00001C86
.xdata$x:00001C88 ; ===========================================================================
.xdata$x:00001C88
.xdata$x:00001C88 ; Segment type: Pure data
.xdata$x:00001C88 ; Segment permissions: Read
.xdata$x:00001C88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C88                 assume cs:_xdata$x
.xdata$x:00001C88                 ;org 1C88h
.xdata$x:00001C88 ; COMDAT (pick any)
.xdata$x:00001C88                 public __TI2PAD
.xdata$x:00001C88 __TI2PAD        db    0                 ; DATA XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+40Do
.xdata$x:00001C89                 db    0
.xdata$x:00001C8A                 db    0
.xdata$x:00001C8B                 db    0
.xdata$x:00001C8C                 db    0
.xdata$x:00001C8D                 db    0
.xdata$x:00001C8E                 db    0
.xdata$x:00001C8F                 db    0
.xdata$x:00001C90                 db    0
.xdata$x:00001C91                 db    0
.xdata$x:00001C92                 db    0
.xdata$x:00001C93                 db    0
.xdata$x:00001C94                 dd offset __CTA2PAD
.xdata$x:00001C94 _xdata$x        ends
.xdata$x:00001C94
.xdata$x:00001C98 ; ===========================================================================
.xdata$x:00001C98
.xdata$x:00001C98 ; Segment type: Pure data
.xdata$x:00001C98 ; Segment permissions: Read
.xdata$x:00001C98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C98                 assume cs:_xdata$x
.xdata$x:00001C98                 ;org 1C98h
.xdata$x:00001C98 __ehfuncinfo$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z db  22h ; "
.xdata$x:00001C98                                         ; DATA XREF: __ehhandler$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z+14o
.xdata$x:00001C99                 db    5
.xdata$x:00001C9A                 db  93h ; 
.xdata$x:00001C9B                 db  19h
.xdata$x:00001C9C                 db    9
.xdata$x:00001C9D                 db    0
.xdata$x:00001C9E                 db    0
.xdata$x:00001C9F                 db    0
.xdata$x:00001CA0                 dd offset __unwindtable$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z
.xdata$x:00001CA4                 db    0
.xdata$x:00001CA5                 db    0
.xdata$x:00001CA6                 db    0
.xdata$x:00001CA7                 db    0
.xdata$x:00001CA8                 db    0
.xdata$x:00001CA9                 db    0
.xdata$x:00001CAA                 db    0
.xdata$x:00001CAB                 db    0
.xdata$x:00001CAC                 db    0
.xdata$x:00001CAD                 db    0
.xdata$x:00001CAE                 db    0
.xdata$x:00001CAF                 db    0
.xdata$x:00001CB0                 db    0
.xdata$x:00001CB1                 db    0
.xdata$x:00001CB2                 db    0
.xdata$x:00001CB3                 db    0
.xdata$x:00001CB4                 db    0
.xdata$x:00001CB5                 db    0
.xdata$x:00001CB6                 db    0
.xdata$x:00001CB7                 db    0
.xdata$x:00001CB8                 db    1
.xdata$x:00001CB9                 db    0
.xdata$x:00001CBA                 db    0
.xdata$x:00001CBB                 db    0
.xdata$x:00001CBC __unwindtable$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z db 0FFh
.xdata$x:00001CBC                                         ; DATA XREF: .xdata$x:00001CA0o
.xdata$x:00001CBD                 db 0FFh
.xdata$x:00001CBE                 db 0FFh
.xdata$x:00001CBF                 db 0FFh
.xdata$x:00001CC0                 dd offset __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$0
.xdata$x:00001CC4                 align 8
.xdata$x:00001CC8                 dd offset __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$1
.xdata$x:00001CCC                 align 10h
.xdata$x:00001CD0                 dd offset __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$2
.xdata$x:00001CD4                 db    2
.xdata$x:00001CD5                 db    0
.xdata$x:00001CD6                 db    0
.xdata$x:00001CD7                 db    0
.xdata$x:00001CD8                 dd offset __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$3
.xdata$x:00001CDC                 db    3
.xdata$x:00001CDD                 db    0
.xdata$x:00001CDE                 db    0
.xdata$x:00001CDF                 db    0
.xdata$x:00001CE0                 dd offset __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$4
.xdata$x:00001CE4                 db    4
.xdata$x:00001CE5                 db    0
.xdata$x:00001CE6                 db    0
.xdata$x:00001CE7                 db    0
.xdata$x:00001CE8                 dd offset __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$5
.xdata$x:00001CEC                 db    3
.xdata$x:00001CED                 db    0
.xdata$x:00001CEE                 db    0
.xdata$x:00001CEF                 db    0
.xdata$x:00001CF0                 dd offset __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$6
.xdata$x:00001CF4                 db    6
.xdata$x:00001CF5                 db    0
.xdata$x:00001CF6                 db    0
.xdata$x:00001CF7                 db    0
.xdata$x:00001CF8                 dd offset __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$7
.xdata$x:00001CFC                 db    7
.xdata$x:00001CFD                 db    0
.xdata$x:00001CFE                 db    0
.xdata$x:00001CFF                 db    0
.xdata$x:00001D00                 dd offset __unwindfunclet$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z$8
.xdata$x:00001D04 __ehfuncinfo$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z db  22h ; "
.xdata$x:00001D04                                         ; DATA XREF: __ehhandler$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z+14o
.xdata$x:00001D05                 db    5
.xdata$x:00001D06                 db  93h ; 
.xdata$x:00001D07                 db  19h
.xdata$x:00001D08                 db  0Bh
.xdata$x:00001D09                 db    0
.xdata$x:00001D0A                 db    0
.xdata$x:00001D0B                 db    0
.xdata$x:00001D0C                 dd offset __unwindtable$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z
.xdata$x:00001D10                 db    0
.xdata$x:00001D11                 db    0
.xdata$x:00001D12                 db    0
.xdata$x:00001D13                 db    0
.xdata$x:00001D14                 db    0
.xdata$x:00001D15                 db    0
.xdata$x:00001D16                 db    0
.xdata$x:00001D17                 db    0
.xdata$x:00001D18                 db    0
.xdata$x:00001D19                 db    0
.xdata$x:00001D1A                 db    0
.xdata$x:00001D1B                 db    0
.xdata$x:00001D1C                 db    0
.xdata$x:00001D1D                 db    0
.xdata$x:00001D1E                 db    0
.xdata$x:00001D1F                 db    0
.xdata$x:00001D20                 db    0
.xdata$x:00001D21                 db    0
.xdata$x:00001D22                 db    0
.xdata$x:00001D23                 db    0
.xdata$x:00001D24                 db    1
.xdata$x:00001D25                 db    0
.xdata$x:00001D26                 db    0
.xdata$x:00001D27                 db    0
.xdata$x:00001D28 __unwindtable$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z db 0FFh
.xdata$x:00001D28                                         ; DATA XREF: .xdata$x:00001D0Co
.xdata$x:00001D29                 db 0FFh
.xdata$x:00001D2A                 db 0FFh
.xdata$x:00001D2B                 db 0FFh
.xdata$x:00001D2C                 dd offset __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$0
.xdata$x:00001D30                 db    0
.xdata$x:00001D31                 db    0
.xdata$x:00001D32                 db    0
.xdata$x:00001D33                 db    0
.xdata$x:00001D34                 dd offset __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$1
.xdata$x:00001D38                 db    0
.xdata$x:00001D39                 db    0
.xdata$x:00001D3A                 db    0
.xdata$x:00001D3B                 db    0
.xdata$x:00001D3C                 dd offset __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$2
.xdata$x:00001D40                 db    0
.xdata$x:00001D41                 db    0
.xdata$x:00001D42                 db    0
.xdata$x:00001D43                 db    0
.xdata$x:00001D44                 dd offset __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$3
.xdata$x:00001D48                 db    3
.xdata$x:00001D49                 db    0
.xdata$x:00001D4A                 db    0
.xdata$x:00001D4B                 db    0
.xdata$x:00001D4C                 dd offset __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$4
.xdata$x:00001D50                 db    4
.xdata$x:00001D51                 db    0
.xdata$x:00001D52                 db    0
.xdata$x:00001D53                 db    0
.xdata$x:00001D54                 dd offset __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$5
.xdata$x:00001D58                 db    5
.xdata$x:00001D59                 db    0
.xdata$x:00001D5A                 db    0
.xdata$x:00001D5B                 db    0
.xdata$x:00001D5C                 dd offset __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$6
.xdata$x:00001D60                 db    6
.xdata$x:00001D61                 db    0
.xdata$x:00001D62                 db    0
.xdata$x:00001D63                 db    0
.xdata$x:00001D64                 dd offset __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$7
.xdata$x:00001D68                 db    6
.xdata$x:00001D69                 db    0
.xdata$x:00001D6A                 db    0
.xdata$x:00001D6B                 db    0
.xdata$x:00001D6C                 dd offset __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$8
.xdata$x:00001D70                 db    6
.xdata$x:00001D71                 db    0
.xdata$x:00001D72                 db    0
.xdata$x:00001D73                 db    0
.xdata$x:00001D74                 dd offset __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$9
.xdata$x:00001D78                 db    6
.xdata$x:00001D79                 db    0
.xdata$x:00001D7A                 db    0
.xdata$x:00001D7B                 db    0
.xdata$x:00001D7C                 dd offset __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$10
.xdata$x:00001D7C _xdata$x        ends
.xdata$x:00001D7C
.rtc$TMZ:00001D80 ; ===========================================================================
.rtc$TMZ:00001D80
.rtc$TMZ:00001D80 ; Segment type: Pure data
.rtc$TMZ:00001D80 ; Segment permissions: Read
.rtc$TMZ:00001D80 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00001D80                 assume cs:_rtc$TMZ
.rtc$TMZ:00001D80                 ;org 1D80h
.rtc$TMZ:00001D80 ; COMDAT (pick any)
.rtc$TMZ:00001D80 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00001D80 _rtc$TMZ        ends
.rtc$TMZ:00001D80
.rtc$IMZ:00001D84 ; ===========================================================================
.rtc$IMZ:00001D84
.rtc$IMZ:00001D84 ; Segment type: Pure data
.rtc$IMZ:00001D84 ; Segment permissions: Read
.rtc$IMZ:00001D84 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00001D84                 assume cs:_rtc$IMZ
.rtc$IMZ:00001D84                 ;org 1D84h
.rtc$IMZ:00001D84 ; COMDAT (pick any)
.rtc$IMZ:00001D84 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00001D84 _rtc$IMZ        ends
.rtc$IMZ:00001D84
.xdata$x:00001D88 ; ===========================================================================
.xdata$x:00001D88
.xdata$x:00001D88 ; Segment type: Pure data
.xdata$x:00001D88 ; Segment permissions: Read
.xdata$x:00001D88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D88                 assume cs:_xdata$x
.xdata$x:00001D88                 ;org 1D88h
.xdata$x:00001D88 ; COMDAT (pick any)
.xdata$x:00001D88                 public __CTA2PAD
.xdata$x:00001D88 __CTA2PAD       db    2                 ; DATA XREF: .xdata$x:00001C94o
.xdata$x:00001D89                 db    0
.xdata$x:00001D8A                 db    0
.xdata$x:00001D8B                 db    0
.xdata$x:00001D8C                 dd offset __CT??_R0PAD@84
.xdata$x:00001D90                 dd offset __CT??_R0PAX@84
.xdata$x:00001D90 _xdata$x        ends
.xdata$x:00001D90
.xdata$x:00001D94 ; ===========================================================================
.xdata$x:00001D94
.xdata$x:00001D94 ; Segment type: Pure data
.xdata$x:00001D94 ; Segment permissions: Read
.xdata$x:00001D94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D94                 assume cs:_xdata$x
.xdata$x:00001D94                 ;org 1D94h
.xdata$x:00001D94 ; COMDAT (pick any)
.xdata$x:00001D94                 public __CT??_R0PAD@84
.xdata$x:00001D94 __CT??_R0PAD@84 db    1                 ; DATA XREF: .xdata$x:00001D8Co
.xdata$x:00001D95                 db    0
.xdata$x:00001D96                 db    0
.xdata$x:00001D97                 db    0
.xdata$x:00001D98                 dd offset ??_R0PAD@8    ; char * `RTTI Type Descriptor'
.xdata$x:00001D9C                 align 10h
.xdata$x:00001DA0                 db 0FFh
.xdata$x:00001DA1                 db 0FFh
.xdata$x:00001DA2                 db 0FFh
.xdata$x:00001DA3                 db 0FFh
.xdata$x:00001DA4                 db    0
.xdata$x:00001DA5                 db    0
.xdata$x:00001DA6                 db    0
.xdata$x:00001DA7                 db    0
.xdata$x:00001DA8                 db    4
.xdata$x:00001DA9                 db    0
.xdata$x:00001DAA                 db    0
.xdata$x:00001DAB                 db    0
.xdata$x:00001DAC                 db    0
.xdata$x:00001DAD                 db    0
.xdata$x:00001DAE                 db    0
.xdata$x:00001DAF                 db    0
.xdata$x:00001DAF _xdata$x        ends
.xdata$x:00001DAF
.data:00001DB0 ; ===========================================================================
.data:00001DB0
.data:00001DB0 ; Segment type: Pure data
.data:00001DB0 ; Segment permissions: Read/Write
.data:00001DB0 _data           segment dword public 'DATA' use32
.data:00001DB0                 assume cs:_data
.data:00001DB0                 ;org 1DB0h
.data:00001DB0 ; COMDAT (pick any)
.data:00001DB0                 public ??_R0PAD@8
.data:00001DB0 ; char * `RTTI Type Descriptor'
.data:00001DB0 ??_R0PAD@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00001D98o
.data:00001DB0                                         ; const type_info::`vftable'
.data:00001DB4                 align 8
.data:00001DB8 a_pad           db '.PAD',0
.data:00001DBD                 align 10h
.data:00001DBD _data           ends
.data:00001DBD
.xdata$x:00001DC0 ; ===========================================================================
.xdata$x:00001DC0
.xdata$x:00001DC0 ; Segment type: Pure data
.xdata$x:00001DC0 ; Segment permissions: Read
.xdata$x:00001DC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001DC0                 assume cs:_xdata$x
.xdata$x:00001DC0                 ;org 1DC0h
.xdata$x:00001DC0 ; COMDAT (pick any)
.xdata$x:00001DC0                 public __CT??_R0PAX@84
.xdata$x:00001DC0 __CT??_R0PAX@84 db    1                 ; DATA XREF: .xdata$x:00001D90o
.xdata$x:00001DC1                 db    0
.xdata$x:00001DC2                 db    0
.xdata$x:00001DC3                 db    0
.xdata$x:00001DC4                 dd offset ??_R0PAX@8    ; void * `RTTI Type Descriptor'
.xdata$x:00001DC8                 db    0
.xdata$x:00001DC9                 db    0
.xdata$x:00001DCA                 db    0
.xdata$x:00001DCB                 db    0
.xdata$x:00001DCC                 db 0FFh
.xdata$x:00001DCD                 db 0FFh
.xdata$x:00001DCE                 db 0FFh
.xdata$x:00001DCF                 db 0FFh
.xdata$x:00001DD0                 db    0
.xdata$x:00001DD1                 db    0
.xdata$x:00001DD2                 db    0
.xdata$x:00001DD3                 db    0
.xdata$x:00001DD4                 db    4
.xdata$x:00001DD5                 db    0
.xdata$x:00001DD6                 db    0
.xdata$x:00001DD7                 db    0
.xdata$x:00001DD8                 db    0
.xdata$x:00001DD9                 db    0
.xdata$x:00001DDA                 db    0
.xdata$x:00001DDB                 db    0
.xdata$x:00001DDB _xdata$x        ends
.xdata$x:00001DDB
.data:00001DDC ; ===========================================================================
.data:00001DDC
.data:00001DDC ; Segment type: Pure data
.data:00001DDC ; Segment permissions: Read/Write
.data:00001DDC _data           segment dword public 'DATA' use32
.data:00001DDC                 assume cs:_data
.data:00001DDC                 ;org 1DDCh
.data:00001DDC ; COMDAT (pick any)
.data:00001DDC                 public ??_R0PAX@8
.data:00001DDC ; void * `RTTI Type Descriptor'
.data:00001DDC ??_R0PAX@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00001DC4o
.data:00001DDC                                         ; const type_info::`vftable'
.data:00001DE0                 db    0
.data:00001DE1                 db    0
.data:00001DE2                 db    0
.data:00001DE3                 db    0
.data:00001DE4                 db  2Eh ; .
.data:00001DE5                 db  50h ; P
.data:00001DE6                 db  41h ; A
.data:00001DE7                 db  58h ; X
.data:00001DE8                 db    0
.data:00001DE9                 align 4
.data:00001DE9 _data           ends
.data:00001DE9
.text:00001DEC ; ===========================================================================
.text:00001DEC
.text:00001DEC ; Segment type: Pure code
.text:00001DEC ; Segment permissions: Read/Execute
.text:00001DEC _text           segment para public 'CODE' use32
.text:00001DEC                 assume cs:_text
.text:00001DEC                 ;org 1DECh
.text:00001DEC ; COMDAT (pick any)
.text:00001DEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001DEC
.text:00001DEC ; =============== S U B R O U T I N E =======================================
.text:00001DEC
.text:00001DEC ; Attributes: bp-based frame
.text:00001DEC
.text:00001DEC ; _DWORD __thiscall AString::~AString(AString *__hidden this)
.text:00001DEC                 public ??1AString@@QAE@XZ
.text:00001DEC ??1AString@@QAE@XZ proc near            ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+3ABp
.text:00001DEC                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+4BBp ...
.text:00001DEC
.text:00001DEC var_8           = dword ptr -8
.text:00001DEC var_4           = dword ptr -4
.text:00001DEC
.text:00001DEC                 push    ebp
.text:00001DED                 mov     ebp, esp
.text:00001DEF                 sub     esp, 8
.text:00001DF2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001DF9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001E00                 mov     [ebp+var_4], ecx
.text:00001E03                 mov     eax, [ebp+var_4]
.text:00001E06                 mov     ecx, [eax]
.text:00001E08                 mov     [ebp+var_8], ecx
.text:00001E0B                 mov     edx, [ebp+var_8]
.text:00001E0E                 push    edx             ; void *
.text:00001E0F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001E14                 add     esp, 4
.text:00001E17                 add     esp, 8
.text:00001E1A                 cmp     ebp, esp
.text:00001E1C                 call    __RTC_CheckEsp
.text:00001E21                 mov     esp, ebp
.text:00001E23                 pop     ebp
.text:00001E24                 retn
.text:00001E24 ??1AString@@QAE@XZ endp
.text:00001E24
.text:00001E24 ; ---------------------------------------------------------------------------
.text:00001E25                 align 4
.text:00001E25 _text           ends
.text:00001E25
.text:00001E28 ; ===========================================================================
.text:00001E28
.text:00001E28 ; Segment type: Pure code
.text:00001E28 ; Segment permissions: Read/Execute
.text:00001E28 _text           segment para public 'CODE' use32
.text:00001E28                 assume cs:_text
.text:00001E28                 ;org 1E28h
.text:00001E28 ; COMDAT (pick any)
.text:00001E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001E28
.text:00001E28 ; =============== S U B R O U T I N E =======================================
.text:00001E28
.text:00001E28 ; Attributes: bp-based frame
.text:00001E28
.text:00001E28 ; bool __thiscall AString::IsEmpty(AString *__hidden this)
.text:00001E28                 public ?IsEmpty@AString@@QBE_NXZ
.text:00001E28 ?IsEmpty@AString@@QBE_NXZ proc near     ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+157p
.text:00001E28
.text:00001E28 var_4           = dword ptr -4
.text:00001E28
.text:00001E28                 push    ebp
.text:00001E29                 mov     ebp, esp
.text:00001E2B                 push    ecx
.text:00001E2C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001E33                 mov     [ebp+var_4], ecx
.text:00001E36                 mov     eax, [ebp+var_4]
.text:00001E39                 xor     ecx, ecx
.text:00001E3B                 cmp     dword ptr [eax+4], 0
.text:00001E3F                 setz    cl
.text:00001E42                 mov     al, cl
.text:00001E44                 mov     esp, ebp
.text:00001E46                 pop     ebp
.text:00001E47                 retn
.text:00001E47 ?IsEmpty@AString@@QBE_NXZ endp
.text:00001E47
.text:00001E47 _text           ends
.text:00001E47
.text:00001E48 ; ===========================================================================
.text:00001E48
.text:00001E48 ; Segment type: Pure code
.text:00001E48 ; Segment permissions: Read/Execute
.text:00001E48 _text           segment para public 'CODE' use32
.text:00001E48                 assume cs:_text
.text:00001E48                 ;org 1E48h
.text:00001E48 ; COMDAT (pick any)
.text:00001E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001E48
.text:00001E48 ; =============== S U B R O U T I N E =======================================
.text:00001E48
.text:00001E48 ; Attributes: bp-based frame
.text:00001E48
.text:00001E48 ; int __stdcall operator==(int, char *Str2)
.text:00001E48                 public ??8@YG_NABVAString@@PBD@Z
.text:00001E48 ??8@YG_NABVAString@@PBD@Z proc near     ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+17Bp
.text:00001E48
.text:00001E48 arg_0           = dword ptr  8
.text:00001E48 Str2            = dword ptr  0Ch
.text:00001E48
.text:00001E48                 push    ebp
.text:00001E49                 mov     ebp, esp
.text:00001E4B                 mov     eax, [ebp+Str2]
.text:00001E4E                 push    eax             ; Str2
.text:00001E4F                 mov     ecx, [ebp+arg_0]
.text:00001E52                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:00001E57                 push    eax             ; Str1
.text:00001E58                 call    _strcmp
.text:00001E5D                 add     esp, 8
.text:00001E60                 neg     eax
.text:00001E62                 sbb     eax, eax
.text:00001E64                 add     eax, 1
.text:00001E67                 cmp     ebp, esp
.text:00001E69                 call    __RTC_CheckEsp
.text:00001E6E                 pop     ebp
.text:00001E6F                 retn    8
.text:00001E6F ??8@YG_NABVAString@@PBD@Z endp
.text:00001E6F
.text:00001E6F ; ---------------------------------------------------------------------------
.text:00001E72                 align 4
.text:00001E72 _text           ends
.text:00001E72
.text:00001E74 ; ===========================================================================
.text:00001E74
.text:00001E74 ; Segment type: Pure code
.text:00001E74 ; Segment permissions: Read/Execute
.text:00001E74 _text           segment para public 'CODE' use32
.text:00001E74                 assume cs:_text
.text:00001E74                 ;org 1E74h
.text:00001E74 ; COMDAT (pick any)
.text:00001E74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001E74
.text:00001E74 ; =============== S U B R O U T I N E =======================================
.text:00001E74
.text:00001E74 ; Attributes: bp-based frame
.text:00001E74
.text:00001E74 ; public: __thiscall AString::operator char const *(void)const
.text:00001E74                 public ??BAString@@QBEPBDXZ
.text:00001E74 ??BAString@@QBEPBDXZ proc near          ; CODE XREF: operator==(AString const &,char const *)+Ap
.text:00001E74
.text:00001E74 var_4           = dword ptr -4
.text:00001E74
.text:00001E74                 push    ebp
.text:00001E75                 mov     ebp, esp
.text:00001E77                 push    ecx
.text:00001E78                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001E7F                 mov     [ebp+var_4], ecx
.text:00001E82                 mov     eax, [ebp+var_4]
.text:00001E85                 mov     eax, [eax]
.text:00001E87                 mov     esp, ebp
.text:00001E89                 pop     ebp
.text:00001E8A                 retn
.text:00001E8A ??BAString@@QBEPBDXZ endp
.text:00001E8A
.text:00001E8A ; ---------------------------------------------------------------------------
.text:00001E8B                 align 4
.text:00001E8B _text           ends
.text:00001E8B
.text:00001E8C ; ===========================================================================
.text:00001E8C
.text:00001E8C ; Segment type: Pure code
.text:00001E8C ; Segment permissions: Read/Execute
.text:00001E8C _text           segment para public 'CODE' use32
.text:00001E8C                 assume cs:_text
.text:00001E8C                 ;org 1E8Ch
.text:00001E8C ; COMDAT (pick any)
.text:00001E8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001E8C
.text:00001E8C ; =============== S U B R O U T I N E =======================================
.text:00001E8C
.text:00001E8C ; Attributes: bp-based frame
.text:00001E8C
.text:00001E8C ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:00001E8C                 public ??1UString@@QAE@XZ
.text:00001E8C ??1UString@@QAE@XZ proc near            ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+91p
.text:00001E8C                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+1A0p ...
.text:00001E8C
.text:00001E8C var_8           = dword ptr -8
.text:00001E8C var_4           = dword ptr -4
.text:00001E8C
.text:00001E8C                 push    ebp
.text:00001E8D                 mov     ebp, esp
.text:00001E8F                 sub     esp, 8
.text:00001E92                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001E99                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001EA0                 mov     [ebp+var_4], ecx
.text:00001EA3                 mov     eax, [ebp+var_4]
.text:00001EA6                 mov     ecx, [eax]
.text:00001EA8                 mov     [ebp+var_8], ecx
.text:00001EAB                 mov     edx, [ebp+var_8]
.text:00001EAE                 push    edx             ; void *
.text:00001EAF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001EB4                 add     esp, 4
.text:00001EB7                 add     esp, 8
.text:00001EBA                 cmp     ebp, esp
.text:00001EBC                 call    __RTC_CheckEsp
.text:00001EC1                 mov     esp, ebp
.text:00001EC3                 pop     ebp
.text:00001EC4                 retn
.text:00001EC4 ??1UString@@QAE@XZ endp
.text:00001EC4
.text:00001EC4 ; ---------------------------------------------------------------------------
.text:00001EC5                 align 4
.text:00001EC5 _text           ends
.text:00001EC5
.text:00001EC8 ; ===========================================================================
.text:00001EC8
.text:00001EC8 ; Segment type: Pure code
.text:00001EC8 ; Segment permissions: Read/Execute
.text:00001EC8 _text           segment para public 'CODE' use32
.text:00001EC8                 assume cs:_text
.text:00001EC8                 ;org 1EC8h
.text:00001EC8 ; COMDAT (pick any)
.text:00001EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001EC8
.text:00001EC8 ; =============== S U B R O U T I N E =======================================
.text:00001EC8
.text:00001EC8 ; Attributes: bp-based frame
.text:00001EC8
.text:00001EC8 ; public: __thiscall COneMethodInfo::COneMethodInfo(void)
.text:00001EC8                 public ??0COneMethodInfo@@QAE@XZ
.text:00001EC8 ??0COneMethodInfo@@QAE@XZ proc near     ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+D7p
.text:00001EC8
.text:00001EC8 var_10          = dword ptr -10h
.text:00001EC8 var_C           = dword ptr -0Ch
.text:00001EC8 var_4           = dword ptr -4
.text:00001EC8
.text:00001EC8                 push    ebp
.text:00001EC9                 mov     ebp, esp
.text:00001ECB                 push    0FFFFFFFFh
.text:00001ECD                 push    offset __ehhandler$??0COneMethodInfo@@QAE@XZ
.text:00001ED2                 mov     eax, large fs:0
.text:00001ED8                 push    eax
.text:00001ED9                 push    ecx
.text:00001EDA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00001EE1                 mov     eax, dword ptr ds:___security_cookie
.text:00001EE6                 xor     eax, ebp
.text:00001EE8                 push    eax
.text:00001EE9                 lea     eax, [ebp+var_C]
.text:00001EEC                 mov     large fs:0, eax
.text:00001EF2                 mov     [ebp+var_10], ecx
.text:00001EF5                 mov     ecx, [ebp+var_10] ; this
.text:00001EF8                 call    ??0CMethodProps@@QAE@XZ ; CMethodProps::CMethodProps(void)
.text:00001EFD                 mov     [ebp+var_4], 0
.text:00001F04                 mov     ecx, [ebp+var_10]
.text:00001F07                 add     ecx, 0Ch
.text:00001F0A                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:00001F0F                 mov     byte ptr [ebp+var_4], 1
.text:00001F13                 mov     ecx, [ebp+var_10]
.text:00001F16                 add     ecx, 18h
.text:00001F19                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00001F1E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001F25                 mov     eax, [ebp+var_10]
.text:00001F28                 mov     ecx, [ebp+var_C]
.text:00001F2B                 mov     large fs:0, ecx
.text:00001F32                 pop     ecx
.text:00001F33                 add     esp, 10h
.text:00001F36                 cmp     ebp, esp
.text:00001F38                 call    __RTC_CheckEsp
.text:00001F3D                 mov     esp, ebp
.text:00001F3F                 pop     ebp
.text:00001F40                 retn
.text:00001F40 ??0COneMethodInfo@@QAE@XZ endp
.text:00001F40
.text:00001F40 ; ---------------------------------------------------------------------------
.text:00001F41                 align 4
.text:00001F41 _text           ends
.text:00001F41
.text$x:00001F44 ; ===========================================================================
.text$x:00001F44
.text$x:00001F44 ; Segment type: Pure code
.text$x:00001F44 ; Segment permissions: Read/Execute
.text$x:00001F44 _text$x         segment para public 'CODE' use32
.text$x:00001F44                 assume cs:_text$x
.text$x:00001F44                 ;org 1F44h
.text$x:00001F44 ; COMDAT (pick associative to section at 1EC8)
.text$x:00001F44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001F44
.text$x:00001F44 ; =============== S U B R O U T I N E =======================================
.text$x:00001F44
.text$x:00001F44
.text$x:00001F44 __unwindfunclet$??0COneMethodInfo@@QAE@XZ$0 proc near
.text$x:00001F44                                         ; DATA XREF: .xdata$x:00001F78o
.text$x:00001F44                 mov     ecx, [ebp-10h]  ; this
.text$x:00001F47                 jmp     ??1CMethodProps@@QAE@XZ ; CMethodProps::~CMethodProps(void)
.text$x:00001F47 __unwindfunclet$??0COneMethodInfo@@QAE@XZ$0 endp
.text$x:00001F47
.text$x:00001F4C
.text$x:00001F4C ; =============== S U B R O U T I N E =======================================
.text$x:00001F4C
.text$x:00001F4C
.text$x:00001F4C __unwindfunclet$??0COneMethodInfo@@QAE@XZ$1 proc near
.text$x:00001F4C                                         ; DATA XREF: .xdata$x:00001F80o
.text$x:00001F4C                 mov     ecx, [ebp-10h]
.text$x:00001F4F                 add     ecx, 0Ch        ; this
.text$x:00001F52                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00001F52 __unwindfunclet$??0COneMethodInfo@@QAE@XZ$1 endp
.text$x:00001F52
.text$x:00001F57
.text$x:00001F57 ; =============== S U B R O U T I N E =======================================
.text$x:00001F57
.text$x:00001F57
.text$x:00001F57 __ehhandler$??0COneMethodInfo@@QAE@XZ proc near
.text$x:00001F57                                         ; DATA XREF: COneMethodInfo::COneMethodInfo(void)+5o
.text$x:00001F57
.text$x:00001F57 arg_4           = dword ptr  8
.text$x:00001F57
.text$x:00001F57                 mov     edx, [esp+arg_4]
.text$x:00001F5B                 lea     eax, [edx+0Ch]
.text$x:00001F5E                 mov     ecx, [edx-8]
.text$x:00001F61                 xor     ecx, eax
.text$x:00001F63                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001F68                 mov     eax, offset __ehfuncinfo$??0COneMethodInfo@@QAE@XZ
.text$x:00001F6D                 jmp     ___CxxFrameHandler3
.text$x:00001F6D __ehhandler$??0COneMethodInfo@@QAE@XZ endp
.text$x:00001F6D
.text$x:00001F6D ; ---------------------------------------------------------------------------
.text$x:00001F72                 align 4
.text$x:00001F72 _text$x         ends
.text$x:00001F72
.xdata$x:00001F74 ; ===========================================================================
.xdata$x:00001F74
.xdata$x:00001F74 ; Segment type: Pure data
.xdata$x:00001F74 ; Segment permissions: Read
.xdata$x:00001F74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F74                 assume cs:_xdata$x
.xdata$x:00001F74                 ;org 1F74h
.xdata$x:00001F74 ; COMDAT (pick associative to section at 1EC8)
.xdata$x:00001F74 __unwindtable$??0COneMethodInfo@@QAE@XZ db 0FFh
.xdata$x:00001F74                                         ; DATA XREF: .xdata$x:00001F8Co
.xdata$x:00001F75                 db 0FFh
.xdata$x:00001F76                 db 0FFh
.xdata$x:00001F77                 db 0FFh
.xdata$x:00001F78                 dd offset __unwindfunclet$??0COneMethodInfo@@QAE@XZ$0
.xdata$x:00001F7C                 align 10h
.xdata$x:00001F80                 dd offset __unwindfunclet$??0COneMethodInfo@@QAE@XZ$1
.xdata$x:00001F84 __ehfuncinfo$??0COneMethodInfo@@QAE@XZ db  22h ; "
.xdata$x:00001F84                                         ; DATA XREF: __ehhandler$??0COneMethodInfo@@QAE@XZ+11o
.xdata$x:00001F85                 db    5
.xdata$x:00001F86                 db  93h ; 
.xdata$x:00001F87                 db  19h
.xdata$x:00001F88                 db    2
.xdata$x:00001F89                 db    0
.xdata$x:00001F8A                 db    0
.xdata$x:00001F8B                 db    0
.xdata$x:00001F8C                 dd offset __unwindtable$??0COneMethodInfo@@QAE@XZ
.xdata$x:00001F90                 db    0
.xdata$x:00001F91                 db    0
.xdata$x:00001F92                 db    0
.xdata$x:00001F93                 db    0
.xdata$x:00001F94                 db    0
.xdata$x:00001F95                 db    0
.xdata$x:00001F96                 db    0
.xdata$x:00001F97                 db    0
.xdata$x:00001F98                 db    0
.xdata$x:00001F99                 db    0
.xdata$x:00001F9A                 db    0
.xdata$x:00001F9B                 db    0
.xdata$x:00001F9C                 db    0
.xdata$x:00001F9D                 db    0
.xdata$x:00001F9E                 db    0
.xdata$x:00001F9F                 db    0
.xdata$x:00001FA0                 db    0
.xdata$x:00001FA1                 db    0
.xdata$x:00001FA2                 db    0
.xdata$x:00001FA3                 db    0
.xdata$x:00001FA4                 db    1
.xdata$x:00001FA5                 db    0
.xdata$x:00001FA6                 db    0
.xdata$x:00001FA7                 db    0
.xdata$x:00001FA7 _xdata$x        ends
.xdata$x:00001FA7
.text:00001FA8 ; ===========================================================================
.text:00001FA8
.text:00001FA8 ; Segment type: Pure code
.text:00001FA8 ; Segment permissions: Read/Execute
.text:00001FA8 _text           segment para public 'CODE' use32
.text:00001FA8                 assume cs:_text
.text:00001FA8                 ;org 1FA8h
.text:00001FA8 ; COMDAT (pick any)
.text:00001FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001FA8
.text:00001FA8 ; =============== S U B R O U T I N E =======================================
.text:00001FA8
.text:00001FA8 ; Attributes: bp-based frame
.text:00001FA8
.text:00001FA8 ; _DWORD __thiscall COneMethodInfo::~COneMethodInfo(COneMethodInfo *__hidden this)
.text:00001FA8                 public ??1COneMethodInfo@@QAE@XZ
.text:00001FA8 ??1COneMethodInfo@@QAE@XZ proc near     ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+11Dp
.text:00001FA8                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+252p ...
.text:00001FA8
.text:00001FA8 var_10          = dword ptr -10h
.text:00001FA8 var_C           = dword ptr -0Ch
.text:00001FA8 var_4           = dword ptr -4
.text:00001FA8
.text:00001FA8                 push    ebp
.text:00001FA9                 mov     ebp, esp
.text:00001FAB                 push    0FFFFFFFFh
.text:00001FAD                 push    offset __ehhandler$??1COneMethodInfo@@QAE@XZ
.text:00001FB2                 mov     eax, large fs:0
.text:00001FB8                 push    eax
.text:00001FB9                 push    ecx
.text:00001FBA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00001FC1                 mov     eax, dword ptr ds:___security_cookie
.text:00001FC6                 xor     eax, ebp
.text:00001FC8                 push    eax
.text:00001FC9                 lea     eax, [ebp+var_C]
.text:00001FCC                 mov     large fs:0, eax
.text:00001FD2                 mov     [ebp+var_10], ecx
.text:00001FD5                 mov     [ebp+var_4], 1
.text:00001FDC                 mov     ecx, [ebp+var_10]
.text:00001FDF                 add     ecx, 18h        ; this
.text:00001FE2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001FE7                 mov     byte ptr [ebp+var_4], 0
.text:00001FEB                 mov     ecx, [ebp+var_10]
.text:00001FEE                 add     ecx, 0Ch        ; this
.text:00001FF1                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00001FF6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001FFD                 mov     ecx, [ebp+var_10] ; this
.text:00002000                 call    ??1CMethodProps@@QAE@XZ ; CMethodProps::~CMethodProps(void)
.text:00002005                 mov     ecx, [ebp+var_C]
.text:00002008                 mov     large fs:0, ecx
.text:0000200F                 pop     ecx
.text:00002010                 add     esp, 10h
.text:00002013                 cmp     ebp, esp
.text:00002015                 call    __RTC_CheckEsp
.text:0000201A                 mov     esp, ebp
.text:0000201C                 pop     ebp
.text:0000201D                 retn
.text:0000201D ??1COneMethodInfo@@QAE@XZ endp
.text:0000201D
.text:0000201D ; ---------------------------------------------------------------------------
.text:0000201E                 align 10h
.text:0000201E _text           ends
.text:0000201E
.text$x:00002020 ; ===========================================================================
.text$x:00002020
.text$x:00002020 ; Segment type: Pure code
.text$x:00002020 ; Segment permissions: Read/Execute
.text$x:00002020 _text$x         segment para public 'CODE' use32
.text$x:00002020                 assume cs:_text$x
.text$x:00002020                 ;org 2020h
.text$x:00002020 ; COMDAT (pick associative to section at 1FA8)
.text$x:00002020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002020
.text$x:00002020 ; =============== S U B R O U T I N E =======================================
.text$x:00002020
.text$x:00002020
.text$x:00002020 __unwindfunclet$??1COneMethodInfo@@QAE@XZ$0 proc near
.text$x:00002020                                         ; DATA XREF: .xdata$x:00002054o
.text$x:00002020                 mov     ecx, [ebp-10h]  ; this
.text$x:00002023                 jmp     ??1CMethodProps@@QAE@XZ ; CMethodProps::~CMethodProps(void)
.text$x:00002023 __unwindfunclet$??1COneMethodInfo@@QAE@XZ$0 endp
.text$x:00002023
.text$x:00002028
.text$x:00002028 ; =============== S U B R O U T I N E =======================================
.text$x:00002028
.text$x:00002028
.text$x:00002028 __unwindfunclet$??1COneMethodInfo@@QAE@XZ$1 proc near
.text$x:00002028                                         ; DATA XREF: .xdata$x:0000205Co
.text$x:00002028                 mov     ecx, [ebp-10h]
.text$x:0000202B                 add     ecx, 0Ch        ; this
.text$x:0000202E                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:0000202E __unwindfunclet$??1COneMethodInfo@@QAE@XZ$1 endp
.text$x:0000202E
.text$x:00002033
.text$x:00002033 ; =============== S U B R O U T I N E =======================================
.text$x:00002033
.text$x:00002033
.text$x:00002033 __ehhandler$??1COneMethodInfo@@QAE@XZ proc near
.text$x:00002033                                         ; DATA XREF: COneMethodInfo::~COneMethodInfo(void)+5o
.text$x:00002033
.text$x:00002033 arg_4           = dword ptr  8
.text$x:00002033
.text$x:00002033                 mov     edx, [esp+arg_4]
.text$x:00002037                 lea     eax, [edx+0Ch]
.text$x:0000203A                 mov     ecx, [edx-8]
.text$x:0000203D                 xor     ecx, eax
.text$x:0000203F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002044                 mov     eax, offset __ehfuncinfo$??1COneMethodInfo@@QAE@XZ
.text$x:00002049                 jmp     ___CxxFrameHandler3
.text$x:00002049 __ehhandler$??1COneMethodInfo@@QAE@XZ endp
.text$x:00002049
.text$x:00002049 ; ---------------------------------------------------------------------------
.text$x:0000204E                 align 10h
.text$x:0000204E _text$x         ends
.text$x:0000204E
.xdata$x:00002050 ; ===========================================================================
.xdata$x:00002050
.xdata$x:00002050 ; Segment type: Pure data
.xdata$x:00002050 ; Segment permissions: Read
.xdata$x:00002050 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002050                 assume cs:_xdata$x
.xdata$x:00002050                 ;org 2050h
.xdata$x:00002050 ; COMDAT (pick associative to section at 1FA8)
.xdata$x:00002050 __unwindtable$??1COneMethodInfo@@QAE@XZ db 0FFh
.xdata$x:00002050                                         ; DATA XREF: .xdata$x:00002068o
.xdata$x:00002051                 db 0FFh
.xdata$x:00002052                 db 0FFh
.xdata$x:00002053                 db 0FFh
.xdata$x:00002054                 dd offset __unwindfunclet$??1COneMethodInfo@@QAE@XZ$0
.xdata$x:00002058                 db    0
.xdata$x:00002059                 db    0
.xdata$x:0000205A                 db    0
.xdata$x:0000205B                 db    0
.xdata$x:0000205C                 dd offset __unwindfunclet$??1COneMethodInfo@@QAE@XZ$1
.xdata$x:00002060 __ehfuncinfo$??1COneMethodInfo@@QAE@XZ db  22h ; "
.xdata$x:00002060                                         ; DATA XREF: __ehhandler$??1COneMethodInfo@@QAE@XZ+11o
.xdata$x:00002061                 db    5
.xdata$x:00002062                 db  93h ; 
.xdata$x:00002063                 db  19h
.xdata$x:00002064                 db    2
.xdata$x:00002065                 db    0
.xdata$x:00002066                 db    0
.xdata$x:00002067                 db    0
.xdata$x:00002068                 dd offset __unwindtable$??1COneMethodInfo@@QAE@XZ
.xdata$x:0000206C                 align 20h
.xdata$x:00002080                 db    1
.xdata$x:00002081                 db    0
.xdata$x:00002082                 db    0
.xdata$x:00002083                 db    0
.xdata$x:00002083 _xdata$x        ends
.xdata$x:00002083
.text:00002084 ; ===========================================================================
.text:00002084
.text:00002084 ; Segment type: Pure code
.text:00002084 ; Segment permissions: Read/Execute
.text:00002084 _text           segment para public 'CODE' use32
.text:00002084                 assume cs:_text
.text:00002084                 ;org 2084h
.text:00002084 ; COMDAT (pick any)
.text:00002084                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002084
.text:00002084 ; =============== S U B R O U T I N E =======================================
.text:00002084
.text:00002084 ; Attributes: bp-based frame
.text:00002084
.text:00002084 ; _DWORD __thiscall CMethodProps::CMethodProps(CMethodProps *__hidden this)
.text:00002084                 public ??0CMethodProps@@QAE@XZ
.text:00002084 ??0CMethodProps@@QAE@XZ proc near       ; CODE XREF: COneMethodInfo::COneMethodInfo(void)+30p
.text:00002084
.text:00002084 var_4           = dword ptr -4
.text:00002084
.text:00002084                 push    ebp
.text:00002085                 mov     ebp, esp
.text:00002087                 push    ecx
.text:00002088                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000208F                 mov     [ebp+var_4], ecx
.text:00002092                 mov     ecx, [ebp+var_4]
.text:00002095                 call    ??0CProps@@QAE@XZ ; CProps::CProps(void)
.text:0000209A                 mov     eax, [ebp+var_4]
.text:0000209D                 add     esp, 4
.text:000020A0                 cmp     ebp, esp
.text:000020A2                 call    __RTC_CheckEsp
.text:000020A7                 mov     esp, ebp
.text:000020A9                 pop     ebp
.text:000020AA                 retn
.text:000020AA ??0CMethodProps@@QAE@XZ endp
.text:000020AA
.text:000020AA ; ---------------------------------------------------------------------------
.text:000020AB                 align 4
.text:000020AB _text           ends
.text:000020AB
.text:000020AC ; ===========================================================================
.text:000020AC
.text:000020AC ; Segment type: Pure code
.text:000020AC ; Segment permissions: Read/Execute
.text:000020AC _text           segment para public 'CODE' use32
.text:000020AC                 assume cs:_text
.text:000020AC                 ;org 20ACh
.text:000020AC ; COMDAT (pick any)
.text:000020AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000020AC
.text:000020AC ; =============== S U B R O U T I N E =======================================
.text:000020AC
.text:000020AC ; Attributes: bp-based frame
.text:000020AC
.text:000020AC ; _DWORD __thiscall CMethodProps::~CMethodProps(CMethodProps *__hidden this)
.text:000020AC                 public ??1CMethodProps@@QAE@XZ
.text:000020AC ??1CMethodProps@@QAE@XZ proc near       ; CODE XREF: __unwindfunclet$??0COneMethodInfo@@QAE@XZ$0+3j
.text:000020AC                                         ; COneMethodInfo::~COneMethodInfo(void)+58p ...
.text:000020AC
.text:000020AC var_4           = dword ptr -4
.text:000020AC
.text:000020AC                 push    ebp
.text:000020AD                 mov     ebp, esp
.text:000020AF                 push    ecx
.text:000020B0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000020B7                 mov     [ebp+var_4], ecx
.text:000020BA                 mov     ecx, [ebp+var_4] ; this
.text:000020BD                 call    ??1CProps@@QAE@XZ ; CProps::~CProps(void)
.text:000020C2                 add     esp, 4
.text:000020C5                 cmp     ebp, esp
.text:000020C7                 call    __RTC_CheckEsp
.text:000020CC                 mov     esp, ebp
.text:000020CE                 pop     ebp
.text:000020CF                 retn
.text:000020CF ??1CMethodProps@@QAE@XZ endp
.text:000020CF
.text:000020CF _text           ends
.text:000020CF
.text:000020D0 ; ===========================================================================
.text:000020D0
.text:000020D0 ; Segment type: Pure code
.text:000020D0 ; Segment permissions: Read/Execute
.text:000020D0 _text           segment para public 'CODE' use32
.text:000020D0                 assume cs:_text
.text:000020D0                 ;org 20D0h
.text:000020D0 ; COMDAT (pick any)
.text:000020D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000020D0
.text:000020D0 ; =============== S U B R O U T I N E =======================================
.text:000020D0
.text:000020D0 ; Attributes: bp-based frame
.text:000020D0
.text:000020D0 ; public: __thiscall CProps::CProps(void)
.text:000020D0                 public ??0CProps@@QAE@XZ
.text:000020D0 ??0CProps@@QAE@XZ proc near             ; CODE XREF: CMethodProps::CMethodProps(void)+11p
.text:000020D0
.text:000020D0 var_4           = dword ptr -4
.text:000020D0
.text:000020D0                 push    ebp
.text:000020D1                 mov     ebp, esp
.text:000020D3                 push    ecx
.text:000020D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000020DB                 mov     [ebp+var_4], ecx
.text:000020DE                 mov     ecx, [ebp+var_4]
.text:000020E1                 call    ??0?$CObjectVector@UCProp@@@@QAE@XZ ; CObjectVector<CProp>::CObjectVector<CProp>(void)
.text:000020E6                 mov     eax, [ebp+var_4]
.text:000020E9                 add     esp, 4
.text:000020EC                 cmp     ebp, esp
.text:000020EE                 call    __RTC_CheckEsp
.text:000020F3                 mov     esp, ebp
.text:000020F5                 pop     ebp
.text:000020F6                 retn
.text:000020F6 ??0CProps@@QAE@XZ endp
.text:000020F6
.text:000020F6 ; ---------------------------------------------------------------------------
.text:000020F7                 align 4
.text:000020F7 _text           ends
.text:000020F7
.text:000020F8 ; ===========================================================================
.text:000020F8
.text:000020F8 ; Segment type: Pure code
.text:000020F8 ; Segment permissions: Read/Execute
.text:000020F8 _text           segment para public 'CODE' use32
.text:000020F8                 assume cs:_text
.text:000020F8                 ;org 20F8h
.text:000020F8 ; COMDAT (pick any)
.text:000020F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000020F8
.text:000020F8 ; =============== S U B R O U T I N E =======================================
.text:000020F8
.text:000020F8 ; Attributes: bp-based frame
.text:000020F8
.text:000020F8 ; _DWORD __thiscall CProps::~CProps(CProps *__hidden this)
.text:000020F8                 public ??1CProps@@QAE@XZ
.text:000020F8 ??1CProps@@QAE@XZ proc near             ; CODE XREF: CMethodProps::~CMethodProps(void)+11p
.text:000020F8
.text:000020F8 var_4           = dword ptr -4
.text:000020F8
.text:000020F8                 push    ebp
.text:000020F9                 mov     ebp, esp
.text:000020FB                 push    ecx
.text:000020FC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002103                 mov     [ebp+var_4], ecx
.text:00002106                 mov     ecx, [ebp+var_4]
.text:00002109                 call    ??1?$CObjectVector@UCProp@@@@QAE@XZ ; CObjectVector<CProp>::~CObjectVector<CProp>(void)
.text:0000210E                 add     esp, 4
.text:00002111                 cmp     ebp, esp
.text:00002113                 call    __RTC_CheckEsp
.text:00002118                 mov     esp, ebp
.text:0000211A                 pop     ebp
.text:0000211B                 retn
.text:0000211B ??1CProps@@QAE@XZ endp
.text:0000211B
.text:0000211B _text           ends
.text:0000211B
.text:0000211C ; ===========================================================================
.text:0000211C
.text:0000211C ; Segment type: Pure code
.text:0000211C ; Segment permissions: Read/Execute
.text:0000211C _text           segment para public 'CODE' use32
.text:0000211C                 assume cs:_text
.text:0000211C                 ;org 211Ch
.text:0000211C ; COMDAT (pick any)
.text:0000211C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000211C
.text:0000211C ; =============== S U B R O U T I N E =======================================
.text:0000211C
.text:0000211C ; Attributes: bp-based frame
.text:0000211C
.text:0000211C ; unsigned int __thiscall UString::Len(UString *__hidden this)
.text:0000211C                 public ?Len@UString@@QBEIXZ
.text:0000211C ?Len@UString@@QBEIXZ proc near          ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+218p
.text:0000211C
.text:0000211C var_4           = dword ptr -4
.text:0000211C
.text:0000211C                 push    ebp
.text:0000211D                 mov     ebp, esp
.text:0000211F                 push    ecx
.text:00002120                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002127                 mov     [ebp+var_4], ecx
.text:0000212A                 mov     eax, [ebp+var_4]
.text:0000212D                 mov     eax, [eax+4]
.text:00002130                 mov     esp, ebp
.text:00002132                 pop     ebp
.text:00002133                 retn
.text:00002133 ?Len@UString@@QBEIXZ endp
.text:00002133
.text:00002133 _text           ends
.text:00002133
.text:00002134 ; ===========================================================================
.text:00002134
.text:00002134 ; Segment type: Pure code
.text:00002134 ; Segment permissions: Read/Execute
.text:00002134 _text           segment para public 'CODE' use32
.text:00002134                 assume cs:_text
.text:00002134                 ;org 2134h
.text:00002134 ; COMDAT (pick any)
.text:00002134                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002134
.text:00002134 ; =============== S U B R O U T I N E =======================================
.text:00002134
.text:00002134 ; Attributes: bp-based frame
.text:00002134
.text:00002134 ; public: __thiscall UString::operator wchar_t const *(void)const
.text:00002134                 public ??BUString@@QBEPB_WXZ
.text:00002134 ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+225p
.text:00002134                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+689p ...
.text:00002134
.text:00002134 var_4           = dword ptr -4
.text:00002134
.text:00002134                 push    ebp
.text:00002135                 mov     ebp, esp
.text:00002137                 push    ecx
.text:00002138                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000213F                 mov     [ebp+var_4], ecx
.text:00002142                 mov     eax, [ebp+var_4]
.text:00002145                 mov     eax, [eax]
.text:00002147                 mov     esp, ebp
.text:00002149                 pop     ebp
.text:0000214A                 retn
.text:0000214A ??BUString@@QBEPB_WXZ endp
.text:0000214A
.text:0000214A ; ---------------------------------------------------------------------------
.text:0000214B                 align 4
.text:0000214B _text           ends
.text:0000214B
.text:0000214C ; ===========================================================================
.text:0000214C
.text:0000214C ; Segment type: Pure code
.text:0000214C ; Segment permissions: Read/Execute
.text:0000214C _text           segment para public 'CODE' use32
.text:0000214C                 assume cs:_text
.text:0000214C                 ;org 214Ch
.text:0000214C ; COMDAT (pick any)
.text:0000214C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000214C
.text:0000214C ; =============== S U B R O U T I N E =======================================
.text:0000214C
.text:0000214C ; Attributes: bp-based frame
.text:0000214C
.text:0000214C ; bool __thiscall CInFileStream::OpenShared(CInFileStream *this, const wchar_t *, bool)
.text:0000214C                 public ?OpenShared@CInFileStream@@QAE_NPB_W_N@Z
.text:0000214C ?OpenShared@CInFileStream@@QAE_NPB_W_N@Z proc near
.text:0000214C                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+695p
.text:0000214C
.text:0000214C var_4           = dword ptr -4
.text:0000214C arg_0           = dword ptr  8
.text:0000214C arg_4           = byte ptr  0Ch
.text:0000214C
.text:0000214C                 push    ebp
.text:0000214D                 mov     ebp, esp
.text:0000214F                 push    ecx
.text:00002150                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002157                 mov     [ebp+var_4], ecx
.text:0000215A                 movzx   eax, [ebp+arg_4]
.text:0000215E                 push    eax             ; bool
.text:0000215F                 mov     ecx, [ebp+arg_0]
.text:00002162                 push    ecx             ; wchar_t *
.text:00002163                 mov     ecx, [ebp+var_4]
.text:00002166                 add     ecx, 18h        ; this
.text:00002169                 call    ?OpenShared@CInFile@NIO@NFile@NWindows@@QAE_NPB_W_N@Z ; NWindows::NFile::NIO::CInFile::OpenShared(wchar_t const *,bool)
.text:0000216E                 add     esp, 4
.text:00002171                 cmp     ebp, esp
.text:00002173                 call    __RTC_CheckEsp
.text:00002178                 mov     esp, ebp
.text:0000217A                 pop     ebp
.text:0000217B                 retn    8
.text:0000217B ?OpenShared@CInFileStream@@QAE_NPB_W_N@Z endp
.text:0000217B
.text:0000217B ; ---------------------------------------------------------------------------
.text:0000217E                 align 10h
.text:0000217E _text           ends
.text:0000217E
.text:00002180 ; ===========================================================================
.text:00002180
.text:00002180 ; Segment type: Pure code
.text:00002180 ; Segment permissions: Read/Execute
.text:00002180 _text           segment para public 'CODE' use32
.text:00002180                 assume cs:_text
.text:00002180                 ;org 2180h
.text:00002180 ; COMDAT (pick any)
.text:00002180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002180
.text:00002180 ; =============== S U B R O U T I N E =======================================
.text:00002180
.text:00002180 ; Attributes: bp-based frame
.text:00002180
.text:00002180 ; unsigned __int64 __thiscall CDirItemsStat::GetTotalBytes(CDirItemsStat *__hidden this)
.text:00002180                 public ?GetTotalBytes@CDirItemsStat@@QBE_KXZ
.text:00002180 ?GetTotalBytes@CDirItemsStat@@QBE_KXZ proc near
.text:00002180                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+335p
.text:00002180
.text:00002180 var_4           = dword ptr -4
.text:00002180
.text:00002180                 push    ebp
.text:00002181                 mov     ebp, esp
.text:00002183                 push    ecx
.text:00002184                 push    esi
.text:00002185                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000218C                 mov     [ebp+var_4], ecx
.text:0000218F                 mov     eax, [ebp+var_4]
.text:00002192                 mov     ecx, [ebp+var_4]
.text:00002195                 mov     edx, [eax+18h]
.text:00002198                 add     edx, [ecx+20h]
.text:0000219B                 mov     esi, [eax+1Ch]
.text:0000219E                 adc     esi, [ecx+24h]
.text:000021A1                 mov     eax, edx
.text:000021A3                 mov     edx, esi
.text:000021A5                 pop     esi
.text:000021A6                 mov     esp, ebp
.text:000021A8                 pop     ebp
.text:000021A9                 retn
.text:000021A9 ?GetTotalBytes@CDirItemsStat@@QBE_KXZ endp
.text:000021A9
.text:000021A9 ; ---------------------------------------------------------------------------
.text:000021AA                 align 4
.text:000021AA _text           ends
.text:000021AA
.text:000021AC ; ===========================================================================
.text:000021AC
.text:000021AC ; Segment type: Pure code
.text:000021AC ; Segment permissions: Read/Execute
.text:000021AC _text           segment para public 'CODE' use32
.text:000021AC                 assume cs:_text
.text:000021AC                 ;org 21ACh
.text:000021AC ; COMDAT (pick any)
.text:000021AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000021AC
.text:000021AC ; =============== S U B R O U T I N E =======================================
.text:000021AC
.text:000021AC ; Attributes: bp-based frame
.text:000021AC
.text:000021AC ; public: __thiscall CDirItem::CDirItem(void)
.text:000021AC                 public ??0CDirItem@@QAE@XZ
.text:000021AC ??0CDirItem@@QAE@XZ proc near           ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+69p
.text:000021AC
.text:000021AC var_10          = dword ptr -10h
.text:000021AC var_C           = dword ptr -0Ch
.text:000021AC var_4           = dword ptr -4
.text:000021AC
.text:000021AC                 push    ebp
.text:000021AD                 mov     ebp, esp
.text:000021AF                 push    0FFFFFFFFh
.text:000021B1                 push    offset __ehhandler$??0CDirItem@@QAE@XZ
.text:000021B6                 mov     eax, large fs:0
.text:000021BC                 push    eax
.text:000021BD                 push    ecx
.text:000021BE                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000021C5                 mov     eax, dword ptr ds:___security_cookie
.text:000021CA                 xor     eax, ebp
.text:000021CC                 push    eax
.text:000021CD                 lea     eax, [ebp+var_C]
.text:000021D0                 mov     large fs:0, eax
.text:000021D6                 mov     [ebp+var_10], ecx
.text:000021D9                 mov     ecx, [ebp+var_10]
.text:000021DC                 add     ecx, 20h ; ' '
.text:000021DF                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000021E4                 mov     [ebp+var_4], 0
.text:000021EB                 mov     ecx, [ebp+var_10]
.text:000021EE                 add     ecx, 2Ch ; ','
.text:000021F1                 call    ??0?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::CBuffer<uchar>(void)
.text:000021F6                 mov     byte ptr [ebp+var_4], 1
.text:000021FA                 mov     ecx, [ebp+var_10]
.text:000021FD                 add     ecx, 34h ; '4'
.text:00002200                 call    ??0?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::CBuffer<uchar>(void)
.text:00002205                 mov     eax, [ebp+var_10]
.text:00002208                 mov     dword ptr [eax+40h], 0FFFFFFFFh
.text:0000220F                 mov     ecx, [ebp+var_10]
.text:00002212                 mov     dword ptr [ecx+44h], 0FFFFFFFFh
.text:00002219                 mov     edx, [ebp+var_10]
.text:0000221C                 mov     dword ptr [edx+48h], 0FFFFFFFFh
.text:00002223                 mov     eax, [ebp+var_10]
.text:00002226                 mov     byte ptr [eax+4Ch], 0
.text:0000222A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002231                 mov     eax, [ebp+var_10]
.text:00002234                 mov     ecx, [ebp+var_C]
.text:00002237                 mov     large fs:0, ecx
.text:0000223E                 pop     ecx
.text:0000223F                 add     esp, 10h
.text:00002242                 cmp     ebp, esp
.text:00002244                 call    __RTC_CheckEsp
.text:00002249                 mov     esp, ebp
.text:0000224B                 pop     ebp
.text:0000224C                 retn
.text:0000224C ??0CDirItem@@QAE@XZ endp
.text:0000224C
.text:0000224C ; ---------------------------------------------------------------------------
.text:0000224D                 align 10h
.text:0000224D _text           ends
.text:0000224D
.text$x:00002250 ; ===========================================================================
.text$x:00002250
.text$x:00002250 ; Segment type: Pure code
.text$x:00002250 ; Segment permissions: Read/Execute
.text$x:00002250 _text$x         segment para public 'CODE' use32
.text$x:00002250                 assume cs:_text$x
.text$x:00002250                 ;org 2250h
.text$x:00002250 ; COMDAT (pick associative to section at 21AC)
.text$x:00002250                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002250
.text$x:00002250 ; =============== S U B R O U T I N E =======================================
.text$x:00002250
.text$x:00002250
.text$x:00002250 __unwindfunclet$??0CDirItem@@QAE@XZ$0 proc near
.text$x:00002250                                         ; DATA XREF: .xdata$x:00002288o
.text$x:00002250                 mov     ecx, [ebp-10h]
.text$x:00002253                 add     ecx, 20h ; ' '  ; this
.text$x:00002256                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00002256 __unwindfunclet$??0CDirItem@@QAE@XZ$0 endp
.text$x:00002256
.text$x:0000225B
.text$x:0000225B ; =============== S U B R O U T I N E =======================================
.text$x:0000225B
.text$x:0000225B
.text$x:0000225B __unwindfunclet$??0CDirItem@@QAE@XZ$1 proc near
.text$x:0000225B                                         ; DATA XREF: .xdata$x:00002290o
.text$x:0000225B                 mov     ecx, [ebp-10h]
.text$x:0000225E                 add     ecx, 2Ch ; ','
.text$x:00002261                 jmp     ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text$x:00002261 __unwindfunclet$??0CDirItem@@QAE@XZ$1 endp
.text$x:00002261
.text$x:00002266
.text$x:00002266 ; =============== S U B R O U T I N E =======================================
.text$x:00002266
.text$x:00002266
.text$x:00002266 __ehhandler$??0CDirItem@@QAE@XZ proc near
.text$x:00002266                                         ; DATA XREF: CDirItem::CDirItem(void)+5o
.text$x:00002266
.text$x:00002266 arg_4           = dword ptr  8
.text$x:00002266
.text$x:00002266                 mov     edx, [esp+arg_4]
.text$x:0000226A                 lea     eax, [edx+0Ch]
.text$x:0000226D                 mov     ecx, [edx-8]
.text$x:00002270                 xor     ecx, eax
.text$x:00002272                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002277                 mov     eax, offset __ehfuncinfo$??0CDirItem@@QAE@XZ
.text$x:0000227C                 jmp     ___CxxFrameHandler3
.text$x:0000227C __ehhandler$??0CDirItem@@QAE@XZ endp
.text$x:0000227C
.text$x:0000227C ; ---------------------------------------------------------------------------
.text$x:00002281                 align 4
.text$x:00002281 _text$x         ends
.text$x:00002281
.xdata$x:00002284 ; ===========================================================================
.xdata$x:00002284
.xdata$x:00002284 ; Segment type: Pure data
.xdata$x:00002284 ; Segment permissions: Read
.xdata$x:00002284 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002284                 assume cs:_xdata$x
.xdata$x:00002284                 ;org 2284h
.xdata$x:00002284 ; COMDAT (pick associative to section at 21AC)
.xdata$x:00002284 __unwindtable$??0CDirItem@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:0000229Co
.xdata$x:00002285                 db 0FFh
.xdata$x:00002286                 db 0FFh
.xdata$x:00002287                 db 0FFh
.xdata$x:00002288                 dd offset __unwindfunclet$??0CDirItem@@QAE@XZ$0
.xdata$x:0000228C                 align 10h
.xdata$x:00002290                 dd offset __unwindfunclet$??0CDirItem@@QAE@XZ$1
.xdata$x:00002294 __ehfuncinfo$??0CDirItem@@QAE@XZ db  22h ; "
.xdata$x:00002294                                         ; DATA XREF: __ehhandler$??0CDirItem@@QAE@XZ+11o
.xdata$x:00002295                 db    5
.xdata$x:00002296                 db  93h ; 
.xdata$x:00002297                 db  19h
.xdata$x:00002298                 db    2
.xdata$x:00002299                 db    0
.xdata$x:0000229A                 db    0
.xdata$x:0000229B                 db    0
.xdata$x:0000229C                 dd offset __unwindtable$??0CDirItem@@QAE@XZ
.xdata$x:000022A0                 db    0
.xdata$x:000022A1                 db    0
.xdata$x:000022A2                 db    0
.xdata$x:000022A3                 db    0
.xdata$x:000022A4                 db    0
.xdata$x:000022A5                 db    0
.xdata$x:000022A6                 db    0
.xdata$x:000022A7                 db    0
.xdata$x:000022A8                 db    0
.xdata$x:000022A9                 db    0
.xdata$x:000022AA                 db    0
.xdata$x:000022AB                 db    0
.xdata$x:000022AC                 db    0
.xdata$x:000022AD                 db    0
.xdata$x:000022AE                 db    0
.xdata$x:000022AF                 db    0
.xdata$x:000022B0                 db    0
.xdata$x:000022B1                 db    0
.xdata$x:000022B2                 db    0
.xdata$x:000022B3                 db    0
.xdata$x:000022B4                 db    1
.xdata$x:000022B5                 db    0
.xdata$x:000022B6                 db    0
.xdata$x:000022B7                 db    0
.xdata$x:000022B7 _xdata$x        ends
.xdata$x:000022B7
.text:000022B8 ; ===========================================================================
.text:000022B8
.text:000022B8 ; Segment type: Pure code
.text:000022B8 ; Segment permissions: Read/Execute
.text:000022B8 _text           segment para public 'CODE' use32
.text:000022B8                 assume cs:_text
.text:000022B8                 ;org 22B8h
.text:000022B8 ; COMDAT (pick any)
.text:000022B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000022B8
.text:000022B8 ; =============== S U B R O U T I N E =======================================
.text:000022B8
.text:000022B8 ; Attributes: bp-based frame
.text:000022B8
.text:000022B8 ; bool __thiscall CDirItem::IsDir(CDirItem *__hidden this)
.text:000022B8                 public ?IsDir@CDirItem@@QBE_NXZ
.text:000022B8 ?IsDir@CDirItem@@QBE_NXZ proc near      ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+5E5p
.text:000022B8
.text:000022B8 var_4           = dword ptr -4
.text:000022B8
.text:000022B8                 push    ebp
.text:000022B9                 mov     ebp, esp
.text:000022BB                 push    ecx
.text:000022BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000022C3                 mov     [ebp+var_4], ecx
.text:000022C6                 mov     eax, [ebp+var_4]
.text:000022C9                 mov     eax, [eax+3Ch]
.text:000022CC                 and     eax, 10h
.text:000022CF                 neg     eax
.text:000022D1                 sbb     eax, eax
.text:000022D3                 neg     eax
.text:000022D5                 mov     esp, ebp
.text:000022D7                 pop     ebp
.text:000022D8                 retn
.text:000022D8 ?IsDir@CDirItem@@QBE_NXZ endp
.text:000022D8
.text:000022D8 ; ---------------------------------------------------------------------------
.text:000022D9                 align 4
.text:000022D9 _text           ends
.text:000022D9
.text:000022DC ; ===========================================================================
.text:000022DC
.text:000022DC ; Segment type: Pure code
.text:000022DC ; Segment permissions: Read/Execute
.text:000022DC _text           segment para public 'CODE' use32
.text:000022DC                 assume cs:_text
.text:000022DC                 ;org 22DCh
.text:000022DC ; COMDAT (pick any)
.text:000022DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000022DC
.text:000022DC ; =============== S U B R O U T I N E =======================================
.text:000022DC
.text:000022DC ; Attributes: bp-based frame
.text:000022DC
.text:000022DC ; void __thiscall CHashBundle::Init(CHashBundle *__hidden this)
.text:000022DC                 public ?Init@CHashBundle@@QAEXXZ
.text:000022DC ?Init@CHashBundle@@QAEXXZ proc near     ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+2ADp
.text:000022DC
.text:000022DC var_4           = dword ptr -4
.text:000022DC
.text:000022DC                 push    ebp
.text:000022DD                 mov     ebp, esp
.text:000022DF                 push    ecx
.text:000022E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000022E7                 mov     [ebp+var_4], ecx
.text:000022EA                 mov     eax, [ebp+var_4]
.text:000022ED                 mov     dword ptr [eax+38h], 0
.text:000022F4                 mov     dword ptr [eax+3Ch], 0
.text:000022FB                 mov     ecx, [ebp+var_4]
.text:000022FE                 mov     dword ptr [ecx+30h], 0
.text:00002305                 mov     dword ptr [ecx+34h], 0
.text:0000230C                 mov     edx, [ebp+var_4]
.text:0000230F                 mov     dword ptr [edx+28h], 0
.text:00002316                 mov     dword ptr [edx+2Ch], 0
.text:0000231D                 mov     eax, [ebp+var_4]
.text:00002320                 mov     dword ptr [eax+20h], 0
.text:00002327                 mov     dword ptr [eax+24h], 0
.text:0000232E                 mov     ecx, [ebp+var_4]
.text:00002331                 mov     dword ptr [ecx+18h], 0
.text:00002338                 mov     dword ptr [ecx+1Ch], 0
.text:0000233F                 mov     edx, [ebp+var_4]
.text:00002342                 mov     dword ptr [edx+10h], 0
.text:00002349                 mov     dword ptr [edx+14h], 0
.text:00002350                 mov     esp, ebp
.text:00002352                 pop     ebp
.text:00002353                 retn
.text:00002353 ?Init@CHashBundle@@QAEXXZ endp
.text:00002353
.text:00002353 _text           ends
.text:00002353
.text:00002354 ; ===========================================================================
.text:00002354
.text:00002354 ; Segment type: Pure code
.text:00002354 ; Segment permissions: Read/Execute
.text:00002354 _text           segment para public 'CODE' use32
.text:00002354                 assume cs:_text
.text:00002354                 ;org 2354h
.text:00002354 ; COMDAT (pick any)
.text:00002354                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002354
.text:00002354 ; =============== S U B R O U T I N E =======================================
.text:00002354
.text:00002354 ; Attributes: bp-based frame
.text:00002354
.text:00002354 ; _DWORD __thiscall CHashMidBuf::CHashMidBuf(CHashMidBuf *__hidden this)
.text:00002354                 public ??0CHashMidBuf@@QAE@XZ
.text:00002354 ??0CHashMidBuf@@QAE@XZ proc near        ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+3A9p
.text:00002354
.text:00002354 var_4           = dword ptr -4
.text:00002354
.text:00002354                 push    ebp
.text:00002355                 mov     ebp, esp
.text:00002357                 push    ecx
.text:00002358                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000235F                 mov     [ebp+var_4], ecx
.text:00002362                 mov     eax, [ebp+var_4]
.text:00002365                 mov     dword ptr [eax], 0
.text:0000236B                 mov     eax, [ebp+var_4]
.text:0000236E                 mov     esp, ebp
.text:00002370                 pop     ebp
.text:00002371                 retn
.text:00002371 ??0CHashMidBuf@@QAE@XZ endp
.text:00002371
.text:00002371 ; ---------------------------------------------------------------------------
.text:00002372                 align 4
.text:00002372 _text           ends
.text:00002372
.text:00002374 ; ===========================================================================
.text:00002374
.text:00002374 ; Segment type: Pure code
.text:00002374 ; Segment permissions: Read/Execute
.text:00002374 _text           segment para public 'CODE' use32
.text:00002374                 assume cs:_text
.text:00002374                 ;org 2374h
.text:00002374 ; COMDAT (pick any)
.text:00002374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002374
.text:00002374 ; =============== S U B R O U T I N E =======================================
.text:00002374
.text:00002374 ; Attributes: bp-based frame
.text:00002374
.text:00002374 ; public: __thiscall CHashMidBuf::operator void *(void)
.text:00002374                 public ??BCHashMidBuf@@QAEPAXXZ
.text:00002374 ??BCHashMidBuf@@QAEPAXXZ proc near      ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+962p
.text:00002374                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+A0Fp
.text:00002374
.text:00002374 var_4           = dword ptr -4
.text:00002374
.text:00002374                 push    ebp
.text:00002375                 mov     ebp, esp
.text:00002377                 push    ecx
.text:00002378                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000237F                 mov     [ebp+var_4], ecx
.text:00002382                 mov     eax, [ebp+var_4]
.text:00002385                 mov     eax, [eax]
.text:00002387                 mov     esp, ebp
.text:00002389                 pop     ebp
.text:0000238A                 retn
.text:0000238A ??BCHashMidBuf@@QAEPAXXZ endp
.text:0000238A
.text:0000238A ; ---------------------------------------------------------------------------
.text:0000238B                 align 4
.text:0000238B _text           ends
.text:0000238B
.text:0000238C ; ===========================================================================
.text:0000238C
.text:0000238C ; Segment type: Pure code
.text:0000238C ; Segment permissions: Read/Execute
.text:0000238C _text           segment para public 'CODE' use32
.text:0000238C                 assume cs:_text
.text:0000238C                 ;org 238Ch
.text:0000238C ; COMDAT (pick any)
.text:0000238C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000238C
.text:0000238C ; =============== S U B R O U T I N E =======================================
.text:0000238C
.text:0000238C ; Attributes: bp-based frame
.text:0000238C
.text:0000238C ; bool __thiscall CHashMidBuf::Alloc(CHashMidBuf *this, unsigned int)
.text:0000238C                 public ?Alloc@CHashMidBuf@@QAE_NI@Z
.text:0000238C ?Alloc@CHashMidBuf@@QAE_NI@Z proc near  ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+3BDp
.text:0000238C
.text:0000238C var_4           = dword ptr -4
.text:0000238C arg_0           = dword ptr  8
.text:0000238C
.text:0000238C                 push    ebp
.text:0000238D                 mov     ebp, esp
.text:0000238F                 push    ecx
.text:00002390                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002397                 mov     [ebp+var_4], ecx
.text:0000239A                 mov     eax, [ebp+var_4]
.text:0000239D                 cmp     dword ptr [eax], 0
.text:000023A0                 jz      short loc_23A6
.text:000023A2                 xor     al, al
.text:000023A4                 jmp     short loc_23C1
.text:000023A6 ; ---------------------------------------------------------------------------
.text:000023A6
.text:000023A6 loc_23A6:                               ; CODE XREF: CHashMidBuf::Alloc(uint)+14j
.text:000023A6                 mov     ecx, [ebp+arg_0]
.text:000023A9                 push    ecx
.text:000023AA                 call    _MidAlloc@4     ; MidAlloc(x)
.text:000023AF                 mov     edx, [ebp+var_4]
.text:000023B2                 mov     [edx], eax
.text:000023B4                 mov     eax, [ebp+var_4]
.text:000023B7                 xor     ecx, ecx
.text:000023B9                 cmp     dword ptr [eax], 0
.text:000023BC                 setnz   cl
.text:000023BF                 mov     al, cl
.text:000023C1
.text:000023C1 loc_23C1:                               ; CODE XREF: CHashMidBuf::Alloc(uint)+18j
.text:000023C1                 add     esp, 4
.text:000023C4                 cmp     ebp, esp
.text:000023C6                 call    __RTC_CheckEsp
.text:000023CB                 mov     esp, ebp
.text:000023CD                 pop     ebp
.text:000023CE                 retn    4
.text:000023CE ?Alloc@CHashMidBuf@@QAE_NI@Z endp
.text:000023CE
.text:000023CE ; ---------------------------------------------------------------------------
.text:000023D1                 align 4
.text:000023D1 _text           ends
.text:000023D1
.text:000023D4 ; ===========================================================================
.text:000023D4
.text:000023D4 ; Segment type: Pure code
.text:000023D4 ; Segment permissions: Read/Execute
.text:000023D4 _text           segment para public 'CODE' use32
.text:000023D4                 assume cs:_text
.text:000023D4                 ;org 23D4h
.text:000023D4 ; COMDAT (pick any)
.text:000023D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000023D4
.text:000023D4 ; =============== S U B R O U T I N E =======================================
.text:000023D4
.text:000023D4 ; Attributes: bp-based frame
.text:000023D4
.text:000023D4 ; _DWORD __thiscall CHashMidBuf::~CHashMidBuf(CHashMidBuf *__hidden this)
.text:000023D4                 public ??1CHashMidBuf@@QAE@XZ
.text:000023D4 ??1CHashMidBuf@@QAE@XZ proc near        ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+3DDp
.text:000023D4                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+464p ...
.text:000023D4
.text:000023D4 var_4           = dword ptr -4
.text:000023D4
.text:000023D4                 push    ebp
.text:000023D5                 mov     ebp, esp
.text:000023D7                 push    ecx
.text:000023D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000023DF                 mov     [ebp+var_4], ecx
.text:000023E2                 mov     eax, [ebp+var_4]
.text:000023E5                 mov     ecx, [eax]
.text:000023E7                 push    ecx
.text:000023E8                 call    _MidFree@4      ; MidFree(x)
.text:000023ED                 add     esp, 4
.text:000023F0                 cmp     ebp, esp
.text:000023F2                 call    __RTC_CheckEsp
.text:000023F7                 mov     esp, ebp
.text:000023F9                 pop     ebp
.text:000023FA                 retn
.text:000023FA ??1CHashMidBuf@@QAE@XZ endp
.text:000023FA
.text:000023FA ; ---------------------------------------------------------------------------
.text:000023FB                 align 4
.text:000023FB _text           ends
.text:000023FB
.text:000023FC ; ===========================================================================
.text:000023FC
.text:000023FC ; Segment type: Pure code
.text:000023FC ; Segment permissions: Read/Execute
.text:000023FC _text           segment para public 'CODE' use32
.text:000023FC                 assume cs:_text
.text:000023FC                 ;org 23FCh
.text:000023FC ; COMDAT (pick any)
.text:000023FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000023FC
.text:000023FC ; =============== S U B R O U T I N E =======================================
.text:000023FC
.text:000023FC ; Attributes: bp-based frame
.text:000023FC
.text:000023FC ; _DWORD __thiscall CDirItems::~CDirItems(CDirItems *__hidden this)
.text:000023FC                 public ??1CDirItems@@QAE@XZ
.text:000023FC ??1CDirItems@@QAE@XZ proc near          ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+138p
.text:000023FC                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+1E0p ...
.text:000023FC
.text:000023FC var_10          = dword ptr -10h
.text:000023FC var_C           = dword ptr -0Ch
.text:000023FC var_4           = dword ptr -4
.text:000023FC
.text:000023FC                 push    ebp
.text:000023FD                 mov     ebp, esp
.text:000023FF                 push    0FFFFFFFFh
.text:00002401                 push    offset __ehhandler$??1CDirItems@@QAE@XZ
.text:00002406                 mov     eax, large fs:0
.text:0000240C                 push    eax
.text:0000240D                 push    ecx
.text:0000240E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002415                 mov     eax, dword ptr ds:___security_cookie
.text:0000241A                 xor     eax, ebp
.text:0000241C                 push    eax
.text:0000241D                 lea     eax, [ebp+var_C]
.text:00002420                 mov     large fs:0, eax
.text:00002426                 mov     [ebp+var_10], ecx
.text:00002429                 mov     [ebp+var_4], 4
.text:00002430                 mov     ecx, [ebp+var_10]
.text:00002433                 add     ecx, 8Ch ; ''
.text:00002439                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:0000243E                 mov     byte ptr [ebp+var_4], 3
.text:00002442                 mov     ecx, [ebp+var_10]
.text:00002445                 add     ecx, 68h ; 'h'  ; this
.text:00002448                 call    ??1CUniqBlocks@@QAE@XZ ; CUniqBlocks::~CUniqBlocks(void)
.text:0000244D                 mov     byte ptr [ebp+var_4], 2
.text:00002451                 mov     ecx, [ebp+var_10]
.text:00002454                 add     ecx, 24h ; '$'
.text:00002457                 call    ??1?$CObjectVector@UCDirItem@@@@QAE@XZ ; CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)
.text:0000245C                 mov     byte ptr [ebp+var_4], 1
.text:00002460                 mov     ecx, [ebp+var_10]
.text:00002463                 add     ecx, 18h
.text:00002466                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:0000246B                 mov     byte ptr [ebp+var_4], 0
.text:0000246F                 mov     ecx, [ebp+var_10]
.text:00002472                 add     ecx, 0Ch
.text:00002475                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:0000247A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002481                 mov     ecx, [ebp+var_10]
.text:00002484                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00002489                 mov     ecx, [ebp+var_C]
.text:0000248C                 mov     large fs:0, ecx
.text:00002493                 pop     ecx
.text:00002494                 add     esp, 10h
.text:00002497                 cmp     ebp, esp
.text:00002499                 call    __RTC_CheckEsp
.text:0000249E                 mov     esp, ebp
.text:000024A0                 pop     ebp
.text:000024A1                 retn
.text:000024A1 ??1CDirItems@@QAE@XZ endp
.text:000024A1
.text:000024A1 ; ---------------------------------------------------------------------------
.text:000024A2                 align 4
.text:000024A2 _text           ends
.text:000024A2
.text$x:000024A4 ; ===========================================================================
.text$x:000024A4
.text$x:000024A4 ; Segment type: Pure code
.text$x:000024A4 ; Segment permissions: Read/Execute
.text$x:000024A4 _text$x         segment para public 'CODE' use32
.text$x:000024A4                 assume cs:_text$x
.text$x:000024A4                 ;org 24A4h
.text$x:000024A4 ; COMDAT (pick associative to section at 23FC)
.text$x:000024A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000024A4
.text$x:000024A4 ; =============== S U B R O U T I N E =======================================
.text$x:000024A4
.text$x:000024A4
.text$x:000024A4 __unwindfunclet$??1CDirItems@@QAE@XZ$0 proc near
.text$x:000024A4                                         ; DATA XREF: .xdata$x:0000251Co
.text$x:000024A4                 mov     ecx, [ebp-10h]
.text$x:000024A7                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:000024A7 __unwindfunclet$??1CDirItems@@QAE@XZ$0 endp
.text$x:000024A7
.text$x:000024AC
.text$x:000024AC ; =============== S U B R O U T I N E =======================================
.text$x:000024AC
.text$x:000024AC
.text$x:000024AC __unwindfunclet$??1CDirItems@@QAE@XZ$1 proc near
.text$x:000024AC                                         ; DATA XREF: .xdata$x:00002524o
.text$x:000024AC                 mov     ecx, [ebp-10h]
.text$x:000024AF                 add     ecx, 0Ch
.text$x:000024B2                 jmp     ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text$x:000024B2 __unwindfunclet$??1CDirItems@@QAE@XZ$1 endp
.text$x:000024B2
.text$x:000024B7
.text$x:000024B7 ; =============== S U B R O U T I N E =======================================
.text$x:000024B7
.text$x:000024B7
.text$x:000024B7 __unwindfunclet$??1CDirItems@@QAE@XZ$2 proc near
.text$x:000024B7                                         ; DATA XREF: .xdata$x:0000252Co
.text$x:000024B7                 mov     ecx, [ebp-10h]
.text$x:000024BA                 add     ecx, 18h
.text$x:000024BD                 jmp     ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text$x:000024BD __unwindfunclet$??1CDirItems@@QAE@XZ$2 endp
.text$x:000024BD
.text$x:000024C2
.text$x:000024C2 ; =============== S U B R O U T I N E =======================================
.text$x:000024C2
.text$x:000024C2
.text$x:000024C2 __unwindfunclet$??1CDirItems@@QAE@XZ$3 proc near
.text$x:000024C2                                         ; DATA XREF: .xdata$x:00002534o
.text$x:000024C2                 mov     ecx, [ebp-10h]
.text$x:000024C5                 add     ecx, 24h ; '$'
.text$x:000024C8                 jmp     ??1?$CObjectVector@UCDirItem@@@@QAE@XZ ; CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)
.text$x:000024C8 __unwindfunclet$??1CDirItems@@QAE@XZ$3 endp
.text$x:000024C8
.text$x:000024CD
.text$x:000024CD ; =============== S U B R O U T I N E =======================================
.text$x:000024CD
.text$x:000024CD
.text$x:000024CD __unwindfunclet$??1CDirItems@@QAE@XZ$4 proc near
.text$x:000024CD                                         ; DATA XREF: .xdata$x:0000253Co
.text$x:000024CD                 mov     ecx, [ebp-10h]
.text$x:000024D0                 add     ecx, 68h ; 'h'  ; this
.text$x:000024D3                 jmp     ??1CUniqBlocks@@QAE@XZ ; CUniqBlocks::~CUniqBlocks(void)
.text$x:000024D3 __unwindfunclet$??1CDirItems@@QAE@XZ$4 endp
.text$x:000024D3
.text$x:000024D8
.text$x:000024D8 ; =============== S U B R O U T I N E =======================================
.text$x:000024D8
.text$x:000024D8
.text$x:000024D8 __ehhandler$??1CDirItems@@QAE@XZ proc near
.text$x:000024D8                                         ; DATA XREF: CDirItems::~CDirItems(void)+5o
.text$x:000024D8
.text$x:000024D8 arg_4           = dword ptr  8
.text$x:000024D8
.text$x:000024D8                 mov     edx, [esp+arg_4]
.text$x:000024DC                 lea     eax, [edx+0Ch]
.text$x:000024DF                 mov     ecx, [edx-8]
.text$x:000024E2                 xor     ecx, eax
.text$x:000024E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000024E9                 mov     eax, offset __ehfuncinfo$??1CDirItems@@QAE@XZ
.text$x:000024EE                 jmp     ___CxxFrameHandler3
.text$x:000024EE __ehhandler$??1CDirItems@@QAE@XZ endp
.text$x:000024EE
.text$x:000024EE ; ---------------------------------------------------------------------------
.text$x:000024F3                 align 4
.text$x:000024F3 _text$x         ends
.text$x:000024F3
.xdata$x:000024F4 ; ===========================================================================
.xdata$x:000024F4
.xdata$x:000024F4 ; Segment type: Pure data
.xdata$x:000024F4 ; Segment permissions: Read
.xdata$x:000024F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000024F4                 assume cs:_xdata$x
.xdata$x:000024F4                 ;org 24F4h
.xdata$x:000024F4 ; COMDAT (pick associative to section at 23FC)
.xdata$x:000024F4 __ehfuncinfo$??1CDirItems@@QAE@XZ db  22h ; "
.xdata$x:000024F4                                         ; DATA XREF: __ehhandler$??1CDirItems@@QAE@XZ+11o
.xdata$x:000024F5                 db    5
.xdata$x:000024F6                 db  93h ; 
.xdata$x:000024F7                 db  19h
.xdata$x:000024F8                 db    5
.xdata$x:000024F9                 db    0
.xdata$x:000024FA                 db    0
.xdata$x:000024FB                 db    0
.xdata$x:000024FC                 dd offset __unwindtable$??1CDirItems@@QAE@XZ
.xdata$x:00002500                 db    0
.xdata$x:00002501                 db    0
.xdata$x:00002502                 db    0
.xdata$x:00002503                 db    0
.xdata$x:00002504                 db    0
.xdata$x:00002505                 db    0
.xdata$x:00002506                 db    0
.xdata$x:00002507                 db    0
.xdata$x:00002508                 db    0
.xdata$x:00002509                 db    0
.xdata$x:0000250A                 db    0
.xdata$x:0000250B                 db    0
.xdata$x:0000250C                 db    0
.xdata$x:0000250D                 db    0
.xdata$x:0000250E                 db    0
.xdata$x:0000250F                 db    0
.xdata$x:00002510                 db    0
.xdata$x:00002511                 db    0
.xdata$x:00002512                 db    0
.xdata$x:00002513                 db    0
.xdata$x:00002514                 db    1
.xdata$x:00002515                 db    0
.xdata$x:00002516                 db    0
.xdata$x:00002517                 db    0
.xdata$x:00002518 __unwindtable$??1CDirItems@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:000024FCo
.xdata$x:00002519                 db 0FFh
.xdata$x:0000251A                 db 0FFh
.xdata$x:0000251B                 db 0FFh
.xdata$x:0000251C                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$0
.xdata$x:00002520                 db    0
.xdata$x:00002521                 db    0
.xdata$x:00002522                 db    0
.xdata$x:00002523                 db    0
.xdata$x:00002524                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$1
.xdata$x:00002528                 db    1
.xdata$x:00002529                 db    0
.xdata$x:0000252A                 db    0
.xdata$x:0000252B                 db    0
.xdata$x:0000252C                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$2
.xdata$x:00002530                 db    2
.xdata$x:00002531                 db    0
.xdata$x:00002532                 db    0
.xdata$x:00002533                 db    0
.xdata$x:00002534                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$3
.xdata$x:00002538                 db    3
.xdata$x:00002539                 db    0
.xdata$x:0000253A                 db    0
.xdata$x:0000253B                 db    0
.xdata$x:0000253C                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$4
.xdata$x:0000253C _xdata$x        ends
.xdata$x:0000253C
.text:00002540 ; ===========================================================================
.text:00002540
.text:00002540 ; Segment type: Pure code
.text:00002540 ; Segment permissions: Read/Execute
.text:00002540 _text           segment para public 'CODE' use32
.text:00002540                 assume cs:_text
.text:00002540                 ;org 2540h
.text:00002540 ; COMDAT (pick any)
.text:00002540                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002540
.text:00002540 ; =============== S U B R O U T I N E =======================================
.text:00002540
.text:00002540 ; Attributes: bp-based frame
.text:00002540
.text:00002540 ; _DWORD __thiscall CDirItem::~CDirItem(CDirItem *__hidden this)
.text:00002540                 public ??1CDirItem@@QAE@XZ
.text:00002540 ??1CDirItem@@QAE@XZ proc near           ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+F0p
.text:00002540                                         ; __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$1+6j ...
.text:00002540
.text:00002540 var_10          = dword ptr -10h
.text:00002540 var_C           = dword ptr -0Ch
.text:00002540 var_4           = dword ptr -4
.text:00002540
.text:00002540                 push    ebp
.text:00002541                 mov     ebp, esp
.text:00002543                 push    0FFFFFFFFh
.text:00002545                 push    offset __ehhandler$??1CDirItem@@QAE@XZ
.text:0000254A                 mov     eax, large fs:0
.text:00002550                 push    eax
.text:00002551                 push    ecx
.text:00002552                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002559                 mov     eax, dword ptr ds:___security_cookie
.text:0000255E                 xor     eax, ebp
.text:00002560                 push    eax
.text:00002561                 lea     eax, [ebp+var_C]
.text:00002564                 mov     large fs:0, eax
.text:0000256A                 mov     [ebp+var_10], ecx
.text:0000256D                 mov     [ebp+var_4], 1
.text:00002574                 mov     ecx, [ebp+var_10]
.text:00002577                 add     ecx, 34h ; '4'
.text:0000257A                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:0000257F                 mov     byte ptr [ebp+var_4], 0
.text:00002583                 mov     ecx, [ebp+var_10]
.text:00002586                 add     ecx, 2Ch ; ','
.text:00002589                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:0000258E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002595                 mov     ecx, [ebp+var_10]
.text:00002598                 add     ecx, 20h ; ' '  ; this
.text:0000259B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000025A0                 mov     ecx, [ebp+var_C]
.text:000025A3                 mov     large fs:0, ecx
.text:000025AA                 pop     ecx
.text:000025AB                 add     esp, 10h
.text:000025AE                 cmp     ebp, esp
.text:000025B0                 call    __RTC_CheckEsp
.text:000025B5                 mov     esp, ebp
.text:000025B7                 pop     ebp
.text:000025B8                 retn
.text:000025B8 ??1CDirItem@@QAE@XZ endp
.text:000025B8
.text:000025B8 ; ---------------------------------------------------------------------------
.text:000025B9                 align 4
.text:000025B9 _text           ends
.text:000025B9
.text$x:000025BC ; ===========================================================================
.text$x:000025BC
.text$x:000025BC ; Segment type: Pure code
.text$x:000025BC ; Segment permissions: Read/Execute
.text$x:000025BC _text$x         segment para public 'CODE' use32
.text$x:000025BC                 assume cs:_text$x
.text$x:000025BC                 ;org 25BCh
.text$x:000025BC ; COMDAT (pick associative to section at 2540)
.text$x:000025BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000025BC
.text$x:000025BC ; =============== S U B R O U T I N E =======================================
.text$x:000025BC
.text$x:000025BC
.text$x:000025BC __unwindfunclet$??1CDirItem@@QAE@XZ$0 proc near
.text$x:000025BC                                         ; DATA XREF: .xdata$x:000025F4o
.text$x:000025BC                 mov     ecx, [ebp-10h]
.text$x:000025BF                 add     ecx, 20h ; ' '  ; this
.text$x:000025C2                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000025C2 __unwindfunclet$??1CDirItem@@QAE@XZ$0 endp
.text$x:000025C2
.text$x:000025C7
.text$x:000025C7 ; =============== S U B R O U T I N E =======================================
.text$x:000025C7
.text$x:000025C7
.text$x:000025C7 __unwindfunclet$??1CDirItem@@QAE@XZ$1 proc near
.text$x:000025C7                                         ; DATA XREF: .xdata$x:000025FCo
.text$x:000025C7                 mov     ecx, [ebp-10h]
.text$x:000025CA                 add     ecx, 2Ch ; ','
.text$x:000025CD                 jmp     ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text$x:000025CD __unwindfunclet$??1CDirItem@@QAE@XZ$1 endp
.text$x:000025CD
.text$x:000025D2
.text$x:000025D2 ; =============== S U B R O U T I N E =======================================
.text$x:000025D2
.text$x:000025D2
.text$x:000025D2 __ehhandler$??1CDirItem@@QAE@XZ proc near
.text$x:000025D2                                         ; DATA XREF: CDirItem::~CDirItem(void)+5o
.text$x:000025D2
.text$x:000025D2 arg_4           = dword ptr  8
.text$x:000025D2
.text$x:000025D2                 mov     edx, [esp+arg_4]
.text$x:000025D6                 lea     eax, [edx+0Ch]
.text$x:000025D9                 mov     ecx, [edx-8]
.text$x:000025DC                 xor     ecx, eax
.text$x:000025DE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000025E3                 mov     eax, offset __ehfuncinfo$??1CDirItem@@QAE@XZ
.text$x:000025E8                 jmp     ___CxxFrameHandler3
.text$x:000025E8 __ehhandler$??1CDirItem@@QAE@XZ endp
.text$x:000025E8
.text$x:000025E8 ; ---------------------------------------------------------------------------
.text$x:000025ED                 align 10h
.text$x:000025ED _text$x         ends
.text$x:000025ED
.xdata$x:000025F0 ; ===========================================================================
.xdata$x:000025F0
.xdata$x:000025F0 ; Segment type: Pure data
.xdata$x:000025F0 ; Segment permissions: Read
.xdata$x:000025F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000025F0                 assume cs:_xdata$x
.xdata$x:000025F0                 ;org 25F0h
.xdata$x:000025F0 ; COMDAT (pick associative to section at 2540)
.xdata$x:000025F0 __unwindtable$??1CDirItem@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:00002608o
.xdata$x:000025F1                 db 0FFh
.xdata$x:000025F2                 db 0FFh
.xdata$x:000025F3                 db 0FFh
.xdata$x:000025F4                 dd offset __unwindfunclet$??1CDirItem@@QAE@XZ$0
.xdata$x:000025F8                 db    0
.xdata$x:000025F9                 db    0
.xdata$x:000025FA                 db    0
.xdata$x:000025FB                 db    0
.xdata$x:000025FC                 dd offset __unwindfunclet$??1CDirItem@@QAE@XZ$1
.xdata$x:00002600 __ehfuncinfo$??1CDirItem@@QAE@XZ db  22h ; "
.xdata$x:00002600                                         ; DATA XREF: __ehhandler$??1CDirItem@@QAE@XZ+11o
.xdata$x:00002601                 db    5
.xdata$x:00002602                 db  93h ; 
.xdata$x:00002603                 db  19h
.xdata$x:00002604                 db    2
.xdata$x:00002605                 db    0
.xdata$x:00002606                 db    0
.xdata$x:00002607                 db    0
.xdata$x:00002608                 dd offset __unwindtable$??1CDirItem@@QAE@XZ
.xdata$x:0000260C                 align 20h
.xdata$x:00002620                 db    1
.xdata$x:00002621                 db    0
.xdata$x:00002622                 db    0
.xdata$x:00002623                 db    0
.xdata$x:00002623 _xdata$x        ends
.xdata$x:00002623
.text:00002624 ; ===========================================================================
.text:00002624
.text:00002624 ; Segment type: Pure code
.text:00002624 ; Segment permissions: Read/Execute
.text:00002624 _text           segment para public 'CODE' use32
.text:00002624                 assume cs:_text
.text:00002624                 ;org 2624h
.text:00002624 ; COMDAT (pick any)
.text:00002624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002624
.text:00002624 ; =============== S U B R O U T I N E =======================================
.text:00002624
.text:00002624 ; Attributes: bp-based frame
.text:00002624
.text:00002624 ; public: __thiscall CHashBundle::CHashBundle(void)
.text:00002624                 public ??0CHashBundle@@QAE@XZ
.text:00002624 ??0CHashBundle@@QAE@XZ proc near        ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+248p
.text:00002624
.text:00002624 var_4           = dword ptr -4
.text:00002624
.text:00002624                 push    ebp
.text:00002625                 mov     ebp, esp
.text:00002627                 push    ecx
.text:00002628                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000262F                 mov     [ebp+var_4], ecx
.text:00002632                 mov     ecx, [ebp+var_4] ; this
.text:00002635                 call    ??0IHashCalc@@QAE@XZ ; IHashCalc::IHashCalc(void)
.text:0000263A                 mov     eax, [ebp+var_4]
.text:0000263D                 mov     dword ptr [eax], offset ??_7CHashBundle@@6B@ ; const CHashBundle::`vftable'
.text:00002643                 mov     ecx, [ebp+var_4]
.text:00002646                 add     ecx, 4
.text:00002649                 call    ??0?$CObjectVector@UCHasherState@@@@QAE@XZ ; CObjectVector<CHasherState>::CObjectVector<CHasherState>(void)
.text:0000264E                 mov     eax, [ebp+var_4]
.text:00002651                 add     esp, 4
.text:00002654                 cmp     ebp, esp
.text:00002656                 call    __RTC_CheckEsp
.text:0000265B                 mov     esp, ebp
.text:0000265D                 pop     ebp
.text:0000265E                 retn
.text:0000265E ??0CHashBundle@@QAE@XZ endp
.text:0000265E
.text:0000265E ; ---------------------------------------------------------------------------
.text:0000265F                 align 10h
.text:0000265F _text           ends
.text:0000265F
.rdata:00002660 ; ===========================================================================
.rdata:00002660
.rdata:00002660 ; Segment type: Pure data
.rdata:00002660 ; Segment permissions: Read
.rdata:00002660 _rdata          segment dword public 'DATA' use32
.rdata:00002660                 assume cs:_rdata
.rdata:00002660                 ;org 2660h
.rdata:00002660 ; COMDAT (pick largest)
.rdata:00002660                 dd offset ??_R4CHashBundle@@6B@ ; const CHashBundle::`RTTI Complete Object Locator'
.rdata:00002664                 public ??_7CHashBundle@@6B@
.rdata:00002664 ; const CHashBundle::`vftable'
.rdata:00002664 ??_7CHashBundle@@6B@ dd offset ?InitForNewFile@CHashBundle@@UAEXXZ
.rdata:00002664                                         ; DATA XREF: CHashBundle::CHashBundle(void)+19o
.rdata:00002664                                         ; CHashBundle::InitForNewFile(void)
.rdata:00002668                 dd offset ?Update@CHashBundle@@UAEXPBXI@Z ; CHashBundle::Update(void const *,uint)
.rdata:0000266C                 dd offset ?SetSize@CHashBundle@@UAEX_K@Z ; CHashBundle::SetSize(unsigned __int64)
.rdata:00002670                 dd offset ?Final@CHashBundle@@UAEX_N0ABVUString@@@Z ; CHashBundle::Final(bool,bool,UString const &)
.rdata:00002670 _rdata          ends
.rdata:00002670
.rdata$r:00002674 ; ===========================================================================
.rdata$r:00002674
.rdata$r:00002674 ; Segment type: Pure data
.rdata$r:00002674 ; Segment permissions: Read
.rdata$r:00002674 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002674                 assume cs:_rdata$r
.rdata$r:00002674                 ;org 2674h
.rdata$r:00002674 ; COMDAT (pick any)
.rdata$r:00002674                 public ??_R4CHashBundle@@6B@
.rdata$r:00002674 ; const CHashBundle::`RTTI Complete Object Locator'
.rdata$r:00002674 ??_R4CHashBundle@@6B@ db    0           ; DATA XREF: .rdata:00002660o
.rdata$r:00002675                 db    0
.rdata$r:00002676                 db    0
.rdata$r:00002677                 db    0
.rdata$r:00002678                 db    0
.rdata$r:00002679                 db    0
.rdata$r:0000267A                 db    0
.rdata$r:0000267B                 db    0
.rdata$r:0000267C                 db    0
.rdata$r:0000267D                 db    0
.rdata$r:0000267E                 db    0
.rdata$r:0000267F                 db    0
.rdata$r:00002680                 dd offset ??_R0?AUCHashBundle@@@8 ; CHashBundle `RTTI Type Descriptor'
.rdata$r:00002684                 dd offset ??_R3CHashBundle@@8 ; CHashBundle::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002684 _rdata$r        ends
.rdata$r:00002684
.data:00002688 ; ===========================================================================
.data:00002688
.data:00002688 ; Segment type: Pure data
.data:00002688 ; Segment permissions: Read/Write
.data:00002688 _data           segment dword public 'DATA' use32
.data:00002688                 assume cs:_data
.data:00002688                 ;org 2688h
.data:00002688 ; COMDAT (pick any)
.data:00002688                 public ??_R0?AUCHashBundle@@@8
.data:00002688 ; struct CHashBundle `RTTI Type Descriptor'
.data:00002688 ??_R0?AUCHashBundle@@@8 dd offset ??_7type_info@@6B@
.data:00002688                                         ; DATA XREF: .rdata$r:00002680o
.data:00002688                                         ; .rdata$r:CHashBundle::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00002688                                         ; const type_info::`vftable'
.data:0000268C                 align 10h
.data:00002690 a_?auchashbundl db '.?AUCHashBundle@@',0
.data:000026A2                 align 4
.data:000026A2 _data           ends
.data:000026A2
.rdata$r:000026A4 ; ===========================================================================
.rdata$r:000026A4
.rdata$r:000026A4 ; Segment type: Pure data
.rdata$r:000026A4 ; Segment permissions: Read
.rdata$r:000026A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026A4                 assume cs:_rdata$r
.rdata$r:000026A4                 ;org 26A4h
.rdata$r:000026A4 ; COMDAT (pick any)
.rdata$r:000026A4                 public ??_R3CHashBundle@@8
.rdata$r:000026A4 ; CHashBundle::`RTTI Class Hierarchy Descriptor'
.rdata$r:000026A4 ??_R3CHashBundle@@8 db    0             ; DATA XREF: .rdata$r:00002684o
.rdata$r:000026A4                                         ; .rdata$r:000026D8o
.rdata$r:000026A5                 db    0
.rdata$r:000026A6                 db    0
.rdata$r:000026A7                 db    0
.rdata$r:000026A8                 db    0
.rdata$r:000026A9                 db    0
.rdata$r:000026AA                 db    0
.rdata$r:000026AB                 db    0
.rdata$r:000026AC                 db    2
.rdata$r:000026AD                 db    0
.rdata$r:000026AE                 db    0
.rdata$r:000026AF                 db    0
.rdata$r:000026B0                 dd offset ??_R2CHashBundle@@8 ; CHashBundle::`RTTI Base Class Array'
.rdata$r:000026B0 _rdata$r        ends
.rdata$r:000026B0
.rdata$r:000026B4 ; ===========================================================================
.rdata$r:000026B4
.rdata$r:000026B4 ; Segment type: Pure data
.rdata$r:000026B4 ; Segment permissions: Read
.rdata$r:000026B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026B4                 assume cs:_rdata$r
.rdata$r:000026B4                 ;org 26B4h
.rdata$r:000026B4 ; COMDAT (pick any)
.rdata$r:000026B4                 public ??_R2CHashBundle@@8
.rdata$r:000026B4 ; CHashBundle::`RTTI Base Class Array'
.rdata$r:000026B4 ??_R2CHashBundle@@8 dd offset ??_R1A@?0A@EA@CHashBundle@@8
.rdata$r:000026B4                                         ; DATA XREF: .rdata$r:000026B0o
.rdata$r:000026B4                                         ; CHashBundle::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000026B8                 dd offset ??_R1A@?0A@EA@IHashCalc@@8 ; IHashCalc::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000026BC                 db    0
.rdata$r:000026BD                 align 10h
.rdata$r:000026BD _rdata$r        ends
.rdata$r:000026BD
.rdata$r:000026C0 ; ===========================================================================
.rdata$r:000026C0
.rdata$r:000026C0 ; Segment type: Pure data
.rdata$r:000026C0 ; Segment permissions: Read
.rdata$r:000026C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026C0                 assume cs:_rdata$r
.rdata$r:000026C0                 ;org 26C0h
.rdata$r:000026C0 ; COMDAT (pick any)
.rdata$r:000026C0                 public ??_R1A@?0A@EA@CHashBundle@@8
.rdata$r:000026C0 ; CHashBundle::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000026C0 ??_R1A@?0A@EA@CHashBundle@@8 dd offset ??_R0?AUCHashBundle@@@8
.rdata$r:000026C0                                         ; DATA XREF: .rdata$r:CHashBundle::`RTTI Base Class Array'o
.rdata$r:000026C0                                         ; CHashBundle `RTTI Type Descriptor'
.rdata$r:000026C4                 db    1
.rdata$r:000026C5                 db    0
.rdata$r:000026C6                 db    0
.rdata$r:000026C7                 db    0
.rdata$r:000026C8                 db    0
.rdata$r:000026C9                 db    0
.rdata$r:000026CA                 db    0
.rdata$r:000026CB                 db    0
.rdata$r:000026CC                 db 0FFh
.rdata$r:000026CD                 db 0FFh
.rdata$r:000026CE                 db 0FFh
.rdata$r:000026CF                 db 0FFh
.rdata$r:000026D0                 db    0
.rdata$r:000026D1                 db    0
.rdata$r:000026D2                 db    0
.rdata$r:000026D3                 db    0
.rdata$r:000026D4                 db  40h ; @
.rdata$r:000026D5                 db    0
.rdata$r:000026D6                 db    0
.rdata$r:000026D7                 db    0
.rdata$r:000026D8                 dd offset ??_R3CHashBundle@@8 ; CHashBundle::`RTTI Class Hierarchy Descriptor'
.rdata$r:000026D8 _rdata$r        ends
.rdata$r:000026D8
.rdata$r:000026DC ; ===========================================================================
.rdata$r:000026DC
.rdata$r:000026DC ; Segment type: Pure data
.rdata$r:000026DC ; Segment permissions: Read
.rdata$r:000026DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026DC                 assume cs:_rdata$r
.rdata$r:000026DC                 ;org 26DCh
.rdata$r:000026DC ; COMDAT (pick any)
.rdata$r:000026DC                 public ??_R1A@?0A@EA@IHashCalc@@8
.rdata$r:000026DC ; IHashCalc::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000026DC ??_R1A@?0A@EA@IHashCalc@@8 dd offset ??_R0?AUIHashCalc@@@8
.rdata$r:000026DC                                         ; DATA XREF: .rdata$r:000026B8o
.rdata$r:000026DC                                         ; .rdata$r:IHashCalc::`RTTI Base Class Array'o
.rdata$r:000026DC                                         ; IHashCalc `RTTI Type Descriptor'
.rdata$r:000026E0                 db    0
.rdata$r:000026E1                 db    0
.rdata$r:000026E2                 db    0
.rdata$r:000026E3                 db    0
.rdata$r:000026E4                 db    0
.rdata$r:000026E5                 db    0
.rdata$r:000026E6                 db    0
.rdata$r:000026E7                 db    0
.rdata$r:000026E8                 db 0FFh
.rdata$r:000026E9                 db 0FFh
.rdata$r:000026EA                 db 0FFh
.rdata$r:000026EB                 db 0FFh
.rdata$r:000026EC                 db    0
.rdata$r:000026ED                 db    0
.rdata$r:000026EE                 db    0
.rdata$r:000026EF                 db    0
.rdata$r:000026F0                 db  40h ; @
.rdata$r:000026F1                 db    0
.rdata$r:000026F2                 db    0
.rdata$r:000026F3                 db    0
.rdata$r:000026F4                 dd offset ??_R3IHashCalc@@8 ; IHashCalc::`RTTI Class Hierarchy Descriptor'
.rdata$r:000026F4 _rdata$r        ends
.rdata$r:000026F4
.data:000026F8 ; ===========================================================================
.data:000026F8
.data:000026F8 ; Segment type: Pure data
.data:000026F8 ; Segment permissions: Read/Write
.data:000026F8 _data           segment dword public 'DATA' use32
.data:000026F8                 assume cs:_data
.data:000026F8                 ;org 26F8h
.data:000026F8 ; COMDAT (pick any)
.data:000026F8                 public ??_R0?AUIHashCalc@@@8
.data:000026F8 ; struct IHashCalc `RTTI Type Descriptor'
.data:000026F8 ??_R0?AUIHashCalc@@@8 dd offset ??_7type_info@@6B@
.data:000026F8                                         ; DATA XREF: .rdata$r:IHashCalc::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000026F8                                         ; .rdata$r:00002C04o
.data:000026F8                                         ; const type_info::`vftable'
.data:000026FC                 align 10h
.data:00002700 a_?auihashcalc@ db '.?AUIHashCalc@@',0
.data:00002700 _data           ends
.data:00002700
.rdata$r:00002710 ; ===========================================================================
.rdata$r:00002710
.rdata$r:00002710 ; Segment type: Pure data
.rdata$r:00002710 ; Segment permissions: Read
.rdata$r:00002710 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002710                 assume cs:_rdata$r
.rdata$r:00002710                 ;org 2710h
.rdata$r:00002710 ; COMDAT (pick any)
.rdata$r:00002710                 public ??_R3IHashCalc@@8
.rdata$r:00002710 ; IHashCalc::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002710 ??_R3IHashCalc@@8 db    0               ; DATA XREF: .rdata$r:000026F4o
.rdata$r:00002710                                         ; .rdata$r:00002C08o
.rdata$r:00002711                 db    0
.rdata$r:00002712                 db    0
.rdata$r:00002713                 db    0
.rdata$r:00002714                 db    0
.rdata$r:00002715                 db    0
.rdata$r:00002716                 db    0
.rdata$r:00002717                 db    0
.rdata$r:00002718                 db    1
.rdata$r:00002719                 db    0
.rdata$r:0000271A                 db    0
.rdata$r:0000271B                 db    0
.rdata$r:0000271C                 dd offset ??_R2IHashCalc@@8 ; IHashCalc::`RTTI Base Class Array'
.rdata$r:0000271C _rdata$r        ends
.rdata$r:0000271C
.rdata$r:00002720 ; ===========================================================================
.rdata$r:00002720
.rdata$r:00002720 ; Segment type: Pure data
.rdata$r:00002720 ; Segment permissions: Read
.rdata$r:00002720 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002720                 assume cs:_rdata$r
.rdata$r:00002720                 ;org 2720h
.rdata$r:00002720 ; COMDAT (pick any)
.rdata$r:00002720                 public ??_R2IHashCalc@@8
.rdata$r:00002720 ; IHashCalc::`RTTI Base Class Array'
.rdata$r:00002720 ??_R2IHashCalc@@8 dd offset ??_R1A@?0A@EA@IHashCalc@@8
.rdata$r:00002720                                         ; DATA XREF: .rdata$r:0000271Co
.rdata$r:00002720                                         ; IHashCalc::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002724                 db    0
.rdata$r:00002725                 align 4
.rdata$r:00002725 _rdata$r        ends
.rdata$r:00002725
.text:00002728 ; ===========================================================================
.text:00002728
.text:00002728 ; Segment type: Pure code
.text:00002728 ; Segment permissions: Read/Execute
.text:00002728 _text           segment para public 'CODE' use32
.text:00002728                 assume cs:_text
.text:00002728                 ;org 2728h
.text:00002728 ; COMDAT (pick any)
.text:00002728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002728
.text:00002728 ; =============== S U B R O U T I N E =======================================
.text:00002728
.text:00002728 ; Attributes: bp-based frame
.text:00002728
.text:00002728 ; _DWORD __thiscall CHashBundle::~CHashBundle(CHashBundle *__hidden this)
.text:00002728                 public ??1CHashBundle@@QAE@XZ
.text:00002728 ??1CHashBundle@@QAE@XZ proc near        ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+285p
.text:00002728                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+30Ep ...
.text:00002728
.text:00002728 var_4           = dword ptr -4
.text:00002728
.text:00002728                 push    ebp
.text:00002729                 mov     ebp, esp
.text:0000272B                 push    ecx
.text:0000272C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002733                 mov     [ebp+var_4], ecx
.text:00002736                 mov     ecx, [ebp+var_4]
.text:00002739                 add     ecx, 4
.text:0000273C                 call    ??1?$CObjectVector@UCHasherState@@@@QAE@XZ ; CObjectVector<CHasherState>::~CObjectVector<CHasherState>(void)
.text:00002741                 add     esp, 4
.text:00002744                 cmp     ebp, esp
.text:00002746                 call    __RTC_CheckEsp
.text:0000274B                 mov     esp, ebp
.text:0000274D                 pop     ebp
.text:0000274E                 retn
.text:0000274E ??1CHashBundle@@QAE@XZ endp
.text:0000274E
.text:0000274E ; ---------------------------------------------------------------------------
.text:0000274F                 align 10h
.text:0000274F _text           ends
.text:0000274F
.text:00002750 ; ===========================================================================
.text:00002750
.text:00002750 ; Segment type: Pure code
.text:00002750 ; Segment permissions: Read/Execute
.text:00002750 _text           segment para public 'CODE' use32
.text:00002750                 assume cs:_text
.text:00002750                 ;org 2750h
.text:00002750 ; COMDAT (pick any)
.text:00002750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002750
.text:00002750 ; =============== S U B R O U T I N E =======================================
.text:00002750
.text:00002750 ; Attributes: bp-based frame
.text:00002750
.text:00002750 ; public: __thiscall CStdInFileStream::CStdInFileStream(void)
.text:00002750                 public ??0CStdInFileStream@@QAE@XZ
.text:00002750 ??0CStdInFileStream@@QAE@XZ proc near   ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+521p
.text:00002750
.text:00002750 var_4           = dword ptr -4
.text:00002750
.text:00002750                 push    ebp
.text:00002751                 mov     ebp, esp
.text:00002753                 push    ecx
.text:00002754                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000275B                 mov     [ebp+var_4], ecx
.text:0000275E                 mov     ecx, [ebp+var_4] ; this
.text:00002761                 call    ??0ISequentialInStream@@QAE@XZ ; ISequentialInStream::ISequentialInStream(void)
.text:00002766                 mov     ecx, [ebp+var_4]
.text:00002769                 add     ecx, 4          ; this
.text:0000276C                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:00002771                 mov     eax, [ebp+var_4]
.text:00002774                 mov     dword ptr [eax], offset ??_7CStdInFileStream@@6B@ ; const CStdInFileStream::`vftable'
.text:0000277A                 mov     eax, [ebp+var_4]
.text:0000277D                 add     esp, 4
.text:00002780                 cmp     ebp, esp
.text:00002782                 call    __RTC_CheckEsp
.text:00002787                 mov     esp, ebp
.text:00002789                 pop     ebp
.text:0000278A                 retn
.text:0000278A ??0CStdInFileStream@@QAE@XZ endp
.text:0000278A
.text:0000278A ; ---------------------------------------------------------------------------
.text:0000278B                 align 4
.text:0000278B _text           ends
.text:0000278B
.rdata:0000278C ; ===========================================================================
.rdata:0000278C
.rdata:0000278C ; Segment type: Pure data
.rdata:0000278C ; Segment permissions: Read
.rdata:0000278C _rdata          segment dword public 'DATA' use32
.rdata:0000278C                 assume cs:_rdata
.rdata:0000278C                 ;org 278Ch
.rdata:0000278C ; COMDAT (pick largest)
.rdata:0000278C                 dd offset ??_R4CStdInFileStream@@6B@ ; const CStdInFileStream::`RTTI Complete Object Locator'
.rdata:00002790                 public ??_7CStdInFileStream@@6B@
.rdata:00002790 ; const CStdInFileStream::`vftable'
.rdata:00002790 ??_7CStdInFileStream@@6B@ dd offset ?QueryInterface@CStdInFileStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:00002790                                         ; DATA XREF: CStdInFileStream::CStdInFileStream(void)+24o
.rdata:00002790                                         ; CStdInFileStream::~CStdInFileStream(void)+11o
.rdata:00002790                                         ; CStdInFileStream::QueryInterface(_GUID const &,void * *)
.rdata:00002794                 dd offset ?AddRef@CStdInFileStream@@UAGKXZ ; CStdInFileStream::AddRef(void)
.rdata:00002798                 dd offset ?Release@CStdInFileStream@@UAGKXZ ; CStdInFileStream::Release(void)
.rdata:0000279C                 dd offset ?Read@CStdInFileStream@@UAGJPAXIPAI@Z ; CStdInFileStream::Read(void *,uint,uint *)
.rdata:000027A0                 dd offset ??_ECStdInFileStream@@UAEPAXI@Z ; CStdInFileStream::`vector deleting destructor'(uint)
.rdata:000027A0 _rdata          ends
.rdata:000027A0
.rdata$r:000027A4 ; ===========================================================================
.rdata$r:000027A4
.rdata$r:000027A4 ; Segment type: Pure data
.rdata$r:000027A4 ; Segment permissions: Read
.rdata$r:000027A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027A4                 assume cs:_rdata$r
.rdata$r:000027A4                 ;org 27A4h
.rdata$r:000027A4 ; COMDAT (pick any)
.rdata$r:000027A4                 public ??_R4CStdInFileStream@@6B@
.rdata$r:000027A4 ; const CStdInFileStream::`RTTI Complete Object Locator'
.rdata$r:000027A4 ??_R4CStdInFileStream@@6B@ db    0      ; DATA XREF: .rdata:0000278Co
.rdata$r:000027A5                 db    0
.rdata$r:000027A6                 db    0
.rdata$r:000027A7                 db    0
.rdata$r:000027A8                 db    0
.rdata$r:000027A9                 db    0
.rdata$r:000027AA                 db    0
.rdata$r:000027AB                 db    0
.rdata$r:000027AC                 db    0
.rdata$r:000027AD                 db    0
.rdata$r:000027AE                 db    0
.rdata$r:000027AF                 db    0
.rdata$r:000027B0                 dd offset ??_R0?AVCStdInFileStream@@@8 ; CStdInFileStream `RTTI Type Descriptor'
.rdata$r:000027B4                 dd offset ??_R3CStdInFileStream@@8 ; CStdInFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027B4 _rdata$r        ends
.rdata$r:000027B4
.data:000027B8 ; ===========================================================================
.data:000027B8
.data:000027B8 ; Segment type: Pure data
.data:000027B8 ; Segment permissions: Read/Write
.data:000027B8 _data           segment dword public 'DATA' use32
.data:000027B8                 assume cs:_data
.data:000027B8                 ;org 27B8h
.data:000027B8 ; COMDAT (pick any)
.data:000027B8                 public ??_R0?AVCStdInFileStream@@@8
.data:000027B8 ; class CStdInFileStream `RTTI Type Descriptor'
.data:000027B8 ??_R0?AVCStdInFileStream@@@8 dd offset ??_7type_info@@6B@
.data:000027B8                                         ; DATA XREF: .rdata$r:000027B0o
.data:000027B8                                         ; .rdata$r:CStdInFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000027B8                                         ; const type_info::`vftable'
.data:000027BC                 align 10h
.data:000027C0 a_?avcstdinfile db '.?AVCStdInFileStream@@',0
.data:000027D7                 align 4
.data:000027D7 _data           ends
.data:000027D7
.rdata$r:000027D8 ; ===========================================================================
.rdata$r:000027D8
.rdata$r:000027D8 ; Segment type: Pure data
.rdata$r:000027D8 ; Segment permissions: Read
.rdata$r:000027D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027D8                 assume cs:_rdata$r
.rdata$r:000027D8                 ;org 27D8h
.rdata$r:000027D8 ; COMDAT (pick any)
.rdata$r:000027D8                 public ??_R3CStdInFileStream@@8
.rdata$r:000027D8 ; CStdInFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027D8 ??_R3CStdInFileStream@@8 db    0        ; DATA XREF: .rdata$r:000027B4o
.rdata$r:000027D8                                         ; .rdata$r:00002814o
.rdata$r:000027D9                 db    0
.rdata$r:000027DA                 db    0
.rdata$r:000027DB                 db    0
.rdata$r:000027DC                 db    1
.rdata$r:000027DD                 db    0
.rdata$r:000027DE                 db    0
.rdata$r:000027DF                 db    0
.rdata$r:000027E0                 db    4
.rdata$r:000027E1                 db    0
.rdata$r:000027E2                 db    0
.rdata$r:000027E3                 db    0
.rdata$r:000027E4                 dd offset ??_R2CStdInFileStream@@8 ; CStdInFileStream::`RTTI Base Class Array'
.rdata$r:000027E4 _rdata$r        ends
.rdata$r:000027E4
.rdata$r:000027E8 ; ===========================================================================
.rdata$r:000027E8
.rdata$r:000027E8 ; Segment type: Pure data
.rdata$r:000027E8 ; Segment permissions: Read
.rdata$r:000027E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027E8                 assume cs:_rdata$r
.rdata$r:000027E8                 ;org 27E8h
.rdata$r:000027E8 ; COMDAT (pick any)
.rdata$r:000027E8                 public ??_R2CStdInFileStream@@8
.rdata$r:000027E8 ; CStdInFileStream::`RTTI Base Class Array'
.rdata$r:000027E8 ??_R2CStdInFileStream@@8 dd offset ??_R1A@?0A@EA@CStdInFileStream@@8
.rdata$r:000027E8                                         ; DATA XREF: .rdata$r:000027E4o
.rdata$r:000027E8                                         ; CStdInFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027EC                 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027F0                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027F4                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:000027F8                 db    0
.rdata$r:000027F9                 align 4
.rdata$r:000027F9 _rdata$r        ends
.rdata$r:000027F9
.rdata$r:000027FC ; ===========================================================================
.rdata$r:000027FC
.rdata$r:000027FC ; Segment type: Pure data
.rdata$r:000027FC ; Segment permissions: Read
.rdata$r:000027FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027FC                 assume cs:_rdata$r
.rdata$r:000027FC                 ;org 27FCh
.rdata$r:000027FC ; COMDAT (pick any)
.rdata$r:000027FC                 public ??_R1A@?0A@EA@CStdInFileStream@@8
.rdata$r:000027FC ; CStdInFileStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000027FC ??_R1A@?0A@EA@CStdInFileStream@@8 dd offset ??_R0?AVCStdInFileStream@@@8
.rdata$r:000027FC                                         ; DATA XREF: .rdata$r:CStdInFileStream::`RTTI Base Class Array'o
.rdata$r:000027FC                                         ; CStdInFileStream `RTTI Type Descriptor'
.rdata$r:00002800                 db    3
.rdata$r:00002801                 db    0
.rdata$r:00002802                 db    0
.rdata$r:00002803                 db    0
.rdata$r:00002804                 db    0
.rdata$r:00002805                 db    0
.rdata$r:00002806                 db    0
.rdata$r:00002807                 db    0
.rdata$r:00002808                 db 0FFh
.rdata$r:00002809                 db 0FFh
.rdata$r:0000280A                 db 0FFh
.rdata$r:0000280B                 db 0FFh
.rdata$r:0000280C                 db    0
.rdata$r:0000280D                 db    0
.rdata$r:0000280E                 db    0
.rdata$r:0000280F                 db    0
.rdata$r:00002810                 db  40h ; @
.rdata$r:00002811                 db    0
.rdata$r:00002812                 db    0
.rdata$r:00002813                 db    0
.rdata$r:00002814                 dd offset ??_R3CStdInFileStream@@8 ; CStdInFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002814 _rdata$r        ends
.rdata$r:00002814
.rdata$r:00002818 ; ===========================================================================
.rdata$r:00002818
.rdata$r:00002818 ; Segment type: Pure data
.rdata$r:00002818 ; Segment permissions: Read
.rdata$r:00002818 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002818                 assume cs:_rdata$r
.rdata$r:00002818                 ;org 2818h
.rdata$r:00002818 ; COMDAT (pick any)
.rdata$r:00002818                 public ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:00002818 ; ISequentialInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002818 ??_R1A@?0A@EA@ISequentialInStream@@8 dd offset ??_R0?AUISequentialInStream@@@8
.rdata$r:00002818                                         ; DATA XREF: .rdata$r:000027ECo
.rdata$r:00002818                                         ; .rdata$r:ISequentialInStream::`RTTI Base Class Array'o
.rdata$r:00002818                                         ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:0000281C                 db    1
.rdata$r:0000281D                 db    0
.rdata$r:0000281E                 db    0
.rdata$r:0000281F                 db    0
.rdata$r:00002820                 db    0
.rdata$r:00002821                 db    0
.rdata$r:00002822                 db    0
.rdata$r:00002823                 db    0
.rdata$r:00002824                 db 0FFh
.rdata$r:00002825                 db 0FFh
.rdata$r:00002826                 db 0FFh
.rdata$r:00002827                 db 0FFh
.rdata$r:00002828                 db    0
.rdata$r:00002829                 db    0
.rdata$r:0000282A                 db    0
.rdata$r:0000282B                 db    0
.rdata$r:0000282C                 db  40h ; @
.rdata$r:0000282D                 db    0
.rdata$r:0000282E                 db    0
.rdata$r:0000282F                 db    0
.rdata$r:00002830                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002830 _rdata$r        ends
.rdata$r:00002830
.data:00002834 ; ===========================================================================
.data:00002834
.data:00002834 ; Segment type: Pure data
.data:00002834 ; Segment permissions: Read/Write
.data:00002834 _data           segment dword public 'DATA' use32
.data:00002834                 assume cs:_data
.data:00002834                 ;org 2834h
.data:00002834 ; COMDAT (pick any)
.data:00002834                 public ??_R0?AUISequentialInStream@@@8
.data:00002834 ; struct ISequentialInStream `RTTI Type Descriptor'
.data:00002834 ??_R0?AUISequentialInStream@@@8 dd offset ??_7type_info@@6B@
.data:00002834                                         ; DATA XREF: .rdata$r:ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00002834                                         ; .rdata$r:00002C5Co
.data:00002834                                         ; const type_info::`vftable'
.data:00002838                 db    0
.data:00002839                 db    0
.data:0000283A                 db    0
.data:0000283B                 db    0
.data:0000283C                 db  2Eh ; .
.data:0000283D                 db  3Fh ; ?
.data:0000283E                 db  41h ; A
.data:0000283F                 db  55h ; U
.data:00002840                 db  49h ; I
.data:00002841                 db  53h ; S
.data:00002842                 db  65h ; e
.data:00002843                 db  71h ; q
.data:00002844                 db  75h ; u
.data:00002845                 db  65h ; e
.data:00002846                 db  6Eh ; n
.data:00002847                 db  74h ; t
.data:00002848                 db  69h ; i
.data:00002849                 db  61h ; a
.data:0000284A                 db  6Ch ; l
.data:0000284B                 db  49h ; I
.data:0000284C                 db  6Eh ; n
.data:0000284D                 db  53h ; S
.data:0000284E                 db  74h ; t
.data:0000284F                 db  72h ; r
.data:00002850                 db  65h ; e
.data:00002851                 db  61h ; a
.data:00002852                 db  6Dh ; m
.data:00002853                 db  40h ; @
.data:00002854                 db  40h ; @
.data:00002855                 db    0
.data:00002856                 align 4
.data:00002856 _data           ends
.data:00002856
.rdata$r:00002858 ; ===========================================================================
.rdata$r:00002858
.rdata$r:00002858 ; Segment type: Pure data
.rdata$r:00002858 ; Segment permissions: Read
.rdata$r:00002858 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002858                 assume cs:_rdata$r
.rdata$r:00002858                 ;org 2858h
.rdata$r:00002858 ; COMDAT (pick any)
.rdata$r:00002858                 public ??_R3ISequentialInStream@@8
.rdata$r:00002858 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002858 ??_R3ISequentialInStream@@8 db    0     ; DATA XREF: .rdata$r:00002830o
.rdata$r:00002858                                         ; .rdata$r:00002C60o
.rdata$r:00002859                 db    0
.rdata$r:0000285A                 db    0
.rdata$r:0000285B                 db    0
.rdata$r:0000285C                 db    0
.rdata$r:0000285D                 db    0
.rdata$r:0000285E                 db    0
.rdata$r:0000285F                 db    0
.rdata$r:00002860                 db    2
.rdata$r:00002861                 db    0
.rdata$r:00002862                 db    0
.rdata$r:00002863                 db    0
.rdata$r:00002864                 dd offset ??_R2ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:00002864 _rdata$r        ends
.rdata$r:00002864
.rdata$r:00002868 ; ===========================================================================
.rdata$r:00002868
.rdata$r:00002868 ; Segment type: Pure data
.rdata$r:00002868 ; Segment permissions: Read
.rdata$r:00002868 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002868                 assume cs:_rdata$r
.rdata$r:00002868                 ;org 2868h
.rdata$r:00002868 ; COMDAT (pick any)
.rdata$r:00002868                 public ??_R2ISequentialInStream@@8
.rdata$r:00002868 ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:00002868 ??_R2ISequentialInStream@@8 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:00002868                                         ; DATA XREF: .rdata$r:00002864o
.rdata$r:00002868                                         ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000286C                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002870                 db    0
.rdata$r:00002871                 align 4
.rdata$r:00002871 _rdata$r        ends
.rdata$r:00002871
.rdata$r:00002874 ; ===========================================================================
.rdata$r:00002874
.rdata$r:00002874 ; Segment type: Pure data
.rdata$r:00002874 ; Segment permissions: Read
.rdata$r:00002874 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002874                 assume cs:_rdata$r
.rdata$r:00002874                 ;org 2874h
.rdata$r:00002874 ; COMDAT (pick any)
.rdata$r:00002874                 public ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:00002874 ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002874 ??_R1A@?0A@EA@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:00002874                                         ; DATA XREF: .rdata$r:000027F0o
.rdata$r:00002874                                         ; .rdata$r:0000286Co ...
.rdata$r:00002874                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00002878                 align 10h
.rdata$r:00002880                 db 0FFh
.rdata$r:00002881                 db 0FFh
.rdata$r:00002882                 db 0FFh
.rdata$r:00002883                 db 0FFh
.rdata$r:00002884                 db    0
.rdata$r:00002885                 db    0
.rdata$r:00002886                 db    0
.rdata$r:00002887                 db    0
.rdata$r:00002888                 db  40h ; @
.rdata$r:00002889                 db    0
.rdata$r:0000288A                 db    0
.rdata$r:0000288B                 db    0
.rdata$r:0000288C                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000288C _rdata$r        ends
.rdata$r:0000288C
.data:00002890 ; ===========================================================================
.data:00002890
.data:00002890 ; Segment type: Pure data
.data:00002890 ; Segment permissions: Read/Write
.data:00002890 _data           segment dword public 'DATA' use32
.data:00002890                 assume cs:_data
.data:00002890                 ;org 2890h
.data:00002890 ; COMDAT (pick any)
.data:00002890                 public ??_R0?AUIUnknown@@@8
.data:00002890 ; struct IUnknown `RTTI Type Descriptor'
.data:00002890 ??_R0?AUIUnknown@@@8 dd offset ??_7type_info@@6B@
.data:00002890                                         ; DATA XREF: .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00002890                                         ; const type_info::`vftable'
.data:00002894                 align 8
.data:00002898 a_?auiunknown@@ db '.?AUIUnknown@@',0
.data:000028A7                 align 4
.data:000028A7 _data           ends
.data:000028A7
.rdata$r:000028A8 ; ===========================================================================
.rdata$r:000028A8
.rdata$r:000028A8 ; Segment type: Pure data
.rdata$r:000028A8 ; Segment permissions: Read
.rdata$r:000028A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028A8                 assume cs:_rdata$r
.rdata$r:000028A8                 ;org 28A8h
.rdata$r:000028A8 ; COMDAT (pick any)
.rdata$r:000028A8                 public ??_R3IUnknown@@8
.rdata$r:000028A8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028A8 ??_R3IUnknown@@8 db    0                ; DATA XREF: .rdata$r:0000288Co
.rdata$r:000028A9                 db    0
.rdata$r:000028AA                 db    0
.rdata$r:000028AB                 db    0
.rdata$r:000028AC                 db    0
.rdata$r:000028AD                 db    0
.rdata$r:000028AE                 db    0
.rdata$r:000028AF                 db    0
.rdata$r:000028B0                 db    1
.rdata$r:000028B1                 db    0
.rdata$r:000028B2                 db    0
.rdata$r:000028B3                 db    0
.rdata$r:000028B4                 dd offset ??_R2IUnknown@@8 ; IUnknown::`RTTI Base Class Array'
.rdata$r:000028B4 _rdata$r        ends
.rdata$r:000028B4
.rdata$r:000028B8 ; ===========================================================================
.rdata$r:000028B8
.rdata$r:000028B8 ; Segment type: Pure data
.rdata$r:000028B8 ; Segment permissions: Read
.rdata$r:000028B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028B8                 assume cs:_rdata$r
.rdata$r:000028B8                 ;org 28B8h
.rdata$r:000028B8 ; COMDAT (pick any)
.rdata$r:000028B8                 public ??_R2IUnknown@@8
.rdata$r:000028B8 ; IUnknown::`RTTI Base Class Array'
.rdata$r:000028B8 ??_R2IUnknown@@8 dd offset ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:000028B8                                         ; DATA XREF: .rdata$r:000028B4o
.rdata$r:000028B8                                         ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000028BC                 db    0
.rdata$r:000028BD                 align 10h
.rdata$r:000028BD _rdata$r        ends
.rdata$r:000028BD
.rdata$r:000028C0 ; ===========================================================================
.rdata$r:000028C0
.rdata$r:000028C0 ; Segment type: Pure data
.rdata$r:000028C0 ; Segment permissions: Read
.rdata$r:000028C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028C0                 assume cs:_rdata$r
.rdata$r:000028C0                 ;org 28C0h
.rdata$r:000028C0 ; COMDAT (pick any)
.rdata$r:000028C0                 public ??_R13?0A@EA@CMyUnknownImp@@8
.rdata$r:000028C0 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:000028C0 ??_R13?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:000028C0                                         ; DATA XREF: .rdata$r:000027F4o
.rdata$r:000028C0                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:000028C4                 align 8
.rdata$r:000028C8                 db    4
.rdata$r:000028C9                 db    0
.rdata$r:000028CA                 db    0
.rdata$r:000028CB                 db    0
.rdata$r:000028CC                 db 0FFh
.rdata$r:000028CD                 db 0FFh
.rdata$r:000028CE                 db 0FFh
.rdata$r:000028CF                 db 0FFh
.rdata$r:000028D0                 db    0
.rdata$r:000028D1                 db    0
.rdata$r:000028D2                 db    0
.rdata$r:000028D3                 db    0
.rdata$r:000028D4                 db  40h ; @
.rdata$r:000028D5                 db    0
.rdata$r:000028D6                 db    0
.rdata$r:000028D7                 db    0
.rdata$r:000028D8                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028D8 _rdata$r        ends
.rdata$r:000028D8
.data:000028DC ; ===========================================================================
.data:000028DC
.data:000028DC ; Segment type: Pure data
.data:000028DC ; Segment permissions: Read/Write
.data:000028DC _data           segment dword public 'DATA' use32
.data:000028DC                 assume cs:_data
.data:000028DC                 ;org 28DCh
.data:000028DC ; COMDAT (pick any)
.data:000028DC                 public ??_R0?AVCMyUnknownImp@@@8
.data:000028DC ; class CMyUnknownImp `RTTI Type Descriptor'
.data:000028DC ??_R0?AVCMyUnknownImp@@@8 dd offset ??_7type_info@@6B@
.data:000028DC                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'o
.data:000028DC                                         ; .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000028DC                                         ; const type_info::`vftable'
.data:000028E0                 db    0
.data:000028E1                 db    0
.data:000028E2                 db    0
.data:000028E3                 db    0
.data:000028E4                 db  2Eh ; .
.data:000028E5                 db  3Fh ; ?
.data:000028E6                 db  41h ; A
.data:000028E7                 db  56h ; V
.data:000028E8                 db  43h ; C
.data:000028E9                 db  4Dh ; M
.data:000028EA                 db  79h ; y
.data:000028EB                 db  55h ; U
.data:000028EC                 db  6Eh ; n
.data:000028ED                 db  6Bh ; k
.data:000028EE                 db  6Eh ; n
.data:000028EF                 db  6Fh ; o
.data:000028F0                 db  77h ; w
.data:000028F1                 db  6Eh ; n
.data:000028F2                 db  49h ; I
.data:000028F3                 db  6Dh ; m
.data:000028F4                 db  70h ; p
.data:000028F5                 db  40h ; @
.data:000028F6                 db  40h ; @
.data:000028F7                 db    0
.data:000028F7 _data           ends
.data:000028F7
.rdata$r:000028F8 ; ===========================================================================
.rdata$r:000028F8
.rdata$r:000028F8 ; Segment type: Pure data
.rdata$r:000028F8 ; Segment permissions: Read
.rdata$r:000028F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028F8                 assume cs:_rdata$r
.rdata$r:000028F8                 ;org 28F8h
.rdata$r:000028F8 ; COMDAT (pick any)
.rdata$r:000028F8                 public ??_R3CMyUnknownImp@@8
.rdata$r:000028F8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028F8 ??_R3CMyUnknownImp@@8 db    0           ; DATA XREF: .rdata$r:000028D8o
.rdata$r:000028F8                                         ; .rdata$r:00002928o
.rdata$r:000028F9                 db    0
.rdata$r:000028FA                 db    0
.rdata$r:000028FB                 db    0
.rdata$r:000028FC                 db    0
.rdata$r:000028FD                 db    0
.rdata$r:000028FE                 db    0
.rdata$r:000028FF                 db    0
.rdata$r:00002900                 db    1
.rdata$r:00002901                 db    0
.rdata$r:00002902                 db    0
.rdata$r:00002903                 db    0
.rdata$r:00002904                 dd offset ??_R2CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:00002904 _rdata$r        ends
.rdata$r:00002904
.rdata$r:00002908 ; ===========================================================================
.rdata$r:00002908
.rdata$r:00002908 ; Segment type: Pure data
.rdata$r:00002908 ; Segment permissions: Read
.rdata$r:00002908 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002908                 assume cs:_rdata$r
.rdata$r:00002908                 ;org 2908h
.rdata$r:00002908 ; COMDAT (pick any)
.rdata$r:00002908                 public ??_R2CMyUnknownImp@@8
.rdata$r:00002908 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:00002908 ??_R2CMyUnknownImp@@8 dd offset ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:00002908                                         ; DATA XREF: .rdata$r:00002904o
.rdata$r:00002908                                         ; CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000290C                 db    0
.rdata$r:0000290D                 align 10h
.rdata$r:0000290D _rdata$r        ends
.rdata$r:0000290D
.rdata$r:00002910 ; ===========================================================================
.rdata$r:00002910
.rdata$r:00002910 ; Segment type: Pure data
.rdata$r:00002910 ; Segment permissions: Read
.rdata$r:00002910 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002910                 assume cs:_rdata$r
.rdata$r:00002910                 ;org 2910h
.rdata$r:00002910 ; COMDAT (pick any)
.rdata$r:00002910                 public ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:00002910 ; CMyUnknownImp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002910 ??_R1A@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:00002910                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Array'o
.rdata$r:00002910                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:00002914                 db    0
.rdata$r:00002915                 db    0
.rdata$r:00002916                 db    0
.rdata$r:00002917                 db    0
.rdata$r:00002918                 db    0
.rdata$r:00002919                 db    0
.rdata$r:0000291A                 db    0
.rdata$r:0000291B                 db    0
.rdata$r:0000291C                 db 0FFh
.rdata$r:0000291D                 db 0FFh
.rdata$r:0000291E                 db 0FFh
.rdata$r:0000291F                 db 0FFh
.rdata$r:00002920                 db    0
.rdata$r:00002921                 db    0
.rdata$r:00002922                 db    0
.rdata$r:00002923                 db    0
.rdata$r:00002924                 db  40h ; @
.rdata$r:00002925                 db    0
.rdata$r:00002926                 db    0
.rdata$r:00002927                 db    0
.rdata$r:00002928                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002928 _rdata$r        ends
.rdata$r:00002928
.text:0000292C ; ===========================================================================
.text:0000292C
.text:0000292C ; Segment type: Pure code
.text:0000292C ; Segment permissions: Read/Execute
.text:0000292C _text           segment para public 'CODE' use32
.text:0000292C                 assume cs:_text
.text:0000292C                 ;org 292Ch
.text:0000292C ; COMDAT (pick any)
.text:0000292C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000292C
.text:0000292C ; =============== S U B R O U T I N E =======================================
.text:0000292C
.text:0000292C ; Attributes: bp-based frame
.text:0000292C
.text:0000292C ; _DWORD __thiscall CMyUnknownImp::CMyUnknownImp(CMyUnknownImp *__hidden this)
.text:0000292C                 public ??0CMyUnknownImp@@QAE@XZ
.text:0000292C ??0CMyUnknownImp@@QAE@XZ proc near      ; CODE XREF: CStdInFileStream::CStdInFileStream(void)+1Cp
.text:0000292C
.text:0000292C var_4           = dword ptr -4
.text:0000292C
.text:0000292C                 push    ebp
.text:0000292D                 mov     ebp, esp
.text:0000292F                 push    ecx
.text:00002930                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002937                 mov     [ebp+var_4], ecx
.text:0000293A                 mov     eax, [ebp+var_4]
.text:0000293D                 mov     dword ptr [eax], 0
.text:00002943                 mov     eax, [ebp+var_4]
.text:00002946                 mov     esp, ebp
.text:00002948                 pop     ebp
.text:00002949                 retn
.text:00002949 ??0CMyUnknownImp@@QAE@XZ endp
.text:00002949
.text:00002949 ; ---------------------------------------------------------------------------
.text:0000294A                 align 4
.text:0000294A _text           ends
.text:0000294A
.text:0000294C ; ===========================================================================
.text:0000294C
.text:0000294C ; Segment type: Pure code
.text:0000294C ; Segment permissions: Read/Execute
.text:0000294C _text           segment para public 'CODE' use32
.text:0000294C                 assume cs:_text
.text:0000294C                 ;org 294Ch
.text:0000294C ; COMDAT (pick any)
.text:0000294C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000294C
.text:0000294C ; =============== S U B R O U T I N E =======================================
.text:0000294C
.text:0000294C ; Attributes: bp-based frame
.text:0000294C
.text:0000294C ; __int32 __stdcall CStdInFileStream::QueryInterface(CStdInFileStream *this, const struct _GUID *Buf1, void **)
.text:0000294C                 public ?QueryInterface@CStdInFileStream@@UAGJABU_GUID@@PAPAX@Z
.text:0000294C ?QueryInterface@CStdInFileStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:0000294C                                         ; DATA XREF: .rdata:const CStdInFileStream::`vftable'o
.text:0000294C
.text:0000294C this            = dword ptr  8
.text:0000294C Buf1            = dword ptr  0Ch
.text:0000294C arg_8           = dword ptr  10h
.text:0000294C
.text:0000294C                 push    ebp
.text:0000294D                 mov     ebp, esp
.text:0000294F                 mov     eax, [ebp+arg_8]
.text:00002952                 mov     dword ptr [eax], 0
.text:00002958                 push    offset _IID_IUnknown ; Buf2
.text:0000295D                 mov     ecx, [ebp+Buf1]
.text:00002960                 push    ecx             ; Buf1
.text:00002961                 call    ___@8           ; __(x,x)
.text:00002966                 test    eax, eax
.text:00002968                 jz      short loc_2974
.text:0000296A                 mov     edx, [ebp+arg_8]
.text:0000296D                 mov     eax, [ebp+this]
.text:00002970                 mov     [edx], eax
.text:00002972                 jmp     short loc_297B
.text:00002974 ; ---------------------------------------------------------------------------
.text:00002974
.text:00002974 loc_2974:                               ; CODE XREF: CStdInFileStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:00002974                 mov     eax, 80004002h
.text:00002979                 jmp     short loc_298C
.text:0000297B ; ---------------------------------------------------------------------------
.text:0000297B
.text:0000297B loc_297B:                               ; CODE XREF: CStdInFileStream::QueryInterface(_GUID const &,void * *)+26j
.text:0000297B                 mov     ecx, [ebp+this]
.text:0000297E                 mov     edx, [ecx+4]
.text:00002981                 add     edx, 1
.text:00002984                 mov     eax, [ebp+this]
.text:00002987                 mov     [eax+4], edx
.text:0000298A                 xor     eax, eax
.text:0000298C
.text:0000298C loc_298C:                               ; CODE XREF: CStdInFileStream::QueryInterface(_GUID const &,void * *)+2Dj
.text:0000298C                 cmp     ebp, esp
.text:0000298E                 call    __RTC_CheckEsp
.text:00002993                 pop     ebp
.text:00002994                 retn    0Ch
.text:00002994 ?QueryInterface@CStdInFileStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:00002994
.text:00002994 ; ---------------------------------------------------------------------------
.text:00002997                 align 4
.text:00002997 _text           ends
.text:00002997
.text:00002998 ; ===========================================================================
.text:00002998
.text:00002998 ; Segment type: Pure code
.text:00002998 ; Segment permissions: Read/Execute
.text:00002998 _text           segment para public 'CODE' use32
.text:00002998                 assume cs:_text
.text:00002998                 ;org 2998h
.text:00002998 ; COMDAT (pick any)
.text:00002998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002998
.text:00002998 ; =============== S U B R O U T I N E =======================================
.text:00002998
.text:00002998 ; Attributes: bp-based frame
.text:00002998
.text:00002998 ; int __stdcall __(void *Buf1, void *Buf2)
.text:00002998                 public ___@8
.text:00002998 ___@8           proc near               ; CODE XREF: CStdInFileStream::QueryInterface(_GUID const &,void * *)+15p
.text:00002998
.text:00002998 Buf1            = dword ptr  8
.text:00002998 Buf2            = dword ptr  0Ch
.text:00002998
.text:00002998                 push    ebp
.text:00002999                 mov     ebp, esp
.text:0000299B                 mov     eax, [ebp+Buf2]
.text:0000299E                 push    eax             ; Buf2
.text:0000299F                 mov     ecx, [ebp+Buf1]
.text:000029A2                 push    ecx             ; Buf1
.text:000029A3                 call    _IsEqualGUID@8  ; IsEqualGUID(x,x)
.text:000029A8                 cmp     ebp, esp
.text:000029AA                 call    __RTC_CheckEsp
.text:000029AF                 pop     ebp
.text:000029B0                 retn    8
.text:000029B0 ___@8           endp
.text:000029B0
.text:000029B0 ; ---------------------------------------------------------------------------
.text:000029B3                 align 4
.text:000029B3 _text           ends
.text:000029B3
.text:000029B4 ; ===========================================================================
.text:000029B4
.text:000029B4 ; Segment type: Pure code
.text:000029B4 ; Segment permissions: Read/Execute
.text:000029B4 _text           segment para public 'CODE' use32
.text:000029B4                 assume cs:_text
.text:000029B4                 ;org 29B4h
.text:000029B4 ; COMDAT (pick any)
.text:000029B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000029B4
.text:000029B4 ; =============== S U B R O U T I N E =======================================
.text:000029B4
.text:000029B4 ; Attributes: bp-based frame
.text:000029B4
.text:000029B4 ; int __stdcall IsEqualGUID(void *Buf1, void *Buf2)
.text:000029B4                 public _IsEqualGUID@8
.text:000029B4 _IsEqualGUID@8  proc near               ; CODE XREF: __(x,x)+Bp
.text:000029B4
.text:000029B4 Buf1            = dword ptr  8
.text:000029B4 Buf2            = dword ptr  0Ch
.text:000029B4
.text:000029B4                 push    ebp
.text:000029B5                 mov     ebp, esp
.text:000029B7                 push    10h             ; Size
.text:000029B9                 mov     eax, [ebp+Buf2]
.text:000029BC                 push    eax             ; Buf2
.text:000029BD                 mov     ecx, [ebp+Buf1]
.text:000029C0                 push    ecx             ; Buf1
.text:000029C1                 call    _memcmp
.text:000029C6                 add     esp, 0Ch
.text:000029C9                 neg     eax
.text:000029CB                 sbb     eax, eax
.text:000029CD                 add     eax, 1
.text:000029D0                 cmp     ebp, esp
.text:000029D2                 call    __RTC_CheckEsp
.text:000029D7                 pop     ebp
.text:000029D8                 retn    8
.text:000029D8 _IsEqualGUID@8  endp
.text:000029D8
.text:000029D8 ; ---------------------------------------------------------------------------
.text:000029DB                 align 4
.text:000029DB _text           ends
.text:000029DB
.text:000029DC ; ===========================================================================
.text:000029DC
.text:000029DC ; Segment type: Pure code
.text:000029DC ; Segment permissions: Read/Execute
.text:000029DC _text           segment para public 'CODE' use32
.text:000029DC                 assume cs:_text
.text:000029DC                 ;org 29DCh
.text:000029DC ; COMDAT (pick any)
.text:000029DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000029DC
.text:000029DC ; =============== S U B R O U T I N E =======================================
.text:000029DC
.text:000029DC ; Attributes: bp-based frame
.text:000029DC
.text:000029DC ; unsigned __int32 __stdcall CStdInFileStream::AddRef(CStdInFileStream *this)
.text:000029DC                 public ?AddRef@CStdInFileStream@@UAGKXZ
.text:000029DC ?AddRef@CStdInFileStream@@UAGKXZ proc near ; DATA XREF: .rdata:00002794o
.text:000029DC
.text:000029DC var_4           = dword ptr -4
.text:000029DC this            = dword ptr  8
.text:000029DC
.text:000029DC                 push    ebp
.text:000029DD                 mov     ebp, esp
.text:000029DF                 push    ecx
.text:000029E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000029E7                 mov     eax, [ebp+this]
.text:000029EA                 mov     ecx, [eax+4]
.text:000029ED                 add     ecx, 1
.text:000029F0                 mov     [ebp+var_4], ecx
.text:000029F3                 mov     edx, [ebp+this]
.text:000029F6                 mov     eax, [ebp+var_4]
.text:000029F9                 mov     [edx+4], eax
.text:000029FC                 mov     eax, [ebp+var_4]
.text:000029FF                 mov     esp, ebp
.text:00002A01                 pop     ebp
.text:00002A02                 retn    4
.text:00002A02 ?AddRef@CStdInFileStream@@UAGKXZ endp
.text:00002A02
.text:00002A02 ; ---------------------------------------------------------------------------
.text:00002A05                 align 4
.text:00002A05 _text           ends
.text:00002A05
.text:00002A08 ; ===========================================================================
.text:00002A08
.text:00002A08 ; Segment type: Pure code
.text:00002A08 ; Segment permissions: Read/Execute
.text:00002A08 _text           segment para public 'CODE' use32
.text:00002A08                 assume cs:_text
.text:00002A08                 ;org 2A08h
.text:00002A08 ; COMDAT (pick any)
.text:00002A08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002A08
.text:00002A08 ; =============== S U B R O U T I N E =======================================
.text:00002A08
.text:00002A08 ; Attributes: bp-based frame
.text:00002A08
.text:00002A08 ; unsigned __int32 __stdcall CStdInFileStream::Release(CStdInFileStream *this)
.text:00002A08                 public ?Release@CStdInFileStream@@UAGKXZ
.text:00002A08 ?Release@CStdInFileStream@@UAGKXZ proc near ; DATA XREF: .rdata:00002798o
.text:00002A08
.text:00002A08 var_10          = dword ptr -10h
.text:00002A08 var_C           = dword ptr -0Ch
.text:00002A08 var_8           = dword ptr -8
.text:00002A08 var_4           = dword ptr -4
.text:00002A08 this            = dword ptr  8
.text:00002A08
.text:00002A08                 push    ebp
.text:00002A09                 mov     ebp, esp
.text:00002A0B                 sub     esp, 10h
.text:00002A0E                 push    esi
.text:00002A0F                 mov     eax, 0CCCCCCCCh
.text:00002A14                 mov     [ebp+var_10], eax
.text:00002A17                 mov     [ebp+var_C], eax
.text:00002A1A                 mov     [ebp+var_8], eax
.text:00002A1D                 mov     [ebp+var_4], eax
.text:00002A20                 mov     eax, [ebp+this]
.text:00002A23                 mov     ecx, [eax+4]
.text:00002A26                 sub     ecx, 1
.text:00002A29                 mov     [ebp+var_C], ecx
.text:00002A2C                 mov     edx, [ebp+this]
.text:00002A2F                 mov     eax, [ebp+var_C]
.text:00002A32                 mov     [edx+4], eax
.text:00002A35                 cmp     [ebp+var_C], 0
.text:00002A39                 jz      short loc_2A43
.text:00002A3B                 mov     ecx, [ebp+this]
.text:00002A3E                 mov     eax, [ecx+4]
.text:00002A41                 jmp     short loc_2A7B
.text:00002A43 ; ---------------------------------------------------------------------------
.text:00002A43
.text:00002A43 loc_2A43:                               ; CODE XREF: CStdInFileStream::Release(void)+31j
.text:00002A43                 mov     edx, [ebp+this]
.text:00002A46                 mov     [ebp+var_8], edx
.text:00002A49                 mov     eax, [ebp+var_8]
.text:00002A4C                 mov     [ebp+var_4], eax
.text:00002A4F                 cmp     [ebp+var_4], 0
.text:00002A53                 jz      short loc_2A72
.text:00002A55                 mov     esi, esp
.text:00002A57                 push    1
.text:00002A59                 mov     ecx, [ebp+var_4]
.text:00002A5C                 mov     edx, [ecx]
.text:00002A5E                 mov     ecx, [ebp+var_4]
.text:00002A61                 mov     eax, [edx+10h]
.text:00002A64                 call    eax
.text:00002A66                 cmp     esi, esp
.text:00002A68                 call    __RTC_CheckEsp
.text:00002A6D                 mov     [ebp+var_10], eax
.text:00002A70                 jmp     short loc_2A79
.text:00002A72 ; ---------------------------------------------------------------------------
.text:00002A72
.text:00002A72 loc_2A72:                               ; CODE XREF: CStdInFileStream::Release(void)+4Bj
.text:00002A72                 mov     [ebp+var_10], 0
.text:00002A79
.text:00002A79 loc_2A79:                               ; CODE XREF: CStdInFileStream::Release(void)+68j
.text:00002A79                 xor     eax, eax
.text:00002A7B
.text:00002A7B loc_2A7B:                               ; CODE XREF: CStdInFileStream::Release(void)+39j
.text:00002A7B                 pop     esi
.text:00002A7C                 add     esp, 10h
.text:00002A7F                 cmp     ebp, esp
.text:00002A81                 call    __RTC_CheckEsp
.text:00002A86                 mov     esp, ebp
.text:00002A88                 pop     ebp
.text:00002A89                 retn    4
.text:00002A89 ?Release@CStdInFileStream@@UAGKXZ endp
.text:00002A89
.text:00002A89 _text           ends
.text:00002A89
.text:00002A8C ; ===========================================================================
.text:00002A8C
.text:00002A8C ; Segment type: Pure code
.text:00002A8C ; Segment permissions: Read/Execute
.text:00002A8C _text           segment para public 'CODE' use32
.text:00002A8C                 assume cs:_text
.text:00002A8C                 ;org 2A8Ch
.text:00002A8C ; COMDAT (pick any)
.text:00002A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002A8C
.text:00002A8C ; =============== S U B R O U T I N E =======================================
.text:00002A8C
.text:00002A8C ; Attributes: bp-based frame
.text:00002A8C
.text:00002A8C ; public: virtual void * __thiscall CStdInFileStream::`scalar deleting destructor'(unsigned int)
.text:00002A8C                 public ??_GCStdInFileStream@@UAEPAXI@Z
.text:00002A8C ??_GCStdInFileStream@@UAEPAXI@Z proc near
.text:00002A8C
.text:00002A8C var_4           = dword ptr -4
.text:00002A8C arg_0           = dword ptr  8
.text:00002A8C
.text:00002A8C                 push    ebp
.text:00002A8D                 mov     ebp, esp
.text:00002A8F                 push    ecx
.text:00002A90                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002A97                 mov     [ebp+var_4], ecx
.text:00002A9A                 mov     ecx, [ebp+var_4] ; this
.text:00002A9D                 call    ??1CStdInFileStream@@UAE@XZ ; CStdInFileStream::~CStdInFileStream(void)
.text:00002AA2                 mov     eax, [ebp+arg_0]
.text:00002AA5                 and     eax, 1
.text:00002AA8                 jz      short loc_2AB6
.text:00002AAA                 mov     ecx, [ebp+var_4]
.text:00002AAD                 push    ecx             ; void *
.text:00002AAE                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00002AB3                 add     esp, 4
.text:00002AB6
.text:00002AB6 loc_2AB6:                               ; CODE XREF: CStdInFileStream::`scalar deleting destructor'(uint)+1Cj
.text:00002AB6                 mov     eax, [ebp+var_4]
.text:00002AB9                 add     esp, 4
.text:00002ABC                 cmp     ebp, esp
.text:00002ABE                 call    __RTC_CheckEsp
.text:00002AC3                 mov     esp, ebp
.text:00002AC5                 pop     ebp
.text:00002AC6                 retn    4
.text:00002AC6 ??_GCStdInFileStream@@UAEPAXI@Z endp
.text:00002AC6
.text:00002AC6 ; ---------------------------------------------------------------------------
.text:00002AC9                 align 4
.text:00002AC9 _text           ends
.text:00002AC9
.text:00002ACC ; ===========================================================================
.text:00002ACC
.text:00002ACC ; Segment type: Pure code
.text:00002ACC ; Segment permissions: Read/Execute
.text:00002ACC _text           segment para public 'CODE' use32
.text:00002ACC                 assume cs:_text
.text:00002ACC                 ;org 2ACCh
.text:00002ACC ; COMDAT (pick any)
.text:00002ACC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002ACC
.text:00002ACC ; =============== S U B R O U T I N E =======================================
.text:00002ACC
.text:00002ACC ; Attributes: bp-based frame
.text:00002ACC
.text:00002ACC ; _DWORD __thiscall CStdInFileStream::~CStdInFileStream(CStdInFileStream *__hidden this)
.text:00002ACC                 public ??1CStdInFileStream@@UAE@XZ
.text:00002ACC ??1CStdInFileStream@@UAE@XZ proc near   ; CODE XREF: CStdInFileStream::`scalar deleting destructor'(uint)+11p
.text:00002ACC
.text:00002ACC var_4           = dword ptr -4
.text:00002ACC
.text:00002ACC                 push    ebp
.text:00002ACD                 mov     ebp, esp
.text:00002ACF                 push    ecx
.text:00002AD0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002AD7                 mov     [ebp+var_4], ecx
.text:00002ADA                 mov     eax, [ebp+var_4]
.text:00002ADD                 mov     dword ptr [eax], offset ??_7CStdInFileStream@@6B@ ; const CStdInFileStream::`vftable'
.text:00002AE3                 mov     esp, ebp
.text:00002AE5                 pop     ebp
.text:00002AE6                 retn
.text:00002AE6 ??1CStdInFileStream@@UAE@XZ endp
.text:00002AE6
.text:00002AE6 ; ---------------------------------------------------------------------------
.text:00002AE7                 align 4
.text:00002AE7 _text           ends
.text:00002AE7
.text:00002AE8 ; ===========================================================================
.text:00002AE8
.text:00002AE8 ; Segment type: Pure code
.text:00002AE8 ; Segment permissions: Read/Execute
.text:00002AE8 _text           segment para public 'CODE' use32
.text:00002AE8                 assume cs:_text
.text:00002AE8                 ;org 2AE8h
.text:00002AE8 ; COMDAT (pick any)
.text:00002AE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002AE8
.text:00002AE8 ; =============== S U B R O U T I N E =======================================
.text:00002AE8
.text:00002AE8 ; Attributes: bp-based frame
.text:00002AE8
.text:00002AE8 ; _DWORD __thiscall CUniqBlocks::~CUniqBlocks(CUniqBlocks *__hidden this)
.text:00002AE8                 public ??1CUniqBlocks@@QAE@XZ
.text:00002AE8 ??1CUniqBlocks@@QAE@XZ proc near        ; CODE XREF: CDirItems::~CDirItems(void)+4Cp
.text:00002AE8                                         ; __unwindfunclet$??1CDirItems@@QAE@XZ$4+6j
.text:00002AE8
.text:00002AE8 var_10          = dword ptr -10h
.text:00002AE8 var_C           = dword ptr -0Ch
.text:00002AE8 var_4           = dword ptr -4
.text:00002AE8
.text:00002AE8                 push    ebp
.text:00002AE9                 mov     ebp, esp
.text:00002AEB                 push    0FFFFFFFFh
.text:00002AED                 push    offset __ehhandler$??1CUniqBlocks@@QAE@XZ
.text:00002AF2                 mov     eax, large fs:0
.text:00002AF8                 push    eax
.text:00002AF9                 push    ecx
.text:00002AFA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002B01                 mov     eax, dword ptr ds:___security_cookie
.text:00002B06                 xor     eax, ebp
.text:00002B08                 push    eax
.text:00002B09                 lea     eax, [ebp+var_C]
.text:00002B0C                 mov     large fs:0, eax
.text:00002B12                 mov     [ebp+var_10], ecx
.text:00002B15                 mov     [ebp+var_4], 1
.text:00002B1C                 mov     ecx, [ebp+var_10]
.text:00002B1F                 add     ecx, 18h
.text:00002B22                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:00002B27                 mov     byte ptr [ebp+var_4], 0
.text:00002B2B                 mov     ecx, [ebp+var_10]
.text:00002B2E                 add     ecx, 0Ch
.text:00002B31                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:00002B36                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002B3D                 mov     ecx, [ebp+var_10]
.text:00002B40                 call    ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ ; CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)
.text:00002B45                 mov     ecx, [ebp+var_C]
.text:00002B48                 mov     large fs:0, ecx
.text:00002B4F                 pop     ecx
.text:00002B50                 add     esp, 10h
.text:00002B53                 cmp     ebp, esp
.text:00002B55                 call    __RTC_CheckEsp
.text:00002B5A                 mov     esp, ebp
.text:00002B5C                 pop     ebp
.text:00002B5D                 retn
.text:00002B5D ??1CUniqBlocks@@QAE@XZ endp
.text:00002B5D
.text:00002B5D ; ---------------------------------------------------------------------------
.text:00002B5E                 align 10h
.text:00002B5E _text           ends
.text:00002B5E
.text$x:00002B60 ; ===========================================================================
.text$x:00002B60
.text$x:00002B60 ; Segment type: Pure code
.text$x:00002B60 ; Segment permissions: Read/Execute
.text$x:00002B60 _text$x         segment para public 'CODE' use32
.text$x:00002B60                 assume cs:_text$x
.text$x:00002B60                 ;org 2B60h
.text$x:00002B60 ; COMDAT (pick associative to section at 2AE8)
.text$x:00002B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002B60
.text$x:00002B60 ; =============== S U B R O U T I N E =======================================
.text$x:00002B60
.text$x:00002B60
.text$x:00002B60 __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0 proc near
.text$x:00002B60                                         ; DATA XREF: .xdata$x:00002B94o
.text$x:00002B60                 mov     ecx, [ebp-10h]
.text$x:00002B63                 jmp     ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ ; CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)
.text$x:00002B63 __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0 endp
.text$x:00002B63
.text$x:00002B68
.text$x:00002B68 ; =============== S U B R O U T I N E =======================================
.text$x:00002B68
.text$x:00002B68
.text$x:00002B68 __unwindfunclet$??1CUniqBlocks@@QAE@XZ$1 proc near
.text$x:00002B68                                         ; DATA XREF: .xdata$x:00002B9Co
.text$x:00002B68                 mov     ecx, [ebp-10h]
.text$x:00002B6B                 add     ecx, 0Ch
.text$x:00002B6E                 jmp     ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text$x:00002B6E __unwindfunclet$??1CUniqBlocks@@QAE@XZ$1 endp
.text$x:00002B6E
.text$x:00002B73
.text$x:00002B73 ; =============== S U B R O U T I N E =======================================
.text$x:00002B73
.text$x:00002B73
.text$x:00002B73 __ehhandler$??1CUniqBlocks@@QAE@XZ proc near
.text$x:00002B73                                         ; DATA XREF: CUniqBlocks::~CUniqBlocks(void)+5o
.text$x:00002B73
.text$x:00002B73 arg_4           = dword ptr  8
.text$x:00002B73
.text$x:00002B73                 mov     edx, [esp+arg_4]
.text$x:00002B77                 lea     eax, [edx+0Ch]
.text$x:00002B7A                 mov     ecx, [edx-8]
.text$x:00002B7D                 xor     ecx, eax
.text$x:00002B7F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B84                 mov     eax, offset __ehfuncinfo$??1CUniqBlocks@@QAE@XZ
.text$x:00002B89                 jmp     ___CxxFrameHandler3
.text$x:00002B89 __ehhandler$??1CUniqBlocks@@QAE@XZ endp
.text$x:00002B89
.text$x:00002B89 ; ---------------------------------------------------------------------------
.text$x:00002B8E                 align 10h
.text$x:00002B8E _text$x         ends
.text$x:00002B8E
.xdata$x:00002B90 ; ===========================================================================
.xdata$x:00002B90
.xdata$x:00002B90 ; Segment type: Pure data
.xdata$x:00002B90 ; Segment permissions: Read
.xdata$x:00002B90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B90                 assume cs:_xdata$x
.xdata$x:00002B90                 ;org 2B90h
.xdata$x:00002B90 ; COMDAT (pick associative to section at 2AE8)
.xdata$x:00002B90 __unwindtable$??1CUniqBlocks@@QAE@XZ db 0FFh
.xdata$x:00002B90                                         ; DATA XREF: .xdata$x:00002BA8o
.xdata$x:00002B91                 db 0FFh
.xdata$x:00002B92                 db 0FFh
.xdata$x:00002B93                 db 0FFh
.xdata$x:00002B94                 dd offset __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0
.xdata$x:00002B98                 db    0
.xdata$x:00002B99                 db    0
.xdata$x:00002B9A                 db    0
.xdata$x:00002B9B                 db    0
.xdata$x:00002B9C                 dd offset __unwindfunclet$??1CUniqBlocks@@QAE@XZ$1
.xdata$x:00002BA0 __ehfuncinfo$??1CUniqBlocks@@QAE@XZ db  22h ; "
.xdata$x:00002BA0                                         ; DATA XREF: __ehhandler$??1CUniqBlocks@@QAE@XZ+11o
.xdata$x:00002BA1                 db    5
.xdata$x:00002BA2                 db  93h ; 
.xdata$x:00002BA3                 db  19h
.xdata$x:00002BA4                 db    2
.xdata$x:00002BA5                 db    0
.xdata$x:00002BA6                 db    0
.xdata$x:00002BA7                 db    0
.xdata$x:00002BA8                 dd offset __unwindtable$??1CUniqBlocks@@QAE@XZ
.xdata$x:00002BAC                 align 20h
.xdata$x:00002BC0                 db    1
.xdata$x:00002BC1                 db    0
.xdata$x:00002BC2                 db    0
.xdata$x:00002BC3                 db    0
.xdata$x:00002BC3 _xdata$x        ends
.xdata$x:00002BC3
.text:00002BC4 ; ===========================================================================
.text:00002BC4
.text:00002BC4 ; Segment type: Pure code
.text:00002BC4 ; Segment permissions: Read/Execute
.text:00002BC4 _text           segment para public 'CODE' use32
.text:00002BC4                 assume cs:_text
.text:00002BC4                 ;org 2BC4h
.text:00002BC4 ; COMDAT (pick any)
.text:00002BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002BC4
.text:00002BC4 ; =============== S U B R O U T I N E =======================================
.text:00002BC4
.text:00002BC4 ; Attributes: bp-based frame
.text:00002BC4
.text:00002BC4 ; _DWORD __thiscall IHashCalc::IHashCalc(IHashCalc *__hidden this)
.text:00002BC4                 public ??0IHashCalc@@QAE@XZ
.text:00002BC4 ??0IHashCalc@@QAE@XZ proc near          ; CODE XREF: CHashBundle::CHashBundle(void)+11p
.text:00002BC4
.text:00002BC4 var_4           = dword ptr -4
.text:00002BC4
.text:00002BC4                 push    ebp
.text:00002BC5                 mov     ebp, esp
.text:00002BC7                 push    ecx
.text:00002BC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002BCF                 mov     [ebp+var_4], ecx
.text:00002BD2                 mov     eax, [ebp+var_4]
.text:00002BD5                 mov     dword ptr [eax], offset ??_7IHashCalc@@6B@ ; const IHashCalc::`vftable'
.text:00002BDB                 mov     eax, [ebp+var_4]
.text:00002BDE                 mov     esp, ebp
.text:00002BE0                 pop     ebp
.text:00002BE1                 retn
.text:00002BE1 ??0IHashCalc@@QAE@XZ endp
.text:00002BE1
.text:00002BE1 ; ---------------------------------------------------------------------------
.text:00002BE2                 align 4
.text:00002BE2 _text           ends
.text:00002BE2
.rdata:00002BE4 ; ===========================================================================
.rdata:00002BE4
.rdata:00002BE4 ; Segment type: Pure data
.rdata:00002BE4 ; Segment permissions: Read
.rdata:00002BE4 _rdata          segment dword public 'DATA' use32
.rdata:00002BE4                 assume cs:_rdata
.rdata:00002BE4                 ;org 2BE4h
.rdata:00002BE4 ; COMDAT (pick largest)
.rdata:00002BE4                 dd offset ??_R4IHashCalc@@6B@ ; const IHashCalc::`RTTI Complete Object Locator'
.rdata:00002BE8                 public ??_7IHashCalc@@6B@
.rdata:00002BE8 ; const IHashCalc::`vftable'
.rdata:00002BE8 ??_7IHashCalc@@6B@ dd offset __purecall ; DATA XREF: IHashCalc::IHashCalc(void)+11o
.rdata:00002BEC                 dd offset __purecall
.rdata:00002BF0                 dd offset __purecall
.rdata:00002BF4                 dd offset __purecall
.rdata:00002BF4 _rdata          ends
.rdata:00002BF4
.rdata$r:00002BF8 ; ===========================================================================
.rdata$r:00002BF8
.rdata$r:00002BF8 ; Segment type: Pure data
.rdata$r:00002BF8 ; Segment permissions: Read
.rdata$r:00002BF8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002BF8                 assume cs:_rdata$r
.rdata$r:00002BF8                 ;org 2BF8h
.rdata$r:00002BF8 ; COMDAT (pick any)
.rdata$r:00002BF8                 public ??_R4IHashCalc@@6B@
.rdata$r:00002BF8 ; const IHashCalc::`RTTI Complete Object Locator'
.rdata$r:00002BF8 ??_R4IHashCalc@@6B@ db    0             ; DATA XREF: .rdata:00002BE4o
.rdata$r:00002BF9                 db    0
.rdata$r:00002BFA                 db    0
.rdata$r:00002BFB                 db    0
.rdata$r:00002BFC                 db    0
.rdata$r:00002BFD                 db    0
.rdata$r:00002BFE                 db    0
.rdata$r:00002BFF                 db    0
.rdata$r:00002C00                 db    0
.rdata$r:00002C01                 db    0
.rdata$r:00002C02                 db    0
.rdata$r:00002C03                 db    0
.rdata$r:00002C04                 dd offset ??_R0?AUIHashCalc@@@8 ; IHashCalc `RTTI Type Descriptor'
.rdata$r:00002C08                 dd offset ??_R3IHashCalc@@8 ; IHashCalc::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002C08 _rdata$r        ends
.rdata$r:00002C08
.text:00002C0C ; ===========================================================================
.text:00002C0C
.text:00002C0C ; Segment type: Pure code
.text:00002C0C ; Segment permissions: Read/Execute
.text:00002C0C _text           segment para public 'CODE' use32
.text:00002C0C                 assume cs:_text
.text:00002C0C                 ;org 2C0Ch
.text:00002C0C ; COMDAT (pick any)
.text:00002C0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002C0C
.text:00002C0C ; =============== S U B R O U T I N E =======================================
.text:00002C0C
.text:00002C0C ; Attributes: bp-based frame
.text:00002C0C
.text:00002C0C ; _DWORD __thiscall ISequentialInStream::ISequentialInStream(ISequentialInStream *__hidden this)
.text:00002C0C                 public ??0ISequentialInStream@@QAE@XZ
.text:00002C0C ??0ISequentialInStream@@QAE@XZ proc near
.text:00002C0C                                         ; CODE XREF: CStdInFileStream::CStdInFileStream(void)+11p
.text:00002C0C
.text:00002C0C var_4           = dword ptr -4
.text:00002C0C
.text:00002C0C                 push    ebp
.text:00002C0D                 mov     ebp, esp
.text:00002C0F                 push    ecx
.text:00002C10                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002C17                 mov     [ebp+var_4], ecx
.text:00002C1A                 mov     ecx, [ebp+var_4]
.text:00002C1D                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00002C22                 mov     eax, [ebp+var_4]
.text:00002C25                 mov     dword ptr [eax], offset ??_7ISequentialInStream@@6B@ ; const ISequentialInStream::`vftable'
.text:00002C2B                 mov     eax, [ebp+var_4]
.text:00002C2E                 add     esp, 4
.text:00002C31                 cmp     ebp, esp
.text:00002C33                 call    __RTC_CheckEsp
.text:00002C38                 mov     esp, ebp
.text:00002C3A                 pop     ebp
.text:00002C3B                 retn
.text:00002C3B ??0ISequentialInStream@@QAE@XZ endp
.text:00002C3B
.text:00002C3B _text           ends
.text:00002C3B
.rdata:00002C3C ; ===========================================================================
.rdata:00002C3C
.rdata:00002C3C ; Segment type: Pure data
.rdata:00002C3C ; Segment permissions: Read
.rdata:00002C3C _rdata          segment dword public 'DATA' use32
.rdata:00002C3C                 assume cs:_rdata
.rdata:00002C3C                 ;org 2C3Ch
.rdata:00002C3C ; COMDAT (pick largest)
.rdata:00002C3C                 dd offset ??_R4ISequentialInStream@@6B@ ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata:00002C40                 public ??_7ISequentialInStream@@6B@
.rdata:00002C40 ; const ISequentialInStream::`vftable'
.rdata:00002C40 ??_7ISequentialInStream@@6B@ dd offset __purecall
.rdata:00002C40                                         ; DATA XREF: ISequentialInStream::ISequentialInStream(void)+19o
.rdata:00002C44                 dd offset __purecall
.rdata:00002C48                 dd offset __purecall
.rdata:00002C4C                 dd offset __purecall
.rdata:00002C4C _rdata          ends
.rdata:00002C4C
.rdata$r:00002C50 ; ===========================================================================
.rdata$r:00002C50
.rdata$r:00002C50 ; Segment type: Pure data
.rdata$r:00002C50 ; Segment permissions: Read
.rdata$r:00002C50 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002C50                 assume cs:_rdata$r
.rdata$r:00002C50                 ;org 2C50h
.rdata$r:00002C50 ; COMDAT (pick any)
.rdata$r:00002C50                 public ??_R4ISequentialInStream@@6B@
.rdata$r:00002C50 ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata$r:00002C50 ??_R4ISequentialInStream@@6B@ db    0   ; DATA XREF: .rdata:00002C3Co
.rdata$r:00002C51                 db    0
.rdata$r:00002C52                 db    0
.rdata$r:00002C53                 db    0
.rdata$r:00002C54                 db    0
.rdata$r:00002C55                 db    0
.rdata$r:00002C56                 db    0
.rdata$r:00002C57                 db    0
.rdata$r:00002C58                 db    0
.rdata$r:00002C59                 db    0
.rdata$r:00002C5A                 db    0
.rdata$r:00002C5B                 db    0
.rdata$r:00002C5C                 dd offset ??_R0?AUISequentialInStream@@@8 ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:00002C60                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002C60 _rdata$r        ends
.rdata$r:00002C60
.text:00002C64 ; ===========================================================================
.text:00002C64
.text:00002C64 ; Segment type: Pure code
.text:00002C64 ; Segment permissions: Read/Execute
.text:00002C64 _text           segment para public 'CODE' use32
.text:00002C64                 assume cs:_text
.text:00002C64                 ;org 2C64h
.text:00002C64 ; COMDAT (pick any)
.text:00002C64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002C64
.text:00002C64 ; =============== S U B R O U T I N E =======================================
.text:00002C64
.text:00002C64 ; Attributes: bp-based frame
.text:00002C64
.text:00002C64 ; public: __thiscall IUnknown::IUnknown(void)
.text:00002C64                 public ??0IUnknown@@QAE@XZ
.text:00002C64 ??0IUnknown@@QAE@XZ proc near           ; CODE XREF: ISequentialInStream::ISequentialInStream(void)+11p
.text:00002C64
.text:00002C64 var_4           = dword ptr -4
.text:00002C64
.text:00002C64                 push    ebp
.text:00002C65                 mov     ebp, esp
.text:00002C67                 push    ecx
.text:00002C68                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002C6F                 mov     [ebp+var_4], ecx
.text:00002C72                 mov     eax, [ebp+var_4]
.text:00002C75                 mov     esp, ebp
.text:00002C77                 pop     ebp
.text:00002C78                 retn
.text:00002C78 ??0IUnknown@@QAE@XZ endp
.text:00002C78
.text:00002C78 ; ---------------------------------------------------------------------------
.text:00002C79                 align 4
.text:00002C79 _text           ends
.text:00002C79
.text:00002C7C ; ===========================================================================
.text:00002C7C
.text:00002C7C ; Segment type: Pure code
.text:00002C7C ; Segment permissions: Read/Execute
.text:00002C7C _text           segment para public 'CODE' use32
.text:00002C7C                 assume cs:_text
.text:00002C7C                 ;org 2C7Ch
.text:00002C7C ; COMDAT (pick any)
.text:00002C7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002C7C
.text:00002C7C ; =============== S U B R O U T I N E =======================================
.text:00002C7C
.text:00002C7C ; Attributes: bp-based frame
.text:00002C7C
.text:00002C7C ; public: unsigned int __thiscall CObjectVector<class UString>::Size(void)const
.text:00002C7C                 public ?Size@?$CObjectVector@VUString@@@@QBEIXZ
.text:00002C7C ?Size@?$CObjectVector@VUString@@@@QBEIXZ proc near
.text:00002C7C                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+C3p
.text:00002C7C                                         ; CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+51p
.text:00002C7C
.text:00002C7C var_4           = dword ptr -4
.text:00002C7C
.text:00002C7C                 push    ebp
.text:00002C7D                 mov     ebp, esp
.text:00002C7F                 push    ecx
.text:00002C80                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002C87                 mov     [ebp+var_4], ecx
.text:00002C8A                 mov     ecx, [ebp+var_4]
.text:00002C8D                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00002C92                 add     esp, 4
.text:00002C95                 cmp     ebp, esp
.text:00002C97                 call    __RTC_CheckEsp
.text:00002C9C                 mov     esp, ebp
.text:00002C9E                 pop     ebp
.text:00002C9F                 retn
.text:00002C9F ?Size@?$CObjectVector@VUString@@@@QBEIXZ endp
.text:00002C9F
.text:00002C9F _text           ends
.text:00002C9F
.text:00002CA0 ; ===========================================================================
.text:00002CA0
.text:00002CA0 ; Segment type: Pure code
.text:00002CA0 ; Segment permissions: Read/Execute
.text:00002CA0 _text           segment para public 'CODE' use32
.text:00002CA0                 assume cs:_text
.text:00002CA0                 ;org 2CA0h
.text:00002CA0 ; COMDAT (pick any)
.text:00002CA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002CA0
.text:00002CA0 ; =============== S U B R O U T I N E =======================================
.text:00002CA0
.text:00002CA0 ; Attributes: bp-based frame
.text:00002CA0
.text:00002CA0 ; public: bool __thiscall CObjectVector<class UString>::IsEmpty(void)const
.text:00002CA0                 public ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ
.text:00002CA0 ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ proc near
.text:00002CA0                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+57p
.text:00002CA0
.text:00002CA0 var_4           = dword ptr -4
.text:00002CA0
.text:00002CA0                 push    ebp
.text:00002CA1                 mov     ebp, esp
.text:00002CA3                 push    ecx
.text:00002CA4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002CAB                 mov     [ebp+var_4], ecx
.text:00002CAE                 mov     ecx, [ebp+var_4]
.text:00002CB1                 call    ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ ; CRecordVector<void *>::IsEmpty(void)
.text:00002CB6                 add     esp, 4
.text:00002CB9                 cmp     ebp, esp
.text:00002CBB                 call    __RTC_CheckEsp
.text:00002CC0                 mov     esp, ebp
.text:00002CC2                 pop     ebp
.text:00002CC3                 retn
.text:00002CC3 ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ endp
.text:00002CC3
.text:00002CC3 _text           ends
.text:00002CC3
.text:00002CC4 ; ===========================================================================
.text:00002CC4
.text:00002CC4 ; Segment type: Pure code
.text:00002CC4 ; Segment permissions: Read/Execute
.text:00002CC4 _text           segment para public 'CODE' use32
.text:00002CC4                 assume cs:_text
.text:00002CC4                 ;org 2CC4h
.text:00002CC4 ; COMDAT (pick any)
.text:00002CC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002CC4
.text:00002CC4 ; =============== S U B R O U T I N E =======================================
.text:00002CC4
.text:00002CC4 ; Attributes: bp-based frame
.text:00002CC4
.text:00002CC4 ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(class CObjectVector<class UString> const &)
.text:00002CC4                 public ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text:00002CC4 ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z proc near
.text:00002CC4                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+48p
.text:00002CC4
.text:00002CC4 var_24          = dword ptr -24h
.text:00002CC4 var_20          = dword ptr -20h
.text:00002CC4 var_1C          = dword ptr -1Ch
.text:00002CC4 var_18          = dword ptr -18h
.text:00002CC4 var_14          = dword ptr -14h
.text:00002CC4 var_10          = dword ptr -10h
.text:00002CC4 var_C           = dword ptr -0Ch
.text:00002CC4 var_4           = dword ptr -4
.text:00002CC4 arg_0           = dword ptr  8
.text:00002CC4
.text:00002CC4                 push    ebp
.text:00002CC5                 mov     ebp, esp
.text:00002CC7                 push    0FFFFFFFFh
.text:00002CC9                 push    offset __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text:00002CCE                 mov     eax, large fs:0
.text:00002CD4                 push    eax
.text:00002CD5                 sub     esp, 18h
.text:00002CD8                 mov     eax, 0CCCCCCCCh
.text:00002CDD                 mov     [ebp+var_24], eax
.text:00002CE0                 mov     [ebp+var_20], eax
.text:00002CE3                 mov     [ebp+var_1C], eax
.text:00002CE6                 mov     [ebp+var_18], eax
.text:00002CE9                 mov     [ebp+var_14], eax
.text:00002CEC                 mov     [ebp+var_10], eax
.text:00002CEF                 mov     eax, dword ptr ds:___security_cookie
.text:00002CF4                 xor     eax, ebp
.text:00002CF6                 push    eax
.text:00002CF7                 lea     eax, [ebp+var_C]
.text:00002CFA                 mov     large fs:0, eax
.text:00002D00                 mov     [ebp+var_10], ecx
.text:00002D03                 mov     ecx, [ebp+var_10]
.text:00002D06                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00002D0B                 mov     [ebp+var_4], 0
.text:00002D12                 mov     ecx, [ebp+arg_0]
.text:00002D15                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00002D1A                 mov     [ebp+var_14], eax
.text:00002D1D                 mov     eax, [ebp+var_14]
.text:00002D20                 push    eax
.text:00002D21                 mov     ecx, [ebp+var_10]
.text:00002D24                 call    ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ConstructReserve(uint)
.text:00002D29                 mov     [ebp+var_18], 0
.text:00002D30                 jmp     short loc_2D3B
.text:00002D32 ; ---------------------------------------------------------------------------
.text:00002D32
.text:00002D32 loc_2D32:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+CDj
.text:00002D32                 mov     ecx, [ebp+var_18]
.text:00002D35                 add     ecx, 1
.text:00002D38                 mov     [ebp+var_18], ecx
.text:00002D3B
.text:00002D3B loc_2D3B:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+6Cj
.text:00002D3B                 mov     edx, [ebp+var_18]
.text:00002D3E                 cmp     edx, [ebp+var_14]
.text:00002D41                 jnb     short loc_2D93
.text:00002D43                 push    0Ch             ; unsigned int
.text:00002D45                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002D4A                 add     esp, 4
.text:00002D4D                 mov     [ebp+var_20], eax
.text:00002D50                 mov     byte ptr [ebp+var_4], 1
.text:00002D54                 cmp     [ebp+var_20], 0
.text:00002D58                 jz      short loc_2D74
.text:00002D5A                 mov     eax, [ebp+var_18]
.text:00002D5D                 push    eax
.text:00002D5E                 mov     ecx, [ebp+arg_0]
.text:00002D61                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002D66                 push    eax
.text:00002D67                 mov     ecx, [ebp+var_20]
.text:00002D6A                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00002D6F                 mov     [ebp+var_24], eax
.text:00002D72                 jmp     short loc_2D7B
.text:00002D74 ; ---------------------------------------------------------------------------
.text:00002D74
.text:00002D74 loc_2D74:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+94j
.text:00002D74                 mov     [ebp+var_24], 0
.text:00002D7B
.text:00002D7B loc_2D7B:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+AEj
.text:00002D7B                 mov     ecx, [ebp+var_24]
.text:00002D7E                 mov     [ebp+var_1C], ecx
.text:00002D81                 mov     byte ptr [ebp+var_4], 0
.text:00002D85                 mov     edx, [ebp+var_1C]
.text:00002D88                 push    edx
.text:00002D89                 mov     ecx, [ebp+var_10]
.text:00002D8C                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00002D91                 jmp     short loc_2D32
.text:00002D93 ; ---------------------------------------------------------------------------
.text:00002D93
.text:00002D93 loc_2D93:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+7Dj
.text:00002D93                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002D9A                 mov     eax, [ebp+var_10]
.text:00002D9D                 mov     ecx, [ebp+var_C]
.text:00002DA0                 mov     large fs:0, ecx
.text:00002DA7                 pop     ecx
.text:00002DA8                 add     esp, 24h
.text:00002DAB                 cmp     ebp, esp
.text:00002DAD                 call    __RTC_CheckEsp
.text:00002DB2                 mov     esp, ebp
.text:00002DB4                 pop     ebp
.text:00002DB5                 retn    4
.text:00002DB5 ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z endp
.text:00002DB5
.text:00002DB5 _text           ends
.text:00002DB5
.text$x:00002DB8 ; ===========================================================================
.text$x:00002DB8
.text$x:00002DB8 ; Segment type: Pure code
.text$x:00002DB8 ; Segment permissions: Read/Execute
.text$x:00002DB8 _text$x         segment para public 'CODE' use32
.text$x:00002DB8                 assume cs:_text$x
.text$x:00002DB8                 ;org 2DB8h
.text$x:00002DB8 ; COMDAT (pick associative to section at 2CC4)
.text$x:00002DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002DB8
.text$x:00002DB8 ; =============== S U B R O U T I N E =======================================
.text$x:00002DB8
.text$x:00002DB8
.text$x:00002DB8 __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0 proc near
.text$x:00002DB8                                         ; DATA XREF: .xdata$x:00002DECo
.text$x:00002DB8                 mov     ecx, [ebp-10h]
.text$x:00002DBB                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00002DBB __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0 endp
.text$x:00002DBB
.text$x:00002DC0
.text$x:00002DC0 ; =============== S U B R O U T I N E =======================================
.text$x:00002DC0
.text$x:00002DC0
.text$x:00002DC0 __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1 proc near
.text$x:00002DC0                                         ; DATA XREF: .xdata$x:00002DF4o
.text$x:00002DC0                 mov     eax, [ebp-20h]
.text$x:00002DC3                 push    eax             ; void *
.text$x:00002DC4                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002DC9                 pop     ecx
.text$x:00002DCA                 retn
.text$x:00002DCA __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1 endp
.text$x:00002DCA
.text$x:00002DCB
.text$x:00002DCB ; =============== S U B R O U T I N E =======================================
.text$x:00002DCB
.text$x:00002DCB
.text$x:00002DCB __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z proc near
.text$x:00002DCB                                         ; DATA XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+5o
.text$x:00002DCB
.text$x:00002DCB arg_4           = dword ptr  8
.text$x:00002DCB
.text$x:00002DCB                 mov     edx, [esp+arg_4]
.text$x:00002DCF                 lea     eax, [edx+0Ch]
.text$x:00002DD2                 mov     ecx, [edx-1Ch]
.text$x:00002DD5                 xor     ecx, eax
.text$x:00002DD7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DDC                 mov     eax, offset __ehfuncinfo$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text$x:00002DE1                 jmp     ___CxxFrameHandler3
.text$x:00002DE1 __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z endp
.text$x:00002DE1
.text$x:00002DE1 ; ---------------------------------------------------------------------------
.text$x:00002DE6                 align 4
.text$x:00002DE6 _text$x         ends
.text$x:00002DE6
.xdata$x:00002DE8 ; ===========================================================================
.xdata$x:00002DE8
.xdata$x:00002DE8 ; Segment type: Pure data
.xdata$x:00002DE8 ; Segment permissions: Read
.xdata$x:00002DE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002DE8                 assume cs:_xdata$x
.xdata$x:00002DE8                 ;org 2DE8h
.xdata$x:00002DE8 ; COMDAT (pick associative to section at 2CC4)
.xdata$x:00002DE8 __unwindtable$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z db 0FFh
.xdata$x:00002DE8                                         ; DATA XREF: .xdata$x:00002E00o
.xdata$x:00002DE9                 db 0FFh
.xdata$x:00002DEA                 db 0FFh
.xdata$x:00002DEB                 db 0FFh
.xdata$x:00002DEC                 dd offset __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0
.xdata$x:00002DF0                 db    0
.xdata$x:00002DF1                 db    0
.xdata$x:00002DF2                 db    0
.xdata$x:00002DF3                 db    0
.xdata$x:00002DF4                 dd offset __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1
.xdata$x:00002DF8 __ehfuncinfo$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z db  22h ; "
.xdata$x:00002DF8                                         ; DATA XREF: __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z+11o
.xdata$x:00002DF9                 db    5
.xdata$x:00002DFA                 db  93h ; 
.xdata$x:00002DFB                 db  19h
.xdata$x:00002DFC                 db    2
.xdata$x:00002DFD                 db    0
.xdata$x:00002DFE                 db    0
.xdata$x:00002DFF                 db    0
.xdata$x:00002E00                 dd offset __unwindtable$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.xdata$x:00002E04                 db    0
.xdata$x:00002E05                 db    0
.xdata$x:00002E06                 db    0
.xdata$x:00002E07                 db    0
.xdata$x:00002E08                 db    0
.xdata$x:00002E09                 db    0
.xdata$x:00002E0A                 db    0
.xdata$x:00002E0B                 db    0
.xdata$x:00002E0C                 db    0
.xdata$x:00002E0D                 db    0
.xdata$x:00002E0E                 db    0
.xdata$x:00002E0F                 db    0
.xdata$x:00002E10                 db    0
.xdata$x:00002E11                 db    0
.xdata$x:00002E12                 db    0
.xdata$x:00002E13                 db    0
.xdata$x:00002E14                 db    0
.xdata$x:00002E15                 db    0
.xdata$x:00002E16                 db    0
.xdata$x:00002E17                 db    0
.xdata$x:00002E18                 db    1
.xdata$x:00002E19                 db    0
.xdata$x:00002E1A                 db    0
.xdata$x:00002E1B                 db    0
.xdata$x:00002E1B _xdata$x        ends
.xdata$x:00002E1B
.text:00002E1C ; ===========================================================================
.text:00002E1C
.text:00002E1C ; Segment type: Pure code
.text:00002E1C ; Segment permissions: Read/Execute
.text:00002E1C _text           segment para public 'CODE' use32
.text:00002E1C                 assume cs:_text
.text:00002E1C                 ;org 2E1Ch
.text:00002E1C ; COMDAT (pick any)
.text:00002E1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002E1C
.text:00002E1C ; =============== S U B R O U T I N E =======================================
.text:00002E1C
.text:00002E1C ; Attributes: bp-based frame
.text:00002E1C
.text:00002E1C ; public: class UString const & __thiscall CObjectVector<class UString>::operator[](unsigned int)const
.text:00002E1C                 public ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z
.text:00002E1C ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z proc near
.text:00002E1C                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+9Dp
.text:00002E1C
.text:00002E1C var_4           = dword ptr -4
.text:00002E1C arg_0           = dword ptr  8
.text:00002E1C
.text:00002E1C                 push    ebp
.text:00002E1D                 mov     ebp, esp
.text:00002E1F                 push    ecx
.text:00002E20                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002E27                 mov     [ebp+var_4], ecx
.text:00002E2A                 mov     eax, [ebp+arg_0]
.text:00002E2D                 push    eax
.text:00002E2E                 mov     ecx, [ebp+var_4]
.text:00002E31                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00002E36                 mov     eax, [eax]
.text:00002E38                 add     esp, 4
.text:00002E3B                 cmp     ebp, esp
.text:00002E3D                 call    __RTC_CheckEsp
.text:00002E42                 mov     esp, ebp
.text:00002E44                 pop     ebp
.text:00002E45                 retn    4
.text:00002E45 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z endp
.text:00002E45
.text:00002E45 _text           ends
.text:00002E45
.text:00002E48 ; ===========================================================================
.text:00002E48
.text:00002E48 ; Segment type: Pure code
.text:00002E48 ; Segment permissions: Read/Execute
.text:00002E48 _text           segment para public 'CODE' use32
.text:00002E48                 assume cs:_text
.text:00002E48                 ;org 2E48h
.text:00002E48 ; COMDAT (pick any)
.text:00002E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002E48
.text:00002E48 ; =============== S U B R O U T I N E =======================================
.text:00002E48
.text:00002E48 ; Attributes: bp-based frame
.text:00002E48
.text:00002E48 ; public: class UString & __thiscall CObjectVector<class UString>::operator[](unsigned int)
.text:00002E48                 public ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z
.text:00002E48 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z proc near
.text:00002E48                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+E7p
.text:00002E48
.text:00002E48 var_4           = dword ptr -4
.text:00002E48 arg_0           = dword ptr  8
.text:00002E48
.text:00002E48                 push    ebp
.text:00002E49                 mov     ebp, esp
.text:00002E4B                 push    ecx
.text:00002E4C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002E53                 mov     [ebp+var_4], ecx
.text:00002E56                 mov     eax, [ebp+arg_0]
.text:00002E59                 push    eax
.text:00002E5A                 mov     ecx, [ebp+var_4]
.text:00002E5D                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00002E62                 mov     eax, [eax]
.text:00002E64                 add     esp, 4
.text:00002E67                 cmp     ebp, esp
.text:00002E69                 call    __RTC_CheckEsp
.text:00002E6E                 mov     esp, ebp
.text:00002E70                 pop     ebp
.text:00002E71                 retn    4
.text:00002E71 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z endp
.text:00002E71
.text:00002E71 _text           ends
.text:00002E71
.text:00002E74 ; ===========================================================================
.text:00002E74
.text:00002E74 ; Segment type: Pure code
.text:00002E74 ; Segment permissions: Read/Execute
.text:00002E74 _text           segment para public 'CODE' use32
.text:00002E74                 assume cs:_text
.text:00002E74                 ;org 2E74h
.text:00002E74 ; COMDAT (pick any)
.text:00002E74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002E74
.text:00002E74 ; =============== S U B R O U T I N E =======================================
.text:00002E74
.text:00002E74 ; Attributes: bp-based frame
.text:00002E74
.text:00002E74 ; public: unsigned int __thiscall CObjectVector<class UString>::Add(class UString const &)
.text:00002E74                 public ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00002E74 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text:00002E74                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+85p
.text:00002E74
.text:00002E74 var_1C          = dword ptr -1Ch
.text:00002E74 var_18          = dword ptr -18h
.text:00002E74 var_14          = dword ptr -14h
.text:00002E74 var_10          = dword ptr -10h
.text:00002E74 var_C           = dword ptr -0Ch
.text:00002E74 var_4           = dword ptr -4
.text:00002E74 arg_0           = dword ptr  8
.text:00002E74
.text:00002E74                 push    ebp
.text:00002E75                 mov     ebp, esp
.text:00002E77                 push    0FFFFFFFFh
.text:00002E79                 push    offset __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00002E7E                 mov     eax, large fs:0
.text:00002E84                 push    eax
.text:00002E85                 sub     esp, 10h
.text:00002E88                 mov     eax, 0CCCCCCCCh
.text:00002E8D                 mov     [ebp+var_1C], eax
.text:00002E90                 mov     [ebp+var_18], eax
.text:00002E93                 mov     [ebp+var_14], eax
.text:00002E96                 mov     [ebp+var_10], eax
.text:00002E99                 mov     eax, dword ptr ds:___security_cookie
.text:00002E9E                 xor     eax, ebp
.text:00002EA0                 push    eax
.text:00002EA1                 lea     eax, [ebp+var_C]
.text:00002EA4                 mov     large fs:0, eax
.text:00002EAA                 mov     [ebp+var_10], ecx
.text:00002EAD                 push    0Ch             ; unsigned int
.text:00002EAF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002EB4                 add     esp, 4
.text:00002EB7                 mov     [ebp+var_18], eax
.text:00002EBA                 mov     [ebp+var_4], 0
.text:00002EC1                 cmp     [ebp+var_18], 0
.text:00002EC5                 jz      short loc_2ED8
.text:00002EC7                 mov     eax, [ebp+arg_0]
.text:00002ECA                 push    eax
.text:00002ECB                 mov     ecx, [ebp+var_18]
.text:00002ECE                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00002ED3                 mov     [ebp+var_1C], eax
.text:00002ED6                 jmp     short loc_2EDF
.text:00002ED8 ; ---------------------------------------------------------------------------
.text:00002ED8
.text:00002ED8 loc_2ED8:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+51j
.text:00002ED8                 mov     [ebp+var_1C], 0
.text:00002EDF
.text:00002EDF loc_2EDF:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+62j
.text:00002EDF                 mov     ecx, [ebp+var_1C]
.text:00002EE2                 mov     [ebp+var_14], ecx
.text:00002EE5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002EEC                 mov     edx, [ebp+var_14]
.text:00002EEF                 push    edx
.text:00002EF0                 mov     ecx, [ebp+var_10]
.text:00002EF3                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00002EF8                 mov     ecx, [ebp+var_C]
.text:00002EFB                 mov     large fs:0, ecx
.text:00002F02                 pop     ecx
.text:00002F03                 add     esp, 1Ch
.text:00002F06                 cmp     ebp, esp
.text:00002F08                 call    __RTC_CheckEsp
.text:00002F0D                 mov     esp, ebp
.text:00002F0F                 pop     ebp
.text:00002F10                 retn    4
.text:00002F10 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text:00002F10
.text:00002F10 ; ---------------------------------------------------------------------------
.text:00002F13                 align 4
.text:00002F13 _text           ends
.text:00002F13
.text$x:00002F14 ; ===========================================================================
.text$x:00002F14
.text$x:00002F14 ; Segment type: Pure code
.text$x:00002F14 ; Segment permissions: Read/Execute
.text$x:00002F14 _text$x         segment para public 'CODE' use32
.text$x:00002F14                 assume cs:_text$x
.text$x:00002F14                 ;org 2F14h
.text$x:00002F14 ; COMDAT (pick associative to section at 2E74)
.text$x:00002F14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002F14
.text$x:00002F14 ; =============== S U B R O U T I N E =======================================
.text$x:00002F14
.text$x:00002F14
.text$x:00002F14 __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 proc near
.text$x:00002F14                                         ; DATA XREF: .xdata$x:00002F40o
.text$x:00002F14                 mov     eax, [ebp-18h]
.text$x:00002F17                 push    eax             ; void *
.text$x:00002F18                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002F1D                 pop     ecx
.text$x:00002F1E                 retn
.text$x:00002F1E __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 endp
.text$x:00002F1E
.text$x:00002F1F
.text$x:00002F1F ; =============== S U B R O U T I N E =======================================
.text$x:00002F1F
.text$x:00002F1F
.text$x:00002F1F __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text$x:00002F1F                                         ; DATA XREF: CObjectVector<UString>::Add(UString const &)+5o
.text$x:00002F1F
.text$x:00002F1F arg_4           = dword ptr  8
.text$x:00002F1F
.text$x:00002F1F                 mov     edx, [esp+arg_4]
.text$x:00002F23                 lea     eax, [edx+0Ch]
.text$x:00002F26                 mov     ecx, [edx-14h]
.text$x:00002F29                 xor     ecx, eax
.text$x:00002F2B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F30                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text$x:00002F35                 jmp     ___CxxFrameHandler3
.text$x:00002F35 __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text$x:00002F35
.text$x:00002F35 ; ---------------------------------------------------------------------------
.text$x:00002F3A                 align 4
.text$x:00002F3A _text$x         ends
.text$x:00002F3A
.xdata$x:00002F3C ; ===========================================================================
.xdata$x:00002F3C
.xdata$x:00002F3C ; Segment type: Pure data
.xdata$x:00002F3C ; Segment permissions: Read
.xdata$x:00002F3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F3C                 assume cs:_xdata$x
.xdata$x:00002F3C                 ;org 2F3Ch
.xdata$x:00002F3C ; COMDAT (pick associative to section at 2E74)
.xdata$x:00002F3C __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db 0FFh
.xdata$x:00002F3C                                         ; DATA XREF: .xdata$x:00002F4Co
.xdata$x:00002F3D                 db 0FFh
.xdata$x:00002F3E                 db 0FFh
.xdata$x:00002F3F                 db 0FFh
.xdata$x:00002F40                 dd offset __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0
.xdata$x:00002F44 __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db  22h ; "
.xdata$x:00002F44                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z+11o
.xdata$x:00002F45                 db    5
.xdata$x:00002F46                 db  93h ; 
.xdata$x:00002F47                 db  19h
.xdata$x:00002F48                 db    1
.xdata$x:00002F49                 db    0
.xdata$x:00002F4A                 db    0
.xdata$x:00002F4B                 db    0
.xdata$x:00002F4C                 dd offset __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.xdata$x:00002F50                 db    0
.xdata$x:00002F51                 db    0
.xdata$x:00002F52                 db    0
.xdata$x:00002F53                 db    0
.xdata$x:00002F54                 db    0
.xdata$x:00002F55                 db    0
.xdata$x:00002F56                 db    0
.xdata$x:00002F57                 db    0
.xdata$x:00002F58                 db    0
.xdata$x:00002F59                 db    0
.xdata$x:00002F5A                 db    0
.xdata$x:00002F5B                 db    0
.xdata$x:00002F5C                 db    0
.xdata$x:00002F5D                 db    0
.xdata$x:00002F5E                 db    0
.xdata$x:00002F5F                 db    0
.xdata$x:00002F60                 db    0
.xdata$x:00002F61                 db    0
.xdata$x:00002F62                 db    0
.xdata$x:00002F63                 db    0
.xdata$x:00002F64                 db    1
.xdata$x:00002F65                 db    0
.xdata$x:00002F66                 db    0
.xdata$x:00002F67                 db    0
.xdata$x:00002F67 _xdata$x        ends
.xdata$x:00002F67
.text:00002F68 ; ===========================================================================
.text:00002F68
.text:00002F68 ; Segment type: Pure code
.text:00002F68 ; Segment permissions: Read/Execute
.text:00002F68 _text           segment para public 'CODE' use32
.text:00002F68                 assume cs:_text
.text:00002F68                 ;org 2F68h
.text:00002F68 ; COMDAT (pick any)
.text:00002F68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002F68
.text:00002F68 ; =============== S U B R O U T I N E =======================================
.text:00002F68
.text:00002F68 ; Attributes: bp-based frame
.text:00002F68
.text:00002F68 ; public: __thiscall CObjectVector<class UString>::~CObjectVector<class UString>(void)
.text:00002F68                 public ??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00002F68 ??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00002F68                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+144p
.text:00002F68                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+2B3p ...
.text:00002F68
.text:00002F68 var_20          = dword ptr -20h
.text:00002F68 var_1C          = dword ptr -1Ch
.text:00002F68 var_18          = dword ptr -18h
.text:00002F68 var_14          = dword ptr -14h
.text:00002F68 var_10          = dword ptr -10h
.text:00002F68 var_C           = dword ptr -0Ch
.text:00002F68 var_4           = dword ptr -4
.text:00002F68
.text:00002F68                 push    ebp
.text:00002F69                 mov     ebp, esp
.text:00002F6B                 push    0FFFFFFFFh
.text:00002F6D                 push    offset __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00002F72                 mov     eax, large fs:0
.text:00002F78                 push    eax
.text:00002F79                 sub     esp, 14h
.text:00002F7C                 mov     eax, 0CCCCCCCCh
.text:00002F81                 mov     [ebp+var_20], eax
.text:00002F84                 mov     [ebp+var_1C], eax
.text:00002F87                 mov     [ebp+var_18], eax
.text:00002F8A                 mov     [ebp+var_14], eax
.text:00002F8D                 mov     [ebp+var_10], eax
.text:00002F90                 mov     eax, dword ptr ds:___security_cookie
.text:00002F95                 xor     eax, ebp
.text:00002F97                 push    eax
.text:00002F98                 lea     eax, [ebp+var_C]
.text:00002F9B                 mov     large fs:0, eax
.text:00002FA1                 mov     [ebp+var_10], ecx
.text:00002FA4                 mov     [ebp+var_4], 0
.text:00002FAB                 mov     ecx, [ebp+var_10]
.text:00002FAE                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00002FB3                 mov     [ebp+var_14], eax
.text:00002FB6
.text:00002FB6 loc_2FB6:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void):loc_2FF8j
.text:00002FB6                 cmp     [ebp+var_14], 0
.text:00002FBA                 jz      short loc_2FFA
.text:00002FBC                 mov     eax, [ebp+var_14]
.text:00002FBF                 sub     eax, 1
.text:00002FC2                 mov     [ebp+var_14], eax
.text:00002FC5                 mov     ecx, [ebp+var_14]
.text:00002FC8                 push    ecx
.text:00002FC9                 mov     ecx, [ebp+var_10]
.text:00002FCC                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00002FD1                 mov     edx, [eax]
.text:00002FD3                 mov     [ebp+var_1C], edx
.text:00002FD6                 mov     eax, [ebp+var_1C]
.text:00002FD9                 mov     [ebp+var_18], eax
.text:00002FDC                 cmp     [ebp+var_18], 0
.text:00002FE0                 jz      short loc_2FF1
.text:00002FE2                 push    1
.text:00002FE4                 mov     ecx, [ebp+var_18]
.text:00002FE7                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00002FEC                 mov     [ebp+var_20], eax
.text:00002FEF                 jmp     short loc_2FF8
.text:00002FF1 ; ---------------------------------------------------------------------------
.text:00002FF1
.text:00002FF1 loc_2FF1:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+78j
.text:00002FF1                 mov     [ebp+var_20], 0
.text:00002FF8
.text:00002FF8 loc_2FF8:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+87j
.text:00002FF8                 jmp     short loc_2FB6
.text:00002FFA ; ---------------------------------------------------------------------------
.text:00002FFA
.text:00002FFA loc_2FFA:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+52j
.text:00002FFA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003001                 mov     ecx, [ebp+var_10]
.text:00003004                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003009                 mov     ecx, [ebp+var_C]
.text:0000300C                 mov     large fs:0, ecx
.text:00003013                 pop     ecx
.text:00003014                 add     esp, 20h
.text:00003017                 cmp     ebp, esp
.text:00003019                 call    __RTC_CheckEsp
.text:0000301E                 mov     esp, ebp
.text:00003020                 pop     ebp
.text:00003021                 retn
.text:00003021 ??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text:00003021
.text:00003021 ; ---------------------------------------------------------------------------
.text:00003022                 align 4
.text:00003022 _text           ends
.text:00003022
.text$x:00003024 ; ===========================================================================
.text$x:00003024
.text$x:00003024 ; Segment type: Pure code
.text$x:00003024 ; Segment permissions: Read/Execute
.text$x:00003024 _text$x         segment para public 'CODE' use32
.text$x:00003024                 assume cs:_text$x
.text$x:00003024                 ;org 3024h
.text$x:00003024 ; COMDAT (pick associative to section at 2F68)
.text$x:00003024                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003024
.text$x:00003024 ; =============== S U B R O U T I N E =======================================
.text$x:00003024
.text$x:00003024
.text$x:00003024 __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 proc near
.text$x:00003024                                         ; DATA XREF: .xdata$x:0000304Co
.text$x:00003024                 mov     ecx, [ebp-10h]
.text$x:00003027                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00003027 __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 endp
.text$x:00003027
.text$x:0000302C
.text$x:0000302C ; =============== S U B R O U T I N E =======================================
.text$x:0000302C
.text$x:0000302C
.text$x:0000302C __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text$x:0000302C                                         ; DATA XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+5o
.text$x:0000302C
.text$x:0000302C arg_4           = dword ptr  8
.text$x:0000302C
.text$x:0000302C                 mov     edx, [esp+arg_4]
.text$x:00003030                 lea     eax, [edx+0Ch]
.text$x:00003033                 mov     ecx, [edx-18h]
.text$x:00003036                 xor     ecx, eax
.text$x:00003038                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000303D                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ
.text$x:00003042                 jmp     ___CxxFrameHandler3
.text$x:00003042 __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text$x:00003042
.text$x:00003042 ; ---------------------------------------------------------------------------
.text$x:00003047                 align 4
.text$x:00003047 _text$x         ends
.text$x:00003047
.xdata$x:00003048 ; ===========================================================================
.xdata$x:00003048
.xdata$x:00003048 ; Segment type: Pure data
.xdata$x:00003048 ; Segment permissions: Read
.xdata$x:00003048 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003048                 assume cs:_xdata$x
.xdata$x:00003048                 ;org 3048h
.xdata$x:00003048 ; COMDAT (pick associative to section at 2F68)
.xdata$x:00003048 __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ db 0FFh
.xdata$x:00003048                                         ; DATA XREF: .xdata$x:00003058o
.xdata$x:00003049                 db 0FFh
.xdata$x:0000304A                 db 0FFh
.xdata$x:0000304B                 db 0FFh
.xdata$x:0000304C                 dd offset __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0
.xdata$x:00003050 __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ db  22h ; "
.xdata$x:00003050                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ+11o
.xdata$x:00003051                 db    5
.xdata$x:00003052                 db  93h ; 
.xdata$x:00003053                 db  19h
.xdata$x:00003054                 db    1
.xdata$x:00003055                 db    0
.xdata$x:00003056                 db    0
.xdata$x:00003057                 db    0
.xdata$x:00003058                 dd offset __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ
.xdata$x:0000305C                 db    0
.xdata$x:0000305D                 db    0
.xdata$x:0000305E                 db    0
.xdata$x:0000305F                 db    0
.xdata$x:00003060                 db    0
.xdata$x:00003061                 db    0
.xdata$x:00003062                 db    0
.xdata$x:00003063                 db    0
.xdata$x:00003064                 db    0
.xdata$x:00003065                 db    0
.xdata$x:00003066                 db    0
.xdata$x:00003067                 db    0
.xdata$x:00003068                 db    0
.xdata$x:00003069                 db    0
.xdata$x:0000306A                 db    0
.xdata$x:0000306B                 db    0
.xdata$x:0000306C                 db    0
.xdata$x:0000306D                 db    0
.xdata$x:0000306E                 db    0
.xdata$x:0000306F                 db    0
.xdata$x:00003070                 db    1
.xdata$x:00003071                 db    0
.xdata$x:00003072                 db    0
.xdata$x:00003073                 db    0
.xdata$x:00003073 _xdata$x        ends
.xdata$x:00003073
.text:00003074 ; ===========================================================================
.text:00003074
.text:00003074 ; Segment type: Pure code
.text:00003074 ; Segment permissions: Read/Execute
.text:00003074 _text           segment para public 'CODE' use32
.text:00003074                 assume cs:_text
.text:00003074                 ;org 3074h
.text:00003074 ; COMDAT (pick any)
.text:00003074                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003074
.text:00003074 ; =============== S U B R O U T I N E =======================================
.text:00003074
.text:00003074 ; Attributes: bp-based frame
.text:00003074
.text:00003074 ; public: __thiscall CObjectVector<class CBuffer<unsigned char>>::~CObjectVector<class CBuffer<unsigned char>>(void)
.text:00003074                 public ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text:00003074 ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ proc near
.text:00003074                                         ; CODE XREF: CUniqBlocks::~CUniqBlocks(void)+58p
.text:00003074                                         ; __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0+3j
.text:00003074
.text:00003074 var_20          = dword ptr -20h
.text:00003074 var_1C          = dword ptr -1Ch
.text:00003074 var_18          = dword ptr -18h
.text:00003074 var_14          = dword ptr -14h
.text:00003074 var_10          = dword ptr -10h
.text:00003074 var_C           = dword ptr -0Ch
.text:00003074 var_4           = dword ptr -4
.text:00003074
.text:00003074                 push    ebp
.text:00003075                 mov     ebp, esp
.text:00003077                 push    0FFFFFFFFh
.text:00003079                 push    offset __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text:0000307E                 mov     eax, large fs:0
.text:00003084                 push    eax
.text:00003085                 sub     esp, 14h
.text:00003088                 mov     eax, 0CCCCCCCCh
.text:0000308D                 mov     [ebp+var_20], eax
.text:00003090                 mov     [ebp+var_1C], eax
.text:00003093                 mov     [ebp+var_18], eax
.text:00003096                 mov     [ebp+var_14], eax
.text:00003099                 mov     [ebp+var_10], eax
.text:0000309C                 mov     eax, dword ptr ds:___security_cookie
.text:000030A1                 xor     eax, ebp
.text:000030A3                 push    eax
.text:000030A4                 lea     eax, [ebp+var_C]
.text:000030A7                 mov     large fs:0, eax
.text:000030AD                 mov     [ebp+var_10], ecx
.text:000030B0                 mov     [ebp+var_4], 0
.text:000030B7                 mov     ecx, [ebp+var_10]
.text:000030BA                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000030BF                 mov     [ebp+var_14], eax
.text:000030C2
.text:000030C2 loc_30C2:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void):loc_3104j
.text:000030C2                 cmp     [ebp+var_14], 0
.text:000030C6                 jz      short loc_3106
.text:000030C8                 mov     eax, [ebp+var_14]
.text:000030CB                 sub     eax, 1
.text:000030CE                 mov     [ebp+var_14], eax
.text:000030D1                 mov     ecx, [ebp+var_14]
.text:000030D4                 push    ecx
.text:000030D5                 mov     ecx, [ebp+var_10]
.text:000030D8                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000030DD                 mov     edx, [eax]
.text:000030DF                 mov     [ebp+var_1C], edx
.text:000030E2                 mov     eax, [ebp+var_1C]
.text:000030E5                 mov     [ebp+var_18], eax
.text:000030E8                 cmp     [ebp+var_18], 0
.text:000030EC                 jz      short loc_30FD
.text:000030EE                 push    1
.text:000030F0                 mov     ecx, [ebp+var_18]
.text:000030F3                 call    ??_G?$CBuffer@E@@QAEPAXI@Z ; CBuffer<uchar>::`scalar deleting destructor'(uint)
.text:000030F8                 mov     [ebp+var_20], eax
.text:000030FB                 jmp     short loc_3104
.text:000030FD ; ---------------------------------------------------------------------------
.text:000030FD
.text:000030FD loc_30FD:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+78j
.text:000030FD                 mov     [ebp+var_20], 0
.text:00003104
.text:00003104 loc_3104:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+87j
.text:00003104                 jmp     short loc_30C2
.text:00003106 ; ---------------------------------------------------------------------------
.text:00003106
.text:00003106 loc_3106:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+52j
.text:00003106                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000310D                 mov     ecx, [ebp+var_10]
.text:00003110                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003115                 mov     ecx, [ebp+var_C]
.text:00003118                 mov     large fs:0, ecx
.text:0000311F                 pop     ecx
.text:00003120                 add     esp, 20h
.text:00003123                 cmp     ebp, esp
.text:00003125                 call    __RTC_CheckEsp
.text:0000312A                 mov     esp, ebp
.text:0000312C                 pop     ebp
.text:0000312D                 retn
.text:0000312D ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ endp
.text:0000312D
.text:0000312D ; ---------------------------------------------------------------------------
.text:0000312E                 align 10h
.text:0000312E _text           ends
.text:0000312E
.text$x:00003130 ; ===========================================================================
.text$x:00003130
.text$x:00003130 ; Segment type: Pure code
.text$x:00003130 ; Segment permissions: Read/Execute
.text$x:00003130 _text$x         segment para public 'CODE' use32
.text$x:00003130                 assume cs:_text$x
.text$x:00003130                 ;org 3130h
.text$x:00003130 ; COMDAT (pick associative to section at 3074)
.text$x:00003130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003130
.text$x:00003130 ; =============== S U B R O U T I N E =======================================
.text$x:00003130
.text$x:00003130
.text$x:00003130 __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0 proc near
.text$x:00003130                                         ; DATA XREF: .xdata$x:00003158o
.text$x:00003130                 mov     ecx, [ebp-10h]
.text$x:00003133                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00003133 __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0 endp
.text$x:00003133
.text$x:00003138
.text$x:00003138 ; =============== S U B R O U T I N E =======================================
.text$x:00003138
.text$x:00003138
.text$x:00003138 __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ proc near
.text$x:00003138                                         ; DATA XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+5o
.text$x:00003138
.text$x:00003138 arg_4           = dword ptr  8
.text$x:00003138
.text$x:00003138                 mov     edx, [esp+arg_4]
.text$x:0000313C                 lea     eax, [edx+0Ch]
.text$x:0000313F                 mov     ecx, [edx-18h]
.text$x:00003142                 xor     ecx, eax
.text$x:00003144                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003149                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text$x:0000314E                 jmp     ___CxxFrameHandler3
.text$x:0000314E __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ endp
.text$x:0000314E
.text$x:0000314E ; ---------------------------------------------------------------------------
.text$x:00003153                 align 4
.text$x:00003153 _text$x         ends
.text$x:00003153
.xdata$x:00003154 ; ===========================================================================
.xdata$x:00003154
.xdata$x:00003154 ; Segment type: Pure data
.xdata$x:00003154 ; Segment permissions: Read
.xdata$x:00003154 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003154                 assume cs:_xdata$x
.xdata$x:00003154                 ;org 3154h
.xdata$x:00003154 ; COMDAT (pick associative to section at 3074)
.xdata$x:00003154 __unwindtable$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ db 0FFh
.xdata$x:00003154                                         ; DATA XREF: .xdata$x:00003164o
.xdata$x:00003155                 db 0FFh
.xdata$x:00003156                 db 0FFh
.xdata$x:00003157                 db 0FFh
.xdata$x:00003158                 dd offset __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0
.xdata$x:0000315C __ehfuncinfo$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ db  22h ; "
.xdata$x:0000315C                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ+11o
.xdata$x:0000315D                 db    5
.xdata$x:0000315E                 db  93h ; 
.xdata$x:0000315F                 db  19h
.xdata$x:00003160                 db    1
.xdata$x:00003161                 db    0
.xdata$x:00003162                 db    0
.xdata$x:00003163                 db    0
.xdata$x:00003164                 dd offset __unwindtable$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.xdata$x:00003168                 db    0
.xdata$x:00003169                 db    0
.xdata$x:0000316A                 db    0
.xdata$x:0000316B                 db    0
.xdata$x:0000316C                 db    0
.xdata$x:0000316D                 db    0
.xdata$x:0000316E                 db    0
.xdata$x:0000316F                 db    0
.xdata$x:00003170                 db    0
.xdata$x:00003171                 db    0
.xdata$x:00003172                 db    0
.xdata$x:00003173                 db    0
.xdata$x:00003174                 db    0
.xdata$x:00003175                 db    0
.xdata$x:00003176                 db    0
.xdata$x:00003177                 db    0
.xdata$x:00003178                 db    0
.xdata$x:00003179                 db    0
.xdata$x:0000317A                 db    0
.xdata$x:0000317B                 db    0
.xdata$x:0000317C                 db    1
.xdata$x:0000317D                 db    0
.xdata$x:0000317E                 db    0
.xdata$x:0000317F                 db    0
.xdata$x:0000317F _xdata$x        ends
.xdata$x:0000317F
.text:00003180 ; ===========================================================================
.text:00003180
.text:00003180 ; Segment type: Pure code
.text:00003180 ; Segment permissions: Read/Execute
.text:00003180 _text           segment para public 'CODE' use32
.text:00003180                 assume cs:_text
.text:00003180                 ;org 3180h
.text:00003180 ; COMDAT (pick any)
.text:00003180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003180
.text:00003180 ; =============== S U B R O U T I N E =======================================
.text:00003180
.text:00003180 ; Attributes: bp-based frame
.text:00003180
.text:00003180 ; public: __thiscall CRecordVector<unsigned int>::~CRecordVector<unsigned int>(void)
.text:00003180                 public ??1?$CRecordVector@I@@QAE@XZ
.text:00003180 ??1?$CRecordVector@I@@QAE@XZ proc near  ; CODE XREF: CUniqBlocks::~CUniqBlocks(void)+3Ap
.text:00003180                                         ; CUniqBlocks::~CUniqBlocks(void)+49p ...
.text:00003180
.text:00003180 var_8           = dword ptr -8
.text:00003180 var_4           = dword ptr -4
.text:00003180
.text:00003180                 push    ebp
.text:00003181                 mov     ebp, esp
.text:00003183                 sub     esp, 8
.text:00003186                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000318D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003194                 mov     [ebp+var_4], ecx
.text:00003197                 mov     eax, [ebp+var_4]
.text:0000319A                 mov     ecx, [eax]
.text:0000319C                 mov     [ebp+var_8], ecx
.text:0000319F                 mov     edx, [ebp+var_8]
.text:000031A2                 push    edx             ; void *
.text:000031A3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000031A8                 add     esp, 4
.text:000031AB                 add     esp, 8
.text:000031AE                 cmp     ebp, esp
.text:000031B0                 call    __RTC_CheckEsp
.text:000031B5                 mov     esp, ebp
.text:000031B7                 pop     ebp
.text:000031B8                 retn
.text:000031B8 ??1?$CRecordVector@I@@QAE@XZ endp
.text:000031B8
.text:000031B8 ; ---------------------------------------------------------------------------
.text:000031B9                 align 4
.text:000031B9 _text           ends
.text:000031B9
.text:000031BC ; ===========================================================================
.text:000031BC
.text:000031BC ; Segment type: Pure code
.text:000031BC ; Segment permissions: Read/Execute
.text:000031BC _text           segment para public 'CODE' use32
.text:000031BC                 assume cs:_text
.text:000031BC                 ;org 31BCh
.text:000031BC ; COMDAT (pick any)
.text:000031BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000031BC
.text:000031BC ; =============== S U B R O U T I N E =======================================
.text:000031BC
.text:000031BC ; Attributes: bp-based frame
.text:000031BC
.text:000031BC ; public: __thiscall CBuffer<unsigned char>::CBuffer<unsigned char>(void)
.text:000031BC                 public ??0?$CBuffer@E@@QAE@XZ
.text:000031BC ??0?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: CDirItem::CDirItem(void)+45p
.text:000031BC                                         ; CDirItem::CDirItem(void)+54p
.text:000031BC
.text:000031BC var_4           = dword ptr -4
.text:000031BC
.text:000031BC                 push    ebp
.text:000031BD                 mov     ebp, esp
.text:000031BF                 push    ecx
.text:000031C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000031C7                 mov     [ebp+var_4], ecx
.text:000031CA                 mov     eax, [ebp+var_4]
.text:000031CD                 mov     dword ptr [eax], 0
.text:000031D3                 mov     ecx, [ebp+var_4]
.text:000031D6                 mov     dword ptr [ecx+4], 0
.text:000031DD                 mov     eax, [ebp+var_4]
.text:000031E0                 mov     esp, ebp
.text:000031E2                 pop     ebp
.text:000031E3                 retn
.text:000031E3 ??0?$CBuffer@E@@QAE@XZ endp
.text:000031E3
.text:000031E3 _text           ends
.text:000031E3
.text:000031E4 ; ===========================================================================
.text:000031E4
.text:000031E4 ; Segment type: Pure code
.text:000031E4 ; Segment permissions: Read/Execute
.text:000031E4 _text           segment para public 'CODE' use32
.text:000031E4                 assume cs:_text
.text:000031E4                 ;org 31E4h
.text:000031E4 ; COMDAT (pick any)
.text:000031E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000031E4
.text:000031E4 ; =============== S U B R O U T I N E =======================================
.text:000031E4
.text:000031E4 ; Attributes: bp-based frame
.text:000031E4
.text:000031E4 ; public: __thiscall CBuffer<unsigned char>::~CBuffer<unsigned char>(void)
.text:000031E4                 public ??1?$CBuffer@E@@QAE@XZ
.text:000031E4 ??1?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: __unwindfunclet$??0CDirItem@@QAE@XZ$1+6j
.text:000031E4                                         ; CDirItems::~CDirItems(void)+3Dp ...
.text:000031E4
.text:000031E4 var_8           = dword ptr -8
.text:000031E4 var_4           = dword ptr -4
.text:000031E4
.text:000031E4                 push    ebp
.text:000031E5                 mov     ebp, esp
.text:000031E7                 sub     esp, 8
.text:000031EA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000031F1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000031F8                 mov     [ebp+var_4], ecx
.text:000031FB                 mov     eax, [ebp+var_4]
.text:000031FE                 mov     ecx, [eax]
.text:00003200                 mov     [ebp+var_8], ecx
.text:00003203                 mov     edx, [ebp+var_8]
.text:00003206                 push    edx             ; void *
.text:00003207                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000320C                 add     esp, 4
.text:0000320F                 add     esp, 8
.text:00003212                 cmp     ebp, esp
.text:00003214                 call    __RTC_CheckEsp
.text:00003219                 mov     esp, ebp
.text:0000321B                 pop     ebp
.text:0000321C                 retn
.text:0000321C ??1?$CBuffer@E@@QAE@XZ endp
.text:0000321C
.text:0000321C ; ---------------------------------------------------------------------------
.text:0000321D                 align 10h
.text:0000321D _text           ends
.text:0000321D
.text:00003220 ; ===========================================================================
.text:00003220
.text:00003220 ; Segment type: Pure code
.text:00003220 ; Segment permissions: Read/Execute
.text:00003220 _text           segment para public 'CODE' use32
.text:00003220                 assume cs:_text
.text:00003220                 ;org 3220h
.text:00003220 ; COMDAT (pick any)
.text:00003220                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003220
.text:00003220 ; =============== S U B R O U T I N E =======================================
.text:00003220
.text:00003220 ; Attributes: bp-based frame
.text:00003220
.text:00003220 ; public: __thiscall CRecordVector<int>::~CRecordVector<int>(void)
.text:00003220                 public ??1?$CRecordVector@H@@QAE@XZ
.text:00003220 ??1?$CRecordVector@H@@QAE@XZ proc near  ; CODE XREF: CDirItems::~CDirItems(void)+6Ap
.text:00003220                                         ; CDirItems::~CDirItems(void)+79p ...
.text:00003220
.text:00003220 var_8           = dword ptr -8
.text:00003220 var_4           = dword ptr -4
.text:00003220
.text:00003220                 push    ebp
.text:00003221                 mov     ebp, esp
.text:00003223                 sub     esp, 8
.text:00003226                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000322D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003234                 mov     [ebp+var_4], ecx
.text:00003237                 mov     eax, [ebp+var_4]
.text:0000323A                 mov     ecx, [eax]
.text:0000323C                 mov     [ebp+var_8], ecx
.text:0000323F                 mov     edx, [ebp+var_8]
.text:00003242                 push    edx             ; void *
.text:00003243                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003248                 add     esp, 4
.text:0000324B                 add     esp, 8
.text:0000324E                 cmp     ebp, esp
.text:00003250                 call    __RTC_CheckEsp
.text:00003255                 mov     esp, ebp
.text:00003257                 pop     ebp
.text:00003258                 retn
.text:00003258 ??1?$CRecordVector@H@@QAE@XZ endp
.text:00003258
.text:00003258 ; ---------------------------------------------------------------------------
.text:00003259                 align 4
.text:00003259 _text           ends
.text:00003259
.text:0000325C ; ===========================================================================
.text:0000325C
.text:0000325C ; Segment type: Pure code
.text:0000325C ; Segment permissions: Read/Execute
.text:0000325C _text           segment para public 'CODE' use32
.text:0000325C                 assume cs:_text
.text:0000325C                 ;org 325Ch
.text:0000325C ; COMDAT (pick any)
.text:0000325C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000325C
.text:0000325C ; =============== S U B R O U T I N E =======================================
.text:0000325C
.text:0000325C ; Attributes: bp-based frame
.text:0000325C
.text:0000325C ; public: unsigned int __thiscall CObjectVector<struct CDirItem>::Size(void)const
.text:0000325C                 public ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ
.text:0000325C ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ proc near
.text:0000325C                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+4B6p
.text:0000325C
.text:0000325C var_4           = dword ptr -4
.text:0000325C
.text:0000325C                 push    ebp
.text:0000325D                 mov     ebp, esp
.text:0000325F                 push    ecx
.text:00003260                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003267                 mov     [ebp+var_4], ecx
.text:0000326A                 mov     ecx, [ebp+var_4]
.text:0000326D                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003272                 add     esp, 4
.text:00003275                 cmp     ebp, esp
.text:00003277                 call    __RTC_CheckEsp
.text:0000327C                 mov     esp, ebp
.text:0000327E                 pop     ebp
.text:0000327F                 retn
.text:0000327F ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ endp
.text:0000327F
.text:0000327F _text           ends
.text:0000327F
.text:00003280 ; ===========================================================================
.text:00003280
.text:00003280 ; Segment type: Pure code
.text:00003280 ; Segment permissions: Read/Execute
.text:00003280 _text           segment para public 'CODE' use32
.text:00003280                 assume cs:_text
.text:00003280                 ;org 3280h
.text:00003280 ; COMDAT (pick any)
.text:00003280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003280
.text:00003280 ; =============== S U B R O U T I N E =======================================
.text:00003280
.text:00003280 ; Attributes: bp-based frame
.text:00003280
.text:00003280 ; public: struct CDirItem & __thiscall CObjectVector<struct CDirItem>::operator[](unsigned int)
.text:00003280                 public ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z
.text:00003280 ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z proc near
.text:00003280                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+5D4p
.text:00003280
.text:00003280 var_4           = dword ptr -4
.text:00003280 arg_0           = dword ptr  8
.text:00003280
.text:00003280                 push    ebp
.text:00003281                 mov     ebp, esp
.text:00003283                 push    ecx
.text:00003284                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000328B                 mov     [ebp+var_4], ecx
.text:0000328E                 mov     eax, [ebp+arg_0]
.text:00003291                 push    eax
.text:00003292                 mov     ecx, [ebp+var_4]
.text:00003295                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000329A                 mov     eax, [eax]
.text:0000329C                 add     esp, 4
.text:0000329F                 cmp     ebp, esp
.text:000032A1                 call    __RTC_CheckEsp
.text:000032A6                 mov     esp, ebp
.text:000032A8                 pop     ebp
.text:000032A9                 retn    4
.text:000032A9 ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z endp
.text:000032A9
.text:000032A9 _text           ends
.text:000032A9
.text:000032AC ; ===========================================================================
.text:000032AC
.text:000032AC ; Segment type: Pure code
.text:000032AC ; Segment permissions: Read/Execute
.text:000032AC _text           segment para public 'CODE' use32
.text:000032AC                 assume cs:_text
.text:000032AC                 ;org 32ACh
.text:000032AC ; COMDAT (pick any)
.text:000032AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000032AC
.text:000032AC ; =============== S U B R O U T I N E =======================================
.text:000032AC
.text:000032AC ; Attributes: bp-based frame
.text:000032AC
.text:000032AC ; public: unsigned int __thiscall CObjectVector<struct CDirItem>::Add(struct CDirItem const &)
.text:000032AC                 public ?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z
.text:000032AC ?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z proc near
.text:000032AC                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+E1p
.text:000032AC
.text:000032AC var_1C          = dword ptr -1Ch
.text:000032AC var_18          = dword ptr -18h
.text:000032AC var_14          = dword ptr -14h
.text:000032AC var_10          = dword ptr -10h
.text:000032AC var_C           = dword ptr -0Ch
.text:000032AC var_4           = dword ptr -4
.text:000032AC arg_0           = dword ptr  8
.text:000032AC
.text:000032AC                 push    ebp
.text:000032AD                 mov     ebp, esp
.text:000032AF                 push    0FFFFFFFFh
.text:000032B1                 push    offset __ehhandler$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z
.text:000032B6                 mov     eax, large fs:0
.text:000032BC                 push    eax
.text:000032BD                 sub     esp, 10h
.text:000032C0                 mov     eax, 0CCCCCCCCh
.text:000032C5                 mov     [ebp+var_1C], eax
.text:000032C8                 mov     [ebp+var_18], eax
.text:000032CB                 mov     [ebp+var_14], eax
.text:000032CE                 mov     [ebp+var_10], eax
.text:000032D1                 mov     eax, dword ptr ds:___security_cookie
.text:000032D6                 xor     eax, ebp
.text:000032D8                 push    eax
.text:000032D9                 lea     eax, [ebp+var_C]
.text:000032DC                 mov     large fs:0, eax
.text:000032E2                 mov     [ebp+var_10], ecx
.text:000032E5                 push    50h ; 'P'       ; unsigned int
.text:000032E7                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000032EC                 add     esp, 4
.text:000032EF                 mov     [ebp+var_18], eax
.text:000032F2                 mov     [ebp+var_4], 0
.text:000032F9                 cmp     [ebp+var_18], 0
.text:000032FD                 jz      short loc_3310
.text:000032FF                 mov     eax, [ebp+arg_0]
.text:00003302                 push    eax
.text:00003303                 mov     ecx, [ebp+var_18]
.text:00003306                 call    ??0CDirItem@@QAE@ABU0@@Z ; CDirItem::CDirItem(CDirItem const &)
.text:0000330B                 mov     [ebp+var_1C], eax
.text:0000330E                 jmp     short loc_3317
.text:00003310 ; ---------------------------------------------------------------------------
.text:00003310
.text:00003310 loc_3310:                               ; CODE XREF: CObjectVector<CDirItem>::Add(CDirItem const &)+51j
.text:00003310                 mov     [ebp+var_1C], 0
.text:00003317
.text:00003317 loc_3317:                               ; CODE XREF: CObjectVector<CDirItem>::Add(CDirItem const &)+62j
.text:00003317                 mov     ecx, [ebp+var_1C]
.text:0000331A                 mov     [ebp+var_14], ecx
.text:0000331D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003324                 mov     edx, [ebp+var_14]
.text:00003327                 push    edx
.text:00003328                 mov     ecx, [ebp+var_10]
.text:0000332B                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00003330                 mov     ecx, [ebp+var_C]
.text:00003333                 mov     large fs:0, ecx
.text:0000333A                 pop     ecx
.text:0000333B                 add     esp, 1Ch
.text:0000333E                 cmp     ebp, esp
.text:00003340                 call    __RTC_CheckEsp
.text:00003345                 mov     esp, ebp
.text:00003347                 pop     ebp
.text:00003348                 retn    4
.text:00003348 ?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z endp
.text:00003348
.text:00003348 ; ---------------------------------------------------------------------------
.text:0000334B                 align 4
.text:0000334B _text           ends
.text:0000334B
.text$x:0000334C ; ===========================================================================
.text$x:0000334C
.text$x:0000334C ; Segment type: Pure code
.text$x:0000334C ; Segment permissions: Read/Execute
.text$x:0000334C _text$x         segment para public 'CODE' use32
.text$x:0000334C                 assume cs:_text$x
.text$x:0000334C                 ;org 334Ch
.text$x:0000334C ; COMDAT (pick associative to section at 32AC)
.text$x:0000334C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000334C
.text$x:0000334C ; =============== S U B R O U T I N E =======================================
.text$x:0000334C
.text$x:0000334C
.text$x:0000334C __unwindfunclet$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z$0 proc near
.text$x:0000334C                                         ; DATA XREF: .xdata$x:00003378o
.text$x:0000334C                 mov     eax, [ebp-18h]
.text$x:0000334F                 push    eax             ; void *
.text$x:00003350                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00003355                 pop     ecx
.text$x:00003356                 retn
.text$x:00003356 __unwindfunclet$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z$0 endp
.text$x:00003356
.text$x:00003357
.text$x:00003357 ; =============== S U B R O U T I N E =======================================
.text$x:00003357
.text$x:00003357
.text$x:00003357 __ehhandler$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z proc near
.text$x:00003357                                         ; DATA XREF: CObjectVector<CDirItem>::Add(CDirItem const &)+5o
.text$x:00003357
.text$x:00003357 arg_4           = dword ptr  8
.text$x:00003357
.text$x:00003357                 mov     edx, [esp+arg_4]
.text$x:0000335B                 lea     eax, [edx+0Ch]
.text$x:0000335E                 mov     ecx, [edx-14h]
.text$x:00003361                 xor     ecx, eax
.text$x:00003363                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003368                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z
.text$x:0000336D                 jmp     ___CxxFrameHandler3
.text$x:0000336D __ehhandler$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z endp
.text$x:0000336D
.text$x:0000336D ; ---------------------------------------------------------------------------
.text$x:00003372                 align 4
.text$x:00003372 _text$x         ends
.text$x:00003372
.xdata$x:00003374 ; ===========================================================================
.xdata$x:00003374
.xdata$x:00003374 ; Segment type: Pure data
.xdata$x:00003374 ; Segment permissions: Read
.xdata$x:00003374 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003374                 assume cs:_xdata$x
.xdata$x:00003374                 ;org 3374h
.xdata$x:00003374 ; COMDAT (pick associative to section at 32AC)
.xdata$x:00003374 __unwindtable$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z db 0FFh
.xdata$x:00003374                                         ; DATA XREF: .xdata$x:00003384o
.xdata$x:00003375                 db 0FFh
.xdata$x:00003376                 db 0FFh
.xdata$x:00003377                 db 0FFh
.xdata$x:00003378                 dd offset __unwindfunclet$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z$0
.xdata$x:0000337C __ehfuncinfo$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z db  22h ; "
.xdata$x:0000337C                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z+11o
.xdata$x:0000337D                 db    5
.xdata$x:0000337E                 db  93h ; 
.xdata$x:0000337F                 db  19h
.xdata$x:00003380                 db    1
.xdata$x:00003381                 db    0
.xdata$x:00003382                 db    0
.xdata$x:00003383                 db    0
.xdata$x:00003384                 dd offset __unwindtable$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z
.xdata$x:00003388                 db    0
.xdata$x:00003389                 db    0
.xdata$x:0000338A                 db    0
.xdata$x:0000338B                 db    0
.xdata$x:0000338C                 db    0
.xdata$x:0000338D                 db    0
.xdata$x:0000338E                 db    0
.xdata$x:0000338F                 db    0
.xdata$x:00003390                 db    0
.xdata$x:00003391                 db    0
.xdata$x:00003392                 db    0
.xdata$x:00003393                 db    0
.xdata$x:00003394                 db    0
.xdata$x:00003395                 db    0
.xdata$x:00003396                 db    0
.xdata$x:00003397                 db    0
.xdata$x:00003398                 db    0
.xdata$x:00003399                 db    0
.xdata$x:0000339A                 db    0
.xdata$x:0000339B                 db    0
.xdata$x:0000339C                 db    1
.xdata$x:0000339D                 db    0
.xdata$x:0000339E                 db    0
.xdata$x:0000339F                 db    0
.xdata$x:0000339F _xdata$x        ends
.xdata$x:0000339F
.text:000033A0 ; ===========================================================================
.text:000033A0
.text:000033A0 ; Segment type: Pure code
.text:000033A0 ; Segment permissions: Read/Execute
.text:000033A0 _text           segment para public 'CODE' use32
.text:000033A0                 assume cs:_text
.text:000033A0                 ;org 33A0h
.text:000033A0 ; COMDAT (pick any)
.text:000033A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000033A0
.text:000033A0 ; =============== S U B R O U T I N E =======================================
.text:000033A0
.text:000033A0 ; Attributes: bp-based frame
.text:000033A0
.text:000033A0 ; public: __thiscall CObjectVector<struct CDirItem>::~CObjectVector<struct CDirItem>(void)
.text:000033A0                 public ??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.text:000033A0 ??1?$CObjectVector@UCDirItem@@@@QAE@XZ proc near
.text:000033A0                                         ; CODE XREF: CDirItems::~CDirItems(void)+5Bp
.text:000033A0                                         ; __unwindfunclet$??1CDirItems@@QAE@XZ$3+6j
.text:000033A0
.text:000033A0 var_20          = dword ptr -20h
.text:000033A0 var_1C          = dword ptr -1Ch
.text:000033A0 var_18          = dword ptr -18h
.text:000033A0 var_14          = dword ptr -14h
.text:000033A0 var_10          = dword ptr -10h
.text:000033A0 var_C           = dword ptr -0Ch
.text:000033A0 var_4           = dword ptr -4
.text:000033A0
.text:000033A0                 push    ebp
.text:000033A1                 mov     ebp, esp
.text:000033A3                 push    0FFFFFFFFh
.text:000033A5                 push    offset __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.text:000033AA                 mov     eax, large fs:0
.text:000033B0                 push    eax
.text:000033B1                 sub     esp, 14h
.text:000033B4                 mov     eax, 0CCCCCCCCh
.text:000033B9                 mov     [ebp+var_20], eax
.text:000033BC                 mov     [ebp+var_1C], eax
.text:000033BF                 mov     [ebp+var_18], eax
.text:000033C2                 mov     [ebp+var_14], eax
.text:000033C5                 mov     [ebp+var_10], eax
.text:000033C8                 mov     eax, dword ptr ds:___security_cookie
.text:000033CD                 xor     eax, ebp
.text:000033CF                 push    eax
.text:000033D0                 lea     eax, [ebp+var_C]
.text:000033D3                 mov     large fs:0, eax
.text:000033D9                 mov     [ebp+var_10], ecx
.text:000033DC                 mov     [ebp+var_4], 0
.text:000033E3                 mov     ecx, [ebp+var_10]
.text:000033E6                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000033EB                 mov     [ebp+var_14], eax
.text:000033EE
.text:000033EE loc_33EE:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void):loc_3430j
.text:000033EE                 cmp     [ebp+var_14], 0
.text:000033F2                 jz      short loc_3432
.text:000033F4                 mov     eax, [ebp+var_14]
.text:000033F7                 sub     eax, 1
.text:000033FA                 mov     [ebp+var_14], eax
.text:000033FD                 mov     ecx, [ebp+var_14]
.text:00003400                 push    ecx
.text:00003401                 mov     ecx, [ebp+var_10]
.text:00003404                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003409                 mov     edx, [eax]
.text:0000340B                 mov     [ebp+var_1C], edx
.text:0000340E                 mov     eax, [ebp+var_1C]
.text:00003411                 mov     [ebp+var_18], eax
.text:00003414                 cmp     [ebp+var_18], 0
.text:00003418                 jz      short loc_3429
.text:0000341A                 push    1
.text:0000341C                 mov     ecx, [ebp+var_18]
.text:0000341F                 call    ??_GCDirItem@@QAEPAXI@Z ; CDirItem::`scalar deleting destructor'(uint)
.text:00003424                 mov     [ebp+var_20], eax
.text:00003427                 jmp     short loc_3430
.text:00003429 ; ---------------------------------------------------------------------------
.text:00003429
.text:00003429 loc_3429:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+78j
.text:00003429                 mov     [ebp+var_20], 0
.text:00003430
.text:00003430 loc_3430:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+87j
.text:00003430                 jmp     short loc_33EE
.text:00003432 ; ---------------------------------------------------------------------------
.text:00003432
.text:00003432 loc_3432:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+52j
.text:00003432                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003439                 mov     ecx, [ebp+var_10]
.text:0000343C                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003441                 mov     ecx, [ebp+var_C]
.text:00003444                 mov     large fs:0, ecx
.text:0000344B                 pop     ecx
.text:0000344C                 add     esp, 20h
.text:0000344F                 cmp     ebp, esp
.text:00003451                 call    __RTC_CheckEsp
.text:00003456                 mov     esp, ebp
.text:00003458                 pop     ebp
.text:00003459                 retn
.text:00003459 ??1?$CObjectVector@UCDirItem@@@@QAE@XZ endp
.text:00003459
.text:00003459 ; ---------------------------------------------------------------------------
.text:0000345A                 align 4
.text:0000345A _text           ends
.text:0000345A
.text$x:0000345C ; ===========================================================================
.text$x:0000345C
.text$x:0000345C ; Segment type: Pure code
.text$x:0000345C ; Segment permissions: Read/Execute
.text$x:0000345C _text$x         segment para public 'CODE' use32
.text$x:0000345C                 assume cs:_text$x
.text$x:0000345C                 ;org 345Ch
.text$x:0000345C ; COMDAT (pick associative to section at 33A0)
.text$x:0000345C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000345C
.text$x:0000345C ; =============== S U B R O U T I N E =======================================
.text$x:0000345C
.text$x:0000345C
.text$x:0000345C __unwindfunclet$??1?$CObjectVector@UCDirItem@@@@QAE@XZ$0 proc near
.text$x:0000345C                                         ; DATA XREF: .xdata$x:00003484o
.text$x:0000345C                 mov     ecx, [ebp-10h]
.text$x:0000345F                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000345F __unwindfunclet$??1?$CObjectVector@UCDirItem@@@@QAE@XZ$0 endp
.text$x:0000345F
.text$x:00003464
.text$x:00003464 ; =============== S U B R O U T I N E =======================================
.text$x:00003464
.text$x:00003464
.text$x:00003464 __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ proc near
.text$x:00003464                                         ; DATA XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+5o
.text$x:00003464
.text$x:00003464 arg_4           = dword ptr  8
.text$x:00003464
.text$x:00003464                 mov     edx, [esp+arg_4]
.text$x:00003468                 lea     eax, [edx+0Ch]
.text$x:0000346B                 mov     ecx, [edx-18h]
.text$x:0000346E                 xor     ecx, eax
.text$x:00003470                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003475                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.text$x:0000347A                 jmp     ___CxxFrameHandler3
.text$x:0000347A __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ endp
.text$x:0000347A
.text$x:0000347A ; ---------------------------------------------------------------------------
.text$x:0000347F                 align 10h
.text$x:0000347F _text$x         ends
.text$x:0000347F
.xdata$x:00003480 ; ===========================================================================
.xdata$x:00003480
.xdata$x:00003480 ; Segment type: Pure data
.xdata$x:00003480 ; Segment permissions: Read
.xdata$x:00003480 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003480                 assume cs:_xdata$x
.xdata$x:00003480                 ;org 3480h
.xdata$x:00003480 ; COMDAT (pick associative to section at 33A0)
.xdata$x:00003480 __unwindtable$??1?$CObjectVector@UCDirItem@@@@QAE@XZ db 0FFh
.xdata$x:00003480                                         ; DATA XREF: .xdata$x:00003490o
.xdata$x:00003481                 db 0FFh
.xdata$x:00003482                 db 0FFh
.xdata$x:00003483                 db 0FFh
.xdata$x:00003484                 dd offset __unwindfunclet$??1?$CObjectVector@UCDirItem@@@@QAE@XZ$0
.xdata$x:00003488 __ehfuncinfo$??1?$CObjectVector@UCDirItem@@@@QAE@XZ db  22h ; "
.xdata$x:00003488                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ+11o
.xdata$x:00003489                 db    5
.xdata$x:0000348A                 db  93h ; 
.xdata$x:0000348B                 db  19h
.xdata$x:0000348C                 db    1
.xdata$x:0000348D                 db    0
.xdata$x:0000348E                 db    0
.xdata$x:0000348F                 db    0
.xdata$x:00003490                 dd offset __unwindtable$??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.xdata$x:00003494                 db    0
.xdata$x:00003495                 db    0
.xdata$x:00003496                 db    0
.xdata$x:00003497                 db    0
.xdata$x:00003498                 db    0
.xdata$x:00003499                 db    0
.xdata$x:0000349A                 db    0
.xdata$x:0000349B                 db    0
.xdata$x:0000349C                 db    0
.xdata$x:0000349D                 db    0
.xdata$x:0000349E                 db    0
.xdata$x:0000349F                 db    0
.xdata$x:000034A0                 db    0
.xdata$x:000034A1                 db    0
.xdata$x:000034A2                 db    0
.xdata$x:000034A3                 db    0
.xdata$x:000034A4                 db    0
.xdata$x:000034A5                 db    0
.xdata$x:000034A6                 db    0
.xdata$x:000034A7                 db    0
.xdata$x:000034A8                 db    1
.xdata$x:000034A9                 db    0
.xdata$x:000034AA                 db    0
.xdata$x:000034AB                 db    0
.xdata$x:000034AB _xdata$x        ends
.xdata$x:000034AB
.text:000034AC ; ===========================================================================
.text:000034AC
.text:000034AC ; Segment type: Pure code
.text:000034AC ; Segment permissions: Read/Execute
.text:000034AC _text           segment para public 'CODE' use32
.text:000034AC                 assume cs:_text
.text:000034AC                 ;org 34ACh
.text:000034AC ; COMDAT (pick any)
.text:000034AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000034AC
.text:000034AC ; =============== S U B R O U T I N E =======================================
.text:000034AC
.text:000034AC ; Attributes: bp-based frame
.text:000034AC
.text:000034AC ; public: __thiscall CObjectVector<struct CProp>::CObjectVector<struct CProp>(void)
.text:000034AC                 public ??0?$CObjectVector@UCProp@@@@QAE@XZ
.text:000034AC ??0?$CObjectVector@UCProp@@@@QAE@XZ proc near
.text:000034AC                                         ; CODE XREF: CProps::CProps(void)+11p
.text:000034AC
.text:000034AC var_4           = dword ptr -4
.text:000034AC
.text:000034AC                 push    ebp
.text:000034AD                 mov     ebp, esp
.text:000034AF                 push    ecx
.text:000034B0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000034B7                 mov     [ebp+var_4], ecx
.text:000034BA                 mov     ecx, [ebp+var_4]
.text:000034BD                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:000034C2                 mov     eax, [ebp+var_4]
.text:000034C5                 add     esp, 4
.text:000034C8                 cmp     ebp, esp
.text:000034CA                 call    __RTC_CheckEsp
.text:000034CF                 mov     esp, ebp
.text:000034D1                 pop     ebp
.text:000034D2                 retn
.text:000034D2 ??0?$CObjectVector@UCProp@@@@QAE@XZ endp
.text:000034D2
.text:000034D2 ; ---------------------------------------------------------------------------
.text:000034D3                 align 4
.text:000034D3 _text           ends
.text:000034D3
.text:000034D4 ; ===========================================================================
.text:000034D4
.text:000034D4 ; Segment type: Pure code
.text:000034D4 ; Segment permissions: Read/Execute
.text:000034D4 _text           segment para public 'CODE' use32
.text:000034D4                 assume cs:_text
.text:000034D4                 ;org 34D4h
.text:000034D4 ; COMDAT (pick any)
.text:000034D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000034D4
.text:000034D4 ; =============== S U B R O U T I N E =======================================
.text:000034D4
.text:000034D4 ; Attributes: bp-based frame
.text:000034D4
.text:000034D4 ; public: __thiscall CObjectVector<struct CProp>::~CObjectVector<struct CProp>(void)
.text:000034D4                 public ??1?$CObjectVector@UCProp@@@@QAE@XZ
.text:000034D4 ??1?$CObjectVector@UCProp@@@@QAE@XZ proc near
.text:000034D4                                         ; CODE XREF: CProps::~CProps(void)+11p
.text:000034D4
.text:000034D4 var_20          = dword ptr -20h
.text:000034D4 var_1C          = dword ptr -1Ch
.text:000034D4 var_18          = dword ptr -18h
.text:000034D4 var_14          = dword ptr -14h
.text:000034D4 var_10          = dword ptr -10h
.text:000034D4 var_C           = dword ptr -0Ch
.text:000034D4 var_4           = dword ptr -4
.text:000034D4
.text:000034D4                 push    ebp
.text:000034D5                 mov     ebp, esp
.text:000034D7                 push    0FFFFFFFFh
.text:000034D9                 push    offset __ehhandler$??1?$CObjectVector@UCProp@@@@QAE@XZ
.text:000034DE                 mov     eax, large fs:0
.text:000034E4                 push    eax
.text:000034E5                 sub     esp, 14h
.text:000034E8                 mov     eax, 0CCCCCCCCh
.text:000034ED                 mov     [ebp+var_20], eax
.text:000034F0                 mov     [ebp+var_1C], eax
.text:000034F3                 mov     [ebp+var_18], eax
.text:000034F6                 mov     [ebp+var_14], eax
.text:000034F9                 mov     [ebp+var_10], eax
.text:000034FC                 mov     eax, dword ptr ds:___security_cookie
.text:00003501                 xor     eax, ebp
.text:00003503                 push    eax
.text:00003504                 lea     eax, [ebp+var_C]
.text:00003507                 mov     large fs:0, eax
.text:0000350D                 mov     [ebp+var_10], ecx
.text:00003510                 mov     [ebp+var_4], 0
.text:00003517                 mov     ecx, [ebp+var_10]
.text:0000351A                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000351F                 mov     [ebp+var_14], eax
.text:00003522
.text:00003522 loc_3522:                               ; CODE XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void):loc_3564j
.text:00003522                 cmp     [ebp+var_14], 0
.text:00003526                 jz      short loc_3566
.text:00003528                 mov     eax, [ebp+var_14]
.text:0000352B                 sub     eax, 1
.text:0000352E                 mov     [ebp+var_14], eax
.text:00003531                 mov     ecx, [ebp+var_14]
.text:00003534                 push    ecx
.text:00003535                 mov     ecx, [ebp+var_10]
.text:00003538                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000353D                 mov     edx, [eax]
.text:0000353F                 mov     [ebp+var_1C], edx
.text:00003542                 mov     eax, [ebp+var_1C]
.text:00003545                 mov     [ebp+var_18], eax
.text:00003548                 cmp     [ebp+var_18], 0
.text:0000354C                 jz      short loc_355D
.text:0000354E                 push    1
.text:00003550                 mov     ecx, [ebp+var_18]
.text:00003553                 call    ??_GCProp@@QAEPAXI@Z ; CProp::`scalar deleting destructor'(uint)
.text:00003558                 mov     [ebp+var_20], eax
.text:0000355B                 jmp     short loc_3564
.text:0000355D ; ---------------------------------------------------------------------------
.text:0000355D
.text:0000355D loc_355D:                               ; CODE XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void)+78j
.text:0000355D                 mov     [ebp+var_20], 0
.text:00003564
.text:00003564 loc_3564:                               ; CODE XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void)+87j
.text:00003564                 jmp     short loc_3522
.text:00003566 ; ---------------------------------------------------------------------------
.text:00003566
.text:00003566 loc_3566:                               ; CODE XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void)+52j
.text:00003566                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000356D                 mov     ecx, [ebp+var_10]
.text:00003570                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003575                 mov     ecx, [ebp+var_C]
.text:00003578                 mov     large fs:0, ecx
.text:0000357F                 pop     ecx
.text:00003580                 add     esp, 20h
.text:00003583                 cmp     ebp, esp
.text:00003585                 call    __RTC_CheckEsp
.text:0000358A                 mov     esp, ebp
.text:0000358C                 pop     ebp
.text:0000358D                 retn
.text:0000358D ??1?$CObjectVector@UCProp@@@@QAE@XZ endp
.text:0000358D
.text:0000358D ; ---------------------------------------------------------------------------
.text:0000358E                 align 10h
.text:0000358E _text           ends
.text:0000358E
.text$x:00003590 ; ===========================================================================
.text$x:00003590
.text$x:00003590 ; Segment type: Pure code
.text$x:00003590 ; Segment permissions: Read/Execute
.text$x:00003590 _text$x         segment para public 'CODE' use32
.text$x:00003590                 assume cs:_text$x
.text$x:00003590                 ;org 3590h
.text$x:00003590 ; COMDAT (pick associative to section at 34D4)
.text$x:00003590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003590
.text$x:00003590 ; =============== S U B R O U T I N E =======================================
.text$x:00003590
.text$x:00003590
.text$x:00003590 __unwindfunclet$??1?$CObjectVector@UCProp@@@@QAE@XZ$0 proc near
.text$x:00003590                                         ; DATA XREF: .xdata$x:000035B8o
.text$x:00003590                 mov     ecx, [ebp-10h]
.text$x:00003593                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00003593 __unwindfunclet$??1?$CObjectVector@UCProp@@@@QAE@XZ$0 endp
.text$x:00003593
.text$x:00003598
.text$x:00003598 ; =============== S U B R O U T I N E =======================================
.text$x:00003598
.text$x:00003598
.text$x:00003598 __ehhandler$??1?$CObjectVector@UCProp@@@@QAE@XZ proc near
.text$x:00003598                                         ; DATA XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void)+5o
.text$x:00003598
.text$x:00003598 arg_4           = dword ptr  8
.text$x:00003598
.text$x:00003598                 mov     edx, [esp+arg_4]
.text$x:0000359C                 lea     eax, [edx+0Ch]
.text$x:0000359F                 mov     ecx, [edx-18h]
.text$x:000035A2                 xor     ecx, eax
.text$x:000035A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000035A9                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCProp@@@@QAE@XZ
.text$x:000035AE                 jmp     ___CxxFrameHandler3
.text$x:000035AE __ehhandler$??1?$CObjectVector@UCProp@@@@QAE@XZ endp
.text$x:000035AE
.text$x:000035AE ; ---------------------------------------------------------------------------
.text$x:000035B3                 align 4
.text$x:000035B3 _text$x         ends
.text$x:000035B3
.xdata$x:000035B4 ; ===========================================================================
.xdata$x:000035B4
.xdata$x:000035B4 ; Segment type: Pure data
.xdata$x:000035B4 ; Segment permissions: Read
.xdata$x:000035B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000035B4                 assume cs:_xdata$x
.xdata$x:000035B4                 ;org 35B4h
.xdata$x:000035B4 ; COMDAT (pick associative to section at 34D4)
.xdata$x:000035B4 __unwindtable$??1?$CObjectVector@UCProp@@@@QAE@XZ db 0FFh
.xdata$x:000035B4                                         ; DATA XREF: .xdata$x:000035C4o
.xdata$x:000035B5                 db 0FFh
.xdata$x:000035B6                 db 0FFh
.xdata$x:000035B7                 db 0FFh
.xdata$x:000035B8                 dd offset __unwindfunclet$??1?$CObjectVector@UCProp@@@@QAE@XZ$0
.xdata$x:000035BC __ehfuncinfo$??1?$CObjectVector@UCProp@@@@QAE@XZ db  22h ; "
.xdata$x:000035BC                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCProp@@@@QAE@XZ+11o
.xdata$x:000035BD                 db    5
.xdata$x:000035BE                 db  93h ; 
.xdata$x:000035BF                 db  19h
.xdata$x:000035C0                 db    1
.xdata$x:000035C1                 db    0
.xdata$x:000035C2                 db    0
.xdata$x:000035C3                 db    0
.xdata$x:000035C4                 dd offset __unwindtable$??1?$CObjectVector@UCProp@@@@QAE@XZ
.xdata$x:000035C8                 db    0
.xdata$x:000035C9                 db    0
.xdata$x:000035CA                 db    0
.xdata$x:000035CB                 db    0
.xdata$x:000035CC                 db    0
.xdata$x:000035CD                 db    0
.xdata$x:000035CE                 db    0
.xdata$x:000035CF                 db    0
.xdata$x:000035D0                 db    0
.xdata$x:000035D1                 db    0
.xdata$x:000035D2                 db    0
.xdata$x:000035D3                 db    0
.xdata$x:000035D4                 db    0
.xdata$x:000035D5                 db    0
.xdata$x:000035D6                 db    0
.xdata$x:000035D7                 db    0
.xdata$x:000035D8                 db    0
.xdata$x:000035D9                 db    0
.xdata$x:000035DA                 db    0
.xdata$x:000035DB                 db    0
.xdata$x:000035DC                 db    1
.xdata$x:000035DD                 db    0
.xdata$x:000035DE                 db    0
.xdata$x:000035DF                 db    0
.xdata$x:000035DF _xdata$x        ends
.xdata$x:000035DF
.text:000035E0 ; ===========================================================================
.text:000035E0
.text:000035E0 ; Segment type: Pure code
.text:000035E0 ; Segment permissions: Read/Execute
.text:000035E0 _text           segment para public 'CODE' use32
.text:000035E0                 assume cs:_text
.text:000035E0                 ;org 35E0h
.text:000035E0 ; COMDAT (pick any)
.text:000035E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000035E0
.text:000035E0 ; =============== S U B R O U T I N E =======================================
.text:000035E0
.text:000035E0 ; Attributes: bp-based frame
.text:000035E0
.text:000035E0 ; public: __thiscall CMyComPtr<struct IHasher>::CMyComPtr<struct IHasher>(void)
.text:000035E0                 public ??0?$CMyComPtr@UIHasher@@@@QAE@XZ
.text:000035E0 ??0?$CMyComPtr@UIHasher@@@@QAE@XZ proc near
.text:000035E0                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+348p
.text:000035E0                                         ; CHasherState::CHasherState(void)+30p
.text:000035E0
.text:000035E0 var_4           = dword ptr -4
.text:000035E0
.text:000035E0                 push    ebp
.text:000035E1                 mov     ebp, esp
.text:000035E3                 push    ecx
.text:000035E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000035EB                 mov     [ebp+var_4], ecx
.text:000035EE                 mov     eax, [ebp+var_4]
.text:000035F1                 mov     dword ptr [eax], 0
.text:000035F7                 mov     eax, [ebp+var_4]
.text:000035FA                 mov     esp, ebp
.text:000035FC                 pop     ebp
.text:000035FD                 retn
.text:000035FD ??0?$CMyComPtr@UIHasher@@@@QAE@XZ endp
.text:000035FD
.text:000035FD ; ---------------------------------------------------------------------------
.text:000035FE                 align 10h
.text:000035FE _text           ends
.text:000035FE
.text:00003600 ; ===========================================================================
.text:00003600
.text:00003600 ; Segment type: Pure code
.text:00003600 ; Segment permissions: Read/Execute
.text:00003600 _text           segment para public 'CODE' use32
.text:00003600                 assume cs:_text
.text:00003600                 ;org 3600h
.text:00003600 ; COMDAT (pick any)
.text:00003600                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003600
.text:00003600 ; =============== S U B R O U T I N E =======================================
.text:00003600
.text:00003600 ; Attributes: bp-based frame
.text:00003600
.text:00003600 ; public: __thiscall CMyComPtr<struct IHasher>::~CMyComPtr<struct IHasher>(void)
.text:00003600                 public ??1?$CMyComPtr@UIHasher@@@@QAE@XZ
.text:00003600 ??1?$CMyComPtr@UIHasher@@@@QAE@XZ proc near
.text:00003600                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+3BAp
.text:00003600                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+4CAp ...
.text:00003600
.text:00003600 var_4           = dword ptr -4
.text:00003600
.text:00003600                 push    ebp
.text:00003601                 mov     ebp, esp
.text:00003603                 push    ecx
.text:00003604                 push    esi
.text:00003605                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000360C                 mov     [ebp+var_4], ecx
.text:0000360F                 mov     eax, [ebp+var_4]
.text:00003612                 cmp     dword ptr [eax], 0
.text:00003615                 jz      short loc_3632
.text:00003617                 mov     ecx, [ebp+var_4]
.text:0000361A                 mov     edx, [ecx]
.text:0000361C                 mov     eax, [ebp+var_4]
.text:0000361F                 mov     ecx, [eax]
.text:00003621                 mov     edx, [edx]
.text:00003623                 mov     esi, esp
.text:00003625                 push    ecx
.text:00003626                 mov     eax, [edx+8]
.text:00003629                 call    eax
.text:0000362B                 cmp     esi, esp
.text:0000362D                 call    __RTC_CheckEsp
.text:00003632
.text:00003632 loc_3632:                               ; CODE XREF: CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)+15j
.text:00003632                 pop     esi
.text:00003633                 add     esp, 4
.text:00003636                 cmp     ebp, esp
.text:00003638                 call    __RTC_CheckEsp
.text:0000363D                 mov     esp, ebp
.text:0000363F                 pop     ebp
.text:00003640                 retn
.text:00003640 ??1?$CMyComPtr@UIHasher@@@@QAE@XZ endp
.text:00003640
.text:00003640 ; ---------------------------------------------------------------------------
.text:00003641                 align 4
.text:00003641 _text           ends
.text:00003641
.text:00003644 ; ===========================================================================
.text:00003644
.text:00003644 ; Segment type: Pure code
.text:00003644 ; Segment permissions: Read/Execute
.text:00003644 _text           segment para public 'CODE' use32
.text:00003644                 assume cs:_text
.text:00003644                 ;org 3644h
.text:00003644 ; COMDAT (pick any)
.text:00003644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003644
.text:00003644 ; =============== S U B R O U T I N E =======================================
.text:00003644
.text:00003644 ; Attributes: bp-based frame
.text:00003644
.text:00003644 ; public: struct IHasher * __thiscall CMyComPtr<struct IHasher>::operator->(void)const
.text:00003644                 public ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ
.text:00003644 ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ proc near
.text:00003644                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+516p
.text:00003644                                         ; CHashBundle::InitForNewFile(void)+63p ...
.text:00003644
.text:00003644 var_4           = dword ptr -4
.text:00003644
.text:00003644                 push    ebp
.text:00003645                 mov     ebp, esp
.text:00003647                 push    ecx
.text:00003648                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000364F                 mov     [ebp+var_4], ecx
.text:00003652                 mov     eax, [ebp+var_4]
.text:00003655                 mov     eax, [eax]
.text:00003657                 mov     esp, ebp
.text:00003659                 pop     ebp
.text:0000365A                 retn
.text:0000365A ??C?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ endp
.text:0000365A
.text:0000365A ; ---------------------------------------------------------------------------
.text:0000365B                 align 4
.text:0000365B _text           ends
.text:0000365B
.text:0000365C ; ===========================================================================
.text:0000365C
.text:0000365C ; Segment type: Pure code
.text:0000365C ; Segment permissions: Read/Execute
.text:0000365C _text           segment para public 'CODE' use32
.text:0000365C                 assume cs:_text
.text:0000365C                 ;org 365Ch
.text:0000365C ; COMDAT (pick any)
.text:0000365C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000365C
.text:0000365C ; =============== S U B R O U T I N E =======================================
.text:0000365C
.text:0000365C ; Attributes: bp-based frame
.text:0000365C
.text:0000365C ; public: struct IHasher * __thiscall CMyComPtr<struct IHasher>::operator=(class CMyComPtr<struct IHasher> const &)
.text:0000365C                 public ??4?$CMyComPtr@UIHasher@@@@QAEPAUIHasher@@ABV0@@Z
.text:0000365C ??4?$CMyComPtr@UIHasher@@@@QAEPAUIHasher@@ABV0@@Z proc near
.text:0000365C                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+5C5p
.text:0000365C
.text:0000365C var_4           = dword ptr -4
.text:0000365C arg_0           = dword ptr  8
.text:0000365C
.text:0000365C                 push    ebp
.text:0000365D                 mov     ebp, esp
.text:0000365F                 push    ecx
.text:00003660                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003667                 mov     [ebp+var_4], ecx
.text:0000366A                 mov     eax, [ebp+arg_0]
.text:0000366D                 mov     ecx, [eax]
.text:0000366F                 push    ecx
.text:00003670                 mov     ecx, [ebp+var_4]
.text:00003673                 call    ??4?$CMyComPtr@UIHasher@@@@QAEPAUIHasher@@PAU1@@Z ; CMyComPtr<IHasher>::operator=(IHasher *)
.text:00003678                 add     esp, 4
.text:0000367B                 cmp     ebp, esp
.text:0000367D                 call    __RTC_CheckEsp
.text:00003682                 mov     esp, ebp
.text:00003684                 pop     ebp
.text:00003685                 retn    4
.text:00003685 ??4?$CMyComPtr@UIHasher@@@@QAEPAUIHasher@@ABV0@@Z endp
.text:00003685
.text:00003685 _text           ends
.text:00003685
.text:00003688 ; ===========================================================================
.text:00003688
.text:00003688 ; Segment type: Pure code
.text:00003688 ; Segment permissions: Read/Execute
.text:00003688 _text           segment para public 'CODE' use32
.text:00003688                 assume cs:_text
.text:00003688                 ;org 3688h
.text:00003688 ; COMDAT (pick any)
.text:00003688                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003688
.text:00003688 ; =============== S U B R O U T I N E =======================================
.text:00003688
.text:00003688 ; Attributes: bp-based frame
.text:00003688
.text:00003688 ; public: bool __thiscall CMyComPtr<struct IHasher>::operator!(void)const
.text:00003688                 public ??7?$CMyComPtr@UIHasher@@@@QBE_NXZ
.text:00003688 ??7?$CMyComPtr@UIHasher@@@@QBE_NXZ proc near
.text:00003688                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+3F7p
.text:00003688
.text:00003688 var_4           = dword ptr -4
.text:00003688
.text:00003688                 push    ebp
.text:00003689                 mov     ebp, esp
.text:0000368B                 push    ecx
.text:0000368C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003693                 mov     [ebp+var_4], ecx
.text:00003696                 mov     eax, [ebp+var_4]
.text:00003699                 xor     ecx, ecx
.text:0000369B                 cmp     dword ptr [eax], 0
.text:0000369E                 setz    cl
.text:000036A1                 mov     al, cl
.text:000036A3                 mov     esp, ebp
.text:000036A5                 pop     ebp
.text:000036A6                 retn
.text:000036A6 ??7?$CMyComPtr@UIHasher@@@@QBE_NXZ endp
.text:000036A6
.text:000036A6 ; ---------------------------------------------------------------------------
.text:000036A7                 align 4
.text:000036A7 _text           ends
.text:000036A7
.text:000036A8 ; ===========================================================================
.text:000036A8
.text:000036A8 ; Segment type: Pure code
.text:000036A8 ; Segment permissions: Read/Execute
.text:000036A8 _text           segment para public 'CODE' use32
.text:000036A8                 assume cs:_text
.text:000036A8                 ;org 36A8h
.text:000036A8 ; COMDAT (pick any)
.text:000036A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000036A8
.text:000036A8 ; =============== S U B R O U T I N E =======================================
.text:000036A8
.text:000036A8 ; Attributes: bp-based frame
.text:000036A8
.text:000036A8 ; public: unsigned int __thiscall CObjectVector<struct CHasherState>::Size(void)const
.text:000036A8                 public ?Size@?$CObjectVector@UCHasherState@@@@QBEIXZ
.text:000036A8 ?Size@?$CObjectVector@UCHasherState@@@@QBEIXZ proc near
.text:000036A8                                         ; CODE XREF: CHashBundle::InitForNewFile(void)+44p
.text:000036A8                                         ; CHashBundle::Update(void const *,uint)+4Ep ...
.text:000036A8
.text:000036A8 var_4           = dword ptr -4
.text:000036A8
.text:000036A8                 push    ebp
.text:000036A9                 mov     ebp, esp
.text:000036AB                 push    ecx
.text:000036AC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000036B3                 mov     [ebp+var_4], ecx
.text:000036B6                 mov     ecx, [ebp+var_4]
.text:000036B9                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000036BE                 add     esp, 4
.text:000036C1                 cmp     ebp, esp
.text:000036C3                 call    __RTC_CheckEsp
.text:000036C8                 mov     esp, ebp
.text:000036CA                 pop     ebp
.text:000036CB                 retn
.text:000036CB ?Size@?$CObjectVector@UCHasherState@@@@QBEIXZ endp
.text:000036CB
.text:000036CB _text           ends
.text:000036CB
.text:000036CC ; ===========================================================================
.text:000036CC
.text:000036CC ; Segment type: Pure code
.text:000036CC ; Segment permissions: Read/Execute
.text:000036CC _text           segment para public 'CODE' use32
.text:000036CC                 assume cs:_text
.text:000036CC                 ;org 36CCh
.text:000036CC ; COMDAT (pick any)
.text:000036CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000036CC
.text:000036CC ; =============== S U B R O U T I N E =======================================
.text:000036CC
.text:000036CC ; Attributes: bp-based frame
.text:000036CC
.text:000036CC ; public: __thiscall CObjectVector<struct CHasherState>::CObjectVector<struct CHasherState>(void)
.text:000036CC                 public ??0?$CObjectVector@UCHasherState@@@@QAE@XZ
.text:000036CC ??0?$CObjectVector@UCHasherState@@@@QAE@XZ proc near
.text:000036CC                                         ; CODE XREF: CHashBundle::CHashBundle(void)+25p
.text:000036CC
.text:000036CC var_4           = dword ptr -4
.text:000036CC
.text:000036CC                 push    ebp
.text:000036CD                 mov     ebp, esp
.text:000036CF                 push    ecx
.text:000036D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000036D7                 mov     [ebp+var_4], ecx
.text:000036DA                 mov     ecx, [ebp+var_4]
.text:000036DD                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:000036E2                 mov     eax, [ebp+var_4]
.text:000036E5                 add     esp, 4
.text:000036E8                 cmp     ebp, esp
.text:000036EA                 call    __RTC_CheckEsp
.text:000036EF                 mov     esp, ebp
.text:000036F1                 pop     ebp
.text:000036F2                 retn
.text:000036F2 ??0?$CObjectVector@UCHasherState@@@@QAE@XZ endp
.text:000036F2
.text:000036F2 ; ---------------------------------------------------------------------------
.text:000036F3                 align 4
.text:000036F3 _text           ends
.text:000036F3
.text:000036F4 ; ===========================================================================
.text:000036F4
.text:000036F4 ; Segment type: Pure code
.text:000036F4 ; Segment permissions: Read/Execute
.text:000036F4 _text           segment para public 'CODE' use32
.text:000036F4                 assume cs:_text
.text:000036F4                 ;org 36F4h
.text:000036F4 ; COMDAT (pick any)
.text:000036F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000036F4
.text:000036F4 ; =============== S U B R O U T I N E =======================================
.text:000036F4
.text:000036F4 ; Attributes: bp-based frame
.text:000036F4
.text:000036F4 ; public: struct CHasherState & __thiscall CObjectVector<struct CHasherState>::operator[](unsigned int)
.text:000036F4                 public ??A?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@I@Z
.text:000036F4 ??A?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@I@Z proc near
.text:000036F4                                         ; CODE XREF: CHashBundle::InitForNewFile(void)+58p
.text:000036F4                                         ; CHashBundle::Update(void const *,uint)+62p ...
.text:000036F4
.text:000036F4 var_4           = dword ptr -4
.text:000036F4 arg_0           = dword ptr  8
.text:000036F4
.text:000036F4                 push    ebp
.text:000036F5                 mov     ebp, esp
.text:000036F7                 push    ecx
.text:000036F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000036FF                 mov     [ebp+var_4], ecx
.text:00003702                 mov     eax, [ebp+arg_0]
.text:00003705                 push    eax
.text:00003706                 mov     ecx, [ebp+var_4]
.text:00003709                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000370E                 mov     eax, [eax]
.text:00003710                 add     esp, 4
.text:00003713                 cmp     ebp, esp
.text:00003715                 call    __RTC_CheckEsp
.text:0000371A                 mov     esp, ebp
.text:0000371C                 pop     ebp
.text:0000371D                 retn    4
.text:0000371D ??A?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@I@Z endp
.text:0000371D
.text:0000371D _text           ends
.text:0000371D
.text:00003720 ; ===========================================================================
.text:00003720
.text:00003720 ; Segment type: Pure code
.text:00003720 ; Segment permissions: Read/Execute
.text:00003720 _text           segment para public 'CODE' use32
.text:00003720                 assume cs:_text
.text:00003720                 ;org 3720h
.text:00003720 ; COMDAT (pick any)
.text:00003720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003720
.text:00003720 ; =============== S U B R O U T I N E =======================================
.text:00003720
.text:00003720 ; Attributes: bp-based frame
.text:00003720
.text:00003720 ; public: struct CHasherState & __thiscall CObjectVector<struct CHasherState>::AddNew(void)
.text:00003720                 public ?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ
.text:00003720 ?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ proc near
.text:00003720                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+5ADp
.text:00003720
.text:00003720 var_20          = dword ptr -20h
.text:00003720 var_1C          = dword ptr -1Ch
.text:00003720 var_18          = dword ptr -18h
.text:00003720 var_14          = dword ptr -14h
.text:00003720 var_10          = dword ptr -10h
.text:00003720 var_C           = dword ptr -0Ch
.text:00003720 var_4           = dword ptr -4
.text:00003720
.text:00003720                 push    ebp
.text:00003721                 mov     ebp, esp
.text:00003723                 push    0FFFFFFFFh
.text:00003725                 push    offset __ehhandler$?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ
.text:0000372A                 mov     eax, large fs:0
.text:00003730                 push    eax
.text:00003731                 sub     esp, 14h
.text:00003734                 mov     eax, 0CCCCCCCCh
.text:00003739                 mov     [ebp+var_20], eax
.text:0000373C                 mov     [ebp+var_1C], eax
.text:0000373F                 mov     [ebp+var_18], eax
.text:00003742                 mov     [ebp+var_14], eax
.text:00003745                 mov     [ebp+var_10], eax
.text:00003748                 mov     eax, dword ptr ds:___security_cookie
.text:0000374D                 xor     eax, ebp
.text:0000374F                 push    eax
.text:00003750                 lea     eax, [ebp+var_C]
.text:00003753                 mov     large fs:0, eax
.text:00003759                 mov     [ebp+var_10], ecx
.text:0000375C                 push    114h            ; unsigned int
.text:00003761                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003766                 add     esp, 4
.text:00003769                 mov     [ebp+var_1C], eax
.text:0000376C                 mov     [ebp+var_4], 0
.text:00003773                 cmp     [ebp+var_1C], 0
.text:00003777                 jz      short loc_3786
.text:00003779                 mov     ecx, [ebp+var_1C] ; this
.text:0000377C                 call    ??0CHasherState@@QAE@XZ ; CHasherState::CHasherState(void)
.text:00003781                 mov     [ebp+var_20], eax
.text:00003784                 jmp     short loc_378D
.text:00003786 ; ---------------------------------------------------------------------------
.text:00003786
.text:00003786 loc_3786:                               ; CODE XREF: CObjectVector<CHasherState>::AddNew(void)+57j
.text:00003786                 mov     [ebp+var_20], 0
.text:0000378D
.text:0000378D loc_378D:                               ; CODE XREF: CObjectVector<CHasherState>::AddNew(void)+64j
.text:0000378D                 mov     eax, [ebp+var_20]
.text:00003790                 mov     [ebp+var_18], eax
.text:00003793                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000379A                 mov     ecx, [ebp+var_18]
.text:0000379D                 mov     [ebp+var_14], ecx
.text:000037A0                 mov     edx, [ebp+var_14]
.text:000037A3                 push    edx
.text:000037A4                 mov     ecx, [ebp+var_10]
.text:000037A7                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:000037AC                 mov     eax, [ebp+var_14]
.text:000037AF                 mov     ecx, [ebp+var_C]
.text:000037B2                 mov     large fs:0, ecx
.text:000037B9                 pop     ecx
.text:000037BA                 add     esp, 20h
.text:000037BD                 cmp     ebp, esp
.text:000037BF                 call    __RTC_CheckEsp
.text:000037C4                 mov     esp, ebp
.text:000037C6                 pop     ebp
.text:000037C7                 retn
.text:000037C7 ?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ endp
.text:000037C7
.text:000037C7 _text           ends
.text:000037C7
.text$x:000037C8 ; ===========================================================================
.text$x:000037C8
.text$x:000037C8 ; Segment type: Pure code
.text$x:000037C8 ; Segment permissions: Read/Execute
.text$x:000037C8 _text$x         segment para public 'CODE' use32
.text$x:000037C8                 assume cs:_text$x
.text$x:000037C8                 ;org 37C8h
.text$x:000037C8 ; COMDAT (pick associative to section at 3720)
.text$x:000037C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000037C8
.text$x:000037C8 ; =============== S U B R O U T I N E =======================================
.text$x:000037C8
.text$x:000037C8
.text$x:000037C8 __unwindfunclet$?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ$0 proc near
.text$x:000037C8                                         ; DATA XREF: .xdata$x:000037F4o
.text$x:000037C8                 mov     eax, [ebp-1Ch]
.text$x:000037CB                 push    eax             ; void *
.text$x:000037CC                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000037D1                 pop     ecx
.text$x:000037D2                 retn
.text$x:000037D2 __unwindfunclet$?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ$0 endp
.text$x:000037D2
.text$x:000037D3
.text$x:000037D3 ; =============== S U B R O U T I N E =======================================
.text$x:000037D3
.text$x:000037D3
.text$x:000037D3 __ehhandler$?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ proc near
.text$x:000037D3                                         ; DATA XREF: CObjectVector<CHasherState>::AddNew(void)+5o
.text$x:000037D3
.text$x:000037D3 arg_4           = dword ptr  8
.text$x:000037D3
.text$x:000037D3                 mov     edx, [esp+arg_4]
.text$x:000037D7                 lea     eax, [edx+0Ch]
.text$x:000037DA                 mov     ecx, [edx-18h]
.text$x:000037DD                 xor     ecx, eax
.text$x:000037DF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000037E4                 mov     eax, offset __ehfuncinfo$?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ
.text$x:000037E9                 jmp     ___CxxFrameHandler3
.text$x:000037E9 __ehhandler$?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ endp
.text$x:000037E9
.text$x:000037E9 ; ---------------------------------------------------------------------------
.text$x:000037EE                 align 10h
.text$x:000037EE _text$x         ends
.text$x:000037EE
.xdata$x:000037F0 ; ===========================================================================
.xdata$x:000037F0
.xdata$x:000037F0 ; Segment type: Pure data
.xdata$x:000037F0 ; Segment permissions: Read
.xdata$x:000037F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000037F0                 assume cs:_xdata$x
.xdata$x:000037F0                 ;org 37F0h
.xdata$x:000037F0 ; COMDAT (pick associative to section at 3720)
.xdata$x:000037F0 __unwindtable$?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ db 0FFh
.xdata$x:000037F0                                         ; DATA XREF: .xdata$x:00003800o
.xdata$x:000037F1                 db 0FFh
.xdata$x:000037F2                 db 0FFh
.xdata$x:000037F3                 db 0FFh
.xdata$x:000037F4                 dd offset __unwindfunclet$?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ$0
.xdata$x:000037F8 __ehfuncinfo$?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ db  22h ; "
.xdata$x:000037F8                                         ; DATA XREF: __ehhandler$?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ+11o
.xdata$x:000037F9                 db    5
.xdata$x:000037FA                 db  93h ; 
.xdata$x:000037FB                 db  19h
.xdata$x:000037FC                 db    1
.xdata$x:000037FD                 db    0
.xdata$x:000037FE                 db    0
.xdata$x:000037FF                 db    0
.xdata$x:00003800                 dd offset __unwindtable$?AddNew@?$CObjectVector@UCHasherState@@@@QAEAAUCHasherState@@XZ
.xdata$x:00003804                 db    0
.xdata$x:00003805                 db    0
.xdata$x:00003806                 db    0
.xdata$x:00003807                 db    0
.xdata$x:00003808                 db    0
.xdata$x:00003809                 db    0
.xdata$x:0000380A                 db    0
.xdata$x:0000380B                 db    0
.xdata$x:0000380C                 db    0
.xdata$x:0000380D                 db    0
.xdata$x:0000380E                 db    0
.xdata$x:0000380F                 db    0
.xdata$x:00003810                 db    0
.xdata$x:00003811                 db    0
.xdata$x:00003812                 db    0
.xdata$x:00003813                 db    0
.xdata$x:00003814                 db    0
.xdata$x:00003815                 db    0
.xdata$x:00003816                 db    0
.xdata$x:00003817                 db    0
.xdata$x:00003818                 db    1
.xdata$x:00003819                 db    0
.xdata$x:0000381A                 db    0
.xdata$x:0000381B                 db    0
.xdata$x:0000381B _xdata$x        ends
.xdata$x:0000381B
.text:0000381C ; ===========================================================================
.text:0000381C
.text:0000381C ; Segment type: Pure code
.text:0000381C ; Segment permissions: Read/Execute
.text:0000381C _text           segment para public 'CODE' use32
.text:0000381C                 assume cs:_text
.text:0000381C                 ;org 381Ch
.text:0000381C ; COMDAT (pick any)
.text:0000381C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000381C
.text:0000381C ; =============== S U B R O U T I N E =======================================
.text:0000381C
.text:0000381C ; Attributes: bp-based frame
.text:0000381C
.text:0000381C ; public: __thiscall CObjectVector<struct CHasherState>::~CObjectVector<struct CHasherState>(void)
.text:0000381C                 public ??1?$CObjectVector@UCHasherState@@@@QAE@XZ
.text:0000381C ??1?$CObjectVector@UCHasherState@@@@QAE@XZ proc near
.text:0000381C                                         ; CODE XREF: CHashBundle::~CHashBundle(void)+14p
.text:0000381C
.text:0000381C var_20          = dword ptr -20h
.text:0000381C var_1C          = dword ptr -1Ch
.text:0000381C var_18          = dword ptr -18h
.text:0000381C var_14          = dword ptr -14h
.text:0000381C var_10          = dword ptr -10h
.text:0000381C var_C           = dword ptr -0Ch
.text:0000381C var_4           = dword ptr -4
.text:0000381C
.text:0000381C                 push    ebp
.text:0000381D                 mov     ebp, esp
.text:0000381F                 push    0FFFFFFFFh
.text:00003821                 push    offset __ehhandler$??1?$CObjectVector@UCHasherState@@@@QAE@XZ
.text:00003826                 mov     eax, large fs:0
.text:0000382C                 push    eax
.text:0000382D                 sub     esp, 14h
.text:00003830                 mov     eax, 0CCCCCCCCh
.text:00003835                 mov     [ebp+var_20], eax
.text:00003838                 mov     [ebp+var_1C], eax
.text:0000383B                 mov     [ebp+var_18], eax
.text:0000383E                 mov     [ebp+var_14], eax
.text:00003841                 mov     [ebp+var_10], eax
.text:00003844                 mov     eax, dword ptr ds:___security_cookie
.text:00003849                 xor     eax, ebp
.text:0000384B                 push    eax
.text:0000384C                 lea     eax, [ebp+var_C]
.text:0000384F                 mov     large fs:0, eax
.text:00003855                 mov     [ebp+var_10], ecx
.text:00003858                 mov     [ebp+var_4], 0
.text:0000385F                 mov     ecx, [ebp+var_10]
.text:00003862                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003867                 mov     [ebp+var_14], eax
.text:0000386A
.text:0000386A loc_386A:                               ; CODE XREF: CObjectVector<CHasherState>::~CObjectVector<CHasherState>(void):loc_38ACj
.text:0000386A                 cmp     [ebp+var_14], 0
.text:0000386E                 jz      short loc_38AE
.text:00003870                 mov     eax, [ebp+var_14]
.text:00003873                 sub     eax, 1
.text:00003876                 mov     [ebp+var_14], eax
.text:00003879                 mov     ecx, [ebp+var_14]
.text:0000387C                 push    ecx
.text:0000387D                 mov     ecx, [ebp+var_10]
.text:00003880                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003885                 mov     edx, [eax]
.text:00003887                 mov     [ebp+var_1C], edx
.text:0000388A                 mov     eax, [ebp+var_1C]
.text:0000388D                 mov     [ebp+var_18], eax
.text:00003890                 cmp     [ebp+var_18], 0
.text:00003894                 jz      short loc_38A5
.text:00003896                 push    1
.text:00003898                 mov     ecx, [ebp+var_18]
.text:0000389B                 call    ??_GCHasherState@@QAEPAXI@Z ; CHasherState::`scalar deleting destructor'(uint)
.text:000038A0                 mov     [ebp+var_20], eax
.text:000038A3                 jmp     short loc_38AC
.text:000038A5 ; ---------------------------------------------------------------------------
.text:000038A5
.text:000038A5 loc_38A5:                               ; CODE XREF: CObjectVector<CHasherState>::~CObjectVector<CHasherState>(void)+78j
.text:000038A5                 mov     [ebp+var_20], 0
.text:000038AC
.text:000038AC loc_38AC:                               ; CODE XREF: CObjectVector<CHasherState>::~CObjectVector<CHasherState>(void)+87j
.text:000038AC                 jmp     short loc_386A
.text:000038AE ; ---------------------------------------------------------------------------
.text:000038AE
.text:000038AE loc_38AE:                               ; CODE XREF: CObjectVector<CHasherState>::~CObjectVector<CHasherState>(void)+52j
.text:000038AE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000038B5                 mov     ecx, [ebp+var_10]
.text:000038B8                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:000038BD                 mov     ecx, [ebp+var_C]
.text:000038C0                 mov     large fs:0, ecx
.text:000038C7                 pop     ecx
.text:000038C8                 add     esp, 20h
.text:000038CB                 cmp     ebp, esp
.text:000038CD                 call    __RTC_CheckEsp
.text:000038D2                 mov     esp, ebp
.text:000038D4                 pop     ebp
.text:000038D5                 retn
.text:000038D5 ??1?$CObjectVector@UCHasherState@@@@QAE@XZ endp
.text:000038D5
.text:000038D5 ; ---------------------------------------------------------------------------
.text:000038D6                 align 4
.text:000038D6 _text           ends
.text:000038D6
.text$x:000038D8 ; ===========================================================================
.text$x:000038D8
.text$x:000038D8 ; Segment type: Pure code
.text$x:000038D8 ; Segment permissions: Read/Execute
.text$x:000038D8 _text$x         segment para public 'CODE' use32
.text$x:000038D8                 assume cs:_text$x
.text$x:000038D8                 ;org 38D8h
.text$x:000038D8 ; COMDAT (pick associative to section at 381C)
.text$x:000038D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000038D8
.text$x:000038D8 ; =============== S U B R O U T I N E =======================================
.text$x:000038D8
.text$x:000038D8
.text$x:000038D8 __unwindfunclet$??1?$CObjectVector@UCHasherState@@@@QAE@XZ$0 proc near
.text$x:000038D8                                         ; DATA XREF: .xdata$x:00003900o
.text$x:000038D8                 mov     ecx, [ebp-10h]
.text$x:000038DB                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:000038DB __unwindfunclet$??1?$CObjectVector@UCHasherState@@@@QAE@XZ$0 endp
.text$x:000038DB
.text$x:000038E0
.text$x:000038E0 ; =============== S U B R O U T I N E =======================================
.text$x:000038E0
.text$x:000038E0
.text$x:000038E0 __ehhandler$??1?$CObjectVector@UCHasherState@@@@QAE@XZ proc near
.text$x:000038E0                                         ; DATA XREF: CObjectVector<CHasherState>::~CObjectVector<CHasherState>(void)+5o
.text$x:000038E0
.text$x:000038E0 arg_4           = dword ptr  8
.text$x:000038E0
.text$x:000038E0                 mov     edx, [esp+arg_4]
.text$x:000038E4                 lea     eax, [edx+0Ch]
.text$x:000038E7                 mov     ecx, [edx-18h]
.text$x:000038EA                 xor     ecx, eax
.text$x:000038EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000038F1                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCHasherState@@@@QAE@XZ
.text$x:000038F6                 jmp     ___CxxFrameHandler3
.text$x:000038F6 __ehhandler$??1?$CObjectVector@UCHasherState@@@@QAE@XZ endp
.text$x:000038F6
.text$x:000038F6 ; ---------------------------------------------------------------------------
.text$x:000038FB                 align 4
.text$x:000038FB _text$x         ends
.text$x:000038FB
.xdata$x:000038FC ; ===========================================================================
.xdata$x:000038FC
.xdata$x:000038FC ; Segment type: Pure data
.xdata$x:000038FC ; Segment permissions: Read
.xdata$x:000038FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000038FC                 assume cs:_xdata$x
.xdata$x:000038FC                 ;org 38FCh
.xdata$x:000038FC ; COMDAT (pick associative to section at 381C)
.xdata$x:000038FC __unwindtable$??1?$CObjectVector@UCHasherState@@@@QAE@XZ db 0FFh
.xdata$x:000038FC                                         ; DATA XREF: .xdata$x:0000390Co
.xdata$x:000038FD                 db 0FFh
.xdata$x:000038FE                 db 0FFh
.xdata$x:000038FF                 db 0FFh
.xdata$x:00003900                 dd offset __unwindfunclet$??1?$CObjectVector@UCHasherState@@@@QAE@XZ$0
.xdata$x:00003904 __ehfuncinfo$??1?$CObjectVector@UCHasherState@@@@QAE@XZ db  22h ; "
.xdata$x:00003904                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCHasherState@@@@QAE@XZ+11o
.xdata$x:00003905                 db    5
.xdata$x:00003906                 db  93h ; 
.xdata$x:00003907                 db  19h
.xdata$x:00003908                 db    1
.xdata$x:00003909                 db    0
.xdata$x:0000390A                 db    0
.xdata$x:0000390B                 db    0
.xdata$x:0000390C                 dd offset __unwindtable$??1?$CObjectVector@UCHasherState@@@@QAE@XZ
.xdata$x:00003910                 db    0
.xdata$x:00003911                 db    0
.xdata$x:00003912                 db    0
.xdata$x:00003913                 db    0
.xdata$x:00003914                 db    0
.xdata$x:00003915                 db    0
.xdata$x:00003916                 db    0
.xdata$x:00003917                 db    0
.xdata$x:00003918                 db    0
.xdata$x:00003919                 db    0
.xdata$x:0000391A                 db    0
.xdata$x:0000391B                 db    0
.xdata$x:0000391C                 db    0
.xdata$x:0000391D                 db    0
.xdata$x:0000391E                 db    0
.xdata$x:0000391F                 db    0
.xdata$x:00003920                 db    0
.xdata$x:00003921                 db    0
.xdata$x:00003922                 db    0
.xdata$x:00003923                 db    0
.xdata$x:00003924                 db    1
.xdata$x:00003925                 db    0
.xdata$x:00003926                 db    0
.xdata$x:00003927                 db    0
.xdata$x:00003927 _xdata$x        ends
.xdata$x:00003927
.text:00003928 ; ===========================================================================
.text:00003928
.text:00003928 ; Segment type: Pure code
.text:00003928 ; Segment permissions: Read/Execute
.text:00003928 _text           segment para public 'CODE' use32
.text:00003928                 assume cs:_text
.text:00003928                 ;org 3928h
.text:00003928 ; COMDAT (pick any)
.text:00003928                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003928
.text:00003928 ; =============== S U B R O U T I N E =======================================
.text:00003928
.text:00003928 ; Attributes: bp-based frame
.text:00003928
.text:00003928 ; public: __thiscall CRecordVector<unsigned __int64>::CRecordVector<unsigned __int64>(void)
.text:00003928                 public ??0?$CRecordVector@_K@@QAE@XZ
.text:00003928 ??0?$CRecordVector@_K@@QAE@XZ proc near ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+99p
.text:00003928                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+191p
.text:00003928
.text:00003928 var_4           = dword ptr -4
.text:00003928
.text:00003928                 push    ebp
.text:00003929                 mov     ebp, esp
.text:0000392B                 push    ecx
.text:0000392C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003933                 mov     [ebp+var_4], ecx
.text:00003936                 mov     eax, [ebp+var_4]
.text:00003939                 mov     dword ptr [eax], 0
.text:0000393F                 mov     ecx, [ebp+var_4]
.text:00003942                 mov     dword ptr [ecx+4], 0
.text:00003949                 mov     edx, [ebp+var_4]
.text:0000394C                 mov     dword ptr [edx+8], 0
.text:00003953                 mov     eax, [ebp+var_4]
.text:00003956                 mov     esp, ebp
.text:00003958                 pop     ebp
.text:00003959                 retn
.text:00003959 ??0?$CRecordVector@_K@@QAE@XZ endp
.text:00003959
.text:00003959 ; ---------------------------------------------------------------------------
.text:0000395A                 align 4
.text:0000395A _text           ends
.text:0000395A
.text:0000395C ; ===========================================================================
.text:0000395C
.text:0000395C ; Segment type: Pure code
.text:0000395C ; Segment permissions: Read/Execute
.text:0000395C _text           segment para public 'CODE' use32
.text:0000395C                 assume cs:_text
.text:0000395C                 ;org 395Ch
.text:0000395C ; COMDAT (pick any)
.text:0000395C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000395C
.text:0000395C ; =============== S U B R O U T I N E =======================================
.text:0000395C
.text:0000395C ; Attributes: bp-based frame
.text:0000395C
.text:0000395C ; public: unsigned int __thiscall CRecordVector<unsigned __int64>::Size(void)const
.text:0000395C                 public ?Size@?$CRecordVector@_K@@QBEIXZ
.text:0000395C ?Size@?$CRecordVector@_K@@QBEIXZ proc near
.text:0000395C                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+1D7p
.text:0000395C                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+20Ep ...
.text:0000395C
.text:0000395C var_4           = dword ptr -4
.text:0000395C
.text:0000395C                 push    ebp
.text:0000395D                 mov     ebp, esp
.text:0000395F                 push    ecx
.text:00003960                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003967                 mov     [ebp+var_4], ecx
.text:0000396A                 mov     eax, [ebp+var_4]
.text:0000396D                 mov     eax, [eax+4]
.text:00003970                 mov     esp, ebp
.text:00003972                 pop     ebp
.text:00003973                 retn
.text:00003973 ?Size@?$CRecordVector@_K@@QBEIXZ endp
.text:00003973
.text:00003973 _text           ends
.text:00003973
.text:00003974 ; ===========================================================================
.text:00003974
.text:00003974 ; Segment type: Pure code
.text:00003974 ; Segment permissions: Read/Execute
.text:00003974 _text           segment para public 'CODE' use32
.text:00003974                 assume cs:_text
.text:00003974                 ;org 3974h
.text:00003974 ; COMDAT (pick any)
.text:00003974                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003974
.text:00003974 ; =============== S U B R O U T I N E =======================================
.text:00003974
.text:00003974 ; Attributes: bp-based frame
.text:00003974
.text:00003974 ; public: __thiscall CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:00003974                 public ??1?$CRecordVector@_K@@QAE@XZ
.text:00003974 ??1?$CRecordVector@_K@@QAE@XZ proc near ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+135p
.text:00003974                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+243p ...
.text:00003974
.text:00003974 var_8           = dword ptr -8
.text:00003974 var_4           = dword ptr -4
.text:00003974
.text:00003974                 push    ebp
.text:00003975                 mov     ebp, esp
.text:00003977                 sub     esp, 8
.text:0000397A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003981                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003988                 mov     [ebp+var_4], ecx
.text:0000398B                 mov     eax, [ebp+var_4]
.text:0000398E                 mov     ecx, [eax]
.text:00003990                 mov     [ebp+var_8], ecx
.text:00003993                 mov     edx, [ebp+var_8]
.text:00003996                 push    edx             ; void *
.text:00003997                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000399C                 add     esp, 4
.text:0000399F                 add     esp, 8
.text:000039A2                 cmp     ebp, esp
.text:000039A4                 call    __RTC_CheckEsp
.text:000039A9                 mov     esp, ebp
.text:000039AB                 pop     ebp
.text:000039AC                 retn
.text:000039AC ??1?$CRecordVector@_K@@QAE@XZ endp
.text:000039AC
.text:000039AC ; ---------------------------------------------------------------------------
.text:000039AD                 align 10h
.text:000039AD _text           ends
.text:000039AD
.text:000039B0 ; ===========================================================================
.text:000039B0
.text:000039B0 ; Segment type: Pure code
.text:000039B0 ; Segment permissions: Read/Execute
.text:000039B0 _text           segment para public 'CODE' use32
.text:000039B0                 assume cs:_text
.text:000039B0                 ;org 39B0h
.text:000039B0 ; COMDAT (pick any)
.text:000039B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000039B0
.text:000039B0 ; =============== S U B R O U T I N E =======================================
.text:000039B0
.text:000039B0 ; Attributes: bp-based frame
.text:000039B0
.text:000039B0 ; public: void __thiscall CRecordVector<unsigned __int64>::Clear(void)
.text:000039B0                 public ?Clear@?$CRecordVector@_K@@QAEXXZ
.text:000039B0 ?Clear@?$CRecordVector@_K@@QAEXXZ proc near
.text:000039B0                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+1B1p
.text:000039B0
.text:000039B0 var_4           = dword ptr -4
.text:000039B0
.text:000039B0                 push    ebp
.text:000039B1                 mov     ebp, esp
.text:000039B3                 push    ecx
.text:000039B4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000039BB                 mov     [ebp+var_4], ecx
.text:000039BE                 mov     eax, [ebp+var_4]
.text:000039C1                 mov     dword ptr [eax+4], 0
.text:000039C8                 mov     esp, ebp
.text:000039CA                 pop     ebp
.text:000039CB                 retn
.text:000039CB ?Clear@?$CRecordVector@_K@@QAEXXZ endp
.text:000039CB
.text:000039CB _text           ends
.text:000039CB
.text:000039CC ; ===========================================================================
.text:000039CC
.text:000039CC ; Segment type: Pure code
.text:000039CC ; Segment permissions: Read/Execute
.text:000039CC _text           segment para public 'CODE' use32
.text:000039CC                 assume cs:_text
.text:000039CC                 ;org 39CCh
.text:000039CC ; COMDAT (pick any)
.text:000039CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000039CC
.text:000039CC ; =============== S U B R O U T I N E =======================================
.text:000039CC
.text:000039CC ; Attributes: bp-based frame
.text:000039CC
.text:000039CC ; public: unsigned __int64 & __thiscall CRecordVector<unsigned __int64>::operator[](unsigned int)
.text:000039CC                 public ??A?$CRecordVector@_K@@QAEAA_KI@Z
.text:000039CC ??A?$CRecordVector@_K@@QAEAA_KI@Z proc near
.text:000039CC                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+1F1p
.text:000039CC                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+375p ...
.text:000039CC
.text:000039CC var_4           = dword ptr -4
.text:000039CC arg_0           = dword ptr  8
.text:000039CC
.text:000039CC                 push    ebp
.text:000039CD                 mov     ebp, esp
.text:000039CF                 push    ecx
.text:000039D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000039D7                 mov     [ebp+var_4], ecx
.text:000039DA                 mov     eax, [ebp+var_4]
.text:000039DD                 mov     ecx, [eax]
.text:000039DF                 mov     edx, [ebp+arg_0]
.text:000039E2                 lea     eax, [ecx+edx*8]
.text:000039E5                 mov     esp, ebp
.text:000039E7                 pop     ebp
.text:000039E8                 retn    4
.text:000039E8 ??A?$CRecordVector@_K@@QAEAA_KI@Z endp
.text:000039E8
.text:000039E8 ; ---------------------------------------------------------------------------
.text:000039EB                 align 4
.text:000039EB _text           ends
.text:000039EB
.text:000039EC ; ===========================================================================
.text:000039EC
.text:000039EC ; Segment type: Pure code
.text:000039EC ; Segment permissions: Read/Execute
.text:000039EC _text           segment para public 'CODE' use32
.text:000039EC                 assume cs:_text
.text:000039EC                 ;org 39ECh
.text:000039EC ; COMDAT (pick any)
.text:000039EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000039EC
.text:000039EC ; =============== S U B R O U T I N E =======================================
.text:000039EC
.text:000039EC ; Attributes: bp-based frame
.text:000039EC
.text:000039EC ; public: unsigned int __thiscall CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)
.text:000039EC                 public ?AddToUniqueSorted@?$CRecordVector@_K@@QAEI_K@Z
.text:000039EC ?AddToUniqueSorted@?$CRecordVector@_K@@QAEI_K@Z proc near
.text:000039EC                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+200p
.text:000039EC                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+2D4p
.text:000039EC
.text:000039EC var_18          = dword ptr -18h
.text:000039EC var_14          = dword ptr -14h
.text:000039EC var_10          = dword ptr -10h
.text:000039EC var_C           = dword ptr -0Ch
.text:000039EC var_8           = dword ptr -8
.text:000039EC var_4           = dword ptr -4
.text:000039EC arg_0           = dword ptr  8
.text:000039EC arg_4           = dword ptr  0Ch
.text:000039EC
.text:000039EC                 push    ebp
.text:000039ED                 mov     ebp, esp
.text:000039EF                 sub     esp, 18h
.text:000039F2                 mov     eax, 0CCCCCCCCh
.text:000039F7                 mov     [ebp+var_18], eax
.text:000039FA                 mov     [ebp+var_14], eax
.text:000039FD                 mov     [ebp+var_10], eax
.text:00003A00                 mov     [ebp+var_C], eax
.text:00003A03                 mov     [ebp+var_8], eax
.text:00003A06                 mov     [ebp+var_4], eax
.text:00003A09                 mov     [ebp+var_4], ecx
.text:00003A0C                 mov     [ebp+var_8], 0
.text:00003A13                 mov     eax, [ebp+var_4]
.text:00003A16                 mov     ecx, [eax+4]
.text:00003A19                 mov     [ebp+var_C], ecx
.text:00003A1C
.text:00003A1C loc_3A1C:                               ; CODE XREF: CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64):loc_3A7Ej
.text:00003A1C                 mov     edx, [ebp+var_8]
.text:00003A1F                 cmp     edx, [ebp+var_C]
.text:00003A22                 jz      short loc_3A80
.text:00003A24                 mov     eax, [ebp+var_8]
.text:00003A27                 add     eax, [ebp+var_C]
.text:00003A2A                 shr     eax, 1
.text:00003A2C                 mov     [ebp+var_10], eax
.text:00003A2F                 mov     ecx, [ebp+var_10]
.text:00003A32                 push    ecx
.text:00003A33                 mov     ecx, [ebp+var_4]
.text:00003A36                 call    ??A?$CRecordVector@_K@@QAEAA_KI@Z ; CRecordVector<unsigned __int64>::operator[](uint)
.text:00003A3B                 mov     edx, [eax]
.text:00003A3D                 mov     [ebp+var_18], edx
.text:00003A40                 mov     eax, [eax+4]
.text:00003A43                 mov     [ebp+var_14], eax
.text:00003A46                 mov     ecx, [ebp+arg_0]
.text:00003A49                 cmp     ecx, [ebp+var_18]
.text:00003A4C                 jnz     short loc_3A5B
.text:00003A4E                 mov     edx, [ebp+arg_4]
.text:00003A51                 cmp     edx, [ebp+var_14]
.text:00003A54                 jnz     short loc_3A5B
.text:00003A56                 mov     eax, [ebp+var_10]
.text:00003A59                 jmp     short loc_3A97
.text:00003A5B ; ---------------------------------------------------------------------------
.text:00003A5B
.text:00003A5B loc_3A5B:                               ; CODE XREF: CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)+60j
.text:00003A5B                                         ; CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)+68j
.text:00003A5B                 mov     eax, [ebp+arg_4]
.text:00003A5E                 cmp     eax, [ebp+var_14]
.text:00003A61                 ja      short loc_3A75
.text:00003A63                 jb      short loc_3A6D
.text:00003A65                 mov     ecx, [ebp+arg_0]
.text:00003A68                 cmp     ecx, [ebp+var_18]
.text:00003A6B                 jnb     short loc_3A75
.text:00003A6D
.text:00003A6D loc_3A6D:                               ; CODE XREF: CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)+77j
.text:00003A6D                 mov     edx, [ebp+var_10]
.text:00003A70                 mov     [ebp+var_C], edx
.text:00003A73                 jmp     short loc_3A7E
.text:00003A75 ; ---------------------------------------------------------------------------
.text:00003A75
.text:00003A75 loc_3A75:                               ; CODE XREF: CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)+75j
.text:00003A75                                         ; CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)+7Fj
.text:00003A75                 mov     eax, [ebp+var_10]
.text:00003A78                 add     eax, 1
.text:00003A7B                 mov     [ebp+var_8], eax
.text:00003A7E
.text:00003A7E loc_3A7E:                               ; CODE XREF: CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)+87j
.text:00003A7E                 jmp     short loc_3A1C
.text:00003A80 ; ---------------------------------------------------------------------------
.text:00003A80
.text:00003A80 loc_3A80:                               ; CODE XREF: CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)+36j
.text:00003A80                 mov     ecx, [ebp+arg_4]
.text:00003A83                 push    ecx
.text:00003A84                 mov     edx, [ebp+arg_0]
.text:00003A87                 push    edx
.text:00003A88                 mov     eax, [ebp+var_C]
.text:00003A8B                 push    eax
.text:00003A8C                 mov     ecx, [ebp+var_4]
.text:00003A8F                 call    ?Insert@?$CRecordVector@_K@@QAEXI_K@Z ; CRecordVector<unsigned __int64>::Insert(uint,unsigned __int64)
.text:00003A94                 mov     eax, [ebp+var_C]
.text:00003A97
.text:00003A97 loc_3A97:                               ; CODE XREF: CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)+6Dj
.text:00003A97                 add     esp, 18h
.text:00003A9A                 cmp     ebp, esp
.text:00003A9C                 call    __RTC_CheckEsp
.text:00003AA1                 mov     esp, ebp
.text:00003AA3                 pop     ebp
.text:00003AA4                 retn    8
.text:00003AA4 ?AddToUniqueSorted@?$CRecordVector@_K@@QAEI_K@Z endp
.text:00003AA4
.text:00003AA4 ; ---------------------------------------------------------------------------
.text:00003AA7                 align 4
.text:00003AA7 _text           ends
.text:00003AA7
.text:00003AA8 ; ===========================================================================
.text:00003AA8
.text:00003AA8 ; Segment type: Pure code
.text:00003AA8 ; Segment permissions: Read/Execute
.text:00003AA8 _text           segment para public 'CODE' use32
.text:00003AA8                 assume cs:_text
.text:00003AA8                 ;org 3AA8h
.text:00003AA8 ; COMDAT (pick any)
.text:00003AA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003AA8
.text:00003AA8 ; =============== S U B R O U T I N E =======================================
.text:00003AA8
.text:00003AA8 ; Attributes: bp-based frame
.text:00003AA8
.text:00003AA8 ; public: unsigned int __thiscall CObjectVector<class COneMethodInfo>::Size(void)const
.text:00003AA8                 public ?Size@?$CObjectVector@VCOneMethodInfo@@@@QBEIXZ
.text:00003AA8 ?Size@?$CObjectVector@VCOneMethodInfo@@@@QBEIXZ proc near
.text:00003AA8                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+218p
.text:00003AA8                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+2ECp
.text:00003AA8
.text:00003AA8 var_4           = dword ptr -4
.text:00003AA8
.text:00003AA8                 push    ebp
.text:00003AA9                 mov     ebp, esp
.text:00003AAB                 push    ecx
.text:00003AAC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003AB3                 mov     [ebp+var_4], ecx
.text:00003AB6                 mov     ecx, [ebp+var_4]
.text:00003AB9                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003ABE                 add     esp, 4
.text:00003AC1                 cmp     ebp, esp
.text:00003AC3                 call    __RTC_CheckEsp
.text:00003AC8                 mov     esp, ebp
.text:00003ACA                 pop     ebp
.text:00003ACB                 retn
.text:00003ACB ?Size@?$CObjectVector@VCOneMethodInfo@@@@QBEIXZ endp
.text:00003ACB
.text:00003ACB _text           ends
.text:00003ACB
.text:00003ACC ; ===========================================================================
.text:00003ACC
.text:00003ACC ; Segment type: Pure code
.text:00003ACC ; Segment permissions: Read/Execute
.text:00003ACC _text           segment para public 'CODE' use32
.text:00003ACC                 assume cs:_text
.text:00003ACC                 ;org 3ACCh
.text:00003ACC ; COMDAT (pick any)
.text:00003ACC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003ACC
.text:00003ACC ; =============== S U B R O U T I N E =======================================
.text:00003ACC
.text:00003ACC ; Attributes: bp-based frame
.text:00003ACC
.text:00003ACC ; public: __thiscall CObjectVector<class COneMethodInfo>::CObjectVector<class COneMethodInfo>(void)
.text:00003ACC                 public ??0?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ
.text:00003ACC ??0?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ proc near
.text:00003ACC                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+A5p
.text:00003ACC
.text:00003ACC var_4           = dword ptr -4
.text:00003ACC
.text:00003ACC                 push    ebp
.text:00003ACD                 mov     ebp, esp
.text:00003ACF                 push    ecx
.text:00003AD0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003AD7                 mov     [ebp+var_4], ecx
.text:00003ADA                 mov     ecx, [ebp+var_4]
.text:00003ADD                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00003AE2                 mov     eax, [ebp+var_4]
.text:00003AE5                 add     esp, 4
.text:00003AE8                 cmp     ebp, esp
.text:00003AEA                 call    __RTC_CheckEsp
.text:00003AEF                 mov     esp, ebp
.text:00003AF1                 pop     ebp
.text:00003AF2                 retn
.text:00003AF2 ??0?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ endp
.text:00003AF2
.text:00003AF2 ; ---------------------------------------------------------------------------
.text:00003AF3                 align 4
.text:00003AF3 _text           ends
.text:00003AF3
.text:00003AF4 ; ===========================================================================
.text:00003AF4
.text:00003AF4 ; Segment type: Pure code
.text:00003AF4 ; Segment permissions: Read/Execute
.text:00003AF4 _text           segment para public 'CODE' use32
.text:00003AF4                 assume cs:_text
.text:00003AF4                 ;org 3AF4h
.text:00003AF4 ; COMDAT (pick any)
.text:00003AF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003AF4
.text:00003AF4 ; =============== S U B R O U T I N E =======================================
.text:00003AF4
.text:00003AF4 ; Attributes: bp-based frame
.text:00003AF4
.text:00003AF4 ; public: class COneMethodInfo & __thiscall CObjectVector<class COneMethodInfo>::operator[](unsigned int)
.text:00003AF4                 public ??A?$CObjectVector@VCOneMethodInfo@@@@QAEAAVCOneMethodInfo@@I@Z
.text:00003AF4 ??A?$CObjectVector@VCOneMethodInfo@@@@QAEAAVCOneMethodInfo@@I@Z proc near
.text:00003AF4                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+425p
.text:00003AF4
.text:00003AF4 var_4           = dword ptr -4
.text:00003AF4 arg_0           = dword ptr  8
.text:00003AF4
.text:00003AF4                 push    ebp
.text:00003AF5                 mov     ebp, esp
.text:00003AF7                 push    ecx
.text:00003AF8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003AFF                 mov     [ebp+var_4], ecx
.text:00003B02                 mov     eax, [ebp+arg_0]
.text:00003B05                 push    eax
.text:00003B06                 mov     ecx, [ebp+var_4]
.text:00003B09                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003B0E                 mov     eax, [eax]
.text:00003B10                 add     esp, 4
.text:00003B13                 cmp     ebp, esp
.text:00003B15                 call    __RTC_CheckEsp
.text:00003B1A                 mov     esp, ebp
.text:00003B1C                 pop     ebp
.text:00003B1D                 retn    4
.text:00003B1D ??A?$CObjectVector@VCOneMethodInfo@@@@QAEAAVCOneMethodInfo@@I@Z endp
.text:00003B1D
.text:00003B1D _text           ends
.text:00003B1D
.text:00003B20 ; ===========================================================================
.text:00003B20
.text:00003B20 ; Segment type: Pure code
.text:00003B20 ; Segment permissions: Read/Execute
.text:00003B20 _text           segment para public 'CODE' use32
.text:00003B20                 assume cs:_text
.text:00003B20                 ;org 3B20h
.text:00003B20 ; COMDAT (pick any)
.text:00003B20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003B20
.text:00003B20 ; =============== S U B R O U T I N E =======================================
.text:00003B20
.text:00003B20 ; Attributes: bp-based frame
.text:00003B20
.text:00003B20 ; public: void __thiscall CObjectVector<class COneMethodInfo>::Insert(unsigned int, class COneMethodInfo const &)
.text:00003B20                 public ?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z
.text:00003B20 ?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z proc near
.text:00003B20                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+232p
.text:00003B20                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+306p
.text:00003B20
.text:00003B20 var_1C          = dword ptr -1Ch
.text:00003B20 var_18          = dword ptr -18h
.text:00003B20 var_14          = dword ptr -14h
.text:00003B20 var_10          = dword ptr -10h
.text:00003B20 var_C           = dword ptr -0Ch
.text:00003B20 var_4           = dword ptr -4
.text:00003B20 arg_0           = dword ptr  8
.text:00003B20 arg_4           = dword ptr  0Ch
.text:00003B20
.text:00003B20                 push    ebp
.text:00003B21                 mov     ebp, esp
.text:00003B23                 push    0FFFFFFFFh
.text:00003B25                 push    offset __ehhandler$?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z
.text:00003B2A                 mov     eax, large fs:0
.text:00003B30                 push    eax
.text:00003B31                 sub     esp, 10h
.text:00003B34                 mov     eax, 0CCCCCCCCh
.text:00003B39                 mov     [ebp+var_1C], eax
.text:00003B3C                 mov     [ebp+var_18], eax
.text:00003B3F                 mov     [ebp+var_14], eax
.text:00003B42                 mov     [ebp+var_10], eax
.text:00003B45                 mov     eax, dword ptr ds:___security_cookie
.text:00003B4A                 xor     eax, ebp
.text:00003B4C                 push    eax
.text:00003B4D                 lea     eax, [ebp+var_C]
.text:00003B50                 mov     large fs:0, eax
.text:00003B56                 mov     [ebp+var_10], ecx
.text:00003B59                 push    24h ; '$'       ; unsigned int
.text:00003B5B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003B60                 add     esp, 4
.text:00003B63                 mov     [ebp+var_18], eax
.text:00003B66                 mov     [ebp+var_4], 0
.text:00003B6D                 cmp     [ebp+var_18], 0
.text:00003B71                 jz      short loc_3B84
.text:00003B73                 mov     eax, [ebp+arg_4]
.text:00003B76                 push    eax
.text:00003B77                 mov     ecx, [ebp+var_18]
.text:00003B7A                 call    ??0COneMethodInfo@@QAE@ABV0@@Z ; COneMethodInfo::COneMethodInfo(COneMethodInfo const &)
.text:00003B7F                 mov     [ebp+var_1C], eax
.text:00003B82                 jmp     short loc_3B8B
.text:00003B84 ; ---------------------------------------------------------------------------
.text:00003B84
.text:00003B84 loc_3B84:                               ; CODE XREF: CObjectVector<COneMethodInfo>::Insert(uint,COneMethodInfo const &)+51j
.text:00003B84                 mov     [ebp+var_1C], 0
.text:00003B8B
.text:00003B8B loc_3B8B:                               ; CODE XREF: CObjectVector<COneMethodInfo>::Insert(uint,COneMethodInfo const &)+62j
.text:00003B8B                 mov     ecx, [ebp+var_1C]
.text:00003B8E                 mov     [ebp+var_14], ecx
.text:00003B91                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003B98                 mov     edx, [ebp+var_14]
.text:00003B9B                 push    edx
.text:00003B9C                 mov     eax, [ebp+arg_0]
.text:00003B9F                 push    eax
.text:00003BA0                 mov     ecx, [ebp+var_10]
.text:00003BA3                 call    ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z ; CRecordVector<void *>::Insert(uint,void * const)
.text:00003BA8                 mov     ecx, [ebp+var_C]
.text:00003BAB                 mov     large fs:0, ecx
.text:00003BB2                 pop     ecx
.text:00003BB3                 add     esp, 1Ch
.text:00003BB6                 cmp     ebp, esp
.text:00003BB8                 call    __RTC_CheckEsp
.text:00003BBD                 mov     esp, ebp
.text:00003BBF                 pop     ebp
.text:00003BC0                 retn    8
.text:00003BC0 ?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z endp
.text:00003BC0
.text:00003BC0 ; ---------------------------------------------------------------------------
.text:00003BC3                 align 4
.text:00003BC3 _text           ends
.text:00003BC3
.text$x:00003BC4 ; ===========================================================================
.text$x:00003BC4
.text$x:00003BC4 ; Segment type: Pure code
.text$x:00003BC4 ; Segment permissions: Read/Execute
.text$x:00003BC4 _text$x         segment para public 'CODE' use32
.text$x:00003BC4                 assume cs:_text$x
.text$x:00003BC4                 ;org 3BC4h
.text$x:00003BC4 ; COMDAT (pick associative to section at 3B20)
.text$x:00003BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003BC4
.text$x:00003BC4 ; =============== S U B R O U T I N E =======================================
.text$x:00003BC4
.text$x:00003BC4
.text$x:00003BC4 __unwindfunclet$?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z$0 proc near
.text$x:00003BC4                                         ; DATA XREF: .xdata$x:00003BF0o
.text$x:00003BC4                 mov     eax, [ebp-18h]
.text$x:00003BC7                 push    eax             ; void *
.text$x:00003BC8                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00003BCD                 pop     ecx
.text$x:00003BCE                 retn
.text$x:00003BCE __unwindfunclet$?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z$0 endp
.text$x:00003BCE
.text$x:00003BCF
.text$x:00003BCF ; =============== S U B R O U T I N E =======================================
.text$x:00003BCF
.text$x:00003BCF
.text$x:00003BCF __ehhandler$?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z proc near
.text$x:00003BCF                                         ; DATA XREF: CObjectVector<COneMethodInfo>::Insert(uint,COneMethodInfo const &)+5o
.text$x:00003BCF
.text$x:00003BCF arg_4           = dword ptr  8
.text$x:00003BCF
.text$x:00003BCF                 mov     edx, [esp+arg_4]
.text$x:00003BD3                 lea     eax, [edx+0Ch]
.text$x:00003BD6                 mov     ecx, [edx-14h]
.text$x:00003BD9                 xor     ecx, eax
.text$x:00003BDB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BE0                 mov     eax, offset __ehfuncinfo$?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z
.text$x:00003BE5                 jmp     ___CxxFrameHandler3
.text$x:00003BE5 __ehhandler$?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z endp
.text$x:00003BE5
.text$x:00003BE5 ; ---------------------------------------------------------------------------
.text$x:00003BEA                 align 4
.text$x:00003BEA _text$x         ends
.text$x:00003BEA
.xdata$x:00003BEC ; ===========================================================================
.xdata$x:00003BEC
.xdata$x:00003BEC ; Segment type: Pure data
.xdata$x:00003BEC ; Segment permissions: Read
.xdata$x:00003BEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003BEC                 assume cs:_xdata$x
.xdata$x:00003BEC                 ;org 3BECh
.xdata$x:00003BEC ; COMDAT (pick associative to section at 3B20)
.xdata$x:00003BEC __unwindtable$?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z db 0FFh
.xdata$x:00003BEC                                         ; DATA XREF: .xdata$x:00003BFCo
.xdata$x:00003BED                 db 0FFh
.xdata$x:00003BEE                 db 0FFh
.xdata$x:00003BEF                 db 0FFh
.xdata$x:00003BF0                 dd offset __unwindfunclet$?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z$0
.xdata$x:00003BF4 __ehfuncinfo$?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z db  22h ; "
.xdata$x:00003BF4                                         ; DATA XREF: __ehhandler$?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z+11o
.xdata$x:00003BF5                 db    5
.xdata$x:00003BF6                 db  93h ; 
.xdata$x:00003BF7                 db  19h
.xdata$x:00003BF8                 db    1
.xdata$x:00003BF9                 db    0
.xdata$x:00003BFA                 db    0
.xdata$x:00003BFB                 db    0
.xdata$x:00003BFC                 dd offset __unwindtable$?Insert@?$CObjectVector@VCOneMethodInfo@@@@QAEXIABVCOneMethodInfo@@@Z
.xdata$x:00003C00                 db    0
.xdata$x:00003C01                 db    0
.xdata$x:00003C02                 db    0
.xdata$x:00003C03                 db    0
.xdata$x:00003C04                 db    0
.xdata$x:00003C05                 db    0
.xdata$x:00003C06                 db    0
.xdata$x:00003C07                 db    0
.xdata$x:00003C08                 db    0
.xdata$x:00003C09                 db    0
.xdata$x:00003C0A                 db    0
.xdata$x:00003C0B                 db    0
.xdata$x:00003C0C                 db    0
.xdata$x:00003C0D                 db    0
.xdata$x:00003C0E                 db    0
.xdata$x:00003C0F                 db    0
.xdata$x:00003C10                 db    0
.xdata$x:00003C11                 db    0
.xdata$x:00003C12                 db    0
.xdata$x:00003C13                 db    0
.xdata$x:00003C14                 db    1
.xdata$x:00003C15                 db    0
.xdata$x:00003C16                 db    0
.xdata$x:00003C17                 db    0
.xdata$x:00003C17 _xdata$x        ends
.xdata$x:00003C17
.text:00003C18 ; ===========================================================================
.text:00003C18
.text:00003C18 ; Segment type: Pure code
.text:00003C18 ; Segment permissions: Read/Execute
.text:00003C18 _text           segment para public 'CODE' use32
.text:00003C18                 assume cs:_text
.text:00003C18                 ;org 3C18h
.text:00003C18 ; COMDAT (pick any)
.text:00003C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003C18
.text:00003C18 ; =============== S U B R O U T I N E =======================================
.text:00003C18
.text:00003C18 ; Attributes: bp-based frame
.text:00003C18
.text:00003C18 ; public: __thiscall CObjectVector<class COneMethodInfo>::~CObjectVector<class COneMethodInfo>(void)
.text:00003C18                 public ??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ
.text:00003C18 ??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ proc near
.text:00003C18                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+129p
.text:00003C18                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+298p ...
.text:00003C18
.text:00003C18 var_20          = dword ptr -20h
.text:00003C18 var_1C          = dword ptr -1Ch
.text:00003C18 var_18          = dword ptr -18h
.text:00003C18 var_14          = dword ptr -14h
.text:00003C18 var_10          = dword ptr -10h
.text:00003C18 var_C           = dword ptr -0Ch
.text:00003C18 var_4           = dword ptr -4
.text:00003C18
.text:00003C18                 push    ebp
.text:00003C19                 mov     ebp, esp
.text:00003C1B                 push    0FFFFFFFFh
.text:00003C1D                 push    offset __ehhandler$??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ
.text:00003C22                 mov     eax, large fs:0
.text:00003C28                 push    eax
.text:00003C29                 sub     esp, 14h
.text:00003C2C                 mov     eax, 0CCCCCCCCh
.text:00003C31                 mov     [ebp+var_20], eax
.text:00003C34                 mov     [ebp+var_1C], eax
.text:00003C37                 mov     [ebp+var_18], eax
.text:00003C3A                 mov     [ebp+var_14], eax
.text:00003C3D                 mov     [ebp+var_10], eax
.text:00003C40                 mov     eax, dword ptr ds:___security_cookie
.text:00003C45                 xor     eax, ebp
.text:00003C47                 push    eax
.text:00003C48                 lea     eax, [ebp+var_C]
.text:00003C4B                 mov     large fs:0, eax
.text:00003C51                 mov     [ebp+var_10], ecx
.text:00003C54                 mov     [ebp+var_4], 0
.text:00003C5B                 mov     ecx, [ebp+var_10]
.text:00003C5E                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003C63                 mov     [ebp+var_14], eax
.text:00003C66
.text:00003C66 loc_3C66:                               ; CODE XREF: CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void):loc_3CA8j
.text:00003C66                 cmp     [ebp+var_14], 0
.text:00003C6A                 jz      short loc_3CAA
.text:00003C6C                 mov     eax, [ebp+var_14]
.text:00003C6F                 sub     eax, 1
.text:00003C72                 mov     [ebp+var_14], eax
.text:00003C75                 mov     ecx, [ebp+var_14]
.text:00003C78                 push    ecx
.text:00003C79                 mov     ecx, [ebp+var_10]
.text:00003C7C                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003C81                 mov     edx, [eax]
.text:00003C83                 mov     [ebp+var_1C], edx
.text:00003C86                 mov     eax, [ebp+var_1C]
.text:00003C89                 mov     [ebp+var_18], eax
.text:00003C8C                 cmp     [ebp+var_18], 0
.text:00003C90                 jz      short loc_3CA1
.text:00003C92                 push    1
.text:00003C94                 mov     ecx, [ebp+var_18]
.text:00003C97                 call    ??_GCOneMethodInfo@@QAEPAXI@Z ; COneMethodInfo::`scalar deleting destructor'(uint)
.text:00003C9C                 mov     [ebp+var_20], eax
.text:00003C9F                 jmp     short loc_3CA8
.text:00003CA1 ; ---------------------------------------------------------------------------
.text:00003CA1
.text:00003CA1 loc_3CA1:                               ; CODE XREF: CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)+78j
.text:00003CA1                 mov     [ebp+var_20], 0
.text:00003CA8
.text:00003CA8 loc_3CA8:                               ; CODE XREF: CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)+87j
.text:00003CA8                 jmp     short loc_3C66
.text:00003CAA ; ---------------------------------------------------------------------------
.text:00003CAA
.text:00003CAA loc_3CAA:                               ; CODE XREF: CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)+52j
.text:00003CAA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003CB1                 mov     ecx, [ebp+var_10]
.text:00003CB4                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003CB9                 mov     ecx, [ebp+var_C]
.text:00003CBC                 mov     large fs:0, ecx
.text:00003CC3                 pop     ecx
.text:00003CC4                 add     esp, 20h
.text:00003CC7                 cmp     ebp, esp
.text:00003CC9                 call    __RTC_CheckEsp
.text:00003CCE                 mov     esp, ebp
.text:00003CD0                 pop     ebp
.text:00003CD1                 retn
.text:00003CD1 ??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ endp
.text:00003CD1
.text:00003CD1 ; ---------------------------------------------------------------------------
.text:00003CD2                 align 4
.text:00003CD2 _text           ends
.text:00003CD2
.text$x:00003CD4 ; ===========================================================================
.text$x:00003CD4
.text$x:00003CD4 ; Segment type: Pure code
.text$x:00003CD4 ; Segment permissions: Read/Execute
.text$x:00003CD4 _text$x         segment para public 'CODE' use32
.text$x:00003CD4                 assume cs:_text$x
.text$x:00003CD4                 ;org 3CD4h
.text$x:00003CD4 ; COMDAT (pick associative to section at 3C18)
.text$x:00003CD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003CD4
.text$x:00003CD4 ; =============== S U B R O U T I N E =======================================
.text$x:00003CD4
.text$x:00003CD4
.text$x:00003CD4 __unwindfunclet$??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ$0 proc near
.text$x:00003CD4                                         ; DATA XREF: .xdata$x:00003CFCo
.text$x:00003CD4                 mov     ecx, [ebp-10h]
.text$x:00003CD7                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00003CD7 __unwindfunclet$??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ$0 endp
.text$x:00003CD7
.text$x:00003CDC
.text$x:00003CDC ; =============== S U B R O U T I N E =======================================
.text$x:00003CDC
.text$x:00003CDC
.text$x:00003CDC __ehhandler$??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ proc near
.text$x:00003CDC                                         ; DATA XREF: CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)+5o
.text$x:00003CDC
.text$x:00003CDC arg_4           = dword ptr  8
.text$x:00003CDC
.text$x:00003CDC                 mov     edx, [esp+arg_4]
.text$x:00003CE0                 lea     eax, [edx+0Ch]
.text$x:00003CE3                 mov     ecx, [edx-18h]
.text$x:00003CE6                 xor     ecx, eax
.text$x:00003CE8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003CED                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ
.text$x:00003CF2                 jmp     ___CxxFrameHandler3
.text$x:00003CF2 __ehhandler$??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ endp
.text$x:00003CF2
.text$x:00003CF2 ; ---------------------------------------------------------------------------
.text$x:00003CF7                 align 4
.text$x:00003CF7 _text$x         ends
.text$x:00003CF7
.xdata$x:00003CF8 ; ===========================================================================
.xdata$x:00003CF8
.xdata$x:00003CF8 ; Segment type: Pure data
.xdata$x:00003CF8 ; Segment permissions: Read
.xdata$x:00003CF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003CF8                 assume cs:_xdata$x
.xdata$x:00003CF8                 ;org 3CF8h
.xdata$x:00003CF8 ; COMDAT (pick associative to section at 3C18)
.xdata$x:00003CF8 __unwindtable$??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ db 0FFh
.xdata$x:00003CF8                                         ; DATA XREF: .xdata$x:00003D08o
.xdata$x:00003CF9                 db 0FFh
.xdata$x:00003CFA                 db 0FFh
.xdata$x:00003CFB                 db 0FFh
.xdata$x:00003CFC                 dd offset __unwindfunclet$??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ$0
.xdata$x:00003D00 __ehfuncinfo$??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ db  22h ; "
.xdata$x:00003D00                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ+11o
.xdata$x:00003D01                 db    5
.xdata$x:00003D02                 db  93h ; 
.xdata$x:00003D03                 db  19h
.xdata$x:00003D04                 db    1
.xdata$x:00003D05                 db    0
.xdata$x:00003D06                 db    0
.xdata$x:00003D07                 db    0
.xdata$x:00003D08                 dd offset __unwindtable$??1?$CObjectVector@VCOneMethodInfo@@@@QAE@XZ
.xdata$x:00003D0C                 align 20h
.xdata$x:00003D20                 db    1
.xdata$x:00003D21                 db    0
.xdata$x:00003D22                 db    0
.xdata$x:00003D23                 db    0
.xdata$x:00003D23 _xdata$x        ends
.xdata$x:00003D23
.text:00003D24 ; ===========================================================================
.text:00003D24
.text:00003D24 ; Segment type: Pure code
.text:00003D24 ; Segment permissions: Read/Execute
.text:00003D24 _text           segment para public 'CODE' use32
.text:00003D24                 assume cs:_text
.text:00003D24                 ;org 3D24h
.text:00003D24 ; COMDAT (pick any)
.text:00003D24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003D24
.text:00003D24 ; =============== S U B R O U T I N E =======================================
.text:00003D24
.text:00003D24 ; Attributes: bp-based frame
.text:00003D24
.text:00003D24 ; public: void __thiscall CObjectVector<class COneMethodInfo>::Clear(void)
.text:00003D24                 public ?Clear@?$CObjectVector@VCOneMethodInfo@@@@QAEXXZ
.text:00003D24 ?Clear@?$CObjectVector@VCOneMethodInfo@@@@QAEXXZ proc near
.text:00003D24                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+1A9p
.text:00003D24
.text:00003D24 var_14          = dword ptr -14h
.text:00003D24 var_10          = dword ptr -10h
.text:00003D24 var_C           = dword ptr -0Ch
.text:00003D24 var_8           = dword ptr -8
.text:00003D24 var_4           = dword ptr -4
.text:00003D24
.text:00003D24                 push    ebp
.text:00003D25                 mov     ebp, esp
.text:00003D27                 sub     esp, 14h
.text:00003D2A                 mov     eax, 0CCCCCCCCh
.text:00003D2F                 mov     [ebp+var_14], eax
.text:00003D32                 mov     [ebp+var_10], eax
.text:00003D35                 mov     [ebp+var_C], eax
.text:00003D38                 mov     [ebp+var_8], eax
.text:00003D3B                 mov     [ebp+var_4], eax
.text:00003D3E                 mov     [ebp+var_4], ecx
.text:00003D41                 mov     ecx, [ebp+var_4]
.text:00003D44                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003D49                 mov     [ebp+var_8], eax
.text:00003D4C
.text:00003D4C loc_3D4C:                               ; CODE XREF: CObjectVector<COneMethodInfo>::Clear(void):loc_3D8Ej
.text:00003D4C                 cmp     [ebp+var_8], 0
.text:00003D50                 jz      short loc_3D90
.text:00003D52                 mov     eax, [ebp+var_8]
.text:00003D55                 sub     eax, 1
.text:00003D58                 mov     [ebp+var_8], eax
.text:00003D5B                 mov     ecx, [ebp+var_8]
.text:00003D5E                 push    ecx
.text:00003D5F                 mov     ecx, [ebp+var_4]
.text:00003D62                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003D67                 mov     edx, [eax]
.text:00003D69                 mov     [ebp+var_10], edx
.text:00003D6C                 mov     eax, [ebp+var_10]
.text:00003D6F                 mov     [ebp+var_C], eax
.text:00003D72                 cmp     [ebp+var_C], 0
.text:00003D76                 jz      short loc_3D87
.text:00003D78                 push    1
.text:00003D7A                 mov     ecx, [ebp+var_C]
.text:00003D7D                 call    ??_GCOneMethodInfo@@QAEPAXI@Z ; COneMethodInfo::`scalar deleting destructor'(uint)
.text:00003D82                 mov     [ebp+var_14], eax
.text:00003D85                 jmp     short loc_3D8E
.text:00003D87 ; ---------------------------------------------------------------------------
.text:00003D87
.text:00003D87 loc_3D87:                               ; CODE XREF: CObjectVector<COneMethodInfo>::Clear(void)+52j
.text:00003D87                 mov     [ebp+var_14], 0
.text:00003D8E
.text:00003D8E loc_3D8E:                               ; CODE XREF: CObjectVector<COneMethodInfo>::Clear(void)+61j
.text:00003D8E                 jmp     short loc_3D4C
.text:00003D90 ; ---------------------------------------------------------------------------
.text:00003D90
.text:00003D90 loc_3D90:                               ; CODE XREF: CObjectVector<COneMethodInfo>::Clear(void)+2Cj
.text:00003D90                 mov     ecx, [ebp+var_4]
.text:00003D93                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00003D98                 add     esp, 14h
.text:00003D9B                 cmp     ebp, esp
.text:00003D9D                 call    __RTC_CheckEsp
.text:00003DA2                 mov     esp, ebp
.text:00003DA4                 pop     ebp
.text:00003DA5                 retn
.text:00003DA5 ?Clear@?$CObjectVector@VCOneMethodInfo@@@@QAEXXZ endp
.text:00003DA5
.text:00003DA5 ; ---------------------------------------------------------------------------
.text:00003DA6                 align 4
.text:00003DA6 _text           ends
.text:00003DA6
.text:00003DA8 ; ===========================================================================
.text:00003DA8
.text:00003DA8 ; Segment type: Pure code
.text:00003DA8 ; Segment permissions: Read/Execute
.text:00003DA8 _text           segment para public 'CODE' use32
.text:00003DA8                 assume cs:_text
.text:00003DA8                 ;org 3DA8h
.text:00003DA8 ; COMDAT (pick any)
.text:00003DA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003DA8
.text:00003DA8 ; =============== S U B R O U T I N E =======================================
.text:00003DA8
.text:00003DA8 ; Attributes: bp-based frame
.text:00003DA8
.text:00003DA8 ; public: __thiscall CMyComPtr<struct ICompressSetCoderProperties>::CMyComPtr<struct ICompressSetCoderProperties>(void)
.text:00003DA8                 public ??0?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ
.text:00003DA8 ??0?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ proc near
.text:00003DA8                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+436p
.text:00003DA8
.text:00003DA8 var_4           = dword ptr -4
.text:00003DA8
.text:00003DA8                 push    ebp
.text:00003DA9                 mov     ebp, esp
.text:00003DAB                 push    ecx
.text:00003DAC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003DB3                 mov     [ebp+var_4], ecx
.text:00003DB6                 mov     eax, [ebp+var_4]
.text:00003DB9                 mov     dword ptr [eax], 0
.text:00003DBF                 mov     eax, [ebp+var_4]
.text:00003DC2                 mov     esp, ebp
.text:00003DC4                 pop     ebp
.text:00003DC5                 retn
.text:00003DC5 ??0?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ endp
.text:00003DC5
.text:00003DC5 ; ---------------------------------------------------------------------------
.text:00003DC6                 align 4
.text:00003DC6 _text           ends
.text:00003DC6
.text:00003DC8 ; ===========================================================================
.text:00003DC8
.text:00003DC8 ; Segment type: Pure code
.text:00003DC8 ; Segment permissions: Read/Execute
.text:00003DC8 _text           segment para public 'CODE' use32
.text:00003DC8                 assume cs:_text
.text:00003DC8                 ;org 3DC8h
.text:00003DC8 ; COMDAT (pick any)
.text:00003DC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003DC8
.text:00003DC8 ; =============== S U B R O U T I N E =======================================
.text:00003DC8
.text:00003DC8 ; Attributes: bp-based frame
.text:00003DC8
.text:00003DC8 ; public: __thiscall CMyComPtr<struct ICompressSetCoderProperties>::~CMyComPtr<struct ICompressSetCoderProperties>(void)
.text:00003DC8                 public ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ
.text:00003DC8 ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ proc near
.text:00003DC8                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+4ACp
.text:00003DC8                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+50Bp ...
.text:00003DC8
.text:00003DC8 var_4           = dword ptr -4
.text:00003DC8
.text:00003DC8                 push    ebp
.text:00003DC9                 mov     ebp, esp
.text:00003DCB                 push    ecx
.text:00003DCC                 push    esi
.text:00003DCD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003DD4                 mov     [ebp+var_4], ecx
.text:00003DD7                 mov     eax, [ebp+var_4]
.text:00003DDA                 cmp     dword ptr [eax], 0
.text:00003DDD                 jz      short loc_3DFA
.text:00003DDF                 mov     ecx, [ebp+var_4]
.text:00003DE2                 mov     edx, [ecx]
.text:00003DE4                 mov     eax, [ebp+var_4]
.text:00003DE7                 mov     ecx, [eax]
.text:00003DE9                 mov     edx, [edx]
.text:00003DEB                 mov     esi, esp
.text:00003DED                 push    ecx
.text:00003DEE                 mov     eax, [edx+8]
.text:00003DF1                 call    eax
.text:00003DF3                 cmp     esi, esp
.text:00003DF5                 call    __RTC_CheckEsp
.text:00003DFA
.text:00003DFA loc_3DFA:                               ; CODE XREF: CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)+15j
.text:00003DFA                 pop     esi
.text:00003DFB                 add     esp, 4
.text:00003DFE                 cmp     ebp, esp
.text:00003E00                 call    __RTC_CheckEsp
.text:00003E05                 mov     esp, ebp
.text:00003E07                 pop     ebp
.text:00003E08                 retn
.text:00003E08 ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ endp
.text:00003E08
.text:00003E08 ; ---------------------------------------------------------------------------
.text:00003E09                 align 4
.text:00003E09 _text           ends
.text:00003E09
.text:00003E0C ; ===========================================================================
.text:00003E0C
.text:00003E0C ; Segment type: Pure code
.text:00003E0C ; Segment permissions: Read/Execute
.text:00003E0C _text           segment para public 'CODE' use32
.text:00003E0C                 assume cs:_text
.text:00003E0C                 ;org 3E0Ch
.text:00003E0C ; COMDAT (pick any)
.text:00003E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003E0C
.text:00003E0C ; =============== S U B R O U T I N E =======================================
.text:00003E0C
.text:00003E0C ; Attributes: bp-based frame
.text:00003E0C
.text:00003E0C ; public: __thiscall CMyComPtr<struct ICompressSetCoderProperties>::operator struct ICompressSetCoderProperties *(void)const
.text:00003E0C                 public ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ
.text:00003E0C ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ proc near
.text:00003E0C                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+461p
.text:00003E0C                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+476p
.text:00003E0C
.text:00003E0C var_4           = dword ptr -4
.text:00003E0C
.text:00003E0C                 push    ebp
.text:00003E0D                 mov     ebp, esp
.text:00003E0F                 push    ecx
.text:00003E10                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003E17                 mov     [ebp+var_4], ecx
.text:00003E1A                 mov     eax, [ebp+var_4]
.text:00003E1D                 mov     eax, [eax]
.text:00003E1F                 mov     esp, ebp
.text:00003E21                 pop     ebp
.text:00003E22                 retn
.text:00003E22 ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ endp
.text:00003E22
.text:00003E22 ; ---------------------------------------------------------------------------
.text:00003E23                 align 4
.text:00003E23 _text           ends
.text:00003E23
.text:00003E24 ; ===========================================================================
.text:00003E24
.text:00003E24 ; Segment type: Pure code
.text:00003E24 ; Segment permissions: Read/Execute
.text:00003E24 _text           segment para public 'CODE' use32
.text:00003E24                 assume cs:_text
.text:00003E24                 ;org 3E24h
.text:00003E24 ; COMDAT (pick any)
.text:00003E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003E24
.text:00003E24 ; =============== S U B R O U T I N E =======================================
.text:00003E24
.text:00003E24 ; Attributes: bp-based frame
.text:00003E24
.text:00003E24 ; public: struct ICompressSetCoderProperties * * __thiscall CMyComPtr<struct ICompressSetCoderProperties>::operator&(void)
.text:00003E24                 public ??I?$CMyComPtr@UICompressSetCoderProperties@@@@QAEPAPAUICompressSetCoderProperties@@XZ
.text:00003E24 ??I?$CMyComPtr@UICompressSetCoderProperties@@@@QAEPAPAUICompressSetCoderProperties@@XZ proc near
.text:00003E24                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+445p
.text:00003E24
.text:00003E24 var_4           = dword ptr -4
.text:00003E24
.text:00003E24                 push    ebp
.text:00003E25                 mov     ebp, esp
.text:00003E27                 push    ecx
.text:00003E28                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003E2F                 mov     [ebp+var_4], ecx
.text:00003E32                 mov     eax, [ebp+var_4]
.text:00003E35                 mov     esp, ebp
.text:00003E37                 pop     ebp
.text:00003E38                 retn
.text:00003E38 ??I?$CMyComPtr@UICompressSetCoderProperties@@@@QAEPAPAUICompressSetCoderProperties@@XZ endp
.text:00003E38
.text:00003E38 ; ---------------------------------------------------------------------------
.text:00003E39                 align 4
.text:00003E39 _text           ends
.text:00003E39
.text:00003E3C ; ===========================================================================
.text:00003E3C
.text:00003E3C ; Segment type: Pure code
.text:00003E3C ; Segment permissions: Read/Execute
.text:00003E3C _text           segment para public 'CODE' use32
.text:00003E3C                 assume cs:_text
.text:00003E3C                 ;org 3E3Ch
.text:00003E3C ; COMDAT (pick any)
.text:00003E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003E3C
.text:00003E3C ; =============== S U B R O U T I N E =======================================
.text:00003E3C
.text:00003E3C ; Attributes: bp-based frame
.text:00003E3C
.text:00003E3C ; public: __thiscall CMyComPtr<struct ISequentialInStream>::CMyComPtr<struct ISequentialInStream>(void)
.text:00003E3C                 public ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ
.text:00003E3C ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ proc near
.text:00003E3C                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+4CDp
.text:00003E3C
.text:00003E3C var_4           = dword ptr -4
.text:00003E3C
.text:00003E3C                 push    ebp
.text:00003E3D                 mov     ebp, esp
.text:00003E3F                 push    ecx
.text:00003E40                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003E47                 mov     [ebp+var_4], ecx
.text:00003E4A                 mov     eax, [ebp+var_4]
.text:00003E4D                 mov     dword ptr [eax], 0
.text:00003E53                 mov     eax, [ebp+var_4]
.text:00003E56                 mov     esp, ebp
.text:00003E58                 pop     ebp
.text:00003E59                 retn
.text:00003E59 ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ endp
.text:00003E59
.text:00003E59 ; ---------------------------------------------------------------------------
.text:00003E5A                 align 4
.text:00003E5A _text           ends
.text:00003E5A
.text:00003E5C ; ===========================================================================
.text:00003E5C
.text:00003E5C ; Segment type: Pure code
.text:00003E5C ; Segment permissions: Read/Execute
.text:00003E5C _text           segment para public 'CODE' use32
.text:00003E5C                 assume cs:_text
.text:00003E5C                 ;org 3E5Ch
.text:00003E5C ; COMDAT (pick any)
.text:00003E5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003E5C
.text:00003E5C ; =============== S U B R O U T I N E =======================================
.text:00003E5C
.text:00003E5C ; Attributes: bp-based frame
.text:00003E5C
.text:00003E5C ; public: __thiscall CMyComPtr<struct ISequentialInStream>::~CMyComPtr<struct ISequentialInStream>(void)
.text:00003E5C                 public ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ
.text:00003E5C ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ proc near
.text:00003E5C                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+733p
.text:00003E5C                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+79Bp ...
.text:00003E5C
.text:00003E5C var_4           = dword ptr -4
.text:00003E5C
.text:00003E5C                 push    ebp
.text:00003E5D                 mov     ebp, esp
.text:00003E5F                 push    ecx
.text:00003E60                 push    esi
.text:00003E61                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003E68                 mov     [ebp+var_4], ecx
.text:00003E6B                 mov     eax, [ebp+var_4]
.text:00003E6E                 cmp     dword ptr [eax], 0
.text:00003E71                 jz      short loc_3E8E
.text:00003E73                 mov     ecx, [ebp+var_4]
.text:00003E76                 mov     edx, [ecx]
.text:00003E78                 mov     eax, [ebp+var_4]
.text:00003E7B                 mov     ecx, [eax]
.text:00003E7D                 mov     edx, [edx]
.text:00003E7F                 mov     esi, esp
.text:00003E81                 push    ecx
.text:00003E82                 mov     eax, [edx+8]
.text:00003E85                 call    eax
.text:00003E87                 cmp     esi, esp
.text:00003E89                 call    __RTC_CheckEsp
.text:00003E8E
.text:00003E8E loc_3E8E:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)+15j
.text:00003E8E                 pop     esi
.text:00003E8F                 add     esp, 4
.text:00003E92                 cmp     ebp, esp
.text:00003E94                 call    __RTC_CheckEsp
.text:00003E99                 mov     esp, ebp
.text:00003E9B                 pop     ebp
.text:00003E9C                 retn
.text:00003E9C ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ endp
.text:00003E9C
.text:00003E9C ; ---------------------------------------------------------------------------
.text:00003E9D                 align 10h
.text:00003E9D _text           ends
.text:00003E9D
.text:00003EA0 ; ===========================================================================
.text:00003EA0
.text:00003EA0 ; Segment type: Pure code
.text:00003EA0 ; Segment permissions: Read/Execute
.text:00003EA0 _text           segment para public 'CODE' use32
.text:00003EA0                 assume cs:_text
.text:00003EA0                 ;org 3EA0h
.text:00003EA0 ; COMDAT (pick any)
.text:00003EA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003EA0
.text:00003EA0 ; =============== S U B R O U T I N E =======================================
.text:00003EA0
.text:00003EA0 ; Attributes: bp-based frame
.text:00003EA0
.text:00003EA0 ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::operator->(void)const
.text:00003EA0                 public ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ
.text:00003EA0 ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ proc near
.text:00003EA0                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+943p
.text:00003EA0
.text:00003EA0 var_4           = dword ptr -4
.text:00003EA0
.text:00003EA0                 push    ebp
.text:00003EA1                 mov     ebp, esp
.text:00003EA3                 push    ecx
.text:00003EA4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003EAB                 mov     [ebp+var_4], ecx
.text:00003EAE                 mov     eax, [ebp+var_4]
.text:00003EB1                 mov     eax, [eax]
.text:00003EB3                 mov     esp, ebp
.text:00003EB5                 pop     ebp
.text:00003EB6                 retn
.text:00003EB6 ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ endp
.text:00003EB6
.text:00003EB6 ; ---------------------------------------------------------------------------
.text:00003EB7                 align 4
.text:00003EB7 _text           ends
.text:00003EB7
.text:00003EB8 ; ===========================================================================
.text:00003EB8
.text:00003EB8 ; Segment type: Pure code
.text:00003EB8 ; Segment permissions: Read/Execute
.text:00003EB8 _text           segment para public 'CODE' use32
.text:00003EB8                 assume cs:_text
.text:00003EB8                 ;org 3EB8h
.text:00003EB8 ; COMDAT (pick any)
.text:00003EB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003EB8
.text:00003EB8 ; =============== S U B R O U T I N E =======================================
.text:00003EB8
.text:00003EB8 ; Attributes: bp-based frame
.text:00003EB8
.text:00003EB8 ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::operator=(struct ISequentialInStream *)
.text:00003EB8                 public ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z
.text:00003EB8 ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z proc near
.text:00003EB8                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+555p
.text:00003EB8                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+5C2p
.text:00003EB8
.text:00003EB8 var_4           = dword ptr -4
.text:00003EB8 arg_0           = dword ptr  8
.text:00003EB8
.text:00003EB8                 push    ebp
.text:00003EB9                 mov     ebp, esp
.text:00003EBB                 push    ecx
.text:00003EBC                 push    esi
.text:00003EBD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003EC4                 mov     [ebp+var_4], ecx
.text:00003EC7                 cmp     [ebp+arg_0], 0
.text:00003ECB                 jz      short loc_3EE4
.text:00003ECD                 mov     eax, [ebp+arg_0]
.text:00003ED0                 mov     ecx, [eax]
.text:00003ED2                 mov     esi, esp
.text:00003ED4                 mov     edx, [ebp+arg_0]
.text:00003ED7                 push    edx
.text:00003ED8                 mov     eax, [ecx+4]
.text:00003EDB                 call    eax
.text:00003EDD                 cmp     esi, esp
.text:00003EDF                 call    __RTC_CheckEsp
.text:00003EE4
.text:00003EE4 loc_3EE4:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::operator=(ISequentialInStream *)+13j
.text:00003EE4                 mov     ecx, [ebp+var_4]
.text:00003EE7                 cmp     dword ptr [ecx], 0
.text:00003EEA                 jz      short loc_3F07
.text:00003EEC                 mov     edx, [ebp+var_4]
.text:00003EEF                 mov     eax, [edx]
.text:00003EF1                 mov     ecx, [ebp+var_4]
.text:00003EF4                 mov     edx, [ecx]
.text:00003EF6                 mov     eax, [eax]
.text:00003EF8                 mov     esi, esp
.text:00003EFA                 push    edx
.text:00003EFB                 mov     ecx, [eax+8]
.text:00003EFE                 call    ecx
.text:00003F00                 cmp     esi, esp
.text:00003F02                 call    __RTC_CheckEsp
.text:00003F07
.text:00003F07 loc_3F07:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::operator=(ISequentialInStream *)+32j
.text:00003F07                 mov     edx, [ebp+var_4]
.text:00003F0A                 mov     eax, [ebp+arg_0]
.text:00003F0D                 mov     [edx], eax
.text:00003F0F                 mov     eax, [ebp+arg_0]
.text:00003F12                 pop     esi
.text:00003F13                 add     esp, 4
.text:00003F16                 cmp     ebp, esp
.text:00003F18                 call    __RTC_CheckEsp
.text:00003F1D                 mov     esp, ebp
.text:00003F1F                 pop     ebp
.text:00003F20                 retn    4
.text:00003F20 ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z endp
.text:00003F20
.text:00003F20 ; ---------------------------------------------------------------------------
.text:00003F23                 align 4
.text:00003F23 _text           ends
.text:00003F23
.text:00003F24 ; ===========================================================================
.text:00003F24
.text:00003F24 ; Segment type: Pure code
.text:00003F24 ; Segment permissions: Read/Execute
.text:00003F24 _text           segment para public 'CODE' use32
.text:00003F24                 assume cs:_text
.text:00003F24                 ;org 3F24h
.text:00003F24 ; COMDAT (pick any)
.text:00003F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003F24
.text:00003F24 ; =============== S U B R O U T I N E =======================================
.text:00003F24
.text:00003F24 ; Attributes: bp-based frame
.text:00003F24
.text:00003F24 ; public: void * __thiscall UString::`scalar deleting destructor'(unsigned int)
.text:00003F24                 public ??_GUString@@QAEPAXI@Z
.text:00003F24 ??_GUString@@QAEPAXI@Z proc near        ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+7Fp
.text:00003F24
.text:00003F24 var_4           = dword ptr -4
.text:00003F24 arg_0           = dword ptr  8
.text:00003F24
.text:00003F24                 push    ebp
.text:00003F25                 mov     ebp, esp
.text:00003F27                 push    ecx
.text:00003F28                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003F2F                 mov     [ebp+var_4], ecx
.text:00003F32                 mov     ecx, [ebp+var_4] ; this
.text:00003F35                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003F3A                 mov     eax, [ebp+arg_0]
.text:00003F3D                 and     eax, 1
.text:00003F40                 jz      short loc_3F4E
.text:00003F42                 mov     ecx, [ebp+var_4]
.text:00003F45                 push    ecx             ; void *
.text:00003F46                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003F4B                 add     esp, 4
.text:00003F4E
.text:00003F4E loc_3F4E:                               ; CODE XREF: UString::`scalar deleting destructor'(uint)+1Cj
.text:00003F4E                 mov     eax, [ebp+var_4]
.text:00003F51                 add     esp, 4
.text:00003F54                 cmp     ebp, esp
.text:00003F56                 call    __RTC_CheckEsp
.text:00003F5B                 mov     esp, ebp
.text:00003F5D                 pop     ebp
.text:00003F5E                 retn    4
.text:00003F5E ??_GUString@@QAEPAXI@Z endp
.text:00003F5E
.text:00003F5E ; ---------------------------------------------------------------------------
.text:00003F61                 align 4
.text:00003F61 _text           ends
.text:00003F61
.text:00003F64 ; ===========================================================================
.text:00003F64
.text:00003F64 ; Segment type: Pure code
.text:00003F64 ; Segment permissions: Read/Execute
.text:00003F64 _text           segment para public 'CODE' use32
.text:00003F64                 assume cs:_text
.text:00003F64                 ;org 3F64h
.text:00003F64 ; COMDAT (pick any)
.text:00003F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003F64
.text:00003F64 ; =============== S U B R O U T I N E =======================================
.text:00003F64
.text:00003F64 ; Attributes: bp-based frame
.text:00003F64
.text:00003F64 ; public: void * __thiscall CBuffer<unsigned char>::`scalar deleting destructor'(unsigned int)
.text:00003F64                 public ??_G?$CBuffer@E@@QAEPAXI@Z
.text:00003F64 ??_G?$CBuffer@E@@QAEPAXI@Z proc near    ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+7Fp
.text:00003F64
.text:00003F64 var_4           = dword ptr -4
.text:00003F64 arg_0           = dword ptr  8
.text:00003F64
.text:00003F64                 push    ebp
.text:00003F65                 mov     ebp, esp
.text:00003F67                 push    ecx
.text:00003F68                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003F6F                 mov     [ebp+var_4], ecx
.text:00003F72                 mov     ecx, [ebp+var_4]
.text:00003F75                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00003F7A                 mov     eax, [ebp+arg_0]
.text:00003F7D                 and     eax, 1
.text:00003F80                 jz      short loc_3F8E
.text:00003F82                 mov     ecx, [ebp+var_4]
.text:00003F85                 push    ecx             ; void *
.text:00003F86                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003F8B                 add     esp, 4
.text:00003F8E
.text:00003F8E loc_3F8E:                               ; CODE XREF: CBuffer<uchar>::`scalar deleting destructor'(uint)+1Cj
.text:00003F8E                 mov     eax, [ebp+var_4]
.text:00003F91                 add     esp, 4
.text:00003F94                 cmp     ebp, esp
.text:00003F96                 call    __RTC_CheckEsp
.text:00003F9B                 mov     esp, ebp
.text:00003F9D                 pop     ebp
.text:00003F9E                 retn    4
.text:00003F9E ??_G?$CBuffer@E@@QAEPAXI@Z endp
.text:00003F9E
.text:00003F9E ; ---------------------------------------------------------------------------
.text:00003FA1                 align 4
.text:00003FA1 _text           ends
.text:00003FA1
.text:00003FA4 ; ===========================================================================
.text:00003FA4
.text:00003FA4 ; Segment type: Pure code
.text:00003FA4 ; Segment permissions: Read/Execute
.text:00003FA4 _text           segment para public 'CODE' use32
.text:00003FA4                 assume cs:_text
.text:00003FA4                 ;org 3FA4h
.text:00003FA4 ; COMDAT (pick any)
.text:00003FA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003FA4
.text:00003FA4 ; =============== S U B R O U T I N E =======================================
.text:00003FA4
.text:00003FA4 ; Attributes: bp-based frame
.text:00003FA4
.text:00003FA4 ; public: __thiscall CDirItem::CDirItem(struct CDirItem const &)
.text:00003FA4                 public ??0CDirItem@@QAE@ABU0@@Z
.text:00003FA4 ??0CDirItem@@QAE@ABU0@@Z proc near      ; CODE XREF: CObjectVector<CDirItem>::Add(CDirItem const &)+5Ap
.text:00003FA4
.text:00003FA4 var_10          = dword ptr -10h
.text:00003FA4 var_C           = dword ptr -0Ch
.text:00003FA4 var_4           = dword ptr -4
.text:00003FA4 arg_0           = dword ptr  8
.text:00003FA4
.text:00003FA4                 push    ebp
.text:00003FA5                 mov     ebp, esp
.text:00003FA7                 push    0FFFFFFFFh
.text:00003FA9                 push    offset __ehhandler$??0CDirItem@@QAE@ABU0@@Z
.text:00003FAE                 mov     eax, large fs:0
.text:00003FB4                 push    eax
.text:00003FB5                 push    ecx
.text:00003FB6                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00003FBD                 mov     eax, dword ptr ds:___security_cookie
.text:00003FC2                 xor     eax, ebp
.text:00003FC4                 push    eax
.text:00003FC5                 lea     eax, [ebp+var_C]
.text:00003FC8                 mov     large fs:0, eax
.text:00003FCE                 mov     [ebp+var_10], ecx
.text:00003FD1                 mov     eax, [ebp+var_10]
.text:00003FD4                 mov     ecx, [ebp+arg_0]
.text:00003FD7                 mov     edx, [ecx]
.text:00003FD9                 mov     [eax], edx
.text:00003FDB                 mov     ecx, [ecx+4]
.text:00003FDE                 mov     [eax+4], ecx
.text:00003FE1                 mov     edx, [ebp+arg_0]
.text:00003FE4                 mov     eax, [edx+8]
.text:00003FE7                 mov     ecx, [edx+0Ch]
.text:00003FEA                 mov     edx, [ebp+var_10]
.text:00003FED                 mov     [edx+8], eax
.text:00003FF0                 mov     [edx+0Ch], ecx
.text:00003FF3                 mov     eax, [ebp+arg_0]
.text:00003FF6                 mov     ecx, [eax+10h]
.text:00003FF9                 mov     edx, [eax+14h]
.text:00003FFC                 mov     eax, [ebp+var_10]
.text:00003FFF                 mov     [eax+10h], ecx
.text:00004002                 mov     [eax+14h], edx
.text:00004005                 mov     ecx, [ebp+arg_0]
.text:00004008                 mov     edx, [ecx+18h]
.text:0000400B                 mov     eax, [ecx+1Ch]
.text:0000400E                 mov     ecx, [ebp+var_10]
.text:00004011                 mov     [ecx+18h], edx
.text:00004014                 mov     [ecx+1Ch], eax
.text:00004017                 mov     edx, [ebp+arg_0]
.text:0000401A                 add     edx, 20h ; ' '
.text:0000401D                 push    edx
.text:0000401E                 mov     ecx, [ebp+var_10]
.text:00004021                 add     ecx, 20h ; ' '
.text:00004024                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00004029                 mov     [ebp+var_4], 0
.text:00004030                 mov     eax, [ebp+arg_0]
.text:00004033                 add     eax, 2Ch ; ','
.text:00004036                 push    eax
.text:00004037                 mov     ecx, [ebp+var_10]
.text:0000403A                 add     ecx, 2Ch ; ','
.text:0000403D                 call    ??0?$CBuffer@E@@QAE@ABV0@@Z ; CBuffer<uchar>::CBuffer<uchar>(CBuffer<uchar> const &)
.text:00004042                 mov     byte ptr [ebp+var_4], 1
.text:00004046                 mov     ecx, [ebp+arg_0]
.text:00004049                 add     ecx, 34h ; '4'
.text:0000404C                 push    ecx
.text:0000404D                 mov     ecx, [ebp+var_10]
.text:00004050                 add     ecx, 34h ; '4'
.text:00004053                 call    ??0?$CBuffer@E@@QAE@ABV0@@Z ; CBuffer<uchar>::CBuffer<uchar>(CBuffer<uchar> const &)
.text:00004058                 mov     edx, [ebp+var_10]
.text:0000405B                 mov     eax, [ebp+arg_0]
.text:0000405E                 mov     ecx, [eax+3Ch]
.text:00004061                 mov     [edx+3Ch], ecx
.text:00004064                 mov     edx, [ebp+var_10]
.text:00004067                 mov     eax, [ebp+arg_0]
.text:0000406A                 mov     ecx, [eax+40h]
.text:0000406D                 mov     [edx+40h], ecx
.text:00004070                 mov     edx, [ebp+var_10]
.text:00004073                 mov     eax, [ebp+arg_0]
.text:00004076                 mov     ecx, [eax+44h]
.text:00004079                 mov     [edx+44h], ecx
.text:0000407C                 mov     edx, [ebp+var_10]
.text:0000407F                 mov     eax, [ebp+arg_0]
.text:00004082                 mov     ecx, [eax+48h]
.text:00004085                 mov     [edx+48h], ecx
.text:00004088                 mov     edx, [ebp+var_10]
.text:0000408B                 mov     eax, [ebp+arg_0]
.text:0000408E                 mov     cl, [eax+4Ch]
.text:00004091                 mov     [edx+4Ch], cl
.text:00004094                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000409B                 mov     eax, [ebp+var_10]
.text:0000409E                 mov     ecx, [ebp+var_C]
.text:000040A1                 mov     large fs:0, ecx
.text:000040A8                 pop     ecx
.text:000040A9                 add     esp, 10h
.text:000040AC                 cmp     ebp, esp
.text:000040AE                 call    __RTC_CheckEsp
.text:000040B3                 mov     esp, ebp
.text:000040B5                 pop     ebp
.text:000040B6                 retn    4
.text:000040B6 ??0CDirItem@@QAE@ABU0@@Z endp
.text:000040B6
.text:000040B6 ; ---------------------------------------------------------------------------
.text:000040B9                 align 4
.text:000040B9 _text           ends
.text:000040B9
.text$x:000040BC ; ===========================================================================
.text$x:000040BC
.text$x:000040BC ; Segment type: Pure code
.text$x:000040BC ; Segment permissions: Read/Execute
.text$x:000040BC _text$x         segment para public 'CODE' use32
.text$x:000040BC                 assume cs:_text$x
.text$x:000040BC                 ;org 40BCh
.text$x:000040BC ; COMDAT (pick associative to section at 3FA4)
.text$x:000040BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000040BC
.text$x:000040BC ; =============== S U B R O U T I N E =======================================
.text$x:000040BC
.text$x:000040BC
.text$x:000040BC __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$0 proc near
.text$x:000040BC                                         ; DATA XREF: .xdata$x:000040F4o
.text$x:000040BC                 mov     ecx, [ebp-10h]
.text$x:000040BF                 add     ecx, 20h ; ' '  ; this
.text$x:000040C2                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000040C2 __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$0 endp
.text$x:000040C2
.text$x:000040C7
.text$x:000040C7 ; =============== S U B R O U T I N E =======================================
.text$x:000040C7
.text$x:000040C7
.text$x:000040C7 __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$1 proc near
.text$x:000040C7                                         ; DATA XREF: .xdata$x:000040FCo
.text$x:000040C7                 mov     ecx, [ebp-10h]
.text$x:000040CA                 add     ecx, 2Ch ; ','
.text$x:000040CD                 jmp     ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text$x:000040CD __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$1 endp
.text$x:000040CD
.text$x:000040D2
.text$x:000040D2 ; =============== S U B R O U T I N E =======================================
.text$x:000040D2
.text$x:000040D2
.text$x:000040D2 __ehhandler$??0CDirItem@@QAE@ABU0@@Z proc near
.text$x:000040D2                                         ; DATA XREF: CDirItem::CDirItem(CDirItem const &)+5o
.text$x:000040D2
.text$x:000040D2 arg_4           = dword ptr  8
.text$x:000040D2
.text$x:000040D2                 mov     edx, [esp+arg_4]
.text$x:000040D6                 lea     eax, [edx+0Ch]
.text$x:000040D9                 mov     ecx, [edx-8]
.text$x:000040DC                 xor     ecx, eax
.text$x:000040DE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000040E3                 mov     eax, offset __ehfuncinfo$??0CDirItem@@QAE@ABU0@@Z
.text$x:000040E8                 jmp     ___CxxFrameHandler3
.text$x:000040E8 __ehhandler$??0CDirItem@@QAE@ABU0@@Z endp
.text$x:000040E8
.text$x:000040E8 ; ---------------------------------------------------------------------------
.text$x:000040ED                 align 10h
.text$x:000040ED _text$x         ends
.text$x:000040ED
.xdata$x:000040F0 ; ===========================================================================
.xdata$x:000040F0
.xdata$x:000040F0 ; Segment type: Pure data
.xdata$x:000040F0 ; Segment permissions: Read
.xdata$x:000040F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000040F0                 assume cs:_xdata$x
.xdata$x:000040F0                 ;org 40F0h
.xdata$x:000040F0 ; COMDAT (pick associative to section at 3FA4)
.xdata$x:000040F0 __unwindtable$??0CDirItem@@QAE@ABU0@@Z db 0FFh
.xdata$x:000040F0                                         ; DATA XREF: .xdata$x:00004108o
.xdata$x:000040F1                 db 0FFh
.xdata$x:000040F2                 db 0FFh
.xdata$x:000040F3                 db 0FFh
.xdata$x:000040F4                 dd offset __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$0
.xdata$x:000040F8                 db    0
.xdata$x:000040F9                 db    0
.xdata$x:000040FA                 db    0
.xdata$x:000040FB                 db    0
.xdata$x:000040FC                 dd offset __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$1
.xdata$x:00004100 __ehfuncinfo$??0CDirItem@@QAE@ABU0@@Z db  22h ; "
.xdata$x:00004100                                         ; DATA XREF: __ehhandler$??0CDirItem@@QAE@ABU0@@Z+11o
.xdata$x:00004101                 db    5
.xdata$x:00004102                 db  93h ; 
.xdata$x:00004103                 db  19h
.xdata$x:00004104                 db    2
.xdata$x:00004105                 db    0
.xdata$x:00004106                 db    0
.xdata$x:00004107                 db    0
.xdata$x:00004108                 dd offset __unwindtable$??0CDirItem@@QAE@ABU0@@Z
.xdata$x:0000410C                 align 20h
.xdata$x:00004120                 db    1
.xdata$x:00004121                 db    0
.xdata$x:00004122                 db    0
.xdata$x:00004123                 db    0
.xdata$x:00004123 _xdata$x        ends
.xdata$x:00004123
.text:00004124 ; ===========================================================================
.text:00004124
.text:00004124 ; Segment type: Pure code
.text:00004124 ; Segment permissions: Read/Execute
.text:00004124 _text           segment para public 'CODE' use32
.text:00004124                 assume cs:_text
.text:00004124                 ;org 4124h
.text:00004124 ; COMDAT (pick any)
.text:00004124                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004124
.text:00004124 ; =============== S U B R O U T I N E =======================================
.text:00004124
.text:00004124 ; Attributes: bp-based frame
.text:00004124
.text:00004124 ; public: void * __thiscall CDirItem::`scalar deleting destructor'(unsigned int)
.text:00004124                 public ??_GCDirItem@@QAEPAXI@Z
.text:00004124 ??_GCDirItem@@QAEPAXI@Z proc near       ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+7Fp
.text:00004124
.text:00004124 var_4           = dword ptr -4
.text:00004124 arg_0           = dword ptr  8
.text:00004124
.text:00004124                 push    ebp
.text:00004125                 mov     ebp, esp
.text:00004127                 push    ecx
.text:00004128                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000412F                 mov     [ebp+var_4], ecx
.text:00004132                 mov     ecx, [ebp+var_4] ; this
.text:00004135                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:0000413A                 mov     eax, [ebp+arg_0]
.text:0000413D                 and     eax, 1
.text:00004140                 jz      short loc_414E
.text:00004142                 mov     ecx, [ebp+var_4]
.text:00004145                 push    ecx             ; void *
.text:00004146                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000414B                 add     esp, 4
.text:0000414E
.text:0000414E loc_414E:                               ; CODE XREF: CDirItem::`scalar deleting destructor'(uint)+1Cj
.text:0000414E                 mov     eax, [ebp+var_4]
.text:00004151                 add     esp, 4
.text:00004154                 cmp     ebp, esp
.text:00004156                 call    __RTC_CheckEsp
.text:0000415B                 mov     esp, ebp
.text:0000415D                 pop     ebp
.text:0000415E                 retn    4
.text:0000415E ??_GCDirItem@@QAEPAXI@Z endp
.text:0000415E
.text:0000415E ; ---------------------------------------------------------------------------
.text:00004161                 align 4
.text:00004161 _text           ends
.text:00004161
.text:00004164 ; ===========================================================================
.text:00004164
.text:00004164 ; Segment type: Pure code
.text:00004164 ; Segment permissions: Read/Execute
.text:00004164 _text           segment para public 'CODE' use32
.text:00004164                 assume cs:_text
.text:00004164                 ;org 4164h
.text:00004164 ; COMDAT (pick any)
.text:00004164                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004164
.text:00004164 ; =============== S U B R O U T I N E =======================================
.text:00004164
.text:00004164 ; Attributes: bp-based frame
.text:00004164
.text:00004164 ; public: void * __thiscall CProp::`scalar deleting destructor'(unsigned int)
.text:00004164                 public ??_GCProp@@QAEPAXI@Z
.text:00004164 ??_GCProp@@QAEPAXI@Z proc near          ; CODE XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void)+7Fp
.text:00004164
.text:00004164 var_4           = dword ptr -4
.text:00004164 arg_0           = dword ptr  8
.text:00004164
.text:00004164                 push    ebp
.text:00004165                 mov     ebp, esp
.text:00004167                 push    ecx
.text:00004168                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000416F                 mov     [ebp+var_4], ecx
.text:00004172                 mov     ecx, [ebp+var_4] ; this
.text:00004175                 call    ??1CProp@@QAE@XZ ; CProp::~CProp(void)
.text:0000417A                 mov     eax, [ebp+arg_0]
.text:0000417D                 and     eax, 1
.text:00004180                 jz      short loc_418E
.text:00004182                 mov     ecx, [ebp+var_4]
.text:00004185                 push    ecx             ; void *
.text:00004186                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000418B                 add     esp, 4
.text:0000418E
.text:0000418E loc_418E:                               ; CODE XREF: CProp::`scalar deleting destructor'(uint)+1Cj
.text:0000418E                 mov     eax, [ebp+var_4]
.text:00004191                 add     esp, 4
.text:00004194                 cmp     ebp, esp
.text:00004196                 call    __RTC_CheckEsp
.text:0000419B                 mov     esp, ebp
.text:0000419D                 pop     ebp
.text:0000419E                 retn    4
.text:0000419E ??_GCProp@@QAEPAXI@Z endp
.text:0000419E
.text:0000419E ; ---------------------------------------------------------------------------
.text:000041A1                 align 4
.text:000041A1 _text           ends
.text:000041A1
.text:000041A4 ; ===========================================================================
.text:000041A4
.text:000041A4 ; Segment type: Pure code
.text:000041A4 ; Segment permissions: Read/Execute
.text:000041A4 _text           segment para public 'CODE' use32
.text:000041A4                 assume cs:_text
.text:000041A4                 ;org 41A4h
.text:000041A4 ; COMDAT (pick any)
.text:000041A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000041A4
.text:000041A4 ; =============== S U B R O U T I N E =======================================
.text:000041A4
.text:000041A4 ; Attributes: bp-based frame
.text:000041A4
.text:000041A4 ; _DWORD __thiscall CHasherState::CHasherState(CHasherState *__hidden this)
.text:000041A4                 public ??0CHasherState@@QAE@XZ
.text:000041A4 ??0CHasherState@@QAE@XZ proc near       ; CODE XREF: CObjectVector<CHasherState>::AddNew(void)+5Cp
.text:000041A4
.text:000041A4 var_10          = dword ptr -10h
.text:000041A4 var_C           = dword ptr -0Ch
.text:000041A4 var_4           = dword ptr -4
.text:000041A4
.text:000041A4                 push    ebp
.text:000041A5                 mov     ebp, esp
.text:000041A7                 push    0FFFFFFFFh
.text:000041A9                 push    offset __ehhandler$??0CHasherState@@QAE@XZ
.text:000041AE                 mov     eax, large fs:0
.text:000041B4                 push    eax
.text:000041B5                 push    ecx
.text:000041B6                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000041BD                 mov     eax, dword ptr ds:___security_cookie
.text:000041C2                 xor     eax, ebp
.text:000041C4                 push    eax
.text:000041C5                 lea     eax, [ebp+var_C]
.text:000041C8                 mov     large fs:0, eax
.text:000041CE                 mov     [ebp+var_10], ecx
.text:000041D1                 mov     ecx, [ebp+var_10]
.text:000041D4                 call    ??0?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::CMyComPtr<IHasher>(void)
.text:000041D9                 mov     [ebp+var_4], 0
.text:000041E0                 mov     ecx, [ebp+var_10]
.text:000041E3                 add     ecx, 4
.text:000041E6                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:000041EB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000041F2                 mov     eax, [ebp+var_10]
.text:000041F5                 mov     ecx, [ebp+var_C]
.text:000041F8                 mov     large fs:0, ecx
.text:000041FF                 pop     ecx
.text:00004200                 add     esp, 10h
.text:00004203                 cmp     ebp, esp
.text:00004205                 call    __RTC_CheckEsp
.text:0000420A                 mov     esp, ebp
.text:0000420C                 pop     ebp
.text:0000420D                 retn
.text:0000420D ??0CHasherState@@QAE@XZ endp
.text:0000420D
.text:0000420D ; ---------------------------------------------------------------------------
.text:0000420E                 align 10h
.text:0000420E _text           ends
.text:0000420E
.text$x:00004210 ; ===========================================================================
.text$x:00004210
.text$x:00004210 ; Segment type: Pure code
.text$x:00004210 ; Segment permissions: Read/Execute
.text$x:00004210 _text$x         segment para public 'CODE' use32
.text$x:00004210                 assume cs:_text$x
.text$x:00004210                 ;org 4210h
.text$x:00004210 ; COMDAT (pick associative to section at 41A4)
.text$x:00004210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004210
.text$x:00004210 ; =============== S U B R O U T I N E =======================================
.text$x:00004210
.text$x:00004210
.text$x:00004210 __unwindfunclet$??0CHasherState@@QAE@XZ$0 proc near
.text$x:00004210                                         ; DATA XREF: .xdata$x:00004238o
.text$x:00004210                 mov     ecx, [ebp-10h]
.text$x:00004213                 jmp     ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text$x:00004213 __unwindfunclet$??0CHasherState@@QAE@XZ$0 endp
.text$x:00004213
.text$x:00004218
.text$x:00004218 ; =============== S U B R O U T I N E =======================================
.text$x:00004218
.text$x:00004218
.text$x:00004218 __ehhandler$??0CHasherState@@QAE@XZ proc near
.text$x:00004218                                         ; DATA XREF: CHasherState::CHasherState(void)+5o
.text$x:00004218
.text$x:00004218 arg_4           = dword ptr  8
.text$x:00004218
.text$x:00004218                 mov     edx, [esp+arg_4]
.text$x:0000421C                 lea     eax, [edx+0Ch]
.text$x:0000421F                 mov     ecx, [edx-8]
.text$x:00004222                 xor     ecx, eax
.text$x:00004224                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004229                 mov     eax, offset __ehfuncinfo$??0CHasherState@@QAE@XZ
.text$x:0000422E                 jmp     ___CxxFrameHandler3
.text$x:0000422E __ehhandler$??0CHasherState@@QAE@XZ endp
.text$x:0000422E
.text$x:0000422E ; ---------------------------------------------------------------------------
.text$x:00004233                 align 4
.text$x:00004233 _text$x         ends
.text$x:00004233
.xdata$x:00004234 ; ===========================================================================
.xdata$x:00004234
.xdata$x:00004234 ; Segment type: Pure data
.xdata$x:00004234 ; Segment permissions: Read
.xdata$x:00004234 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004234                 assume cs:_xdata$x
.xdata$x:00004234                 ;org 4234h
.xdata$x:00004234 ; COMDAT (pick associative to section at 41A4)
.xdata$x:00004234 __unwindtable$??0CHasherState@@QAE@XZ db 0FFh
.xdata$x:00004234                                         ; DATA XREF: .xdata$x:00004244o
.xdata$x:00004235                 db 0FFh
.xdata$x:00004236                 db 0FFh
.xdata$x:00004237                 db 0FFh
.xdata$x:00004238                 dd offset __unwindfunclet$??0CHasherState@@QAE@XZ$0
.xdata$x:0000423C __ehfuncinfo$??0CHasherState@@QAE@XZ db  22h ; "
.xdata$x:0000423C                                         ; DATA XREF: __ehhandler$??0CHasherState@@QAE@XZ+11o
.xdata$x:0000423D                 db    5
.xdata$x:0000423E                 db  93h ; 
.xdata$x:0000423F                 db  19h
.xdata$x:00004240                 db    1
.xdata$x:00004241                 db    0
.xdata$x:00004242                 db    0
.xdata$x:00004243                 db    0
.xdata$x:00004244                 dd offset __unwindtable$??0CHasherState@@QAE@XZ
.xdata$x:00004248                 db    0
.xdata$x:00004249                 db    0
.xdata$x:0000424A                 db    0
.xdata$x:0000424B                 db    0
.xdata$x:0000424C                 db    0
.xdata$x:0000424D                 db    0
.xdata$x:0000424E                 db    0
.xdata$x:0000424F                 db    0
.xdata$x:00004250                 db    0
.xdata$x:00004251                 db    0
.xdata$x:00004252                 db    0
.xdata$x:00004253                 db    0
.xdata$x:00004254                 db    0
.xdata$x:00004255                 db    0
.xdata$x:00004256                 db    0
.xdata$x:00004257                 db    0
.xdata$x:00004258                 db    0
.xdata$x:00004259                 db    0
.xdata$x:0000425A                 db    0
.xdata$x:0000425B                 db    0
.xdata$x:0000425C                 db    1
.xdata$x:0000425D                 db    0
.xdata$x:0000425E                 db    0
.xdata$x:0000425F                 db    0
.xdata$x:0000425F _xdata$x        ends
.xdata$x:0000425F
.text:00004260 ; ===========================================================================
.text:00004260
.text:00004260 ; Segment type: Pure code
.text:00004260 ; Segment permissions: Read/Execute
.text:00004260 _text           segment para public 'CODE' use32
.text:00004260                 assume cs:_text
.text:00004260                 ;org 4260h
.text:00004260 ; COMDAT (pick any)
.text:00004260                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004260
.text:00004260 ; =============== S U B R O U T I N E =======================================
.text:00004260
.text:00004260 ; Attributes: bp-based frame
.text:00004260
.text:00004260 ; public: void * __thiscall CHasherState::`scalar deleting destructor'(unsigned int)
.text:00004260                 public ??_GCHasherState@@QAEPAXI@Z
.text:00004260 ??_GCHasherState@@QAEPAXI@Z proc near   ; CODE XREF: CObjectVector<CHasherState>::~CObjectVector<CHasherState>(void)+7Fp
.text:00004260
.text:00004260 var_4           = dword ptr -4
.text:00004260 arg_0           = dword ptr  8
.text:00004260
.text:00004260                 push    ebp
.text:00004261                 mov     ebp, esp
.text:00004263                 push    ecx
.text:00004264                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000426B                 mov     [ebp+var_4], ecx
.text:0000426E                 mov     ecx, [ebp+var_4] ; this
.text:00004271                 call    ??1CHasherState@@QAE@XZ ; CHasherState::~CHasherState(void)
.text:00004276                 mov     eax, [ebp+arg_0]
.text:00004279                 and     eax, 1
.text:0000427C                 jz      short loc_428A
.text:0000427E                 mov     ecx, [ebp+var_4]
.text:00004281                 push    ecx             ; void *
.text:00004282                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00004287                 add     esp, 4
.text:0000428A
.text:0000428A loc_428A:                               ; CODE XREF: CHasherState::`scalar deleting destructor'(uint)+1Cj
.text:0000428A                 mov     eax, [ebp+var_4]
.text:0000428D                 add     esp, 4
.text:00004290                 cmp     ebp, esp
.text:00004292                 call    __RTC_CheckEsp
.text:00004297                 mov     esp, ebp
.text:00004299                 pop     ebp
.text:0000429A                 retn    4
.text:0000429A ??_GCHasherState@@QAEPAXI@Z endp
.text:0000429A
.text:0000429A ; ---------------------------------------------------------------------------
.text:0000429D                 align 10h
.text:0000429D _text           ends
.text:0000429D
.text:000042A0 ; ===========================================================================
.text:000042A0
.text:000042A0 ; Segment type: Pure code
.text:000042A0 ; Segment permissions: Read/Execute
.text:000042A0 _text           segment para public 'CODE' use32
.text:000042A0                 assume cs:_text
.text:000042A0                 ;org 42A0h
.text:000042A0 ; COMDAT (pick any)
.text:000042A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000042A0
.text:000042A0 ; =============== S U B R O U T I N E =======================================
.text:000042A0
.text:000042A0 ; Attributes: bp-based frame
.text:000042A0
.text:000042A0 ; public: __thiscall COneMethodInfo::COneMethodInfo(class COneMethodInfo const &)
.text:000042A0                 public ??0COneMethodInfo@@QAE@ABV0@@Z
.text:000042A0 ??0COneMethodInfo@@QAE@ABV0@@Z proc near
.text:000042A0                                         ; CODE XREF: CObjectVector<COneMethodInfo>::Insert(uint,COneMethodInfo const &)+5Ap
.text:000042A0
.text:000042A0 var_10          = dword ptr -10h
.text:000042A0 var_C           = dword ptr -0Ch
.text:000042A0 var_4           = dword ptr -4
.text:000042A0 arg_0           = dword ptr  8
.text:000042A0
.text:000042A0                 push    ebp
.text:000042A1                 mov     ebp, esp
.text:000042A3                 push    0FFFFFFFFh
.text:000042A5                 push    offset __ehhandler$??0COneMethodInfo@@QAE@ABV0@@Z
.text:000042AA                 mov     eax, large fs:0
.text:000042B0                 push    eax
.text:000042B1                 push    ecx
.text:000042B2                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000042B9                 mov     eax, dword ptr ds:___security_cookie
.text:000042BE                 xor     eax, ebp
.text:000042C0                 push    eax
.text:000042C1                 lea     eax, [ebp+var_C]
.text:000042C4                 mov     large fs:0, eax
.text:000042CA                 mov     [ebp+var_10], ecx
.text:000042CD                 mov     eax, [ebp+arg_0]
.text:000042D0                 push    eax
.text:000042D1                 mov     ecx, [ebp+var_10]
.text:000042D4                 call    ??0CMethodProps@@QAE@ABV0@@Z ; CMethodProps::CMethodProps(CMethodProps const &)
.text:000042D9                 mov     [ebp+var_4], 0
.text:000042E0                 mov     ecx, [ebp+arg_0]
.text:000042E3                 add     ecx, 0Ch
.text:000042E6                 push    ecx
.text:000042E7                 mov     ecx, [ebp+var_10]
.text:000042EA                 add     ecx, 0Ch
.text:000042ED                 call    ??0AString@@QAE@ABV0@@Z ; AString::AString(AString const &)
.text:000042F2                 mov     byte ptr [ebp+var_4], 1
.text:000042F6                 mov     edx, [ebp+arg_0]
.text:000042F9                 add     edx, 18h
.text:000042FC                 push    edx
.text:000042FD                 mov     ecx, [ebp+var_10]
.text:00004300                 add     ecx, 18h
.text:00004303                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00004308                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000430F                 mov     eax, [ebp+var_10]
.text:00004312                 mov     ecx, [ebp+var_C]
.text:00004315                 mov     large fs:0, ecx
.text:0000431C                 pop     ecx
.text:0000431D                 add     esp, 10h
.text:00004320                 cmp     ebp, esp
.text:00004322                 call    __RTC_CheckEsp
.text:00004327                 mov     esp, ebp
.text:00004329                 pop     ebp
.text:0000432A                 retn    4
.text:0000432A ??0COneMethodInfo@@QAE@ABV0@@Z endp
.text:0000432A
.text:0000432A ; ---------------------------------------------------------------------------
.text:0000432D                 align 10h
.text:0000432D _text           ends
.text:0000432D
.text$x:00004330 ; ===========================================================================
.text$x:00004330
.text$x:00004330 ; Segment type: Pure code
.text$x:00004330 ; Segment permissions: Read/Execute
.text$x:00004330 _text$x         segment para public 'CODE' use32
.text$x:00004330                 assume cs:_text$x
.text$x:00004330                 ;org 4330h
.text$x:00004330 ; COMDAT (pick associative to section at 42A0)
.text$x:00004330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004330
.text$x:00004330 ; =============== S U B R O U T I N E =======================================
.text$x:00004330
.text$x:00004330
.text$x:00004330 __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$0 proc near
.text$x:00004330                                         ; DATA XREF: .xdata$x:00004364o
.text$x:00004330                 mov     ecx, [ebp-10h]  ; this
.text$x:00004333                 jmp     ??1CMethodProps@@QAE@XZ ; CMethodProps::~CMethodProps(void)
.text$x:00004333 __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$0 endp
.text$x:00004333
.text$x:00004338
.text$x:00004338 ; =============== S U B R O U T I N E =======================================
.text$x:00004338
.text$x:00004338
.text$x:00004338 __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$1 proc near
.text$x:00004338                                         ; DATA XREF: .xdata$x:0000436Co
.text$x:00004338                 mov     ecx, [ebp-10h]
.text$x:0000433B                 add     ecx, 0Ch        ; this
.text$x:0000433E                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:0000433E __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$1 endp
.text$x:0000433E
.text$x:00004343
.text$x:00004343 ; =============== S U B R O U T I N E =======================================
.text$x:00004343
.text$x:00004343
.text$x:00004343 __ehhandler$??0COneMethodInfo@@QAE@ABV0@@Z proc near
.text$x:00004343                                         ; DATA XREF: COneMethodInfo::COneMethodInfo(COneMethodInfo const &)+5o
.text$x:00004343
.text$x:00004343 arg_4           = dword ptr  8
.text$x:00004343
.text$x:00004343                 mov     edx, [esp+arg_4]
.text$x:00004347                 lea     eax, [edx+0Ch]
.text$x:0000434A                 mov     ecx, [edx-8]
.text$x:0000434D                 xor     ecx, eax
.text$x:0000434F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004354                 mov     eax, offset __ehfuncinfo$??0COneMethodInfo@@QAE@ABV0@@Z
.text$x:00004359                 jmp     ___CxxFrameHandler3
.text$x:00004359 __ehhandler$??0COneMethodInfo@@QAE@ABV0@@Z endp
.text$x:00004359
.text$x:00004359 ; ---------------------------------------------------------------------------
.text$x:0000435E                 align 10h
.text$x:0000435E _text$x         ends
.text$x:0000435E
.xdata$x:00004360 ; ===========================================================================
.xdata$x:00004360
.xdata$x:00004360 ; Segment type: Pure data
.xdata$x:00004360 ; Segment permissions: Read
.xdata$x:00004360 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004360                 assume cs:_xdata$x
.xdata$x:00004360                 ;org 4360h
.xdata$x:00004360 ; COMDAT (pick associative to section at 42A0)
.xdata$x:00004360 __unwindtable$??0COneMethodInfo@@QAE@ABV0@@Z db 0FFh
.xdata$x:00004360                                         ; DATA XREF: .xdata$x:00004378o
.xdata$x:00004361                 db 0FFh
.xdata$x:00004362                 db 0FFh
.xdata$x:00004363                 db 0FFh
.xdata$x:00004364                 dd offset __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$0
.xdata$x:00004368                 db    0
.xdata$x:00004369                 db    0
.xdata$x:0000436A                 db    0
.xdata$x:0000436B                 db    0
.xdata$x:0000436C                 dd offset __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$1
.xdata$x:00004370 __ehfuncinfo$??0COneMethodInfo@@QAE@ABV0@@Z db  22h ; "
.xdata$x:00004370                                         ; DATA XREF: __ehhandler$??0COneMethodInfo@@QAE@ABV0@@Z+11o
.xdata$x:00004371                 db    5
.xdata$x:00004372                 db  93h ; 
.xdata$x:00004373                 db  19h
.xdata$x:00004374                 db    2
.xdata$x:00004375                 db    0
.xdata$x:00004376                 db    0
.xdata$x:00004377                 db    0
.xdata$x:00004378                 dd offset __unwindtable$??0COneMethodInfo@@QAE@ABV0@@Z
.xdata$x:0000437C                 db    0
.xdata$x:0000437D                 db    0
.xdata$x:0000437E                 db    0
.xdata$x:0000437F                 db    0
.xdata$x:00004380                 db    0
.xdata$x:00004381                 db    0
.xdata$x:00004382                 db    0
.xdata$x:00004383                 db    0
.xdata$x:00004384                 db    0
.xdata$x:00004385                 db    0
.xdata$x:00004386                 db    0
.xdata$x:00004387                 db    0
.xdata$x:00004388                 db    0
.xdata$x:00004389                 db    0
.xdata$x:0000438A                 db    0
.xdata$x:0000438B                 db    0
.xdata$x:0000438C                 db    0
.xdata$x:0000438D                 db    0
.xdata$x:0000438E                 db    0
.xdata$x:0000438F                 db    0
.xdata$x:00004390                 db    1
.xdata$x:00004391                 db    0
.xdata$x:00004392                 db    0
.xdata$x:00004393                 db    0
.xdata$x:00004393 _xdata$x        ends
.xdata$x:00004393
.text:00004394 ; ===========================================================================
.text:00004394
.text:00004394 ; Segment type: Pure code
.text:00004394 ; Segment permissions: Read/Execute
.text:00004394 _text           segment para public 'CODE' use32
.text:00004394                 assume cs:_text
.text:00004394                 ;org 4394h
.text:00004394 ; COMDAT (pick any)
.text:00004394                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004394
.text:00004394 ; =============== S U B R O U T I N E =======================================
.text:00004394
.text:00004394 ; Attributes: bp-based frame
.text:00004394
.text:00004394 ; public: void * __thiscall COneMethodInfo::`scalar deleting destructor'(unsigned int)
.text:00004394                 public ??_GCOneMethodInfo@@QAEPAXI@Z
.text:00004394 ??_GCOneMethodInfo@@QAEPAXI@Z proc near ; CODE XREF: CObjectVector<COneMethodInfo>::~CObjectVector<COneMethodInfo>(void)+7Fp
.text:00004394                                         ; CObjectVector<COneMethodInfo>::Clear(void)+59p
.text:00004394
.text:00004394 var_4           = dword ptr -4
.text:00004394 arg_0           = dword ptr  8
.text:00004394
.text:00004394                 push    ebp
.text:00004395                 mov     ebp, esp
.text:00004397                 push    ecx
.text:00004398                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000439F                 mov     [ebp+var_4], ecx
.text:000043A2                 mov     ecx, [ebp+var_4] ; this
.text:000043A5                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000043AA                 mov     eax, [ebp+arg_0]
.text:000043AD                 and     eax, 1
.text:000043B0                 jz      short loc_43BE
.text:000043B2                 mov     ecx, [ebp+var_4]
.text:000043B5                 push    ecx             ; void *
.text:000043B6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000043BB                 add     esp, 4
.text:000043BE
.text:000043BE loc_43BE:                               ; CODE XREF: COneMethodInfo::`scalar deleting destructor'(uint)+1Cj
.text:000043BE                 mov     eax, [ebp+var_4]
.text:000043C1                 add     esp, 4
.text:000043C4                 cmp     ebp, esp
.text:000043C6                 call    __RTC_CheckEsp
.text:000043CB                 mov     esp, ebp
.text:000043CD                 pop     ebp
.text:000043CE                 retn    4
.text:000043CE ??_GCOneMethodInfo@@QAEPAXI@Z endp
.text:000043CE
.text:000043CE ; ---------------------------------------------------------------------------
.text:000043D1                 align 4
.text:000043D1 _text           ends
.text:000043D1
.text:000043D4 ; ===========================================================================
.text:000043D4
.text:000043D4 ; Segment type: Pure code
.text:000043D4 ; Segment permissions: Read/Execute
.text:000043D4 _text           segment para public 'CODE' use32
.text:000043D4                 assume cs:_text
.text:000043D4                 ;org 43D4h
.text:000043D4 ; COMDAT (pick any)
.text:000043D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000043D4
.text:000043D4 ; =============== S U B R O U T I N E =======================================
.text:000043D4
.text:000043D4 ; Attributes: bp-based frame
.text:000043D4
.text:000043D4 ; _DWORD __thiscall CProp::~CProp(CProp *__hidden this)
.text:000043D4                 public ??1CProp@@QAE@XZ
.text:000043D4 ??1CProp@@QAE@XZ proc near              ; CODE XREF: CProp::`scalar deleting destructor'(uint)+11p
.text:000043D4
.text:000043D4 var_4           = dword ptr -4
.text:000043D4
.text:000043D4                 push    ebp
.text:000043D5                 mov     ebp, esp
.text:000043D7                 push    ecx
.text:000043D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000043DF                 mov     [ebp+var_4], ecx
.text:000043E2                 mov     ecx, [ebp+var_4]
.text:000043E5                 add     ecx, 8          ; this
.text:000043E8                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000043ED                 add     esp, 4
.text:000043F0                 cmp     ebp, esp
.text:000043F2                 call    __RTC_CheckEsp
.text:000043F7                 mov     esp, ebp
.text:000043F9                 pop     ebp
.text:000043FA                 retn
.text:000043FA ??1CProp@@QAE@XZ endp
.text:000043FA
.text:000043FA ; ---------------------------------------------------------------------------
.text:000043FB                 align 4
.text:000043FB _text           ends
.text:000043FB
.text:000043FC ; ===========================================================================
.text:000043FC
.text:000043FC ; Segment type: Pure code
.text:000043FC ; Segment permissions: Read/Execute
.text:000043FC _text           segment para public 'CODE' use32
.text:000043FC                 assume cs:_text
.text:000043FC                 ;org 43FCh
.text:000043FC ; COMDAT (pick any)
.text:000043FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000043FC
.text:000043FC ; =============== S U B R O U T I N E =======================================
.text:000043FC
.text:000043FC ; Attributes: bp-based frame
.text:000043FC
.text:000043FC ; _DWORD __thiscall NWindows::NCOM::CPropVariant::~CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:000043FC                 public ??1CPropVariant@NCOM@NWindows@@QAE@XZ
.text:000043FC ??1CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:000043FC                                         ; CODE XREF: CProp::~CProp(void)+14p
.text:000043FC
.text:000043FC var_4           = dword ptr -4
.text:000043FC
.text:000043FC                 push    ebp
.text:000043FD                 mov     ebp, esp
.text:000043FF                 push    ecx
.text:00004400                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004407                 mov     [ebp+var_4], ecx
.text:0000440A                 mov     ecx, [ebp+var_4] ; this
.text:0000440D                 call    ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ ; NWindows::NCOM::CPropVariant::Clear(void)
.text:00004412                 add     esp, 4
.text:00004415                 cmp     ebp, esp
.text:00004417                 call    __RTC_CheckEsp
.text:0000441C                 mov     esp, ebp
.text:0000441E                 pop     ebp
.text:0000441F                 retn
.text:0000441F ??1CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:0000441F
.text:0000441F _text           ends
.text:0000441F
.text:00004420 ; ===========================================================================
.text:00004420
.text:00004420 ; Segment type: Pure code
.text:00004420 ; Segment permissions: Read/Execute
.text:00004420 _text           segment para public 'CODE' use32
.text:00004420                 assume cs:_text
.text:00004420                 ;org 4420h
.text:00004420 ; COMDAT (pick any)
.text:00004420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004420
.text:00004420 ; =============== S U B R O U T I N E =======================================
.text:00004420
.text:00004420 ; Attributes: bp-based frame
.text:00004420
.text:00004420 ; _DWORD __thiscall CHasherState::~CHasherState(CHasherState *__hidden this)
.text:00004420                 public ??1CHasherState@@QAE@XZ
.text:00004420 ??1CHasherState@@QAE@XZ proc near       ; CODE XREF: CHasherState::`scalar deleting destructor'(uint)+11p
.text:00004420
.text:00004420 var_10          = dword ptr -10h
.text:00004420 var_C           = dword ptr -0Ch
.text:00004420 var_4           = dword ptr -4
.text:00004420
.text:00004420                 push    ebp
.text:00004421                 mov     ebp, esp
.text:00004423                 push    0FFFFFFFFh
.text:00004425                 push    offset __ehhandler$??1CHasherState@@QAE@XZ
.text:0000442A                 mov     eax, large fs:0
.text:00004430                 push    eax
.text:00004431                 push    ecx
.text:00004432                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00004439                 mov     eax, dword ptr ds:___security_cookie
.text:0000443E                 xor     eax, ebp
.text:00004440                 push    eax
.text:00004441                 lea     eax, [ebp+var_C]
.text:00004444                 mov     large fs:0, eax
.text:0000444A                 mov     [ebp+var_10], ecx
.text:0000444D                 mov     [ebp+var_4], 0
.text:00004454                 mov     ecx, [ebp+var_10]
.text:00004457                 add     ecx, 4          ; this
.text:0000445A                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000445F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004466                 mov     ecx, [ebp+var_10]
.text:00004469                 call    ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text:0000446E                 mov     ecx, [ebp+var_C]
.text:00004471                 mov     large fs:0, ecx
.text:00004478                 pop     ecx
.text:00004479                 add     esp, 10h
.text:0000447C                 cmp     ebp, esp
.text:0000447E                 call    __RTC_CheckEsp
.text:00004483                 mov     esp, ebp
.text:00004485                 pop     ebp
.text:00004486                 retn
.text:00004486 ??1CHasherState@@QAE@XZ endp
.text:00004486
.text:00004486 ; ---------------------------------------------------------------------------
.text:00004487                 align 4
.text:00004487 _text           ends
.text:00004487
.text$x:00004488 ; ===========================================================================
.text$x:00004488
.text$x:00004488 ; Segment type: Pure code
.text$x:00004488 ; Segment permissions: Read/Execute
.text$x:00004488 _text$x         segment para public 'CODE' use32
.text$x:00004488                 assume cs:_text$x
.text$x:00004488                 ;org 4488h
.text$x:00004488 ; COMDAT (pick associative to section at 4420)
.text$x:00004488                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004488
.text$x:00004488 ; =============== S U B R O U T I N E =======================================
.text$x:00004488
.text$x:00004488
.text$x:00004488 __unwindfunclet$??1CHasherState@@QAE@XZ$0 proc near
.text$x:00004488                                         ; DATA XREF: .xdata$x:000044B0o
.text$x:00004488                 mov     ecx, [ebp-10h]
.text$x:0000448B                 jmp     ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text$x:0000448B __unwindfunclet$??1CHasherState@@QAE@XZ$0 endp
.text$x:0000448B
.text$x:00004490
.text$x:00004490 ; =============== S U B R O U T I N E =======================================
.text$x:00004490
.text$x:00004490
.text$x:00004490 __ehhandler$??1CHasherState@@QAE@XZ proc near
.text$x:00004490                                         ; DATA XREF: CHasherState::~CHasherState(void)+5o
.text$x:00004490
.text$x:00004490 arg_4           = dword ptr  8
.text$x:00004490
.text$x:00004490                 mov     edx, [esp+arg_4]
.text$x:00004494                 lea     eax, [edx+0Ch]
.text$x:00004497                 mov     ecx, [edx-8]
.text$x:0000449A                 xor     ecx, eax
.text$x:0000449C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000044A1                 mov     eax, offset __ehfuncinfo$??1CHasherState@@QAE@XZ
.text$x:000044A6                 jmp     ___CxxFrameHandler3
.text$x:000044A6 __ehhandler$??1CHasherState@@QAE@XZ endp
.text$x:000044A6
.text$x:000044A6 ; ---------------------------------------------------------------------------
.text$x:000044AB                 align 4
.text$x:000044AB _text$x         ends
.text$x:000044AB
.xdata$x:000044AC ; ===========================================================================
.xdata$x:000044AC
.xdata$x:000044AC ; Segment type: Pure data
.xdata$x:000044AC ; Segment permissions: Read
.xdata$x:000044AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000044AC                 assume cs:_xdata$x
.xdata$x:000044AC                 ;org 44ACh
.xdata$x:000044AC ; COMDAT (pick associative to section at 4420)
.xdata$x:000044AC __unwindtable$??1CHasherState@@QAE@XZ db 0FFh
.xdata$x:000044AC                                         ; DATA XREF: .xdata$x:000044BCo
.xdata$x:000044AD                 db 0FFh
.xdata$x:000044AE                 db 0FFh
.xdata$x:000044AF                 db 0FFh
.xdata$x:000044B0                 dd offset __unwindfunclet$??1CHasherState@@QAE@XZ$0
.xdata$x:000044B4 __ehfuncinfo$??1CHasherState@@QAE@XZ db  22h ; "
.xdata$x:000044B4                                         ; DATA XREF: __ehhandler$??1CHasherState@@QAE@XZ+11o
.xdata$x:000044B5                 db    5
.xdata$x:000044B6                 db  93h ; 
.xdata$x:000044B7                 db  19h
.xdata$x:000044B8                 db    1
.xdata$x:000044B9                 db    0
.xdata$x:000044BA                 db    0
.xdata$x:000044BB                 db    0
.xdata$x:000044BC                 dd offset __unwindtable$??1CHasherState@@QAE@XZ
.xdata$x:000044C0                 db    0
.xdata$x:000044C1                 db    0
.xdata$x:000044C2                 db    0
.xdata$x:000044C3                 db    0
.xdata$x:000044C4                 db    0
.xdata$x:000044C5                 db    0
.xdata$x:000044C6                 db    0
.xdata$x:000044C7                 db    0
.xdata$x:000044C8                 db    0
.xdata$x:000044C9                 db    0
.xdata$x:000044CA                 db    0
.xdata$x:000044CB                 db    0
.xdata$x:000044CC                 db    0
.xdata$x:000044CD                 db    0
.xdata$x:000044CE                 db    0
.xdata$x:000044CF                 db    0
.xdata$x:000044D0                 db    0
.xdata$x:000044D1                 db    0
.xdata$x:000044D2                 db    0
.xdata$x:000044D3                 db    0
.xdata$x:000044D4                 db    1
.xdata$x:000044D5                 db    0
.xdata$x:000044D6                 db    0
.xdata$x:000044D7                 db    0
.xdata$x:000044D7 _xdata$x        ends
.xdata$x:000044D7
.text:000044D8 ; ===========================================================================
.text:000044D8
.text:000044D8 ; Segment type: Pure code
.text:000044D8 ; Segment permissions: Read/Execute
.text:000044D8 _text           segment para public 'CODE' use32
.text:000044D8                 assume cs:_text
.text:000044D8                 ;org 44D8h
.text:000044D8 ; COMDAT (pick any)
.text:000044D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000044D8
.text:000044D8 ; =============== S U B R O U T I N E =======================================
.text:000044D8
.text:000044D8 ; Attributes: bp-based frame
.text:000044D8
.text:000044D8 ; public: __thiscall CMethodProps::CMethodProps(class CMethodProps const &)
.text:000044D8                 public ??0CMethodProps@@QAE@ABV0@@Z
.text:000044D8 ??0CMethodProps@@QAE@ABV0@@Z proc near  ; CODE XREF: COneMethodInfo::COneMethodInfo(COneMethodInfo const &)+34p
.text:000044D8
.text:000044D8 var_4           = dword ptr -4
.text:000044D8 arg_0           = dword ptr  8
.text:000044D8
.text:000044D8                 push    ebp
.text:000044D9                 mov     ebp, esp
.text:000044DB                 push    ecx
.text:000044DC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000044E3                 mov     [ebp+var_4], ecx
.text:000044E6                 mov     eax, [ebp+arg_0]
.text:000044E9                 push    eax
.text:000044EA                 mov     ecx, [ebp+var_4]
.text:000044ED                 call    ??0CProps@@QAE@ABU0@@Z ; CProps::CProps(CProps const &)
.text:000044F2                 mov     eax, [ebp+var_4]
.text:000044F5                 add     esp, 4
.text:000044F8                 cmp     ebp, esp
.text:000044FA                 call    __RTC_CheckEsp
.text:000044FF                 mov     esp, ebp
.text:00004501                 pop     ebp
.text:00004502                 retn    4
.text:00004502 ??0CMethodProps@@QAE@ABV0@@Z endp
.text:00004502
.text:00004502 ; ---------------------------------------------------------------------------
.text:00004505                 align 4
.text:00004505 _text           ends
.text:00004505
.text:00004508 ; ===========================================================================
.text:00004508
.text:00004508 ; Segment type: Pure code
.text:00004508 ; Segment permissions: Read/Execute
.text:00004508 _text           segment para public 'CODE' use32
.text:00004508                 assume cs:_text
.text:00004508                 ;org 4508h
.text:00004508 ; COMDAT (pick any)
.text:00004508                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004508
.text:00004508 ; =============== S U B R O U T I N E =======================================
.text:00004508
.text:00004508 ; Attributes: bp-based frame
.text:00004508
.text:00004508 ; public: __thiscall CProps::CProps(struct CProps const &)
.text:00004508                 public ??0CProps@@QAE@ABU0@@Z
.text:00004508 ??0CProps@@QAE@ABU0@@Z proc near        ; CODE XREF: CMethodProps::CMethodProps(CMethodProps const &)+15p
.text:00004508
.text:00004508 var_4           = dword ptr -4
.text:00004508 arg_0           = dword ptr  8
.text:00004508
.text:00004508                 push    ebp
.text:00004509                 mov     ebp, esp
.text:0000450B                 push    ecx
.text:0000450C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004513                 mov     [ebp+var_4], ecx
.text:00004516                 mov     eax, [ebp+arg_0]
.text:00004519                 push    eax
.text:0000451A                 mov     ecx, [ebp+var_4]
.text:0000451D                 call    ??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z ; CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)
.text:00004522                 mov     eax, [ebp+var_4]
.text:00004525                 add     esp, 4
.text:00004528                 cmp     ebp, esp
.text:0000452A                 call    __RTC_CheckEsp
.text:0000452F                 mov     esp, ebp
.text:00004531                 pop     ebp
.text:00004532                 retn    4
.text:00004532 ??0CProps@@QAE@ABU0@@Z endp
.text:00004532
.text:00004532 ; ---------------------------------------------------------------------------
.text:00004535                 align 4
.text:00004535 _text           ends
.text:00004535
.text:00004538 ; ===========================================================================
.text:00004538
.text:00004538 ; Segment type: Pure code
.text:00004538 ; Segment permissions: Read/Execute
.text:00004538 _text           segment para public 'CODE' use32
.text:00004538                 assume cs:_text
.text:00004538                 ;org 4538h
.text:00004538 ; COMDAT (pick any)
.text:00004538                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004538
.text:00004538 ; =============== S U B R O U T I N E =======================================
.text:00004538
.text:00004538 ; Attributes: bp-based frame
.text:00004538
.text:00004538 ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:00004538                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:00004538 ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:00004538                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+42p
.text:00004538                                         ; CObjectVector<CProp>::CObjectVector<CProp>(void)+11p ...
.text:00004538
.text:00004538 var_4           = dword ptr -4
.text:00004538
.text:00004538                 push    ebp
.text:00004539                 mov     ebp, esp
.text:0000453B                 push    ecx
.text:0000453C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004543                 mov     [ebp+var_4], ecx
.text:00004546                 mov     eax, [ebp+var_4]
.text:00004549                 mov     dword ptr [eax], 0
.text:0000454F                 mov     ecx, [ebp+var_4]
.text:00004552                 mov     dword ptr [ecx+4], 0
.text:00004559                 mov     edx, [ebp+var_4]
.text:0000455C                 mov     dword ptr [edx+8], 0
.text:00004563                 mov     eax, [ebp+var_4]
.text:00004566                 mov     esp, ebp
.text:00004568                 pop     ebp
.text:00004569                 retn
.text:00004569 ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:00004569
.text:00004569 ; ---------------------------------------------------------------------------
.text:0000456A                 align 4
.text:0000456A _text           ends
.text:0000456A
.text:0000456C ; ===========================================================================
.text:0000456C
.text:0000456C ; Segment type: Pure code
.text:0000456C ; Segment permissions: Read/Execute
.text:0000456C _text           segment para public 'CODE' use32
.text:0000456C                 assume cs:_text
.text:0000456C                 ;org 456Ch
.text:0000456C ; COMDAT (pick any)
.text:0000456C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000456C
.text:0000456C ; =============== S U B R O U T I N E =======================================
.text:0000456C
.text:0000456C ; Attributes: bp-based frame
.text:0000456C
.text:0000456C ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:0000456C                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:0000456C ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:0000456C                                         ; CODE XREF: CObjectVector<UString>::Size(void)+11p
.text:0000456C                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+46p ...
.text:0000456C
.text:0000456C var_4           = dword ptr -4
.text:0000456C
.text:0000456C                 push    ebp
.text:0000456D                 mov     ebp, esp
.text:0000456F                 push    ecx
.text:00004570                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004577                 mov     [ebp+var_4], ecx
.text:0000457A                 mov     eax, [ebp+var_4]
.text:0000457D                 mov     eax, [eax+4]
.text:00004580                 mov     esp, ebp
.text:00004582                 pop     ebp
.text:00004583                 retn
.text:00004583 ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:00004583
.text:00004583 _text           ends
.text:00004583
.text:00004584 ; ===========================================================================
.text:00004584
.text:00004584 ; Segment type: Pure code
.text:00004584 ; Segment permissions: Read/Execute
.text:00004584 _text           segment para public 'CODE' use32
.text:00004584                 assume cs:_text
.text:00004584                 ;org 4584h
.text:00004584 ; COMDAT (pick any)
.text:00004584                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004584
.text:00004584 ; =============== S U B R O U T I N E =======================================
.text:00004584
.text:00004584 ; Attributes: bp-based frame
.text:00004584
.text:00004584 ; public: bool __thiscall CRecordVector<void *>::IsEmpty(void)const
.text:00004584                 public ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ
.text:00004584 ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ proc near
.text:00004584                                         ; CODE XREF: CObjectVector<UString>::IsEmpty(void)+11p
.text:00004584
.text:00004584 var_4           = dword ptr -4
.text:00004584
.text:00004584                 push    ebp
.text:00004585                 mov     ebp, esp
.text:00004587                 push    ecx
.text:00004588                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000458F                 mov     [ebp+var_4], ecx
.text:00004592                 mov     eax, [ebp+var_4]
.text:00004595                 xor     ecx, ecx
.text:00004597                 cmp     dword ptr [eax+4], 0
.text:0000459B                 setz    cl
.text:0000459E                 mov     al, cl
.text:000045A0                 mov     esp, ebp
.text:000045A2                 pop     ebp
.text:000045A3                 retn
.text:000045A3 ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ endp
.text:000045A3
.text:000045A3 _text           ends
.text:000045A3
.text:000045A4 ; ===========================================================================
.text:000045A4
.text:000045A4 ; Segment type: Pure code
.text:000045A4 ; Segment permissions: Read/Execute
.text:000045A4 _text           segment para public 'CODE' use32
.text:000045A4                 assume cs:_text
.text:000045A4                 ;org 45A4h
.text:000045A4 ; COMDAT (pick any)
.text:000045A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000045A4
.text:000045A4 ; =============== S U B R O U T I N E =======================================
.text:000045A4
.text:000045A4 ; Attributes: bp-based frame
.text:000045A4
.text:000045A4 ; public: void __thiscall CRecordVector<void *>::ConstructReserve(unsigned int)
.text:000045A4                 public ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z
.text:000045A4 ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:000045A4                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+60p
.text:000045A4                                         ; CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+60p
.text:000045A4
.text:000045A4 var_8           = dword ptr -8
.text:000045A4 var_4           = dword ptr -4
.text:000045A4 arg_0           = dword ptr  8
.text:000045A4
.text:000045A4                 push    ebp
.text:000045A5                 mov     ebp, esp
.text:000045A7                 sub     esp, 8
.text:000045AA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000045B1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000045B8                 mov     [ebp+var_4], ecx
.text:000045BB                 cmp     [ebp+arg_0], 0
.text:000045BF                 jz      short loc_45F1
.text:000045C1                 xor     ecx, ecx
.text:000045C3                 mov     eax, [ebp+arg_0]
.text:000045C6                 mov     edx, 4
.text:000045CB                 mul     edx
.text:000045CD                 seto    cl
.text:000045D0                 neg     ecx
.text:000045D2                 or      ecx, eax
.text:000045D4                 push    ecx             ; unsigned int
.text:000045D5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000045DA                 add     esp, 4
.text:000045DD                 mov     [ebp+var_8], eax
.text:000045E0                 mov     eax, [ebp+var_4]
.text:000045E3                 mov     ecx, [ebp+var_8]
.text:000045E6                 mov     [eax], ecx
.text:000045E8                 mov     edx, [ebp+var_4]
.text:000045EB                 mov     eax, [ebp+arg_0]
.text:000045EE                 mov     [edx+8], eax
.text:000045F1
.text:000045F1 loc_45F1:                               ; CODE XREF: CRecordVector<void *>::ConstructReserve(uint)+1Bj
.text:000045F1                 add     esp, 8
.text:000045F4                 cmp     ebp, esp
.text:000045F6                 call    __RTC_CheckEsp
.text:000045FB                 mov     esp, ebp
.text:000045FD                 pop     ebp
.text:000045FE                 retn    4
.text:000045FE ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:000045FE
.text:000045FE ; ---------------------------------------------------------------------------
.text:00004601                 align 4
.text:00004601 _text           ends
.text:00004601
.text:00004604 ; ===========================================================================
.text:00004604
.text:00004604 ; Segment type: Pure code
.text:00004604 ; Segment permissions: Read/Execute
.text:00004604 _text           segment para public 'CODE' use32
.text:00004604                 assume cs:_text
.text:00004604                 ;org 4604h
.text:00004604 ; COMDAT (pick any)
.text:00004604                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004604
.text:00004604 ; =============== S U B R O U T I N E =======================================
.text:00004604
.text:00004604 ; Attributes: bp-based frame
.text:00004604
.text:00004604 ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00004604                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:00004604 ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:00004604                                         ; CODE XREF: __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0+3j
.text:00004604                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+9Cp ...
.text:00004604
.text:00004604 var_8           = dword ptr -8
.text:00004604 var_4           = dword ptr -4
.text:00004604
.text:00004604                 push    ebp
.text:00004605                 mov     ebp, esp
.text:00004607                 sub     esp, 8
.text:0000460A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00004611                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004618                 mov     [ebp+var_4], ecx
.text:0000461B                 mov     eax, [ebp+var_4]
.text:0000461E                 mov     ecx, [eax]
.text:00004620                 mov     [ebp+var_8], ecx
.text:00004623                 mov     edx, [ebp+var_8]
.text:00004626                 push    edx             ; void *
.text:00004627                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000462C                 add     esp, 4
.text:0000462F                 add     esp, 8
.text:00004632                 cmp     ebp, esp
.text:00004634                 call    __RTC_CheckEsp
.text:00004639                 mov     esp, ebp
.text:0000463B                 pop     ebp
.text:0000463C                 retn
.text:0000463C ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:0000463C
.text:0000463C ; ---------------------------------------------------------------------------
.text:0000463D                 align 10h
.text:0000463D _text           ends
.text:0000463D
.text:00004640 ; ===========================================================================
.text:00004640
.text:00004640 ; Segment type: Pure code
.text:00004640 ; Segment permissions: Read/Execute
.text:00004640 _text           segment para public 'CODE' use32
.text:00004640                 assume cs:_text
.text:00004640                 ;org 4640h
.text:00004640 ; COMDAT (pick any)
.text:00004640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004640
.text:00004640 ; =============== S U B R O U T I N E =======================================
.text:00004640
.text:00004640 ; Attributes: bp-based frame
.text:00004640
.text:00004640 ; public: void __thiscall CRecordVector<void *>::Clear(void)
.text:00004640                 public ?Clear@?$CRecordVector@PAX@@QAEXXZ
.text:00004640 ?Clear@?$CRecordVector@PAX@@QAEXXZ proc near
.text:00004640                                         ; CODE XREF: CObjectVector<COneMethodInfo>::Clear(void)+6Fp
.text:00004640
.text:00004640 var_4           = dword ptr -4
.text:00004640
.text:00004640                 push    ebp
.text:00004641                 mov     ebp, esp
.text:00004643                 push    ecx
.text:00004644                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000464B                 mov     [ebp+var_4], ecx
.text:0000464E                 mov     eax, [ebp+var_4]
.text:00004651                 mov     dword ptr [eax+4], 0
.text:00004658                 mov     esp, ebp
.text:0000465A                 pop     ebp
.text:0000465B                 retn
.text:0000465B ?Clear@?$CRecordVector@PAX@@QAEXXZ endp
.text:0000465B
.text:0000465B _text           ends
.text:0000465B
.text:0000465C ; ===========================================================================
.text:0000465C
.text:0000465C ; Segment type: Pure code
.text:0000465C ; Segment permissions: Read/Execute
.text:0000465C _text           segment para public 'CODE' use32
.text:0000465C                 assume cs:_text
.text:0000465C                 ;org 465Ch
.text:0000465C ; COMDAT (pick any)
.text:0000465C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000465C
.text:0000465C ; =============== S U B R O U T I N E =======================================
.text:0000465C
.text:0000465C ; Attributes: bp-based frame
.text:0000465C
.text:0000465C ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:0000465C                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:0000465C ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:0000465C                                         ; CODE XREF: CObjectVector<UString>::Add(UString const &)+7Fp
.text:0000465C                                         ; CObjectVector<CDirItem>::Add(CDirItem const &)+7Fp ...
.text:0000465C
.text:0000465C var_8           = dword ptr -8
.text:0000465C var_4           = dword ptr -4
.text:0000465C arg_0           = dword ptr  8
.text:0000465C
.text:0000465C                 push    ebp
.text:0000465D                 mov     ebp, esp
.text:0000465F                 sub     esp, 8
.text:00004662                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00004669                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004670                 mov     [ebp+var_4], ecx
.text:00004673                 mov     ecx, [ebp+var_4]
.text:00004676                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:0000467B                 mov     eax, [ebp+var_4]
.text:0000467E                 mov     ecx, [eax+4]
.text:00004681                 mov     edx, [ebp+var_4]
.text:00004684                 mov     eax, [edx]
.text:00004686                 mov     edx, [ebp+arg_0]
.text:00004689                 mov     [eax+ecx*4], edx
.text:0000468C                 mov     eax, [ebp+var_4]
.text:0000468F                 mov     ecx, [eax+4]
.text:00004692                 mov     [ebp+var_8], ecx
.text:00004695                 mov     edx, [ebp+var_4]
.text:00004698                 mov     eax, [edx+4]
.text:0000469B                 add     eax, 1
.text:0000469E                 mov     ecx, [ebp+var_4]
.text:000046A1                 mov     [ecx+4], eax
.text:000046A4                 mov     eax, [ebp+var_8]
.text:000046A7                 add     esp, 8
.text:000046AA                 cmp     ebp, esp
.text:000046AC                 call    __RTC_CheckEsp
.text:000046B1                 mov     esp, ebp
.text:000046B3                 pop     ebp
.text:000046B4                 retn    4
.text:000046B4 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:000046B4
.text:000046B4 ; ---------------------------------------------------------------------------
.text:000046B7                 align 4
.text:000046B7 _text           ends
.text:000046B7
.text:000046B8 ; ===========================================================================
.text:000046B8
.text:000046B8 ; Segment type: Pure code
.text:000046B8 ; Segment permissions: Read/Execute
.text:000046B8 _text           segment para public 'CODE' use32
.text:000046B8                 assume cs:_text
.text:000046B8                 ;org 46B8h
.text:000046B8 ; COMDAT (pick any)
.text:000046B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046B8
.text:000046B8 ; =============== S U B R O U T I N E =======================================
.text:000046B8
.text:000046B8 ; Attributes: bp-based frame
.text:000046B8
.text:000046B8 ; public: void __thiscall CRecordVector<void *>::AddInReserved(void * const)
.text:000046B8                 public ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z
.text:000046B8 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z proc near
.text:000046B8                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+C8p
.text:000046B8                                         ; CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+C8p
.text:000046B8
.text:000046B8 var_4           = dword ptr -4
.text:000046B8 arg_0           = dword ptr  8
.text:000046B8
.text:000046B8                 push    ebp
.text:000046B9                 mov     ebp, esp
.text:000046BB                 push    ecx
.text:000046BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000046C3                 mov     [ebp+var_4], ecx
.text:000046C6                 mov     eax, [ebp+var_4]
.text:000046C9                 mov     ecx, [eax+4]
.text:000046CC                 mov     edx, [ebp+var_4]
.text:000046CF                 mov     eax, [edx]
.text:000046D1                 mov     edx, [ebp+arg_0]
.text:000046D4                 mov     [eax+ecx*4], edx
.text:000046D7                 mov     eax, [ebp+var_4]
.text:000046DA                 mov     ecx, [eax+4]
.text:000046DD                 add     ecx, 1
.text:000046E0                 mov     edx, [ebp+var_4]
.text:000046E3                 mov     [edx+4], ecx
.text:000046E6                 mov     esp, ebp
.text:000046E8                 pop     ebp
.text:000046E9                 retn    4
.text:000046E9 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z endp
.text:000046E9
.text:000046E9 _text           ends
.text:000046E9
.text:000046EC ; ===========================================================================
.text:000046EC
.text:000046EC ; Segment type: Pure code
.text:000046EC ; Segment permissions: Read/Execute
.text:000046EC _text           segment para public 'CODE' use32
.text:000046EC                 assume cs:_text
.text:000046EC                 ;org 46ECh
.text:000046EC ; COMDAT (pick any)
.text:000046EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046EC
.text:000046EC ; =============== S U B R O U T I N E =======================================
.text:000046EC
.text:000046EC ; Attributes: bp-based frame
.text:000046EC
.text:000046EC ; public: void __thiscall CRecordVector<void *>::Insert(unsigned int, void * const)
.text:000046EC                 public ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z
.text:000046EC ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z proc near
.text:000046EC                                         ; CODE XREF: CObjectVector<COneMethodInfo>::Insert(uint,COneMethodInfo const &)+83p
.text:000046EC
.text:000046EC var_4           = dword ptr -4
.text:000046EC arg_0           = dword ptr  8
.text:000046EC arg_4           = dword ptr  0Ch
.text:000046EC
.text:000046EC                 push    ebp
.text:000046ED                 mov     ebp, esp
.text:000046EF                 push    ecx
.text:000046F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000046F7                 mov     [ebp+var_4], ecx
.text:000046FA                 mov     ecx, [ebp+var_4]
.text:000046FD                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:00004702                 mov     eax, [ebp+arg_0]
.text:00004705                 push    eax
.text:00004706                 mov     ecx, [ebp+arg_0]
.text:00004709                 add     ecx, 1
.text:0000470C                 push    ecx
.text:0000470D                 mov     ecx, [ebp+var_4]
.text:00004710                 call    ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z ; CRecordVector<void *>::MoveItems(uint,uint)
.text:00004715                 mov     edx, [ebp+var_4]
.text:00004718                 mov     eax, [edx]
.text:0000471A                 mov     ecx, [ebp+arg_0]
.text:0000471D                 mov     edx, [ebp+arg_4]
.text:00004720                 mov     [eax+ecx*4], edx
.text:00004723                 mov     eax, [ebp+var_4]
.text:00004726                 mov     ecx, [eax+4]
.text:00004729                 add     ecx, 1
.text:0000472C                 mov     edx, [ebp+var_4]
.text:0000472F                 mov     [edx+4], ecx
.text:00004732                 add     esp, 4
.text:00004735                 cmp     ebp, esp
.text:00004737                 call    __RTC_CheckEsp
.text:0000473C                 mov     esp, ebp
.text:0000473E                 pop     ebp
.text:0000473F                 retn    8
.text:0000473F ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z endp
.text:0000473F
.text:0000473F ; ---------------------------------------------------------------------------
.text:00004742                 align 4
.text:00004742 _text           ends
.text:00004742
.text:00004744 ; ===========================================================================
.text:00004744
.text:00004744 ; Segment type: Pure code
.text:00004744 ; Segment permissions: Read/Execute
.text:00004744 _text           segment para public 'CODE' use32
.text:00004744                 assume cs:_text
.text:00004744                 ;org 4744h
.text:00004744 ; COMDAT (pick any)
.text:00004744                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004744
.text:00004744 ; =============== S U B R O U T I N E =======================================
.text:00004744
.text:00004744 ; Attributes: bp-based frame
.text:00004744
.text:00004744 ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:00004744                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:00004744 ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:00004744                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:00004744                                         ; CObjectVector<CProp>::operator[](uint)+15p
.text:00004744
.text:00004744 var_4           = dword ptr -4
.text:00004744 arg_0           = dword ptr  8
.text:00004744
.text:00004744                 push    ebp
.text:00004745                 mov     ebp, esp
.text:00004747                 push    ecx
.text:00004748                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000474F                 mov     [ebp+var_4], ecx
.text:00004752                 mov     eax, [ebp+var_4]
.text:00004755                 mov     ecx, [eax]
.text:00004757                 mov     edx, [ebp+arg_0]
.text:0000475A                 lea     eax, [ecx+edx*4]
.text:0000475D                 mov     esp, ebp
.text:0000475F                 pop     ebp
.text:00004760                 retn    4
.text:00004760 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:00004760
.text:00004760 ; ---------------------------------------------------------------------------
.text:00004763                 align 4
.text:00004763 _text           ends
.text:00004763
.text:00004764 ; ===========================================================================
.text:00004764
.text:00004764 ; Segment type: Pure code
.text:00004764 ; Segment permissions: Read/Execute
.text:00004764 _text           segment para public 'CODE' use32
.text:00004764                 assume cs:_text
.text:00004764                 ;org 4764h
.text:00004764 ; COMDAT (pick any)
.text:00004764                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004764
.text:00004764 ; =============== S U B R O U T I N E =======================================
.text:00004764
.text:00004764 ; Attributes: bp-based frame
.text:00004764
.text:00004764 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:00004764                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:00004764 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:00004764                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:00004764                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+64p ...
.text:00004764
.text:00004764 var_4           = dword ptr -4
.text:00004764 arg_0           = dword ptr  8
.text:00004764
.text:00004764                 push    ebp
.text:00004765                 mov     ebp, esp
.text:00004767                 push    ecx
.text:00004768                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000476F                 mov     [ebp+var_4], ecx
.text:00004772                 mov     eax, [ebp+var_4]
.text:00004775                 mov     ecx, [eax]
.text:00004777                 mov     edx, [ebp+arg_0]
.text:0000477A                 lea     eax, [ecx+edx*4]
.text:0000477D                 mov     esp, ebp
.text:0000477F                 pop     ebp
.text:00004780                 retn    4
.text:00004780 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:00004780
.text:00004780 ; ---------------------------------------------------------------------------
.text:00004783                 align 4
.text:00004783 _text           ends
.text:00004783
.text:00004784 ; ===========================================================================
.text:00004784
.text:00004784 ; Segment type: Pure code
.text:00004784 ; Segment permissions: Read/Execute
.text:00004784 _text           segment para public 'CODE' use32
.text:00004784                 assume cs:_text
.text:00004784                 ;org 4784h
.text:00004784 ; COMDAT (pick any)
.text:00004784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004784
.text:00004784 ; =============== S U B R O U T I N E =======================================
.text:00004784
.text:00004784 ; Attributes: bp-based frame
.text:00004784
.text:00004784 ; public: __thiscall CBuffer<unsigned char>::CBuffer<unsigned char>(class CBuffer<unsigned char> const &)
.text:00004784                 public ??0?$CBuffer@E@@QAE@ABV0@@Z
.text:00004784 ??0?$CBuffer@E@@QAE@ABV0@@Z proc near   ; CODE XREF: CDirItem::CDirItem(CDirItem const &)+99p
.text:00004784                                         ; CDirItem::CDirItem(CDirItem const &)+AFp
.text:00004784
.text:00004784 var_C           = dword ptr -0Ch
.text:00004784 Size            = dword ptr -8
.text:00004784 var_4           = dword ptr -4
.text:00004784 arg_0           = dword ptr  8
.text:00004784
.text:00004784                 push    ebp
.text:00004785                 mov     ebp, esp
.text:00004787                 sub     esp, 0Ch
.text:0000478A                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00004791                 mov     [ebp+Size], 0CCCCCCCCh
.text:00004798                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000479F                 mov     [ebp+var_4], ecx
.text:000047A2                 mov     eax, [ebp+var_4]
.text:000047A5                 mov     dword ptr [eax], 0
.text:000047AB                 mov     ecx, [ebp+var_4]
.text:000047AE                 mov     dword ptr [ecx+4], 0
.text:000047B5                 mov     edx, [ebp+arg_0]
.text:000047B8                 mov     eax, [edx+4]
.text:000047BB                 mov     [ebp+Size], eax
.text:000047BE                 cmp     [ebp+Size], 0
.text:000047C2                 jz      short loc_47FC
.text:000047C4                 mov     ecx, [ebp+Size]
.text:000047C7                 push    ecx             ; unsigned int
.text:000047C8                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000047CD                 add     esp, 4
.text:000047D0                 mov     [ebp+var_C], eax
.text:000047D3                 mov     edx, [ebp+var_4]
.text:000047D6                 mov     eax, [ebp+var_C]
.text:000047D9                 mov     [edx], eax
.text:000047DB                 mov     ecx, [ebp+Size]
.text:000047DE                 push    ecx             ; Size
.text:000047DF                 mov     edx, [ebp+arg_0]
.text:000047E2                 mov     eax, [edx]
.text:000047E4                 push    eax             ; Src
.text:000047E5                 mov     ecx, [ebp+var_4]
.text:000047E8                 mov     edx, [ecx]
.text:000047EA                 push    edx             ; Dst
.text:000047EB                 call    _memcpy
.text:000047F0                 add     esp, 0Ch
.text:000047F3                 mov     eax, [ebp+var_4]
.text:000047F6                 mov     ecx, [ebp+Size]
.text:000047F9                 mov     [eax+4], ecx
.text:000047FC
.text:000047FC loc_47FC:                               ; CODE XREF: CBuffer<uchar>::CBuffer<uchar>(CBuffer<uchar> const &)+3Ej
.text:000047FC                 mov     eax, [ebp+var_4]
.text:000047FF                 add     esp, 0Ch
.text:00004802                 cmp     ebp, esp
.text:00004804                 call    __RTC_CheckEsp
.text:00004809                 mov     esp, ebp
.text:0000480B                 pop     ebp
.text:0000480C                 retn    4
.text:0000480C ??0?$CBuffer@E@@QAE@ABV0@@Z endp
.text:0000480C
.text:0000480C ; ---------------------------------------------------------------------------
.text:0000480F                 align 10h
.text:0000480F _text           ends
.text:0000480F
.text:00004810 ; ===========================================================================
.text:00004810
.text:00004810 ; Segment type: Pure code
.text:00004810 ; Segment permissions: Read/Execute
.text:00004810 _text           segment para public 'CODE' use32
.text:00004810                 assume cs:_text
.text:00004810                 ;org 4810h
.text:00004810 ; COMDAT (pick any)
.text:00004810                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004810
.text:00004810 ; =============== S U B R O U T I N E =======================================
.text:00004810
.text:00004810 ; Attributes: bp-based frame
.text:00004810
.text:00004810 ; public: __thiscall CObjectVector<struct CProp>::CObjectVector<struct CProp>(class CObjectVector<struct CProp> const &)
.text:00004810                 public ??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z
.text:00004810 ??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z proc near
.text:00004810                                         ; CODE XREF: CProps::CProps(CProps const &)+15p
.text:00004810
.text:00004810 var_24          = dword ptr -24h
.text:00004810 var_20          = dword ptr -20h
.text:00004810 var_1C          = dword ptr -1Ch
.text:00004810 var_18          = dword ptr -18h
.text:00004810 var_14          = dword ptr -14h
.text:00004810 var_10          = dword ptr -10h
.text:00004810 var_C           = dword ptr -0Ch
.text:00004810 var_4           = dword ptr -4
.text:00004810 arg_0           = dword ptr  8
.text:00004810
.text:00004810                 push    ebp
.text:00004811                 mov     ebp, esp
.text:00004813                 push    0FFFFFFFFh
.text:00004815                 push    offset __ehhandler$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z
.text:0000481A                 mov     eax, large fs:0
.text:00004820                 push    eax
.text:00004821                 sub     esp, 18h
.text:00004824                 mov     eax, 0CCCCCCCCh
.text:00004829                 mov     [ebp+var_24], eax
.text:0000482C                 mov     [ebp+var_20], eax
.text:0000482F                 mov     [ebp+var_1C], eax
.text:00004832                 mov     [ebp+var_18], eax
.text:00004835                 mov     [ebp+var_14], eax
.text:00004838                 mov     [ebp+var_10], eax
.text:0000483B                 mov     eax, dword ptr ds:___security_cookie
.text:00004840                 xor     eax, ebp
.text:00004842                 push    eax
.text:00004843                 lea     eax, [ebp+var_C]
.text:00004846                 mov     large fs:0, eax
.text:0000484C                 mov     [ebp+var_10], ecx
.text:0000484F                 mov     ecx, [ebp+var_10]
.text:00004852                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00004857                 mov     [ebp+var_4], 0
.text:0000485E                 mov     ecx, [ebp+arg_0]
.text:00004861                 call    ?Size@?$CObjectVector@UCProp@@@@QBEIXZ ; CObjectVector<CProp>::Size(void)
.text:00004866                 mov     [ebp+var_14], eax
.text:00004869                 mov     eax, [ebp+var_14]
.text:0000486C                 push    eax
.text:0000486D                 mov     ecx, [ebp+var_10]
.text:00004870                 call    ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ConstructReserve(uint)
.text:00004875                 mov     [ebp+var_18], 0
.text:0000487C                 jmp     short loc_4887
.text:0000487E ; ---------------------------------------------------------------------------
.text:0000487E
.text:0000487E loc_487E:                               ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+CDj
.text:0000487E                 mov     ecx, [ebp+var_18]
.text:00004881                 add     ecx, 1
.text:00004884                 mov     [ebp+var_18], ecx
.text:00004887
.text:00004887 loc_4887:                               ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+6Cj
.text:00004887                 mov     edx, [ebp+var_18]
.text:0000488A                 cmp     edx, [ebp+var_14]
.text:0000488D                 jnb     short loc_48DF
.text:0000488F                 push    18h             ; unsigned int
.text:00004891                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00004896                 add     esp, 4
.text:00004899                 mov     [ebp+var_20], eax
.text:0000489C                 mov     byte ptr [ebp+var_4], 1
.text:000048A0                 cmp     [ebp+var_20], 0
.text:000048A4                 jz      short loc_48C0
.text:000048A6                 mov     eax, [ebp+var_18]
.text:000048A9                 push    eax
.text:000048AA                 mov     ecx, [ebp+arg_0]
.text:000048AD                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:000048B2                 push    eax             ; struct CProp *
.text:000048B3                 mov     ecx, [ebp+var_20] ; this
.text:000048B6                 call    ??0CProp@@QAE@ABU0@@Z ; CProp::CProp(CProp const &)
.text:000048BB                 mov     [ebp+var_24], eax
.text:000048BE                 jmp     short loc_48C7
.text:000048C0 ; ---------------------------------------------------------------------------
.text:000048C0
.text:000048C0 loc_48C0:                               ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+94j
.text:000048C0                 mov     [ebp+var_24], 0
.text:000048C7
.text:000048C7 loc_48C7:                               ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+AEj
.text:000048C7                 mov     ecx, [ebp+var_24]
.text:000048CA                 mov     [ebp+var_1C], ecx
.text:000048CD                 mov     byte ptr [ebp+var_4], 0
.text:000048D1                 mov     edx, [ebp+var_1C]
.text:000048D4                 push    edx
.text:000048D5                 mov     ecx, [ebp+var_10]
.text:000048D8                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:000048DD                 jmp     short loc_487E
.text:000048DF ; ---------------------------------------------------------------------------
.text:000048DF
.text:000048DF loc_48DF:                               ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+7Dj
.text:000048DF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000048E6                 mov     eax, [ebp+var_10]
.text:000048E9                 mov     ecx, [ebp+var_C]
.text:000048EC                 mov     large fs:0, ecx
.text:000048F3                 pop     ecx
.text:000048F4                 add     esp, 24h
.text:000048F7                 cmp     ebp, esp
.text:000048F9                 call    __RTC_CheckEsp
.text:000048FE                 mov     esp, ebp
.text:00004900                 pop     ebp
.text:00004901                 retn    4
.text:00004901 ??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z endp
.text:00004901
.text:00004901 _text           ends
.text:00004901
.text$x:00004904 ; ===========================================================================
.text$x:00004904
.text$x:00004904 ; Segment type: Pure code
.text$x:00004904 ; Segment permissions: Read/Execute
.text$x:00004904 _text$x         segment para public 'CODE' use32
.text$x:00004904                 assume cs:_text$x
.text$x:00004904                 ;org 4904h
.text$x:00004904 ; COMDAT (pick associative to section at 4810)
.text$x:00004904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004904
.text$x:00004904 ; =============== S U B R O U T I N E =======================================
.text$x:00004904
.text$x:00004904
.text$x:00004904 __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$0 proc near
.text$x:00004904                                         ; DATA XREF: .xdata$x:00004938o
.text$x:00004904                 mov     ecx, [ebp-10h]
.text$x:00004907                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00004907 __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$0 endp
.text$x:00004907
.text$x:0000490C
.text$x:0000490C ; =============== S U B R O U T I N E =======================================
.text$x:0000490C
.text$x:0000490C
.text$x:0000490C __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$1 proc near
.text$x:0000490C                                         ; DATA XREF: .xdata$x:00004940o
.text$x:0000490C                 mov     eax, [ebp-20h]
.text$x:0000490F                 push    eax             ; void *
.text$x:00004910                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00004915                 pop     ecx
.text$x:00004916                 retn
.text$x:00004916 __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$1 endp
.text$x:00004916
.text$x:00004917
.text$x:00004917 ; =============== S U B R O U T I N E =======================================
.text$x:00004917
.text$x:00004917
.text$x:00004917 __ehhandler$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z proc near
.text$x:00004917                                         ; DATA XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+5o
.text$x:00004917
.text$x:00004917 arg_4           = dword ptr  8
.text$x:00004917
.text$x:00004917                 mov     edx, [esp+arg_4]
.text$x:0000491B                 lea     eax, [edx+0Ch]
.text$x:0000491E                 mov     ecx, [edx-1Ch]
.text$x:00004921                 xor     ecx, eax
.text$x:00004923                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004928                 mov     eax, offset __ehfuncinfo$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z
.text$x:0000492D                 jmp     ___CxxFrameHandler3
.text$x:0000492D __ehhandler$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z endp
.text$x:0000492D
.text$x:0000492D ; ---------------------------------------------------------------------------
.text$x:00004932                 align 4
.text$x:00004932 _text$x         ends
.text$x:00004932
.xdata$x:00004934 ; ===========================================================================
.xdata$x:00004934
.xdata$x:00004934 ; Segment type: Pure data
.xdata$x:00004934 ; Segment permissions: Read
.xdata$x:00004934 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004934                 assume cs:_xdata$x
.xdata$x:00004934                 ;org 4934h
.xdata$x:00004934 ; COMDAT (pick associative to section at 4810)
.xdata$x:00004934 __unwindtable$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z db 0FFh
.xdata$x:00004934                                         ; DATA XREF: .xdata$x:0000494Co
.xdata$x:00004935                 db 0FFh
.xdata$x:00004936                 db 0FFh
.xdata$x:00004937                 db 0FFh
.xdata$x:00004938                 dd offset __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$0
.xdata$x:0000493C                 align 10h
.xdata$x:00004940                 dd offset __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$1
.xdata$x:00004944 __ehfuncinfo$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z db  22h ; "
.xdata$x:00004944                                         ; DATA XREF: __ehhandler$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z+11o
.xdata$x:00004945                 db    5
.xdata$x:00004946                 db  93h ; 
.xdata$x:00004947                 db  19h
.xdata$x:00004948                 db    2
.xdata$x:00004949                 db    0
.xdata$x:0000494A                 db    0
.xdata$x:0000494B                 db    0
.xdata$x:0000494C                 dd offset __unwindtable$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z
.xdata$x:00004950                 db    0
.xdata$x:00004951                 db    0
.xdata$x:00004952                 db    0
.xdata$x:00004953                 db    0
.xdata$x:00004954                 db    0
.xdata$x:00004955                 db    0
.xdata$x:00004956                 db    0
.xdata$x:00004957                 db    0
.xdata$x:00004958                 db    0
.xdata$x:00004959                 db    0
.xdata$x:0000495A                 db    0
.xdata$x:0000495B                 db    0
.xdata$x:0000495C                 db    0
.xdata$x:0000495D                 db    0
.xdata$x:0000495E                 db    0
.xdata$x:0000495F                 db    0
.xdata$x:00004960                 db    0
.xdata$x:00004961                 db    0
.xdata$x:00004962                 db    0
.xdata$x:00004963                 db    0
.xdata$x:00004964                 db    1
.xdata$x:00004965                 db    0
.xdata$x:00004966                 db    0
.xdata$x:00004967                 db    0
.xdata$x:00004967 _xdata$x        ends
.xdata$x:00004967
.text:00004968 ; ===========================================================================
.text:00004968
.text:00004968 ; Segment type: Pure code
.text:00004968 ; Segment permissions: Read/Execute
.text:00004968 _text           segment para public 'CODE' use32
.text:00004968                 assume cs:_text
.text:00004968                 ;org 4968h
.text:00004968 ; COMDAT (pick any)
.text:00004968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004968
.text:00004968 ; =============== S U B R O U T I N E =======================================
.text:00004968
.text:00004968 ; Attributes: bp-based frame
.text:00004968
.text:00004968 ; public: unsigned int __thiscall CObjectVector<struct CProp>::Size(void)const
.text:00004968                 public ?Size@?$CObjectVector@UCProp@@@@QBEIXZ
.text:00004968 ?Size@?$CObjectVector@UCProp@@@@QBEIXZ proc near
.text:00004968                                         ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+51p
.text:00004968
.text:00004968 var_4           = dword ptr -4
.text:00004968
.text:00004968                 push    ebp
.text:00004969                 mov     ebp, esp
.text:0000496B                 push    ecx
.text:0000496C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004973                 mov     [ebp+var_4], ecx
.text:00004976                 mov     ecx, [ebp+var_4]
.text:00004979                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000497E                 add     esp, 4
.text:00004981                 cmp     ebp, esp
.text:00004983                 call    __RTC_CheckEsp
.text:00004988                 mov     esp, ebp
.text:0000498A                 pop     ebp
.text:0000498B                 retn
.text:0000498B ?Size@?$CObjectVector@UCProp@@@@QBEIXZ endp
.text:0000498B
.text:0000498B _text           ends
.text:0000498B
.text:0000498C ; ===========================================================================
.text:0000498C
.text:0000498C ; Segment type: Pure code
.text:0000498C ; Segment permissions: Read/Execute
.text:0000498C _text           segment para public 'CODE' use32
.text:0000498C                 assume cs:_text
.text:0000498C                 ;org 498Ch
.text:0000498C ; COMDAT (pick any)
.text:0000498C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000498C
.text:0000498C ; =============== S U B R O U T I N E =======================================
.text:0000498C
.text:0000498C ; Attributes: bp-based frame
.text:0000498C
.text:0000498C ; public: struct CProp const & __thiscall CObjectVector<struct CProp>::operator[](unsigned int)const
.text:0000498C                 public ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z
.text:0000498C ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z proc near
.text:0000498C                                         ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+9Dp
.text:0000498C
.text:0000498C var_4           = dword ptr -4
.text:0000498C arg_0           = dword ptr  8
.text:0000498C
.text:0000498C                 push    ebp
.text:0000498D                 mov     ebp, esp
.text:0000498F                 push    ecx
.text:00004990                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004997                 mov     [ebp+var_4], ecx
.text:0000499A                 mov     eax, [ebp+arg_0]
.text:0000499D                 push    eax
.text:0000499E                 mov     ecx, [ebp+var_4]
.text:000049A1                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000049A6                 mov     eax, [eax]
.text:000049A8                 add     esp, 4
.text:000049AB                 cmp     ebp, esp
.text:000049AD                 call    __RTC_CheckEsp
.text:000049B2                 mov     esp, ebp
.text:000049B4                 pop     ebp
.text:000049B5                 retn    4
.text:000049B5 ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z endp
.text:000049B5
.text:000049B5 _text           ends
.text:000049B5
.text:000049B8 ; ===========================================================================
.text:000049B8
.text:000049B8 ; Segment type: Pure code
.text:000049B8 ; Segment permissions: Read/Execute
.text:000049B8 _text           segment para public 'CODE' use32
.text:000049B8                 assume cs:_text
.text:000049B8                 ;org 49B8h
.text:000049B8 ; COMDAT (pick any)
.text:000049B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000049B8
.text:000049B8 ; =============== S U B R O U T I N E =======================================
.text:000049B8
.text:000049B8 ; Attributes: bp-based frame
.text:000049B8
.text:000049B8 ; public: struct IHasher * __thiscall CMyComPtr<struct IHasher>::operator=(struct IHasher *)
.text:000049B8                 public ??4?$CMyComPtr@UIHasher@@@@QAEPAUIHasher@@PAU1@@Z
.text:000049B8 ??4?$CMyComPtr@UIHasher@@@@QAEPAUIHasher@@PAU1@@Z proc near
.text:000049B8                                         ; CODE XREF: CMyComPtr<IHasher>::operator=(CMyComPtr<IHasher> const &)+17p
.text:000049B8
.text:000049B8 var_4           = dword ptr -4
.text:000049B8 arg_0           = dword ptr  8
.text:000049B8
.text:000049B8                 push    ebp
.text:000049B9                 mov     ebp, esp
.text:000049BB                 push    ecx
.text:000049BC                 push    esi
.text:000049BD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000049C4                 mov     [ebp+var_4], ecx
.text:000049C7                 cmp     [ebp+arg_0], 0
.text:000049CB                 jz      short loc_49E4
.text:000049CD                 mov     eax, [ebp+arg_0]
.text:000049D0                 mov     ecx, [eax]
.text:000049D2                 mov     esi, esp
.text:000049D4                 mov     edx, [ebp+arg_0]
.text:000049D7                 push    edx
.text:000049D8                 mov     eax, [ecx+4]
.text:000049DB                 call    eax
.text:000049DD                 cmp     esi, esp
.text:000049DF                 call    __RTC_CheckEsp
.text:000049E4
.text:000049E4 loc_49E4:                               ; CODE XREF: CMyComPtr<IHasher>::operator=(IHasher *)+13j
.text:000049E4                 mov     ecx, [ebp+var_4]
.text:000049E7                 cmp     dword ptr [ecx], 0
.text:000049EA                 jz      short loc_4A07
.text:000049EC                 mov     edx, [ebp+var_4]
.text:000049EF                 mov     eax, [edx]
.text:000049F1                 mov     ecx, [ebp+var_4]
.text:000049F4                 mov     edx, [ecx]
.text:000049F6                 mov     eax, [eax]
.text:000049F8                 mov     esi, esp
.text:000049FA                 push    edx
.text:000049FB                 mov     ecx, [eax+8]
.text:000049FE                 call    ecx
.text:00004A00                 cmp     esi, esp
.text:00004A02                 call    __RTC_CheckEsp
.text:00004A07
.text:00004A07 loc_4A07:                               ; CODE XREF: CMyComPtr<IHasher>::operator=(IHasher *)+32j
.text:00004A07                 mov     edx, [ebp+var_4]
.text:00004A0A                 mov     eax, [ebp+arg_0]
.text:00004A0D                 mov     [edx], eax
.text:00004A0F                 mov     eax, [ebp+arg_0]
.text:00004A12                 pop     esi
.text:00004A13                 add     esp, 4
.text:00004A16                 cmp     ebp, esp
.text:00004A18                 call    __RTC_CheckEsp
.text:00004A1D                 mov     esp, ebp
.text:00004A1F                 pop     ebp
.text:00004A20                 retn    4
.text:00004A20 ??4?$CMyComPtr@UIHasher@@@@QAEPAUIHasher@@PAU1@@Z endp
.text:00004A20
.text:00004A20 ; ---------------------------------------------------------------------------
.text:00004A23                 align 4
.text:00004A23 _text           ends
.text:00004A23
.text:00004A24 ; ===========================================================================
.text:00004A24
.text:00004A24 ; Segment type: Pure code
.text:00004A24 ; Segment permissions: Read/Execute
.text:00004A24 _text           segment para public 'CODE' use32
.text:00004A24                 assume cs:_text
.text:00004A24                 ;org 4A24h
.text:00004A24 ; COMDAT (pick any)
.text:00004A24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004A24
.text:00004A24 ; =============== S U B R O U T I N E =======================================
.text:00004A24
.text:00004A24 ; Attributes: bp-based frame
.text:00004A24
.text:00004A24 ; public: void __thiscall CRecordVector<unsigned __int64>::Insert(unsigned int, unsigned __int64)
.text:00004A24                 public ?Insert@?$CRecordVector@_K@@QAEXI_K@Z
.text:00004A24 ?Insert@?$CRecordVector@_K@@QAEXI_K@Z proc near
.text:00004A24                                         ; CODE XREF: CRecordVector<unsigned __int64>::AddToUniqueSorted(unsigned __int64)+A3p
.text:00004A24
.text:00004A24 var_4           = dword ptr -4
.text:00004A24 arg_0           = dword ptr  8
.text:00004A24 arg_4           = dword ptr  0Ch
.text:00004A24 arg_8           = dword ptr  10h
.text:00004A24
.text:00004A24                 push    ebp
.text:00004A25                 mov     ebp, esp
.text:00004A27                 push    ecx
.text:00004A28                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004A2F                 mov     [ebp+var_4], ecx
.text:00004A32                 mov     ecx, [ebp+var_4]
.text:00004A35                 call    ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ ; CRecordVector<unsigned __int64>::ReserveOnePosition(void)
.text:00004A3A                 mov     eax, [ebp+arg_0]
.text:00004A3D                 push    eax
.text:00004A3E                 mov     ecx, [ebp+arg_0]
.text:00004A41                 add     ecx, 1
.text:00004A44                 push    ecx
.text:00004A45                 mov     ecx, [ebp+var_4]
.text:00004A48                 call    ?MoveItems@?$CRecordVector@_K@@AAEXII@Z ; CRecordVector<unsigned __int64>::MoveItems(uint,uint)
.text:00004A4D                 mov     edx, [ebp+var_4]
.text:00004A50                 mov     eax, [edx]
.text:00004A52                 mov     ecx, [ebp+arg_0]
.text:00004A55                 mov     edx, [ebp+arg_4]
.text:00004A58                 mov     [eax+ecx*8], edx
.text:00004A5B                 mov     edx, [ebp+arg_8]
.text:00004A5E                 mov     [eax+ecx*8+4], edx
.text:00004A62                 mov     eax, [ebp+var_4]
.text:00004A65                 mov     ecx, [eax+4]
.text:00004A68                 add     ecx, 1
.text:00004A6B                 mov     edx, [ebp+var_4]
.text:00004A6E                 mov     [edx+4], ecx
.text:00004A71                 add     esp, 4
.text:00004A74                 cmp     ebp, esp
.text:00004A76                 call    __RTC_CheckEsp
.text:00004A7B                 mov     esp, ebp
.text:00004A7D                 pop     ebp
.text:00004A7E                 retn    0Ch
.text:00004A7E ?Insert@?$CRecordVector@_K@@QAEXI_K@Z endp
.text:00004A7E
.text:00004A7E ; ---------------------------------------------------------------------------
.text:00004A81                 align 4
.text:00004A81 _text           ends
.text:00004A81
.text:00004A84 ; ===========================================================================
.text:00004A84
.text:00004A84 ; Segment type: Pure code
.text:00004A84 ; Segment permissions: Read/Execute
.text:00004A84 _text           segment para public 'CODE' use32
.text:00004A84                 assume cs:_text
.text:00004A84                 ;org 4A84h
.text:00004A84 ; COMDAT (pick any)
.text:00004A84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004A84
.text:00004A84 ; =============== S U B R O U T I N E =======================================
.text:00004A84
.text:00004A84 ; Attributes: bp-based frame
.text:00004A84
.text:00004A84 ; _DWORD __thiscall CProp::CProp(CProp *this, const struct CProp *)
.text:00004A84                 public ??0CProp@@QAE@ABU0@@Z
.text:00004A84 ??0CProp@@QAE@ABU0@@Z proc near         ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+A6p
.text:00004A84
.text:00004A84 var_4           = dword ptr -4
.text:00004A84 arg_0           = dword ptr  8
.text:00004A84
.text:00004A84                 push    ebp
.text:00004A85                 mov     ebp, esp
.text:00004A87                 push    ecx
.text:00004A88                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004A8F                 mov     [ebp+var_4], ecx
.text:00004A92                 mov     eax, [ebp+var_4]
.text:00004A95                 mov     ecx, [ebp+arg_0]
.text:00004A98                 mov     edx, [ecx]
.text:00004A9A                 mov     [eax], edx
.text:00004A9C                 mov     eax, [ebp+var_4]
.text:00004A9F                 mov     ecx, [ebp+arg_0]
.text:00004AA2                 mov     dl, [ecx+4]
.text:00004AA5                 mov     [eax+4], dl
.text:00004AA8                 mov     eax, [ebp+arg_0]
.text:00004AAB                 add     eax, 8
.text:00004AAE                 push    eax             ; struct NWindows::NCOM::CPropVariant *
.text:00004AAF                 mov     ecx, [ebp+var_4]
.text:00004AB2                 add     ecx, 8          ; this
.text:00004AB5                 call    ??0CPropVariant@NCOM@NWindows@@QAE@ABV012@@Z ; NWindows::NCOM::CPropVariant::CPropVariant(NWindows::NCOM::CPropVariant const &)
.text:00004ABA                 mov     eax, [ebp+var_4]
.text:00004ABD                 add     esp, 4
.text:00004AC0                 cmp     ebp, esp
.text:00004AC2                 call    __RTC_CheckEsp
.text:00004AC7                 mov     esp, ebp
.text:00004AC9                 pop     ebp
.text:00004ACA                 retn    4
.text:00004ACA ??0CProp@@QAE@ABU0@@Z endp
.text:00004ACA
.text:00004ACA ; ---------------------------------------------------------------------------
.text:00004ACD                 align 10h
.text:00004ACD _text           ends
.text:00004ACD
.text:00004AD0 ; ===========================================================================
.text:00004AD0
.text:00004AD0 ; Segment type: Pure code
.text:00004AD0 ; Segment permissions: Read/Execute
.text:00004AD0 _text           segment para public 'CODE' use32
.text:00004AD0                 assume cs:_text
.text:00004AD0                 ;org 4AD0h
.text:00004AD0 ; COMDAT (pick any)
.text:00004AD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004AD0
.text:00004AD0 ; =============== S U B R O U T I N E =======================================
.text:00004AD0
.text:00004AD0 ; Attributes: bp-based frame
.text:00004AD0
.text:00004AD0 ; private: void __thiscall CRecordVector<void *>::MoveItems(unsigned int, unsigned int)
.text:00004AD0                 public ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z
.text:00004AD0 ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z proc near
.text:00004AD0                                         ; CODE XREF: CRecordVector<void *>::Insert(uint,void * const)+24p
.text:00004AD0
.text:00004AD0 var_4           = dword ptr -4
.text:00004AD0 arg_0           = dword ptr  8
.text:00004AD0 arg_4           = dword ptr  0Ch
.text:00004AD0
.text:00004AD0                 push    ebp
.text:00004AD1                 mov     ebp, esp
.text:00004AD3                 push    ecx
.text:00004AD4                 push    esi
.text:00004AD5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004ADC                 mov     [ebp+var_4], ecx
.text:00004ADF                 mov     eax, [ebp+var_4]
.text:00004AE2                 mov     ecx, [eax+4]
.text:00004AE5                 sub     ecx, [ebp+arg_4]
.text:00004AE8                 shl     ecx, 2
.text:00004AEB                 mov     esi, esp
.text:00004AED                 push    ecx             ; Size
.text:00004AEE                 mov     edx, [ebp+var_4]
.text:00004AF1                 mov     eax, [edx]
.text:00004AF3                 mov     ecx, [ebp+arg_4]
.text:00004AF6                 lea     edx, [eax+ecx*4]
.text:00004AF9                 push    edx             ; Src
.text:00004AFA                 mov     eax, [ebp+var_4]
.text:00004AFD                 mov     ecx, [eax]
.text:00004AFF                 mov     edx, [ebp+arg_0]
.text:00004B02                 lea     eax, [ecx+edx*4]
.text:00004B05                 push    eax             ; Dst
.text:00004B06                 call    dword ptr ds:__imp__memmove
.text:00004B0C                 add     esp, 0Ch
.text:00004B0F                 cmp     esi, esp
.text:00004B11                 call    __RTC_CheckEsp
.text:00004B16                 pop     esi
.text:00004B17                 add     esp, 4
.text:00004B1A                 cmp     ebp, esp
.text:00004B1C                 call    __RTC_CheckEsp
.text:00004B21                 mov     esp, ebp
.text:00004B23                 pop     ebp
.text:00004B24                 retn    8
.text:00004B24 ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z endp
.text:00004B24
.text:00004B24 ; ---------------------------------------------------------------------------
.text:00004B27                 align 4
.text:00004B27 _text           ends
.text:00004B27
.text:00004B28 ; ===========================================================================
.text:00004B28
.text:00004B28 ; Segment type: Pure code
.text:00004B28 ; Segment permissions: Read/Execute
.text:00004B28 _text           segment para public 'CODE' use32
.text:00004B28                 assume cs:_text
.text:00004B28                 ;org 4B28h
.text:00004B28 ; COMDAT (pick any)
.text:00004B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004B28
.text:00004B28 ; =============== S U B R O U T I N E =======================================
.text:00004B28
.text:00004B28 ; Attributes: bp-based frame
.text:00004B28
.text:00004B28 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:00004B28                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:00004B28 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:00004B28                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:00004B28                                         ; CRecordVector<void *>::Insert(uint,void * const)+11p
.text:00004B28
.text:00004B28 var_14          = dword ptr -14h
.text:00004B28 var_10          = dword ptr -10h
.text:00004B28 Dst             = dword ptr -0Ch
.text:00004B28 var_8           = dword ptr -8
.text:00004B28 var_4           = dword ptr -4
.text:00004B28
.text:00004B28                 push    ebp
.text:00004B29                 mov     ebp, esp
.text:00004B2B                 sub     esp, 14h
.text:00004B2E                 mov     eax, 0CCCCCCCCh
.text:00004B33                 mov     [ebp+var_14], eax
.text:00004B36                 mov     [ebp+var_10], eax
.text:00004B39                 mov     [ebp+Dst], eax
.text:00004B3C                 mov     [ebp+var_8], eax
.text:00004B3F                 mov     [ebp+var_4], eax
.text:00004B42                 mov     [ebp+var_4], ecx
.text:00004B45                 mov     eax, [ebp+var_4]
.text:00004B48                 mov     ecx, [ebp+var_4]
.text:00004B4B                 mov     edx, [eax+4]
.text:00004B4E                 cmp     edx, [ecx+8]
.text:00004B51                 jnz     loc_4BDC
.text:00004B57                 mov     eax, [ebp+var_4]
.text:00004B5A                 mov     ecx, [eax+8]
.text:00004B5D                 shr     ecx, 2
.text:00004B60                 mov     edx, [ebp+var_4]
.text:00004B63                 mov     eax, [edx+8]
.text:00004B66                 lea     ecx, [eax+ecx+1]
.text:00004B6A                 mov     [ebp+var_8], ecx
.text:00004B6D                 xor     ecx, ecx
.text:00004B6F                 mov     eax, [ebp+var_8]
.text:00004B72                 mov     edx, 4
.text:00004B77                 mul     edx
.text:00004B79                 seto    cl
.text:00004B7C                 neg     ecx
.text:00004B7E                 or      ecx, eax
.text:00004B80                 push    ecx             ; unsigned int
.text:00004B81                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00004B86                 add     esp, 4
.text:00004B89                 mov     [ebp+var_10], eax
.text:00004B8C                 mov     eax, [ebp+var_10]
.text:00004B8F                 mov     [ebp+Dst], eax
.text:00004B92                 mov     ecx, [ebp+var_4]
.text:00004B95                 cmp     dword ptr [ecx+4], 0
.text:00004B99                 jz      short loc_4BB7
.text:00004B9B                 mov     edx, [ebp+var_4]
.text:00004B9E                 mov     eax, [edx+4]
.text:00004BA1                 shl     eax, 2
.text:00004BA4                 push    eax             ; Size
.text:00004BA5                 mov     ecx, [ebp+var_4]
.text:00004BA8                 mov     edx, [ecx]
.text:00004BAA                 push    edx             ; Src
.text:00004BAB                 mov     eax, [ebp+Dst]
.text:00004BAE                 push    eax             ; Dst
.text:00004BAF                 call    _memcpy
.text:00004BB4                 add     esp, 0Ch
.text:00004BB7
.text:00004BB7 loc_4BB7:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:00004BB7                 mov     ecx, [ebp+var_4]
.text:00004BBA                 mov     edx, [ecx]
.text:00004BBC                 mov     [ebp+var_14], edx
.text:00004BBF                 mov     eax, [ebp+var_14]
.text:00004BC2                 push    eax             ; void *
.text:00004BC3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00004BC8                 add     esp, 4
.text:00004BCB                 mov     ecx, [ebp+var_4]
.text:00004BCE                 mov     edx, [ebp+Dst]
.text:00004BD1                 mov     [ecx], edx
.text:00004BD3                 mov     eax, [ebp+var_4]
.text:00004BD6                 mov     ecx, [ebp+var_8]
.text:00004BD9                 mov     [eax+8], ecx
.text:00004BDC
.text:00004BDC loc_4BDC:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:00004BDC                 add     esp, 14h
.text:00004BDF                 cmp     ebp, esp
.text:00004BE1                 call    __RTC_CheckEsp
.text:00004BE6                 mov     esp, ebp
.text:00004BE8                 pop     ebp
.text:00004BE9                 retn
.text:00004BE9 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:00004BE9
.text:00004BE9 ; ---------------------------------------------------------------------------
.text:00004BEA                 align 4
.text:00004BEA _text           ends
.text:00004BEA
.text:00004BEC ; ===========================================================================
.text:00004BEC
.text:00004BEC ; Segment type: Pure code
.text:00004BEC ; Segment permissions: Read/Execute
.text:00004BEC _text           segment para public 'CODE' use32
.text:00004BEC                 assume cs:_text
.text:00004BEC                 ;org 4BECh
.text:00004BEC ; COMDAT (pick any)
.text:00004BEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004BEC
.text:00004BEC ; =============== S U B R O U T I N E =======================================
.text:00004BEC
.text:00004BEC ; Attributes: bp-based frame
.text:00004BEC
.text:00004BEC ; private: void __thiscall CRecordVector<unsigned __int64>::MoveItems(unsigned int, unsigned int)
.text:00004BEC                 public ?MoveItems@?$CRecordVector@_K@@AAEXII@Z
.text:00004BEC ?MoveItems@?$CRecordVector@_K@@AAEXII@Z proc near
.text:00004BEC                                         ; CODE XREF: CRecordVector<unsigned __int64>::Insert(uint,unsigned __int64)+24p
.text:00004BEC
.text:00004BEC var_4           = dword ptr -4
.text:00004BEC arg_0           = dword ptr  8
.text:00004BEC arg_4           = dword ptr  0Ch
.text:00004BEC
.text:00004BEC                 push    ebp
.text:00004BED                 mov     ebp, esp
.text:00004BEF                 push    ecx
.text:00004BF0                 push    esi
.text:00004BF1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004BF8                 mov     [ebp+var_4], ecx
.text:00004BFB                 mov     eax, [ebp+var_4]
.text:00004BFE                 mov     ecx, [eax+4]
.text:00004C01                 sub     ecx, [ebp+arg_4]
.text:00004C04                 shl     ecx, 3
.text:00004C07                 mov     esi, esp
.text:00004C09                 push    ecx             ; Size
.text:00004C0A                 mov     edx, [ebp+var_4]
.text:00004C0D                 mov     eax, [edx]
.text:00004C0F                 mov     ecx, [ebp+arg_4]
.text:00004C12                 lea     edx, [eax+ecx*8]
.text:00004C15                 push    edx             ; Src
.text:00004C16                 mov     eax, [ebp+var_4]
.text:00004C19                 mov     ecx, [eax]
.text:00004C1B                 mov     edx, [ebp+arg_0]
.text:00004C1E                 lea     eax, [ecx+edx*8]
.text:00004C21                 push    eax             ; Dst
.text:00004C22                 call    dword ptr ds:__imp__memmove
.text:00004C28                 add     esp, 0Ch
.text:00004C2B                 cmp     esi, esp
.text:00004C2D                 call    __RTC_CheckEsp
.text:00004C32                 pop     esi
.text:00004C33                 add     esp, 4
.text:00004C36                 cmp     ebp, esp
.text:00004C38                 call    __RTC_CheckEsp
.text:00004C3D                 mov     esp, ebp
.text:00004C3F                 pop     ebp
.text:00004C40                 retn    8
.text:00004C40 ?MoveItems@?$CRecordVector@_K@@AAEXII@Z endp
.text:00004C40
.text:00004C40 ; ---------------------------------------------------------------------------
.text:00004C43                 align 4
.text:00004C43 _text           ends
.text:00004C43
.text:00004C44 ; ===========================================================================
.text:00004C44
.text:00004C44 ; Segment type: Pure code
.text:00004C44 ; Segment permissions: Read/Execute
.text:00004C44 _text           segment para public 'CODE' use32
.text:00004C44                 assume cs:_text
.text:00004C44                 ;org 4C44h
.text:00004C44 ; COMDAT (pick any)
.text:00004C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004C44
.text:00004C44 ; =============== S U B R O U T I N E =======================================
.text:00004C44
.text:00004C44 ; Attributes: bp-based frame
.text:00004C44
.text:00004C44 ; private: void __thiscall CRecordVector<unsigned __int64>::ReserveOnePosition(void)
.text:00004C44                 public ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ
.text:00004C44 ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ proc near
.text:00004C44                                         ; CODE XREF: CRecordVector<unsigned __int64>::Insert(uint,unsigned __int64)+11p
.text:00004C44
.text:00004C44 var_14          = dword ptr -14h
.text:00004C44 var_10          = dword ptr -10h
.text:00004C44 Dst             = dword ptr -0Ch
.text:00004C44 var_8           = dword ptr -8
.text:00004C44 var_4           = dword ptr -4
.text:00004C44
.text:00004C44                 push    ebp
.text:00004C45                 mov     ebp, esp
.text:00004C47                 sub     esp, 14h
.text:00004C4A                 mov     eax, 0CCCCCCCCh
.text:00004C4F                 mov     [ebp+var_14], eax
.text:00004C52                 mov     [ebp+var_10], eax
.text:00004C55                 mov     [ebp+Dst], eax
.text:00004C58                 mov     [ebp+var_8], eax
.text:00004C5B                 mov     [ebp+var_4], eax
.text:00004C5E                 mov     [ebp+var_4], ecx
.text:00004C61                 mov     eax, [ebp+var_4]
.text:00004C64                 mov     ecx, [ebp+var_4]
.text:00004C67                 mov     edx, [eax+4]
.text:00004C6A                 cmp     edx, [ecx+8]
.text:00004C6D                 jnz     loc_4CF8
.text:00004C73                 mov     eax, [ebp+var_4]
.text:00004C76                 mov     ecx, [eax+8]
.text:00004C79                 shr     ecx, 2
.text:00004C7C                 mov     edx, [ebp+var_4]
.text:00004C7F                 mov     eax, [edx+8]
.text:00004C82                 lea     ecx, [eax+ecx+1]
.text:00004C86                 mov     [ebp+var_8], ecx
.text:00004C89                 xor     ecx, ecx
.text:00004C8B                 mov     eax, [ebp+var_8]
.text:00004C8E                 mov     edx, 8
.text:00004C93                 mul     edx
.text:00004C95                 seto    cl
.text:00004C98                 neg     ecx
.text:00004C9A                 or      ecx, eax
.text:00004C9C                 push    ecx             ; unsigned int
.text:00004C9D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00004CA2                 add     esp, 4
.text:00004CA5                 mov     [ebp+var_10], eax
.text:00004CA8                 mov     eax, [ebp+var_10]
.text:00004CAB                 mov     [ebp+Dst], eax
.text:00004CAE                 mov     ecx, [ebp+var_4]
.text:00004CB1                 cmp     dword ptr [ecx+4], 0
.text:00004CB5                 jz      short loc_4CD3
.text:00004CB7                 mov     edx, [ebp+var_4]
.text:00004CBA                 mov     eax, [edx+4]
.text:00004CBD                 shl     eax, 3
.text:00004CC0                 push    eax             ; Size
.text:00004CC1                 mov     ecx, [ebp+var_4]
.text:00004CC4                 mov     edx, [ecx]
.text:00004CC6                 push    edx             ; Src
.text:00004CC7                 mov     eax, [ebp+Dst]
.text:00004CCA                 push    eax             ; Dst
.text:00004CCB                 call    _memcpy
.text:00004CD0                 add     esp, 0Ch
.text:00004CD3
.text:00004CD3 loc_4CD3:                               ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+71j
.text:00004CD3                 mov     ecx, [ebp+var_4]
.text:00004CD6                 mov     edx, [ecx]
.text:00004CD8                 mov     [ebp+var_14], edx
.text:00004CDB                 mov     eax, [ebp+var_14]
.text:00004CDE                 push    eax             ; void *
.text:00004CDF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00004CE4                 add     esp, 4
.text:00004CE7                 mov     ecx, [ebp+var_4]
.text:00004CEA                 mov     edx, [ebp+Dst]
.text:00004CED                 mov     [ecx], edx
.text:00004CEF                 mov     eax, [ebp+var_4]
.text:00004CF2                 mov     ecx, [ebp+var_8]
.text:00004CF5                 mov     [eax+8], ecx
.text:00004CF8
.text:00004CF8 loc_4CF8:                               ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+29j
.text:00004CF8                 add     esp, 14h
.text:00004CFB                 cmp     ebp, esp
.text:00004CFD                 call    __RTC_CheckEsp
.text:00004D02                 mov     esp, ebp
.text:00004D04                 pop     ebp
.text:00004D05                 retn
.text:00004D05 ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ endp
.text:00004D05
.text:00004D05 ; ---------------------------------------------------------------------------
.text:00004D06                 align 4
.text:00004D06 _text           ends
.text:00004D06
.text:00004D08 ; ===========================================================================
.text:00004D08
.text:00004D08 ; Segment type: Pure code
.text:00004D08 ; Segment permissions: Read/Execute
.text:00004D08 _text           segment para public 'CODE' use32
.text:00004D08                 assume cs:_text
.text:00004D08                 ;org 4D08h
.text:00004D08 ; COMDAT (pick any)
.text:00004D08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004D08
.text:00004D08 ; =============== S U B R O U T I N E =======================================
.text:00004D08
.text:00004D08 ; Attributes: bp-based frame
.text:00004D08
.text:00004D08 ; public: long __thiscall CMyComPtr<struct IHasher>::QueryInterface<struct ICompressSetCoderProperties>(struct _GUID const &, struct ICompressSetCoderProperties * *)const
.text:00004D08                 public ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIHasher@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z
.text:00004D08 ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIHasher@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z proc near
.text:00004D08                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+456p
.text:00004D08
.text:00004D08 var_4           = dword ptr -4
.text:00004D08 arg_0           = dword ptr  8
.text:00004D08 arg_4           = dword ptr  0Ch
.text:00004D08
.text:00004D08                 push    ebp
.text:00004D09                 mov     ebp, esp
.text:00004D0B                 push    ecx
.text:00004D0C                 push    esi
.text:00004D0D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004D14                 mov     [ebp+var_4], ecx
.text:00004D17                 mov     esi, esp
.text:00004D19                 mov     eax, [ebp+arg_4]
.text:00004D1C                 push    eax
.text:00004D1D                 mov     ecx, [ebp+arg_0]
.text:00004D20                 push    ecx
.text:00004D21                 mov     edx, [ebp+var_4]
.text:00004D24                 mov     eax, [edx]
.text:00004D26                 mov     ecx, [ebp+var_4]
.text:00004D29                 mov     edx, [ecx]
.text:00004D2B                 mov     eax, [eax]
.text:00004D2D                 push    edx
.text:00004D2E                 mov     ecx, [eax]
.text:00004D30                 call    ecx
.text:00004D32                 cmp     esi, esp
.text:00004D34                 call    __RTC_CheckEsp
.text:00004D39                 pop     esi
.text:00004D3A                 add     esp, 4
.text:00004D3D                 cmp     ebp, esp
.text:00004D3F                 call    __RTC_CheckEsp
.text:00004D44                 mov     esp, ebp
.text:00004D46                 pop     ebp
.text:00004D47                 retn    8
.text:00004D47 ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIHasher@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z endp
.text:00004D47
.text:00004D47 _text           ends
.text:00004D47
UNDEF:00004D50 ; ===========================================================================
UNDEF:00004D50
UNDEF:00004D50 ; Segment type: Externs
UNDEF:00004D50 ; UNDEF
UNDEF:00004D50 ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:00004D50                 extrn _memset:near      ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+62Fp
UNDEF:00004D50                                         ; CHashBundle::InitForNewFile(void)+92p ...
UNDEF:00004D54 ; public: class AString & __thiscall AString::operator=(class AString const &)
UNDEF:00004D54                 extrn ??4AString@@QAEAAV0@ABV0@@Z:near
UNDEF:00004D54                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+5DAp
UNDEF:00004D58 ; __int32 __thiscall CProps::SetCoderProps(CProps *__hidden this, struct ICompressSetCoderProperties *, const unsigned __int64 *)
UNDEF:00004D58                 extrn ?SetCoderProps@CProps@@QBEJPAUICompressSetCoderProperties@@PB_K@Z:near
UNDEF:00004D58                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+482p
UNDEF:00004D5C                 extrn _IID_ICompressSetCoderProperties:near
UNDEF:00004D5C                                         ; DATA XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+44Bo
UNDEF:00004D60 ; long __stdcall CreateHasher(unsigned __int64, class AString &, class CMyComPtr<struct IHasher> &)
UNDEF:00004D60                 extrn ?CreateHasher@@YGJ_KAAVAString@@AAV?$CMyComPtr@UIHasher@@@@@Z:near
UNDEF:00004D60                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+381p
UNDEF:00004D64 ; public: __thiscall AString::AString(void)
UNDEF:00004D64                 extrn ??0AString@@QAE@XZ:near
UNDEF:00004D64                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+357p
UNDEF:00004D64                                         ; COneMethodInfo::COneMethodInfo(void)+42p ...
UNDEF:00004D68 ; bool __stdcall FindHashMethod(const struct AString *, unsigned __int64 *)
UNDEF:00004D68                 extrn ?FindHashMethod@@YG_NABVAString@@AA_K@Z:near
UNDEF:00004D68                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+26Cp
UNDEF:00004D6C ; void __stdcall GetHashMethods(class CRecordVector<unsigned __int64> &)
UNDEF:00004D6C                 extrn ?GetHashMethods@@YGXAAV?$CRecordVector@_K@@@Z:near
UNDEF:00004D6C                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+1A1p
UNDEF:00004D70 ; public: class AString & __thiscall AString::operator=(char const *)
UNDEF:00004D70                 extrn ??4AString@@QAEAAV0@PBD@Z:near
UNDEF:00004D70                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+16Dp
UNDEF:00004D70                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+1C2p
UNDEF:00004D74 ; __int32 __thiscall COneMethodInfo::ParseMethodFromString(COneMethodInfo *__hidden this, const struct UString *)
UNDEF:00004D74                 extrn ?ParseMethodFromString@COneMethodInfo@@QAEJABVUString@@@Z:near
UNDEF:00004D74                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+F3p
UNDEF:00004D78 ; void __thiscall UString::SetFromAscii(UString *__hidden this, const char *)
UNDEF:00004D78                 extrn ?SetFromAscii@UString@@QAEXPBD@Z:near
UNDEF:00004D78                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+79p
UNDEF:00004D7C ; public: __thiscall UString::UString(void)
UNDEF:00004D7C                 extrn ??0UString@@QAE@XZ:near
UNDEF:00004D7C                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+66p
UNDEF:00004D7C                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+15Ep ...
UNDEF:00004D80                 extrn ___security_cookie:near
UNDEF:00004D80                                         ; DATA XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+2Dr
UNDEF:00004D80                                         ; CHashBundle::Final(bool,bool,UString const &)+1Fr ...
UNDEF:00004D84                 extrn ___CxxFrameHandler3:near
UNDEF:00004D84                                         ; CODE XREF: __ehhandler$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z+19j
UNDEF:00004D84                                         ; __ehhandler$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z+19j ...
UNDEF:00004D88 ; __fastcall __security_check_cookie(x)
UNDEF:00004D88                 extrn @__security_check_cookie@4:near
UNDEF:00004D88                                         ; CODE XREF: CHashBundle::Final(bool,bool,UString const &)+30Cp
UNDEF:00004D88                                         ; __ehhandler$?SetMethods@CHashBundle@@QAEJABV?$CObjectVector@VUString@@@@@Z+Fp ...
UNDEF:00004D8C ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00004D8C                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00004D8C                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+69Dp
UNDEF:00004D8C                                         ; CHashBundle::Final(bool,bool,UString const &)+2FEp ...
UNDEF:00004D90                 extrn __RTC_CheckEsp:near
UNDEF:00004D90                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+539p
UNDEF:00004D90                                         ; CHashBundle::SetMethods(CObjectVector<UString> const &)+6B9p ...
UNDEF:00004D94                 extrn __RTC_Shutdown:near
UNDEF:00004D94                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00004D98                 extrn __RTC_InitBase:near
UNDEF:00004D98                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00004D9C ; __stdcall _CxxThrowException(x, x)
UNDEF:00004D9C                 extrn __CxxThrowException@8:near
UNDEF:00004D9C                                         ; CODE XREF: CHashBundle::SetMethods(CObjectVector<UString> const &)+419p
UNDEF:00004DA0 ; const type_info::`vftable'
UNDEF:00004DA0                 extrn ??_7type_info@@6B@:near
UNDEF:00004DA0                                         ; DATA XREF: .data:char * `RTTI Type Descriptor'o
UNDEF:00004DA0                                         ; .data:void * `RTTI Type Descriptor'o ...
UNDEF:00004DA4 ; void __cdecl operator delete(void *)
UNDEF:00004DA4                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$7+7p
UNDEF:00004DA4                                         ; __unwindfunclet$?HashCalc@@YGJABVCCensor@NWildcard@@ABUCHashOptions@@AAVAString@@PAUIHashCallbackUI@@@Z$8+7p ...
UNDEF:00004DA8 ; int __cdecl strcmp(const char *Str1, const char *Str2)
UNDEF:00004DA8                 extrn _strcmp:near      ; CODE XREF: operator==(AString const &,char const *)+10p
UNDEF:00004DAC ; DWORD __stdcall GetLastError()
UNDEF:00004DAC                 extrn __imp__GetLastError@0:near
UNDEF:00004DAC                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+6A7p
UNDEF:00004DAC                                         ; DATA XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+6A7r
UNDEF:00004DB0 ; struct UString __thiscall __high CDirItems::GetPhyPath(unsigned int)
UNDEF:00004DB0                 extrn ?GetPhyPath@CDirItems@@QBE?AVUString@@I@Z:near
UNDEF:00004DB0                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+672p
UNDEF:00004DB4 ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:00004DB4                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:00004DB4                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+63Bp
UNDEF:00004DB8 ; struct UString __thiscall __high CDirItems::GetLogPath(unsigned int)
UNDEF:00004DB8                 extrn ?GetLogPath@CDirItems@@QBE?AVUString@@I@Z:near
UNDEF:00004DB8                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+613p
UNDEF:00004DBC ; _DWORD __thiscall CInFileStream::CInFileStream(CInFileStream *__hidden this)
UNDEF:00004DBC                 extrn ??0CInFileStream@@QAE@XZ:near
UNDEF:00004DBC                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+582p
UNDEF:00004DC0 ; void *__cdecl operator new(unsigned int)
UNDEF:00004DC0                 extrn ??2@YAPAXI@Z:near ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+500p
UNDEF:00004DC0                                         ; HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+561p ...
UNDEF:00004DC4 ; __int32 __stdcall __high EnumerateItems(const struct NWildcard::CCensor *, enum NWildcard::ECensorPathMode, const struct UString *, struct CDirItems *)
UNDEF:00004DC4                 extrn ?EnumerateItems@@YGJABVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAVCDirItems@@@Z:near
UNDEF:00004DC4                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+18Bp
UNDEF:00004DC8 ; _DWORD __thiscall CDirItems::CDirItems(CDirItems *__hidden this)
UNDEF:00004DC8                 extrn ??0CDirItems@@QAE@XZ:near
UNDEF:00004DC8                                         ; CODE XREF: HashCalc(NWildcard::CCensor const &,CHashOptions const &,AString &,IHashCallbackUI *)+42p
UNDEF:00004DCC ; bool __thiscall NWindows::NFile::NIO::CInFile::OpenShared(NWindows::NFile::NIO::CInFile *__hidden this, const wchar_t *, bool)
UNDEF:00004DCC                 extrn ?OpenShared@CInFile@NIO@NFile@NWindows@@QAE_NPB_W_N@Z:near
UNDEF:00004DCC                                         ; CODE XREF: CInFileStream::OpenShared(wchar_t const *,bool)+1Dp
UNDEF:00004DD0 ; __stdcall MidAlloc(x)
UNDEF:00004DD0                 extrn _MidAlloc@4:near  ; CODE XREF: CHashMidBuf::Alloc(uint)+1Ep
UNDEF:00004DD4 ; __stdcall MidFree(x)
UNDEF:00004DD4                 extrn _MidFree@4:near   ; CODE XREF: CHashMidBuf::~CHashMidBuf(void)+14p
UNDEF:00004DD8 ; public: virtual long __stdcall CStdInFileStream::Read(void *, unsigned int, unsigned int *)
UNDEF:00004DD8                 extrn ?Read@CStdInFileStream@@UAGJPAXIPAI@Z:near
UNDEF:00004DD8                                         ; DATA XREF: .rdata:0000279Co
UNDEF:00004DDC ; public: virtual void * __thiscall CStdInFileStream::`scalar deleting destructor'(unsigned int)
UNDEF:00004DDC                 extrn ??_GCStdInFileStream@@UAEPAXI@Z_0:near
UNDEF:00004DE0 ; public: virtual void * __thiscall CStdInFileStream::`vector deleting destructor'(unsigned int)
UNDEF:00004DE0                 extrn ??_ECStdInFileStream@@UAEPAXI@Z:near ; weak
UNDEF:00004DE0                                         ; DATA XREF: .rdata:000027A0o
UNDEF:00004DE4 ; const IID IID_IUnknown
UNDEF:00004DE4                 extrn _IID_IUnknown:near
UNDEF:00004DE4                                         ; DATA XREF: CStdInFileStream::QueryInterface(_GUID const &,void * *)+Co
UNDEF:00004DE8 ; int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
UNDEF:00004DE8                 extrn _memcmp:near      ; CODE XREF: IsEqualGUID(x,x)+Dp
UNDEF:00004DEC                 extrn __purecall:near   ; DATA XREF: .rdata:const IHashCalc::`vftable'o
UNDEF:00004DEC                                         ; .rdata:00002BECo ...
UNDEF:00004DF0 ; public: __thiscall UString::UString(class UString const &)
UNDEF:00004DF0                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:00004DF0                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+A6p
UNDEF:00004DF0                                         ; CObjectVector<UString>::Add(UString const &)+5Ap ...
UNDEF:00004DF4 ; public: __thiscall AString::AString(class AString const &)
UNDEF:00004DF4                 extrn ??0AString@@QAE@ABV0@@Z:near
UNDEF:00004DF4                                         ; CODE XREF: COneMethodInfo::COneMethodInfo(COneMethodInfo const &)+4Dp
UNDEF:00004DF8 ; __int32 __thiscall NWindows::NCOM::CPropVariant::Clear(NWindows::NCOM::CPropVariant *__hidden this)
UNDEF:00004DF8                 extrn ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ:near
UNDEF:00004DF8                                         ; CODE XREF: NWindows::NCOM::CPropVariant::~CPropVariant(void)+11p
UNDEF:00004DFC ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00004DFC                 extrn _memcpy:near      ; CODE XREF: CBuffer<uchar>::CBuffer<uchar>(CBuffer<uchar> const &)+67p
UNDEF:00004DFC                                         ; CRecordVector<void *>::ReserveOnePosition(void)+87p ...
UNDEF:00004E00 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::CPropVariant(NWindows::NCOM::CPropVariant *__hidden this, const struct NWindows::NCOM::CPropVariant *)
UNDEF:00004E00                 extrn ??0CPropVariant@NCOM@NWindows@@QAE@ABV012@@Z:near
UNDEF:00004E00                                         ; CODE XREF: CProp::CProp(CProp const &)+31p
UNDEF:00004E04 ; void *__cdecl _memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00004E04                 extrn __imp__memmove:near
UNDEF:00004E04                                         ; CODE XREF: CRecordVector<void *>::MoveItems(uint,uint)+36p
UNDEF:00004E04                                         ; CRecordVector<unsigned __int64>::MoveItems(uint,uint)+36p
UNDEF:00004E04                                         ; DATA XREF: ...
UNDEF:00004E04
UNDEF:00004E04