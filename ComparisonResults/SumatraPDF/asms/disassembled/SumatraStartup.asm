.bss:00000000 ;
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.bss:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.bss:00000000 ; |                      License info: 48-3677-7074-51                      |
.bss:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ;
.bss:00000000 ; Input MD5   : 40EC182999AB39BD34434390B2AEE523
.bss:00000000 ; Input CRC32 : 4429E1CE
.bss:00000000
.bss:00000000 ; File Name   : C:\workspace\sumatrapdf-master\dbg\obj\x32\Debug\SumatraPDF\SumatraStartup.obj
.bss:00000000 ; Format      : COFF (X386MAGIC)
.bss:00000000 ; includelib "uuid.lib"
.bss:00000000 ; includelib "libcpmtd"
.bss:00000000 ; includelib "LIBCMTD"
.bss:00000000 ; includelib "OLDNAMES"
.bss:00000000
.bss:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.bss:00000000
.bss:00000000                 .686p
.bss:00000000                 .mmx
.bss:00000000                 .model flat
.bss:00000000
.bss:00000000 ; ===========================================================================
.bss:00000000
.bss:00000000 ; Segment type: Uninitialized
.bss:00000000 ; Segment permissions: Read/Write
.bss:00000000 _bss            segment dword public 'BSS' use32
.bss:00000000                 assume cs:_bss
.bss:00000000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00000000 ; class Gdiplus::FontFamily * Gdiplus::GenericSansSerifFontFamily
.bss:00000000 ?GenericSansSerifFontFamily@Gdiplus@@3PAVFontFamily@1@A db    ? ;
.bss:00000001 ; const WCHAR IconName
.bss:00000001 IconName        dw ?                    ; DATA XREF: RegisterWinClass(void)+36o
.bss:00000001                                         ; RegisterWinClass(void)+161o
.bss:00000003                 align 4
.bss:00000004 ; class Gdiplus::FontFamily * Gdiplus::GenericSerifFontFamily
.bss:00000004 ?GenericSerifFontFamily@Gdiplus@@3PAVFontFamily@1@A db    ? ;
.bss:00000005                 db    ? ;
.bss:00000006                 db    ? ;
.bss:00000007                 db    ? ;
.bss:00000008 ; class Gdiplus::FontFamily * Gdiplus::GenericMonospaceFontFamily
.bss:00000008 ?GenericMonospaceFontFamily@Gdiplus@@3PAVFontFamily@1@A db    ? ;
.bss:00000009                 db    ? ;
.bss:0000000A                 db    ? ;
.bss:0000000B                 db    ? ;
.bss:0000000C ; unsigned char * Gdiplus::GenericSansSerifFontFamilyBuffer
.bss:0000000C ?GenericSansSerifFontFamilyBuffer@Gdiplus@@3PAEA db    ? ;
.bss:0000000D                 db    ? ;
.bss:0000000E                 db    ? ;
.bss:0000000F                 db    ? ;
.bss:00000010                 db    ? ;
.bss:00000011                 db    ? ;
.bss:00000012                 db    ? ;
.bss:00000013                 db    ? ;
.bss:00000014 ; unsigned char * Gdiplus::GenericSerifFontFamilyBuffer
.bss:00000014 ?GenericSerifFontFamilyBuffer@Gdiplus@@3PAEA db    ? ;
.bss:00000015                 db    ? ;
.bss:00000016                 db    ? ;
.bss:00000017                 db    ? ;
.bss:00000018                 db    ? ;
.bss:00000019                 db    ? ;
.bss:0000001A                 db    ? ;
.bss:0000001B                 db    ? ;
.bss:0000001C ; unsigned char * Gdiplus::GenericMonospaceFontFamilyBuffer
.bss:0000001C ?GenericMonospaceFontFamilyBuffer@Gdiplus@@3PAEA db    ? ;
.bss:0000001D                 db    ? ;
.bss:0000001E                 db    ? ;
.bss:0000001F                 db    ? ;
.bss:00000020                 db    ? ;
.bss:00000021                 db    ? ;
.bss:00000022                 db    ? ;
.bss:00000023 ; wchar_t unk_23
.bss:00000023 unk_23          db    ? ;               ; DATA XREF: SetupPluginMode(CommandLineInfo &)+174o
.bss:00000023                                         ; SetupPluginMode(CommandLineInfo &)+195o ...
.bss:00000024 ; ThreadBase *gFileExistenceChecker
.bss:00000024 ?gFileExistenceChecker@@3PAVFileExistenceChecker@@A dd ?
.bss:00000024                                         ; DATA XREF: FileExistenceChecker::Terminate(void)+23w
.bss:00000024                                         ; WinMain(x,x,x,x)+A5Ew ...
.bss:00000028 ; unsigned char * Gdiplus::GenericTypographicStringFormatBuffer
.bss:00000028 ?GenericTypographicStringFormatBuffer@Gdiplus@@3PAEA db    ? ;
.bss:00000029                 db    ? ;
.bss:0000002A                 db    ? ;
.bss:0000002B                 db    ? ;
.bss:0000002C                 db    ? ;
.bss:0000002D                 db    ? ;
.bss:0000002E                 db    ? ;
.bss:0000002F                 db    ? ;
.bss:00000030 ; unsigned char * Gdiplus::GenericDefaultStringFormatBuffer
.bss:00000030 ?GenericDefaultStringFormatBuffer@Gdiplus@@3PAEA db    ? ;
.bss:00000030                                         ; DATA XREF: .text$mn:00004EA4o
.bss:00000031                 db    ? ;
.bss:00000032                 db    ? ;
.bss:00000033                 db    ? ;
.bss:00000034                 db    ? ;
.bss:00000035                 db    ? ;
.bss:00000036                 db    ? ;
.bss:00000037                 db    ? ;
.bss:00000037 _bss            ends
.bss:00000037
.text$mn:00000038 ; ===========================================================================
.text$mn:00000038
.text$mn:00000038 ; Segment type: Pure code
.text$mn:00000038 ; Segment permissions: Read/Execute
.text$mn:00000038 _text$mn        segment para public 'CODE' use32
.text$mn:00000038                 assume cs:_text$mn
.text$mn:00000038                 ;org 38h
.text$mn:00000038                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000038
.text$mn:00000038 ; =============== S U B R O U T I N E =======================================
.text$mn:00000038
.text$mn:00000038 ; Attributes: bp-based frame
.text$mn:00000038
.text$mn:00000038                 public ??$?0ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000038 ??$?0ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z proc near
.text$mn:00000038                                         ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+60p
.text$mn:00000038
.text$mn:00000038 var_D8          = byte ptr -0D8h
.text$mn:00000038 var_D1          = byte ptr -0D1h
.text$mn:00000038 var_8           = dword ptr -8
.text$mn:00000038 arg_0           = dword ptr  8
.text$mn:00000038 arg_4           = dword ptr  0Ch
.text$mn:00000038
.text$mn:00000038                 push    ebp
.text$mn:00000039                 mov     ebp, esp
.text$mn:0000003B                 sub     esp, 0D8h       ; DATA XREF: SetupPluginMode(CommandLineInfo &):loc_5AECo
.text$mn:00000041                 push    ebx
.text$mn:00000042                 push    esi
.text$mn:00000043                 push    edi
.text$mn:00000044                 push    ecx
.text$mn:00000045                 lea     edi, [ebp+var_D8]
.text$mn:0000004B                 mov     ecx, 36h ; '6'
.text$mn:00000050                 mov     eax, 0CCCCCCCCh
.text$mn:00000055                 rep stosd
.text$mn:00000057                 pop     ecx
.text$mn:00000058                 mov     [ebp+var_8], ecx
.text$mn:0000005B                 mov     ecx, [ebp+var_8]
.text$mn:0000005E                 call    ??0?$_Func_base@X$$V@std@@QAE@XZ
.text$mn:00000063                 mov     eax, [ebp+var_8]
.text$mn:00000066                 mov     dword ptr [eax], offset ??_7?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@6B@
.text$mn:0000006C                 mov     eax, [ebp+arg_0]
.text$mn:0000006F                 push    eax
.text$mn:00000070                 call    ??$forward@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:00000075                 add     esp, 4
.text$mn:00000078                 push    eax
.text$mn:00000079                 mov     ecx, [ebp+arg_4]
.text$mn:0000007C                 push    ecx
.text$mn:0000007D                 call    ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>(std::allocator<int> const &)
.text$mn:00000082                 add     esp, 4          ; DATA XREF: InstanceInit(int)+20o
.text$mn:00000085                 push    eax
.text$mn:00000086                 movzx   edx, [ebp+var_D1]
.text$mn:0000008D                 push    edx
.text$mn:0000008E                 mov     ecx, [ebp+var_8]
.text$mn:00000091                 add     ecx, 4
.text$mn:00000094                 call    ??$?0ABV?$allocator@H@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>(std::_One_then_variadic_args_t,std::allocator<int> const &,_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:00000099                 mov     eax, [ebp+var_8]
.text$mn:0000009C                 pop     edi
.text$mn:0000009D                 pop     esi
.text$mn:0000009E                 pop     ebx
.text$mn:0000009F                 add     esp, 0D8h
.text$mn:000000A5                 cmp     ebp, esp
.text$mn:000000A7                 call    __RTC_CheckEsp
.text$mn:000000AC                 mov     esp, ebp
.text$mn:000000AE                 pop     ebp
.text$mn:000000AF                 retn    8
.text$mn:000000AF ??$?0ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z endp
.text$mn:000000AF
.text$mn:000000AF ; ---------------------------------------------------------------------------
.text$mn:000000B2                 align 4
.text$mn:000000B2 _text$mn        ends
.text$mn:000000B2
.text$mn:000000B4 ; ===========================================================================
.text$mn:000000B4
.text$mn:000000B4 ; Segment type: Pure code
.text$mn:000000B4 ; Segment permissions: Read/Execute
.text$mn:000000B4 _text$mn        segment para public 'CODE' use32
.text$mn:000000B4                 assume cs:_text$mn
.text$mn:000000B4                 ;org 0B4h
.text$mn:000000B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000000B4
.text$mn:000000B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000000B4
.text$mn:000000B4 ; Attributes: bp-based frame
.text$mn:000000B4
.text$mn:000000B4 ; public: __thiscall std::_Compressed_pair<class std::allocator<int>, class _lambda_b6f3cb1c717d8c8a816f87295491882e_, 1>::_Compressed_pair<class std::allocator<int>, class _lambda_b6f3cb1c717d8c8a816f87295491882e_, 1>(struct std::_One_then_variadic_args_t, class std::allocator<int> const &, class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:000000B4                 public ??$?0ABV?$allocator@H@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:000000B4 ??$?0ABV?$allocator@H@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z proc near
.text$mn:000000B4                                         ; CODE XREF: ??$?0ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+5Cp
.text$mn:000000B4
.text$mn:000000B4 var_CC          = byte ptr -0CCh
.text$mn:000000B4 var_8           = dword ptr -8
.text$mn:000000B4 arg_4           = dword ptr  0Ch
.text$mn:000000B4 arg_8           = dword ptr  10h
.text$mn:000000B4
.text$mn:000000B4                 push    ebp
.text$mn:000000B5                 mov     ebp, esp
.text$mn:000000B7                 sub     esp, 0CCh
.text$mn:000000BD                 push    ebx
.text$mn:000000BE                 push    esi
.text$mn:000000BF                 push    edi
.text$mn:000000C0                 push    ecx
.text$mn:000000C1                 lea     edi, [ebp+var_CC]
.text$mn:000000C7                 mov     ecx, 33h ; '3'
.text$mn:000000CC                 mov     eax, 0CCCCCCCCh
.text$mn:000000D1                 rep stosd
.text$mn:000000D3                 pop     ecx
.text$mn:000000D4                 mov     [ebp+var_8], ecx
.text$mn:000000D7                 mov     eax, [ebp+arg_4]
.text$mn:000000DA                 push    eax
.text$mn:000000DB                 call    ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>(std::allocator<int> const &)
.text$mn:000000E0                 add     esp, 4
.text$mn:000000E3                 push    eax
.text$mn:000000E4                 mov     ecx, [ebp+var_8]
.text$mn:000000E7                 call    ??0?$allocator@H@std@@QAE@ABV01@@Z ; std::allocator<int>::allocator<int>(std::allocator<int> const &)
.text$mn:000000EC                 mov     eax, [ebp+arg_8]
.text$mn:000000EF                 push    eax
.text$mn:000000F0                 call    ??$forward@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:000000F5                 add     esp, 4
.text$mn:000000F8                 mov     ecx, [eax]
.text$mn:000000FA                 mov     edx, [ebp+var_8]
.text$mn:000000FD                 mov     [edx], ecx
.text$mn:000000FF                 mov     eax, [ebp+var_8]
.text$mn:00000102                 pop     edi
.text$mn:00000103                 pop     esi
.text$mn:00000104                 pop     ebx
.text$mn:00000105                 add     esp, 0CCh
.text$mn:0000010B                 cmp     ebp, esp
.text$mn:0000010D                 call    __RTC_CheckEsp
.text$mn:00000112                 mov     esp, ebp
.text$mn:00000114                 pop     ebp
.text$mn:00000115                 retn    0Ch
.text$mn:00000115 ??$?0ABV?$allocator@H@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z endp
.text$mn:00000115
.text$mn:00000115 _text$mn        ends
.text$mn:00000115
.text$mn:00000118 ; ===========================================================================
.text$mn:00000118
.text$mn:00000118 ; Segment type: Pure code
.text$mn:00000118 ; Segment permissions: Read/Execute
.text$mn:00000118 _text$mn        segment para public 'CODE' use32
.text$mn:00000118                 assume cs:_text$mn
.text$mn:00000118                 ;org 118h
.text$mn:00000118                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000118
.text$mn:00000118 ; =============== S U B R O U T I N E =======================================
.text$mn:00000118
.text$mn:00000118 ; Attributes: bp-based frame
.text$mn:00000118
.text$mn:00000118 ; public: __thiscall std::_Compressed_pair<class std::allocator<int>, class _lambda_b6f3cb1c717d8c8a816f87295491882e_, 1>::_Compressed_pair<class std::allocator<int>, class _lambda_b6f3cb1c717d8c8a816f87295491882e_, 1>(struct std::_One_then_variadic_args_t, class std::allocator<int> const &, class _lambda_b6f3cb1c717d8c8a816f87295491882e_ &&)
.text$mn:00000118                 public ??$?0ABV?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:00000118 ??$?0ABV?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z proc near
.text$mn:00000118                                         ; CODE XREF: ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+5Cp
.text$mn:00000118
.text$mn:00000118 var_CC          = byte ptr -0CCh
.text$mn:00000118 var_8           = dword ptr -8
.text$mn:00000118 arg_4           = dword ptr  0Ch
.text$mn:00000118 arg_8           = dword ptr  10h
.text$mn:00000118
.text$mn:00000118                 push    ebp
.text$mn:00000119                 mov     ebp, esp
.text$mn:0000011B                 sub     esp, 0CCh
.text$mn:00000121                 push    ebx
.text$mn:00000122                 push    esi
.text$mn:00000123                 push    edi
.text$mn:00000124                 push    ecx
.text$mn:00000125                 lea     edi, [ebp+var_CC]
.text$mn:0000012B                 mov     ecx, 33h ; '3'
.text$mn:00000130                 mov     eax, 0CCCCCCCCh
.text$mn:00000135                 rep stosd
.text$mn:00000137                 pop     ecx
.text$mn:00000138                 mov     [ebp+var_8], ecx
.text$mn:0000013B                 mov     eax, [ebp+arg_4]
.text$mn:0000013E                 push    eax
.text$mn:0000013F                 call    ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>(std::allocator<int> const &)
.text$mn:00000144                 add     esp, 4
.text$mn:00000147                 push    eax
.text$mn:00000148                 mov     ecx, [ebp+var_8]
.text$mn:0000014B                 call    ??0?$allocator@H@std@@QAE@ABV01@@Z ; std::allocator<int>::allocator<int>(std::allocator<int> const &)
.text$mn:00000150                 mov     eax, [ebp+arg_8]
.text$mn:00000153                 push    eax
.text$mn:00000154                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00000159                 add     esp, 4
.text$mn:0000015C                 mov     ecx, [eax]
.text$mn:0000015E                 mov     edx, [ebp+var_8]
.text$mn:00000161                 mov     [edx], ecx
.text$mn:00000163                 mov     eax, [ebp+var_8]
.text$mn:00000166                 pop     edi
.text$mn:00000167                 pop     esi
.text$mn:00000168                 pop     ebx
.text$mn:00000169                 add     esp, 0CCh
.text$mn:0000016F                 cmp     ebp, esp
.text$mn:00000171                 call    __RTC_CheckEsp
.text$mn:00000176                 mov     esp, ebp
.text$mn:00000178                 pop     ebp
.text$mn:00000179                 retn    0Ch
.text$mn:00000179 ??$?0ABV?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z endp
.text$mn:00000179
.text$mn:00000179 _text$mn        ends
.text$mn:00000179
.text$mn:0000017C ; ===========================================================================
.text$mn:0000017C
.text$mn:0000017C ; Segment type: Pure code
.text$mn:0000017C ; Segment permissions: Read/Execute
.text$mn:0000017C _text$mn        segment para public 'CODE' use32
.text$mn:0000017C                 assume cs:_text$mn
.text$mn:0000017C                 ;org 17Ch
.text$mn:0000017C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000017C
.text$mn:0000017C ; =============== S U B R O U T I N E =======================================
.text$mn:0000017C
.text$mn:0000017C ; Attributes: bp-based frame
.text$mn:0000017C
.text$mn:0000017C                 public ??$?0H@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:0000017C ??$?0H@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAE@ABV?$allocator@H@1@@Z proc near
.text$mn:0000017C                                         ; CODE XREF: ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@AAV?$allocator@H@1@@Z+2Ap
.text$mn:0000017C                                         ; ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z+2Ap
.text$mn:0000017C
.text$mn:0000017C var_CC          = byte ptr -0CCh
.text$mn:0000017C var_8           = dword ptr -8
.text$mn:0000017C
.text$mn:0000017C                 push    ebp
.text$mn:0000017D                 mov     ebp, esp
.text$mn:0000017F                 sub     esp, 0CCh
.text$mn:00000185                 push    ebx
.text$mn:00000186                 push    esi
.text$mn:00000187                 push    edi
.text$mn:00000188                 push    ecx
.text$mn:00000189                 lea     edi, [ebp+var_CC]
.text$mn:0000018F                 mov     ecx, 33h ; '3'
.text$mn:00000194                 mov     eax, 0CCCCCCCCh
.text$mn:00000199                 rep stosd
.text$mn:0000019B                 pop     ecx
.text$mn:0000019C                 mov     [ebp+var_8], ecx
.text$mn:0000019F                 mov     eax, [ebp+var_8]
.text$mn:000001A2                 pop     edi
.text$mn:000001A3                 pop     esi
.text$mn:000001A4                 pop     ebx
.text$mn:000001A5                 mov     esp, ebp
.text$mn:000001A7                 pop     ebp
.text$mn:000001A8                 retn    4
.text$mn:000001A8 ??$?0H@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAE@ABV?$allocator@H@1@@Z endp
.text$mn:000001A8
.text$mn:000001A8 ; ---------------------------------------------------------------------------
.text$mn:000001AB                 align 4
.text$mn:000001AB _text$mn        ends
.text$mn:000001AB
.text$mn:000001AC ; ===========================================================================
.text$mn:000001AC
.text$mn:000001AC ; Segment type: Pure code
.text$mn:000001AC ; Segment permissions: Read/Execute
.text$mn:000001AC _text$mn        segment para public 'CODE' use32
.text$mn:000001AC                 assume cs:_text$mn
.text$mn:000001AC                 ;org 1ACh
.text$mn:000001AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000001AC
.text$mn:000001AC ; =============== S U B R O U T I N E =======================================
.text$mn:000001AC
.text$mn:000001AC ; Attributes: bp-based frame
.text$mn:000001AC
.text$mn:000001AC ; public: __thiscall std::function<void __cdecl (void)>::function<void __cdecl (void)>(class _lambda_b6f3cb1c717d8c8a816f87295491882e_)
.text$mn:000001AC                 public ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$function@$$A6AXXZ@std@@QAE@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:000001AC ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$function@$$A6AXXZ@std@@QAE@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z proc near
.text$mn:000001AC                                         ; CODE XREF: FileExistenceChecker::Run(void)+DBp
.text$mn:000001AC
.text$mn:000001AC var_CC          = byte ptr -0CCh
.text$mn:000001AC var_8           = dword ptr -8
.text$mn:000001AC arg_0           = byte ptr  8
.text$mn:000001AC
.text$mn:000001AC                 push    ebp
.text$mn:000001AD                 mov     ebp, esp
.text$mn:000001AF                 sub     esp, 0CCh
.text$mn:000001B5                 push    ebx
.text$mn:000001B6                 push    esi
.text$mn:000001B7                 push    edi
.text$mn:000001B8                 push    ecx
.text$mn:000001B9                 lea     edi, [ebp+var_CC]
.text$mn:000001BF                 mov     ecx, 33h ; '3'
.text$mn:000001C4                 mov     eax, 0CCCCCCCCh
.text$mn:000001C9                 rep stosd
.text$mn:000001CB                 pop     ecx
.text$mn:000001CC                 mov     [ebp+var_8], ecx
.text$mn:000001CF                 mov     ecx, [ebp+var_8]
.text$mn:000001D2                 call    ??0?$_Func_class@X$$V@std@@QAE@XZ
.text$mn:000001D7                 lea     eax, [ebp+arg_0]
.text$mn:000001DA                 push    eax
.text$mn:000001DB                 call    ??$move@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::move<_lambda_b6f3cb1c717d8c8a816f87295491882e_ &>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:000001E0                 add     esp, 4
.text$mn:000001E3                 push    eax
.text$mn:000001E4                 mov     ecx, [ebp+var_8]
.text$mn:000001E7                 call    ??$_Reset@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:000001EC                 mov     eax, [ebp+var_8]
.text$mn:000001EF                 pop     edi
.text$mn:000001F0                 pop     esi
.text$mn:000001F1                 pop     ebx
.text$mn:000001F2                 add     esp, 0CCh
.text$mn:000001F8                 cmp     ebp, esp
.text$mn:000001FA                 call    __RTC_CheckEsp
.text$mn:000001FF                 mov     esp, ebp
.text$mn:00000201                 pop     ebp
.text$mn:00000202                 retn    4
.text$mn:00000202 ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$function@$$A6AXXZ@std@@QAE@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z endp
.text$mn:00000202
.text$mn:00000202 ; ---------------------------------------------------------------------------
.text$mn:00000205                 align 4
.text$mn:00000205 _text$mn        ends
.text$mn:00000205
.text$mn:00000208 ; ===========================================================================
.text$mn:00000208
.text$mn:00000208 ; Segment type: Pure code
.text$mn:00000208 ; Segment permissions: Read/Execute
.text$mn:00000208 _text$mn        segment para public 'CODE' use32
.text$mn:00000208                 assume cs:_text$mn
.text$mn:00000208                 ;org 208h
.text$mn:00000208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000208
.text$mn:00000208 ; =============== S U B R O U T I N E =======================================
.text$mn:00000208
.text$mn:00000208 ; Attributes: bp-based frame
.text$mn:00000208
.text$mn:00000208                 public ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000208 ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z proc near
.text$mn:00000208                                         ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+60p
.text$mn:00000208
.text$mn:00000208 var_D8          = byte ptr -0D8h
.text$mn:00000208 var_D1          = byte ptr -0D1h
.text$mn:00000208 var_8           = dword ptr -8
.text$mn:00000208 arg_0           = dword ptr  8
.text$mn:00000208 arg_4           = dword ptr  0Ch
.text$mn:00000208
.text$mn:00000208                 push    ebp
.text$mn:00000209                 mov     ebp, esp
.text$mn:0000020B                 sub     esp, 0D8h
.text$mn:00000211                 push    ebx
.text$mn:00000212                 push    esi
.text$mn:00000213                 push    edi
.text$mn:00000214                 push    ecx
.text$mn:00000215                 lea     edi, [ebp+var_D8]
.text$mn:0000021B                 mov     ecx, 36h ; '6'
.text$mn:00000220                 mov     eax, 0CCCCCCCCh
.text$mn:00000225                 rep stosd
.text$mn:00000227                 pop     ecx
.text$mn:00000228                 mov     [ebp+var_8], ecx
.text$mn:0000022B                 mov     ecx, [ebp+var_8]
.text$mn:0000022E                 call    ??0?$_Func_base@X$$V@std@@QAE@XZ
.text$mn:00000233                 mov     eax, [ebp+var_8]
.text$mn:00000236                 mov     dword ptr [eax], offset ??_7?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@6B@
.text$mn:0000023C                 mov     eax, [ebp+arg_0]
.text$mn:0000023F                 push    eax
.text$mn:00000240                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00000245                 add     esp, 4
.text$mn:00000248                 push    eax
.text$mn:00000249                 mov     ecx, [ebp+arg_4]
.text$mn:0000024C                 push    ecx
.text$mn:0000024D                 call    ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>(std::allocator<int> const &)
.text$mn:00000252                 add     esp, 4
.text$mn:00000255                 push    eax
.text$mn:00000256                 movzx   edx, [ebp+var_D1]
.text$mn:0000025D                 push    edx
.text$mn:0000025E                 mov     ecx, [ebp+var_8]
.text$mn:00000261                 add     ecx, 4
.text$mn:00000264                 call    ??$?0ABV?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>(std::_One_then_variadic_args_t,std::allocator<int> const &,_lambda_b6f3cb1c717d8c8a816f87295491882e_ &&)
.text$mn:00000269                 mov     eax, [ebp+var_8]
.text$mn:0000026C                 pop     edi
.text$mn:0000026D                 pop     esi
.text$mn:0000026E                 pop     ebx
.text$mn:0000026F                 add     esp, 0D8h
.text$mn:00000275                 cmp     ebp, esp
.text$mn:00000277                 call    __RTC_CheckEsp
.text$mn:0000027C                 mov     esp, ebp
.text$mn:0000027E                 pop     ebp
.text$mn:0000027F                 retn    8
.text$mn:0000027F ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z endp
.text$mn:0000027F
.text$mn:0000027F ; ---------------------------------------------------------------------------
.text$mn:00000282                 align 4
.text$mn:00000282 _text$mn        ends
.text$mn:00000282
.text$mn:00000284 ; ===========================================================================
.text$mn:00000284
.text$mn:00000284 ; Segment type: Pure code
.text$mn:00000284 ; Segment permissions: Read/Execute
.text$mn:00000284 _text$mn        segment para public 'CODE' use32
.text$mn:00000284                 assume cs:_text$mn
.text$mn:00000284                 ;org 284h
.text$mn:00000284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000284
.text$mn:00000284 ; =============== S U B R O U T I N E =======================================
.text$mn:00000284
.text$mn:00000284 ; Attributes: bp-based frame
.text$mn:00000284
.text$mn:00000284                 public ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z
.text$mn:00000284 ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z proc near
.text$mn:00000284                                         ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z+60p
.text$mn:00000284
.text$mn:00000284 var_D8          = byte ptr -0D8h
.text$mn:00000284 var_D1          = byte ptr -0D1h
.text$mn:00000284 var_8           = dword ptr -8
.text$mn:00000284 arg_0           = dword ptr  8
.text$mn:00000284 arg_4           = dword ptr  0Ch
.text$mn:00000284
.text$mn:00000284                 push    ebp
.text$mn:00000285                 mov     ebp, esp
.text$mn:00000287                 sub     esp, 0D8h
.text$mn:0000028D                 push    ebx
.text$mn:0000028E                 push    esi
.text$mn:0000028F                 push    edi
.text$mn:00000290                 push    ecx
.text$mn:00000291                 lea     edi, [ebp+var_D8]
.text$mn:00000297                 mov     ecx, 36h ; '6'
.text$mn:0000029C                 mov     eax, 0CCCCCCCCh
.text$mn:000002A1                 rep stosd
.text$mn:000002A3                 pop     ecx
.text$mn:000002A4                 mov     [ebp+var_8], ecx
.text$mn:000002A7                 mov     ecx, [ebp+var_8]
.text$mn:000002AA                 call    ??0?$_Func_base@X$$V@std@@QAE@XZ
.text$mn:000002AF                 mov     eax, [ebp+var_8]
.text$mn:000002B2                 mov     dword ptr [eax], offset ??_7?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@6B@
.text$mn:000002B8                 mov     eax, [ebp+arg_0]
.text$mn:000002BB                 push    eax
.text$mn:000002BC                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:000002C1                 add     esp, 4
.text$mn:000002C4                 push    eax
.text$mn:000002C5                 mov     ecx, [ebp+arg_4]
.text$mn:000002C8                 push    ecx
.text$mn:000002C9                 call    ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int>>(std::allocator<int> &)
.text$mn:000002CE                 add     esp, 4
.text$mn:000002D1                 push    eax
.text$mn:000002D2                 movzx   edx, [ebp+var_D1]
.text$mn:000002D9                 push    edx
.text$mn:000002DA                 mov     ecx, [ebp+var_8]
.text$mn:000002DD                 add     ecx, 4
.text$mn:000002E0                 call    ??$?0V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>(std::_One_then_variadic_args_t,std::allocator<int> &&,_lambda_b6f3cb1c717d8c8a816f87295491882e_ &&)
.text$mn:000002E5                 mov     eax, [ebp+var_8]
.text$mn:000002E8                 pop     edi
.text$mn:000002E9                 pop     esi
.text$mn:000002EA                 pop     ebx
.text$mn:000002EB                 add     esp, 0D8h
.text$mn:000002F1                 cmp     ebp, esp
.text$mn:000002F3                 call    __RTC_CheckEsp
.text$mn:000002F8                 mov     esp, ebp
.text$mn:000002FA                 pop     ebp
.text$mn:000002FB                 retn    8
.text$mn:000002FB ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z endp
.text$mn:000002FB
.text$mn:000002FB ; ---------------------------------------------------------------------------
.text$mn:000002FE                 align 10h
.text$mn:000002FE _text$mn        ends
.text$mn:000002FE
.text$mn:00000300 ; ===========================================================================
.text$mn:00000300
.text$mn:00000300 ; Segment type: Pure code
.text$mn:00000300 ; Segment permissions: Read/Execute
.text$mn:00000300 _text$mn        segment para public 'CODE' use32
.text$mn:00000300                 assume cs:_text$mn
.text$mn:00000300                 ;org 300h
.text$mn:00000300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000300
.text$mn:00000300 ; =============== S U B R O U T I N E =======================================
.text$mn:00000300
.text$mn:00000300 ; Attributes: bp-based frame
.text$mn:00000300
.text$mn:00000300                 public ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@AAV?$allocator@H@1@@Z
.text$mn:00000300 ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@AAV?$allocator@H@1@@Z proc near
.text$mn:00000300                                         ; CODE XREF: ?_Delete_this@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEX_N@Z+2Fp
.text$mn:00000300                                         ; ?_Move@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEPAV?$_Func_base@X$$V@2@PAX@Z+2Fp
.text$mn:00000300
.text$mn:00000300 var_CC          = byte ptr -0CCh
.text$mn:00000300 var_8           = dword ptr -8
.text$mn:00000300 arg_0           = dword ptr  8
.text$mn:00000300
.text$mn:00000300                 push    ebp
.text$mn:00000301                 mov     ebp, esp
.text$mn:00000303                 sub     esp, 0CCh
.text$mn:00000309                 push    ebx
.text$mn:0000030A                 push    esi
.text$mn:0000030B                 push    edi
.text$mn:0000030C                 push    ecx
.text$mn:0000030D                 lea     edi, [ebp+var_CC]
.text$mn:00000313                 mov     ecx, 33h ; '3'
.text$mn:00000318                 mov     eax, 0CCCCCCCCh
.text$mn:0000031D                 rep stosd
.text$mn:0000031F                 pop     ecx
.text$mn:00000320                 mov     [ebp+var_8], ecx
.text$mn:00000323                 mov     eax, [ebp+arg_0]
.text$mn:00000326                 push    eax
.text$mn:00000327                 mov     ecx, [ebp+var_8]
.text$mn:0000032A                 call    ??$?0H@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:0000032F                 mov     eax, [ebp+var_8]
.text$mn:00000332                 pop     edi
.text$mn:00000333                 pop     esi
.text$mn:00000334                 pop     ebx
.text$mn:00000335                 add     esp, 0CCh
.text$mn:0000033B                 cmp     ebp, esp
.text$mn:0000033D                 call    __RTC_CheckEsp
.text$mn:00000342                 mov     esp, ebp
.text$mn:00000344                 pop     ebp
.text$mn:00000345                 retn    4
.text$mn:00000345 ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@AAV?$allocator@H@1@@Z endp
.text$mn:00000345
.text$mn:00000345 _text$mn        ends
.text$mn:00000345
.text$mn:00000348 ; ===========================================================================
.text$mn:00000348
.text$mn:00000348 ; Segment type: Pure code
.text$mn:00000348 ; Segment permissions: Read/Execute
.text$mn:00000348 _text$mn        segment para public 'CODE' use32
.text$mn:00000348                 assume cs:_text$mn
.text$mn:00000348                 ;org 348h
.text$mn:00000348                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000348
.text$mn:00000348 ; =============== S U B R O U T I N E =======================================
.text$mn:00000348
.text$mn:00000348 ; Attributes: bp-based frame
.text$mn:00000348
.text$mn:00000348                 public ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:00000348 ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z proc near
.text$mn:00000348                                         ; CODE XREF: ??$_Clone@X@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEPAV?$_Func_base@X$$V@1@PAXU?$integral_constant@_N$0A@@1@@Z+2Fp
.text$mn:00000348                                         ; ??$_Reset_alloc@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+46p
.text$mn:00000348
.text$mn:00000348 var_CC          = byte ptr -0CCh
.text$mn:00000348 var_8           = dword ptr -8
.text$mn:00000348 arg_0           = dword ptr  8
.text$mn:00000348
.text$mn:00000348                 push    ebp
.text$mn:00000349                 mov     ebp, esp
.text$mn:0000034B                 sub     esp, 0CCh
.text$mn:00000351                 push    ebx
.text$mn:00000352                 push    esi
.text$mn:00000353                 push    edi
.text$mn:00000354                 push    ecx
.text$mn:00000355                 lea     edi, [ebp+var_CC]
.text$mn:0000035B                 mov     ecx, 33h ; '3'
.text$mn:00000360                 mov     eax, 0CCCCCCCCh
.text$mn:00000365                 rep stosd
.text$mn:00000367                 pop     ecx
.text$mn:00000368                 mov     [ebp+var_8], ecx
.text$mn:0000036B                 mov     eax, [ebp+arg_0]
.text$mn:0000036E                 push    eax
.text$mn:0000036F                 mov     ecx, [ebp+var_8]
.text$mn:00000372                 call    ??$?0H@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:00000377                 mov     eax, [ebp+var_8]
.text$mn:0000037A                 pop     edi
.text$mn:0000037B                 pop     esi
.text$mn:0000037C                 pop     ebx
.text$mn:0000037D                 add     esp, 0CCh
.text$mn:00000383                 cmp     ebp, esp
.text$mn:00000385                 call    __RTC_CheckEsp
.text$mn:0000038A                 mov     esp, ebp
.text$mn:0000038C                 pop     ebp
.text$mn:0000038D                 retn    4
.text$mn:0000038D ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z endp
.text$mn:0000038D
.text$mn:0000038D _text$mn        ends
.text$mn:0000038D
.text$mn:00000390 ; ===========================================================================
.text$mn:00000390
.text$mn:00000390 ; Segment type: Pure code
.text$mn:00000390 ; Segment permissions: Read/Execute
.text$mn:00000390 _text$mn        segment para public 'CODE' use32
.text$mn:00000390                 assume cs:_text$mn
.text$mn:00000390                 ;org 390h
.text$mn:00000390                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000390
.text$mn:00000390 ; =============== S U B R O U T I N E =======================================
.text$mn:00000390
.text$mn:00000390 ; Attributes: bp-based frame
.text$mn:00000390
.text$mn:00000390 ; public: __thiscall std::_Compressed_pair<class std::allocator<int>, class _lambda_b6f3cb1c717d8c8a816f87295491882e_, 1>::_Compressed_pair<class std::allocator<int>, class _lambda_b6f3cb1c717d8c8a816f87295491882e_, 1>(struct std::_One_then_variadic_args_t, class std::allocator<int> &&, class _lambda_b6f3cb1c717d8c8a816f87295491882e_ &&)
.text$mn:00000390                 public ??$?0V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:00000390 ??$?0V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z proc near
.text$mn:00000390                                         ; CODE XREF: ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z+5Cp
.text$mn:00000390
.text$mn:00000390 var_CC          = byte ptr -0CCh
.text$mn:00000390 var_8           = dword ptr -8
.text$mn:00000390 arg_4           = dword ptr  0Ch
.text$mn:00000390 arg_8           = dword ptr  10h
.text$mn:00000390
.text$mn:00000390                 push    ebp
.text$mn:00000391                 mov     ebp, esp
.text$mn:00000393                 sub     esp, 0CCh
.text$mn:00000399                 push    ebx
.text$mn:0000039A                 push    esi
.text$mn:0000039B                 push    edi
.text$mn:0000039C                 push    ecx
.text$mn:0000039D                 lea     edi, [ebp+var_CC]
.text$mn:000003A3                 mov     ecx, 33h ; '3'
.text$mn:000003A8                 mov     eax, 0CCCCCCCCh
.text$mn:000003AD                 rep stosd
.text$mn:000003AF                 pop     ecx
.text$mn:000003B0                 mov     [ebp+var_8], ecx
.text$mn:000003B3                 mov     eax, [ebp+arg_4]
.text$mn:000003B6                 push    eax
.text$mn:000003B7                 call    ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int>>(std::allocator<int> &)
.text$mn:000003BC                 add     esp, 4
.text$mn:000003BF                 push    eax
.text$mn:000003C0                 mov     ecx, [ebp+var_8]
.text$mn:000003C3                 call    ??0?$allocator@H@std@@QAE@ABV01@@Z ; std::allocator<int>::allocator<int>(std::allocator<int> const &)
.text$mn:000003C8                 mov     eax, [ebp+arg_8]
.text$mn:000003CB                 push    eax
.text$mn:000003CC                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:000003D1                 add     esp, 4
.text$mn:000003D4                 mov     ecx, [eax]
.text$mn:000003D6                 mov     edx, [ebp+var_8]
.text$mn:000003D9                 mov     [edx], ecx
.text$mn:000003DB                 mov     eax, [ebp+var_8]
.text$mn:000003DE                 pop     edi
.text$mn:000003DF                 pop     esi
.text$mn:000003E0                 pop     ebx
.text$mn:000003E1                 add     esp, 0CCh
.text$mn:000003E7                 cmp     ebp, esp
.text$mn:000003E9                 call    __RTC_CheckEsp
.text$mn:000003EE                 mov     esp, ebp
.text$mn:000003F0                 pop     ebp
.text$mn:000003F1                 retn    0Ch
.text$mn:000003F1 ??$?0V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z endp
.text$mn:000003F1
.text$mn:000003F1 _text$mn        ends
.text$mn:000003F1
.text$mn:000003F4 ; ===========================================================================
.text$mn:000003F4
.text$mn:000003F4 ; Segment type: Pure code
.text$mn:000003F4 ; Segment permissions: Read/Execute
.text$mn:000003F4 _text$mn        segment para public 'CODE' use32
.text$mn:000003F4                 assume cs:_text$mn
.text$mn:000003F4                 ;org 3F4h
.text$mn:000003F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000003F4
.text$mn:000003F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000003F4
.text$mn:000003F4 ; Attributes: bp-based frame
.text$mn:000003F4
.text$mn:000003F4 ; public: bool __thiscall std::less<void>::operator()<unsigned int const &, unsigned int const &>(unsigned int const &, unsigned int const &)const
.text$mn:000003F4                 public ??$?RABIABI@?$less@X@std@@QBE_NABI0@Z
.text$mn:000003F4 ??$?RABIABI@?$less@X@std@@QBE_NABI0@Z proc near
.text$mn:000003F4                                         ; CODE XREF: std::_Debug_lt_pred<std::less<void>,uint const &,uint const &>(std::less<void>,uint const &,uint const &,wchar_t const *,uint)+29p
.text$mn:000003F4                                         ; std::_Debug_lt_pred<std::less<void>,uint const &,uint const &>(std::less<void>,uint const &,uint const &,wchar_t const *,uint)+49p
.text$mn:000003F4
.text$mn:000003F4 var_D0          = dword ptr -0D0h
.text$mn:000003F4 var_8           = dword ptr -8
.text$mn:000003F4 arg_0           = dword ptr  8
.text$mn:000003F4 arg_4           = dword ptr  0Ch
.text$mn:000003F4
.text$mn:000003F4                 push    ebp
.text$mn:000003F5                 mov     ebp, esp
.text$mn:000003F7                 sub     esp, 0D0h
.text$mn:000003FD                 push    ebx
.text$mn:000003FE                 push    esi
.text$mn:000003FF                 push    edi
.text$mn:00000400                 push    ecx
.text$mn:00000401                 lea     edi, [ebp+var_D0]
.text$mn:00000407                 mov     ecx, 34h ; '4'
.text$mn:0000040C                 mov     eax, 0CCCCCCCCh
.text$mn:00000411                 rep stosd
.text$mn:00000413                 pop     ecx
.text$mn:00000414                 mov     [ebp+var_8], ecx
.text$mn:00000417                 mov     eax, [ebp+arg_0]
.text$mn:0000041A                 mov     ecx, [ebp+arg_4]
.text$mn:0000041D                 mov     edx, [eax]
.text$mn:0000041F                 cmp     edx, [ecx]
.text$mn:00000421                 jnb     short loc_42F
.text$mn:00000423                 mov     [ebp+var_D0], 1
.text$mn:0000042D                 jmp     short loc_439
.text$mn:0000042F ; ---------------------------------------------------------------------------
.text$mn:0000042F
.text$mn:0000042F loc_42F:                                ; CODE XREF: std::less<void>::operator()<uint const &,uint const &>(uint const &,uint const &)+2Dj
.text$mn:0000042F                 mov     [ebp+var_D0], 0
.text$mn:00000439
.text$mn:00000439 loc_439:                                ; CODE XREF: std::less<void>::operator()<uint const &,uint const &>(uint const &,uint const &)+39j
.text$mn:00000439                 mov     al, byte ptr [ebp+var_D0]
.text$mn:0000043F                 pop     edi
.text$mn:00000440                 pop     esi
.text$mn:00000441                 pop     ebx
.text$mn:00000442                 mov     esp, ebp
.text$mn:00000444                 pop     ebp
.text$mn:00000445                 retn    8
.text$mn:00000445 ??$?RABIABI@?$less@X@std@@QBE_NABI0@Z endp
.text$mn:00000445
.text$mn:00000445 _text$mn        ends
.text$mn:00000445
.text$mn:00000448 ; ===========================================================================
.text$mn:00000448
.text$mn:00000448 ; Segment type: Pure code
.text$mn:00000448 ; Segment permissions: Read/Execute
.text$mn:00000448 _text$mn        segment para public 'CODE' use32
.text$mn:00000448                 assume cs:_text$mn
.text$mn:00000448                 ;org 448h
.text$mn:00000448                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000448
.text$mn:00000448 ; =============== S U B R O U T I N E =======================================
.text$mn:00000448
.text$mn:00000448 ; Attributes: bp-based frame
.text$mn:00000448
.text$mn:00000448 ; bool __cdecl str::StartsWith<char>(char const *, char const *)
.text$mn:00000448                 public ??$StartsWith@D@str@@YA_NPBD0@Z
.text$mn:00000448 ??$StartsWith@D@str@@YA_NPBD0@Z proc near
.text$mn:00000448                                         ; CODE XREF: WinMain(x,x,x,x)+A1p
.text$mn:00000448                                         ; WinMain(x,x,x,x)+C3p
.text$mn:00000448
.text$mn:00000448 var_C0          = byte ptr -0C0h
.text$mn:00000448 arg_0           = dword ptr  8
.text$mn:00000448 arg_4           = dword ptr  0Ch
.text$mn:00000448
.text$mn:00000448                 push    ebp
.text$mn:00000449                 mov     ebp, esp
.text$mn:0000044B                 sub     esp, 0C0h
.text$mn:00000451                 push    ebx
.text$mn:00000452                 push    esi
.text$mn:00000453                 push    edi             ; unsigned int
.text$mn:00000454                 lea     edi, [ebp+var_C0]
.text$mn:0000045A                 mov     ecx, 30h ; '0'
.text$mn:0000045F                 mov     eax, 0CCCCCCCCh
.text$mn:00000464                 rep stosd
.text$mn:00000466                 mov     eax, [ebp+arg_4]
.text$mn:00000469                 push    eax             ; this
.text$mn:0000046A                 call    ?Len@str@@YAIPBD@Z ; str::Len(char const *)
.text$mn:0000046F                 add     esp, 4
.text$mn:00000472                 push    eax             ; char *
.text$mn:00000473                 mov     ecx, [ebp+arg_4]
.text$mn:00000476                 push    ecx             ; char *
.text$mn:00000477                 mov     edx, [ebp+arg_0]
.text$mn:0000047A                 push    edx             ; this
.text$mn:0000047B                 call    ?EqN@str@@YA_NPBD0I@Z ; str::EqN(char const *,char const *,uint)
.text$mn:00000480                 add     esp, 0Ch
.text$mn:00000483                 pop     edi
.text$mn:00000484                 pop     esi
.text$mn:00000485                 pop     ebx
.text$mn:00000486                 add     esp, 0C0h
.text$mn:0000048C                 cmp     ebp, esp
.text$mn:0000048E                 call    __RTC_CheckEsp
.text$mn:00000493                 mov     esp, ebp
.text$mn:00000495                 pop     ebp
.text$mn:00000496                 retn
.text$mn:00000496 ??$StartsWith@D@str@@YA_NPBD0@Z endp
.text$mn:00000496
.text$mn:00000496 ; ---------------------------------------------------------------------------
.text$mn:00000497                 align 4
.text$mn:00000497 _text$mn        ends
.text$mn:00000497
.text$mn:00000498 ; ===========================================================================
.text$mn:00000498
.text$mn:00000498 ; Segment type: Pure code
.text$mn:00000498 ; Segment permissions: Read/Execute
.text$mn:00000498 _text$mn        segment para public 'CODE' use32
.text$mn:00000498                 assume cs:_text$mn
.text$mn:00000498                 ;org 498h
.text$mn:00000498                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000498
.text$mn:00000498 ; =============== S U B R O U T I N E =======================================
.text$mn:00000498
.text$mn:00000498 ; Attributes: bp-based frame
.text$mn:00000498
.text$mn:00000498 ; class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const * __cdecl std::_Addressof<class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const>(class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const &, struct std::integral_constant<bool, 0>)
.text$mn:00000498                 public ??$_Addressof@$$CBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAPBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@U?$integral_constant@_N$0A@@0@@Z
.text$mn:00000498 ??$_Addressof@$$CBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAPBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@U?$integral_constant@_N$0A@@0@@Z proc near
.text$mn:00000498                                         ; CODE XREF: std::addressof<_lambda_b6f3cb1c717d8c8a816f87295491882e_ const>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)+2Ap
.text$mn:00000498
.text$mn:00000498 var_C0          = byte ptr -0C0h
.text$mn:00000498 arg_0           = dword ptr  8
.text$mn:00000498
.text$mn:00000498                 push    ebp
.text$mn:00000499                 mov     ebp, esp
.text$mn:0000049B                 sub     esp, 0C0h
.text$mn:000004A1                 push    ebx
.text$mn:000004A2                 push    esi
.text$mn:000004A3                 push    edi
.text$mn:000004A4                 lea     edi, [ebp+var_C0]
.text$mn:000004AA                 mov     ecx, 30h ; '0'
.text$mn:000004AF                 mov     eax, 0CCCCCCCCh
.text$mn:000004B4                 rep stosd
.text$mn:000004B6                 mov     eax, [ebp+arg_0]
.text$mn:000004B9                 pop     edi
.text$mn:000004BA                 pop     esi
.text$mn:000004BB                 pop     ebx
.text$mn:000004BC                 mov     esp, ebp
.text$mn:000004BE                 pop     ebp
.text$mn:000004BF                 retn
.text$mn:000004BF ??$_Addressof@$$CBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAPBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@U?$integral_constant@_N$0A@@0@@Z endp
.text$mn:000004BF
.text$mn:000004BF _text$mn        ends
.text$mn:000004BF
.text$mn:000004C0 ; ===========================================================================
.text$mn:000004C0
.text$mn:000004C0 ; Segment type: Pure code
.text$mn:000004C0 ; Segment permissions: Read/Execute
.text$mn:000004C0 _text$mn        segment para public 'CODE' use32
.text$mn:000004C0                 assume cs:_text$mn
.text$mn:000004C0                 ;org 4C0h
.text$mn:000004C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000004C0
.text$mn:000004C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000004C0
.text$mn:000004C0 ; Attributes: bp-based frame
.text$mn:000004C0
.text$mn:000004C0                 public ??$_Call@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$V@_Invoker_functor@std@@SAXAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:000004C0 ??$_Call@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$V@_Invoker_functor@std@@SAXAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z proc near
.text$mn:000004C0                                         ; CODE XREF: ??$invoke@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$V@std@@YAXAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z+2Bp
.text$mn:000004C0
.text$mn:000004C0 var_C0          = byte ptr -0C0h
.text$mn:000004C0 arg_0           = dword ptr  8
.text$mn:000004C0
.text$mn:000004C0                 push    ebp
.text$mn:000004C1                 mov     ebp, esp
.text$mn:000004C3                 sub     esp, 0C0h
.text$mn:000004C9                 push    ebx
.text$mn:000004CA                 push    esi
.text$mn:000004CB                 push    edi
.text$mn:000004CC                 lea     edi, [ebp+var_C0]
.text$mn:000004D2                 mov     ecx, 30h ; '0'
.text$mn:000004D7                 mov     eax, 0CCCCCCCCh
.text$mn:000004DC                 rep stosd
.text$mn:000004DE                 mov     eax, [ebp+arg_0]
.text$mn:000004E1                 push    eax
.text$mn:000004E2                 call    ??$forward@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_ &>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:000004E7                 add     esp, 4
.text$mn:000004EA                 mov     ecx, eax
.text$mn:000004EC                 call    ??R_lambda_b6f3cb1c717d8c8a816f87295491882e_@@QBEXXZ ; _lambda_b6f3cb1c717d8c8a816f87295491882e_::operator()(void)
.text$mn:000004F1                 pop     edi
.text$mn:000004F2                 pop     esi
.text$mn:000004F3                 pop     ebx
.text$mn:000004F4                 add     esp, 0C0h
.text$mn:000004FA                 cmp     ebp, esp
.text$mn:000004FC                 call    __RTC_CheckEsp
.text$mn:00000501                 mov     esp, ebp
.text$mn:00000503                 pop     ebp
.text$mn:00000504                 retn
.text$mn:00000504 ??$_Call@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$V@_Invoker_functor@std@@SAXAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z endp
.text$mn:00000504
.text$mn:00000504 ; ---------------------------------------------------------------------------
.text$mn:00000505                 align 4
.text$mn:00000505 _text$mn        ends
.text$mn:00000505
.text$mn:00000508 ; ===========================================================================
.text$mn:00000508
.text$mn:00000508 ; Segment type: Pure code
.text$mn:00000508 ; Segment permissions: Read/Execute
.text$mn:00000508 _text$mn        segment para public 'CODE' use32
.text$mn:00000508                 assume cs:_text$mn
.text$mn:00000508                 ;org 508h
.text$mn:00000508                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000508
.text$mn:00000508 ; =============== S U B R O U T I N E =======================================
.text$mn:00000508
.text$mn:00000508 ; Attributes: bp-based frame
.text$mn:00000508
.text$mn:00000508                 public ??$_Clone@X@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEPAV?$_Func_base@X$$V@1@PAXU?$integral_constant@_N$0A@@1@@Z
.text$mn:00000508 ??$_Clone@X@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEPAV?$_Func_base@X$$V@1@PAXU?$integral_constant@_N$0A@@1@@Z proc near
.text$mn:00000508                                         ; CODE XREF: ?_Copy@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEPAV?$_Func_base@X$$V@2@PAX@Z+32p
.text$mn:00000508
.text$mn:00000508 var_E4          = byte ptr -0E4h
.text$mn:00000508 var_20          = dword ptr -20h
.text$mn:00000508 var_11          = byte ptr -11h
.text$mn:00000508 var_8           = dword ptr -8
.text$mn:00000508 arg_0           = dword ptr  8
.text$mn:00000508
.text$mn:00000508                 push    ebp
.text$mn:00000509                 mov     ebp, esp
.text$mn:0000050B                 sub     esp, 0E4h
.text$mn:00000511                 push    ebx
.text$mn:00000512                 push    esi
.text$mn:00000513                 push    edi
.text$mn:00000514                 push    ecx
.text$mn:00000515                 lea     edi, [ebp+var_E4]
.text$mn:0000051B                 mov     ecx, 39h ; '9'
.text$mn:00000520                 mov     eax, 0CCCCCCCCh
.text$mn:00000525                 rep stosd
.text$mn:00000527                 pop     ecx
.text$mn:00000528                 mov     [ebp+var_8], ecx
.text$mn:0000052B                 mov     ecx, [ebp+var_8]
.text$mn:0000052E                 call    ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV?$allocator@H@2@XZ
.text$mn:00000533                 push    eax
.text$mn:00000534                 lea     ecx, [ebp+var_11]
.text$mn:00000537                 call    ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:0000053C                 mov     eax, [ebp+arg_0]
.text$mn:0000053F                 mov     [ebp+var_20], eax
.text$mn:00000542                 mov     ecx, [ebp+var_8]
.text$mn:00000545                 call    ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV?$allocator@H@2@XZ
.text$mn:0000054A                 push    eax             ; int
.text$mn:0000054B                 mov     ecx, [ebp+var_8]
.text$mn:0000054E                 call    ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ
.text$mn:00000553                 push    eax             ; int
.text$mn:00000554                 mov     eax, [ebp+var_20]
.text$mn:00000557                 push    eax             ; void *
.text$mn:00000558                 lea     ecx, [ebp+var_11]
.text$mn:0000055B                 call    ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000560                 mov     eax, [ebp+var_20]
.text$mn:00000563                 push    edx
.text$mn:00000564                 mov     ecx, ebp
.text$mn:00000566                 push    eax
.text$mn:00000567                 lea     edx, $LN5_6
.text$mn:0000056D                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00000572                 pop     eax
.text$mn:00000573                 pop     edx
.text$mn:00000574                 pop     edi
.text$mn:00000575                 pop     esi
.text$mn:00000576                 pop     ebx
.text$mn:00000577                 add     esp, 0E4h
.text$mn:0000057D                 cmp     ebp, esp
.text$mn:0000057F                 call    __RTC_CheckEsp
.text$mn:00000584                 mov     esp, ebp
.text$mn:00000586                 pop     ebp
.text$mn:00000587                 retn    8
.text$mn:00000587 ??$_Clone@X@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEPAV?$_Func_base@X$$V@1@PAXU?$integral_constant@_N$0A@@1@@Z endp
.text$mn:00000587
.text$mn:00000587 ; ---------------------------------------------------------------------------
.text$mn:0000058A                 align 4
.text$mn:0000058C $LN5_6          dd 1                    ; DATA XREF: ??$_Clone@X@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEPAV?$_Func_base@X$$V@1@PAXU?$integral_constant@_N$0A@@1@@Z+5Fo
.text$mn:00000590                 dd offset $LN4_5
.text$mn:00000594 $LN4_5          dd 0FFFFFFEFh, 1        ; DATA XREF: .text$mn:00000590o
.text$mn:0000059C                 dd offset $LN3_1
.text$mn:000005A0 $LN3_1          dd 6C415Fh              ; DATA XREF: .text$mn:0000059Co
.text$mn:000005A0 _text$mn        ends
.text$mn:000005A0
.text$mn:000005A4 ; ===========================================================================
.text$mn:000005A4
.text$mn:000005A4 ; Segment type: Pure code
.text$mn:000005A4 ; Segment permissions: Read/Execute
.text$mn:000005A4 _text$mn        segment para public 'CODE' use32
.text$mn:000005A4                 assume cs:_text$mn
.text$mn:000005A4                 ;org 5A4h
.text$mn:000005A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000005A4
.text$mn:000005A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000005A4
.text$mn:000005A4 ; Attributes: bp-based frame
.text$mn:000005A4
.text$mn:000005A4 ; int __cdecl ____Deallocate_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std__YAXPAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_0_I_Z(void *, int)
.text$mn:000005A4                 public ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z
.text$mn:000005A4 ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z proc near
.text$mn:000005A4                                         ; CODE XREF: ?deallocate@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@2@I@Z+2Bp
.text$mn:000005A4
.text$mn:000005A4 var_F0          = byte ptr -0F0h
.text$mn:000005A4 var_2C          = dword ptr -2Ch
.text$mn:000005A4 var_20          = dword ptr -20h
.text$mn:000005A4 var_14          = dword ptr -14h
.text$mn:000005A4 var_8           = dword ptr -8
.text$mn:000005A4 arg_0           = dword ptr  8
.text$mn:000005A4 arg_4           = dword ptr  0Ch
.text$mn:000005A4
.text$mn:000005A4                 push    ebp
.text$mn:000005A5                 mov     ebp, esp
.text$mn:000005A7                 sub     esp, 0F0h
.text$mn:000005AD                 push    ebx
.text$mn:000005AE                 push    esi
.text$mn:000005AF                 push    edi
.text$mn:000005B0                 lea     edi, [ebp+var_F0]
.text$mn:000005B6                 mov     ecx, 3Ch ; '<'
.text$mn:000005BB                 mov     eax, 0CCCCCCCCh
.text$mn:000005C0                 rep stosd
.text$mn:000005C2                 cmp     [ebp+arg_4], 1FFFFFFFh
.text$mn:000005C9                 jbe     short loc_616
.text$mn:000005CB                 mov     eax, offset ??_C@_0CG@FHBDFCGK@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5sizeof?5@ ; "_Count <= (size_t)(-1) / sizeof (_Ty)"
.text$mn:000005D0                 test    eax, eax
.text$mn:000005D2                 jz      short loc_5D8
.text$mn:000005D4                 xor     ecx, ecx
.text$mn:000005D6                 jnz     short loc_5FB
.text$mn:000005D8
.text$mn:000005D8 loc_5D8:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+2Ej
.text$mn:000005D8                 push    offset ??_C@_1FK@EJGLHMGC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf@ ; "\"_Count <= (size_t)(-1) / sizeof (_Ty)"...
.text$mn:000005DD                 push    offset ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@ ; "%ls"
.text$mn:000005E2                 push    0
.text$mn:000005E4                 push    64h ; 'd'
.text$mn:000005E6                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:000005EB                 push    2
.text$mn:000005ED                 call    __CrtDbgReportW
.text$mn:000005F2                 add     esp, 18h
.text$mn:000005F5                 cmp     eax, 1
.text$mn:000005F8                 jnz     short loc_5FB
.text$mn:000005FA                 int     3               ; Trap to Debugger
.text$mn:000005FB
.text$mn:000005FB loc_5FB:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+32j
.text$mn:000005FB                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+54j
.text$mn:000005FB                 push    0
.text$mn:000005FD                 push    64h ; 'd'
.text$mn:000005FF                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:00000604                 push    offset ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; "std::_Deallocate"
.text$mn:00000609                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:0000060E                 call    __invalid_parameter
.text$mn:00000613                 add     esp, 14h
.text$mn:00000616
.text$mn:00000616 loc_616:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+25j
.text$mn:00000616                 mov     eax, [ebp+arg_4]
.text$mn:00000619                 shl     eax, 3
.text$mn:0000061C                 mov     [ebp+var_8], eax
.text$mn:0000061F                 cmp     [ebp+var_8], 1000h
.text$mn:00000626                 jb      loc_800
.text$mn:0000062C                 mov     eax, [ebp+arg_0]
.text$mn:0000062F                 mov     [ebp+var_14], eax
.text$mn:00000632                 mov     eax, [ebp+var_14]
.text$mn:00000635                 and     eax, 1Fh
.text$mn:00000638                 jz      short loc_685
.text$mn:0000063A                 mov     eax, offset ??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@ ; "(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT"...
.text$mn:0000063F                 test    eax, eax
.text$mn:00000641                 jz      short loc_647
.text$mn:00000643                 xor     ecx, ecx
.text$mn:00000645                 jnz     short loc_66A
.text$mn:00000647
.text$mn:00000647 loc_647:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+9Dj
.text$mn:00000647                 push    offset ??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@ ; "\"(_Ptr_user & (_BIG_ALLOCATION_ALIGNME"...
.text$mn:0000064C                 push    offset ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@ ; "%ls"
.text$mn:00000651                 push    0
.text$mn:00000653                 push    6Ah ; 'j'
.text$mn:00000655                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:0000065A                 push    2
.text$mn:0000065C                 call    __CrtDbgReportW
.text$mn:00000661                 add     esp, 18h
.text$mn:00000664                 cmp     eax, 1
.text$mn:00000667                 jnz     short loc_66A
.text$mn:00000669                 int     3               ; Trap to Debugger
.text$mn:0000066A
.text$mn:0000066A loc_66A:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+A1j
.text$mn:0000066A                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+C3j
.text$mn:0000066A                 push    0
.text$mn:0000066C                 push    6Ah ; 'j'
.text$mn:0000066E                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:00000673                 push    offset ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; "std::_Deallocate"
.text$mn:00000678                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:0000067D                 call    __invalid_parameter
.text$mn:00000682                 add     esp, 14h
.text$mn:00000685
.text$mn:00000685 loc_685:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+94j
.text$mn:00000685                 mov     eax, [ebp+var_14]
.text$mn:00000688                 sub     eax, 4
.text$mn:0000068B                 mov     [ebp+var_20], eax
.text$mn:0000068E                 mov     eax, [ebp+var_20]
.text$mn:00000691                 mov     ecx, [eax]
.text$mn:00000693                 mov     [ebp+var_2C], ecx
.text$mn:00000696                 mov     eax, 4
.text$mn:0000069B                 imul    ecx, eax, -1
.text$mn:0000069E                 mov     edx, [ebp+var_20]
.text$mn:000006A1                 cmp     dword ptr [edx+ecx], 0FAFAFAFAh
.text$mn:000006A8                 jz      short loc_6F5
.text$mn:000006AA                 mov     eax, offset ??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@ ; "reinterpret_cast<uintptr_t *>(_Ptr_ptr)"...
.text$mn:000006AF                 test    eax, eax
.text$mn:000006B1                 jz      short loc_6B7
.text$mn:000006B3                 xor     ecx, ecx
.text$mn:000006B5                 jnz     short loc_6DA
.text$mn:000006B7
.text$mn:000006B7 loc_6B7:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+10Dj
.text$mn:000006B7                 push    offset ??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@ ; "\"reinterpret_cast<uintptr_t *>(_Ptr_pt"...
.text$mn:000006BC                 push    offset ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@ ; "%ls"
.text$mn:000006C1                 push    0
.text$mn:000006C3                 push    74h ; 't'
.text$mn:000006C5                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:000006CA                 push    2
.text$mn:000006CC                 call    __CrtDbgReportW
.text$mn:000006D1                 add     esp, 18h
.text$mn:000006D4                 cmp     eax, 1
.text$mn:000006D7                 jnz     short loc_6DA
.text$mn:000006D9                 int     3               ; Trap to Debugger
.text$mn:000006DA
.text$mn:000006DA loc_6DA:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+111j
.text$mn:000006DA                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+133j
.text$mn:000006DA                 push    0
.text$mn:000006DC                 push    74h ; 't'
.text$mn:000006DE                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:000006E3                 push    offset ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; "std::_Deallocate"
.text$mn:000006E8                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:000006ED                 call    __invalid_parameter
.text$mn:000006F2                 add     esp, 14h
.text$mn:000006F5
.text$mn:000006F5 loc_6F5:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+104j
.text$mn:000006F5                 mov     eax, [ebp+var_2C]
.text$mn:000006F8                 cmp     eax, [ebp+var_14]
.text$mn:000006FB                 jb      short loc_748
.text$mn:000006FD                 mov     eax, offset ??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@ ; "_Ptr_container < _Ptr_user"
.text$mn:00000702                 test    eax, eax
.text$mn:00000704                 jz      short loc_70A
.text$mn:00000706                 xor     ecx, ecx
.text$mn:00000708                 jnz     short loc_72D
.text$mn:0000070A
.text$mn:0000070A loc_70A:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+160j
.text$mn:0000070A                 push    offset ??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ ; "\"_Ptr_container < _Ptr_user\" && 0"
.text$mn:0000070F                 push    offset ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@ ; "%ls"
.text$mn:00000714                 push    0
.text$mn:00000716                 push    78h ; 'x'
.text$mn:00000718                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:0000071D                 push    2
.text$mn:0000071F                 call    __CrtDbgReportW
.text$mn:00000724                 add     esp, 18h
.text$mn:00000727                 cmp     eax, 1
.text$mn:0000072A                 jnz     short loc_72D
.text$mn:0000072C                 int     3               ; Trap to Debugger
.text$mn:0000072D
.text$mn:0000072D loc_72D:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+164j
.text$mn:0000072D                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+186j
.text$mn:0000072D                 push    0
.text$mn:0000072F                 push    78h ; 'x'
.text$mn:00000731                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:00000736                 push    offset ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; "std::_Deallocate"
.text$mn:0000073B                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:00000740                 call    __invalid_parameter
.text$mn:00000745                 add     esp, 14h
.text$mn:00000748
.text$mn:00000748 loc_748:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+157j
.text$mn:00000748                 mov     eax, [ebp+var_14]
.text$mn:0000074B                 sub     eax, [ebp+var_2C]
.text$mn:0000074E                 cmp     eax, 8
.text$mn:00000751                 jnb     short loc_79E
.text$mn:00000753                 mov     eax, offset ??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@ ; "2 * sizeof(void *) <= _Ptr_user - _Ptr_"...
.text$mn:00000758                 test    eax, eax
.text$mn:0000075A                 jz      short loc_760
.text$mn:0000075C                 xor     ecx, ecx
.text$mn:0000075E                 jnz     short loc_783
.text$mn:00000760
.text$mn:00000760 loc_760:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+1B6j
.text$mn:00000760                 push    offset ??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@ ; "\"2 * sizeof(void *) <= _Ptr_user - _Pt"...
.text$mn:00000765                 push    offset ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@ ; "%ls"
.text$mn:0000076A                 push    0
.text$mn:0000076C                 push    7Ch ; '|'
.text$mn:0000076E                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:00000773                 push    2
.text$mn:00000775                 call    __CrtDbgReportW
.text$mn:0000077A                 add     esp, 18h
.text$mn:0000077D                 cmp     eax, 1
.text$mn:00000780                 jnz     short loc_783
.text$mn:00000782                 int     3               ; Trap to Debugger
.text$mn:00000783
.text$mn:00000783 loc_783:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+1BAj
.text$mn:00000783                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+1DCj
.text$mn:00000783                 push    0
.text$mn:00000785                 push    7Ch ; '|'
.text$mn:00000787                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:0000078C                 push    offset ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; "std::_Deallocate"
.text$mn:00000791                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:00000796                 call    __invalid_parameter
.text$mn:0000079B                 add     esp, 14h
.text$mn:0000079E
.text$mn:0000079E loc_79E:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+1ADj
.text$mn:0000079E                 mov     eax, [ebp+var_14]
.text$mn:000007A1                 sub     eax, [ebp+var_2C]
.text$mn:000007A4                 cmp     eax, 27h ; '''
.text$mn:000007A7                 jbe     short loc_7FA
.text$mn:000007A9                 mov     eax, offset ??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@ ; "_Ptr_user - _Ptr_container <= _NON_USER"...
.text$mn:000007AE                 test    eax, eax
.text$mn:000007B0                 jz      short loc_7B6
.text$mn:000007B2                 xor     ecx, ecx
.text$mn:000007B4                 jnz     short loc_7DC
.text$mn:000007B6
.text$mn:000007B6 loc_7B6:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+20Cj
.text$mn:000007B6                 push    offset ??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@ ; "\"_Ptr_user - _Ptr_container <= _NON_US"...
.text$mn:000007BB                 push    offset ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@ ; "%ls"
.text$mn:000007C0                 push    0
.text$mn:000007C2                 push    84h ; ''
.text$mn:000007C7                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:000007CC                 push    2
.text$mn:000007CE                 call    __CrtDbgReportW
.text$mn:000007D3                 add     esp, 18h
.text$mn:000007D6                 cmp     eax, 1
.text$mn:000007D9                 jnz     short loc_7DC   ; DATA XREF: InstanceInit(int)+7Co
.text$mn:000007DB                 int     3               ; Trap to Debugger
.text$mn:000007DC
.text$mn:000007DC loc_7DC:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+210j
.text$mn:000007DC                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+235j
.text$mn:000007DC                 push    0
.text$mn:000007DE                 push    84h ; ''
.text$mn:000007E3                 push    offset ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:000007E8                 push    offset ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; "std::_Deallocate"
.text$mn:000007ED                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:000007F2                 call    __invalid_parameter
.text$mn:000007F7                 add     esp, 14h
.text$mn:000007FA
.text$mn:000007FA loc_7FA:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+203j
.text$mn:000007FA                 mov     eax, [ebp+var_2C]
.text$mn:000007FD                 mov     [ebp+arg_0], eax
.text$mn:00000800
.text$mn:00000800 loc_800:                                ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+82j
.text$mn:00000800                 mov     eax, [ebp+arg_0]
.text$mn:00000803                 push    eax             ; void *
.text$mn:00000804                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000809                 add     esp, 4
.text$mn:0000080C                 pop     edi
.text$mn:0000080D                 pop     esi
.text$mn:0000080E                 pop     ebx
.text$mn:0000080F                 add     esp, 0F0h
.text$mn:00000815                 cmp     ebp, esp
.text$mn:00000817                 call    __RTC_CheckEsp
.text$mn:0000081C                 mov     esp, ebp
.text$mn:0000081E                 pop     ebp
.text$mn:0000081F                 retn
.text$mn:0000081F ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z endp
.text$mn:0000081F
.text$mn:0000081F _text$mn        ends
.text$mn:0000081F
.text$mn:00000820 ; ===========================================================================
.text$mn:00000820
.text$mn:00000820 ; Segment type: Pure code
.text$mn:00000820 ; Segment permissions: Read/Execute
.text$mn:00000820 _text$mn        segment para public 'CODE' use32
.text$mn:00000820                 assume cs:_text$mn
.text$mn:00000820                 ;org 820h
.text$mn:00000820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000820
.text$mn:00000820 ; =============== S U B R O U T I N E =======================================
.text$mn:00000820
.text$mn:00000820 ; Attributes: bp-based frame
.text$mn:00000820
.text$mn:00000820 ; int __cdecl std::_Debug_lt<unsigned int const &,unsigned int const &>(int, int, wchar_t *, unsigned int)
.text$mn:00000820                 public ??$_Debug_lt@ABIABI@std@@YA_NABI0PB_WI@Z
.text$mn:00000820 ??$_Debug_lt@ABIABI@std@@YA_NABI0PB_WI@Z proc near
.text$mn:00000820                                         ; CODE XREF: std::max<uint>(uint const &,uint const &)+30p
.text$mn:00000820
.text$mn:00000820 var_CC          = byte ptr -0CCh
.text$mn:00000820 var_C5          = byte ptr -0C5h
.text$mn:00000820 arg_0           = dword ptr  8
.text$mn:00000820 arg_4           = dword ptr  0Ch
.text$mn:00000820 arg_8           = dword ptr  10h
.text$mn:00000820 arg_C           = dword ptr  14h
.text$mn:00000820
.text$mn:00000820                 push    ebp
.text$mn:00000821                 mov     ebp, esp
.text$mn:00000823                 sub     esp, 0CCh
.text$mn:00000829                 push    ebx
.text$mn:0000082A                 push    esi
.text$mn:0000082B                 push    edi
.text$mn:0000082C                 lea     edi, [ebp+var_CC]
.text$mn:00000832                 mov     ecx, 33h ; '3'
.text$mn:00000837                 mov     eax, 0CCCCCCCCh
.text$mn:0000083C                 rep stosd
.text$mn:0000083E                 mov     eax, [ebp+arg_C]
.text$mn:00000841                 push    eax             ; unsigned int
.text$mn:00000842                 mov     ecx, [ebp+arg_8]
.text$mn:00000845                 push    ecx             ; wchar_t *
.text$mn:00000846                 mov     edx, [ebp+arg_4]
.text$mn:00000849                 push    edx
.text$mn:0000084A                 call    ??$forward@ABI@std@@YAABIABI@Z ; std::forward<uint const &>(uint const &)
.text$mn:0000084F                 add     esp, 4
.text$mn:00000852                 push    eax             ; int
.text$mn:00000853                 mov     eax, [ebp+arg_0]
.text$mn:00000856                 push    eax
.text$mn:00000857                 call    ??$forward@ABI@std@@YAABIABI@Z ; std::forward<uint const &>(uint const &)
.text$mn:0000085C                 add     esp, 4
.text$mn:0000085F                 push    eax             ; int
.text$mn:00000860                 movzx   ecx, [ebp+var_C5]
.text$mn:00000867                 push    ecx             ; char
.text$mn:00000868                 call    ??$_Debug_lt_pred@U?$less@X@std@@ABIABI@std@@YA_NU?$less@X@0@ABI1PB_WI@Z ; std::_Debug_lt_pred<std::less<void>,uint const &,uint const &>(std::less<void>,uint const &,uint const &,wchar_t const *,uint)
.text$mn:0000086D                 add     esp, 14h
.text$mn:00000870                 pop     edi
.text$mn:00000871                 pop     esi
.text$mn:00000872                 pop     ebx
.text$mn:00000873                 add     esp, 0CCh
.text$mn:00000879                 cmp     ebp, esp
.text$mn:0000087B                 call    __RTC_CheckEsp
.text$mn:00000880                 mov     esp, ebp
.text$mn:00000882                 pop     ebp
.text$mn:00000883                 retn
.text$mn:00000883 ??$_Debug_lt@ABIABI@std@@YA_NABI0PB_WI@Z endp
.text$mn:00000883
.text$mn:00000883 _text$mn        ends
.text$mn:00000883
.text$mn:00000884 ; ===========================================================================
.text$mn:00000884
.text$mn:00000884 ; Segment type: Pure code
.text$mn:00000884 ; Segment permissions: Read/Execute
.text$mn:00000884 _text$mn        segment para public 'CODE' use32
.text$mn:00000884                 assume cs:_text$mn
.text$mn:00000884                 ;org 884h
.text$mn:00000884                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000884
.text$mn:00000884 ; =============== S U B R O U T I N E =======================================
.text$mn:00000884
.text$mn:00000884 ; Attributes: bp-based frame
.text$mn:00000884
.text$mn:00000884 ; int __cdecl std::_Debug_lt_pred<std::less<void>,unsigned int const &,unsigned int const &>(char, int, int, wchar_t *, unsigned int)
.text$mn:00000884                 public ??$_Debug_lt_pred@U?$less@X@std@@ABIABI@std@@YA_NU?$less@X@0@ABI1PB_WI@Z
.text$mn:00000884 ??$_Debug_lt_pred@U?$less@X@std@@ABIABI@std@@YA_NU?$less@X@0@ABI1PB_WI@Z proc near
.text$mn:00000884                                         ; CODE XREF: std::_Debug_lt<uint const &,uint const &>(uint const &,uint const &,wchar_t const *,uint)+48p
.text$mn:00000884
.text$mn:00000884 var_C4          = byte ptr -0C4h
.text$mn:00000884 var_C2          = byte ptr -0C2h
.text$mn:00000884 var_C1          = byte ptr -0C1h
.text$mn:00000884 arg_0           = byte ptr  8
.text$mn:00000884 arg_4           = dword ptr  0Ch
.text$mn:00000884 arg_8           = dword ptr  10h
.text$mn:00000884 arg_C           = dword ptr  14h
.text$mn:00000884 arg_10          = dword ptr  18h
.text$mn:00000884
.text$mn:00000884                 push    ebp
.text$mn:00000885                 mov     ebp, esp
.text$mn:00000887                 sub     esp, 0C4h
.text$mn:0000088D                 push    ebx
.text$mn:0000088E                 push    esi
.text$mn:0000088F                 push    edi
.text$mn:00000890                 lea     edi, [ebp+var_C4]
.text$mn:00000896                 mov     ecx, 31h ; '1'
.text$mn:0000089B                 mov     eax, 0CCCCCCCCh
.text$mn:000008A0                 rep stosd
.text$mn:000008A2                 mov     eax, [ebp+arg_8]
.text$mn:000008A5                 push    eax
.text$mn:000008A6                 mov     ecx, [ebp+arg_4]
.text$mn:000008A9                 push    ecx
.text$mn:000008AA                 lea     ecx, [ebp+arg_0]
.text$mn:000008AD                 call    ??$?RABIABI@?$less@X@std@@QBE_NABI0@Z ; std::less<void>::operator()<uint const &,uint const &>(uint const &,uint const &)
.text$mn:000008B2                 movzx   edx, al
.text$mn:000008B5                 test    edx, edx
.text$mn:000008B7                 jnz     short loc_8C2
.text$mn:000008B9                 mov     [ebp+var_C1], 0
.text$mn:000008C0                 jmp     short loc_90A
.text$mn:000008C2 ; ---------------------------------------------------------------------------
.text$mn:000008C2
.text$mn:000008C2 loc_8C2:                                ; CODE XREF: std::_Debug_lt_pred<std::less<void>,uint const &,uint const &>(std::less<void>,uint const &,uint const &,wchar_t const *,uint)+33j
.text$mn:000008C2                 mov     eax, [ebp+arg_4]
.text$mn:000008C5                 push    eax
.text$mn:000008C6                 mov     ecx, [ebp+arg_8]
.text$mn:000008C9                 push    ecx
.text$mn:000008CA                 lea     ecx, [ebp+arg_0]
.text$mn:000008CD                 call    ??$?RABIABI@?$less@X@std@@QBE_NABI0@Z ; std::less<void>::operator()<uint const &,uint const &>(uint const &,uint const &)
.text$mn:000008D2                 movzx   edx, al
.text$mn:000008D5                 test    edx, edx
.text$mn:000008D7                 jz      short loc_8F7
.text$mn:000008D9                 mov     eax, [ebp+arg_10]
.text$mn:000008DC                 push    eax             ; unsigned int
.text$mn:000008DD                 mov     ecx, [ebp+arg_C]
.text$mn:000008E0                 push    ecx             ; wchar_t *
.text$mn:000008E1                 push    offset ??_C@_1CG@LEJCKCBB@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$AA@ ; "invalid comparator"
.text$mn:000008E6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000008EB                 add     esp, 0Ch
.text$mn:000008EE                 mov     [ebp+var_C2], 1
.text$mn:000008F5                 jmp     short loc_8FE
.text$mn:000008F7 ; ---------------------------------------------------------------------------
.text$mn:000008F7
.text$mn:000008F7 loc_8F7:                                ; CODE XREF: std::_Debug_lt_pred<std::less<void>,uint const &,uint const &>(std::less<void>,uint const &,uint const &,wchar_t const *,uint)+53j
.text$mn:000008F7                 mov     [ebp+var_C2], 1
.text$mn:000008FE
.text$mn:000008FE loc_8FE:                                ; CODE XREF: std::_Debug_lt_pred<std::less<void>,uint const &,uint const &>(std::less<void>,uint const &,uint const &,wchar_t const *,uint)+71j
.text$mn:000008FE                 mov     dl, [ebp+var_C2]
.text$mn:00000904                 mov     [ebp+var_C1], dl
.text$mn:0000090A
.text$mn:0000090A loc_90A:                                ; CODE XREF: std::_Debug_lt_pred<std::less<void>,uint const &,uint const &>(std::less<void>,uint const &,uint const &,wchar_t const *,uint)+3Cj
.text$mn:0000090A                 mov     al, [ebp+var_C1]
.text$mn:00000910                 pop     edi
.text$mn:00000911                 pop     esi
.text$mn:00000912                 pop     ebx
.text$mn:00000913                 add     esp, 0C4h
.text$mn:00000919                 cmp     ebp, esp
.text$mn:0000091B                 call    __RTC_CheckEsp
.text$mn:00000920                 mov     esp, ebp
.text$mn:00000922                 pop     ebp
.text$mn:00000923                 retn
.text$mn:00000923 ??$_Debug_lt_pred@U?$less@X@std@@ABIABI@std@@YA_NU?$less@X@0@ABI1PB_WI@Z endp
.text$mn:00000923
.text$mn:00000923 _text$mn        ends
.text$mn:00000923
.text$mn:00000924 ; ===========================================================================
.text$mn:00000924
.text$mn:00000924 ; Segment type: Pure code
.text$mn:00000924 ; Segment permissions: Read/Execute
.text$mn:00000924 _text$mn        segment para public 'CODE' use32
.text$mn:00000924                 assume cs:_text$mn
.text$mn:00000924                 ;org 924h
.text$mn:00000924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000924
.text$mn:00000924 ; =============== S U B R O U T I N E =======================================
.text$mn:00000924
.text$mn:00000924 ; Attributes: bp-based frame
.text$mn:00000924
.text$mn:00000924 ; void __cdecl std::_Invoke_ret<void, class _lambda_b6f3cb1c717d8c8a816f87295491882e_ &>(struct std::_Forced<void, 1>, class _lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00000924                 public ??$_Invoke_ret@XAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAXU?$_Forced@X$00@0@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:00000924 ??$_Invoke_ret@XAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAXU?$_Forced@X$00@0@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z proc near
.text$mn:00000924                                         ; CODE XREF: ?_Do_call@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEXXZ+34p
.text$mn:00000924
.text$mn:00000924 var_C0          = byte ptr -0C0h
.text$mn:00000924 arg_4           = dword ptr  0Ch
.text$mn:00000924
.text$mn:00000924                 push    ebp
.text$mn:00000925                 mov     ebp, esp
.text$mn:00000927                 sub     esp, 0C0h
.text$mn:0000092D                 push    ebx
.text$mn:0000092E                 push    esi
.text$mn:0000092F                 push    edi
.text$mn:00000930                 lea     edi, [ebp+var_C0]
.text$mn:00000936                 mov     ecx, 30h ; '0'
.text$mn:0000093B                 mov     eax, 0CCCCCCCCh
.text$mn:00000940                 rep stosd
.text$mn:00000942                 mov     eax, [ebp+arg_4]
.text$mn:00000945                 push    eax
.text$mn:00000946                 call    ??$forward@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_ &>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:0000094B                 add     esp, 4
.text$mn:0000094E                 push    eax
.text$mn:0000094F                 call    ??$invoke@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$V@std@@YAXAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:00000954                 add     esp, 4
.text$mn:00000957                 pop     edi
.text$mn:00000958                 pop     esi
.text$mn:00000959                 pop     ebx
.text$mn:0000095A                 add     esp, 0C0h
.text$mn:00000960                 cmp     ebp, esp
.text$mn:00000962                 call    __RTC_CheckEsp
.text$mn:00000967                 mov     esp, ebp
.text$mn:00000969                 pop     ebp
.text$mn:0000096A                 retn
.text$mn:0000096A ??$_Invoke_ret@XAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAXU?$_Forced@X$00@0@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z endp
.text$mn:0000096A
.text$mn:0000096A ; ---------------------------------------------------------------------------
.text$mn:0000096B                 align 4
.text$mn:0000096B _text$mn        ends
.text$mn:0000096B
.text$mn:0000096C ; ===========================================================================
.text$mn:0000096C
.text$mn:0000096C ; Segment type: Pure code
.text$mn:0000096C ; Segment permissions: Read/Execute
.text$mn:0000096C _text$mn        segment para public 'CODE' use32
.text$mn:0000096C                 assume cs:_text$mn
.text$mn:0000096C                 ;org 96Ch
.text$mn:0000096C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000096C
.text$mn:0000096C ; =============== S U B R O U T I N E =======================================
.text$mn:0000096C
.text$mn:0000096C ; Attributes: bp-based frame
.text$mn:0000096C
.text$mn:0000096C                 public ??$_Reset@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:0000096C ??$_Reset@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z proc near
.text$mn:0000096C                                         ; CODE XREF: std::function<void (void)>::function<void (void)>(_lambda_b6f3cb1c717d8c8a816f87295491882e_)+3Bp
.text$mn:0000096C
.text$mn:0000096C var_D8          = byte ptr -0D8h
.text$mn:0000096C var_D1          = byte ptr -0D1h
.text$mn:0000096C var_8           = dword ptr -8
.text$mn:0000096C arg_0           = dword ptr  8
.text$mn:0000096C
.text$mn:0000096C                 push    ebp
.text$mn:0000096D                 mov     ebp, esp
.text$mn:0000096F                 sub     esp, 0D8h
.text$mn:00000975                 push    ebx
.text$mn:00000976                 push    esi
.text$mn:00000977                 push    edi
.text$mn:00000978                 push    ecx
.text$mn:00000979                 lea     edi, [ebp+var_D8]
.text$mn:0000097F                 mov     ecx, 36h ; '6'
.text$mn:00000984                 mov     eax, 0CCCCCCCCh
.text$mn:00000989                 rep stosd
.text$mn:0000098B                 pop     ecx
.text$mn:0000098C                 mov     [ebp+var_8], ecx
.text$mn:0000098F                 lea     ecx, [ebp+var_D1]
.text$mn:00000995                 call    ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>(void)
.text$mn:0000099A                 push    eax
.text$mn:0000099B                 mov     eax, [ebp+arg_0]
.text$mn:0000099E                 push    eax
.text$mn:0000099F                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:000009A4                 add     esp, 4
.text$mn:000009A7                 push    eax
.text$mn:000009A8                 mov     ecx, [ebp+var_8]
.text$mn:000009AB                 call    ??$_Reset_alloc@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:000009B0                 pop     edi
.text$mn:000009B1                 pop     esi
.text$mn:000009B2                 pop     ebx
.text$mn:000009B3                 add     esp, 0D8h
.text$mn:000009B9                 cmp     ebp, esp
.text$mn:000009BB                 call    __RTC_CheckEsp
.text$mn:000009C0                 mov     esp, ebp
.text$mn:000009C2                 pop     ebp
.text$mn:000009C3                 retn    4
.text$mn:000009C3 ??$_Reset@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z endp
.text$mn:000009C3
.text$mn:000009C3 ; ---------------------------------------------------------------------------
.text$mn:000009C6                 align 4
.text$mn:000009C6 _text$mn        ends
.text$mn:000009C6
.text$mn:000009C8 ; ===========================================================================
.text$mn:000009C8
.text$mn:000009C8 ; Segment type: Pure code
.text$mn:000009C8 ; Segment permissions: Read/Execute
.text$mn:000009C8 _text$mn        segment para public 'CODE' use32
.text$mn:000009C8                 assume cs:_text$mn
.text$mn:000009C8                 ;org 9C8h
.text$mn:000009C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009C8
.text$mn:000009C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000009C8
.text$mn:000009C8 ; Attributes: bp-based frame
.text$mn:000009C8
.text$mn:000009C8                 public ??$_Reset_alloc@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:000009C8 ??$_Reset_alloc@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z proc near
.text$mn:000009C8                                         ; CODE XREF: ??$_Reset@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z+3Fp
.text$mn:000009C8
.text$mn:000009C8 var_FC          = byte ptr -0FCh
.text$mn:000009C8 var_F5          = byte ptr -0F5h
.text$mn:000009C8 var_1D          = byte ptr -1Dh
.text$mn:000009C8 var_14          = dword ptr -14h
.text$mn:000009C8 var_8           = dword ptr -8
.text$mn:000009C8 arg_0           = dword ptr  8
.text$mn:000009C8 arg_4           = dword ptr  0Ch
.text$mn:000009C8
.text$mn:000009C8                 push    ebp
.text$mn:000009C9                 mov     ebp, esp
.text$mn:000009CB                 sub     esp, 0FCh
.text$mn:000009D1                 push    ebx
.text$mn:000009D2                 push    esi
.text$mn:000009D3                 push    edi
.text$mn:000009D4                 push    ecx
.text$mn:000009D5                 lea     edi, [ebp+var_FC]
.text$mn:000009DB                 mov     ecx, 3Fh ; '?'
.text$mn:000009E0                 mov     eax, 0CCCCCCCCh
.text$mn:000009E5                 rep stosd
.text$mn:000009E7                 pop     ecx
.text$mn:000009E8                 mov     [ebp+var_8], ecx
.text$mn:000009EB                 mov     eax, [ebp+arg_0]
.text$mn:000009EE                 push    eax
.text$mn:000009EF                 call    ??$_Test_callable@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA_NABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z ; std::_Test_callable<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:000009F4                 add     esp, 4
.text$mn:000009F7                 movzx   ecx, al
.text$mn:000009FA                 test    ecx, ecx
.text$mn:000009FC                 jnz     short loc_A00
.text$mn:000009FE                 jmp     short loc_A3C
.text$mn:00000A00 ; ---------------------------------------------------------------------------
.text$mn:00000A00
.text$mn:00000A00 loc_A00:                                ; CODE XREF: ??$_Reset_alloc@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+34j
.text$mn:00000A00                 mov     [ebp+var_14], 0
.text$mn:00000A07                 mov     eax, [ebp+arg_4]
.text$mn:00000A0A                 push    eax
.text$mn:00000A0B                 lea     ecx, [ebp+var_1D]
.text$mn:00000A0E                 call    ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:00000A13                 movzx   eax, [ebp+var_F5]
.text$mn:00000A1A                 push    eax
.text$mn:00000A1B                 lea     ecx, [ebp+var_1D]
.text$mn:00000A1E                 push    ecx
.text$mn:00000A1F                 mov     edx, [ebp+var_14]
.text$mn:00000A22                 push    edx
.text$mn:00000A23                 mov     eax, [ebp+arg_4]
.text$mn:00000A26                 push    eax
.text$mn:00000A27                 mov     ecx, [ebp+arg_0]
.text$mn:00000A2A                 push    ecx
.text$mn:00000A2B                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00000A30                 add     esp, 4
.text$mn:00000A33                 push    eax
.text$mn:00000A34                 mov     ecx, [ebp+var_8]
.text$mn:00000A37                 call    ??$_Reset_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@3@U?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@3@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@AAU?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@1@U?$integral_constant@_N$0A@@1@@Z
.text$mn:00000A3C
.text$mn:00000A3C loc_A3C:                                ; CODE XREF: ??$_Reset_alloc@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+36j
.text$mn:00000A3C                 push    edx
.text$mn:00000A3D                 mov     ecx, ebp
.text$mn:00000A3F                 push    eax
.text$mn:00000A40                 lea     edx, $LN6_2
.text$mn:00000A46                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00000A4B                 pop     eax
.text$mn:00000A4C                 pop     edx
.text$mn:00000A4D                 pop     edi
.text$mn:00000A4E                 pop     esi
.text$mn:00000A4F                 pop     ebx
.text$mn:00000A50                 add     esp, 0FCh
.text$mn:00000A56                 cmp     ebp, esp
.text$mn:00000A58                 call    __RTC_CheckEsp
.text$mn:00000A5D                 mov     esp, ebp
.text$mn:00000A5F                 pop     ebp
.text$mn:00000A60                 retn    8
.text$mn:00000A60 ??$_Reset_alloc@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z endp
.text$mn:00000A60
.text$mn:00000A60 ; ---------------------------------------------------------------------------
.text$mn:00000A63                 align 4
.text$mn:00000A64 $LN6_2          dd 1                    ; DATA XREF: ??$_Reset_alloc@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+78o
.text$mn:00000A68                 dd offset $LN5_2
.text$mn:00000A6C $LN5_2          dd 0FFFFFFE3h, 1        ; DATA XREF: .text$mn:00000A68o
.text$mn:00000A74                 dd offset $LN4_1
.text$mn:00000A78 $LN4_1          dd 6C415Fh              ; DATA XREF: .text$mn:00000A74o
.text$mn:00000A78 _text$mn        ends
.text$mn:00000A78
.text$mn:00000A7C ; ===========================================================================
.text$mn:00000A7C
.text$mn:00000A7C ; Segment type: Pure code
.text$mn:00000A7C ; Segment permissions: Read/Execute
.text$mn:00000A7C _text$mn        segment para public 'CODE' use32
.text$mn:00000A7C                 assume cs:_text$mn
.text$mn:00000A7C                 ;org 0A7Ch
.text$mn:00000A7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A7C
.text$mn:00000A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00000A7C
.text$mn:00000A7C ; Attributes: bp-based frame
.text$mn:00000A7C
.text$mn:00000A7C                 public ??$_Reset_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@3@U?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@3@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@AAU?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@1@U?$integral_constant@_N$0A@@1@@Z
.text$mn:00000A7C ??$_Reset_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@3@U?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@3@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@AAU?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@1@U?$integral_constant@_N$0A@@1@@Z proc near
.text$mn:00000A7C                                         ; CODE XREF: ??$_Reset_alloc@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+6Fp
.text$mn:00000A7C
.text$mn:00000A7C var_D8          = byte ptr -0D8h
.text$mn:00000A7C var_14          = dword ptr -14h
.text$mn:00000A7C var_8           = dword ptr -8
.text$mn:00000A7C arg_0           = dword ptr  8
.text$mn:00000A7C arg_4           = dword ptr  0Ch
.text$mn:00000A7C arg_C           = dword ptr  14h
.text$mn:00000A7C
.text$mn:00000A7C                 push    ebp
.text$mn:00000A7D                 mov     ebp, esp
.text$mn:00000A7F                 sub     esp, 0D8h
.text$mn:00000A85                 push    ebx
.text$mn:00000A86                 push    esi
.text$mn:00000A87                 push    edi
.text$mn:00000A88                 push    ecx
.text$mn:00000A89                 lea     edi, [ebp+var_D8]
.text$mn:00000A8F                 mov     ecx, 36h ; '6'
.text$mn:00000A94                 mov     eax, 0CCCCCCCCh
.text$mn:00000A99                 rep stosd
.text$mn:00000A9B                 pop     ecx
.text$mn:00000A9C                 mov     [ebp+var_8], ecx
.text$mn:00000A9F                 mov     ecx, [ebp+var_8]
.text$mn:00000AA2                 call    ?_Getspace@?$_Func_class@X$$V@std@@AAEPAXXZ
.text$mn:00000AA7                 mov     [ebp+var_14], eax
.text$mn:00000AAA                 mov     eax, [ebp+arg_4]
.text$mn:00000AAD                 push    eax             ; int
.text$mn:00000AAE                 mov     ecx, [ebp+arg_0]
.text$mn:00000AB1                 push    ecx
.text$mn:00000AB2                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00000AB7                 add     esp, 4
.text$mn:00000ABA                 push    eax             ; int
.text$mn:00000ABB                 mov     edx, [ebp+var_14]
.text$mn:00000ABE                 push    edx             ; void *
.text$mn:00000ABF                 mov     ecx, [ebp+arg_C]
.text$mn:00000AC2                 call    ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000AC7                 mov     eax, [ebp+var_14]
.text$mn:00000ACA                 push    eax
.text$mn:00000ACB                 mov     ecx, [ebp+var_8]
.text$mn:00000ACE                 call    ?_Set@?$_Func_class@X$$V@std@@AAEXPAV?$_Func_base@X$$V@2@@Z
.text$mn:00000AD3                 pop     edi
.text$mn:00000AD4                 pop     esi
.text$mn:00000AD5                 pop     ebx
.text$mn:00000AD6                 add     esp, 0D8h
.text$mn:00000ADC                 cmp     ebp, esp
.text$mn:00000ADE                 call    __RTC_CheckEsp
.text$mn:00000AE3                 mov     esp, ebp
.text$mn:00000AE5                 pop     ebp
.text$mn:00000AE6                 retn    14h
.text$mn:00000AE6 ??$_Reset_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@3@U?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@3@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@AAU?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@1@U?$integral_constant@_N$0A@@1@@Z endp
.text$mn:00000AE6
.text$mn:00000AE6 ; ---------------------------------------------------------------------------
.text$mn:00000AE9                 align 4
.text$mn:00000AE9 _text$mn        ends
.text$mn:00000AE9
.text$mn:00000AEC ; ===========================================================================
.text$mn:00000AEC
.text$mn:00000AEC ; Segment type: Pure code
.text$mn:00000AEC ; Segment permissions: Read/Execute
.text$mn:00000AEC _text$mn        segment para public 'CODE' use32
.text$mn:00000AEC                 assume cs:_text$mn
.text$mn:00000AEC                 ;org 0AECh
.text$mn:00000AEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000AEC
.text$mn:00000AEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000AEC
.text$mn:00000AEC ; Attributes: bp-based frame
.text$mn:00000AEC
.text$mn:00000AEC ; bool __cdecl std::_Test_callable<class _lambda_b6f3cb1c717d8c8a816f87295491882e_>(class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:00000AEC                 public ??$_Test_callable@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA_NABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:00000AEC ??$_Test_callable@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA_NABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z proc near
.text$mn:00000AEC                                         ; CODE XREF: ??$_Reset_alloc@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+27p
.text$mn:00000AEC
.text$mn:00000AEC var_D8          = byte ptr -0D8h
.text$mn:00000AEC var_D1          = byte ptr -0D1h
.text$mn:00000AEC arg_0           = dword ptr  8
.text$mn:00000AEC
.text$mn:00000AEC                 push    ebp
.text$mn:00000AED                 mov     ebp, esp
.text$mn:00000AEF                 sub     esp, 0D8h
.text$mn:00000AF5                 push    ebx
.text$mn:00000AF6                 push    esi
.text$mn:00000AF7                 push    edi
.text$mn:00000AF8                 lea     edi, [ebp+var_D8]
.text$mn:00000AFE                 mov     ecx, 36h ; '6'
.text$mn:00000B03                 mov     eax, 0CCCCCCCCh
.text$mn:00000B08                 rep stosd
.text$mn:00000B0A                 movzx   eax, [ebp+var_D1]
.text$mn:00000B11                 push    eax
.text$mn:00000B12                 mov     ecx, [ebp+arg_0]
.text$mn:00000B15                 push    ecx
.text$mn:00000B16                 call    ??$_Test_callable@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA_NABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@U?$integral_constant@_N$0A@@0@@Z ; std::_Test_callable<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &,std::integral_constant<bool,0>)
.text$mn:00000B1B                 add     esp, 8
.text$mn:00000B1E                 push    edx
.text$mn:00000B1F                 mov     ecx, ebp
.text$mn:00000B21                 push    eax
.text$mn:00000B22                 lea     edx, $LN5_3
.text$mn:00000B28                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00000B2D                 pop     eax
.text$mn:00000B2E                 pop     edx
.text$mn:00000B2F                 pop     edi
.text$mn:00000B30                 pop     esi
.text$mn:00000B31                 pop     ebx
.text$mn:00000B32                 add     esp, 0D8h
.text$mn:00000B38                 cmp     ebp, esp
.text$mn:00000B3A                 call    __RTC_CheckEsp
.text$mn:00000B3F                 mov     esp, ebp
.text$mn:00000B41                 pop     ebp
.text$mn:00000B42                 retn
.text$mn:00000B42 ??$_Test_callable@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA_NABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z endp
.text$mn:00000B42
.text$mn:00000B42 ; ---------------------------------------------------------------------------
.text$mn:00000B43                 align 4
.text$mn:00000B44 $LN5_3          dd 1                    ; DATA XREF: std::_Test_callable<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)+36o
.text$mn:00000B48                 dd offset $LN4_2
.text$mn:00000B4C $LN4_2          dd 0FFFFFFFBh, 1        ; DATA XREF: .text$mn:00000B48o
.text$mn:00000B54                 dd offset $LN3          ; "_Testable"
.text$mn:00000B58 $LN3            db '_Testable',0        ; DATA XREF: .text$mn:00000B54o
.text$mn:00000B62                 align 4
.text$mn:00000B62 _text$mn        ends
.text$mn:00000B62
.text$mn:00000B64 ; ===========================================================================
.text$mn:00000B64
.text$mn:00000B64 ; Segment type: Pure code
.text$mn:00000B64 ; Segment permissions: Read/Execute
.text$mn:00000B64 _text$mn        segment para public 'CODE' use32
.text$mn:00000B64                 assume cs:_text$mn
.text$mn:00000B64                 ;org 0B64h
.text$mn:00000B64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B64
.text$mn:00000B64 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B64
.text$mn:00000B64 ; Attributes: bp-based frame
.text$mn:00000B64
.text$mn:00000B64 ; bool __cdecl std::_Test_callable<class _lambda_b6f3cb1c717d8c8a816f87295491882e_>(class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const &, struct std::integral_constant<bool, 0>)
.text$mn:00000B64                 public ??$_Test_callable@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA_NABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@U?$integral_constant@_N$0A@@0@@Z
.text$mn:00000B64 ??$_Test_callable@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA_NABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@U?$integral_constant@_N$0A@@0@@Z proc near
.text$mn:00000B64                                         ; CODE XREF: std::_Test_callable<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)+2Ap
.text$mn:00000B64
.text$mn:00000B64 var_C0          = byte ptr -0C0h
.text$mn:00000B64
.text$mn:00000B64                 push    ebp
.text$mn:00000B65                 mov     ebp, esp
.text$mn:00000B67                 sub     esp, 0C0h
.text$mn:00000B6D                 push    ebx
.text$mn:00000B6E                 push    esi
.text$mn:00000B6F                 push    edi
.text$mn:00000B70                 lea     edi, [ebp+var_C0]
.text$mn:00000B76                 mov     ecx, 30h ; '0'
.text$mn:00000B7B                 mov     eax, 0CCCCCCCCh
.text$mn:00000B80                 rep stosd
.text$mn:00000B82                 mov     al, 1
.text$mn:00000B84                 pop     edi
.text$mn:00000B85                 pop     esi
.text$mn:00000B86                 pop     ebx
.text$mn:00000B87                 mov     esp, ebp
.text$mn:00000B89                 pop     ebp
.text$mn:00000B8A                 retn
.text$mn:00000B8A ??$_Test_callable@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA_NABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@U?$integral_constant@_N$0A@@0@@Z endp
.text$mn:00000B8A
.text$mn:00000B8A ; ---------------------------------------------------------------------------
.text$mn:00000B8B                 align 4
.text$mn:00000B8B _text$mn        ends
.text$mn:00000B8B
.text$mn:00000B8C ; ===========================================================================
.text$mn:00000B8C
.text$mn:00000B8C ; Segment type: Pure code
.text$mn:00000B8C ; Segment permissions: Read/Execute
.text$mn:00000B8C _text$mn        segment para public 'CODE' use32
.text$mn:00000B8C                 assume cs:_text$mn
.text$mn:00000B8C                 ;org 0B8Ch
.text$mn:00000B8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B8C
.text$mn:00000B8C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B8C
.text$mn:00000B8C ; Attributes: bp-based frame
.text$mn:00000B8C
.text$mn:00000B8C ; void __cdecl __vcrt_va_start_verify_argument_type<wchar_t const *>(void)
.text$mn:00000B8C                 public ??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ
.text$mn:00000B8C ??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ proc near
.text$mn:00000B8C                                         ; CODE XREF: str::Str<wchar_t>::AppendFmt(wchar_t const *,...)+1Ep
.text$mn:00000B8C
.text$mn:00000B8C var_C0          = byte ptr -0C0h
.text$mn:00000B8C
.text$mn:00000B8C                 push    ebp
.text$mn:00000B8D                 mov     ebp, esp
.text$mn:00000B8F                 sub     esp, 0C0h
.text$mn:00000B95                 push    ebx
.text$mn:00000B96                 push    esi
.text$mn:00000B97                 push    edi
.text$mn:00000B98                 lea     edi, [ebp+var_C0]
.text$mn:00000B9E                 mov     ecx, 30h ; '0'
.text$mn:00000BA3                 mov     eax, 0CCCCCCCCh
.text$mn:00000BA8                 rep stosd
.text$mn:00000BAA                 pop     edi
.text$mn:00000BAB                 pop     esi
.text$mn:00000BAC                 pop     ebx
.text$mn:00000BAD                 mov     esp, ebp
.text$mn:00000BAF                 pop     ebp
.text$mn:00000BB0                 retn
.text$mn:00000BB0 ??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ endp
.text$mn:00000BB0
.text$mn:00000BB0 ; ---------------------------------------------------------------------------
.text$mn:00000BB1                 align 4
.text$mn:00000BB1 _text$mn        ends
.text$mn:00000BB1
.text$mn:00000BB4 ; ===========================================================================
.text$mn:00000BB4
.text$mn:00000BB4 ; Segment type: Pure code
.text$mn:00000BB4 ; Segment permissions: Read/Execute
.text$mn:00000BB4 _text$mn        segment para public 'CODE' use32
.text$mn:00000BB4                 assume cs:_text$mn
.text$mn:00000BB4                 ;org 0BB4h
.text$mn:00000BB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BB4
.text$mn:00000BB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BB4
.text$mn:00000BB4 ; Attributes: bp-based frame
.text$mn:00000BB4
.text$mn:00000BB4 ; class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const * __cdecl std::addressof<class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const>(class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:00000BB4                 public ??$addressof@$$CBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAPBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z
.text$mn:00000BB4 ??$addressof@$$CBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAPBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z proc near
.text$mn:00000BB4                                         ; CODE XREF: ?_Get@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEPBXXZ+2Cp
.text$mn:00000BB4
.text$mn:00000BB4 var_D8          = byte ptr -0D8h
.text$mn:00000BB4 var_D1          = byte ptr -0D1h
.text$mn:00000BB4 arg_0           = dword ptr  8
.text$mn:00000BB4
.text$mn:00000BB4                 push    ebp
.text$mn:00000BB5                 mov     ebp, esp
.text$mn:00000BB7                 sub     esp, 0D8h
.text$mn:00000BBD                 push    ebx
.text$mn:00000BBE                 push    esi
.text$mn:00000BBF                 push    edi
.text$mn:00000BC0                 lea     edi, [ebp+var_D8]
.text$mn:00000BC6                 mov     ecx, 36h ; '6'
.text$mn:00000BCB                 mov     eax, 0CCCCCCCCh
.text$mn:00000BD0                 rep stosd
.text$mn:00000BD2                 movzx   eax, [ebp+var_D1]
.text$mn:00000BD9                 push    eax
.text$mn:00000BDA                 mov     ecx, [ebp+arg_0]
.text$mn:00000BDD                 push    ecx
.text$mn:00000BDE                 call    ??$_Addressof@$$CBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAPBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@U?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<_lambda_b6f3cb1c717d8c8a816f87295491882e_ const>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &,std::integral_constant<bool,0>)
.text$mn:00000BE3                 add     esp, 8
.text$mn:00000BE6                 pop     edi
.text$mn:00000BE7                 pop     esi
.text$mn:00000BE8                 pop     ebx
.text$mn:00000BE9                 add     esp, 0D8h
.text$mn:00000BEF                 cmp     ebp, esp
.text$mn:00000BF1                 call    __RTC_CheckEsp
.text$mn:00000BF6                 mov     esp, ebp
.text$mn:00000BF8                 pop     ebp
.text$mn:00000BF9                 retn
.text$mn:00000BF9 ??$addressof@$$CBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAPBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z endp
.text$mn:00000BF9
.text$mn:00000BF9 ; ---------------------------------------------------------------------------
.text$mn:00000BFA                 align 4
.text$mn:00000BFA _text$mn        ends
.text$mn:00000BFA
.text$mn:00000BFC ; ===========================================================================
.text$mn:00000BFC
.text$mn:00000BFC ; Segment type: Pure code
.text$mn:00000BFC ; Segment permissions: Read/Execute
.text$mn:00000BFC _text$mn        segment para public 'CODE' use32
.text$mn:00000BFC                 assume cs:_text$mn
.text$mn:00000BFC                 ;org 0BFCh
.text$mn:00000BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BFC
.text$mn:00000BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00000BFC
.text$mn:00000BFC ; Attributes: bp-based frame
.text$mn:00000BFC
.text$mn:00000BFC ; int __stdcall ___construct_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std__ABV_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_2_____Wrap_alloc_V__allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std___std__QAEXPAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_1_ABV_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_1__Z(void *, int, int)
.text$mn:00000BFC                 public ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000BFC ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z proc near
.text$mn:00000BFC                                         ; CODE XREF: ??$_Clone@X@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEPAV?$_Func_base@X$$V@1@PAXU?$integral_constant@_N$0A@@1@@Z+53p
.text$mn:00000BFC
.text$mn:00000BFC var_CC          = byte ptr -0CCh
.text$mn:00000BFC var_8           = dword ptr -8
.text$mn:00000BFC arg_0           = dword ptr  8
.text$mn:00000BFC arg_4           = dword ptr  0Ch
.text$mn:00000BFC arg_8           = dword ptr  10h
.text$mn:00000BFC
.text$mn:00000BFC                 push    ebp
.text$mn:00000BFD                 mov     ebp, esp
.text$mn:00000BFF                 sub     esp, 0CCh
.text$mn:00000C05                 push    ebx
.text$mn:00000C06                 push    esi
.text$mn:00000C07                 push    edi
.text$mn:00000C08                 push    ecx
.text$mn:00000C09                 lea     edi, [ebp+var_CC]
.text$mn:00000C0F                 mov     ecx, 33h ; '3'
.text$mn:00000C14                 mov     eax, 0CCCCCCCCh
.text$mn:00000C19                 rep stosd
.text$mn:00000C1B                 pop     ecx
.text$mn:00000C1C                 mov     [ebp+var_8], ecx
.text$mn:00000C1F                 mov     eax, [ebp+arg_8]
.text$mn:00000C22                 push    eax
.text$mn:00000C23                 call    ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>(std::allocator<int> const &)
.text$mn:00000C28                 add     esp, 4
.text$mn:00000C2B                 push    eax             ; int
.text$mn:00000C2C                 mov     ecx, [ebp+arg_4]
.text$mn:00000C2F                 push    ecx
.text$mn:00000C30                 call    ??$forward@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:00000C35                 add     esp, 4
.text$mn:00000C38                 push    eax             ; int
.text$mn:00000C39                 mov     edx, [ebp+arg_0]
.text$mn:00000C3C                 push    edx             ; void *
.text$mn:00000C3D                 mov     eax, [ebp+var_8]
.text$mn:00000C40                 push    eax             ; int
.text$mn:00000C41                 call    ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000C46                 add     esp, 10h
.text$mn:00000C49                 pop     edi
.text$mn:00000C4A                 pop     esi
.text$mn:00000C4B                 pop     ebx
.text$mn:00000C4C                 add     esp, 0CCh
.text$mn:00000C52                 cmp     ebp, esp
.text$mn:00000C54                 call    __RTC_CheckEsp
.text$mn:00000C59                 mov     esp, ebp
.text$mn:00000C5B                 pop     ebp
.text$mn:00000C5C                 retn    0Ch
.text$mn:00000C5C ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z endp
.text$mn:00000C5C
.text$mn:00000C5C ; ---------------------------------------------------------------------------
.text$mn:00000C5F                 align 10h
.text$mn:00000C5F _text$mn        ends
.text$mn:00000C5F
.text$mn:00000C60 ; ===========================================================================
.text$mn:00000C60
.text$mn:00000C60 ; Segment type: Pure code
.text$mn:00000C60 ; Segment permissions: Read/Execute
.text$mn:00000C60 _text$mn        segment para public 'CODE' use32
.text$mn:00000C60                 assume cs:_text$mn
.text$mn:00000C60                 ;org 0C60h
.text$mn:00000C60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C60
.text$mn:00000C60 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C60
.text$mn:00000C60 ; Attributes: bp-based frame
.text$mn:00000C60
.text$mn:00000C60 ; int __stdcall ___construct_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std__ABV_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_2____allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std__QAEXPAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_1_ABV_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_1__Z(void *, int, int)
.text$mn:00000C60                 public ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000C60 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z proc near
.text$mn:00000C60                                         ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+3Fp
.text$mn:00000C60
.text$mn:00000C60 var_DC          = dword ptr -0DCh
.text$mn:00000C60 var_D4          = dword ptr -0D4h
.text$mn:00000C60 var_8           = dword ptr -8
.text$mn:00000C60 arg_0           = dword ptr  8
.text$mn:00000C60 arg_4           = dword ptr  0Ch
.text$mn:00000C60 arg_8           = dword ptr  10h
.text$mn:00000C60
.text$mn:00000C60                 push    ebp
.text$mn:00000C61                 mov     ebp, esp
.text$mn:00000C63                 sub     esp, 0DCh
.text$mn:00000C69                 push    ebx
.text$mn:00000C6A                 push    esi
.text$mn:00000C6B                 push    edi
.text$mn:00000C6C                 push    ecx
.text$mn:00000C6D                 lea     edi, [ebp+var_DC]
.text$mn:00000C73                 mov     ecx, 37h ; '7'
.text$mn:00000C78                 mov     eax, 0CCCCCCCCh
.text$mn:00000C7D                 rep stosd
.text$mn:00000C7F                 pop     ecx
.text$mn:00000C80                 mov     [ebp+var_8], ecx
.text$mn:00000C83                 mov     eax, [ebp+arg_0]
.text$mn:00000C86                 push    eax             ; void *
.text$mn:00000C87                 push    8               ; unsigned int
.text$mn:00000C89                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000C8E                 add     esp, 8
.text$mn:00000C91                 mov     [ebp+var_D4], eax
.text$mn:00000C97                 cmp     [ebp+var_D4], 0
.text$mn:00000C9E                 jz      short loc_CCD
.text$mn:00000CA0                 mov     ecx, [ebp+arg_8]
.text$mn:00000CA3                 push    ecx
.text$mn:00000CA4                 call    ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>(std::allocator<int> const &)
.text$mn:00000CA9                 add     esp, 4
.text$mn:00000CAC                 push    eax
.text$mn:00000CAD                 mov     edx, [ebp+arg_4]
.text$mn:00000CB0                 push    edx
.text$mn:00000CB1                 call    ??$forward@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:00000CB6                 add     esp, 4
.text$mn:00000CB9                 push    eax
.text$mn:00000CBA                 mov     ecx, [ebp+var_D4]
.text$mn:00000CC0                 call    ??$?0ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000CC5                 mov     [ebp+var_DC], eax
.text$mn:00000CCB                 jmp     short loc_CD7
.text$mn:00000CCD ; ---------------------------------------------------------------------------
.text$mn:00000CCD
.text$mn:00000CCD loc_CCD:                                ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+3Ej
.text$mn:00000CCD                 mov     [ebp+var_DC], 0
.text$mn:00000CD7
.text$mn:00000CD7 loc_CD7:                                ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+6Bj
.text$mn:00000CD7                 pop     edi
.text$mn:00000CD8                 pop     esi
.text$mn:00000CD9                 pop     ebx
.text$mn:00000CDA                 add     esp, 0DCh
.text$mn:00000CE0                 cmp     ebp, esp
.text$mn:00000CE2                 call    __RTC_CheckEsp
.text$mn:00000CE7                 mov     esp, ebp
.text$mn:00000CE9                 pop     ebp
.text$mn:00000CEA                 retn    0Ch
.text$mn:00000CEA ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z endp
.text$mn:00000CEA
.text$mn:00000CEA ; ---------------------------------------------------------------------------
.text$mn:00000CED                 align 10h
.text$mn:00000CED _text$mn        ends
.text$mn:00000CED
.text$mn:00000CF0 ; ===========================================================================
.text$mn:00000CF0
.text$mn:00000CF0 ; Segment type: Pure code
.text$mn:00000CF0 ; Segment permissions: Read/Execute
.text$mn:00000CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00000CF0                 assume cs:_text$mn
.text$mn:00000CF0                 ;org 0CF0h
.text$mn:00000CF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CF0
.text$mn:00000CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CF0
.text$mn:00000CF0 ; Attributes: bp-based frame
.text$mn:00000CF0
.text$mn:00000CF0 ; int __cdecl ___construct_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std__ABV_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_2____allocator_traits_V__allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std___std__SAXAAV__allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___1_PAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_1_ABV_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_1__Z(int, void *, int, int)
.text$mn:00000CF0                 public ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000CF0 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z proc near
.text$mn:00000CF0                                         ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+45p
.text$mn:00000CF0
.text$mn:00000CF0 var_C0          = byte ptr -0C0h
.text$mn:00000CF0 arg_0           = dword ptr  8
.text$mn:00000CF0 arg_4           = dword ptr  0Ch
.text$mn:00000CF0 arg_8           = dword ptr  10h
.text$mn:00000CF0 arg_C           = dword ptr  14h
.text$mn:00000CF0
.text$mn:00000CF0                 push    ebp
.text$mn:00000CF1                 mov     ebp, esp
.text$mn:00000CF3                 sub     esp, 0C0h
.text$mn:00000CF9                 push    ebx
.text$mn:00000CFA                 push    esi
.text$mn:00000CFB                 push    edi
.text$mn:00000CFC                 lea     edi, [ebp+var_C0]
.text$mn:00000D02                 mov     ecx, 30h ; '0'
.text$mn:00000D07                 mov     eax, 0CCCCCCCCh
.text$mn:00000D0C                 rep stosd
.text$mn:00000D0E                 mov     eax, [ebp+arg_C]
.text$mn:00000D11                 push    eax
.text$mn:00000D12                 call    ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>(std::allocator<int> const &)
.text$mn:00000D17                 add     esp, 4
.text$mn:00000D1A                 push    eax             ; int
.text$mn:00000D1B                 mov     ecx, [ebp+arg_8]
.text$mn:00000D1E                 push    ecx
.text$mn:00000D1F                 call    ??$forward@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:00000D24                 add     esp, 4
.text$mn:00000D27                 push    eax             ; int
.text$mn:00000D28                 mov     edx, [ebp+arg_4]
.text$mn:00000D2B                 push    edx             ; void *
.text$mn:00000D2C                 mov     ecx, [ebp+arg_0]
.text$mn:00000D2F                 call    ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000D34                 pop     edi
.text$mn:00000D35                 pop     esi
.text$mn:00000D36                 pop     ebx
.text$mn:00000D37                 add     esp, 0C0h
.text$mn:00000D3D                 cmp     ebp, esp
.text$mn:00000D3F                 call    __RTC_CheckEsp
.text$mn:00000D44                 mov     esp, ebp
.text$mn:00000D46                 pop     ebp
.text$mn:00000D47                 retn
.text$mn:00000D47 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z endp
.text$mn:00000D47
.text$mn:00000D47 _text$mn        ends
.text$mn:00000D47
.text$mn:00000D48 ; ===========================================================================
.text$mn:00000D48
.text$mn:00000D48 ; Segment type: Pure code
.text$mn:00000D48 ; Segment permissions: Read/Execute
.text$mn:00000D48 _text$mn        segment para public 'CODE' use32
.text$mn:00000D48                 assume cs:_text$mn
.text$mn:00000D48                 ;org 0D48h
.text$mn:00000D48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D48
.text$mn:00000D48 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D48
.text$mn:00000D48 ; Attributes: bp-based frame
.text$mn:00000D48
.text$mn:00000D48 ; int __stdcall ___construct_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std__V_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_2_____Wrap_alloc_V__allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std___std__QAEXPAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_1___QAV_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_1__Z(void *, int, int)
.text$mn:00000D48                 public ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000D48 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z proc near
.text$mn:00000D48                                         ; CODE XREF: ??$_Reset_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@3@U?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@3@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@AAU?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@1@U?$integral_constant@_N$0A@@1@@Z+46p
.text$mn:00000D48
.text$mn:00000D48 var_CC          = byte ptr -0CCh
.text$mn:00000D48 var_8           = dword ptr -8
.text$mn:00000D48 arg_0           = dword ptr  8
.text$mn:00000D48 arg_4           = dword ptr  0Ch
.text$mn:00000D48 arg_8           = dword ptr  10h
.text$mn:00000D48
.text$mn:00000D48                 push    ebp
.text$mn:00000D49                 mov     ebp, esp
.text$mn:00000D4B                 sub     esp, 0CCh
.text$mn:00000D51                 push    ebx
.text$mn:00000D52                 push    esi
.text$mn:00000D53                 push    edi
.text$mn:00000D54                 push    ecx
.text$mn:00000D55                 lea     edi, [ebp+var_CC]
.text$mn:00000D5B                 mov     ecx, 33h ; '3'
.text$mn:00000D60                 mov     eax, 0CCCCCCCCh
.text$mn:00000D65                 rep stosd
.text$mn:00000D67                 pop     ecx
.text$mn:00000D68                 mov     [ebp+var_8], ecx
.text$mn:00000D6B                 mov     eax, [ebp+arg_8]
.text$mn:00000D6E                 push    eax
.text$mn:00000D6F                 call    ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>(std::allocator<int> const &)
.text$mn:00000D74                 add     esp, 4
.text$mn:00000D77                 push    eax             ; int
.text$mn:00000D78                 mov     ecx, [ebp+arg_4]
.text$mn:00000D7B                 push    ecx
.text$mn:00000D7C                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00000D81                 add     esp, 4
.text$mn:00000D84                 push    eax             ; int
.text$mn:00000D85                 mov     edx, [ebp+arg_0]
.text$mn:00000D88                 push    edx             ; void *
.text$mn:00000D89                 mov     eax, [ebp+var_8]
.text$mn:00000D8C                 push    eax             ; int
.text$mn:00000D8D                 call    ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000D92                 add     esp, 10h
.text$mn:00000D95                 pop     edi
.text$mn:00000D96                 pop     esi
.text$mn:00000D97                 pop     ebx
.text$mn:00000D98                 add     esp, 0CCh
.text$mn:00000D9E                 cmp     ebp, esp
.text$mn:00000DA0                 call    __RTC_CheckEsp
.text$mn:00000DA5                 mov     esp, ebp
.text$mn:00000DA7                 pop     ebp
.text$mn:00000DA8                 retn    0Ch
.text$mn:00000DA8 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z endp
.text$mn:00000DA8
.text$mn:00000DA8 ; ---------------------------------------------------------------------------
.text$mn:00000DAB                 align 4
.text$mn:00000DAB _text$mn        ends
.text$mn:00000DAB
.text$mn:00000DAC ; ===========================================================================
.text$mn:00000DAC
.text$mn:00000DAC ; Segment type: Pure code
.text$mn:00000DAC ; Segment permissions: Read/Execute
.text$mn:00000DAC _text$mn        segment para public 'CODE' use32
.text$mn:00000DAC                 assume cs:_text$mn
.text$mn:00000DAC                 ;org 0DACh
.text$mn:00000DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DAC
.text$mn:00000DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DAC
.text$mn:00000DAC ; Attributes: bp-based frame
.text$mn:00000DAC
.text$mn:00000DAC ; int __stdcall ___construct_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std__V_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_2____allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std__QAEXPAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_1___QAV_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_1__Z(void *, int, int)
.text$mn:00000DAC                 public ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000DAC ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z proc near
.text$mn:00000DAC                                         ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+3Fp
.text$mn:00000DAC
.text$mn:00000DAC var_DC          = dword ptr -0DCh
.text$mn:00000DAC var_D4          = dword ptr -0D4h
.text$mn:00000DAC var_8           = dword ptr -8
.text$mn:00000DAC arg_0           = dword ptr  8
.text$mn:00000DAC arg_4           = dword ptr  0Ch
.text$mn:00000DAC arg_8           = dword ptr  10h
.text$mn:00000DAC
.text$mn:00000DAC                 push    ebp
.text$mn:00000DAD                 mov     ebp, esp
.text$mn:00000DAF                 sub     esp, 0DCh
.text$mn:00000DB5                 push    ebx
.text$mn:00000DB6                 push    esi
.text$mn:00000DB7                 push    edi
.text$mn:00000DB8                 push    ecx
.text$mn:00000DB9                 lea     edi, [ebp+var_DC]
.text$mn:00000DBF                 mov     ecx, 37h ; '7'
.text$mn:00000DC4                 mov     eax, 0CCCCCCCCh
.text$mn:00000DC9                 rep stosd
.text$mn:00000DCB                 pop     ecx
.text$mn:00000DCC                 mov     [ebp+var_8], ecx
.text$mn:00000DCF                 mov     eax, [ebp+arg_0]
.text$mn:00000DD2                 push    eax             ; void *
.text$mn:00000DD3                 push    8               ; unsigned int
.text$mn:00000DD5                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000DDA                 add     esp, 8
.text$mn:00000DDD                 mov     [ebp+var_D4], eax
.text$mn:00000DE3                 cmp     [ebp+var_D4], 0
.text$mn:00000DEA                 jz      short loc_E19
.text$mn:00000DEC                 mov     ecx, [ebp+arg_8]
.text$mn:00000DEF                 push    ecx
.text$mn:00000DF0                 call    ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>(std::allocator<int> const &)
.text$mn:00000DF5                 add     esp, 4
.text$mn:00000DF8                 push    eax
.text$mn:00000DF9                 mov     edx, [ebp+arg_4]
.text$mn:00000DFC                 push    edx
.text$mn:00000DFD                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00000E02                 add     esp, 4
.text$mn:00000E05                 push    eax
.text$mn:00000E06                 mov     ecx, [ebp+var_D4]
.text$mn:00000E0C                 call    ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000E11                 mov     [ebp+var_DC], eax
.text$mn:00000E17                 jmp     short loc_E23
.text$mn:00000E19 ; ---------------------------------------------------------------------------
.text$mn:00000E19
.text$mn:00000E19 loc_E19:                                ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+3Ej
.text$mn:00000E19                 mov     [ebp+var_DC], 0
.text$mn:00000E23
.text$mn:00000E23 loc_E23:                                ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+6Bj
.text$mn:00000E23                 pop     edi
.text$mn:00000E24                 pop     esi
.text$mn:00000E25                 pop     ebx
.text$mn:00000E26                 add     esp, 0DCh
.text$mn:00000E2C                 cmp     ebp, esp
.text$mn:00000E2E                 call    __RTC_CheckEsp
.text$mn:00000E33                 mov     esp, ebp
.text$mn:00000E35                 pop     ebp
.text$mn:00000E36                 retn    0Ch
.text$mn:00000E36 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z endp
.text$mn:00000E36
.text$mn:00000E36 ; ---------------------------------------------------------------------------
.text$mn:00000E39                 align 4
.text$mn:00000E39 _text$mn        ends
.text$mn:00000E39
.text$mn:00000E3C ; ===========================================================================
.text$mn:00000E3C
.text$mn:00000E3C ; Segment type: Pure code
.text$mn:00000E3C ; Segment permissions: Read/Execute
.text$mn:00000E3C _text$mn        segment para public 'CODE' use32
.text$mn:00000E3C                 assume cs:_text$mn
.text$mn:00000E3C                 ;org 0E3Ch
.text$mn:00000E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E3C
.text$mn:00000E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E3C
.text$mn:00000E3C ; Attributes: bp-based frame
.text$mn:00000E3C
.text$mn:00000E3C ; int __cdecl ___construct_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std__V_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_2____allocator_traits_V__allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std___std__SAXAAV__allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___1_PAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_1___QAV_lambda_b6f3cb1c717d8c8a816f87295491882e___ABV__allocator_H_1__Z(int, void *, int, int)
.text$mn:00000E3C                 public ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000E3C ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z proc near
.text$mn:00000E3C                                         ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+45p
.text$mn:00000E3C
.text$mn:00000E3C var_C0          = byte ptr -0C0h
.text$mn:00000E3C arg_0           = dword ptr  8
.text$mn:00000E3C arg_4           = dword ptr  0Ch
.text$mn:00000E3C arg_8           = dword ptr  10h
.text$mn:00000E3C arg_C           = dword ptr  14h
.text$mn:00000E3C
.text$mn:00000E3C                 push    ebp
.text$mn:00000E3D                 mov     ebp, esp
.text$mn:00000E3F                 sub     esp, 0C0h
.text$mn:00000E45                 push    ebx
.text$mn:00000E46                 push    esi
.text$mn:00000E47                 push    edi
.text$mn:00000E48                 lea     edi, [ebp+var_C0]
.text$mn:00000E4E                 mov     ecx, 30h ; '0'
.text$mn:00000E53                 mov     eax, 0CCCCCCCCh
.text$mn:00000E58                 rep stosd
.text$mn:00000E5A                 mov     eax, [ebp+arg_C]
.text$mn:00000E5D                 push    eax
.text$mn:00000E5E                 call    ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>(std::allocator<int> const &)
.text$mn:00000E63                 add     esp, 4
.text$mn:00000E66                 push    eax             ; int
.text$mn:00000E67                 mov     ecx, [ebp+arg_8]
.text$mn:00000E6A                 push    ecx
.text$mn:00000E6B                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00000E70                 add     esp, 4
.text$mn:00000E73                 push    eax             ; int
.text$mn:00000E74                 mov     edx, [ebp+arg_4]
.text$mn:00000E77                 push    edx             ; void *
.text$mn:00000E78                 mov     ecx, [ebp+arg_0]
.text$mn:00000E7B                 call    ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z
.text$mn:00000E80                 pop     edi
.text$mn:00000E81                 pop     esi
.text$mn:00000E82                 pop     ebx
.text$mn:00000E83                 add     esp, 0C0h
.text$mn:00000E89                 cmp     ebp, esp
.text$mn:00000E8B                 call    __RTC_CheckEsp
.text$mn:00000E90                 mov     esp, ebp
.text$mn:00000E92                 pop     ebp
.text$mn:00000E93                 retn
.text$mn:00000E93 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z endp
.text$mn:00000E93
.text$mn:00000E93 _text$mn        ends
.text$mn:00000E93
.text$mn:00000E94 ; ===========================================================================
.text$mn:00000E94
.text$mn:00000E94 ; Segment type: Pure code
.text$mn:00000E94 ; Segment permissions: Read/Execute
.text$mn:00000E94 _text$mn        segment para public 'CODE' use32
.text$mn:00000E94                 assume cs:_text$mn
.text$mn:00000E94                 ;org 0E94h
.text$mn:00000E94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E94
.text$mn:00000E94 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E94
.text$mn:00000E94 ; Attributes: bp-based frame
.text$mn:00000E94
.text$mn:00000E94 ; int __stdcall ___construct_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std__V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_2_____Wrap_alloc_V__allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std___std__QAEXPAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_1___QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_____QAV__allocator_H_1__Z(void *, int, int)
.text$mn:00000E94                 public ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z
.text$mn:00000E94 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z proc near
.text$mn:00000E94                                         ; CODE XREF: ?_Move@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEPAV?$_Func_base@X$$V@2@PAX@Z+65p
.text$mn:00000E94
.text$mn:00000E94 var_CC          = byte ptr -0CCh
.text$mn:00000E94 var_8           = dword ptr -8
.text$mn:00000E94 arg_0           = dword ptr  8
.text$mn:00000E94 arg_4           = dword ptr  0Ch
.text$mn:00000E94 arg_8           = dword ptr  10h
.text$mn:00000E94
.text$mn:00000E94                 push    ebp
.text$mn:00000E95                 mov     ebp, esp
.text$mn:00000E97                 sub     esp, 0CCh
.text$mn:00000E9D                 push    ebx
.text$mn:00000E9E                 push    esi
.text$mn:00000E9F                 push    edi
.text$mn:00000EA0                 push    ecx
.text$mn:00000EA1                 lea     edi, [ebp+var_CC]
.text$mn:00000EA7                 mov     ecx, 33h ; '3'
.text$mn:00000EAC                 mov     eax, 0CCCCCCCCh
.text$mn:00000EB1                 rep stosd
.text$mn:00000EB3                 pop     ecx
.text$mn:00000EB4                 mov     [ebp+var_8], ecx
.text$mn:00000EB7                 mov     eax, [ebp+arg_8]
.text$mn:00000EBA                 push    eax
.text$mn:00000EBB                 call    ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int>>(std::allocator<int> &)
.text$mn:00000EC0                 add     esp, 4
.text$mn:00000EC3                 push    eax             ; int
.text$mn:00000EC4                 mov     ecx, [ebp+arg_4]
.text$mn:00000EC7                 push    ecx
.text$mn:00000EC8                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00000ECD                 add     esp, 4
.text$mn:00000ED0                 push    eax             ; int
.text$mn:00000ED1                 mov     edx, [ebp+arg_0]
.text$mn:00000ED4                 push    edx             ; void *
.text$mn:00000ED5                 mov     eax, [ebp+var_8]
.text$mn:00000ED8                 push    eax             ; int
.text$mn:00000ED9                 call    ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z
.text$mn:00000EDE                 add     esp, 10h
.text$mn:00000EE1                 pop     edi
.text$mn:00000EE2                 pop     esi
.text$mn:00000EE3                 pop     ebx
.text$mn:00000EE4                 add     esp, 0CCh
.text$mn:00000EEA                 cmp     ebp, esp
.text$mn:00000EEC                 call    __RTC_CheckEsp
.text$mn:00000EF1                 mov     esp, ebp
.text$mn:00000EF3                 pop     ebp
.text$mn:00000EF4                 retn    0Ch
.text$mn:00000EF4 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z endp
.text$mn:00000EF4
.text$mn:00000EF4 ; ---------------------------------------------------------------------------
.text$mn:00000EF7                 align 4
.text$mn:00000EF7 _text$mn        ends
.text$mn:00000EF7
.text$mn:00000EF8 ; ===========================================================================
.text$mn:00000EF8
.text$mn:00000EF8 ; Segment type: Pure code
.text$mn:00000EF8 ; Segment permissions: Read/Execute
.text$mn:00000EF8 _text$mn        segment para public 'CODE' use32
.text$mn:00000EF8                 assume cs:_text$mn
.text$mn:00000EF8                 ;org 0EF8h
.text$mn:00000EF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000EF8
.text$mn:00000EF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EF8
.text$mn:00000EF8 ; Attributes: bp-based frame
.text$mn:00000EF8
.text$mn:00000EF8 ; int __stdcall ___construct_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std__V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_2____allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std__QAEXPAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_1___QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_____QAV__allocator_H_1__Z(void *, int, int)
.text$mn:00000EF8                 public ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z
.text$mn:00000EF8 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z proc near
.text$mn:00000EF8                                         ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z+3Fp
.text$mn:00000EF8
.text$mn:00000EF8 var_DC          = dword ptr -0DCh
.text$mn:00000EF8 var_D4          = dword ptr -0D4h
.text$mn:00000EF8 var_8           = dword ptr -8
.text$mn:00000EF8 arg_0           = dword ptr  8
.text$mn:00000EF8 arg_4           = dword ptr  0Ch
.text$mn:00000EF8 arg_8           = dword ptr  10h
.text$mn:00000EF8
.text$mn:00000EF8                 push    ebp
.text$mn:00000EF9                 mov     ebp, esp
.text$mn:00000EFB                 sub     esp, 0DCh
.text$mn:00000F01                 push    ebx
.text$mn:00000F02                 push    esi
.text$mn:00000F03                 push    edi
.text$mn:00000F04                 push    ecx
.text$mn:00000F05                 lea     edi, [ebp+var_DC]
.text$mn:00000F0B                 mov     ecx, 37h ; '7'
.text$mn:00000F10                 mov     eax, 0CCCCCCCCh
.text$mn:00000F15                 rep stosd
.text$mn:00000F17                 pop     ecx
.text$mn:00000F18                 mov     [ebp+var_8], ecx
.text$mn:00000F1B                 mov     eax, [ebp+arg_0]
.text$mn:00000F1E                 push    eax             ; void *
.text$mn:00000F1F                 push    8               ; unsigned int
.text$mn:00000F21                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000F26                 add     esp, 8
.text$mn:00000F29                 mov     [ebp+var_D4], eax
.text$mn:00000F2F                 cmp     [ebp+var_D4], 0
.text$mn:00000F36                 jz      short loc_F65
.text$mn:00000F38                 mov     ecx, [ebp+arg_8]
.text$mn:00000F3B                 push    ecx
.text$mn:00000F3C                 call    ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int>>(std::allocator<int> &)
.text$mn:00000F41                 add     esp, 4
.text$mn:00000F44                 push    eax
.text$mn:00000F45                 mov     edx, [ebp+arg_4]
.text$mn:00000F48                 push    edx
.text$mn:00000F49                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00000F4E                 add     esp, 4
.text$mn:00000F51                 push    eax
.text$mn:00000F52                 mov     ecx, [ebp+var_D4]
.text$mn:00000F58                 call    ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z
.text$mn:00000F5D                 mov     [ebp+var_DC], eax
.text$mn:00000F63                 jmp     short loc_F6F
.text$mn:00000F65 ; ---------------------------------------------------------------------------
.text$mn:00000F65
.text$mn:00000F65 loc_F65:                                ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z+3Ej
.text$mn:00000F65                 mov     [ebp+var_DC], 0
.text$mn:00000F6F
.text$mn:00000F6F loc_F6F:                                ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z+6Bj
.text$mn:00000F6F                 pop     edi
.text$mn:00000F70                 pop     esi
.text$mn:00000F71                 pop     ebx
.text$mn:00000F72                 add     esp, 0DCh
.text$mn:00000F78                 cmp     ebp, esp
.text$mn:00000F7A                 call    __RTC_CheckEsp
.text$mn:00000F7F                 mov     esp, ebp
.text$mn:00000F81                 pop     ebp
.text$mn:00000F82                 retn    0Ch
.text$mn:00000F82 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z endp
.text$mn:00000F82
.text$mn:00000F82 ; ---------------------------------------------------------------------------
.text$mn:00000F85                 align 4
.text$mn:00000F85 _text$mn        ends
.text$mn:00000F85
.text$mn:00000F88 ; ===========================================================================
.text$mn:00000F88
.text$mn:00000F88 ; Segment type: Pure code
.text$mn:00000F88 ; Segment permissions: Read/Execute
.text$mn:00000F88 _text$mn        segment para public 'CODE' use32
.text$mn:00000F88                 assume cs:_text$mn
.text$mn:00000F88                 ;org 0F88h
.text$mn:00000F88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F88
.text$mn:00000F88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F88
.text$mn:00000F88 ; Attributes: bp-based frame
.text$mn:00000F88
.text$mn:00000F88 ; int __cdecl ___construct_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std__V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_2____allocator_traits_V__allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std___std__SAXAAV__allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___1_PAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_1___QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_____QAV__allocator_H_1__Z(int, void *, int, int)
.text$mn:00000F88                 public ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z
.text$mn:00000F88 ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z proc near
.text$mn:00000F88                                         ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z+45p
.text$mn:00000F88
.text$mn:00000F88 var_C0          = byte ptr -0C0h
.text$mn:00000F88 arg_0           = dword ptr  8
.text$mn:00000F88 arg_4           = dword ptr  0Ch
.text$mn:00000F88 arg_8           = dword ptr  10h
.text$mn:00000F88 arg_C           = dword ptr  14h
.text$mn:00000F88
.text$mn:00000F88                 push    ebp
.text$mn:00000F89                 mov     ebp, esp
.text$mn:00000F8B                 sub     esp, 0C0h
.text$mn:00000F91                 push    ebx
.text$mn:00000F92                 push    esi
.text$mn:00000F93                 push    edi
.text$mn:00000F94                 lea     edi, [ebp+var_C0]
.text$mn:00000F9A                 mov     ecx, 30h ; '0'
.text$mn:00000F9F                 mov     eax, 0CCCCCCCCh ; DATA XREF: RunMessageLoop(void)+20o
.text$mn:00000FA4                 rep stosd
.text$mn:00000FA6                 mov     eax, [ebp+arg_C]
.text$mn:00000FA9                 push    eax
.text$mn:00000FAA                 call    ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int>>(std::allocator<int> &)
.text$mn:00000FAF                 add     esp, 4
.text$mn:00000FB2                 push    eax             ; int
.text$mn:00000FB3                 mov     ecx, [ebp+arg_8]
.text$mn:00000FB6                 push    ecx
.text$mn:00000FB7                 call    ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00000FBC                 add     esp, 4
.text$mn:00000FBF                 push    eax             ; int
.text$mn:00000FC0                 mov     edx, [ebp+arg_4]
.text$mn:00000FC3                 push    edx             ; void *
.text$mn:00000FC4                 mov     ecx, [ebp+arg_0]
.text$mn:00000FC7                 call    ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z
.text$mn:00000FCC                 pop     edi
.text$mn:00000FCD                 pop     esi
.text$mn:00000FCE                 pop     ebx
.text$mn:00000FCF                 add     esp, 0C0h
.text$mn:00000FD5                 cmp     ebp, esp
.text$mn:00000FD7                 call    __RTC_CheckEsp
.text$mn:00000FDC                 mov     esp, ebp
.text$mn:00000FDE                 pop     ebp
.text$mn:00000FDF                 retn
.text$mn:00000FDF ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z endp
.text$mn:00000FDF
.text$mn:00000FDF _text$mn        ends
.text$mn:00000FDF
.text$mn:00000FE0 ; ===========================================================================
.text$mn:00000FE0
.text$mn:00000FE0 ; Segment type: Pure code
.text$mn:00000FE0 ; Segment permissions: Read/Execute
.text$mn:00000FE0 _text$mn        segment para public 'CODE' use32
.text$mn:00000FE0                 assume cs:_text$mn
.text$mn:00000FE0                 ;org 0FE0h
.text$mn:00000FE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FE0
.text$mn:00000FE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FE0
.text$mn:00000FE0 ; Attributes: bp-based frame
.text$mn:00000FE0
.text$mn:00000FE0                 public ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z
.text$mn:00000FE0 ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z proc near
.text$mn:00000FE0                                         ; CODE XREF: ?_Delete_this@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEX_N@Z+3Bp
.text$mn:00000FE0
.text$mn:00000FE0 var_CC          = byte ptr -0CCh
.text$mn:00000FE0 var_8           = dword ptr -8
.text$mn:00000FE0 arg_0           = dword ptr  8
.text$mn:00000FE0
.text$mn:00000FE0                 push    ebp
.text$mn:00000FE1                 mov     ebp, esp
.text$mn:00000FE3                 sub     esp, 0CCh
.text$mn:00000FE9                 push    ebx
.text$mn:00000FEA                 push    esi
.text$mn:00000FEB                 push    edi
.text$mn:00000FEC                 push    ecx
.text$mn:00000FED                 lea     edi, [ebp+var_CC]
.text$mn:00000FF3                 mov     ecx, 33h ; '3'
.text$mn:00000FF8                 mov     eax, 0CCCCCCCCh
.text$mn:00000FFD                 rep stosd
.text$mn:00000FFF                 pop     ecx
.text$mn:00001000                 mov     [ebp+var_8], ecx
.text$mn:00001003                 mov     eax, [ebp+arg_0]
.text$mn:00001006                 push    eax
.text$mn:00001007                 mov     ecx, [ebp+var_8]
.text$mn:0000100A                 push    ecx
.text$mn:0000100B                 call    ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z
.text$mn:00001010                 add     esp, 8
.text$mn:00001013                 pop     edi
.text$mn:00001014                 pop     esi
.text$mn:00001015                 pop     ebx
.text$mn:00001016                 add     esp, 0CCh
.text$mn:0000101C                 cmp     ebp, esp
.text$mn:0000101E                 call    __RTC_CheckEsp
.text$mn:00001023                 mov     esp, ebp
.text$mn:00001025                 pop     ebp
.text$mn:00001026                 retn    4
.text$mn:00001026 ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z endp
.text$mn:00001026
.text$mn:00001026 ; ---------------------------------------------------------------------------
.text$mn:00001029                 align 4
.text$mn:00001029 _text$mn        ends
.text$mn:00001029
.text$mn:0000102C ; ===========================================================================
.text$mn:0000102C
.text$mn:0000102C ; Segment type: Pure code
.text$mn:0000102C ; Segment permissions: Read/Execute
.text$mn:0000102C _text$mn        segment para public 'CODE' use32
.text$mn:0000102C                 assume cs:_text$mn
.text$mn:0000102C                 ;org 102Ch
.text$mn:0000102C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000102C
.text$mn:0000102C ; =============== S U B R O U T I N E =======================================
.text$mn:0000102C
.text$mn:0000102C ; Attributes: bp-based frame
.text$mn:0000102C
.text$mn:0000102C                 public ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z
.text$mn:0000102C ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z proc near
.text$mn:0000102C                                         ; CODE XREF: ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z+25p
.text$mn:0000102C
.text$mn:0000102C var_CC          = byte ptr -0CCh
.text$mn:0000102C var_8           = dword ptr -8
.text$mn:0000102C arg_0           = dword ptr  8
.text$mn:0000102C
.text$mn:0000102C                 push    ebp
.text$mn:0000102D                 mov     ebp, esp
.text$mn:0000102F                 sub     esp, 0CCh
.text$mn:00001035                 push    ebx
.text$mn:00001036                 push    esi
.text$mn:00001037                 push    edi
.text$mn:00001038                 push    ecx
.text$mn:00001039                 lea     edi, [ebp+var_CC]
.text$mn:0000103F                 mov     ecx, 33h ; '3'
.text$mn:00001044                 mov     eax, 0CCCCCCCCh
.text$mn:00001049                 rep stosd
.text$mn:0000104B                 pop     ecx
.text$mn:0000104C                 mov     [ebp+var_8], ecx
.text$mn:0000104F                 push    0
.text$mn:00001051                 mov     ecx, [ebp+arg_0]
.text$mn:00001054                 call    ??_G?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAEPAXI@Z
.text$mn:00001059                 pop     edi
.text$mn:0000105A                 pop     esi
.text$mn:0000105B                 pop     ebx
.text$mn:0000105C                 add     esp, 0CCh
.text$mn:00001062                 cmp     ebp, esp
.text$mn:00001064                 call    __RTC_CheckEsp
.text$mn:00001069                 mov     esp, ebp
.text$mn:0000106B                 pop     ebp
.text$mn:0000106C                 retn    4
.text$mn:0000106C ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z endp
.text$mn:0000106C
.text$mn:0000106C ; ---------------------------------------------------------------------------
.text$mn:0000106F                 align 10h
.text$mn:0000106F _text$mn        ends
.text$mn:0000106F
.text$mn:00001070 ; ===========================================================================
.text$mn:00001070
.text$mn:00001070 ; Segment type: Pure code
.text$mn:00001070 ; Segment permissions: Read/Execute
.text$mn:00001070 _text$mn        segment para public 'CODE' use32
.text$mn:00001070                 assume cs:_text$mn
.text$mn:00001070                 ;org 1070h
.text$mn:00001070                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001070
.text$mn:00001070 ; =============== S U B R O U T I N E =======================================
.text$mn:00001070
.text$mn:00001070 ; Attributes: bp-based frame
.text$mn:00001070
.text$mn:00001070                 public ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z
.text$mn:00001070 ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z proc near
.text$mn:00001070                                         ; CODE XREF: ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z+2Bp
.text$mn:00001070
.text$mn:00001070 var_C0          = byte ptr -0C0h
.text$mn:00001070 arg_0           = dword ptr  8
.text$mn:00001070 arg_4           = dword ptr  0Ch
.text$mn:00001070
.text$mn:00001070                 push    ebp
.text$mn:00001071                 mov     ebp, esp
.text$mn:00001073                 sub     esp, 0C0h
.text$mn:00001079                 push    ebx
.text$mn:0000107A                 push    esi
.text$mn:0000107B                 push    edi
.text$mn:0000107C                 lea     edi, [ebp+var_C0]
.text$mn:00001082                 mov     ecx, 30h ; '0'
.text$mn:00001087                 mov     eax, 0CCCCCCCCh
.text$mn:0000108C                 rep stosd
.text$mn:0000108E                 mov     eax, [ebp+arg_4]
.text$mn:00001091                 push    eax
.text$mn:00001092                 mov     ecx, [ebp+arg_0]
.text$mn:00001095                 call    ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z
.text$mn:0000109A                 pop     edi
.text$mn:0000109B                 pop     esi
.text$mn:0000109C                 pop     ebx
.text$mn:0000109D                 add     esp, 0C0h
.text$mn:000010A3                 cmp     ebp, esp
.text$mn:000010A5                 call    __RTC_CheckEsp
.text$mn:000010AA                 mov     esp, ebp
.text$mn:000010AC                 pop     ebp
.text$mn:000010AD                 retn
.text$mn:000010AD ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$allocator_traits@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@SAXAAV?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z endp
.text$mn:000010AD
.text$mn:000010AD ; ---------------------------------------------------------------------------
.text$mn:000010AE                 align 10h
.text$mn:000010AE _text$mn        ends
.text$mn:000010AE
.text$mn:000010B0 ; ===========================================================================
.text$mn:000010B0
.text$mn:000010B0 ; Segment type: Pure code
.text$mn:000010B0 ; Segment permissions: Read/Execute
.text$mn:000010B0 _text$mn        segment para public 'CODE' use32
.text$mn:000010B0                 assume cs:_text$mn
.text$mn:000010B0                 ;org 10B0h
.text$mn:000010B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010B0
.text$mn:000010B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000010B0
.text$mn:000010B0 ; Attributes: bp-based frame
.text$mn:000010B0
.text$mn:000010B0 ; class _lambda_b6f3cb1c717d8c8a816f87295491882e_ & __cdecl std::forward<class _lambda_b6f3cb1c717d8c8a816f87295491882e_ &>(class _lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:000010B0                 public ??$forward@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z
.text$mn:000010B0 ??$forward@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z proc near
.text$mn:000010B0                                         ; CODE XREF: ??$_Call@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$V@_Invoker_functor@std@@SAXAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z+22p
.text$mn:000010B0                                         ; std::_Invoke_ret<void,_lambda_b6f3cb1c717d8c8a816f87295491882e_ &>(std::_Forced<void,1>,_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)+22p ...
.text$mn:000010B0
.text$mn:000010B0 var_C0          = byte ptr -0C0h
.text$mn:000010B0 arg_0           = dword ptr  8
.text$mn:000010B0
.text$mn:000010B0                 push    ebp
.text$mn:000010B1                 mov     ebp, esp
.text$mn:000010B3                 sub     esp, 0C0h
.text$mn:000010B9                 push    ebx
.text$mn:000010BA                 push    esi
.text$mn:000010BB                 push    edi
.text$mn:000010BC                 lea     edi, [ebp+var_C0]
.text$mn:000010C2                 mov     ecx, 30h ; '0'
.text$mn:000010C7                 mov     eax, 0CCCCCCCCh
.text$mn:000010CC                 rep stosd
.text$mn:000010CE                 mov     eax, [ebp+arg_0]
.text$mn:000010D1                 pop     edi
.text$mn:000010D2                 pop     esi
.text$mn:000010D3                 pop     ebx
.text$mn:000010D4                 mov     esp, ebp
.text$mn:000010D6                 pop     ebp
.text$mn:000010D7                 retn
.text$mn:000010D7 ??$forward@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z endp
.text$mn:000010D7
.text$mn:000010D7 _text$mn        ends
.text$mn:000010D7
.text$mn:000010D8 ; ===========================================================================
.text$mn:000010D8
.text$mn:000010D8 ; Segment type: Pure code
.text$mn:000010D8 ; Segment permissions: Read/Execute
.text$mn:000010D8 _text$mn        segment para public 'CODE' use32
.text$mn:000010D8                 assume cs:_text$mn
.text$mn:000010D8                 ;org 10D8h
.text$mn:000010D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010D8
.text$mn:000010D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000010D8
.text$mn:000010D8 ; Attributes: bp-based frame
.text$mn:000010D8
.text$mn:000010D8 ; unsigned int const & __cdecl std::forward<unsigned int const &>(unsigned int const &)
.text$mn:000010D8                 public ??$forward@ABI@std@@YAABIABI@Z
.text$mn:000010D8 ??$forward@ABI@std@@YAABIABI@Z proc near
.text$mn:000010D8                                         ; CODE XREF: std::_Debug_lt<uint const &,uint const &>(uint const &,uint const &,wchar_t const *,uint)+2Ap
.text$mn:000010D8                                         ; std::_Debug_lt<uint const &,uint const &>(uint const &,uint const &,wchar_t const *,uint)+37p
.text$mn:000010D8
.text$mn:000010D8 var_C0          = byte ptr -0C0h
.text$mn:000010D8 arg_0           = dword ptr  8
.text$mn:000010D8
.text$mn:000010D8                 push    ebp
.text$mn:000010D9                 mov     ebp, esp
.text$mn:000010DB                 sub     esp, 0C0h
.text$mn:000010E1                 push    ebx
.text$mn:000010E2                 push    esi
.text$mn:000010E3                 push    edi
.text$mn:000010E4                 lea     edi, [ebp+var_C0]
.text$mn:000010EA                 mov     ecx, 30h ; '0'
.text$mn:000010EF                 mov     eax, 0CCCCCCCCh
.text$mn:000010F4                 rep stosd
.text$mn:000010F6                 mov     eax, [ebp+arg_0]
.text$mn:000010F9                 pop     edi
.text$mn:000010FA                 pop     esi
.text$mn:000010FB                 pop     ebx
.text$mn:000010FC                 mov     esp, ebp
.text$mn:000010FE                 pop     ebp
.text$mn:000010FF                 retn
.text$mn:000010FF ??$forward@ABI@std@@YAABIABI@Z endp
.text$mn:000010FF
.text$mn:000010FF _text$mn        ends
.text$mn:000010FF
.text$mn:00001100 ; ===========================================================================
.text$mn:00001100
.text$mn:00001100 ; Segment type: Pure code
.text$mn:00001100 ; Segment permissions: Read/Execute
.text$mn:00001100 _text$mn        segment para public 'CODE' use32
.text$mn:00001100                 assume cs:_text$mn
.text$mn:00001100                 ;org 1100h
.text$mn:00001100                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001100
.text$mn:00001100 ; =============== S U B R O U T I N E =======================================
.text$mn:00001100
.text$mn:00001100 ; Attributes: bp-based frame
.text$mn:00001100
.text$mn:00001100 ; class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const & __cdecl std::forward<class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const &>(class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:00001100                 public ??$forward@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z
.text$mn:00001100 ??$forward@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z proc near
.text$mn:00001100                                         ; CODE XREF: ??$?0ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+38p
.text$mn:00001100                                         ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>(std::_One_then_variadic_args_t,std::allocator<int> const &,_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)+3Cp ...
.text$mn:00001100
.text$mn:00001100 var_C0          = byte ptr -0C0h
.text$mn:00001100 arg_0           = dword ptr  8
.text$mn:00001100
.text$mn:00001100                 push    ebp
.text$mn:00001101                 mov     ebp, esp
.text$mn:00001103                 sub     esp, 0C0h
.text$mn:00001109                 push    ebx
.text$mn:0000110A                 push    esi
.text$mn:0000110B                 push    edi
.text$mn:0000110C                 lea     edi, [ebp+var_C0]
.text$mn:00001112                 mov     ecx, 30h ; '0'
.text$mn:00001117                 mov     eax, 0CCCCCCCCh
.text$mn:0000111C                 rep stosd
.text$mn:0000111E                 mov     eax, [ebp+arg_0]
.text$mn:00001121                 pop     edi
.text$mn:00001122                 pop     esi
.text$mn:00001123                 pop     ebx
.text$mn:00001124                 mov     esp, ebp
.text$mn:00001126                 pop     ebp
.text$mn:00001127                 retn
.text$mn:00001127 ??$forward@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z endp
.text$mn:00001127
.text$mn:00001127 _text$mn        ends
.text$mn:00001127
.text$mn:00001128 ; ===========================================================================
.text$mn:00001128
.text$mn:00001128 ; Segment type: Pure code
.text$mn:00001128 ; Segment permissions: Read/Execute
.text$mn:00001128 _text$mn        segment para public 'CODE' use32
.text$mn:00001128                 assume cs:_text$mn
.text$mn:00001128                 ;org 1128h
.text$mn:00001128                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001128
.text$mn:00001128 ; =============== S U B R O U T I N E =======================================
.text$mn:00001128
.text$mn:00001128 ; Attributes: bp-based frame
.text$mn:00001128
.text$mn:00001128 ; class std::allocator<int> const & __cdecl std::forward<class std::allocator<int> const &>(class std::allocator<int> const &)
.text$mn:00001128                 public ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z
.text$mn:00001128 ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z proc near
.text$mn:00001128                                         ; CODE XREF: ??$?0ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+45p
.text$mn:00001128                                         ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>(std::_One_then_variadic_args_t,std::allocator<int> const &,_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)+27p ...
.text$mn:00001128
.text$mn:00001128 var_C0          = byte ptr -0C0h
.text$mn:00001128 arg_0           = dword ptr  8
.text$mn:00001128
.text$mn:00001128                 push    ebp
.text$mn:00001129                 mov     ebp, esp
.text$mn:0000112B                 sub     esp, 0C0h
.text$mn:00001131                 push    ebx
.text$mn:00001132                 push    esi
.text$mn:00001133                 push    edi
.text$mn:00001134                 lea     edi, [ebp+var_C0]
.text$mn:0000113A                 mov     ecx, 30h ; '0'
.text$mn:0000113F                 mov     eax, 0CCCCCCCCh
.text$mn:00001144                 rep stosd
.text$mn:00001146                 mov     eax, [ebp+arg_0]
.text$mn:00001149                 pop     edi
.text$mn:0000114A                 pop     esi
.text$mn:0000114B                 pop     ebx
.text$mn:0000114C                 mov     esp, ebp
.text$mn:0000114E                 pop     ebp
.text$mn:0000114F                 retn
.text$mn:0000114F ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z endp
.text$mn:0000114F
.text$mn:0000114F _text$mn        ends
.text$mn:0000114F
.text$mn:00001150 ; ===========================================================================
.text$mn:00001150
.text$mn:00001150 ; Segment type: Pure code
.text$mn:00001150 ; Segment permissions: Read/Execute
.text$mn:00001150 _text$mn        segment para public 'CODE' use32
.text$mn:00001150                 assume cs:_text$mn
.text$mn:00001150                 ;org 1150h
.text$mn:00001150                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001150
.text$mn:00001150 ; =============== S U B R O U T I N E =======================================
.text$mn:00001150
.text$mn:00001150 ; Attributes: bp-based frame
.text$mn:00001150
.text$mn:00001150 ; class _lambda_b6f3cb1c717d8c8a816f87295491882e_ && __cdecl std::forward<class _lambda_b6f3cb1c717d8c8a816f87295491882e_>(class _lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00001150                 public ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z
.text$mn:00001150 ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z proc near
.text$mn:00001150                                         ; CODE XREF: std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>(std::_One_then_variadic_args_t,std::allocator<int> const &,_lambda_b6f3cb1c717d8c8a816f87295491882e_ &&)+3Cp
.text$mn:00001150                                         ; ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+38p ...
.text$mn:00001150
.text$mn:00001150 var_C0          = byte ptr -0C0h
.text$mn:00001150 arg_0           = dword ptr  8
.text$mn:00001150
.text$mn:00001150                 push    ebp
.text$mn:00001151                 mov     ebp, esp
.text$mn:00001153                 sub     esp, 0C0h
.text$mn:00001159                 push    ebx
.text$mn:0000115A                 push    esi
.text$mn:0000115B                 push    edi
.text$mn:0000115C                 lea     edi, [ebp+var_C0]
.text$mn:00001162                 mov     ecx, 30h ; '0'
.text$mn:00001167                 mov     eax, 0CCCCCCCCh
.text$mn:0000116C                 rep stosd
.text$mn:0000116E                 mov     eax, [ebp+arg_0]
.text$mn:00001171                 pop     edi
.text$mn:00001172                 pop     esi
.text$mn:00001173                 pop     ebx
.text$mn:00001174                 mov     esp, ebp
.text$mn:00001176                 pop     ebp
.text$mn:00001177                 retn
.text$mn:00001177 ??$forward@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z endp
.text$mn:00001177
.text$mn:00001177 _text$mn        ends
.text$mn:00001177
.text$mn:00001178 ; ===========================================================================
.text$mn:00001178
.text$mn:00001178 ; Segment type: Pure code
.text$mn:00001178 ; Segment permissions: Read/Execute
.text$mn:00001178 _text$mn        segment para public 'CODE' use32
.text$mn:00001178                 assume cs:_text$mn
.text$mn:00001178                 ;org 1178h
.text$mn:00001178                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001178
.text$mn:00001178 ; =============== S U B R O U T I N E =======================================
.text$mn:00001178
.text$mn:00001178 ; Attributes: bp-based frame
.text$mn:00001178
.text$mn:00001178 ; class std::allocator<int> && __cdecl std::forward<class std::allocator<int>>(class std::allocator<int> &)
.text$mn:00001178                 public ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z
.text$mn:00001178 ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z proc near
.text$mn:00001178                                         ; CODE XREF: ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z+45p
.text$mn:00001178                                         ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>(std::_One_then_variadic_args_t,std::allocator<int> &&,_lambda_b6f3cb1c717d8c8a816f87295491882e_ &&)+27p ...
.text$mn:00001178
.text$mn:00001178 var_C0          = byte ptr -0C0h
.text$mn:00001178 arg_0           = dword ptr  8
.text$mn:00001178
.text$mn:00001178                 push    ebp
.text$mn:00001179                 mov     ebp, esp
.text$mn:0000117B                 sub     esp, 0C0h
.text$mn:00001181                 push    ebx
.text$mn:00001182                 push    esi
.text$mn:00001183                 push    edi
.text$mn:00001184                 lea     edi, [ebp+var_C0]
.text$mn:0000118A                 mov     ecx, 30h ; '0'
.text$mn:0000118F                 mov     eax, 0CCCCCCCCh
.text$mn:00001194                 rep stosd
.text$mn:00001196                 mov     eax, [ebp+arg_0]
.text$mn:00001199                 pop     edi
.text$mn:0000119A                 pop     esi
.text$mn:0000119B                 pop     ebx
.text$mn:0000119C                 mov     esp, ebp
.text$mn:0000119E                 pop     ebp
.text$mn:0000119F                 retn
.text$mn:0000119F ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z endp
.text$mn:0000119F
.text$mn:0000119F _text$mn        ends
.text$mn:0000119F
.text$mn:000011A0 ; ===========================================================================
.text$mn:000011A0
.text$mn:000011A0 ; Segment type: Pure code
.text$mn:000011A0 ; Segment permissions: Read/Execute
.text$mn:000011A0 _text$mn        segment para public 'CODE' use32
.text$mn:000011A0                 assume cs:_text$mn
.text$mn:000011A0                 ;org 11A0h
.text$mn:000011A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011A0
.text$mn:000011A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011A0
.text$mn:000011A0 ; Attributes: bp-based frame
.text$mn:000011A0
.text$mn:000011A0                 public ??$invoke@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$V@std@@YAXAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:000011A0 ??$invoke@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$V@std@@YAXAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z proc near
.text$mn:000011A0                                         ; CODE XREF: std::_Invoke_ret<void,_lambda_b6f3cb1c717d8c8a816f87295491882e_ &>(std::_Forced<void,1>,_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)+2Bp
.text$mn:000011A0
.text$mn:000011A0 var_C0          = byte ptr -0C0h
.text$mn:000011A0 arg_0           = dword ptr  8
.text$mn:000011A0
.text$mn:000011A0                 push    ebp
.text$mn:000011A1                 mov     ebp, esp
.text$mn:000011A3                 sub     esp, 0C0h
.text$mn:000011A9                 push    ebx
.text$mn:000011AA                 push    esi
.text$mn:000011AB                 push    edi
.text$mn:000011AC                 lea     edi, [ebp+var_C0]
.text$mn:000011B2                 mov     ecx, 30h ; '0'
.text$mn:000011B7                 mov     eax, 0CCCCCCCCh
.text$mn:000011BC                 rep stosd
.text$mn:000011BE                 mov     eax, [ebp+arg_0]
.text$mn:000011C1                 push    eax
.text$mn:000011C2                 call    ??$forward@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::forward<_lambda_b6f3cb1c717d8c8a816f87295491882e_ &>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:000011C7                 add     esp, 4
.text$mn:000011CA                 push    eax
.text$mn:000011CB                 call    ??$_Call@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$V@_Invoker_functor@std@@SAXAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z
.text$mn:000011D0                 add     esp, 4
.text$mn:000011D3                 pop     edi
.text$mn:000011D4                 pop     esi
.text$mn:000011D5                 pop     ebx
.text$mn:000011D6                 add     esp, 0C0h
.text$mn:000011DC                 cmp     ebp, esp
.text$mn:000011DE                 call    __RTC_CheckEsp
.text$mn:000011E3                 mov     esp, ebp
.text$mn:000011E5                 pop     ebp
.text$mn:000011E6                 retn
.text$mn:000011E6 ??$invoke@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$V@std@@YAXAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z endp
.text$mn:000011E6
.text$mn:000011E6 ; ---------------------------------------------------------------------------
.text$mn:000011E7                 align 4
.text$mn:000011E7 _text$mn        ends
.text$mn:000011E7
.text$mn:000011E8 ; ===========================================================================
.text$mn:000011E8
.text$mn:000011E8 ; Segment type: Pure code
.text$mn:000011E8 ; Segment permissions: Read/Execute
.text$mn:000011E8 _text$mn        segment para public 'CODE' use32
.text$mn:000011E8                 assume cs:_text$mn
.text$mn:000011E8                 ;org 11E8h
.text$mn:000011E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011E8
.text$mn:000011E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000011E8
.text$mn:000011E8 ; Attributes: bp-based frame
.text$mn:000011E8
.text$mn:000011E8 ; unsigned int const & __cdecl std::max<unsigned int>(unsigned int const &, unsigned int const &)
.text$mn:000011E8                 public ??$max@I@std@@YAABIABI0@Z
.text$mn:000011E8 ??$max@I@std@@YAABIABI0@Z proc near     ; CODE XREF: Vec<wchar_t *>::MakeSpaceAt(uint,uint,bool)+2Bp
.text$mn:000011E8                                         ; Vec<wchar_t>::MakeSpaceAt(uint,uint,bool)+2Bp
.text$mn:000011E8
.text$mn:000011E8 var_D0          = dword ptr -0D0h
.text$mn:000011E8 var_C8          = dword ptr -0C8h
.text$mn:000011E8 arg_0           = dword ptr  8
.text$mn:000011E8 arg_4           = dword ptr  0Ch
.text$mn:000011E8
.text$mn:000011E8                 push    ebp
.text$mn:000011E9                 mov     ebp, esp
.text$mn:000011EB                 sub     esp, 0D0h
.text$mn:000011F1                 push    ebx
.text$mn:000011F2                 push    esi
.text$mn:000011F3                 push    edi
.text$mn:000011F4                 lea     edi, [ebp+var_D0]
.text$mn:000011FA                 mov     ecx, 34h ; '4'
.text$mn:000011FF                 mov     eax, 0CCCCCCCCh
.text$mn:00001204                 rep stosd
.text$mn:00001206                 push    102Eh           ; unsigned int
.text$mn:0000120B                 push    offset ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "c:\\program files (x86)\\microsoft visu"...
.text$mn:00001210                 mov     eax, [ebp+arg_4]
.text$mn:00001213                 push    eax             ; int
.text$mn:00001214                 mov     ecx, [ebp+arg_0]
.text$mn:00001217                 push    ecx             ; int
.text$mn:00001218                 call    ??$_Debug_lt@ABIABI@std@@YA_NABI0PB_WI@Z ; std::_Debug_lt<uint const &,uint const &>(uint const &,uint const &,wchar_t const *,uint)
.text$mn:0000121D                 add     esp, 10h
.text$mn:00001220                 movzx   edx, al
.text$mn:00001223                 test    edx, edx
.text$mn:00001225                 jz      short loc_1232
.text$mn:00001227                 mov     eax, [ebp+arg_4]
.text$mn:0000122A                 mov     [ebp+var_D0], eax
.text$mn:00001230                 jmp     short loc_123B
.text$mn:00001232 ; ---------------------------------------------------------------------------
.text$mn:00001232
.text$mn:00001232 loc_1232:                               ; CODE XREF: std::max<uint>(uint const &,uint const &)+3Dj
.text$mn:00001232                 mov     ecx, [ebp+arg_0]
.text$mn:00001235                 mov     [ebp+var_D0], ecx
.text$mn:0000123B
.text$mn:0000123B loc_123B:                               ; CODE XREF: std::max<uint>(uint const &,uint const &)+48j
.text$mn:0000123B                 mov     edx, [ebp+var_D0]
.text$mn:00001241                 mov     [ebp+var_C8], edx
.text$mn:00001247                 mov     eax, [ebp+var_C8]
.text$mn:0000124D                 pop     edi
.text$mn:0000124E                 pop     esi
.text$mn:0000124F                 pop     ebx
.text$mn:00001250                 add     esp, 0D0h
.text$mn:00001256                 cmp     ebp, esp
.text$mn:00001258                 call    __RTC_CheckEsp
.text$mn:0000125D                 mov     esp, ebp
.text$mn:0000125F                 pop     ebp
.text$mn:00001260                 retn
.text$mn:00001260 ??$max@I@std@@YAABIABI0@Z endp
.text$mn:00001260
.text$mn:00001260 ; ---------------------------------------------------------------------------
.text$mn:00001261                 align 4
.text$mn:00001261 _text$mn        ends
.text$mn:00001261
.text$mn:00001264 ; ===========================================================================
.text$mn:00001264
.text$mn:00001264 ; Segment type: Pure code
.text$mn:00001264 ; Segment permissions: Read/Execute
.text$mn:00001264 _text$mn        segment para public 'CODE' use32
.text$mn:00001264                 assume cs:_text$mn
.text$mn:00001264                 ;org 1264h
.text$mn:00001264                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001264
.text$mn:00001264 ; =============== S U B R O U T I N E =======================================
.text$mn:00001264
.text$mn:00001264 ; Attributes: bp-based frame
.text$mn:00001264
.text$mn:00001264 ; class _lambda_b6f3cb1c717d8c8a816f87295491882e_ && __cdecl std::move<class _lambda_b6f3cb1c717d8c8a816f87295491882e_ &>(class _lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00001264                 public ??$move@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z
.text$mn:00001264 ??$move@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z proc near
.text$mn:00001264                                         ; CODE XREF: std::function<void (void)>::function<void (void)>(_lambda_b6f3cb1c717d8c8a816f87295491882e_)+2Fp
.text$mn:00001264                                         ; ?_Move@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEPAV?$_Func_base@X$$V@2@PAX@Z+55p
.text$mn:00001264
.text$mn:00001264 var_C0          = byte ptr -0C0h
.text$mn:00001264 arg_0           = dword ptr  8
.text$mn:00001264
.text$mn:00001264                 push    ebp
.text$mn:00001265                 mov     ebp, esp
.text$mn:00001267                 sub     esp, 0C0h
.text$mn:0000126D                 push    ebx
.text$mn:0000126E                 push    esi
.text$mn:0000126F                 push    edi
.text$mn:00001270                 lea     edi, [ebp+var_C0]
.text$mn:00001276                 mov     ecx, 30h ; '0'
.text$mn:0000127B                 mov     eax, 0CCCCCCCCh
.text$mn:00001280                 rep stosd
.text$mn:00001282                 mov     eax, [ebp+arg_0]
.text$mn:00001285                 pop     edi
.text$mn:00001286                 pop     esi
.text$mn:00001287                 pop     ebx
.text$mn:00001288                 mov     esp, ebp
.text$mn:0000128A                 pop     ebp
.text$mn:0000128B                 retn
.text$mn:0000128B ??$move@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z endp
.text$mn:0000128B
.text$mn:0000128B _text$mn        ends
.text$mn:0000128B
.text$mn:0000128C ; ===========================================================================
.text$mn:0000128C
.text$mn:0000128C ; Segment type: Pure code
.text$mn:0000128C ; Segment permissions: Read/Execute
.text$mn:0000128C _text$mn        segment para public 'CODE' use32
.text$mn:0000128C                 assume cs:_text$mn
.text$mn:0000128C                 ;org 128Ch
.text$mn:0000128C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000128C
.text$mn:0000128C ; =============== S U B R O U T I N E =======================================
.text$mn:0000128C
.text$mn:0000128C ; Attributes: bp-based frame
.text$mn:0000128C
.text$mn:0000128C ; class std::allocator<int> && __cdecl std::move<class std::allocator<int> &>(class std::allocator<int> &)
.text$mn:0000128C                 public ??$move@AAV?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z
.text$mn:0000128C ??$move@AAV?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z proc near
.text$mn:0000128C                                         ; CODE XREF: ?_Move@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEPAV?$_Func_base@X$$V@2@PAX@Z+43p
.text$mn:0000128C
.text$mn:0000128C var_C0          = byte ptr -0C0h
.text$mn:0000128C arg_0           = dword ptr  8
.text$mn:0000128C
.text$mn:0000128C                 push    ebp
.text$mn:0000128D                 mov     ebp, esp
.text$mn:0000128F                 sub     esp, 0C0h
.text$mn:00001295                 push    ebx
.text$mn:00001296                 push    esi
.text$mn:00001297                 push    edi
.text$mn:00001298                 lea     edi, [ebp+var_C0]
.text$mn:0000129E                 mov     ecx, 30h ; '0'
.text$mn:000012A3                 mov     eax, 0CCCCCCCCh
.text$mn:000012A8                 rep stosd
.text$mn:000012AA                 mov     eax, [ebp+arg_0]
.text$mn:000012AD                 pop     edi
.text$mn:000012AE                 pop     esi
.text$mn:000012AF                 pop     ebx
.text$mn:000012B0                 mov     esp, ebp
.text$mn:000012B2                 pop     ebp
.text$mn:000012B3                 retn
.text$mn:000012B3 ??$move@AAV?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z endp
.text$mn:000012B3
.text$mn:000012B3 _text$mn        ends
.text$mn:000012B3
.text$mn:000012B4 ; ===========================================================================
.text$mn:000012B4
.text$mn:000012B4 ; Segment type: Pure code
.text$mn:000012B4 ; Segment permissions: Read/Execute
.text$mn:000012B4 _text$mn        segment para public 'CODE' use32
.text$mn:000012B4                 assume cs:_text$mn
.text$mn:000012B4                 ;org 12B4h
.text$mn:000012B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012B4
.text$mn:000012B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000012B4
.text$mn:000012B4 ; Attributes: bp-based frame
.text$mn:000012B4
.text$mn:000012B4 ; public: __thiscall _lambda_b6f3cb1c717d8c8a816f87295491882e_::_lambda_b6f3cb1c717d8c8a816f87295491882e_(class FileExistenceChecker * const)
.text$mn:000012B4 ??0_lambda_b6f3cb1c717d8c8a816f87295491882e_@@QAE@QAVFileExistenceChecker@@@Z proc near
.text$mn:000012B4                                         ; CODE XREF: FileExistenceChecker::Run(void)+CDp
.text$mn:000012B4
.text$mn:000012B4 var_CC          = byte ptr -0CCh
.text$mn:000012B4 var_8           = dword ptr -8
.text$mn:000012B4 arg_0           = dword ptr  8
.text$mn:000012B4
.text$mn:000012B4                 push    ebp
.text$mn:000012B5                 mov     ebp, esp
.text$mn:000012B7                 sub     esp, 0CCh
.text$mn:000012BD                 push    ebx
.text$mn:000012BE                 push    esi
.text$mn:000012BF                 push    edi
.text$mn:000012C0                 push    ecx
.text$mn:000012C1                 lea     edi, [ebp+var_CC]
.text$mn:000012C7                 mov     ecx, 33h ; '3'
.text$mn:000012CC                 mov     eax, 0CCCCCCCCh
.text$mn:000012D1                 rep stosd
.text$mn:000012D3                 pop     ecx
.text$mn:000012D4                 mov     [ebp+var_8], ecx
.text$mn:000012D7                 mov     eax, [ebp+var_8]
.text$mn:000012DA                 mov     ecx, [ebp+arg_0]
.text$mn:000012DD                 mov     [eax], ecx
.text$mn:000012DF                 mov     eax, [ebp+var_8]
.text$mn:000012E2                 pop     edi
.text$mn:000012E3                 pop     esi
.text$mn:000012E4                 pop     ebx
.text$mn:000012E5                 mov     esp, ebp
.text$mn:000012E7                 pop     ebp
.text$mn:000012E8                 retn    4
.text$mn:000012E8 ??0_lambda_b6f3cb1c717d8c8a816f87295491882e_@@QAE@QAVFileExistenceChecker@@@Z endp
.text$mn:000012E8
.text$mn:000012E8 ; ---------------------------------------------------------------------------
.text$mn:000012EB                 align 4
.text$mn:000012EB _text$mn        ends
.text$mn:000012EB
.text$mn:000012EC ; ===========================================================================
.text$mn:000012EC
.text$mn:000012EC ; Segment type: Pure code
.text$mn:000012EC ; Segment permissions: Read/Execute
.text$mn:000012EC _text$mn        segment para public 'CODE' use32
.text$mn:000012EC                 assume cs:_text$mn
.text$mn:000012EC                 ;org 12ECh
.text$mn:000012EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012EC
.text$mn:000012EC ; =============== S U B R O U T I N E =======================================
.text$mn:000012EC
.text$mn:000012EC ; Attributes: bp-based frame
.text$mn:000012EC
.text$mn:000012EC ; public: __thiscall geomutil::PointT<int>::PointT<int>(int, int)
.text$mn:000012EC                 public ??0?$PointT@H@geomutil@@QAE@HH@Z
.text$mn:000012EC ??0?$PointT@H@geomutil@@QAE@HH@Z proc near
.text$mn:000012EC                                         ; CODE XREF: CommandLineInfo::CommandLineInfo(void)+103p
.text$mn:000012EC
.text$mn:000012EC var_CC          = byte ptr -0CCh
.text$mn:000012EC var_8           = dword ptr -8
.text$mn:000012EC arg_0           = dword ptr  8
.text$mn:000012EC arg_4           = dword ptr  0Ch
.text$mn:000012EC
.text$mn:000012EC                 push    ebp
.text$mn:000012ED                 mov     ebp, esp
.text$mn:000012EF                 sub     esp, 0CCh
.text$mn:000012F5                 push    ebx
.text$mn:000012F6                 push    esi
.text$mn:000012F7                 push    edi
.text$mn:000012F8                 push    ecx
.text$mn:000012F9                 lea     edi, [ebp+var_CC]
.text$mn:000012FF                 mov     ecx, 33h ; '3'
.text$mn:00001304                 mov     eax, 0CCCCCCCCh
.text$mn:00001309                 rep stosd
.text$mn:0000130B                 pop     ecx
.text$mn:0000130C                 mov     [ebp+var_8], ecx
.text$mn:0000130F                 mov     eax, [ebp+var_8]
.text$mn:00001312                 mov     ecx, [ebp+arg_0]
.text$mn:00001315                 mov     [eax], ecx
.text$mn:00001317                 mov     eax, [ebp+var_8]
.text$mn:0000131A                 mov     ecx, [ebp+arg_4]
.text$mn:0000131D                 mov     [eax+4], ecx
.text$mn:00001320                 mov     eax, [ebp+var_8]
.text$mn:00001323                 pop     edi
.text$mn:00001324                 pop     esi
.text$mn:00001325                 pop     ebx
.text$mn:00001326                 mov     esp, ebp
.text$mn:00001328                 pop     ebp
.text$mn:00001329                 retn    8
.text$mn:00001329 ??0?$PointT@H@geomutil@@QAE@HH@Z endp
.text$mn:00001329
.text$mn:00001329 _text$mn        ends
.text$mn:00001329
.text$mn:0000132C ; ===========================================================================
.text$mn:0000132C
.text$mn:0000132C ; Segment type: Pure code
.text$mn:0000132C ; Segment permissions: Read/Execute
.text$mn:0000132C _text$mn        segment para public 'CODE' use32
.text$mn:0000132C                 assume cs:_text$mn
.text$mn:0000132C                 ;org 132Ch
.text$mn:0000132C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000132C
.text$mn:0000132C ; =============== S U B R O U T I N E =======================================
.text$mn:0000132C
.text$mn:0000132C ; Attributes: bp-based frame
.text$mn:0000132C
.text$mn:0000132C ; public: __thiscall geomutil::RectT<int>::RectT<int>(void)
.text$mn:0000132C                 public ??0?$RectT@H@geomutil@@QAE@XZ
.text$mn:0000132C ??0?$RectT@H@geomutil@@QAE@XZ proc near ; CODE XREF: ClientRect::ClientRect(HWND__ *)+30p
.text$mn:0000132C                                         ; DATA XREF: Vec<geomutil::RectT<int>>::Vec<geomutil::RectT<int>>(uint,Allocator *)+2Co
.text$mn:0000132C
.text$mn:0000132C var_CC          = byte ptr -0CCh
.text$mn:0000132C var_8           = dword ptr -8
.text$mn:0000132C
.text$mn:0000132C                 push    ebp
.text$mn:0000132D                 mov     ebp, esp
.text$mn:0000132F                 sub     esp, 0CCh
.text$mn:00001335                 push    ebx
.text$mn:00001336                 push    esi
.text$mn:00001337                 push    edi
.text$mn:00001338                 push    ecx
.text$mn:00001339                 lea     edi, [ebp+var_CC]
.text$mn:0000133F                 mov     ecx, 33h ; '3'
.text$mn:00001344                 mov     eax, 0CCCCCCCCh
.text$mn:00001349                 rep stosd
.text$mn:0000134B                 pop     ecx
.text$mn:0000134C                 mov     [ebp+var_8], ecx
.text$mn:0000134F                 mov     eax, [ebp+var_8]
.text$mn:00001352                 mov     dword ptr [eax], 0
.text$mn:00001358                 mov     eax, [ebp+var_8]
.text$mn:0000135B                 mov     dword ptr [eax+4], 0
.text$mn:00001362                 mov     eax, [ebp+var_8]
.text$mn:00001365                 mov     dword ptr [eax+8], 0
.text$mn:0000136C                 mov     eax, [ebp+var_8]
.text$mn:0000136F                 mov     dword ptr [eax+0Ch], 0
.text$mn:00001376                 mov     eax, [ebp+var_8]
.text$mn:00001379                 pop     edi
.text$mn:0000137A                 pop     esi
.text$mn:0000137B                 pop     ebx
.text$mn:0000137C                 mov     esp, ebp
.text$mn:0000137E                 pop     ebp
.text$mn:0000137F                 retn
.text$mn:0000137F ??0?$RectT@H@geomutil@@QAE@XZ endp
.text$mn:0000137F
.text$mn:0000137F _text$mn        ends
.text$mn:0000137F
.text$mn:00001380 ; ===========================================================================
.text$mn:00001380
.text$mn:00001380 ; Segment type: Pure code
.text$mn:00001380 ; Segment permissions: Read/Execute
.text$mn:00001380 _text$mn        segment para public 'CODE' use32
.text$mn:00001380                 assume cs:_text$mn
.text$mn:00001380                 ;org 1380h
.text$mn:00001380                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001380
.text$mn:00001380 ; =============== S U B R O U T I N E =======================================
.text$mn:00001380
.text$mn:00001380 ; Attributes: bp-based frame
.text$mn:00001380
.text$mn:00001380 ; public: __thiscall ScopedMem<char>::ScopedMem<char>(char *)
.text$mn:00001380                 public ??0?$ScopedMem@D@@QAE@PAD@Z
.text$mn:00001380 ??0?$ScopedMem@D@@QAE@PAD@Z proc near   ; CODE XREF: CommandLineInfo::CommandLineInfo(void)+1D6p
.text$mn:00001380
.text$mn:00001380 var_CC          = byte ptr -0CCh
.text$mn:00001380 var_8           = dword ptr -8
.text$mn:00001380 arg_0           = dword ptr  8
.text$mn:00001380
.text$mn:00001380                 push    ebp
.text$mn:00001381                 mov     ebp, esp
.text$mn:00001383                 sub     esp, 0CCh
.text$mn:00001389                 push    ebx
.text$mn:0000138A                 push    esi
.text$mn:0000138B                 push    edi
.text$mn:0000138C                 push    ecx
.text$mn:0000138D                 lea     edi, [ebp+var_CC]
.text$mn:00001393                 mov     ecx, 33h ; '3'
.text$mn:00001398                 mov     eax, 0CCCCCCCCh
.text$mn:0000139D                 rep stosd
.text$mn:0000139F                 pop     ecx
.text$mn:000013A0                 mov     [ebp+var_8], ecx
.text$mn:000013A3                 mov     eax, [ebp+var_8]
.text$mn:000013A6                 mov     ecx, [ebp+arg_0]
.text$mn:000013A9                 mov     [eax], ecx
.text$mn:000013AB                 mov     eax, [ebp+var_8]
.text$mn:000013AE                 pop     edi
.text$mn:000013AF                 pop     esi
.text$mn:000013B0                 pop     ebx
.text$mn:000013B1                 mov     esp, ebp
.text$mn:000013B3                 pop     ebp
.text$mn:000013B4                 retn    4
.text$mn:000013B4 ??0?$ScopedMem@D@@QAE@PAD@Z endp
.text$mn:000013B4
.text$mn:000013B4 ; ---------------------------------------------------------------------------
.text$mn:000013B7                 align 4
.text$mn:000013B7 _text$mn        ends
.text$mn:000013B7
.text$mn:000013B8 ; ===========================================================================
.text$mn:000013B8
.text$mn:000013B8 ; Segment type: Pure code
.text$mn:000013B8 ; Segment permissions: Read/Execute
.text$mn:000013B8 _text$mn        segment para public 'CODE' use32
.text$mn:000013B8                 assume cs:_text$mn
.text$mn:000013B8                 ;org 13B8h
.text$mn:000013B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013B8
.text$mn:000013B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000013B8
.text$mn:000013B8 ; Attributes: bp-based frame
.text$mn:000013B8
.text$mn:000013B8 ; public: __thiscall ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:000013B8                 public ??0?$ScopedMem@_W@@QAE@PA_W@Z
.text$mn:000013B8 ??0?$ScopedMem@_W@@QAE@PA_W@Z proc near ; CODE XREF: CommandLineInfo::CommandLineInfo(void)+5Fp
.text$mn:000013B8                                         ; CommandLineInfo::CommandLineInfo(void)+6Fp ...
.text$mn:000013B8
.text$mn:000013B8 var_CC          = byte ptr -0CCh
.text$mn:000013B8 var_8           = dword ptr -8
.text$mn:000013B8 arg_0           = dword ptr  8
.text$mn:000013B8
.text$mn:000013B8                 push    ebp
.text$mn:000013B9                 mov     ebp, esp
.text$mn:000013BB                 sub     esp, 0CCh
.text$mn:000013C1                 push    ebx
.text$mn:000013C2                 push    esi
.text$mn:000013C3                 push    edi
.text$mn:000013C4                 push    ecx
.text$mn:000013C5                 lea     edi, [ebp+var_CC]
.text$mn:000013CB                 mov     ecx, 33h ; '3'
.text$mn:000013D0                 mov     eax, 0CCCCCCCCh
.text$mn:000013D5                 rep stosd
.text$mn:000013D7                 pop     ecx
.text$mn:000013D8                 mov     [ebp+var_8], ecx
.text$mn:000013DB                 mov     eax, [ebp+var_8]
.text$mn:000013DE                 mov     ecx, [ebp+arg_0]
.text$mn:000013E1                 mov     [eax], ecx
.text$mn:000013E3                 mov     eax, [ebp+var_8]
.text$mn:000013E6                 pop     edi
.text$mn:000013E7                 pop     esi
.text$mn:000013E8                 pop     ebx
.text$mn:000013E9                 mov     esp, ebp
.text$mn:000013EB                 pop     ebp
.text$mn:000013EC                 retn    4
.text$mn:000013EC ??0?$ScopedMem@_W@@QAE@PA_W@Z endp
.text$mn:000013EC
.text$mn:000013EC ; ---------------------------------------------------------------------------
.text$mn:000013EF                 align 10h
.text$mn:000013EF _text$mn        ends
.text$mn:000013EF
.text$mn:000013F0 ; ===========================================================================
.text$mn:000013F0
.text$mn:000013F0 ; Segment type: Pure code
.text$mn:000013F0 ; Segment permissions: Read/Execute
.text$mn:000013F0 _text$mn        segment para public 'CODE' use32
.text$mn:000013F0                 assume cs:_text$mn
.text$mn:000013F0                 ;org 13F0h
.text$mn:000013F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013F0
.text$mn:000013F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000013F0
.text$mn:000013F0 ; Attributes: bp-based frame
.text$mn:000013F0
.text$mn:000013F0 ; public: __thiscall ScopedMem<wchar_t>::ScopedMem<wchar_t>(void)
.text$mn:000013F0                 public ??0?$ScopedMem@_W@@QAE@XZ
.text$mn:000013F0 ??0?$ScopedMem@_W@@QAE@XZ proc near     ; CODE XREF: SetupCrashHandler(void)+21p
.text$mn:000013F0
.text$mn:000013F0 var_CC          = byte ptr -0CCh
.text$mn:000013F0 var_8           = dword ptr -8
.text$mn:000013F0
.text$mn:000013F0                 push    ebp
.text$mn:000013F1                 mov     ebp, esp
.text$mn:000013F3                 sub     esp, 0CCh
.text$mn:000013F9                 push    ebx
.text$mn:000013FA                 push    esi
.text$mn:000013FB                 push    edi
.text$mn:000013FC                 push    ecx
.text$mn:000013FD                 lea     edi, [ebp+var_CC]
.text$mn:00001403                 mov     ecx, 33h ; '3'
.text$mn:00001408                 mov     eax, 0CCCCCCCCh
.text$mn:0000140D                 rep stosd
.text$mn:0000140F                 pop     ecx
.text$mn:00001410                 mov     [ebp+var_8], ecx
.text$mn:00001413                 mov     eax, [ebp+var_8]
.text$mn:00001416                 mov     dword ptr [eax], 0
.text$mn:0000141C                 mov     eax, [ebp+var_8]
.text$mn:0000141F                 pop     edi
.text$mn:00001420                 pop     esi
.text$mn:00001421                 pop     ebx
.text$mn:00001422                 mov     esp, ebp
.text$mn:00001424                 pop     ebp
.text$mn:00001425                 retn
.text$mn:00001425 ??0?$ScopedMem@_W@@QAE@XZ endp
.text$mn:00001425
.text$mn:00001425 ; ---------------------------------------------------------------------------
.text$mn:00001426                 align 4
.text$mn:00001426 _text$mn        ends
.text$mn:00001426
.text$mn:00001428 ; ===========================================================================
.text$mn:00001428
.text$mn:00001428 ; Segment type: Pure code
.text$mn:00001428 ; Segment permissions: Read/Execute
.text$mn:00001428 _text$mn        segment para public 'CODE' use32
.text$mn:00001428                 assume cs:_text$mn
.text$mn:00001428                 ;org 1428h
.text$mn:00001428                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001428
.text$mn:00001428 ; =============== S U B R O U T I N E =======================================
.text$mn:00001428
.text$mn:00001428 ; Attributes: bp-based frame
.text$mn:00001428
.text$mn:00001428 ; public: __thiscall str::Str<wchar_t>::Str<wchar_t>(unsigned int, class Allocator *)
.text$mn:00001428                 public ??0?$Str@_W@str@@QAE@IPAVAllocator@@@Z
.text$mn:00001428 ??0?$Str@_W@str@@QAE@IPAVAllocator@@@Z proc near
.text$mn:00001428                                         ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+53p
.text$mn:00001428
.text$mn:00001428 var_CC          = byte ptr -0CCh
.text$mn:00001428 var_8           = dword ptr -8
.text$mn:00001428 arg_0           = dword ptr  8
.text$mn:00001428 arg_4           = dword ptr  0Ch
.text$mn:00001428
.text$mn:00001428                 push    ebp
.text$mn:00001429                 mov     ebp, esp
.text$mn:0000142B                 sub     esp, 0CCh
.text$mn:00001431                 push    ebx
.text$mn:00001432                 push    esi
.text$mn:00001433                 push    edi
.text$mn:00001434                 push    ecx
.text$mn:00001435                 lea     edi, [ebp+var_CC]
.text$mn:0000143B                 mov     ecx, 33h ; '3'
.text$mn:00001440                 mov     eax, 0CCCCCCCCh
.text$mn:00001445                 rep stosd
.text$mn:00001447                 pop     ecx
.text$mn:00001448                 mov     [ebp+var_8], ecx
.text$mn:0000144B                 mov     eax, [ebp+arg_4]
.text$mn:0000144E                 push    eax
.text$mn:0000144F                 mov     ecx, [ebp+arg_0]
.text$mn:00001452                 push    ecx
.text$mn:00001453                 mov     ecx, [ebp+var_8]
.text$mn:00001456                 call    ??0?$Vec@_W@@QAE@IPAVAllocator@@@Z ; Vec<wchar_t>::Vec<wchar_t>(uint,Allocator *)
.text$mn:0000145B                 mov     eax, [ebp+var_8]
.text$mn:0000145E                 pop     edi
.text$mn:0000145F                 pop     esi
.text$mn:00001460                 pop     ebx
.text$mn:00001461                 add     esp, 0CCh
.text$mn:00001467                 cmp     ebp, esp
.text$mn:00001469                 call    __RTC_CheckEsp
.text$mn:0000146E                 mov     esp, ebp
.text$mn:00001470                 pop     ebp
.text$mn:00001471                 retn    8
.text$mn:00001471 ??0?$Str@_W@str@@QAE@IPAVAllocator@@@Z endp
.text$mn:00001471
.text$mn:00001471 _text$mn        ends
.text$mn:00001471
.text$mn:00001474 ; ===========================================================================
.text$mn:00001474
.text$mn:00001474 ; Segment type: Pure code
.text$mn:00001474 ; Segment permissions: Read/Execute
.text$mn:00001474 _text$mn        segment para public 'CODE' use32
.text$mn:00001474                 assume cs:_text$mn
.text$mn:00001474                 ;org 1474h
.text$mn:00001474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001474
.text$mn:00001474 ; =============== S U B R O U T I N E =======================================
.text$mn:00001474
.text$mn:00001474 ; Attributes: bp-based frame
.text$mn:00001474
.text$mn:00001474 ; public: __thiscall Vec<struct FileState *>::Vec<struct FileState *>(unsigned int, class Allocator *)
.text$mn:00001474                 public ??0?$Vec@PAUFileState@@@@QAE@IPAVAllocator@@@Z
.text$mn:00001474 ??0?$Vec@PAUFileState@@@@QAE@IPAVAllocator@@@Z proc near
.text$mn:00001474                                         ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+8Cp
.text$mn:00001474
.text$mn:00001474 var_CC          = byte ptr -0CCh
.text$mn:00001474 var_8           = dword ptr -8
.text$mn:00001474 arg_0           = dword ptr  8
.text$mn:00001474 arg_4           = dword ptr  0Ch
.text$mn:00001474
.text$mn:00001474                 push    ebp
.text$mn:00001475                 mov     ebp, esp
.text$mn:00001477                 sub     esp, 0CCh
.text$mn:0000147D                 push    ebx
.text$mn:0000147E                 push    esi
.text$mn:0000147F                 push    edi
.text$mn:00001480                 push    ecx
.text$mn:00001481                 lea     edi, [ebp+var_CC]
.text$mn:00001487                 mov     ecx, 33h ; '3'
.text$mn:0000148C                 mov     eax, 0CCCCCCCCh
.text$mn:00001491                 rep stosd
.text$mn:00001493                 pop     ecx
.text$mn:00001494                 mov     [ebp+var_8], ecx
.text$mn:00001497                 mov     eax, [ebp+var_8]
.text$mn:0000149A                 mov     ecx, [ebp+arg_0]
.text$mn:0000149D                 mov     [eax+8], ecx
.text$mn:000014A0                 mov     eax, [ebp+var_8]
.text$mn:000014A3                 mov     ecx, [ebp+arg_4]
.text$mn:000014A6                 mov     [eax+50h], ecx
.text$mn:000014A9                 mov     eax, [ebp+var_8]
.text$mn:000014AC                 add     eax, 10h
.text$mn:000014AF                 mov     ecx, [ebp+var_8]
.text$mn:000014B2                 mov     [ecx+0Ch], eax
.text$mn:000014B5                 mov     ecx, [ebp+var_8]
.text$mn:000014B8                 call    ?Reset@?$Vec@PAUFileState@@@@QAEXXZ ; Vec<FileState *>::Reset(void)
.text$mn:000014BD                 mov     eax, [ebp+var_8]
.text$mn:000014C0                 pop     edi
.text$mn:000014C1                 pop     esi
.text$mn:000014C2                 pop     ebx
.text$mn:000014C3                 add     esp, 0CCh
.text$mn:000014C9                 cmp     ebp, esp
.text$mn:000014CB                 call    __RTC_CheckEsp
.text$mn:000014D0                 mov     esp, ebp
.text$mn:000014D2                 pop     ebp
.text$mn:000014D3                 retn    8
.text$mn:000014D3 ??0?$Vec@PAUFileState@@@@QAE@IPAVAllocator@@@Z endp
.text$mn:000014D3
.text$mn:000014D3 ; ---------------------------------------------------------------------------
.text$mn:000014D6                 align 4
.text$mn:000014D6 _text$mn        ends
.text$mn:000014D6
.text$mn:000014D8 ; ===========================================================================
.text$mn:000014D8
.text$mn:000014D8 ; Segment type: Pure code
.text$mn:000014D8 ; Segment permissions: Read/Execute
.text$mn:000014D8 _text$mn        segment para public 'CODE' use32
.text$mn:000014D8                 assume cs:_text$mn
.text$mn:000014D8                 ;org 14D8h
.text$mn:000014D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014D8
.text$mn:000014D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014D8
.text$mn:000014D8 ; Attributes: bp-based frame
.text$mn:000014D8
.text$mn:000014D8 ; public: __thiscall Vec<wchar_t *>::Vec<wchar_t *>(unsigned int, class Allocator *)
.text$mn:000014D8                 public ??0?$Vec@PA_W@@QAE@IPAVAllocator@@@Z
.text$mn:000014D8 ??0?$Vec@PA_W@@QAE@IPAVAllocator@@@Z proc near
.text$mn:000014D8                                         ; CODE XREF: WStrVec::WStrVec(void)+2Ap
.text$mn:000014D8
.text$mn:000014D8 var_CC          = byte ptr -0CCh
.text$mn:000014D8 var_8           = dword ptr -8
.text$mn:000014D8 arg_0           = dword ptr  8
.text$mn:000014D8 arg_4           = dword ptr  0Ch
.text$mn:000014D8
.text$mn:000014D8                 push    ebp
.text$mn:000014D9                 mov     ebp, esp
.text$mn:000014DB                 sub     esp, 0CCh
.text$mn:000014E1                 push    ebx
.text$mn:000014E2                 push    esi
.text$mn:000014E3                 push    edi
.text$mn:000014E4                 push    ecx
.text$mn:000014E5                 lea     edi, [ebp+var_CC]
.text$mn:000014EB                 mov     ecx, 33h ; '3'
.text$mn:000014F0                 mov     eax, 0CCCCCCCCh
.text$mn:000014F5                 rep stosd
.text$mn:000014F7                 pop     ecx
.text$mn:000014F8                 mov     [ebp+var_8], ecx
.text$mn:000014FB                 mov     eax, [ebp+var_8]
.text$mn:000014FE                 mov     ecx, [ebp+arg_0]
.text$mn:00001501                 mov     [eax+8], ecx
.text$mn:00001504                 mov     eax, [ebp+var_8]
.text$mn:00001507                 mov     ecx, [ebp+arg_4]
.text$mn:0000150A                 mov     [eax+50h], ecx
.text$mn:0000150D                 mov     eax, [ebp+var_8]
.text$mn:00001510                 add     eax, 10h
.text$mn:00001513                 mov     ecx, [ebp+var_8]
.text$mn:00001516                 mov     [ecx+0Ch], eax
.text$mn:00001519                 mov     ecx, [ebp+var_8]
.text$mn:0000151C                 call    ?Reset@?$Vec@PA_W@@QAEXXZ ; Vec<wchar_t *>::Reset(void)
.text$mn:00001521                 mov     eax, [ebp+var_8]
.text$mn:00001524                 pop     edi
.text$mn:00001525                 pop     esi
.text$mn:00001526                 pop     ebx
.text$mn:00001527                 add     esp, 0CCh
.text$mn:0000152D                 cmp     ebp, esp
.text$mn:0000152F                 call    __RTC_CheckEsp
.text$mn:00001534                 mov     esp, ebp
.text$mn:00001536                 pop     ebp
.text$mn:00001537                 retn    8
.text$mn:00001537 ??0?$Vec@PA_W@@QAE@IPAVAllocator@@@Z endp
.text$mn:00001537
.text$mn:00001537 ; ---------------------------------------------------------------------------
.text$mn:0000153A                 align 4
.text$mn:0000153A _text$mn        ends
.text$mn:0000153A
.text$mn:0000153C ; ===========================================================================
.text$mn:0000153C
.text$mn:0000153C ; Segment type: Pure code
.text$mn:0000153C ; Segment permissions: Read/Execute
.text$mn:0000153C _text$mn        segment para public 'CODE' use32
.text$mn:0000153C                 assume cs:_text$mn
.text$mn:0000153C                 ;org 153Ch
.text$mn:0000153C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000153C
.text$mn:0000153C ; =============== S U B R O U T I N E =======================================
.text$mn:0000153C
.text$mn:0000153C ; Attributes: bp-based frame
.text$mn:0000153C
.text$mn:0000153C ; public: __thiscall Vec<class geomutil::RectT<int>>::Vec<class geomutil::RectT<int>>(unsigned int, class Allocator *)
.text$mn:0000153C                 public ??0?$Vec@V?$RectT@H@geomutil@@@@QAE@IPAVAllocator@@@Z
.text$mn:0000153C ??0?$Vec@V?$RectT@H@geomutil@@@@QAE@IPAVAllocator@@@Z proc near
.text$mn:0000153C                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+343p
.text$mn:0000153C
.text$mn:0000153C var_CC          = byte ptr -0CCh
.text$mn:0000153C var_8           = dword ptr -8
.text$mn:0000153C arg_0           = dword ptr  8
.text$mn:0000153C arg_4           = dword ptr  0Ch
.text$mn:0000153C
.text$mn:0000153C                 push    ebp
.text$mn:0000153D                 mov     ebp, esp
.text$mn:0000153F                 sub     esp, 0CCh
.text$mn:00001545                 push    ebx
.text$mn:00001546                 push    esi
.text$mn:00001547                 push    edi
.text$mn:00001548                 push    ecx
.text$mn:00001549                 lea     edi, [ebp+var_CC]
.text$mn:0000154F                 mov     ecx, 33h ; '3'
.text$mn:00001554                 mov     eax, 0CCCCCCCCh
.text$mn:00001559                 rep stosd
.text$mn:0000155B                 pop     ecx
.text$mn:0000155C                 mov     [ebp+var_8], ecx
.text$mn:0000155F                 mov     eax, [ebp+var_8]
.text$mn:00001562                 mov     ecx, [ebp+arg_0]
.text$mn:00001565                 mov     [eax+8], ecx
.text$mn:00001568                 push    offset ??0?$RectT@H@geomutil@@QAE@XZ ; geomutil::RectT<int>::RectT<int>(void)
.text$mn:0000156D                 push    10h
.text$mn:0000156F                 push    10h
.text$mn:00001571                 mov     eax, [ebp+var_8]
.text$mn:00001574                 add     eax, 10h
.text$mn:00001577                 push    eax
.text$mn:00001578                 call    ??_H@YGXPAXIIP6EPAX0@Z@Z ; `vector constructor iterator'(void *,uint,uint,void * (*)(void *))
.text$mn:0000157D                 mov     eax, [ebp+var_8]
.text$mn:00001580                 mov     ecx, [ebp+arg_4]
.text$mn:00001583                 mov     [eax+110h], ecx
.text$mn:00001589                 mov     eax, [ebp+var_8]
.text$mn:0000158C                 add     eax, 10h
.text$mn:0000158F                 mov     ecx, [ebp+var_8]
.text$mn:00001592                 mov     [ecx+0Ch], eax
.text$mn:00001595                 mov     ecx, [ebp+var_8]
.text$mn:00001598                 call    ?Reset@?$Vec@V?$RectT@H@geomutil@@@@QAEXXZ ; Vec<geomutil::RectT<int>>::Reset(void)
.text$mn:0000159D                 mov     eax, [ebp+var_8]
.text$mn:000015A0                 pop     edi
.text$mn:000015A1                 pop     esi
.text$mn:000015A2                 pop     ebx
.text$mn:000015A3                 add     esp, 0CCh
.text$mn:000015A9                 cmp     ebp, esp
.text$mn:000015AB                 call    __RTC_CheckEsp
.text$mn:000015B0                 mov     esp, ebp
.text$mn:000015B2                 pop     ebp
.text$mn:000015B3                 retn    8
.text$mn:000015B3 ??0?$Vec@V?$RectT@H@geomutil@@@@QAE@IPAVAllocator@@@Z endp
.text$mn:000015B3
.text$mn:000015B3 ; ---------------------------------------------------------------------------
.text$mn:000015B6                 align 4
.text$mn:000015B6 _text$mn        ends
.text$mn:000015B6
.text$mn:000015B8 ; ===========================================================================
.text$mn:000015B8
.text$mn:000015B8 ; Segment type: Pure code
.text$mn:000015B8 ; Segment permissions: Read/Execute
.text$mn:000015B8 _text$mn        segment para public 'CODE' use32
.text$mn:000015B8                 assume cs:_text$mn
.text$mn:000015B8                 ;org 15B8h
.text$mn:000015B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015B8
.text$mn:000015B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015B8
.text$mn:000015B8 ; Attributes: bp-based frame
.text$mn:000015B8
.text$mn:000015B8 ; public: __thiscall Vec<wchar_t>::Vec<wchar_t>(unsigned int, class Allocator *)
.text$mn:000015B8                 public ??0?$Vec@_W@@QAE@IPAVAllocator@@@Z
.text$mn:000015B8 ??0?$Vec@_W@@QAE@IPAVAllocator@@@Z proc near
.text$mn:000015B8                                         ; CODE XREF: str::Str<wchar_t>::Str<wchar_t>(uint,Allocator *)+2Ep
.text$mn:000015B8
.text$mn:000015B8 var_CC          = byte ptr -0CCh
.text$mn:000015B8 var_8           = dword ptr -8
.text$mn:000015B8 arg_0           = dword ptr  8
.text$mn:000015B8 arg_4           = dword ptr  0Ch
.text$mn:000015B8
.text$mn:000015B8                 push    ebp
.text$mn:000015B9                 mov     ebp, esp
.text$mn:000015BB                 sub     esp, 0CCh
.text$mn:000015C1                 push    ebx
.text$mn:000015C2                 push    esi
.text$mn:000015C3                 push    edi
.text$mn:000015C4                 push    ecx
.text$mn:000015C5                 lea     edi, [ebp+var_CC]
.text$mn:000015CB                 mov     ecx, 33h ; '3'
.text$mn:000015D0                 mov     eax, 0CCCCCCCCh
.text$mn:000015D5                 rep stosd
.text$mn:000015D7                 pop     ecx
.text$mn:000015D8                 mov     [ebp+var_8], ecx
.text$mn:000015DB                 mov     eax, [ebp+var_8]
.text$mn:000015DE                 mov     ecx, [ebp+arg_0]
.text$mn:000015E1                 mov     [eax+8], ecx
.text$mn:000015E4                 mov     eax, [ebp+var_8]
.text$mn:000015E7                 mov     ecx, [ebp+arg_4]
.text$mn:000015EA                 mov     [eax+30h], ecx
.text$mn:000015ED                 mov     eax, [ebp+var_8]
.text$mn:000015F0                 add     eax, 10h
.text$mn:000015F3                 mov     ecx, [ebp+var_8]
.text$mn:000015F6                 mov     [ecx+0Ch], eax
.text$mn:000015F9                 mov     ecx, [ebp+var_8]
.text$mn:000015FC                 call    ?Reset@?$Vec@_W@@QAEXXZ ; Vec<wchar_t>::Reset(void)
.text$mn:00001601                 mov     eax, [ebp+var_8]
.text$mn:00001604                 pop     edi
.text$mn:00001605                 pop     esi
.text$mn:00001606                 pop     ebx
.text$mn:00001607                 add     esp, 0CCh
.text$mn:0000160D                 cmp     ebp, esp
.text$mn:0000160F                 call    __RTC_CheckEsp
.text$mn:00001614                 mov     esp, ebp
.text$mn:00001616                 pop     ebp
.text$mn:00001617                 retn    8
.text$mn:00001617 ??0?$Vec@_W@@QAE@IPAVAllocator@@@Z endp
.text$mn:00001617
.text$mn:00001617 ; ---------------------------------------------------------------------------
.text$mn:0000161A                 align 4
.text$mn:0000161A _text$mn        ends
.text$mn:0000161A
.text$mn:0000161C ; ===========================================================================
.text$mn:0000161C
.text$mn:0000161C ; Segment type: Pure code
.text$mn:0000161C ; Segment permissions: Read/Execute
.text$mn:0000161C _text$mn        segment para public 'CODE' use32
.text$mn:0000161C                 assume cs:_text$mn
.text$mn:0000161C                 ;org 161Ch
.text$mn:0000161C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000161C
.text$mn:0000161C ; =============== S U B R O U T I N E =======================================
.text$mn:0000161C
.text$mn:0000161C ; Attributes: bp-based frame
.text$mn:0000161C
.text$mn:0000161C                 public ??0?$_Func_base@X$$V@std@@QAE@XZ
.text$mn:0000161C ??0?$_Func_base@X$$V@std@@QAE@XZ proc near
.text$mn:0000161C                                         ; CODE XREF: ??$?0ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+26p
.text$mn:0000161C                                         ; ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+26p ...
.text$mn:0000161C
.text$mn:0000161C var_CC          = byte ptr -0CCh
.text$mn:0000161C var_8           = dword ptr -8
.text$mn:0000161C
.text$mn:0000161C                 push    ebp
.text$mn:0000161D                 mov     ebp, esp
.text$mn:0000161F                 sub     esp, 0CCh
.text$mn:00001625                 push    ebx
.text$mn:00001626                 push    esi
.text$mn:00001627                 push    edi
.text$mn:00001628                 push    ecx
.text$mn:00001629                 lea     edi, [ebp+var_CC]
.text$mn:0000162F                 mov     ecx, 33h ; '3'
.text$mn:00001634                 mov     eax, 0CCCCCCCCh
.text$mn:00001639                 rep stosd
.text$mn:0000163B                 pop     ecx
.text$mn:0000163C                 mov     [ebp+var_8], ecx
.text$mn:0000163F                 mov     eax, [ebp+var_8]
.text$mn:00001642                 mov     dword ptr [eax], offset ??_7?$_Func_base@X$$V@std@@6B@
.text$mn:00001648                 mov     eax, [ebp+var_8]
.text$mn:0000164B                 pop     edi
.text$mn:0000164C                 pop     esi
.text$mn:0000164D                 pop     ebx
.text$mn:0000164E                 mov     esp, ebp
.text$mn:00001650                 pop     ebp
.text$mn:00001651                 retn
.text$mn:00001651 ??0?$_Func_base@X$$V@std@@QAE@XZ endp
.text$mn:00001651
.text$mn:00001651 ; ---------------------------------------------------------------------------
.text$mn:00001652                 align 4
.text$mn:00001652 _text$mn        ends
.text$mn:00001652
.text$mn:00001654 ; ===========================================================================
.text$mn:00001654
.text$mn:00001654 ; Segment type: Pure code
.text$mn:00001654 ; Segment permissions: Read/Execute
.text$mn:00001654 _text$mn        segment para public 'CODE' use32
.text$mn:00001654                 assume cs:_text$mn
.text$mn:00001654                 ;org 1654h
.text$mn:00001654                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001654
.text$mn:00001654 ; =============== S U B R O U T I N E =======================================
.text$mn:00001654
.text$mn:00001654 ; Attributes: bp-based frame
.text$mn:00001654
.text$mn:00001654                 public ??0?$_Func_class@X$$V@std@@QAE@XZ
.text$mn:00001654 ??0?$_Func_class@X$$V@std@@QAE@XZ proc near
.text$mn:00001654                                         ; CODE XREF: std::function<void (void)>::function<void (void)>(_lambda_b6f3cb1c717d8c8a816f87295491882e_)+26p
.text$mn:00001654
.text$mn:00001654 var_CC          = byte ptr -0CCh
.text$mn:00001654 var_8           = dword ptr -8
.text$mn:00001654
.text$mn:00001654                 push    ebp
.text$mn:00001655                 mov     ebp, esp
.text$mn:00001657                 sub     esp, 0CCh
.text$mn:0000165D                 push    ebx
.text$mn:0000165E                 push    esi
.text$mn:0000165F                 push    edi
.text$mn:00001660                 push    ecx
.text$mn:00001661                 lea     edi, [ebp+var_CC]
.text$mn:00001667                 mov     ecx, 33h ; '3'
.text$mn:0000166C                 mov     eax, 0CCCCCCCCh
.text$mn:00001671                 rep stosd
.text$mn:00001673                 pop     ecx
.text$mn:00001674                 mov     [ebp+var_8], ecx
.text$mn:00001677                 push    0
.text$mn:00001679                 mov     ecx, [ebp+var_8]
.text$mn:0000167C                 call    ?_Set@?$_Func_class@X$$V@std@@AAEXPAV?$_Func_base@X$$V@2@@Z
.text$mn:00001681                 mov     eax, [ebp+var_8]
.text$mn:00001684                 pop     edi
.text$mn:00001685                 pop     esi
.text$mn:00001686                 pop     ebx
.text$mn:00001687                 add     esp, 0CCh
.text$mn:0000168D                 cmp     ebp, esp
.text$mn:0000168F                 call    __RTC_CheckEsp
.text$mn:00001694                 mov     esp, ebp
.text$mn:00001696                 pop     ebp
.text$mn:00001697                 retn
.text$mn:00001697 ??0?$_Func_class@X$$V@std@@QAE@XZ endp
.text$mn:00001697
.text$mn:00001697 _text$mn        ends
.text$mn:00001697
.text$mn:00001698 ; ===========================================================================
.text$mn:00001698
.text$mn:00001698 ; Segment type: Pure code
.text$mn:00001698 ; Segment permissions: Read/Execute
.text$mn:00001698 _text$mn        segment para public 'CODE' use32
.text$mn:00001698                 assume cs:_text$mn
.text$mn:00001698                 ;org 1698h
.text$mn:00001698                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001698
.text$mn:00001698 ; =============== S U B R O U T I N E =======================================
.text$mn:00001698
.text$mn:00001698 ; Attributes: bp-based frame
.text$mn:00001698
.text$mn:00001698 ; public: __thiscall std::allocator<int>::allocator<int>(class std::allocator<int> const &)
.text$mn:00001698                 public ??0?$allocator@H@std@@QAE@ABV01@@Z
.text$mn:00001698 ??0?$allocator@H@std@@QAE@ABV01@@Z proc near
.text$mn:00001698                                         ; CODE XREF: std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>(std::_One_then_variadic_args_t,std::allocator<int> const &,_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)+33p
.text$mn:00001698                                         ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>(std::_One_then_variadic_args_t,std::allocator<int> const &,_lambda_b6f3cb1c717d8c8a816f87295491882e_ &&)+33p ...
.text$mn:00001698
.text$mn:00001698 var_CC          = byte ptr -0CCh
.text$mn:00001698 var_8           = dword ptr -8
.text$mn:00001698
.text$mn:00001698                 push    ebp
.text$mn:00001699                 mov     ebp, esp
.text$mn:0000169B                 sub     esp, 0CCh
.text$mn:000016A1                 push    ebx
.text$mn:000016A2                 push    esi
.text$mn:000016A3                 push    edi
.text$mn:000016A4                 push    ecx
.text$mn:000016A5                 lea     edi, [ebp+var_CC]
.text$mn:000016AB                 mov     ecx, 33h ; '3'
.text$mn:000016B0                 mov     eax, 0CCCCCCCCh
.text$mn:000016B5                 rep stosd
.text$mn:000016B7                 pop     ecx
.text$mn:000016B8                 mov     [ebp+var_8], ecx
.text$mn:000016BB                 mov     eax, [ebp+var_8]
.text$mn:000016BE                 pop     edi
.text$mn:000016BF                 pop     esi
.text$mn:000016C0                 pop     ebx
.text$mn:000016C1                 mov     esp, ebp
.text$mn:000016C3                 pop     ebp
.text$mn:000016C4                 retn    4
.text$mn:000016C4 ??0?$allocator@H@std@@QAE@ABV01@@Z endp
.text$mn:000016C4
.text$mn:000016C4 ; ---------------------------------------------------------------------------
.text$mn:000016C7                 align 4
.text$mn:000016C7 _text$mn        ends
.text$mn:000016C7
.text$mn:000016C8 ; ===========================================================================
.text$mn:000016C8
.text$mn:000016C8 ; Segment type: Pure code
.text$mn:000016C8 ; Segment permissions: Read/Execute
.text$mn:000016C8 _text$mn        segment para public 'CODE' use32
.text$mn:000016C8                 assume cs:_text$mn
.text$mn:000016C8                 ;org 16C8h
.text$mn:000016C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016C8
.text$mn:000016C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016C8
.text$mn:000016C8 ; Attributes: bp-based frame
.text$mn:000016C8
.text$mn:000016C8 ; public: __thiscall std::allocator<int>::allocator<int>(void)
.text$mn:000016C8                 public ??0?$allocator@H@std@@QAE@XZ
.text$mn:000016C8 ??0?$allocator@H@std@@QAE@XZ proc near  ; CODE XREF: ??$_Reset@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z+29p
.text$mn:000016C8
.text$mn:000016C8 var_CC          = byte ptr -0CCh
.text$mn:000016C8 var_8           = dword ptr -8
.text$mn:000016C8
.text$mn:000016C8                 push    ebp
.text$mn:000016C9                 mov     ebp, esp
.text$mn:000016CB                 sub     esp, 0CCh
.text$mn:000016D1                 push    ebx
.text$mn:000016D2                 push    esi
.text$mn:000016D3                 push    edi
.text$mn:000016D4                 push    ecx
.text$mn:000016D5                 lea     edi, [ebp+var_CC]
.text$mn:000016DB                 mov     ecx, 33h ; '3'
.text$mn:000016E0                 mov     eax, 0CCCCCCCCh
.text$mn:000016E5                 rep stosd
.text$mn:000016E7                 pop     ecx
.text$mn:000016E8                 mov     [ebp+var_8], ecx
.text$mn:000016EB                 mov     eax, [ebp+var_8]
.text$mn:000016EE                 pop     edi
.text$mn:000016EF                 pop     esi
.text$mn:000016F0                 pop     ebx
.text$mn:000016F1                 mov     esp, ebp
.text$mn:000016F3                 pop     ebp
.text$mn:000016F4                 retn
.text$mn:000016F4 ??0?$allocator@H@std@@QAE@XZ endp
.text$mn:000016F4
.text$mn:000016F4 ; ---------------------------------------------------------------------------
.text$mn:000016F5                 align 4
.text$mn:000016F5 _text$mn        ends
.text$mn:000016F5
.text$mn:000016F8 ; ===========================================================================
.text$mn:000016F8
.text$mn:000016F8 ; Segment type: Pure code
.text$mn:000016F8 ; Segment permissions: Read/Execute
.text$mn:000016F8 _text$mn        segment para public 'CODE' use32
.text$mn:000016F8                 assume cs:_text$mn
.text$mn:000016F8                 ;org 16F8h
.text$mn:000016F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016F8
.text$mn:000016F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016F8
.text$mn:000016F8 ; Attributes: bp-based frame
.text$mn:000016F8
.text$mn:000016F8 ; _DWORD __thiscall ClientRect::ClientRect(ClientRect *this, HWND)
.text$mn:000016F8                 public ??0ClientRect@@QAE@PAUHWND__@@@Z
.text$mn:000016F8 ??0ClientRect@@QAE@PAUHWND__@@@Z proc near
.text$mn:000016F8                                         ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+E6p
.text$mn:000016F8
.text$mn:000016F8 var_E8          = byte ptr -0E8h
.text$mn:000016F8 Rect            = tagRECT ptr -24h
.text$mn:000016F8 var_C           = dword ptr -0Ch
.text$mn:000016F8 var_4           = dword ptr -4
.text$mn:000016F8 hWnd            = dword ptr  8
.text$mn:000016F8
.text$mn:000016F8                 push    ebp
.text$mn:000016F9                 mov     ebp, esp
.text$mn:000016FB                 sub     esp, 0E8h
.text$mn:00001701                 push    ebx
.text$mn:00001702                 push    esi
.text$mn:00001703                 push    edi
.text$mn:00001704                 push    ecx
.text$mn:00001705                 lea     edi, [ebp+var_E8]
.text$mn:0000170B                 mov     ecx, 3Ah ; ':'
.text$mn:00001710                 mov     eax, 0CCCCCCCCh
.text$mn:00001715                 rep stosd
.text$mn:00001717                 pop     ecx
.text$mn:00001718                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000171D                 xor     eax, ebp
.text$mn:0000171F                 mov     [ebp+var_4], eax
.text$mn:00001722                 mov     [ebp+var_C], ecx
.text$mn:00001725                 mov     ecx, [ebp+var_C]
.text$mn:00001728                 call    ??0?$RectT@H@geomutil@@QAE@XZ ; geomutil::RectT<int>::RectT<int>(void)
.text$mn:0000172D                 mov     esi, esp
.text$mn:0000172F                 lea     eax, [ebp+Rect]
.text$mn:00001732                 push    eax             ; lpRect
.text$mn:00001733                 mov     ecx, [ebp+hWnd]
.text$mn:00001736                 push    ecx             ; hWnd
.text$mn:00001737                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:0000173D                 cmp     esi, esp
.text$mn:0000173F                 call    __RTC_CheckEsp
.text$mn:00001744                 test    eax, eax
.text$mn:00001746                 jz      short loc_1771
.text$mn:00001748                 mov     eax, [ebp+var_C]
.text$mn:0000174B                 mov     ecx, [ebp+Rect.left]
.text$mn:0000174E                 mov     [eax], ecx
.text$mn:00001750                 mov     eax, [ebp+Rect.right]
.text$mn:00001753                 sub     eax, [ebp+Rect.left]
.text$mn:00001756                 mov     ecx, [ebp+var_C]
.text$mn:00001759                 mov     [ecx+8], eax
.text$mn:0000175C                 mov     eax, [ebp+var_C]
.text$mn:0000175F                 mov     ecx, [ebp+Rect.top]
.text$mn:00001762                 mov     [eax+4], ecx
.text$mn:00001765                 mov     eax, [ebp+Rect.bottom]
.text$mn:00001768                 sub     eax, [ebp+Rect.top]
.text$mn:0000176B                 mov     ecx, [ebp+var_C]
.text$mn:0000176E                 mov     [ecx+0Ch], eax
.text$mn:00001771
.text$mn:00001771 loc_1771:                               ; CODE XREF: ClientRect::ClientRect(HWND__ *)+4Ej
.text$mn:00001771                 mov     eax, [ebp+var_C]
.text$mn:00001774                 push    edx
.text$mn:00001775                 mov     ecx, ebp
.text$mn:00001777                 push    eax
.text$mn:00001778                 lea     edx, $LN6
.text$mn:0000177E                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00001783                 pop     eax
.text$mn:00001784                 pop     edx
.text$mn:00001785                 pop     edi
.text$mn:00001786                 pop     esi
.text$mn:00001787                 pop     ebx
.text$mn:00001788                 mov     ecx, [ebp+var_4]
.text$mn:0000178B                 xor     ecx, ebp
.text$mn:0000178D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001792                 add     esp, 0E8h
.text$mn:00001798                 cmp     ebp, esp
.text$mn:0000179A                 call    __RTC_CheckEsp
.text$mn:0000179F                 mov     esp, ebp
.text$mn:000017A1                 pop     ebp
.text$mn:000017A2                 retn    4
.text$mn:000017A2 ??0ClientRect@@QAE@PAUHWND__@@@Z endp
.text$mn:000017A2
.text$mn:000017A2 ; ---------------------------------------------------------------------------
.text$mn:000017A5                 align 4
.text$mn:000017A8 $LN6            dd 1                    ; DATA XREF: ClientRect::ClientRect(HWND__ *)+80o
.text$mn:000017AC                 dd offset $LN5
.text$mn:000017B0 $LN5            dd 0FFFFFFDCh, 10h      ; DATA XREF: .text$mn:000017ACo
.text$mn:000017B8                 dd offset $LN4
.text$mn:000017BC $LN4            db 72h, 63h, 0          ; DATA XREF: .text$mn:000017B8o
.text$mn:000017BF                 align 10h
.text$mn:000017BF _text$mn        ends
.text$mn:000017BF
.text$mn:000017C0 ; ===========================================================================
.text$mn:000017C0
.text$mn:000017C0 ; Segment type: Pure code
.text$mn:000017C0 ; Segment permissions: Read/Execute
.text$mn:000017C0 _text$mn        segment para public 'CODE' use32
.text$mn:000017C0                 assume cs:_text$mn
.text$mn:000017C0                 ;org 17C0h
.text$mn:000017C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017C0
.text$mn:000017C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017C0
.text$mn:000017C0 ; Attributes: bp-based frame
.text$mn:000017C0
.text$mn:000017C0 ; public: __thiscall CommandLineInfo::CommandLineInfo(void)
.text$mn:000017C0                 public ??0CommandLineInfo@@QAE@XZ
.text$mn:000017C0 ??0CommandLineInfo@@QAE@XZ proc near    ; CODE XREF: WinMain(x,x,x,x)+125p
.text$mn:000017C0
.text$mn:000017C0 var_CC          = byte ptr -0CCh
.text$mn:000017C0 var_8           = dword ptr -8
.text$mn:000017C0
.text$mn:000017C0                 push    ebp
.text$mn:000017C1                 mov     ebp, esp
.text$mn:000017C3                 sub     esp, 0CCh
.text$mn:000017C9                 push    ebx
.text$mn:000017CA                 push    esi
.text$mn:000017CB                 push    edi
.text$mn:000017CC                 push    ecx
.text$mn:000017CD                 lea     edi, [ebp+var_CC]
.text$mn:000017D3                 mov     ecx, 33h ; '3'
.text$mn:000017D8                 mov     eax, 0CCCCCCCCh
.text$mn:000017DD                 rep stosd
.text$mn:000017DF                 pop     ecx
.text$mn:000017E0                 mov     [ebp+var_8], ecx
.text$mn:000017E3                 mov     ecx, [ebp+var_8] ; this
.text$mn:000017E6                 call    ??0WStrVec@@QAE@XZ ; WStrVec::WStrVec(void)
.text$mn:000017EB                 mov     ecx, [ebp+var_8]
.text$mn:000017EE                 add     ecx, 54h ; 'T'  ; this
.text$mn:000017F1                 call    ??0WStrVec@@QAE@XZ ; WStrVec::WStrVec(void)
.text$mn:000017F6                 mov     eax, [ebp+var_8]
.text$mn:000017F9                 mov     byte ptr [eax+0A8h], 0
.text$mn:00001800                 mov     eax, [ebp+var_8]
.text$mn:00001803                 mov     byte ptr [eax+0A9h], 0
.text$mn:0000180A                 mov     eax, [ebp+var_8]
.text$mn:0000180D                 mov     byte ptr [eax+0AAh], 0
.text$mn:00001814                 push    0
.text$mn:00001816                 mov     ecx, [ebp+var_8]
.text$mn:00001819                 add     ecx, 0ACh ; ''
.text$mn:0000181F                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:00001824                 push    0
.text$mn:00001826                 mov     ecx, [ebp+var_8]
.text$mn:00001829                 add     ecx, 0B0h ; ''
.text$mn:0000182F                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:00001834                 push    0
.text$mn:00001836                 mov     ecx, [ebp+var_8]
.text$mn:00001839                 add     ecx, 0B4h ; ''
.text$mn:0000183F                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:00001844                 mov     eax, [ebp+var_8]
.text$mn:00001847                 mov     dword ptr [eax+0B8h], 0
.text$mn:00001851                 mov     eax, [ebp+var_8]
.text$mn:00001854                 mov     byte ptr [eax+0BCh], 0
.text$mn:0000185B                 push    0
.text$mn:0000185D                 mov     ecx, [ebp+var_8]
.text$mn:00001860                 add     ecx, 0C0h ; '+'
.text$mn:00001866                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:0000186B                 mov     eax, [ebp+var_8]
.text$mn:0000186E                 mov     dword ptr [eax+0C4h], 0FFFFFFFFh
.text$mn:00001878                 mov     eax, [ebp+var_8]
.text$mn:0000187B                 mov     byte ptr [eax+0C8h], 0
.text$mn:00001882                 mov     eax, [ebp+var_8]
.text$mn:00001885                 mov     byte ptr [eax+0C9h], 0
.text$mn:0000188C                 mov     eax, [ebp+var_8]
.text$mn:0000188F                 mov     byte ptr [eax+0CAh], 0
.text$mn:00001896                 mov     eax, [ebp+var_8]
.text$mn:00001899                 mov     dword ptr [eax+0CCh], 0
.text$mn:000018A3                 mov     eax, [ebp+var_8]
.text$mn:000018A6                 movss   xmm0, ds:__real@c2c60000
.text$mn:000018AE                 movss   dword ptr [eax+0D0h], xmm0
.text$mn:000018B6                 push    0FFFFFFFFh
.text$mn:000018B8                 push    0FFFFFFFFh
.text$mn:000018BA                 mov     ecx, [ebp+var_8]
.text$mn:000018BD                 add     ecx, 0D4h ; '+'
.text$mn:000018C3                 call    ??0?$PointT@H@geomutil@@QAE@HH@Z ; geomutil::PointT<int>::PointT<int>(int,int)
.text$mn:000018C8                 mov     eax, [ebp+var_8]
.text$mn:000018CB                 mov     byte ptr [eax+0DCh], 0
.text$mn:000018D2                 mov     eax, [ebp+var_8]
.text$mn:000018D5                 mov     dword ptr [eax+0E0h], 0
.text$mn:000018DF                 push    0
.text$mn:000018E1                 mov     ecx, [ebp+var_8]
.text$mn:000018E4                 add     ecx, 0E4h ; 'S'
.text$mn:000018EA                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:000018EF                 mov     eax, [ebp+var_8]
.text$mn:000018F2                 mov     byte ptr [eax+0E8h], 0
.text$mn:000018F9                 mov     eax, [ebp+var_8]
.text$mn:000018FC                 mov     byte ptr [eax+0E9h], 0
.text$mn:00001903                 push    0
.text$mn:00001905                 mov     ecx, [ebp+var_8]
.text$mn:00001908                 add     ecx, 0ECh ; '8'
.text$mn:0000190E                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:00001913                 push    0
.text$mn:00001915                 mov     ecx, [ebp+var_8]
.text$mn:00001918                 add     ecx, 0F0h ; '='
.text$mn:0000191E                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:00001923                 mov     eax, [ebp+var_8]
.text$mn:00001926                 mov     byte ptr [eax+0F4h], 0
.text$mn:0000192D                 push    0
.text$mn:0000192F                 mov     ecx, [ebp+var_8]
.text$mn:00001932                 add     ecx, 0F8h ; ''
.text$mn:00001938                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:0000193D                 push    0
.text$mn:0000193F                 mov     ecx, [ebp+var_8]
.text$mn:00001942                 add     ecx, 0FCh ; 'n'
.text$mn:00001948                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:0000194D                 push    0
.text$mn:0000194F                 mov     ecx, [ebp+var_8]
.text$mn:00001952                 add     ecx, 100h
.text$mn:00001958                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:0000195D                 mov     eax, [ebp+var_8]
.text$mn:00001960                 mov     dword ptr [eax+104h], 1
.text$mn:0000196A                 mov     eax, [ebp+var_8]
.text$mn:0000196D                 mov     dword ptr [eax+108h], 1
.text$mn:00001977                 mov     eax, [ebp+var_8]
.text$mn:0000197A                 mov     byte ptr [eax+10Ch], 0
.text$mn:00001981                 mov     eax, [ebp+var_8]
.text$mn:00001984                 mov     byte ptr [eax+10Dh], 0
.text$mn:0000198B                 push    0
.text$mn:0000198D                 mov     ecx, [ebp+var_8]
.text$mn:00001990                 add     ecx, 110h
.text$mn:00001996                 call    ??0?$ScopedMem@D@@QAE@PAD@Z ; ScopedMem<char>::ScopedMem<char>(char *)
.text$mn:0000199B                 mov     ecx, [ebp+var_8]
.text$mn:0000199E                 add     ecx, 114h       ; this
.text$mn:000019A4                 call    ??0WStrVec@@QAE@XZ ; WStrVec::WStrVec(void)
.text$mn:000019A9                 mov     eax, [ebp+var_8]
.text$mn:000019AC                 pop     edi
.text$mn:000019AD                 pop     esi
.text$mn:000019AE                 pop     ebx
.text$mn:000019AF                 add     esp, 0CCh
.text$mn:000019B5                 cmp     ebp, esp
.text$mn:000019B7                 call    __RTC_CheckEsp
.text$mn:000019BC                 mov     esp, ebp
.text$mn:000019BE                 pop     ebp
.text$mn:000019BF                 retn
.text$mn:000019BF ??0CommandLineInfo@@QAE@XZ endp
.text$mn:000019BF
.text$mn:000019BF _text$mn        ends
.text$mn:000019BF
.text$mn:000019C0 ; ===========================================================================
.text$mn:000019C0
.text$mn:000019C0 ; Segment type: Pure code
.text$mn:000019C0 ; Segment permissions: Read/Execute
.text$mn:000019C0 _text$mn        segment para public 'CODE' use32
.text$mn:000019C0                 assume cs:_text$mn
.text$mn:000019C0                 ;org 19C0h
.text$mn:000019C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019C0
.text$mn:000019C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000019C0
.text$mn:000019C0 ; Attributes: bp-based frame
.text$mn:000019C0
.text$mn:000019C0 ; public: __thiscall FileExistenceChecker::FileExistenceChecker(void)
.text$mn:000019C0                 public ??0FileExistenceChecker@@QAE@XZ
.text$mn:000019C0 ??0FileExistenceChecker@@QAE@XZ proc near
.text$mn:000019C0                                         ; CODE XREF: WinMain(x,x,x,x)+A41p
.text$mn:000019C0
.text$mn:000019C0 var_CC          = byte ptr -0CCh
.text$mn:000019C0 var_8           = dword ptr -8
.text$mn:000019C0
.text$mn:000019C0                 push    ebp
.text$mn:000019C1                 mov     ebp, esp
.text$mn:000019C3                 sub     esp, 0CCh
.text$mn:000019C9                 push    ebx
.text$mn:000019CA                 push    esi
.text$mn:000019CB                 push    edi
.text$mn:000019CC                 push    ecx
.text$mn:000019CD                 lea     edi, [ebp+var_CC]
.text$mn:000019D3                 mov     ecx, 33h ; '3'
.text$mn:000019D8                 mov     eax, 0CCCCCCCCh
.text$mn:000019DD                 rep stosd
.text$mn:000019DF                 pop     ecx
.text$mn:000019E0                 mov     [ebp+var_8], ecx
.text$mn:000019E3                 push    0
.text$mn:000019E5                 mov     ecx, [ebp+var_8]
.text$mn:000019E8                 call    ??0ThreadBase@@QAE@PBD@Z ; ThreadBase::ThreadBase(char const *)
.text$mn:000019ED                 mov     eax, [ebp+var_8]
.text$mn:000019F0                 mov     dword ptr [eax], offset ??_7FileExistenceChecker@@6B@ ; const FileExistenceChecker::`vftable'
.text$mn:000019F6                 mov     ecx, [ebp+var_8]
.text$mn:000019F9                 add     ecx, 14h        ; this
.text$mn:000019FC                 call    ??0WStrVec@@QAE@XZ ; WStrVec::WStrVec(void)
.text$mn:00001A01                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001A04                 call    ?GetFilePathsToCheck@FileExistenceChecker@@AAEXXZ ; FileExistenceChecker::GetFilePathsToCheck(void)
.text$mn:00001A09                 mov     eax, [ebp+var_8]
.text$mn:00001A0C                 pop     edi
.text$mn:00001A0D                 pop     esi
.text$mn:00001A0E                 pop     ebx
.text$mn:00001A0F                 add     esp, 0CCh
.text$mn:00001A15                 cmp     ebp, esp
.text$mn:00001A17                 call    __RTC_CheckEsp
.text$mn:00001A1C                 mov     esp, ebp
.text$mn:00001A1E                 pop     ebp
.text$mn:00001A1F                 retn
.text$mn:00001A1F ??0FileExistenceChecker@@QAE@XZ endp
.text$mn:00001A1F
.text$mn:00001A1F _text$mn        ends
.text$mn:00001A1F
.text$mn:00001A20 ; ===========================================================================
.text$mn:00001A20
.text$mn:00001A20 ; Segment type: Pure code
.text$mn:00001A20 ; Segment permissions: Read/Execute
.text$mn:00001A20 _text$mn        segment para public 'CODE' use32
.text$mn:00001A20                 assume cs:_text$mn
.text$mn:00001A20                 ;org 1A20h
.text$mn:00001A20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A20
.text$mn:00001A20 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A20
.text$mn:00001A20 ; Attributes: bp-based frame
.text$mn:00001A20
.text$mn:00001A20 ; _DWORD __thiscall Gdiplus::GdiplusStartupInput::GdiplusStartupInput(Gdiplus::GdiplusStartupInput *this, void (__stdcall __high *)(enum Gdiplus::DebugEventLevel, char *), int, int)
.text$mn:00001A20                 public ??0GdiplusStartupInput@Gdiplus@@QAE@P6GXW4DebugEventLevel@1@PAD@ZHH@Z
.text$mn:00001A20 ??0GdiplusStartupInput@Gdiplus@@QAE@P6GXW4DebugEventLevel@1@PAD@ZHH@Z proc near
.text$mn:00001A20                                         ; CODE XREF: ScopedGdiPlus::ScopedGdiPlus(bool)+2Cp
.text$mn:00001A20
.text$mn:00001A20 var_CC          = byte ptr -0CCh
.text$mn:00001A20 var_8           = dword ptr -8
.text$mn:00001A20 arg_0           = dword ptr  8
.text$mn:00001A20 arg_4           = dword ptr  0Ch
.text$mn:00001A20 arg_8           = dword ptr  10h
.text$mn:00001A20
.text$mn:00001A20                 push    ebp
.text$mn:00001A21                 mov     ebp, esp
.text$mn:00001A23                 sub     esp, 0CCh
.text$mn:00001A29                 push    ebx
.text$mn:00001A2A                 push    esi
.text$mn:00001A2B                 push    edi
.text$mn:00001A2C                 push    ecx
.text$mn:00001A2D                 lea     edi, [ebp+var_CC]
.text$mn:00001A33                 mov     ecx, 33h ; '3'
.text$mn:00001A38                 mov     eax, 0CCCCCCCCh
.text$mn:00001A3D                 rep stosd
.text$mn:00001A3F                 pop     ecx
.text$mn:00001A40                 mov     [ebp+var_8], ecx
.text$mn:00001A43                 mov     eax, [ebp+var_8]
.text$mn:00001A46                 mov     dword ptr [eax], 1
.text$mn:00001A4C                 mov     eax, [ebp+var_8]
.text$mn:00001A4F                 mov     ecx, [ebp+arg_0]
.text$mn:00001A52                 mov     [eax+4], ecx
.text$mn:00001A55                 mov     eax, [ebp+var_8]
.text$mn:00001A58                 mov     ecx, [ebp+arg_4]
.text$mn:00001A5B                 mov     [eax+8], ecx
.text$mn:00001A5E                 mov     eax, [ebp+var_8]
.text$mn:00001A61                 mov     ecx, [ebp+arg_8]
.text$mn:00001A64                 mov     [eax+0Ch], ecx
.text$mn:00001A67                 mov     eax, [ebp+var_8]
.text$mn:00001A6A                 pop     edi
.text$mn:00001A6B                 pop     esi
.text$mn:00001A6C                 pop     ebx
.text$mn:00001A6D                 mov     esp, ebp
.text$mn:00001A6F                 pop     ebp
.text$mn:00001A70                 retn    0Ch
.text$mn:00001A70 ??0GdiplusStartupInput@Gdiplus@@QAE@P6GXW4DebugEventLevel@1@PAD@ZHH@Z endp
.text$mn:00001A70
.text$mn:00001A70 ; ---------------------------------------------------------------------------
.text$mn:00001A73                 align 4
.text$mn:00001A73 _text$mn        ends
.text$mn:00001A73
.text$mn:00001A74 ; ===========================================================================
.text$mn:00001A74
.text$mn:00001A74 ; Segment type: Pure code
.text$mn:00001A74 ; Segment permissions: Read/Execute
.text$mn:00001A74 _text$mn        segment para public 'CODE' use32
.text$mn:00001A74                 assume cs:_text$mn
.text$mn:00001A74                 ;org 1A74h
.text$mn:00001A74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A74
.text$mn:00001A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A74
.text$mn:00001A74 ; Attributes: bp-based frame
.text$mn:00001A74
.text$mn:00001A74 ; public: __thiscall Vec<struct SessionData *>::Iter::Iter(class Vec<struct SessionData *> *, unsigned int)
.text$mn:00001A74                 public ??0Iter@?$Vec@PAUSessionData@@@@QAE@PAV1@I@Z
.text$mn:00001A74 ??0Iter@?$Vec@PAUSessionData@@@@QAE@PAV1@I@Z proc near
.text$mn:00001A74                                         ; CODE XREF: Vec<SessionData *>::begin(void)+2Cp
.text$mn:00001A74                                         ; Vec<SessionData *>::end(void)+30p
.text$mn:00001A74
.text$mn:00001A74 var_CC          = byte ptr -0CCh
.text$mn:00001A74 var_8           = dword ptr -8
.text$mn:00001A74 arg_0           = dword ptr  8
.text$mn:00001A74 arg_4           = dword ptr  0Ch
.text$mn:00001A74
.text$mn:00001A74                 push    ebp
.text$mn:00001A75                 mov     ebp, esp
.text$mn:00001A77                 sub     esp, 0CCh
.text$mn:00001A7D                 push    ebx
.text$mn:00001A7E                 push    esi
.text$mn:00001A7F                 push    edi
.text$mn:00001A80                 push    ecx
.text$mn:00001A81                 lea     edi, [ebp+var_CC]
.text$mn:00001A87                 mov     ecx, 33h ; '3'
.text$mn:00001A8C                 mov     eax, 0CCCCCCCCh
.text$mn:00001A91                 rep stosd
.text$mn:00001A93                 pop     ecx
.text$mn:00001A94                 mov     [ebp+var_8], ecx
.text$mn:00001A97                 mov     eax, [ebp+var_8]
.text$mn:00001A9A                 mov     ecx, [ebp+arg_0]
.text$mn:00001A9D                 mov     [eax], ecx
.text$mn:00001A9F                 mov     eax, [ebp+var_8]
.text$mn:00001AA2                 mov     ecx, [ebp+arg_4]
.text$mn:00001AA5                 mov     [eax+4], ecx
.text$mn:00001AA8                 mov     eax, [ebp+var_8]
.text$mn:00001AAB                 pop     edi
.text$mn:00001AAC                 pop     esi
.text$mn:00001AAD                 pop     ebx
.text$mn:00001AAE                 mov     esp, ebp
.text$mn:00001AB0                 pop     ebp
.text$mn:00001AB1                 retn    8
.text$mn:00001AB1 ??0Iter@?$Vec@PAUSessionData@@@@QAE@PAV1@I@Z endp
.text$mn:00001AB1
.text$mn:00001AB1 _text$mn        ends
.text$mn:00001AB1
.text$mn:00001AB4 ; ===========================================================================
.text$mn:00001AB4
.text$mn:00001AB4 ; Segment type: Pure code
.text$mn:00001AB4 ; Segment permissions: Read/Execute
.text$mn:00001AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AB4                 assume cs:_text$mn
.text$mn:00001AB4                 ;org 1AB4h
.text$mn:00001AB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AB4
.text$mn:00001AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AB4
.text$mn:00001AB4 ; Attributes: bp-based frame
.text$mn:00001AB4
.text$mn:00001AB4 ; public: __thiscall Vec<struct TabState *>::Iter::Iter(class Vec<struct TabState *> *, unsigned int)
.text$mn:00001AB4                 public ??0Iter@?$Vec@PAUTabState@@@@QAE@PAV1@I@Z
.text$mn:00001AB4 ??0Iter@?$Vec@PAUTabState@@@@QAE@PAV1@I@Z proc near
.text$mn:00001AB4                                         ; CODE XREF: Vec<TabState *>::begin(void)+2Cp
.text$mn:00001AB4                                         ; Vec<TabState *>::end(void)+30p
.text$mn:00001AB4
.text$mn:00001AB4 var_CC          = byte ptr -0CCh
.text$mn:00001AB4 var_8           = dword ptr -8
.text$mn:00001AB4 arg_0           = dword ptr  8
.text$mn:00001AB4 arg_4           = dword ptr  0Ch
.text$mn:00001AB4
.text$mn:00001AB4                 push    ebp
.text$mn:00001AB5                 mov     ebp, esp
.text$mn:00001AB7                 sub     esp, 0CCh
.text$mn:00001ABD                 push    ebx
.text$mn:00001ABE                 push    esi
.text$mn:00001ABF                 push    edi
.text$mn:00001AC0                 push    ecx
.text$mn:00001AC1                 lea     edi, [ebp+var_CC]
.text$mn:00001AC7                 mov     ecx, 33h ; '3'
.text$mn:00001ACC                 mov     eax, 0CCCCCCCCh
.text$mn:00001AD1                 rep stosd
.text$mn:00001AD3                 pop     ecx
.text$mn:00001AD4                 mov     [ebp+var_8], ecx
.text$mn:00001AD7                 mov     eax, [ebp+var_8]
.text$mn:00001ADA                 mov     ecx, [ebp+arg_0]
.text$mn:00001ADD                 mov     [eax], ecx
.text$mn:00001ADF                 mov     eax, [ebp+var_8]
.text$mn:00001AE2                 mov     ecx, [ebp+arg_4]
.text$mn:00001AE5                 mov     [eax+4], ecx
.text$mn:00001AE8                 mov     eax, [ebp+var_8]
.text$mn:00001AEB                 pop     edi
.text$mn:00001AEC                 pop     esi
.text$mn:00001AED                 pop     ebx
.text$mn:00001AEE                 mov     esp, ebp
.text$mn:00001AF0                 pop     ebp
.text$mn:00001AF1                 retn    8
.text$mn:00001AF1 ??0Iter@?$Vec@PAUTabState@@@@QAE@PAV1@I@Z endp
.text$mn:00001AF1
.text$mn:00001AF1 _text$mn        ends
.text$mn:00001AF1
.text$mn:00001AF4 ; ===========================================================================
.text$mn:00001AF4
.text$mn:00001AF4 ; Segment type: Pure code
.text$mn:00001AF4 ; Segment permissions: Read/Execute
.text$mn:00001AF4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AF4                 assume cs:_text$mn
.text$mn:00001AF4                 ;org 1AF4h
.text$mn:00001AF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AF4
.text$mn:00001AF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AF4
.text$mn:00001AF4 ; Attributes: bp-based frame
.text$mn:00001AF4
.text$mn:00001AF4 ; public: __thiscall Vec<wchar_t *>::Iter::Iter(class Vec<wchar_t *> *, unsigned int)
.text$mn:00001AF4                 public ??0Iter@?$Vec@PA_W@@QAE@PAV1@I@Z
.text$mn:00001AF4 ??0Iter@?$Vec@PA_W@@QAE@PAV1@I@Z proc near
.text$mn:00001AF4                                         ; CODE XREF: Vec<wchar_t *>::begin(void)+2Cp
.text$mn:00001AF4                                         ; Vec<wchar_t *>::end(void)+30p
.text$mn:00001AF4
.text$mn:00001AF4 var_CC          = byte ptr -0CCh
.text$mn:00001AF4 var_8           = dword ptr -8
.text$mn:00001AF4 arg_0           = dword ptr  8
.text$mn:00001AF4 arg_4           = dword ptr  0Ch
.text$mn:00001AF4
.text$mn:00001AF4                 push    ebp
.text$mn:00001AF5                 mov     ebp, esp
.text$mn:00001AF7                 sub     esp, 0CCh
.text$mn:00001AFD                 push    ebx
.text$mn:00001AFE                 push    esi
.text$mn:00001AFF                 push    edi
.text$mn:00001B00                 push    ecx
.text$mn:00001B01                 lea     edi, [ebp+var_CC]
.text$mn:00001B07                 mov     ecx, 33h ; '3'
.text$mn:00001B0C                 mov     eax, 0CCCCCCCCh
.text$mn:00001B11                 rep stosd
.text$mn:00001B13                 pop     ecx
.text$mn:00001B14                 mov     [ebp+var_8], ecx
.text$mn:00001B17                 mov     eax, [ebp+var_8]
.text$mn:00001B1A                 mov     ecx, [ebp+arg_0]
.text$mn:00001B1D                 mov     [eax], ecx
.text$mn:00001B1F                 mov     eax, [ebp+var_8]
.text$mn:00001B22                 mov     ecx, [ebp+arg_4]
.text$mn:00001B25                 mov     [eax+4], ecx
.text$mn:00001B28                 mov     eax, [ebp+var_8]
.text$mn:00001B2B                 pop     edi
.text$mn:00001B2C                 pop     esi
.text$mn:00001B2D                 pop     ebx
.text$mn:00001B2E                 mov     esp, ebp
.text$mn:00001B30                 pop     ebp
.text$mn:00001B31                 retn    8
.text$mn:00001B31 ??0Iter@?$Vec@PA_W@@QAE@PAV1@I@Z endp
.text$mn:00001B31
.text$mn:00001B31 _text$mn        ends
.text$mn:00001B31
.text$mn:00001B34 ; ===========================================================================
.text$mn:00001B34
.text$mn:00001B34 ; Segment type: Pure code
.text$mn:00001B34 ; Segment permissions: Read/Execute
.text$mn:00001B34 _text$mn        segment para public 'CODE' use32
.text$mn:00001B34                 assume cs:_text$mn
.text$mn:00001B34                 ;org 1B34h
.text$mn:00001B34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B34
.text$mn:00001B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B34
.text$mn:00001B34 ; Attributes: bp-based frame
.text$mn:00001B34
.text$mn:00001B34 ; _DWORD __thiscall LoadArgs::LoadArgs(LoadArgs *this, const wchar_t *, struct WindowInfo *)
.text$mn:00001B34                 public ??0LoadArgs@@QAE@PB_WPAVWindowInfo@@@Z
.text$mn:00001B34 ??0LoadArgs@@QAE@PB_WPAVWindowInfo@@@Z proc near
.text$mn:00001B34                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+31p
.text$mn:00001B34                                         ; RestoreTabOnStartup(WindowInfo *,TabState *)+2Bp
.text$mn:00001B34
.text$mn:00001B34 var_CC          = byte ptr -0CCh
.text$mn:00001B34 var_8           = dword ptr -8
.text$mn:00001B34 arg_0           = dword ptr  8
.text$mn:00001B34 arg_4           = dword ptr  0Ch
.text$mn:00001B34
.text$mn:00001B34                 push    ebp
.text$mn:00001B35                 mov     ebp, esp
.text$mn:00001B37                 sub     esp, 0CCh
.text$mn:00001B3D                 push    ebx
.text$mn:00001B3E                 push    esi
.text$mn:00001B3F                 push    edi
.text$mn:00001B40                 push    ecx
.text$mn:00001B41                 lea     edi, [ebp+var_CC]
.text$mn:00001B47                 mov     ecx, 33h ; '3'
.text$mn:00001B4C                 mov     eax, 0CCCCCCCCh
.text$mn:00001B51                 rep stosd
.text$mn:00001B53                 pop     ecx
.text$mn:00001B54                 mov     [ebp+var_8], ecx
.text$mn:00001B57                 mov     eax, [ebp+var_8]
.text$mn:00001B5A                 mov     ecx, [ebp+arg_0]
.text$mn:00001B5D                 mov     [eax], ecx
.text$mn:00001B5F                 mov     eax, [ebp+var_8]
.text$mn:00001B62                 mov     ecx, [ebp+arg_4]
.text$mn:00001B65                 mov     [eax+4], ecx
.text$mn:00001B68                 mov     eax, [ebp+var_8]
.text$mn:00001B6B                 mov     byte ptr [eax+8], 1
.text$mn:00001B6F                 mov     eax, [ebp+var_8]
.text$mn:00001B72                 mov     byte ptr [eax+9], 0
.text$mn:00001B76                 mov     eax, [ebp+var_8]
.text$mn:00001B79                 mov     byte ptr [eax+0Ah], 0
.text$mn:00001B7D                 mov     eax, [ebp+var_8]
.text$mn:00001B80                 mov     byte ptr [eax+0Bh], 1
.text$mn:00001B84                 mov     eax, [ebp+var_8]
.text$mn:00001B87                 mov     byte ptr [eax+0Ch], 1
.text$mn:00001B8B                 mov     eax, [ebp+var_8]
.text$mn:00001B8E                 pop     edi
.text$mn:00001B8F                 pop     esi
.text$mn:00001B90                 pop     ebx
.text$mn:00001B91                 mov     esp, ebp
.text$mn:00001B93                 pop     ebp
.text$mn:00001B94                 retn    8
.text$mn:00001B94 ??0LoadArgs@@QAE@PB_WPAVWindowInfo@@@Z endp
.text$mn:00001B94
.text$mn:00001B94 ; ---------------------------------------------------------------------------
.text$mn:00001B97                 align 4
.text$mn:00001B97 _text$mn        ends
.text$mn:00001B97
.text$mn:00001B98 ; ===========================================================================
.text$mn:00001B98
.text$mn:00001B98 ; Segment type: Pure code
.text$mn:00001B98 ; Segment permissions: Read/Execute
.text$mn:00001B98 _text$mn        segment para public 'CODE' use32
.text$mn:00001B98                 assume cs:_text$mn
.text$mn:00001B98                 ;org 1B98h
.text$mn:00001B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B98
.text$mn:00001B98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B98
.text$mn:00001B98 ; Attributes: bp-based frame
.text$mn:00001B98
.text$mn:00001B98 ; _DWORD __thiscall ScopedGdiPlus::ScopedGdiPlus(ScopedGdiPlus *this, bool)
.text$mn:00001B98                 public ??0ScopedGdiPlus@@QAE@_N@Z
.text$mn:00001B98 ??0ScopedGdiPlus@@QAE@_N@Z proc near    ; CODE XREF: WinMain(x,x,x,x)+110p
.text$mn:00001B98
.text$mn:00001B98 var_CC          = byte ptr -0CCh
.text$mn:00001B98 var_8           = dword ptr -8
.text$mn:00001B98 arg_0           = byte ptr  8
.text$mn:00001B98
.text$mn:00001B98                 push    ebp
.text$mn:00001B99                 mov     ebp, esp
.text$mn:00001B9B                 sub     esp, 0CCh
.text$mn:00001BA1                 push    ebx
.text$mn:00001BA2                 push    esi
.text$mn:00001BA3                 push    edi
.text$mn:00001BA4                 push    ecx
.text$mn:00001BA5                 lea     edi, [ebp+var_CC]
.text$mn:00001BAB                 mov     ecx, 33h ; '3'
.text$mn:00001BB0                 mov     eax, 0CCCCCCCCh
.text$mn:00001BB5                 rep stosd
.text$mn:00001BB7                 pop     ecx
.text$mn:00001BB8                 mov     [ebp+var_8], ecx
.text$mn:00001BBB                 push    0               ; int
.text$mn:00001BBD                 push    0               ; int
.text$mn:00001BBF                 push    0               ; void (__stdcall __high *)(enum Gdiplus::DebugEventLevel, char *)
.text$mn:00001BC1                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001BC4                 call    ??0GdiplusStartupInput@Gdiplus@@QAE@P6GXW4DebugEventLevel@1@PAD@ZHH@Z ; Gdiplus::GdiplusStartupInput::GdiplusStartupInput(void (*)(Gdiplus::DebugEventLevel,char *),int,int)
.text$mn:00001BC9                 mov     eax, [ebp+var_8]
.text$mn:00001BCC                 mov     cl, [ebp+arg_0]
.text$mn:00001BCF                 mov     [eax+20h], cl
.text$mn:00001BD2                 mov     eax, [ebp+var_8]
.text$mn:00001BD5                 movzx   ecx, byte ptr [eax+20h]
.text$mn:00001BD9                 mov     edx, [ebp+var_8]
.text$mn:00001BDC                 mov     [edx+8], ecx
.text$mn:00001BDF                 mov     eax, [ebp+var_8]
.text$mn:00001BE2                 add     eax, 10h
.text$mn:00001BE5                 push    eax
.text$mn:00001BE6                 mov     ecx, [ebp+var_8]
.text$mn:00001BE9                 push    ecx
.text$mn:00001BEA                 mov     edx, [ebp+var_8]
.text$mn:00001BED                 add     edx, 18h
.text$mn:00001BF0                 push    edx
.text$mn:00001BF1                 call    _GdiplusStartup@12 ; GdiplusStartup(x,x,x)
.text$mn:00001BF6                 mov     eax, [ebp+var_8]
.text$mn:00001BF9                 movzx   ecx, byte ptr [eax+20h]
.text$mn:00001BFD                 test    ecx, ecx
.text$mn:00001BFF                 jz      short loc_1C19
.text$mn:00001C01                 mov     eax, [ebp+var_8]
.text$mn:00001C04                 add     eax, 1Ch
.text$mn:00001C07                 mov     esi, esp
.text$mn:00001C09                 push    eax
.text$mn:00001C0A                 mov     ecx, [ebp+var_8]
.text$mn:00001C0D                 mov     edx, [ecx+10h]
.text$mn:00001C10                 call    edx
.text$mn:00001C12                 cmp     esi, esp
.text$mn:00001C14                 call    __RTC_CheckEsp
.text$mn:00001C19
.text$mn:00001C19 loc_1C19:                               ; CODE XREF: ScopedGdiPlus::ScopedGdiPlus(bool)+67j
.text$mn:00001C19                 mov     eax, [ebp+var_8]
.text$mn:00001C1C                 pop     edi
.text$mn:00001C1D                 pop     esi
.text$mn:00001C1E                 pop     ebx
.text$mn:00001C1F                 add     esp, 0CCh
.text$mn:00001C25                 cmp     ebp, esp
.text$mn:00001C27                 call    __RTC_CheckEsp
.text$mn:00001C2C                 mov     esp, ebp
.text$mn:00001C2E                 pop     ebp
.text$mn:00001C2F                 retn    4
.text$mn:00001C2F ??0ScopedGdiPlus@@QAE@_N@Z endp
.text$mn:00001C2F
.text$mn:00001C2F ; ---------------------------------------------------------------------------
.text$mn:00001C32                 align 4
.text$mn:00001C32 _text$mn        ends
.text$mn:00001C32
.text$mn:00001C34 ; ===========================================================================
.text$mn:00001C34
.text$mn:00001C34 ; Segment type: Pure code
.text$mn:00001C34 ; Segment permissions: Read/Execute
.text$mn:00001C34 _text$mn        segment para public 'CODE' use32
.text$mn:00001C34                 assume cs:_text$mn
.text$mn:00001C34                 ;org 1C34h
.text$mn:00001C34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C34
.text$mn:00001C34 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C34
.text$mn:00001C34 ; Attributes: bp-based frame
.text$mn:00001C34
.text$mn:00001C34 ; _DWORD __thiscall ScopedOle::ScopedOle(ScopedOle *__hidden this)
.text$mn:00001C34                 public ??0ScopedOle@@QAE@XZ
.text$mn:00001C34 ??0ScopedOle@@QAE@XZ proc near          ; CODE XREF: WinMain(x,x,x,x)+101p
.text$mn:00001C34
.text$mn:00001C34 var_CC          = byte ptr -0CCh
.text$mn:00001C34 var_8           = dword ptr -8
.text$mn:00001C34
.text$mn:00001C34                 push    ebp
.text$mn:00001C35                 mov     ebp, esp
.text$mn:00001C37                 sub     esp, 0CCh
.text$mn:00001C3D                 push    ebx
.text$mn:00001C3E                 push    esi
.text$mn:00001C3F                 push    edi
.text$mn:00001C40                 push    ecx
.text$mn:00001C41                 lea     edi, [ebp+var_CC]
.text$mn:00001C47                 mov     ecx, 33h ; '3'
.text$mn:00001C4C                 mov     eax, 0CCCCCCCCh
.text$mn:00001C51                 rep stosd
.text$mn:00001C53                 pop     ecx
.text$mn:00001C54                 mov     [ebp+var_8], ecx
.text$mn:00001C57                 mov     esi, esp
.text$mn:00001C59                 push    0               ; pvReserved
.text$mn:00001C5B                 call    dword ptr ds:__imp__OleInitialize@4 ; OleInitialize(x)
.text$mn:00001C61                 cmp     esi, esp
.text$mn:00001C63                 call    __RTC_CheckEsp
.text$mn:00001C68                 mov     eax, [ebp+var_8]
.text$mn:00001C6B                 pop     edi
.text$mn:00001C6C                 pop     esi
.text$mn:00001C6D                 pop     ebx
.text$mn:00001C6E                 add     esp, 0CCh
.text$mn:00001C74                 cmp     ebp, esp
.text$mn:00001C76                 call    __RTC_CheckEsp
.text$mn:00001C7B                 mov     esp, ebp
.text$mn:00001C7D                 pop     ebp
.text$mn:00001C7E                 retn
.text$mn:00001C7E ??0ScopedOle@@QAE@XZ endp
.text$mn:00001C7E
.text$mn:00001C7E ; ---------------------------------------------------------------------------
.text$mn:00001C7F                 align 10h
.text$mn:00001C7F _text$mn        ends
.text$mn:00001C7F
.text$mn:00001C80 ; ===========================================================================
.text$mn:00001C80
.text$mn:00001C80 ; Segment type: Pure code
.text$mn:00001C80 ; Segment permissions: Read/Execute
.text$mn:00001C80 _text$mn        segment para public 'CODE' use32
.text$mn:00001C80                 assume cs:_text$mn
.text$mn:00001C80                 ;org 1C80h
.text$mn:00001C80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C80
.text$mn:00001C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C80
.text$mn:00001C80 ; Attributes: bp-based frame
.text$mn:00001C80
.text$mn:00001C80 ; _DWORD __thiscall ScrollState::ScrollState(ScrollState *this, int, double, double)
.text$mn:00001C80                 public ??0ScrollState@@QAE@HNN@Z
.text$mn:00001C80 ??0ScrollState@@QAE@HNN@Z proc near     ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+1B5p
.text$mn:00001C80
.text$mn:00001C80 var_CC          = byte ptr -0CCh
.text$mn:00001C80 var_8           = dword ptr -8
.text$mn:00001C80 arg_0           = dword ptr  8
.text$mn:00001C80 arg_4           = qword ptr  0Ch
.text$mn:00001C80 arg_C           = qword ptr  14h
.text$mn:00001C80
.text$mn:00001C80                 push    ebp
.text$mn:00001C81                 mov     ebp, esp
.text$mn:00001C83                 sub     esp, 0CCh
.text$mn:00001C89                 push    ebx
.text$mn:00001C8A                 push    esi
.text$mn:00001C8B                 push    edi
.text$mn:00001C8C                 push    ecx
.text$mn:00001C8D                 lea     edi, [ebp+var_CC]
.text$mn:00001C93                 mov     ecx, 33h ; '3'
.text$mn:00001C98                 mov     eax, 0CCCCCCCCh
.text$mn:00001C9D                 rep stosd
.text$mn:00001C9F                 pop     ecx
.text$mn:00001CA0                 mov     [ebp+var_8], ecx
.text$mn:00001CA3                 mov     eax, [ebp+var_8]
.text$mn:00001CA6                 mov     ecx, [ebp+arg_0]
.text$mn:00001CA9                 mov     [eax], ecx
.text$mn:00001CAB                 mov     eax, [ebp+var_8]
.text$mn:00001CAE                 movsd   xmm0, [ebp+arg_4]
.text$mn:00001CB3                 movsd   qword ptr [eax+8], xmm0
.text$mn:00001CB8                 mov     eax, [ebp+var_8]
.text$mn:00001CBB                 movsd   xmm0, [ebp+arg_C]
.text$mn:00001CC0                 movsd   qword ptr [eax+10h], xmm0
.text$mn:00001CC5                 mov     eax, [ebp+var_8]
.text$mn:00001CC8                 pop     edi
.text$mn:00001CC9                 pop     esi
.text$mn:00001CCA                 pop     ebx
.text$mn:00001CCB                 mov     esp, ebp
.text$mn:00001CCD                 pop     ebp
.text$mn:00001CCE                 retn    14h
.text$mn:00001CCE ??0ScrollState@@QAE@HNN@Z endp
.text$mn:00001CCE
.text$mn:00001CCE ; ---------------------------------------------------------------------------
.text$mn:00001CD1                 align 4
.text$mn:00001CD1 _text$mn        ends
.text$mn:00001CD1
.text$mn:00001CD4 ; ===========================================================================
.text$mn:00001CD4
.text$mn:00001CD4 ; Segment type: Pure code
.text$mn:00001CD4 ; Segment permissions: Read/Execute
.text$mn:00001CD4 _text$mn        segment para public 'CODE' use32
.text$mn:00001CD4                 assume cs:_text$mn
.text$mn:00001CD4                 ;org 1CD4h
.text$mn:00001CD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CD4
.text$mn:00001CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CD4
.text$mn:00001CD4 ; Attributes: bp-based frame
.text$mn:00001CD4
.text$mn:00001CD4 ; _DWORD __thiscall WStrVec::WStrVec(WStrVec *__hidden this)
.text$mn:00001CD4                 public ??0WStrVec@@QAE@XZ
.text$mn:00001CD4 ??0WStrVec@@QAE@XZ proc near            ; CODE XREF: CommandLineInfo::CommandLineInfo(void)+26p
.text$mn:00001CD4                                         ; CommandLineInfo::CommandLineInfo(void)+31p ...
.text$mn:00001CD4
.text$mn:00001CD4 var_CC          = byte ptr -0CCh
.text$mn:00001CD4 var_8           = dword ptr -8
.text$mn:00001CD4
.text$mn:00001CD4                 push    ebp
.text$mn:00001CD5                 mov     ebp, esp
.text$mn:00001CD7                 sub     esp, 0CCh
.text$mn:00001CDD                 push    ebx
.text$mn:00001CDE                 push    esi
.text$mn:00001CDF                 push    edi
.text$mn:00001CE0                 push    ecx
.text$mn:00001CE1                 lea     edi, [ebp+var_CC]
.text$mn:00001CE7                 mov     ecx, 33h ; '3'
.text$mn:00001CEC                 mov     eax, 0CCCCCCCCh
.text$mn:00001CF1                 rep stosd
.text$mn:00001CF3                 pop     ecx
.text$mn:00001CF4                 mov     [ebp+var_8], ecx
.text$mn:00001CF7                 push    0
.text$mn:00001CF9                 push    0
.text$mn:00001CFB                 mov     ecx, [ebp+var_8]
.text$mn:00001CFE                 call    ??0?$Vec@PA_W@@QAE@IPAVAllocator@@@Z ; Vec<wchar_t *>::Vec<wchar_t *>(uint,Allocator *)
.text$mn:00001D03                 mov     eax, [ebp+var_8]
.text$mn:00001D06                 pop     edi
.text$mn:00001D07                 pop     esi
.text$mn:00001D08                 pop     ebx
.text$mn:00001D09                 add     esp, 0CCh
.text$mn:00001D0F                 cmp     ebp, esp
.text$mn:00001D11                 call    __RTC_CheckEsp
.text$mn:00001D16                 mov     esp, ebp
.text$mn:00001D18                 pop     ebp
.text$mn:00001D19                 retn
.text$mn:00001D19 ??0WStrVec@@QAE@XZ endp
.text$mn:00001D19
.text$mn:00001D19 ; ---------------------------------------------------------------------------
.text$mn:00001D1A                 align 4
.text$mn:00001D1A _text$mn        ends
.text$mn:00001D1A
.text$mn:00001D1C ; ===========================================================================
.text$mn:00001D1C
.text$mn:00001D1C ; Segment type: Pure code
.text$mn:00001D1C ; Segment permissions: Read/Execute
.text$mn:00001D1C _text$mn        segment para public 'CODE' use32
.text$mn:00001D1C                 assume cs:_text$mn
.text$mn:00001D1C                 ;org 1D1Ch
.text$mn:00001D1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D1C
.text$mn:00001D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D1C
.text$mn:00001D1C ; Attributes: bp-based frame
.text$mn:00001D1C
.text$mn:00001D1C ; public: __thiscall ScopedMem<char>::~ScopedMem<char>(void)
.text$mn:00001D1C                 public ??1?$ScopedMem@D@@QAE@XZ
.text$mn:00001D1C ??1?$ScopedMem@D@@QAE@XZ proc near      ; CODE XREF: CommandLineInfo::~CommandLineInfo(void)+3Ap
.text$mn:00001D1C
.text$mn:00001D1C var_CC          = byte ptr -0CCh
.text$mn:00001D1C var_8           = dword ptr -8
.text$mn:00001D1C
.text$mn:00001D1C                 push    ebp
.text$mn:00001D1D                 mov     ebp, esp
.text$mn:00001D1F                 sub     esp, 0CCh
.text$mn:00001D25                 push    ebx
.text$mn:00001D26                 push    esi
.text$mn:00001D27                 push    edi
.text$mn:00001D28                 push    ecx
.text$mn:00001D29                 lea     edi, [ebp+var_CC]
.text$mn:00001D2F                 mov     ecx, 33h ; '3'
.text$mn:00001D34                 mov     eax, 0CCCCCCCCh
.text$mn:00001D39                 rep stosd
.text$mn:00001D3B                 pop     ecx
.text$mn:00001D3C                 mov     [ebp+var_8], ecx
.text$mn:00001D3F                 push    1
.text$mn:00001D41                 mov     eax, [ebp+var_8]
.text$mn:00001D44                 mov     ecx, [eax]
.text$mn:00001D46                 push    ecx
.text$mn:00001D47                 call    __free_dbg
.text$mn:00001D4C                 add     esp, 8
.text$mn:00001D4F                 pop     edi
.text$mn:00001D50                 pop     esi
.text$mn:00001D51                 pop     ebx
.text$mn:00001D52                 add     esp, 0CCh
.text$mn:00001D58                 cmp     ebp, esp
.text$mn:00001D5A                 call    __RTC_CheckEsp
.text$mn:00001D5F                 mov     esp, ebp
.text$mn:00001D61                 pop     ebp
.text$mn:00001D62                 retn
.text$mn:00001D62 ??1?$ScopedMem@D@@QAE@XZ endp
.text$mn:00001D62
.text$mn:00001D62 ; ---------------------------------------------------------------------------
.text$mn:00001D63                 align 4
.text$mn:00001D63 _text$mn        ends
.text$mn:00001D63
.text$mn:00001D64 ; ===========================================================================
.text$mn:00001D64
.text$mn:00001D64 ; Segment type: Pure code
.text$mn:00001D64 ; Segment permissions: Read/Execute
.text$mn:00001D64 _text$mn        segment para public 'CODE' use32
.text$mn:00001D64                 assume cs:_text$mn
.text$mn:00001D64                 ;org 1D64h
.text$mn:00001D64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D64
.text$mn:00001D64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D64
.text$mn:00001D64 ; Attributes: bp-based frame
.text$mn:00001D64
.text$mn:00001D64 ; public: __thiscall ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:00001D64                 public ??1?$ScopedMem@_W@@QAE@XZ
.text$mn:00001D64 ??1?$ScopedMem@_W@@QAE@XZ proc near     ; CODE XREF: CommandLineInfo::~CommandLineInfo(void)+48p
.text$mn:00001D64                                         ; CommandLineInfo::~CommandLineInfo(void)+56p ...
.text$mn:00001D64
.text$mn:00001D64 var_CC          = byte ptr -0CCh
.text$mn:00001D64 var_8           = dword ptr -8
.text$mn:00001D64
.text$mn:00001D64                 push    ebp
.text$mn:00001D65                 mov     ebp, esp
.text$mn:00001D67                 sub     esp, 0CCh
.text$mn:00001D6D                 push    ebx
.text$mn:00001D6E                 push    esi
.text$mn:00001D6F                 push    edi
.text$mn:00001D70                 push    ecx
.text$mn:00001D71                 lea     edi, [ebp+var_CC]
.text$mn:00001D77                 mov     ecx, 33h ; '3'
.text$mn:00001D7C                 mov     eax, 0CCCCCCCCh
.text$mn:00001D81                 rep stosd
.text$mn:00001D83                 pop     ecx
.text$mn:00001D84                 mov     [ebp+var_8], ecx
.text$mn:00001D87                 push    1
.text$mn:00001D89                 mov     eax, [ebp+var_8]
.text$mn:00001D8C                 mov     ecx, [eax]
.text$mn:00001D8E                 push    ecx
.text$mn:00001D8F                 call    __free_dbg
.text$mn:00001D94                 add     esp, 8
.text$mn:00001D97                 pop     edi
.text$mn:00001D98                 pop     esi
.text$mn:00001D99                 pop     ebx
.text$mn:00001D9A                 add     esp, 0CCh
.text$mn:00001DA0                 cmp     ebp, esp
.text$mn:00001DA2                 call    __RTC_CheckEsp
.text$mn:00001DA7                 mov     esp, ebp
.text$mn:00001DA9                 pop     ebp
.text$mn:00001DAA                 retn
.text$mn:00001DAA ??1?$ScopedMem@_W@@QAE@XZ endp
.text$mn:00001DAA
.text$mn:00001DAA ; ---------------------------------------------------------------------------
.text$mn:00001DAB                 align 4
.text$mn:00001DAB _text$mn        ends
.text$mn:00001DAB
.text$mn:00001DAC ; ===========================================================================
.text$mn:00001DAC
.text$mn:00001DAC ; Segment type: Pure code
.text$mn:00001DAC ; Segment permissions: Read/Execute
.text$mn:00001DAC _text$mn        segment para public 'CODE' use32
.text$mn:00001DAC                 assume cs:_text$mn
.text$mn:00001DAC                 ;org 1DACh
.text$mn:00001DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DAC
.text$mn:00001DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DAC
.text$mn:00001DAC ; Attributes: bp-based frame
.text$mn:00001DAC
.text$mn:00001DAC ; public: __thiscall str::Str<wchar_t>::~Str<wchar_t>(void)
.text$mn:00001DAC                 public ??1?$Str@_W@str@@QAE@XZ
.text$mn:00001DAC ??1?$Str@_W@str@@QAE@XZ proc near       ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+27Bp
.text$mn:00001DAC                                         ; OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+2A6p
.text$mn:00001DAC
.text$mn:00001DAC var_CC          = byte ptr -0CCh
.text$mn:00001DAC var_8           = dword ptr -8
.text$mn:00001DAC
.text$mn:00001DAC                 push    ebp
.text$mn:00001DAD                 mov     ebp, esp
.text$mn:00001DAF                 sub     esp, 0CCh
.text$mn:00001DB5                 push    ebx
.text$mn:00001DB6                 push    esi
.text$mn:00001DB7                 push    edi
.text$mn:00001DB8                 push    ecx
.text$mn:00001DB9                 lea     edi, [ebp+var_CC]
.text$mn:00001DBF                 mov     ecx, 33h ; '3'
.text$mn:00001DC4                 mov     eax, 0CCCCCCCCh
.text$mn:00001DC9                 rep stosd
.text$mn:00001DCB                 pop     ecx
.text$mn:00001DCC                 mov     [ebp+var_8], ecx
.text$mn:00001DCF                 mov     ecx, [ebp+var_8]
.text$mn:00001DD2                 call    ??1?$Vec@_W@@QAE@XZ ; Vec<wchar_t>::~Vec<wchar_t>(void)
.text$mn:00001DD7                 pop     edi
.text$mn:00001DD8                 pop     esi
.text$mn:00001DD9                 pop     ebx
.text$mn:00001DDA                 add     esp, 0CCh
.text$mn:00001DE0                 cmp     ebp, esp
.text$mn:00001DE2                 call    __RTC_CheckEsp
.text$mn:00001DE7                 mov     esp, ebp
.text$mn:00001DE9                 pop     ebp
.text$mn:00001DEA                 retn
.text$mn:00001DEA ??1?$Str@_W@str@@QAE@XZ endp
.text$mn:00001DEA
.text$mn:00001DEA ; ---------------------------------------------------------------------------
.text$mn:00001DEB                 align 4
.text$mn:00001DEB _text$mn        ends
.text$mn:00001DEB
.text$mn:00001DEC ; ===========================================================================
.text$mn:00001DEC
.text$mn:00001DEC ; Segment type: Pure code
.text$mn:00001DEC ; Segment permissions: Read/Execute
.text$mn:00001DEC _text$mn        segment para public 'CODE' use32
.text$mn:00001DEC                 assume cs:_text$mn
.text$mn:00001DEC                 ;org 1DECh
.text$mn:00001DEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DEC
.text$mn:00001DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DEC
.text$mn:00001DEC ; Attributes: bp-based frame
.text$mn:00001DEC
.text$mn:00001DEC ; public: __thiscall Vec<struct FileState *>::~Vec<struct FileState *>(void)
.text$mn:00001DEC                 public ??1?$Vec@PAUFileState@@@@QAE@XZ
.text$mn:00001DEC ??1?$Vec@PAUFileState@@@@QAE@XZ proc near
.text$mn:00001DEC                                         ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+12Ap
.text$mn:00001DEC
.text$mn:00001DEC var_CC          = byte ptr -0CCh
.text$mn:00001DEC var_8           = dword ptr -8
.text$mn:00001DEC
.text$mn:00001DEC                 push    ebp
.text$mn:00001DED                 mov     ebp, esp
.text$mn:00001DEF                 sub     esp, 0CCh
.text$mn:00001DF5                 push    ebx
.text$mn:00001DF6                 push    esi
.text$mn:00001DF7                 push    edi
.text$mn:00001DF8                 push    ecx
.text$mn:00001DF9                 lea     edi, [ebp+var_CC]
.text$mn:00001DFF                 mov     ecx, 33h ; '3'
.text$mn:00001E04                 mov     eax, 0CCCCCCCCh
.text$mn:00001E09                 rep stosd
.text$mn:00001E0B                 pop     ecx
.text$mn:00001E0C                 mov     [ebp+var_8], ecx
.text$mn:00001E0F                 mov     ecx, [ebp+var_8]
.text$mn:00001E12                 call    ?FreeEls@?$Vec@PAUFileState@@@@IAEXXZ ; Vec<FileState *>::FreeEls(void)
.text$mn:00001E17                 pop     edi
.text$mn:00001E18                 pop     esi
.text$mn:00001E19                 pop     ebx
.text$mn:00001E1A                 add     esp, 0CCh
.text$mn:00001E20                 cmp     ebp, esp
.text$mn:00001E22                 call    __RTC_CheckEsp
.text$mn:00001E27                 mov     esp, ebp
.text$mn:00001E29                 pop     ebp
.text$mn:00001E2A                 retn
.text$mn:00001E2A ??1?$Vec@PAUFileState@@@@QAE@XZ endp
.text$mn:00001E2A
.text$mn:00001E2A ; ---------------------------------------------------------------------------
.text$mn:00001E2B                 align 4
.text$mn:00001E2B _text$mn        ends
.text$mn:00001E2B
.text$mn:00001E2C ; ===========================================================================
.text$mn:00001E2C
.text$mn:00001E2C ; Segment type: Pure code
.text$mn:00001E2C ; Segment permissions: Read/Execute
.text$mn:00001E2C _text$mn        segment para public 'CODE' use32
.text$mn:00001E2C                 assume cs:_text$mn
.text$mn:00001E2C                 ;org 1E2Ch
.text$mn:00001E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E2C
.text$mn:00001E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E2C
.text$mn:00001E2C ; Attributes: bp-based frame
.text$mn:00001E2C
.text$mn:00001E2C ; public: __thiscall Vec<wchar_t *>::~Vec<wchar_t *>(void)
.text$mn:00001E2C                 public ??1?$Vec@PA_W@@QAE@XZ
.text$mn:00001E2C ??1?$Vec@PA_W@@QAE@XZ proc near         ; CODE XREF: WStrVec::~WStrVec(void)+2Ep
.text$mn:00001E2C
.text$mn:00001E2C var_CC          = byte ptr -0CCh
.text$mn:00001E2C var_8           = dword ptr -8
.text$mn:00001E2C
.text$mn:00001E2C                 push    ebp
.text$mn:00001E2D                 mov     ebp, esp
.text$mn:00001E2F                 sub     esp, 0CCh
.text$mn:00001E35                 push    ebx
.text$mn:00001E36                 push    esi
.text$mn:00001E37                 push    edi
.text$mn:00001E38                 push    ecx
.text$mn:00001E39                 lea     edi, [ebp+var_CC]
.text$mn:00001E3F                 mov     ecx, 33h ; '3'
.text$mn:00001E44                 mov     eax, 0CCCCCCCCh
.text$mn:00001E49                 rep stosd
.text$mn:00001E4B                 pop     ecx
.text$mn:00001E4C                 mov     [ebp+var_8], ecx
.text$mn:00001E4F                 mov     ecx, [ebp+var_8]
.text$mn:00001E52                 call    ?FreeEls@?$Vec@PA_W@@IAEXXZ ; Vec<wchar_t *>::FreeEls(void)
.text$mn:00001E57                 pop     edi
.text$mn:00001E58                 pop     esi
.text$mn:00001E59                 pop     ebx
.text$mn:00001E5A                 add     esp, 0CCh
.text$mn:00001E60                 cmp     ebp, esp
.text$mn:00001E62                 call    __RTC_CheckEsp
.text$mn:00001E67                 mov     esp, ebp
.text$mn:00001E69                 pop     ebp
.text$mn:00001E6A                 retn
.text$mn:00001E6A ??1?$Vec@PA_W@@QAE@XZ endp
.text$mn:00001E6A
.text$mn:00001E6A ; ---------------------------------------------------------------------------
.text$mn:00001E6B                 align 4
.text$mn:00001E6B _text$mn        ends
.text$mn:00001E6B
.text$mn:00001E6C ; ===========================================================================
.text$mn:00001E6C
.text$mn:00001E6C ; Segment type: Pure code
.text$mn:00001E6C ; Segment permissions: Read/Execute
.text$mn:00001E6C _text$mn        segment para public 'CODE' use32
.text$mn:00001E6C                 assume cs:_text$mn
.text$mn:00001E6C                 ;org 1E6Ch
.text$mn:00001E6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E6C
.text$mn:00001E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E6C
.text$mn:00001E6C ; Attributes: bp-based frame
.text$mn:00001E6C
.text$mn:00001E6C ; public: __thiscall Vec<class geomutil::RectT<int>>::~Vec<class geomutil::RectT<int>>(void)
.text$mn:00001E6C                 public ??1?$Vec@V?$RectT@H@geomutil@@@@QAE@XZ
.text$mn:00001E6C ??1?$Vec@V?$RectT@H@geomutil@@@@QAE@XZ proc near
.text$mn:00001E6C                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+408p
.text$mn:00001E6C
.text$mn:00001E6C var_CC          = byte ptr -0CCh
.text$mn:00001E6C var_8           = dword ptr -8
.text$mn:00001E6C
.text$mn:00001E6C                 push    ebp
.text$mn:00001E6D                 mov     ebp, esp
.text$mn:00001E6F                 sub     esp, 0CCh
.text$mn:00001E75                 push    ebx
.text$mn:00001E76                 push    esi
.text$mn:00001E77                 push    edi
.text$mn:00001E78                 push    ecx
.text$mn:00001E79                 lea     edi, [ebp+var_CC]
.text$mn:00001E7F                 mov     ecx, 33h ; '3'
.text$mn:00001E84                 mov     eax, 0CCCCCCCCh
.text$mn:00001E89                 rep stosd
.text$mn:00001E8B                 pop     ecx
.text$mn:00001E8C                 mov     [ebp+var_8], ecx
.text$mn:00001E8F                 mov     ecx, [ebp+var_8]
.text$mn:00001E92                 call    ?FreeEls@?$Vec@V?$RectT@H@geomutil@@@@IAEXXZ ; Vec<geomutil::RectT<int>>::FreeEls(void)
.text$mn:00001E97                 pop     edi
.text$mn:00001E98                 pop     esi
.text$mn:00001E99                 pop     ebx
.text$mn:00001E9A                 add     esp, 0CCh
.text$mn:00001EA0                 cmp     ebp, esp
.text$mn:00001EA2                 call    __RTC_CheckEsp
.text$mn:00001EA7                 mov     esp, ebp
.text$mn:00001EA9                 pop     ebp
.text$mn:00001EAA                 retn
.text$mn:00001EAA ??1?$Vec@V?$RectT@H@geomutil@@@@QAE@XZ endp
.text$mn:00001EAA
.text$mn:00001EAA ; ---------------------------------------------------------------------------
.text$mn:00001EAB                 align 4
.text$mn:00001EAB _text$mn        ends
.text$mn:00001EAB
.text$mn:00001EAC ; ===========================================================================
.text$mn:00001EAC
.text$mn:00001EAC ; Segment type: Pure code
.text$mn:00001EAC ; Segment permissions: Read/Execute
.text$mn:00001EAC _text$mn        segment para public 'CODE' use32
.text$mn:00001EAC                 assume cs:_text$mn
.text$mn:00001EAC                 ;org 1EACh
.text$mn:00001EAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EAC
.text$mn:00001EAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001EAC
.text$mn:00001EAC ; Attributes: bp-based frame
.text$mn:00001EAC
.text$mn:00001EAC ; public: __thiscall Vec<wchar_t>::~Vec<wchar_t>(void)
.text$mn:00001EAC                 public ??1?$Vec@_W@@QAE@XZ
.text$mn:00001EAC ??1?$Vec@_W@@QAE@XZ proc near           ; CODE XREF: str::Str<wchar_t>::~Str<wchar_t>(void)+26p
.text$mn:00001EAC
.text$mn:00001EAC var_CC          = byte ptr -0CCh
.text$mn:00001EAC var_8           = dword ptr -8
.text$mn:00001EAC
.text$mn:00001EAC                 push    ebp
.text$mn:00001EAD                 mov     ebp, esp
.text$mn:00001EAF                 sub     esp, 0CCh
.text$mn:00001EB5                 push    ebx
.text$mn:00001EB6                 push    esi
.text$mn:00001EB7                 push    edi
.text$mn:00001EB8                 push    ecx
.text$mn:00001EB9                 lea     edi, [ebp+var_CC]
.text$mn:00001EBF                 mov     ecx, 33h ; '3'
.text$mn:00001EC4                 mov     eax, 0CCCCCCCCh
.text$mn:00001EC9                 rep stosd
.text$mn:00001ECB                 pop     ecx
.text$mn:00001ECC                 mov     [ebp+var_8], ecx
.text$mn:00001ECF                 mov     ecx, [ebp+var_8]
.text$mn:00001ED2                 call    ?FreeEls@?$Vec@_W@@IAEXXZ ; Vec<wchar_t>::FreeEls(void)
.text$mn:00001ED7                 pop     edi
.text$mn:00001ED8                 pop     esi
.text$mn:00001ED9                 pop     ebx
.text$mn:00001EDA                 add     esp, 0CCh
.text$mn:00001EE0                 cmp     ebp, esp
.text$mn:00001EE2                 call    __RTC_CheckEsp
.text$mn:00001EE7                 mov     esp, ebp
.text$mn:00001EE9                 pop     ebp
.text$mn:00001EEA                 retn
.text$mn:00001EEA ??1?$Vec@_W@@QAE@XZ endp
.text$mn:00001EEA
.text$mn:00001EEA ; ---------------------------------------------------------------------------
.text$mn:00001EEB                 align 4
.text$mn:00001EEB _text$mn        ends
.text$mn:00001EEB
.text$mn:00001EEC ; ===========================================================================
.text$mn:00001EEC
.text$mn:00001EEC ; Segment type: Pure code
.text$mn:00001EEC ; Segment permissions: Read/Execute
.text$mn:00001EEC _text$mn        segment para public 'CODE' use32
.text$mn:00001EEC                 assume cs:_text$mn
.text$mn:00001EEC                 ;org 1EECh
.text$mn:00001EEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EEC
.text$mn:00001EEC ; =============== S U B R O U T I N E =======================================
.text$mn:00001EEC
.text$mn:00001EEC ; Attributes: bp-based frame
.text$mn:00001EEC
.text$mn:00001EEC                 public ??1?$_Func_base@X$$V@std@@QAE@XZ
.text$mn:00001EEC ??1?$_Func_base@X$$V@std@@QAE@XZ proc near
.text$mn:00001EEC                                         ; CODE XREF: ??1?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@XZ+2Fp
.text$mn:00001EEC
.text$mn:00001EEC var_CC          = byte ptr -0CCh
.text$mn:00001EEC var_8           = dword ptr -8
.text$mn:00001EEC
.text$mn:00001EEC                 push    ebp
.text$mn:00001EED                 mov     ebp, esp
.text$mn:00001EEF                 sub     esp, 0CCh
.text$mn:00001EF5                 push    ebx
.text$mn:00001EF6                 push    esi
.text$mn:00001EF7                 push    edi
.text$mn:00001EF8                 push    ecx
.text$mn:00001EF9                 lea     edi, [ebp+var_CC]
.text$mn:00001EFF                 mov     ecx, 33h ; '3'
.text$mn:00001F04                 mov     eax, 0CCCCCCCCh
.text$mn:00001F09                 rep stosd
.text$mn:00001F0B                 pop     ecx
.text$mn:00001F0C                 mov     [ebp+var_8], ecx
.text$mn:00001F0F                 mov     eax, [ebp+var_8]
.text$mn:00001F12                 mov     dword ptr [eax], offset ??_7?$_Func_base@X$$V@std@@6B@
.text$mn:00001F18                 pop     edi
.text$mn:00001F19                 pop     esi
.text$mn:00001F1A                 pop     ebx
.text$mn:00001F1B                 mov     esp, ebp
.text$mn:00001F1D                 pop     ebp
.text$mn:00001F1E                 retn
.text$mn:00001F1E ??1?$_Func_base@X$$V@std@@QAE@XZ endp
.text$mn:00001F1E
.text$mn:00001F1E ; ---------------------------------------------------------------------------
.text$mn:00001F1F                 align 10h
.text$mn:00001F1F _text$mn        ends
.text$mn:00001F1F
.text$mn:00001F20 ; ===========================================================================
.text$mn:00001F20
.text$mn:00001F20 ; Segment type: Pure code
.text$mn:00001F20 ; Segment permissions: Read/Execute
.text$mn:00001F20 _text$mn        segment para public 'CODE' use32
.text$mn:00001F20                 assume cs:_text$mn
.text$mn:00001F20                 ;org 1F20h
.text$mn:00001F20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F20
.text$mn:00001F20 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F20
.text$mn:00001F20 ; Attributes: bp-based frame
.text$mn:00001F20
.text$mn:00001F20                 public ??1?$_Func_class@X$$V@std@@QAE@XZ
.text$mn:00001F20 ??1?$_Func_class@X$$V@std@@QAE@XZ proc near
.text$mn:00001F20                                         ; CODE XREF: std::function<void (void)>::~function<void (void)>(void)+26p
.text$mn:00001F20
.text$mn:00001F20 var_CC          = byte ptr -0CCh
.text$mn:00001F20 var_8           = dword ptr -8
.text$mn:00001F20
.text$mn:00001F20                 push    ebp
.text$mn:00001F21                 mov     ebp, esp
.text$mn:00001F23                 sub     esp, 0CCh
.text$mn:00001F29                 push    ebx
.text$mn:00001F2A                 push    esi
.text$mn:00001F2B                 push    edi
.text$mn:00001F2C                 push    ecx
.text$mn:00001F2D                 lea     edi, [ebp+var_CC]
.text$mn:00001F33                 mov     ecx, 33h ; '3'
.text$mn:00001F38                 mov     eax, 0CCCCCCCCh
.text$mn:00001F3D                 rep stosd
.text$mn:00001F3F                 pop     ecx
.text$mn:00001F40                 mov     [ebp+var_8], ecx
.text$mn:00001F43                 mov     ecx, [ebp+var_8]
.text$mn:00001F46                 call    ?_Tidy@?$_Func_class@X$$V@std@@IAEXXZ
.text$mn:00001F4B                 pop     edi
.text$mn:00001F4C                 pop     esi
.text$mn:00001F4D                 pop     ebx
.text$mn:00001F4E                 add     esp, 0CCh
.text$mn:00001F54                 cmp     ebp, esp
.text$mn:00001F56                 call    __RTC_CheckEsp
.text$mn:00001F5B                 mov     esp, ebp
.text$mn:00001F5D                 pop     ebp
.text$mn:00001F5E                 retn
.text$mn:00001F5E ??1?$_Func_class@X$$V@std@@QAE@XZ endp
.text$mn:00001F5E
.text$mn:00001F5E ; ---------------------------------------------------------------------------
.text$mn:00001F5F                 align 10h
.text$mn:00001F5F _text$mn        ends
.text$mn:00001F5F
.text$mn:00001F60 ; ===========================================================================
.text$mn:00001F60
.text$mn:00001F60 ; Segment type: Pure code
.text$mn:00001F60 ; Segment permissions: Read/Execute
.text$mn:00001F60 _text$mn        segment para public 'CODE' use32
.text$mn:00001F60                 assume cs:_text$mn
.text$mn:00001F60                 ;org 1F60h
.text$mn:00001F60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F60
.text$mn:00001F60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F60
.text$mn:00001F60 ; Attributes: bp-based frame
.text$mn:00001F60
.text$mn:00001F60                 public ??1?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@XZ
.text$mn:00001F60 ??1?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@XZ proc near
.text$mn:00001F60                                         ; CODE XREF: ??_G?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAEPAXI@Z+26p
.text$mn:00001F60
.text$mn:00001F60 var_CC          = byte ptr -0CCh
.text$mn:00001F60 var_8           = dword ptr -8
.text$mn:00001F60
.text$mn:00001F60                 push    ebp
.text$mn:00001F61                 mov     ebp, esp
.text$mn:00001F63                 sub     esp, 0CCh
.text$mn:00001F69                 push    ebx
.text$mn:00001F6A                 push    esi
.text$mn:00001F6B                 push    edi
.text$mn:00001F6C                 push    ecx
.text$mn:00001F6D                 lea     edi, [ebp+var_CC]
.text$mn:00001F73                 mov     ecx, 33h ; '3'
.text$mn:00001F78                 mov     eax, 0CCCCCCCCh
.text$mn:00001F7D                 rep stosd
.text$mn:00001F7F                 pop     ecx
.text$mn:00001F80                 mov     [ebp+var_8], ecx
.text$mn:00001F83                 mov     eax, [ebp+var_8]
.text$mn:00001F86                 mov     dword ptr [eax], offset ??_7?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@6B@
.text$mn:00001F8C                 mov     ecx, [ebp+var_8]
.text$mn:00001F8F                 call    ??1?$_Func_base@X$$V@std@@QAE@XZ
.text$mn:00001F94                 pop     edi
.text$mn:00001F95                 pop     esi
.text$mn:00001F96                 pop     ebx
.text$mn:00001F97                 add     esp, 0CCh
.text$mn:00001F9D                 cmp     ebp, esp
.text$mn:00001F9F                 call    __RTC_CheckEsp
.text$mn:00001FA4                 mov     esp, ebp
.text$mn:00001FA6                 pop     ebp
.text$mn:00001FA7                 retn
.text$mn:00001FA7 ??1?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@XZ endp
.text$mn:00001FA7
.text$mn:00001FA7 _text$mn        ends
.text$mn:00001FA7
.text$mn:00001FA8 ; ===========================================================================
.text$mn:00001FA8
.text$mn:00001FA8 ; Segment type: Pure code
.text$mn:00001FA8 ; Segment permissions: Read/Execute
.text$mn:00001FA8 _text$mn        segment para public 'CODE' use32
.text$mn:00001FA8                 assume cs:_text$mn
.text$mn:00001FA8                 ;org 1FA8h
.text$mn:00001FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FA8
.text$mn:00001FA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FA8
.text$mn:00001FA8 ; Attributes: bp-based frame
.text$mn:00001FA8
.text$mn:00001FA8 ; public: __thiscall std::function<void __cdecl (void)>::~function<void __cdecl (void)>(void)
.text$mn:00001FA8                 public ??1?$function@$$A6AXXZ@std@@QAE@XZ
.text$mn:00001FA8 ??1?$function@$$A6AXXZ@std@@QAE@XZ proc near
.text$mn:00001FA8                                         ; CODE XREF: FileExistenceChecker::Run(void)+F5p
.text$mn:00001FA8
.text$mn:00001FA8 var_CC          = byte ptr -0CCh
.text$mn:00001FA8 var_8           = dword ptr -8
.text$mn:00001FA8
.text$mn:00001FA8                 push    ebp
.text$mn:00001FA9                 mov     ebp, esp
.text$mn:00001FAB                 sub     esp, 0CCh
.text$mn:00001FB1                 push    ebx
.text$mn:00001FB2                 push    esi
.text$mn:00001FB3                 push    edi
.text$mn:00001FB4                 push    ecx
.text$mn:00001FB5                 lea     edi, [ebp+var_CC]
.text$mn:00001FBB                 mov     ecx, 33h ; '3'
.text$mn:00001FC0                 mov     eax, 0CCCCCCCCh
.text$mn:00001FC5                 rep stosd
.text$mn:00001FC7                 pop     ecx
.text$mn:00001FC8                 mov     [ebp+var_8], ecx
.text$mn:00001FCB                 mov     ecx, [ebp+var_8]
.text$mn:00001FCE                 call    ??1?$_Func_class@X$$V@std@@QAE@XZ
.text$mn:00001FD3                 pop     edi
.text$mn:00001FD4                 pop     esi
.text$mn:00001FD5                 pop     ebx
.text$mn:00001FD6                 add     esp, 0CCh
.text$mn:00001FDC                 cmp     ebp, esp
.text$mn:00001FDE                 call    __RTC_CheckEsp
.text$mn:00001FE3                 mov     esp, ebp
.text$mn:00001FE5                 pop     ebp
.text$mn:00001FE6                 retn
.text$mn:00001FE6 ??1?$function@$$A6AXXZ@std@@QAE@XZ endp
.text$mn:00001FE6
.text$mn:00001FE6 ; ---------------------------------------------------------------------------
.text$mn:00001FE7                 align 4
.text$mn:00001FE7 _text$mn        ends
.text$mn:00001FE7
.text$mn:00001FE8 ; ===========================================================================
.text$mn:00001FE8
.text$mn:00001FE8 ; Segment type: Pure code
.text$mn:00001FE8 ; Segment permissions: Read/Execute
.text$mn:00001FE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001FE8                 assume cs:_text$mn
.text$mn:00001FE8                 ;org 1FE8h
.text$mn:00001FE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FE8
.text$mn:00001FE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FE8
.text$mn:00001FE8 ; Attributes: bp-based frame
.text$mn:00001FE8
.text$mn:00001FE8 ; _DWORD __thiscall CommandLineInfo::~CommandLineInfo(CommandLineInfo *__hidden this)
.text$mn:00001FE8                 public ??1CommandLineInfo@@QAE@XZ
.text$mn:00001FE8 ??1CommandLineInfo@@QAE@XZ proc near    ; CODE XREF: WinMain(x,x,x,x)+B66p
.text$mn:00001FE8
.text$mn:00001FE8 var_CC          = byte ptr -0CCh
.text$mn:00001FE8 var_8           = dword ptr -8
.text$mn:00001FE8
.text$mn:00001FE8                 push    ebp
.text$mn:00001FE9                 mov     ebp, esp
.text$mn:00001FEB                 sub     esp, 0CCh
.text$mn:00001FF1                 push    ebx
.text$mn:00001FF2                 push    esi
.text$mn:00001FF3                 push    edi
.text$mn:00001FF4                 push    ecx
.text$mn:00001FF5                 lea     edi, [ebp+var_CC]
.text$mn:00001FFB                 mov     ecx, 33h ; '3'
.text$mn:00002000                 mov     eax, 0CCCCCCCCh
.text$mn:00002005                 rep stosd
.text$mn:00002007                 pop     ecx
.text$mn:00002008                 mov     [ebp+var_8], ecx
.text$mn:0000200B                 mov     ecx, [ebp+var_8]
.text$mn:0000200E                 add     ecx, 114h       ; this
.text$mn:00002014                 call    ??1WStrVec@@QAE@XZ ; WStrVec::~WStrVec(void)
.text$mn:00002019                 mov     ecx, [ebp+var_8]
.text$mn:0000201C                 add     ecx, 110h
.text$mn:00002022                 call    ??1?$ScopedMem@D@@QAE@XZ ; ScopedMem<char>::~ScopedMem<char>(void)
.text$mn:00002027                 mov     ecx, [ebp+var_8]
.text$mn:0000202A                 add     ecx, 100h
.text$mn:00002030                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:00002035                 mov     ecx, [ebp+var_8]
.text$mn:00002038                 add     ecx, 0FCh ; 'n'
.text$mn:0000203E                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:00002043                 mov     ecx, [ebp+var_8]
.text$mn:00002046                 add     ecx, 0F8h ; ''
.text$mn:0000204C                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:00002051                 mov     ecx, [ebp+var_8]
.text$mn:00002054                 add     ecx, 0F0h ; '='
.text$mn:0000205A                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:0000205F                 mov     ecx, [ebp+var_8]
.text$mn:00002062                 add     ecx, 0ECh ; '8'
.text$mn:00002068                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:0000206D                 mov     ecx, [ebp+var_8]
.text$mn:00002070                 add     ecx, 0E4h ; 'S'
.text$mn:00002076                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:0000207B                 mov     ecx, [ebp+var_8]
.text$mn:0000207E                 add     ecx, 0C0h ; '+'
.text$mn:00002084                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:00002089                 mov     ecx, [ebp+var_8]
.text$mn:0000208C                 add     ecx, 0B4h ; ''
.text$mn:00002092                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:00002097                 mov     ecx, [ebp+var_8]
.text$mn:0000209A                 add     ecx, 0B0h ; ''
.text$mn:000020A0                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000020A5                 mov     ecx, [ebp+var_8]
.text$mn:000020A8                 add     ecx, 0ACh ; ''
.text$mn:000020AE                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000020B3                 mov     ecx, [ebp+var_8]
.text$mn:000020B6                 add     ecx, 54h ; 'T'  ; this
.text$mn:000020B9                 call    ??1WStrVec@@QAE@XZ ; WStrVec::~WStrVec(void)
.text$mn:000020BE                 mov     ecx, [ebp+var_8] ; this
.text$mn:000020C1                 call    ??1WStrVec@@QAE@XZ ; WStrVec::~WStrVec(void)
.text$mn:000020C6                 pop     edi
.text$mn:000020C7                 pop     esi
.text$mn:000020C8                 pop     ebx
.text$mn:000020C9                 add     esp, 0CCh
.text$mn:000020CF                 cmp     ebp, esp
.text$mn:000020D1                 call    __RTC_CheckEsp
.text$mn:000020D6                 mov     esp, ebp
.text$mn:000020D8                 pop     ebp
.text$mn:000020D9                 retn
.text$mn:000020D9 ??1CommandLineInfo@@QAE@XZ endp
.text$mn:000020D9
.text$mn:000020D9 ; ---------------------------------------------------------------------------
.text$mn:000020DA                 align 4
.text$mn:000020DA _text$mn        ends
.text$mn:000020DA
.text$mn:000020DC ; ===========================================================================
.text$mn:000020DC
.text$mn:000020DC ; Segment type: Pure code
.text$mn:000020DC ; Segment permissions: Read/Execute
.text$mn:000020DC _text$mn        segment para public 'CODE' use32
.text$mn:000020DC                 assume cs:_text$mn
.text$mn:000020DC                 ;org 20DCh
.text$mn:000020DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020DC
.text$mn:000020DC ; =============== S U B R O U T I N E =======================================
.text$mn:000020DC
.text$mn:000020DC ; Attributes: bp-based frame
.text$mn:000020DC
.text$mn:000020DC ; _DWORD __thiscall FileExistenceChecker::~FileExistenceChecker(FileExistenceChecker *__hidden this)
.text$mn:000020DC                 public ??1FileExistenceChecker@@UAE@XZ
.text$mn:000020DC ??1FileExistenceChecker@@UAE@XZ proc near
.text$mn:000020DC                                         ; CODE XREF: FileExistenceChecker::`scalar deleting destructor'(uint)+26p
.text$mn:000020DC
.text$mn:000020DC var_CC          = byte ptr -0CCh
.text$mn:000020DC var_8           = dword ptr -8
.text$mn:000020DC
.text$mn:000020DC                 push    ebp
.text$mn:000020DD                 mov     ebp, esp
.text$mn:000020DF                 sub     esp, 0CCh
.text$mn:000020E5                 push    ebx
.text$mn:000020E6                 push    esi
.text$mn:000020E7                 push    edi
.text$mn:000020E8                 push    ecx
.text$mn:000020E9                 lea     edi, [ebp+var_CC]
.text$mn:000020EF                 mov     ecx, 33h ; '3'
.text$mn:000020F4                 mov     eax, 0CCCCCCCCh
.text$mn:000020F9                 rep stosd
.text$mn:000020FB                 pop     ecx
.text$mn:000020FC                 mov     [ebp+var_8], ecx
.text$mn:000020FF                 mov     ecx, [ebp+var_8]
.text$mn:00002102                 add     ecx, 14h        ; this
.text$mn:00002105                 call    ??1WStrVec@@QAE@XZ ; WStrVec::~WStrVec(void)
.text$mn:0000210A                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000210D                 call    ??1ThreadBase@@MAE@XZ ; ThreadBase::~ThreadBase(void)
.text$mn:00002112                 pop     edi
.text$mn:00002113                 pop     esi
.text$mn:00002114                 pop     ebx
.text$mn:00002115                 add     esp, 0CCh
.text$mn:0000211B                 cmp     ebp, esp
.text$mn:0000211D                 call    __RTC_CheckEsp
.text$mn:00002122                 mov     esp, ebp
.text$mn:00002124                 pop     ebp
.text$mn:00002125                 retn
.text$mn:00002125 ??1FileExistenceChecker@@UAE@XZ endp
.text$mn:00002125
.text$mn:00002125 ; ---------------------------------------------------------------------------
.text$mn:00002126                 align 4
.text$mn:00002126 _text$mn        ends
.text$mn:00002126
.text$mn:00002128 ; ===========================================================================
.text$mn:00002128
.text$mn:00002128 ; Segment type: Pure code
.text$mn:00002128 ; Segment permissions: Read/Execute
.text$mn:00002128 _text$mn        segment para public 'CODE' use32
.text$mn:00002128                 assume cs:_text$mn
.text$mn:00002128                 ;org 2128h
.text$mn:00002128                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002128
.text$mn:00002128 ; =============== S U B R O U T I N E =======================================
.text$mn:00002128
.text$mn:00002128 ; Attributes: bp-based frame
.text$mn:00002128
.text$mn:00002128 ; _DWORD __thiscall ScopedGdiPlus::~ScopedGdiPlus(ScopedGdiPlus *__hidden this)
.text$mn:00002128                 public ??1ScopedGdiPlus@@QAE@XZ
.text$mn:00002128 ??1ScopedGdiPlus@@QAE@XZ proc near      ; CODE XREF: WinMain(x,x,x,x)+B6Ep
.text$mn:00002128
.text$mn:00002128 var_CC          = byte ptr -0CCh
.text$mn:00002128 var_8           = dword ptr -8
.text$mn:00002128
.text$mn:00002128                 push    ebp
.text$mn:00002129                 mov     ebp, esp
.text$mn:0000212B                 sub     esp, 0CCh
.text$mn:00002131                 push    ebx
.text$mn:00002132                 push    esi
.text$mn:00002133                 push    edi
.text$mn:00002134                 push    ecx
.text$mn:00002135                 lea     edi, [ebp+var_CC]
.text$mn:0000213B                 mov     ecx, 33h ; '3'
.text$mn:00002140                 mov     eax, 0CCCCCCCCh
.text$mn:00002145                 rep stosd
.text$mn:00002147                 pop     ecx
.text$mn:00002148                 mov     [ebp+var_8], ecx
.text$mn:0000214B                 mov     eax, [ebp+var_8]
.text$mn:0000214E                 movzx   ecx, byte ptr [eax+20h]
.text$mn:00002152                 test    ecx, ecx
.text$mn:00002154                 jz      short loc_216E
.text$mn:00002156                 mov     esi, esp
.text$mn:00002158                 mov     eax, [ebp+var_8]
.text$mn:0000215B                 mov     ecx, [eax+1Ch]
.text$mn:0000215E                 push    ecx
.text$mn:0000215F                 mov     edx, [ebp+var_8]
.text$mn:00002162                 mov     eax, [edx+14h]
.text$mn:00002165                 call    eax
.text$mn:00002167                 cmp     esi, esp
.text$mn:00002169                 call    __RTC_CheckEsp
.text$mn:0000216E
.text$mn:0000216E loc_216E:                               ; CODE XREF: ScopedGdiPlus::~ScopedGdiPlus(void)+2Cj
.text$mn:0000216E                 mov     eax, [ebp+var_8]
.text$mn:00002171                 mov     ecx, [eax+18h]
.text$mn:00002174                 push    ecx
.text$mn:00002175                 call    _GdiplusShutdown@4 ; GdiplusShutdown(x)
.text$mn:0000217A                 pop     edi
.text$mn:0000217B                 pop     esi
.text$mn:0000217C                 pop     ebx
.text$mn:0000217D                 add     esp, 0CCh
.text$mn:00002183                 cmp     ebp, esp
.text$mn:00002185                 call    __RTC_CheckEsp
.text$mn:0000218A                 mov     esp, ebp
.text$mn:0000218C                 pop     ebp
.text$mn:0000218D                 retn
.text$mn:0000218D ??1ScopedGdiPlus@@QAE@XZ endp
.text$mn:0000218D
.text$mn:0000218D ; ---------------------------------------------------------------------------
.text$mn:0000218E                 align 10h
.text$mn:0000218E _text$mn        ends
.text$mn:0000218E
.text$mn:00002190 ; ===========================================================================
.text$mn:00002190
.text$mn:00002190 ; Segment type: Pure code
.text$mn:00002190 ; Segment permissions: Read/Execute
.text$mn:00002190 _text$mn        segment para public 'CODE' use32
.text$mn:00002190                 assume cs:_text$mn
.text$mn:00002190                 ;org 2190h
.text$mn:00002190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002190
.text$mn:00002190 ; =============== S U B R O U T I N E =======================================
.text$mn:00002190
.text$mn:00002190 ; Attributes: bp-based frame
.text$mn:00002190
.text$mn:00002190 ; _DWORD __thiscall ScopedOle::~ScopedOle(ScopedOle *__hidden this)
.text$mn:00002190                 public ??1ScopedOle@@QAE@XZ
.text$mn:00002190 ??1ScopedOle@@QAE@XZ proc near          ; CODE XREF: WinMain(x,x,x,x)+B76p
.text$mn:00002190
.text$mn:00002190 var_CC          = byte ptr -0CCh
.text$mn:00002190 var_8           = dword ptr -8
.text$mn:00002190
.text$mn:00002190                 push    ebp
.text$mn:00002191                 mov     ebp, esp
.text$mn:00002193                 sub     esp, 0CCh
.text$mn:00002199                 push    ebx
.text$mn:0000219A                 push    esi
.text$mn:0000219B                 push    edi
.text$mn:0000219C                 push    ecx
.text$mn:0000219D                 lea     edi, [ebp+var_CC]
.text$mn:000021A3                 mov     ecx, 33h ; '3'
.text$mn:000021A8                 mov     eax, 0CCCCCCCCh
.text$mn:000021AD                 rep stosd
.text$mn:000021AF                 pop     ecx
.text$mn:000021B0                 mov     [ebp+var_8], ecx
.text$mn:000021B3                 mov     esi, esp
.text$mn:000021B5                 call    dword ptr ds:__imp__OleUninitialize@0 ; OleUninitialize()
.text$mn:000021BB                 cmp     esi, esp
.text$mn:000021BD                 call    __RTC_CheckEsp
.text$mn:000021C2                 pop     edi
.text$mn:000021C3                 pop     esi
.text$mn:000021C4                 pop     ebx
.text$mn:000021C5                 add     esp, 0CCh
.text$mn:000021CB                 cmp     ebp, esp
.text$mn:000021CD                 call    __RTC_CheckEsp
.text$mn:000021D2                 mov     esp, ebp
.text$mn:000021D4                 pop     ebp
.text$mn:000021D5                 retn
.text$mn:000021D5 ??1ScopedOle@@QAE@XZ endp
.text$mn:000021D5
.text$mn:000021D5 ; ---------------------------------------------------------------------------
.text$mn:000021D6                 align 4
.text$mn:000021D6 _text$mn        ends
.text$mn:000021D6
.text$mn:000021D8 ; ===========================================================================
.text$mn:000021D8
.text$mn:000021D8 ; Segment type: Pure code
.text$mn:000021D8 ; Segment permissions: Read/Execute
.text$mn:000021D8 _text$mn        segment para public 'CODE' use32
.text$mn:000021D8                 assume cs:_text$mn
.text$mn:000021D8                 ;org 21D8h
.text$mn:000021D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021D8
.text$mn:000021D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000021D8
.text$mn:000021D8 ; Attributes: bp-based frame
.text$mn:000021D8
.text$mn:000021D8 ; _DWORD __thiscall WStrVec::~WStrVec(WStrVec *__hidden this)
.text$mn:000021D8                 public ??1WStrVec@@QAE@XZ
.text$mn:000021D8 ??1WStrVec@@QAE@XZ proc near            ; CODE XREF: CommandLineInfo::~CommandLineInfo(void)+2Cp
.text$mn:000021D8                                         ; CommandLineInfo::~CommandLineInfo(void)+D1p ...
.text$mn:000021D8
.text$mn:000021D8 var_CC          = byte ptr -0CCh
.text$mn:000021D8 var_8           = dword ptr -8
.text$mn:000021D8
.text$mn:000021D8                 push    ebp
.text$mn:000021D9                 mov     ebp, esp
.text$mn:000021DB                 sub     esp, 0CCh
.text$mn:000021E1                 push    ebx
.text$mn:000021E2                 push    esi
.text$mn:000021E3                 push    edi
.text$mn:000021E4                 push    ecx
.text$mn:000021E5                 lea     edi, [ebp+var_CC]
.text$mn:000021EB                 mov     ecx, 33h ; '3'
.text$mn:000021F0                 mov     eax, 0CCCCCCCCh
.text$mn:000021F5                 rep stosd
.text$mn:000021F7                 pop     ecx
.text$mn:000021F8                 mov     [ebp+var_8], ecx
.text$mn:000021FB                 mov     ecx, [ebp+var_8]
.text$mn:000021FE                 call    ?FreeMembers@?$Vec@PA_W@@QAEXXZ ; Vec<wchar_t *>::FreeMembers(void)
.text$mn:00002203                 mov     ecx, [ebp+var_8]
.text$mn:00002206                 call    ??1?$Vec@PA_W@@QAE@XZ ; Vec<wchar_t *>::~Vec<wchar_t *>(void)
.text$mn:0000220B                 pop     edi
.text$mn:0000220C                 pop     esi
.text$mn:0000220D                 pop     ebx
.text$mn:0000220E                 add     esp, 0CCh
.text$mn:00002214                 cmp     ebp, esp
.text$mn:00002216                 call    __RTC_CheckEsp
.text$mn:0000221B                 mov     esp, ebp
.text$mn:0000221D                 pop     ebp
.text$mn:0000221E                 retn
.text$mn:0000221E ??1WStrVec@@QAE@XZ endp
.text$mn:0000221E
.text$mn:0000221E ; ---------------------------------------------------------------------------
.text$mn:0000221F                 align 10h
.text$mn:0000221F _text$mn        ends
.text$mn:0000221F
.text$mn:00002220 ; ===========================================================================
.text$mn:00002220
.text$mn:00002220 ; Segment type: Pure code
.text$mn:00002220 ; Segment permissions: Read/Execute
.text$mn:00002220 _text$mn        segment para public 'CODE' use32
.text$mn:00002220                 assume cs:_text$mn
.text$mn:00002220                 ;org 2220h
.text$mn:00002220                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002220
.text$mn:00002220 ; =============== S U B R O U T I N E =======================================
.text$mn:00002220
.text$mn:00002220 ; Attributes: bp-based frame
.text$mn:00002220
.text$mn:00002220 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00002220                 public ??2@YAPAXIPAX@Z
.text$mn:00002220 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+29p
.text$mn:00002220                                         ; ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@2@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+29p ...
.text$mn:00002220
.text$mn:00002220 var_C0          = byte ptr -0C0h
.text$mn:00002220 arg_4           = dword ptr  0Ch
.text$mn:00002220
.text$mn:00002220                 push    ebp
.text$mn:00002221                 mov     ebp, esp
.text$mn:00002223                 sub     esp, 0C0h
.text$mn:00002229                 push    ebx
.text$mn:0000222A                 push    esi
.text$mn:0000222B                 push    edi
.text$mn:0000222C                 lea     edi, [ebp+var_C0]
.text$mn:00002232                 mov     ecx, 30h ; '0'
.text$mn:00002237                 mov     eax, 0CCCCCCCCh
.text$mn:0000223C                 rep stosd
.text$mn:0000223E                 mov     eax, [ebp+arg_4]
.text$mn:00002241                 pop     edi
.text$mn:00002242                 pop     esi
.text$mn:00002243                 pop     ebx
.text$mn:00002244                 mov     esp, ebp
.text$mn:00002246                 pop     ebp
.text$mn:00002247                 retn
.text$mn:00002247 ??2@YAPAXIPAX@Z endp
.text$mn:00002247
.text$mn:00002247 _text$mn        ends
.text$mn:00002247
.text$mn:00002248 ; ===========================================================================
.text$mn:00002248
.text$mn:00002248 ; Segment type: Pure code
.text$mn:00002248 ; Segment permissions: Read/Execute
.text$mn:00002248 _text$mn        segment para public 'CODE' use32
.text$mn:00002248                 assume cs:_text$mn
.text$mn:00002248                 ;org 2248h
.text$mn:00002248                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002248
.text$mn:00002248 ; =============== S U B R O U T I N E =======================================
.text$mn:00002248
.text$mn:00002248 ; Attributes: bp-based frame
.text$mn:00002248
.text$mn:00002248 ; public: class Vec<int> & __thiscall Vec<int>::operator=(class Vec<int> const &)
.text$mn:00002248                 public ??4?$Vec@H@@QAEAAV0@ABV0@@Z
.text$mn:00002248 ??4?$Vec@H@@QAEAAV0@ABV0@@Z proc near   ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+6Fp
.text$mn:00002248
.text$mn:00002248 var_CC          = byte ptr -0CCh
.text$mn:00002248 var_8           = dword ptr -8
.text$mn:00002248 arg_0           = dword ptr  8
.text$mn:00002248
.text$mn:00002248                 push    ebp
.text$mn:00002249                 mov     ebp, esp
.text$mn:0000224B                 sub     esp, 0CCh
.text$mn:00002251                 push    ebx
.text$mn:00002252                 push    esi
.text$mn:00002253                 push    edi
.text$mn:00002254                 push    ecx
.text$mn:00002255                 lea     edi, [ebp+var_CC]
.text$mn:0000225B                 mov     ecx, 33h ; '3'
.text$mn:00002260                 mov     eax, 0CCCCCCCCh
.text$mn:00002265                 rep stosd
.text$mn:00002267                 pop     ecx
.text$mn:00002268                 mov     [ebp+var_8], ecx
.text$mn:0000226B                 mov     eax, [ebp+var_8]
.text$mn:0000226E                 cmp     eax, [ebp+arg_0]
.text$mn:00002271                 jz      short loc_22D3
.text$mn:00002273                 mov     eax, [ebp+arg_0]
.text$mn:00002276                 mov     ecx, [eax+4]
.text$mn:00002279                 push    ecx
.text$mn:0000227A                 mov     ecx, [ebp+var_8]
.text$mn:0000227D                 call    ?EnsureCapCrash@?$Vec@H@@IAEXI@Z ; Vec<int>::EnsureCapCrash(uint)
.text$mn:00002282                 mov     eax, [ebp+var_8]
.text$mn:00002285                 mov     ecx, [ebp+arg_0]
.text$mn:00002288                 mov     edx, [ecx]
.text$mn:0000228A                 mov     [eax], edx
.text$mn:0000228C                 mov     eax, [ebp+var_8]
.text$mn:0000228F                 mov     ecx, [eax]
.text$mn:00002291                 shl     ecx, 2
.text$mn:00002294                 push    ecx             ; Size
.text$mn:00002295                 mov     edx, [ebp+arg_0]
.text$mn:00002298                 mov     eax, [edx+0Ch]
.text$mn:0000229B                 push    eax             ; Src
.text$mn:0000229C                 mov     ecx, [ebp+var_8]
.text$mn:0000229F                 mov     edx, [ecx+0Ch]
.text$mn:000022A2                 push    edx             ; Dst
.text$mn:000022A3                 call    _memcpy
.text$mn:000022A8                 add     esp, 0Ch
.text$mn:000022AB                 mov     eax, [ebp+var_8]
.text$mn:000022AE                 mov     ecx, [ebp+var_8]
.text$mn:000022B1                 mov     edx, [eax+4]
.text$mn:000022B4                 sub     edx, [ecx]
.text$mn:000022B6                 shl     edx, 2
.text$mn:000022B9                 push    edx             ; Size
.text$mn:000022BA                 push    0               ; Val
.text$mn:000022BC                 mov     eax, [ebp+var_8]
.text$mn:000022BF                 mov     ecx, [eax]
.text$mn:000022C1                 mov     edx, [ebp+var_8]
.text$mn:000022C4                 mov     eax, [edx+0Ch]
.text$mn:000022C7                 lea     ecx, [eax+ecx*4]
.text$mn:000022CA                 push    ecx             ; Dst
.text$mn:000022CB                 call    _memset
.text$mn:000022D0                 add     esp, 0Ch
.text$mn:000022D3
.text$mn:000022D3 loc_22D3:                               ; CODE XREF: Vec<int>::operator=(Vec<int> const &)+29j
.text$mn:000022D3                 mov     eax, [ebp+var_8]
.text$mn:000022D6                 pop     edi
.text$mn:000022D7                 pop     esi
.text$mn:000022D8                 pop     ebx
.text$mn:000022D9                 add     esp, 0CCh
.text$mn:000022DF                 cmp     ebp, esp
.text$mn:000022E1                 call    __RTC_CheckEsp
.text$mn:000022E6                 mov     esp, ebp
.text$mn:000022E8                 pop     ebp
.text$mn:000022E9                 retn    4
.text$mn:000022E9 ??4?$Vec@H@@QAEAAV0@ABV0@@Z endp
.text$mn:000022E9
.text$mn:000022E9 _text$mn        ends
.text$mn:000022E9
.text$mn:000022EC ; ===========================================================================
.text$mn:000022EC
.text$mn:000022EC ; Segment type: Pure code
.text$mn:000022EC ; Segment permissions: Read/Execute
.text$mn:000022EC _text$mn        segment para public 'CODE' use32
.text$mn:000022EC                 assume cs:_text$mn
.text$mn:000022EC                 ;org 22ECh
.text$mn:000022EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022EC
.text$mn:000022EC ; =============== S U B R O U T I N E =======================================
.text$mn:000022EC
.text$mn:000022EC ; Attributes: bp-based frame
.text$mn:000022EC
.text$mn:000022EC ; public: bool __thiscall Vec<struct SessionData *>::Iter::operator!=(class Vec<struct SessionData *>::Iter const &)const
.text$mn:000022EC                 public ??9Iter@?$Vec@PAUSessionData@@@@QBE_NABV01@@Z
.text$mn:000022EC ??9Iter@?$Vec@PAUSessionData@@@@QBE_NABV01@@Z proc near
.text$mn:000022EC                                         ; CODE XREF: WinMain(x,x,x,x)+76Cp
.text$mn:000022EC
.text$mn:000022EC var_D0          = dword ptr -0D0h
.text$mn:000022EC var_8           = dword ptr -8
.text$mn:000022EC arg_0           = dword ptr  8
.text$mn:000022EC
.text$mn:000022EC                 push    ebp
.text$mn:000022ED                 mov     ebp, esp
.text$mn:000022EF                 sub     esp, 0D0h
.text$mn:000022F5                 push    ebx
.text$mn:000022F6                 push    esi
.text$mn:000022F7                 push    edi
.text$mn:000022F8                 push    ecx
.text$mn:000022F9                 lea     edi, [ebp+var_D0]
.text$mn:000022FF                 mov     ecx, 34h ; '4'
.text$mn:00002304                 mov     eax, 0CCCCCCCCh
.text$mn:00002309                 rep stosd
.text$mn:0000230B                 pop     ecx
.text$mn:0000230C                 mov     [ebp+var_8], ecx
.text$mn:0000230F                 mov     eax, [ebp+var_8]
.text$mn:00002312                 mov     ecx, [ebp+arg_0]
.text$mn:00002315                 mov     edx, [eax+4]
.text$mn:00002318                 cmp     edx, [ecx+4]
.text$mn:0000231B                 jz      short loc_2329
.text$mn:0000231D                 mov     [ebp+var_D0], 1
.text$mn:00002327                 jmp     short loc_2333
.text$mn:00002329 ; ---------------------------------------------------------------------------
.text$mn:00002329
.text$mn:00002329 loc_2329:                               ; CODE XREF: Vec<SessionData *>::Iter::operator!=(Vec<SessionData *>::Iter const &)+2Fj
.text$mn:00002329                 mov     [ebp+var_D0], 0
.text$mn:00002333
.text$mn:00002333 loc_2333:                               ; CODE XREF: Vec<SessionData *>::Iter::operator!=(Vec<SessionData *>::Iter const &)+3Bj
.text$mn:00002333                 mov     al, byte ptr [ebp+var_D0]
.text$mn:00002339                 pop     edi
.text$mn:0000233A                 pop     esi
.text$mn:0000233B                 pop     ebx
.text$mn:0000233C                 mov     esp, ebp
.text$mn:0000233E                 pop     ebp
.text$mn:0000233F                 retn    4
.text$mn:0000233F ??9Iter@?$Vec@PAUSessionData@@@@QBE_NABV01@@Z endp
.text$mn:0000233F
.text$mn:0000233F ; ---------------------------------------------------------------------------
.text$mn:00002342                 align 4
.text$mn:00002342 _text$mn        ends
.text$mn:00002342
.text$mn:00002344 ; ===========================================================================
.text$mn:00002344
.text$mn:00002344 ; Segment type: Pure code
.text$mn:00002344 ; Segment permissions: Read/Execute
.text$mn:00002344 _text$mn        segment para public 'CODE' use32
.text$mn:00002344                 assume cs:_text$mn
.text$mn:00002344                 ;org 2344h
.text$mn:00002344                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002344
.text$mn:00002344 ; =============== S U B R O U T I N E =======================================
.text$mn:00002344
.text$mn:00002344 ; Attributes: bp-based frame
.text$mn:00002344
.text$mn:00002344 ; public: bool __thiscall Vec<struct TabState *>::Iter::operator!=(class Vec<struct TabState *>::Iter const &)const
.text$mn:00002344                 public ??9Iter@?$Vec@PAUTabState@@@@QBE_NABV01@@Z
.text$mn:00002344 ??9Iter@?$Vec@PAUTabState@@@@QBE_NABV01@@Z proc near
.text$mn:00002344                                         ; CODE XREF: WinMain(x,x,x,x)+7F0p
.text$mn:00002344
.text$mn:00002344 var_D0          = dword ptr -0D0h
.text$mn:00002344 var_8           = dword ptr -8
.text$mn:00002344 arg_0           = dword ptr  8
.text$mn:00002344
.text$mn:00002344                 push    ebp
.text$mn:00002345                 mov     ebp, esp
.text$mn:00002347                 sub     esp, 0D0h
.text$mn:0000234D                 push    ebx
.text$mn:0000234E                 push    esi
.text$mn:0000234F                 push    edi
.text$mn:00002350                 push    ecx
.text$mn:00002351                 lea     edi, [ebp+var_D0]
.text$mn:00002357                 mov     ecx, 34h ; '4'
.text$mn:0000235C                 mov     eax, 0CCCCCCCCh
.text$mn:00002361                 rep stosd
.text$mn:00002363                 pop     ecx
.text$mn:00002364                 mov     [ebp+var_8], ecx
.text$mn:00002367                 mov     eax, [ebp+var_8]
.text$mn:0000236A                 mov     ecx, [ebp+arg_0]
.text$mn:0000236D                 mov     edx, [eax+4]
.text$mn:00002370                 cmp     edx, [ecx+4]
.text$mn:00002373                 jz      short loc_2381
.text$mn:00002375                 mov     [ebp+var_D0], 1
.text$mn:0000237F                 jmp     short loc_238B
.text$mn:00002381 ; ---------------------------------------------------------------------------
.text$mn:00002381
.text$mn:00002381 loc_2381:                               ; CODE XREF: Vec<TabState *>::Iter::operator!=(Vec<TabState *>::Iter const &)+2Fj
.text$mn:00002381                 mov     [ebp+var_D0], 0
.text$mn:0000238B
.text$mn:0000238B loc_238B:                               ; CODE XREF: Vec<TabState *>::Iter::operator!=(Vec<TabState *>::Iter const &)+3Bj
.text$mn:0000238B                 mov     al, byte ptr [ebp+var_D0]
.text$mn:00002391                 pop     edi
.text$mn:00002392                 pop     esi
.text$mn:00002393                 pop     ebx
.text$mn:00002394                 mov     esp, ebp
.text$mn:00002396                 pop     ebp
.text$mn:00002397                 retn    4
.text$mn:00002397 ??9Iter@?$Vec@PAUTabState@@@@QBE_NABV01@@Z endp
.text$mn:00002397
.text$mn:00002397 ; ---------------------------------------------------------------------------
.text$mn:0000239A                 align 4
.text$mn:0000239A _text$mn        ends
.text$mn:0000239A
.text$mn:0000239C ; ===========================================================================
.text$mn:0000239C
.text$mn:0000239C ; Segment type: Pure code
.text$mn:0000239C ; Segment permissions: Read/Execute
.text$mn:0000239C _text$mn        segment para public 'CODE' use32
.text$mn:0000239C                 assume cs:_text$mn
.text$mn:0000239C                 ;org 239Ch
.text$mn:0000239C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000239C
.text$mn:0000239C ; =============== S U B R O U T I N E =======================================
.text$mn:0000239C
.text$mn:0000239C ; Attributes: bp-based frame
.text$mn:0000239C
.text$mn:0000239C ; public: bool __thiscall Vec<wchar_t *>::Iter::operator!=(class Vec<wchar_t *>::Iter const &)const
.text$mn:0000239C                 public ??9Iter@?$Vec@PA_W@@QBE_NABV01@@Z
.text$mn:0000239C ??9Iter@?$Vec@PA_W@@QBE_NABV01@@Z proc near
.text$mn:0000239C                                         ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+55p
.text$mn:0000239C
.text$mn:0000239C var_D0          = dword ptr -0D0h
.text$mn:0000239C var_8           = dword ptr -8
.text$mn:0000239C arg_0           = dword ptr  8
.text$mn:0000239C
.text$mn:0000239C                 push    ebp
.text$mn:0000239D                 mov     ebp, esp
.text$mn:0000239F                 sub     esp, 0D0h
.text$mn:000023A5                 push    ebx
.text$mn:000023A6                 push    esi
.text$mn:000023A7                 push    edi
.text$mn:000023A8                 push    ecx
.text$mn:000023A9                 lea     edi, [ebp+var_D0]
.text$mn:000023AF                 mov     ecx, 34h ; '4'
.text$mn:000023B4                 mov     eax, 0CCCCCCCCh
.text$mn:000023B9                 rep stosd
.text$mn:000023BB                 pop     ecx
.text$mn:000023BC                 mov     [ebp+var_8], ecx
.text$mn:000023BF                 mov     eax, [ebp+var_8]
.text$mn:000023C2                 mov     ecx, [ebp+arg_0]
.text$mn:000023C5                 mov     edx, [eax+4]
.text$mn:000023C8                 cmp     edx, [ecx+4]
.text$mn:000023CB                 jz      short loc_23D9
.text$mn:000023CD                 mov     [ebp+var_D0], 1
.text$mn:000023D7                 jmp     short loc_23E3
.text$mn:000023D9 ; ---------------------------------------------------------------------------
.text$mn:000023D9
.text$mn:000023D9 loc_23D9:                               ; CODE XREF: Vec<wchar_t *>::Iter::operator!=(Vec<wchar_t *>::Iter const &)+2Fj
.text$mn:000023D9                 mov     [ebp+var_D0], 0
.text$mn:000023E3
.text$mn:000023E3 loc_23E3:                               ; CODE XREF: Vec<wchar_t *>::Iter::operator!=(Vec<wchar_t *>::Iter const &)+3Bj
.text$mn:000023E3                 mov     al, byte ptr [ebp+var_D0]
.text$mn:000023E9                 pop     edi
.text$mn:000023EA                 pop     esi
.text$mn:000023EB                 pop     ebx
.text$mn:000023EC                 mov     esp, ebp
.text$mn:000023EE                 pop     ebp
.text$mn:000023EF                 retn    4
.text$mn:000023EF ??9Iter@?$Vec@PA_W@@QBE_NABV01@@Z endp
.text$mn:000023EF
.text$mn:000023EF ; ---------------------------------------------------------------------------
.text$mn:000023F2                 align 4
.text$mn:000023F2 _text$mn        ends
.text$mn:000023F2
.text$mn:000023F4 ; ===========================================================================
.text$mn:000023F4
.text$mn:000023F4 ; Segment type: Pure code
.text$mn:000023F4 ; Segment permissions: Read/Execute
.text$mn:000023F4 _text$mn        segment para public 'CODE' use32
.text$mn:000023F4                 assume cs:_text$mn
.text$mn:000023F4                 ;org 23F4h
.text$mn:000023F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023F4
.text$mn:000023F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023F4
.text$mn:000023F4 ; Attributes: bp-based frame
.text$mn:000023F4
.text$mn:000023F4 ; public: __thiscall ScopedMem<char>::operator char *(void)const
.text$mn:000023F4                 public ??B?$ScopedMem@D@@QBEPADXZ
.text$mn:000023F4 ??B?$ScopedMem@D@@QBEPADXZ proc near    ; CODE XREF: WinMain(x,x,x,x)+18Ep
.text$mn:000023F4                                         ; WinMain(x,x,x,x)+19Dp
.text$mn:000023F4
.text$mn:000023F4 var_CC          = byte ptr -0CCh
.text$mn:000023F4 var_8           = dword ptr -8
.text$mn:000023F4
.text$mn:000023F4                 push    ebp
.text$mn:000023F5                 mov     ebp, esp
.text$mn:000023F7                 sub     esp, 0CCh
.text$mn:000023FD                 push    ebx
.text$mn:000023FE                 push    esi
.text$mn:000023FF                 push    edi
.text$mn:00002400                 push    ecx
.text$mn:00002401                 lea     edi, [ebp+var_CC]
.text$mn:00002407                 mov     ecx, 33h ; '3'
.text$mn:0000240C                 mov     eax, 0CCCCCCCCh
.text$mn:00002411                 rep stosd
.text$mn:00002413                 pop     ecx
.text$mn:00002414                 mov     [ebp+var_8], ecx
.text$mn:00002417                 mov     eax, [ebp+var_8]
.text$mn:0000241A                 mov     eax, [eax]
.text$mn:0000241C                 pop     edi
.text$mn:0000241D                 pop     esi
.text$mn:0000241E                 pop     ebx
.text$mn:0000241F                 mov     esp, ebp
.text$mn:00002421                 pop     ebp
.text$mn:00002422                 retn
.text$mn:00002422 ??B?$ScopedMem@D@@QBEPADXZ endp
.text$mn:00002422
.text$mn:00002422 ; ---------------------------------------------------------------------------
.text$mn:00002423                 align 4
.text$mn:00002423 _text$mn        ends
.text$mn:00002423
.text$mn:00002424 ; ===========================================================================
.text$mn:00002424
.text$mn:00002424 ; Segment type: Pure code
.text$mn:00002424 ; Segment permissions: Read/Execute
.text$mn:00002424 _text$mn        segment para public 'CODE' use32
.text$mn:00002424                 assume cs:_text$mn
.text$mn:00002424                 ;org 2424h
.text$mn:00002424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002424
.text$mn:00002424 ; =============== S U B R O U T I N E =======================================
.text$mn:00002424
.text$mn:00002424 ; Attributes: bp-based frame
.text$mn:00002424
.text$mn:00002424 ; public: __thiscall ScopedMem<wchar_t>::operator wchar_t *(void)const
.text$mn:00002424                 public ??B?$ScopedMem@_W@@QBEPA_WXZ
.text$mn:00002424 ??B?$ScopedMem@_W@@QBEPA_WXZ proc near  ; CODE XREF: FindPrevInstWindow(void * *)+2Fp
.text$mn:00002424                                         ; FindPrevInstWindow(void * *)+40p ...
.text$mn:00002424
.text$mn:00002424 var_CC          = byte ptr -0CCh
.text$mn:00002424 var_8           = dword ptr -8
.text$mn:00002424
.text$mn:00002424                 push    ebp
.text$mn:00002425                 mov     ebp, esp
.text$mn:00002427                 sub     esp, 0CCh
.text$mn:0000242D                 push    ebx
.text$mn:0000242E                 push    esi
.text$mn:0000242F                 push    edi
.text$mn:00002430                 push    ecx
.text$mn:00002431                 lea     edi, [ebp+var_CC]
.text$mn:00002437                 mov     ecx, 33h ; '3'
.text$mn:0000243C                 mov     eax, 0CCCCCCCCh
.text$mn:00002441                 rep stosd
.text$mn:00002443                 pop     ecx
.text$mn:00002444                 mov     [ebp+var_8], ecx
.text$mn:00002447                 mov     eax, [ebp+var_8]
.text$mn:0000244A                 mov     eax, [eax]
.text$mn:0000244C                 pop     edi
.text$mn:0000244D                 pop     esi
.text$mn:0000244E                 pop     ebx
.text$mn:0000244F                 mov     esp, ebp
.text$mn:00002451                 pop     ebp
.text$mn:00002452                 retn
.text$mn:00002452 ??B?$ScopedMem@_W@@QBEPA_WXZ endp
.text$mn:00002452
.text$mn:00002452 ; ---------------------------------------------------------------------------
.text$mn:00002453                 align 4
.text$mn:00002453 _text$mn        ends
.text$mn:00002453
.text$mn:00002454 ; ===========================================================================
.text$mn:00002454
.text$mn:00002454 ; Segment type: Pure code
.text$mn:00002454 ; Segment permissions: Read/Execute
.text$mn:00002454 _text$mn        segment para public 'CODE' use32
.text$mn:00002454                 assume cs:_text$mn
.text$mn:00002454                 ;org 2454h
.text$mn:00002454                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002454
.text$mn:00002454 ; =============== S U B R O U T I N E =======================================
.text$mn:00002454
.text$mn:00002454 ; Attributes: bp-based frame
.text$mn:00002454
.text$mn:00002454 ; public: struct SessionData * & __thiscall Vec<struct SessionData *>::Iter::operator*(void)const
.text$mn:00002454                 public ??DIter@?$Vec@PAUSessionData@@@@QBEAAPAUSessionData@@XZ
.text$mn:00002454 ??DIter@?$Vec@PAUSessionData@@@@QBEAAPAUSessionData@@XZ proc near
.text$mn:00002454                                         ; CODE XREF: WinMain(x,x,x,x)+782p
.text$mn:00002454
.text$mn:00002454 var_CC          = byte ptr -0CCh
.text$mn:00002454 var_8           = dword ptr -8
.text$mn:00002454
.text$mn:00002454                 push    ebp
.text$mn:00002455                 mov     ebp, esp
.text$mn:00002457                 sub     esp, 0CCh
.text$mn:0000245D                 push    ebx
.text$mn:0000245E                 push    esi
.text$mn:0000245F                 push    edi
.text$mn:00002460                 push    ecx
.text$mn:00002461                 lea     edi, [ebp+var_CC]
.text$mn:00002467                 mov     ecx, 33h ; '3'
.text$mn:0000246C                 mov     eax, 0CCCCCCCCh
.text$mn:00002471                 rep stosd
.text$mn:00002473                 pop     ecx
.text$mn:00002474                 mov     [ebp+var_8], ecx
.text$mn:00002477                 mov     eax, [ebp+var_8]
.text$mn:0000247A                 mov     ecx, [eax+4]
.text$mn:0000247D                 push    ecx
.text$mn:0000247E                 mov     edx, [ebp+var_8]
.text$mn:00002481                 mov     ecx, [edx]
.text$mn:00002483                 call    ?At@?$Vec@PAUSessionData@@@@QBEAAPAUSessionData@@I@Z ; Vec<SessionData *>::At(uint)
.text$mn:00002488                 pop     edi
.text$mn:00002489                 pop     esi
.text$mn:0000248A                 pop     ebx
.text$mn:0000248B                 add     esp, 0CCh
.text$mn:00002491                 cmp     ebp, esp
.text$mn:00002493                 call    __RTC_CheckEsp
.text$mn:00002498                 mov     esp, ebp
.text$mn:0000249A                 pop     ebp
.text$mn:0000249B                 retn
.text$mn:0000249B ??DIter@?$Vec@PAUSessionData@@@@QBEAAPAUSessionData@@XZ endp
.text$mn:0000249B
.text$mn:0000249B _text$mn        ends
.text$mn:0000249B
.text$mn:0000249C ; ===========================================================================
.text$mn:0000249C
.text$mn:0000249C ; Segment type: Pure code
.text$mn:0000249C ; Segment permissions: Read/Execute
.text$mn:0000249C _text$mn        segment para public 'CODE' use32
.text$mn:0000249C                 assume cs:_text$mn
.text$mn:0000249C                 ;org 249Ch
.text$mn:0000249C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000249C
.text$mn:0000249C ; =============== S U B R O U T I N E =======================================
.text$mn:0000249C
.text$mn:0000249C ; Attributes: bp-based frame
.text$mn:0000249C
.text$mn:0000249C ; public: struct TabState * & __thiscall Vec<struct TabState *>::Iter::operator*(void)const
.text$mn:0000249C                 public ??DIter@?$Vec@PAUTabState@@@@QBEAAPAUTabState@@XZ
.text$mn:0000249C ??DIter@?$Vec@PAUTabState@@@@QBEAAPAUTabState@@XZ proc near
.text$mn:0000249C                                         ; CODE XREF: WinMain(x,x,x,x)+802p
.text$mn:0000249C
.text$mn:0000249C var_CC          = byte ptr -0CCh
.text$mn:0000249C var_8           = dword ptr -8
.text$mn:0000249C
.text$mn:0000249C                 push    ebp
.text$mn:0000249D                 mov     ebp, esp
.text$mn:0000249F                 sub     esp, 0CCh
.text$mn:000024A5                 push    ebx
.text$mn:000024A6                 push    esi
.text$mn:000024A7                 push    edi
.text$mn:000024A8                 push    ecx
.text$mn:000024A9                 lea     edi, [ebp+var_CC]
.text$mn:000024AF                 mov     ecx, 33h ; '3'
.text$mn:000024B4                 mov     eax, 0CCCCCCCCh
.text$mn:000024B9                 rep stosd
.text$mn:000024BB                 pop     ecx
.text$mn:000024BC                 mov     [ebp+var_8], ecx
.text$mn:000024BF                 mov     eax, [ebp+var_8]
.text$mn:000024C2                 mov     ecx, [eax+4]
.text$mn:000024C5                 push    ecx
.text$mn:000024C6                 mov     edx, [ebp+var_8]
.text$mn:000024C9                 mov     ecx, [edx]
.text$mn:000024CB                 call    ?At@?$Vec@PAUTabState@@@@QBEAAPAUTabState@@I@Z ; Vec<TabState *>::At(uint)
.text$mn:000024D0                 pop     edi
.text$mn:000024D1                 pop     esi
.text$mn:000024D2                 pop     ebx
.text$mn:000024D3                 add     esp, 0CCh
.text$mn:000024D9                 cmp     ebp, esp
.text$mn:000024DB                 call    __RTC_CheckEsp
.text$mn:000024E0                 mov     esp, ebp
.text$mn:000024E2                 pop     ebp
.text$mn:000024E3                 retn
.text$mn:000024E3 ??DIter@?$Vec@PAUTabState@@@@QBEAAPAUTabState@@XZ endp
.text$mn:000024E3
.text$mn:000024E3 _text$mn        ends
.text$mn:000024E3
.text$mn:000024E4 ; ===========================================================================
.text$mn:000024E4
.text$mn:000024E4 ; Segment type: Pure code
.text$mn:000024E4 ; Segment permissions: Read/Execute
.text$mn:000024E4 _text$mn        segment para public 'CODE' use32
.text$mn:000024E4                 assume cs:_text$mn
.text$mn:000024E4                 ;org 24E4h
.text$mn:000024E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024E4
.text$mn:000024E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000024E4
.text$mn:000024E4 ; Attributes: bp-based frame
.text$mn:000024E4
.text$mn:000024E4 ; public: wchar_t * & __thiscall Vec<wchar_t *>::Iter::operator*(void)const
.text$mn:000024E4                 public ??DIter@?$Vec@PA_W@@QBEAAPA_WXZ
.text$mn:000024E4 ??DIter@?$Vec@PA_W@@QBEAAPA_WXZ proc near
.text$mn:000024E4                                         ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+64p
.text$mn:000024E4
.text$mn:000024E4 var_CC          = byte ptr -0CCh
.text$mn:000024E4 var_8           = dword ptr -8
.text$mn:000024E4
.text$mn:000024E4                 push    ebp
.text$mn:000024E5                 mov     ebp, esp
.text$mn:000024E7                 sub     esp, 0CCh
.text$mn:000024ED                 push    ebx
.text$mn:000024EE                 push    esi
.text$mn:000024EF                 push    edi
.text$mn:000024F0                 push    ecx
.text$mn:000024F1                 lea     edi, [ebp+var_CC]
.text$mn:000024F7                 mov     ecx, 33h ; '3'
.text$mn:000024FC                 mov     eax, 0CCCCCCCCh
.text$mn:00002501                 rep stosd
.text$mn:00002503                 pop     ecx
.text$mn:00002504                 mov     [ebp+var_8], ecx
.text$mn:00002507                 mov     eax, [ebp+var_8]
.text$mn:0000250A                 mov     ecx, [eax+4]
.text$mn:0000250D                 push    ecx
.text$mn:0000250E                 mov     edx, [ebp+var_8]
.text$mn:00002511                 mov     ecx, [edx]
.text$mn:00002513                 call    ?At@?$Vec@PA_W@@QBEAAPA_WI@Z ; Vec<wchar_t *>::At(uint)
.text$mn:00002518                 pop     edi
.text$mn:00002519                 pop     esi
.text$mn:0000251A                 pop     ebx
.text$mn:0000251B                 add     esp, 0CCh
.text$mn:00002521                 cmp     ebp, esp
.text$mn:00002523                 call    __RTC_CheckEsp
.text$mn:00002528                 mov     esp, ebp
.text$mn:0000252A                 pop     ebp
.text$mn:0000252B                 retn
.text$mn:0000252B ??DIter@?$Vec@PA_W@@QBEAAPA_WXZ endp
.text$mn:0000252B
.text$mn:0000252B _text$mn        ends
.text$mn:0000252B
.text$mn:0000252C ; ===========================================================================
.text$mn:0000252C
.text$mn:0000252C ; Segment type: Pure code
.text$mn:0000252C ; Segment permissions: Read/Execute
.text$mn:0000252C _text$mn        segment para public 'CODE' use32
.text$mn:0000252C                 assume cs:_text$mn
.text$mn:0000252C                 ;org 252Ch
.text$mn:0000252C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000252C
.text$mn:0000252C ; =============== S U B R O U T I N E =======================================
.text$mn:0000252C
.text$mn:0000252C ; Attributes: bp-based frame
.text$mn:0000252C
.text$mn:0000252C ; public: class Vec<struct SessionData *>::Iter & __thiscall Vec<struct SessionData *>::Iter::operator++(void)
.text$mn:0000252C                 public ??EIter@?$Vec@PAUSessionData@@@@QAEAAV01@XZ
.text$mn:0000252C ??EIter@?$Vec@PAUSessionData@@@@QAEAAV01@XZ proc near
.text$mn:0000252C                                         ; CODE XREF: WinMain(x,x,x,x)+75Ap
.text$mn:0000252C
.text$mn:0000252C var_CC          = byte ptr -0CCh
.text$mn:0000252C var_8           = dword ptr -8
.text$mn:0000252C
.text$mn:0000252C                 push    ebp
.text$mn:0000252D                 mov     ebp, esp
.text$mn:0000252F                 sub     esp, 0CCh
.text$mn:00002535                 push    ebx
.text$mn:00002536                 push    esi
.text$mn:00002537                 push    edi
.text$mn:00002538                 push    ecx
.text$mn:00002539                 lea     edi, [ebp+var_CC]
.text$mn:0000253F                 mov     ecx, 33h ; '3'
.text$mn:00002544                 mov     eax, 0CCCCCCCCh
.text$mn:00002549                 rep stosd
.text$mn:0000254B                 pop     ecx
.text$mn:0000254C                 mov     [ebp+var_8], ecx
.text$mn:0000254F                 mov     eax, [ebp+var_8]
.text$mn:00002552                 mov     ecx, [eax+4]
.text$mn:00002555                 add     ecx, 1
.text$mn:00002558                 mov     edx, [ebp+var_8]
.text$mn:0000255B                 mov     [edx+4], ecx
.text$mn:0000255E                 mov     eax, [ebp+var_8]
.text$mn:00002561                 pop     edi
.text$mn:00002562                 pop     esi
.text$mn:00002563                 pop     ebx
.text$mn:00002564                 mov     esp, ebp
.text$mn:00002566                 pop     ebp
.text$mn:00002567                 retn
.text$mn:00002567 ??EIter@?$Vec@PAUSessionData@@@@QAEAAV01@XZ endp
.text$mn:00002567
.text$mn:00002567 _text$mn        ends
.text$mn:00002567
.text$mn:00002568 ; ===========================================================================
.text$mn:00002568
.text$mn:00002568 ; Segment type: Pure code
.text$mn:00002568 ; Segment permissions: Read/Execute
.text$mn:00002568 _text$mn        segment para public 'CODE' use32
.text$mn:00002568                 assume cs:_text$mn
.text$mn:00002568                 ;org 2568h
.text$mn:00002568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002568
.text$mn:00002568 ; =============== S U B R O U T I N E =======================================
.text$mn:00002568
.text$mn:00002568 ; Attributes: bp-based frame
.text$mn:00002568
.text$mn:00002568 ; public: class Vec<struct TabState *>::Iter & __thiscall Vec<struct TabState *>::Iter::operator++(void)
.text$mn:00002568                 public ??EIter@?$Vec@PAUTabState@@@@QAEAAV01@XZ
.text$mn:00002568 ??EIter@?$Vec@PAUTabState@@@@QAEAAV01@XZ proc near
.text$mn:00002568                                         ; CODE XREF: WinMain(x,x,x,x)+7DEp
.text$mn:00002568
.text$mn:00002568 var_CC          = byte ptr -0CCh
.text$mn:00002568 var_8           = dword ptr -8
.text$mn:00002568
.text$mn:00002568                 push    ebp
.text$mn:00002569                 mov     ebp, esp
.text$mn:0000256B                 sub     esp, 0CCh
.text$mn:00002571                 push    ebx
.text$mn:00002572                 push    esi
.text$mn:00002573                 push    edi
.text$mn:00002574                 push    ecx
.text$mn:00002575                 lea     edi, [ebp+var_CC]
.text$mn:0000257B                 mov     ecx, 33h ; '3'
.text$mn:00002580                 mov     eax, 0CCCCCCCCh
.text$mn:00002585                 rep stosd
.text$mn:00002587                 pop     ecx
.text$mn:00002588                 mov     [ebp+var_8], ecx
.text$mn:0000258B                 mov     eax, [ebp+var_8]
.text$mn:0000258E                 mov     ecx, [eax+4]
.text$mn:00002591                 add     ecx, 1
.text$mn:00002594                 mov     edx, [ebp+var_8]
.text$mn:00002597                 mov     [edx+4], ecx
.text$mn:0000259A                 mov     eax, [ebp+var_8]
.text$mn:0000259D                 pop     edi
.text$mn:0000259E                 pop     esi
.text$mn:0000259F                 pop     ebx
.text$mn:000025A0                 mov     esp, ebp
.text$mn:000025A2                 pop     ebp
.text$mn:000025A3                 retn
.text$mn:000025A3 ??EIter@?$Vec@PAUTabState@@@@QAEAAV01@XZ endp
.text$mn:000025A3
.text$mn:000025A3 _text$mn        ends
.text$mn:000025A3
.text$mn:000025A4 ; ===========================================================================
.text$mn:000025A4
.text$mn:000025A4 ; Segment type: Pure code
.text$mn:000025A4 ; Segment permissions: Read/Execute
.text$mn:000025A4 _text$mn        segment para public 'CODE' use32
.text$mn:000025A4                 assume cs:_text$mn
.text$mn:000025A4                 ;org 25A4h
.text$mn:000025A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025A4
.text$mn:000025A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000025A4
.text$mn:000025A4 ; Attributes: bp-based frame
.text$mn:000025A4
.text$mn:000025A4 ; public: class Vec<wchar_t *>::Iter & __thiscall Vec<wchar_t *>::Iter::operator++(void)
.text$mn:000025A4                 public ??EIter@?$Vec@PA_W@@QAEAAV01@XZ
.text$mn:000025A4 ??EIter@?$Vec@PA_W@@QAEAAV01@XZ proc near
.text$mn:000025A4                                         ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+49p
.text$mn:000025A4
.text$mn:000025A4 var_CC          = byte ptr -0CCh
.text$mn:000025A4 var_8           = dword ptr -8
.text$mn:000025A4
.text$mn:000025A4                 push    ebp
.text$mn:000025A5                 mov     ebp, esp
.text$mn:000025A7                 sub     esp, 0CCh
.text$mn:000025AD                 push    ebx
.text$mn:000025AE                 push    esi
.text$mn:000025AF                 push    edi
.text$mn:000025B0                 push    ecx
.text$mn:000025B1                 lea     edi, [ebp+var_CC]
.text$mn:000025B7                 mov     ecx, 33h ; '3'
.text$mn:000025BC                 mov     eax, 0CCCCCCCCh
.text$mn:000025C1                 rep stosd
.text$mn:000025C3                 pop     ecx
.text$mn:000025C4                 mov     [ebp+var_8], ecx
.text$mn:000025C7                 mov     eax, [ebp+var_8]
.text$mn:000025CA                 mov     ecx, [eax+4]
.text$mn:000025CD                 add     ecx, 1
.text$mn:000025D0                 mov     edx, [ebp+var_8]
.text$mn:000025D3                 mov     [edx+4], ecx
.text$mn:000025D6                 mov     eax, [ebp+var_8]
.text$mn:000025D9                 pop     edi
.text$mn:000025DA                 pop     esi
.text$mn:000025DB                 pop     ebx
.text$mn:000025DC                 mov     esp, ebp
.text$mn:000025DE                 pop     ebp
.text$mn:000025DF                 retn
.text$mn:000025DF ??EIter@?$Vec@PA_W@@QAEAAV01@XZ endp
.text$mn:000025DF
.text$mn:000025DF _text$mn        ends
.text$mn:000025DF
.text$mn:000025E0 ; ===========================================================================
.text$mn:000025E0
.text$mn:000025E0 ; Segment type: Pure code
.text$mn:000025E0 ; Segment permissions: Read/Execute
.text$mn:000025E0 _text$mn        segment para public 'CODE' use32
.text$mn:000025E0                 assume cs:_text$mn
.text$mn:000025E0                 ;org 25E0h
.text$mn:000025E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025E0
.text$mn:000025E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025E0
.text$mn:000025E0 ; Attributes: bp-based frame
.text$mn:000025E0
.text$mn:000025E0 ; public: void __thiscall _lambda_b6f3cb1c717d8c8a816f87295491882e_::operator()(void)const
.text$mn:000025E0 ??R_lambda_b6f3cb1c717d8c8a816f87295491882e_@@QBEXXZ proc near
.text$mn:000025E0                                         ; CODE XREF: ??$_Call@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$V@_Invoker_functor@std@@SAXAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z+2Cp
.text$mn:000025E0
.text$mn:000025E0 var_CC          = byte ptr -0CCh
.text$mn:000025E0 var_8           = dword ptr -8
.text$mn:000025E0
.text$mn:000025E0                 push    ebp
.text$mn:000025E1                 mov     ebp, esp
.text$mn:000025E3                 sub     esp, 0CCh
.text$mn:000025E9                 push    ebx
.text$mn:000025EA                 push    esi
.text$mn:000025EB                 push    edi
.text$mn:000025EC                 push    ecx
.text$mn:000025ED                 lea     edi, [ebp+var_CC]
.text$mn:000025F3                 mov     ecx, 33h ; '3'
.text$mn:000025F8                 mov     eax, 0CCCCCCCCh
.text$mn:000025FD                 rep stosd
.text$mn:000025FF                 pop     ecx
.text$mn:00002600                 mov     [ebp+var_8], ecx
.text$mn:00002603
.text$mn:00002603 loc_2603:                               ; CODE XREF: _lambda_b6f3cb1c717d8c8a816f87295491882e_::operator()(void)+25j
.text$mn:00002603                                         ; _lambda_b6f3cb1c717d8c8a816f87295491882e_::operator()(void)+3Fj
.text$mn:00002603                 xor     eax, eax
.text$mn:00002605                 jnz     short loc_2603
.text$mn:00002607                 mov     eax, [ebp+var_8]
.text$mn:0000260A                 mov     ecx, [eax]      ; this
.text$mn:0000260C                 call    ?WasCancelRequested@ThreadBase@@IAE_NXZ ; ThreadBase::WasCancelRequested(void)
.text$mn:00002611                 movzx   ecx, al
.text$mn:00002614                 push    ecx             ; bool
.text$mn:00002615                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:0000261A                 add     esp, 4
.text$mn:0000261D                 xor     eax, eax
.text$mn:0000261F                 jnz     short loc_2603
.text$mn:00002621                 mov     eax, [ebp+var_8]
.text$mn:00002624                 mov     ecx, [eax]      ; this
.text$mn:00002626                 call    ?HideMissingFiles@FileExistenceChecker@@AAEXXZ ; FileExistenceChecker::HideMissingFiles(void)
.text$mn:0000262B                 mov     eax, [ebp+var_8]
.text$mn:0000262E                 mov     ecx, [eax]      ; this
.text$mn:00002630                 call    ?Terminate@FileExistenceChecker@@AAEXXZ ; FileExistenceChecker::Terminate(void)
.text$mn:00002635                 pop     edi
.text$mn:00002636                 pop     esi
.text$mn:00002637                 pop     ebx
.text$mn:00002638                 add     esp, 0CCh
.text$mn:0000263E                 cmp     ebp, esp
.text$mn:00002640                 call    __RTC_CheckEsp
.text$mn:00002645                 mov     esp, ebp
.text$mn:00002647                 pop     ebp
.text$mn:00002648                 retn
.text$mn:00002648 ??R_lambda_b6f3cb1c717d8c8a816f87295491882e_@@QBEXXZ endp
.text$mn:00002648
.text$mn:00002648 ; ---------------------------------------------------------------------------
.text$mn:00002649                 align 4
.text$mn:00002649 _text$mn        ends
.text$mn:00002649
.text$mn:0000264C ; ===========================================================================
.text$mn:0000264C
.text$mn:0000264C ; Segment type: Pure code
.text$mn:0000264C ; Segment permissions: Read/Execute
.text$mn:0000264C _text$mn        segment para public 'CODE' use32
.text$mn:0000264C                 assume cs:_text$mn
.text$mn:0000264C                 ;org 264Ch
.text$mn:0000264C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000264C
.text$mn:0000264C ; =============== S U B R O U T I N E =======================================
.text$mn:0000264C
.text$mn:0000264C ; Attributes: bp-based frame
.text$mn:0000264C
.text$mn:0000264C                 public ??_G?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAEPAXI@Z
.text$mn:0000264C ??_G?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAEPAXI@Z proc near
.text$mn:0000264C                                         ; CODE XREF: ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z+28p
.text$mn:0000264C
.text$mn:0000264C var_CC          = byte ptr -0CCh
.text$mn:0000264C var_8           = dword ptr -8
.text$mn:0000264C arg_0           = dword ptr  8
.text$mn:0000264C
.text$mn:0000264C                 push    ebp
.text$mn:0000264D                 mov     ebp, esp
.text$mn:0000264F                 sub     esp, 0CCh
.text$mn:00002655                 push    ebx
.text$mn:00002656                 push    esi
.text$mn:00002657                 push    edi
.text$mn:00002658                 push    ecx
.text$mn:00002659                 lea     edi, [ebp+var_CC]
.text$mn:0000265F                 mov     ecx, 33h ; '3'
.text$mn:00002664                 mov     eax, 0CCCCCCCCh
.text$mn:00002669                 rep stosd
.text$mn:0000266B                 pop     ecx
.text$mn:0000266C                 mov     [ebp+var_8], ecx
.text$mn:0000266F                 mov     ecx, [ebp+var_8]
.text$mn:00002672                 call    ??1?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@XZ
.text$mn:00002677                 mov     eax, [ebp+arg_0]
.text$mn:0000267A                 and     eax, 1
.text$mn:0000267D                 jz      short loc_268D
.text$mn:0000267F                 push    8
.text$mn:00002681                 mov     eax, [ebp+var_8]
.text$mn:00002684                 push    eax             ; void *
.text$mn:00002685                 call    ??3@YAXPAXI@Z   ; operator delete(void *,uint)
.text$mn:0000268A                 add     esp, 8
.text$mn:0000268D
.text$mn:0000268D loc_268D:                               ; CODE XREF: ??_G?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAEPAXI@Z+31j
.text$mn:0000268D                 mov     eax, [ebp+var_8]
.text$mn:00002690                 pop     edi
.text$mn:00002691                 pop     esi
.text$mn:00002692                 pop     ebx
.text$mn:00002693                 add     esp, 0CCh
.text$mn:00002699                 cmp     ebp, esp
.text$mn:0000269B                 call    __RTC_CheckEsp
.text$mn:000026A0                 mov     esp, ebp
.text$mn:000026A2                 pop     ebp
.text$mn:000026A3                 retn    4
.text$mn:000026A3 ??_G?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAEPAXI@Z endp
.text$mn:000026A3
.text$mn:000026A3 ; ---------------------------------------------------------------------------
.text$mn:000026A6                 align 4
.text$mn:000026A6 _text$mn        ends
.text$mn:000026A6
.text$mn:000026A8 ; ===========================================================================
.text$mn:000026A8
.text$mn:000026A8 ; Segment type: Pure code
.text$mn:000026A8 ; Segment permissions: Read/Execute
.text$mn:000026A8 _text$mn        segment para public 'CODE' use32
.text$mn:000026A8                 assume cs:_text$mn
.text$mn:000026A8                 ;org 26A8h
.text$mn:000026A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026A8
.text$mn:000026A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026A8
.text$mn:000026A8 ; Attributes: bp-based frame
.text$mn:000026A8
.text$mn:000026A8 ; public: virtual void * __thiscall FileExistenceChecker::`scalar deleting destructor'(unsigned int)
.text$mn:000026A8                 public ??_GFileExistenceChecker@@UAEPAXI@Z
.text$mn:000026A8 ??_GFileExistenceChecker@@UAEPAXI@Z proc near
.text$mn:000026A8
.text$mn:000026A8 var_CC          = byte ptr -0CCh
.text$mn:000026A8 var_8           = dword ptr -8
.text$mn:000026A8 arg_0           = dword ptr  8
.text$mn:000026A8
.text$mn:000026A8                 push    ebp
.text$mn:000026A9                 mov     ebp, esp
.text$mn:000026AB                 sub     esp, 0CCh
.text$mn:000026B1                 push    ebx
.text$mn:000026B2                 push    esi
.text$mn:000026B3                 push    edi
.text$mn:000026B4                 push    ecx
.text$mn:000026B5                 lea     edi, [ebp+var_CC]
.text$mn:000026BB                 mov     ecx, 33h ; '3'
.text$mn:000026C0                 mov     eax, 0CCCCCCCCh
.text$mn:000026C5                 rep stosd
.text$mn:000026C7                 pop     ecx
.text$mn:000026C8                 mov     [ebp+var_8], ecx
.text$mn:000026CB                 mov     ecx, [ebp+var_8] ; this
.text$mn:000026CE                 call    ??1FileExistenceChecker@@UAE@XZ ; FileExistenceChecker::~FileExistenceChecker(void)
.text$mn:000026D3                 mov     eax, [ebp+arg_0]
.text$mn:000026D6                 and     eax, 1
.text$mn:000026D9                 jz      short loc_26E9
.text$mn:000026DB                 push    68h ; 'h'
.text$mn:000026DD                 mov     eax, [ebp+var_8]
.text$mn:000026E0                 push    eax             ; void *
.text$mn:000026E1                 call    ??3@YAXPAXI@Z   ; operator delete(void *,uint)
.text$mn:000026E6                 add     esp, 8
.text$mn:000026E9
.text$mn:000026E9 loc_26E9:                               ; CODE XREF: FileExistenceChecker::`scalar deleting destructor'(uint)+31j
.text$mn:000026E9                 mov     eax, [ebp+var_8]
.text$mn:000026EC                 pop     edi
.text$mn:000026ED                 pop     esi
.text$mn:000026EE                 pop     ebx
.text$mn:000026EF                 add     esp, 0CCh
.text$mn:000026F5                 cmp     ebp, esp
.text$mn:000026F7                 call    __RTC_CheckEsp
.text$mn:000026FC                 mov     esp, ebp
.text$mn:000026FE                 pop     ebp
.text$mn:000026FF                 retn    4
.text$mn:000026FF ??_GFileExistenceChecker@@UAEPAXI@Z endp
.text$mn:000026FF
.text$mn:000026FF ; ---------------------------------------------------------------------------
.text$mn:00002702                 align 4
.text$mn:00002702 _text$mn        ends
.text$mn:00002702
.text$mn:00002704 ; ===========================================================================
.text$mn:00002704
.text$mn:00002704 ; Segment type: Pure code
.text$mn:00002704 ; Segment permissions: Read/Execute
.text$mn:00002704 _text$mn        segment para public 'CODE' use32
.text$mn:00002704                 assume cs:_text$mn
.text$mn:00002704                 ;org 2704h
.text$mn:00002704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002704
.text$mn:00002704 ; =============== S U B R O U T I N E =======================================
.text$mn:00002704
.text$mn:00002704 ; Attributes: bp-based frame
.text$mn:00002704
.text$mn:00002704 ; void __stdcall `vector constructor iterator'(void *, unsigned int, unsigned int, void * (__thiscall *)(void *))
.text$mn:00002704                 public ??_H@YGXPAXIIP6EPAX0@Z@Z
.text$mn:00002704 ??_H@YGXPAXIIP6EPAX0@Z@Z proc near      ; CODE XREF: Vec<geomutil::RectT<int>>::Vec<geomutil::RectT<int>>(uint,Allocator *)+3Cp
.text$mn:00002704
.text$mn:00002704 var_C8          = dword ptr -0C8h
.text$mn:00002704 var_C4          = dword ptr -0C4h
.text$mn:00002704 arg_0           = dword ptr  8
.text$mn:00002704 arg_4           = dword ptr  0Ch
.text$mn:00002704 arg_8           = dword ptr  10h
.text$mn:00002704 arg_C           = dword ptr  14h
.text$mn:00002704
.text$mn:00002704                 push    ebp
.text$mn:00002705                 mov     ebp, esp
.text$mn:00002707                 sub     esp, 0C8h
.text$mn:0000270D                 push    ebx
.text$mn:0000270E                 push    esi
.text$mn:0000270F                 push    edi
.text$mn:00002710                 lea     edi, [ebp+var_C8]
.text$mn:00002716                 mov     ecx, 32h ; '2'
.text$mn:0000271B                 mov     eax, 0CCCCCCCCh
.text$mn:00002720                 rep stosd
.text$mn:00002722
.text$mn:00002722 loc_2722:                               ; CODE XREF: `vector constructor iterator'(void *,uint,uint,void * (*)(void *))+70j
.text$mn:00002722                 mov     eax, [ebp+arg_8]
.text$mn:00002725                 mov     [ebp+var_C4], eax
.text$mn:0000272B                 mov     ecx, [ebp+arg_8]
.text$mn:0000272E                 sub     ecx, 1
.text$mn:00002731                 mov     [ebp+arg_8], ecx
.text$mn:00002734                 cmp     [ebp+var_C4], 0
.text$mn:0000273B                 jbe     short loc_2749
.text$mn:0000273D                 mov     [ebp+var_C8], 1
.text$mn:00002747                 jmp     short loc_2753
.text$mn:00002749 ; ---------------------------------------------------------------------------
.text$mn:00002749
.text$mn:00002749 loc_2749:                               ; CODE XREF: `vector constructor iterator'(void *,uint,uint,void * (*)(void *))+37j
.text$mn:00002749                 mov     [ebp+var_C8], 0
.text$mn:00002753
.text$mn:00002753 loc_2753:                               ; CODE XREF: `vector constructor iterator'(void *,uint,uint,void * (*)(void *))+43j
.text$mn:00002753                 cmp     [ebp+var_C8], 0
.text$mn:0000275A                 jz      short loc_2776
.text$mn:0000275C                 mov     esi, esp
.text$mn:0000275E                 mov     ecx, [ebp+arg_0]
.text$mn:00002761                 call    [ebp+arg_C]
.text$mn:00002764                 cmp     esi, esp
.text$mn:00002766                 call    __RTC_CheckEsp
.text$mn:0000276B                 mov     eax, [ebp+arg_0]
.text$mn:0000276E                 add     eax, [ebp+arg_4]
.text$mn:00002771                 mov     [ebp+arg_0], eax
.text$mn:00002774                 jmp     short loc_2722
.text$mn:00002776 ; ---------------------------------------------------------------------------
.text$mn:00002776
.text$mn:00002776 loc_2776:                               ; CODE XREF: `vector constructor iterator'(void *,uint,uint,void * (*)(void *))+56j
.text$mn:00002776                 pop     edi
.text$mn:00002777                 pop     esi
.text$mn:00002778                 pop     ebx
.text$mn:00002779                 add     esp, 0C8h
.text$mn:0000277F                 cmp     ebp, esp
.text$mn:00002781                 call    __RTC_CheckEsp
.text$mn:00002786                 mov     esp, ebp
.text$mn:00002788                 pop     ebp
.text$mn:00002789                 retn    10h
.text$mn:00002789 ??_H@YGXPAXIIP6EPAX0@Z@Z endp
.text$mn:00002789
.text$mn:00002789 _text$mn        ends
.text$mn:00002789
.text$mn:0000278C ; ===========================================================================
.text$mn:0000278C
.text$mn:0000278C ; Segment type: Pure code
.text$mn:0000278C ; Segment permissions: Read/Execute
.text$mn:0000278C _text$mn        segment para public 'CODE' use32
.text$mn:0000278C                 assume cs:_text$mn
.text$mn:0000278C                 ;org 278Ch
.text$mn:0000278C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000278C
.text$mn:0000278C ; =============== S U B R O U T I N E =======================================
.text$mn:0000278C
.text$mn:0000278C ; Attributes: bp-based frame
.text$mn:0000278C
.text$mn:0000278C ; public: void __thiscall str::Str<wchar_t>::Append(wchar_t const *, unsigned int)
.text$mn:0000278C                 public ?Append@?$Str@_W@str@@QAEXPB_WI@Z
.text$mn:0000278C ?Append@?$Str@_W@str@@QAEXPB_WI@Z proc near
.text$mn:0000278C                                         ; CODE XREF: str::Str<wchar_t>::AppendAndFree(wchar_t *)+32p
.text$mn:0000278C
.text$mn:0000278C var_CC          = byte ptr -0CCh
.text$mn:0000278C var_8           = dword ptr -8
.text$mn:0000278C arg_0           = dword ptr  8
.text$mn:0000278C arg_4           = dword ptr  0Ch
.text$mn:0000278C
.text$mn:0000278C                 push    ebp
.text$mn:0000278D                 mov     ebp, esp
.text$mn:0000278F                 sub     esp, 0CCh
.text$mn:00002795                 push    ebx
.text$mn:00002796                 push    esi
.text$mn:00002797                 push    edi             ; wchar_t *
.text$mn:00002798                 push    ecx
.text$mn:00002799                 lea     edi, [ebp+var_CC]
.text$mn:0000279F                 mov     ecx, 33h ; '3'
.text$mn:000027A4                 mov     eax, 0CCCCCCCCh
.text$mn:000027A9                 rep stosd
.text$mn:000027AB                 pop     ecx
.text$mn:000027AC                 mov     [ebp+var_8], ecx
.text$mn:000027AF                 cmp     [ebp+arg_4], 0FFFFFFFFh
.text$mn:000027B3                 jnz     short loc_27C4
.text$mn:000027B5                 mov     eax, [ebp+arg_0]
.text$mn:000027B8                 push    eax             ; this
.text$mn:000027B9                 call    ?Len@str@@YAIPB_W@Z ; str::Len(wchar_t const *)
.text$mn:000027BE                 add     esp, 4
.text$mn:000027C1                 mov     [ebp+arg_4], eax
.text$mn:000027C4
.text$mn:000027C4 loc_27C4:                               ; CODE XREF: str::Str<wchar_t>::Append(wchar_t const *,uint)+27j
.text$mn:000027C4                 mov     eax, [ebp+arg_4]
.text$mn:000027C7                 push    eax             ; int
.text$mn:000027C8                 mov     ecx, [ebp+arg_0]
.text$mn:000027CB                 push    ecx             ; Src
.text$mn:000027CC                 mov     ecx, [ebp+var_8]
.text$mn:000027CF                 call    ?Append@?$Vec@_W@@QAEXPB_WI@Z ; Vec<wchar_t>::Append(wchar_t const *,uint)
.text$mn:000027D4                 pop     edi
.text$mn:000027D5                 pop     esi
.text$mn:000027D6                 pop     ebx
.text$mn:000027D7                 add     esp, 0CCh
.text$mn:000027DD                 cmp     ebp, esp
.text$mn:000027DF                 call    __RTC_CheckEsp
.text$mn:000027E4                 mov     esp, ebp
.text$mn:000027E6                 pop     ebp
.text$mn:000027E7                 retn    8
.text$mn:000027E7 ?Append@?$Str@_W@str@@QAEXPB_WI@Z endp
.text$mn:000027E7
.text$mn:000027E7 ; ---------------------------------------------------------------------------
.text$mn:000027EA                 align 4
.text$mn:000027EA _text$mn        ends
.text$mn:000027EA
.text$mn:000027EC ; ===========================================================================
.text$mn:000027EC
.text$mn:000027EC ; Segment type: Pure code
.text$mn:000027EC ; Segment permissions: Read/Execute
.text$mn:000027EC _text$mn        segment para public 'CODE' use32
.text$mn:000027EC                 assume cs:_text$mn
.text$mn:000027EC                 ;org 27ECh
.text$mn:000027EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027EC
.text$mn:000027EC ; =============== S U B R O U T I N E =======================================
.text$mn:000027EC
.text$mn:000027EC ; Attributes: bp-based frame
.text$mn:000027EC
.text$mn:000027EC ; public: void __thiscall Vec<wchar_t *>::Append(wchar_t * const &)
.text$mn:000027EC                 public ?Append@?$Vec@PA_W@@QAEXABQA_W@Z
.text$mn:000027EC ?Append@?$Vec@PA_W@@QAEXABQA_W@Z proc near
.text$mn:000027EC                                         ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+7Ep
.text$mn:000027EC                                         ; FileExistenceChecker::GetFilePathsToCheck(void)+120p ...
.text$mn:000027EC
.text$mn:000027EC var_CC          = byte ptr -0CCh
.text$mn:000027EC var_8           = dword ptr -8
.text$mn:000027EC arg_0           = dword ptr  8
.text$mn:000027EC
.text$mn:000027EC                 push    ebp
.text$mn:000027ED                 mov     ebp, esp
.text$mn:000027EF                 sub     esp, 0CCh
.text$mn:000027F5                 push    ebx
.text$mn:000027F6                 push    esi
.text$mn:000027F7                 push    edi
.text$mn:000027F8                 push    ecx
.text$mn:000027F9                 lea     edi, [ebp+var_CC]
.text$mn:000027FF                 mov     ecx, 33h ; '3'
.text$mn:00002804                 mov     eax, 0CCCCCCCCh
.text$mn:00002809                 rep stosd
.text$mn:0000280B                 pop     ecx
.text$mn:0000280C                 mov     [ebp+var_8], ecx
.text$mn:0000280F                 mov     eax, [ebp+arg_0]
.text$mn:00002812                 push    eax
.text$mn:00002813                 mov     ecx, [ebp+var_8]
.text$mn:00002816                 mov     edx, [ecx]
.text$mn:00002818                 push    edx
.text$mn:00002819                 mov     ecx, [ebp+var_8]
.text$mn:0000281C                 call    ?InsertAt@?$Vec@PA_W@@QAEXIABQA_W@Z ; Vec<wchar_t *>::InsertAt(uint,wchar_t * const &)
.text$mn:00002821                 pop     edi
.text$mn:00002822                 pop     esi
.text$mn:00002823                 pop     ebx
.text$mn:00002824                 add     esp, 0CCh
.text$mn:0000282A                 cmp     ebp, esp
.text$mn:0000282C                 call    __RTC_CheckEsp
.text$mn:00002831                 mov     esp, ebp
.text$mn:00002833                 pop     ebp
.text$mn:00002834                 retn    4
.text$mn:00002834 ?Append@?$Vec@PA_W@@QAEXABQA_W@Z endp
.text$mn:00002834
.text$mn:00002834 ; ---------------------------------------------------------------------------
.text$mn:00002837                 align 4
.text$mn:00002837 _text$mn        ends
.text$mn:00002837
.text$mn:00002838 ; ===========================================================================
.text$mn:00002838
.text$mn:00002838 ; Segment type: Pure code
.text$mn:00002838 ; Segment permissions: Read/Execute
.text$mn:00002838 _text$mn        segment para public 'CODE' use32
.text$mn:00002838                 assume cs:_text$mn
.text$mn:00002838                 ;org 2838h
.text$mn:00002838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002838
.text$mn:00002838 ; =============== S U B R O U T I N E =======================================
.text$mn:00002838
.text$mn:00002838 ; Attributes: bp-based frame
.text$mn:00002838
.text$mn:00002838 ; int __stdcall Vec<wchar_t>::Append(void *Src, int)
.text$mn:00002838                 public ?Append@?$Vec@_W@@QAEXPB_WI@Z
.text$mn:00002838 ?Append@?$Vec@_W@@QAEXPB_WI@Z proc near ; CODE XREF: str::Str<wchar_t>::Append(wchar_t const *,uint)+43p
.text$mn:00002838
.text$mn:00002838 var_D8          = byte ptr -0D8h
.text$mn:00002838 Dst             = dword ptr -14h
.text$mn:00002838 var_8           = dword ptr -8
.text$mn:00002838 Src             = dword ptr  8
.text$mn:00002838 arg_4           = dword ptr  0Ch
.text$mn:00002838
.text$mn:00002838                 push    ebp
.text$mn:00002839                 mov     ebp, esp
.text$mn:0000283B                 sub     esp, 0D8h
.text$mn:00002841                 push    ebx
.text$mn:00002842                 push    esi
.text$mn:00002843                 push    edi
.text$mn:00002844                 push    ecx
.text$mn:00002845                 lea     edi, [ebp+var_D8]
.text$mn:0000284B                 mov     ecx, 36h ; '6'
.text$mn:00002850                 mov     eax, 0CCCCCCCCh
.text$mn:00002855                 rep stosd
.text$mn:00002857                 pop     ecx
.text$mn:00002858                 mov     [ebp+var_8], ecx
.text$mn:0000285B                 cmp     [ebp+arg_4], 0
.text$mn:0000285F                 jnz     short loc_2863
.text$mn:00002861                 jmp     short loc_2890
.text$mn:00002863 ; ---------------------------------------------------------------------------
.text$mn:00002863
.text$mn:00002863 loc_2863:                               ; CODE XREF: Vec<wchar_t>::Append(wchar_t const *,uint)+27j
.text$mn:00002863                 push    0
.text$mn:00002865                 mov     eax, [ebp+arg_4]
.text$mn:00002868                 push    eax
.text$mn:00002869                 mov     ecx, [ebp+var_8]
.text$mn:0000286C                 mov     edx, [ecx]
.text$mn:0000286E                 push    edx
.text$mn:0000286F                 mov     ecx, [ebp+var_8]
.text$mn:00002872                 call    ?MakeSpaceAt@?$Vec@_W@@IAEPA_WII_N@Z ; Vec<wchar_t>::MakeSpaceAt(uint,uint,bool)
.text$mn:00002877                 mov     [ebp+Dst], eax
.text$mn:0000287A                 mov     eax, [ebp+arg_4]
.text$mn:0000287D                 shl     eax, 1
.text$mn:0000287F                 push    eax             ; Size
.text$mn:00002880                 mov     ecx, [ebp+Src]
.text$mn:00002883                 push    ecx             ; Src
.text$mn:00002884                 mov     edx, [ebp+Dst]
.text$mn:00002887                 push    edx             ; Dst
.text$mn:00002888                 call    _memcpy
.text$mn:0000288D                 add     esp, 0Ch
.text$mn:00002890
.text$mn:00002890 loc_2890:                               ; CODE XREF: Vec<wchar_t>::Append(wchar_t const *,uint)+29j
.text$mn:00002890                 pop     edi
.text$mn:00002891                 pop     esi
.text$mn:00002892                 pop     ebx
.text$mn:00002893                 add     esp, 0D8h
.text$mn:00002899                 cmp     ebp, esp
.text$mn:0000289B                 call    __RTC_CheckEsp
.text$mn:000028A0                 mov     esp, ebp
.text$mn:000028A2                 pop     ebp
.text$mn:000028A3                 retn    8
.text$mn:000028A3 ?Append@?$Vec@_W@@QAEXPB_WI@Z endp
.text$mn:000028A3
.text$mn:000028A3 ; ---------------------------------------------------------------------------
.text$mn:000028A6                 align 4
.text$mn:000028A6 _text$mn        ends
.text$mn:000028A6
.text$mn:000028A8 ; ===========================================================================
.text$mn:000028A8
.text$mn:000028A8 ; Segment type: Pure code
.text$mn:000028A8 ; Segment permissions: Read/Execute
.text$mn:000028A8 _text$mn        segment para public 'CODE' use32
.text$mn:000028A8                 assume cs:_text$mn
.text$mn:000028A8                 ;org 28A8h
.text$mn:000028A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028A8
.text$mn:000028A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000028A8
.text$mn:000028A8 ; Attributes: bp-based frame
.text$mn:000028A8
.text$mn:000028A8 ; public: void __thiscall str::Str<wchar_t>::AppendAndFree(wchar_t *)
.text$mn:000028A8                 public ?AppendAndFree@?$Str@_W@str@@QAEXPA_W@Z
.text$mn:000028A8 ?AppendAndFree@?$Str@_W@str@@QAEXPA_W@Z proc near
.text$mn:000028A8                                         ; CODE XREF: str::Str<wchar_t>::AppendFmt(wchar_t const *,...)+43p
.text$mn:000028A8
.text$mn:000028A8 var_CC          = byte ptr -0CCh
.text$mn:000028A8 var_8           = dword ptr -8
.text$mn:000028A8 arg_0           = dword ptr  8
.text$mn:000028A8
.text$mn:000028A8                 push    ebp
.text$mn:000028A9                 mov     ebp, esp
.text$mn:000028AB                 sub     esp, 0CCh
.text$mn:000028B1                 push    ebx
.text$mn:000028B2                 push    esi
.text$mn:000028B3                 push    edi
.text$mn:000028B4                 push    ecx
.text$mn:000028B5                 lea     edi, [ebp+var_CC]
.text$mn:000028BB                 mov     ecx, 33h ; '3'
.text$mn:000028C0                 mov     eax, 0CCCCCCCCh
.text$mn:000028C5                 rep stosd
.text$mn:000028C7                 pop     ecx
.text$mn:000028C8                 mov     [ebp+var_8], ecx
.text$mn:000028CB                 cmp     [ebp+arg_0], 0
.text$mn:000028CF                 jz      short loc_28DF
.text$mn:000028D1                 push    0FFFFFFFFh
.text$mn:000028D3                 mov     eax, [ebp+arg_0]
.text$mn:000028D6                 push    eax
.text$mn:000028D7                 mov     ecx, [ebp+var_8]
.text$mn:000028DA                 call    ?Append@?$Str@_W@str@@QAEXPB_WI@Z ; str::Str<wchar_t>::Append(wchar_t const *,uint)
.text$mn:000028DF
.text$mn:000028DF loc_28DF:                               ; CODE XREF: str::Str<wchar_t>::AppendAndFree(wchar_t *)+27j
.text$mn:000028DF                 push    1
.text$mn:000028E1                 mov     eax, [ebp+arg_0]
.text$mn:000028E4                 push    eax
.text$mn:000028E5                 call    __free_dbg
.text$mn:000028EA                 add     esp, 8
.text$mn:000028ED                 pop     edi
.text$mn:000028EE                 pop     esi
.text$mn:000028EF                 pop     ebx
.text$mn:000028F0                 add     esp, 0CCh
.text$mn:000028F6                 cmp     ebp, esp
.text$mn:000028F8                 call    __RTC_CheckEsp
.text$mn:000028FD                 mov     esp, ebp
.text$mn:000028FF                 pop     ebp
.text$mn:00002900                 retn    4
.text$mn:00002900 ?AppendAndFree@?$Str@_W@str@@QAEXPA_W@Z endp
.text$mn:00002900
.text$mn:00002900 ; ---------------------------------------------------------------------------
.text$mn:00002903                 align 4
.text$mn:00002903 _text$mn        ends
.text$mn:00002903
.text$mn:00002904 ; ===========================================================================
.text$mn:00002904
.text$mn:00002904 ; Segment type: Pure code
.text$mn:00002904 ; Segment permissions: Read/Execute
.text$mn:00002904 _text$mn        segment para public 'CODE' use32
.text$mn:00002904                 assume cs:_text$mn
.text$mn:00002904                 ;org 2904h
.text$mn:00002904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002904
.text$mn:00002904 ; =============== S U B R O U T I N E =======================================
.text$mn:00002904
.text$mn:00002904 ; Attributes: bp-based frame
.text$mn:00002904
.text$mn:00002904 ; public: void __cdecl str::Str<wchar_t>::AppendFmt(wchar_t const *, ...)
.text$mn:00002904                 public ?AppendFmt@?$Str@_W@str@@QAAXPB_WZZ
.text$mn:00002904 ?AppendFmt@?$Str@_W@str@@QAAXPB_WZZ proc near
.text$mn:00002904                                         ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+6Bp
.text$mn:00002904                                         ; OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+AAp ...
.text$mn:00002904
.text$mn:00002904 var_D8          = byte ptr -0D8h
.text$mn:00002904 var_14          = dword ptr -14h
.text$mn:00002904 var_8           = dword ptr -8
.text$mn:00002904 arg_0           = dword ptr  8
.text$mn:00002904 arg_4           = dword ptr  0Ch
.text$mn:00002904 arg_8           = byte ptr  10h
.text$mn:00002904
.text$mn:00002904                 push    ebp
.text$mn:00002905                 mov     ebp, esp
.text$mn:00002907                 sub     esp, 0D8h
.text$mn:0000290D                 push    ebx
.text$mn:0000290E                 push    esi
.text$mn:0000290F                 push    edi             ; char *
.text$mn:00002910                 lea     edi, [ebp+var_D8]
.text$mn:00002916                 mov     ecx, 36h ; '6'
.text$mn:0000291B                 mov     eax, 0CCCCCCCCh
.text$mn:00002920                 rep stosd
.text$mn:00002922                 call    ??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ ; __vcrt_va_start_verify_argument_type<wchar_t const *>(void)
.text$mn:00002927                 lea     eax, [ebp+arg_8]
.text$mn:0000292A                 mov     [ebp+var_8], eax
.text$mn:0000292D                 mov     eax, [ebp+var_8]
.text$mn:00002930                 push    eax             ; wchar_t *
.text$mn:00002931                 mov     ecx, [ebp+arg_4]
.text$mn:00002934                 push    ecx             ; this
.text$mn:00002935                 call    ?FmtV@str@@YAPA_WPB_WPAD@Z ; str::FmtV(wchar_t const *,char *)
.text$mn:0000293A                 add     esp, 8
.text$mn:0000293D                 mov     [ebp+var_14], eax
.text$mn:00002940                 mov     eax, [ebp+var_14]
.text$mn:00002943                 push    eax
.text$mn:00002944                 mov     ecx, [ebp+arg_0]
.text$mn:00002947                 call    ?AppendAndFree@?$Str@_W@str@@QAEXPA_W@Z ; str::Str<wchar_t>::AppendAndFree(wchar_t *)
.text$mn:0000294C                 mov     [ebp+var_8], 0
.text$mn:00002953                 pop     edi
.text$mn:00002954                 pop     esi
.text$mn:00002955                 pop     ebx
.text$mn:00002956                 add     esp, 0D8h
.text$mn:0000295C                 cmp     ebp, esp
.text$mn:0000295E                 call    __RTC_CheckEsp
.text$mn:00002963                 mov     esp, ebp
.text$mn:00002965                 pop     ebp
.text$mn:00002966                 retn
.text$mn:00002966 ?AppendFmt@?$Str@_W@str@@QAAXPB_WZZ endp
.text$mn:00002966
.text$mn:00002966 ; ---------------------------------------------------------------------------
.text$mn:00002967                 align 4
.text$mn:00002967 _text$mn        ends
.text$mn:00002967
.text$mn:00002968 ; ===========================================================================
.text$mn:00002968
.text$mn:00002968 ; Segment type: Pure code
.text$mn:00002968 ; Segment permissions: Read/Execute
.text$mn:00002968 _text$mn        segment para public 'CODE' use32
.text$mn:00002968                 assume cs:_text$mn
.text$mn:00002968                 ;org 2968h
.text$mn:00002968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002968
.text$mn:00002968 ; =============== S U B R O U T I N E =======================================
.text$mn:00002968
.text$mn:00002968 ; Attributes: bp-based frame
.text$mn:00002968
.text$mn:00002968 ; struct EbookController *__thiscall TabInfo::AsEbook(TabInfo *__hidden this)
.text$mn:00002968                 public ?AsEbook@TabInfo@@QBEPAVEbookController@@XZ
.text$mn:00002968 ?AsEbook@TabInfo@@QBEPAVEbookController@@XZ proc near
.text$mn:00002968                                         ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+C4p
.text$mn:00002968
.text$mn:00002968 var_D0          = dword ptr -0D0h
.text$mn:00002968 var_8           = dword ptr -8
.text$mn:00002968
.text$mn:00002968                 push    ebp
.text$mn:00002969                 mov     ebp, esp
.text$mn:0000296B                 sub     esp, 0D0h
.text$mn:00002971                 push    ebx
.text$mn:00002972                 push    esi
.text$mn:00002973                 push    edi
.text$mn:00002974                 push    ecx
.text$mn:00002975                 lea     edi, [ebp+var_D0]
.text$mn:0000297B                 mov     ecx, 34h ; '4'
.text$mn:00002980                 mov     eax, 0CCCCCCCCh
.text$mn:00002985                 rep stosd
.text$mn:00002987                 pop     ecx
.text$mn:00002988                 mov     [ebp+var_8], ecx
.text$mn:0000298B                 mov     eax, [ebp+var_8]
.text$mn:0000298E                 cmp     dword ptr [eax+4], 0
.text$mn:00002992                 jz      short loc_29BB
.text$mn:00002994                 mov     ecx, [ebp+var_8]
.text$mn:00002997                 mov     edx, [ecx+4]
.text$mn:0000299A                 mov     eax, [ebp+var_8]
.text$mn:0000299D                 mov     edx, [edx]
.text$mn:0000299F                 mov     esi, esp
.text$mn:000029A1                 mov     ecx, [eax+4]
.text$mn:000029A4                 mov     eax, [edx+80h]
.text$mn:000029AA                 call    eax
.text$mn:000029AC                 cmp     esi, esp
.text$mn:000029AE                 call    __RTC_CheckEsp
.text$mn:000029B3                 mov     [ebp+var_D0], eax
.text$mn:000029B9                 jmp     short loc_29C5
.text$mn:000029BB ; ---------------------------------------------------------------------------
.text$mn:000029BB
.text$mn:000029BB loc_29BB:                               ; CODE XREF: TabInfo::AsEbook(void)+2Aj
.text$mn:000029BB                 mov     [ebp+var_D0], 0
.text$mn:000029C5
.text$mn:000029C5 loc_29C5:                               ; CODE XREF: TabInfo::AsEbook(void)+51j
.text$mn:000029C5                 mov     eax, [ebp+var_D0]
.text$mn:000029CB                 pop     edi
.text$mn:000029CC                 pop     esi
.text$mn:000029CD                 pop     ebx
.text$mn:000029CE                 add     esp, 0D0h
.text$mn:000029D4                 cmp     ebp, esp
.text$mn:000029D6                 call    __RTC_CheckEsp
.text$mn:000029DB                 mov     esp, ebp
.text$mn:000029DD                 pop     ebp
.text$mn:000029DE                 retn
.text$mn:000029DE ?AsEbook@TabInfo@@QBEPAVEbookController@@XZ endp
.text$mn:000029DE
.text$mn:000029DE ; ---------------------------------------------------------------------------
.text$mn:000029DF                 align 10h
.text$mn:000029DF _text$mn        ends
.text$mn:000029DF
.text$mn:000029E0 ; ===========================================================================
.text$mn:000029E0
.text$mn:000029E0 ; Segment type: Pure code
.text$mn:000029E0 ; Segment permissions: Read/Execute
.text$mn:000029E0 _text$mn        segment para public 'CODE' use32
.text$mn:000029E0                 assume cs:_text$mn
.text$mn:000029E0                 ;org 29E0h
.text$mn:000029E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029E0
.text$mn:000029E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000029E0
.text$mn:000029E0 ; Attributes: bp-based frame
.text$mn:000029E0
.text$mn:000029E0 ; struct DisplayModel *__thiscall TabInfo::AsFixed(TabInfo *__hidden this)
.text$mn:000029E0                 public ?AsFixed@TabInfo@@QBEPAVDisplayModel@@XZ
.text$mn:000029E0 ?AsFixed@TabInfo@@QBEPAVDisplayModel@@XZ proc near
.text$mn:000029E0                                         ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+127p
.text$mn:000029E0                                         ; RestoreTabOnStartup(WindowInfo *,TabState *)+145p ...
.text$mn:000029E0
.text$mn:000029E0 var_D0          = dword ptr -0D0h
.text$mn:000029E0 var_8           = dword ptr -8
.text$mn:000029E0
.text$mn:000029E0                 push    ebp
.text$mn:000029E1                 mov     ebp, esp
.text$mn:000029E3                 sub     esp, 0D0h
.text$mn:000029E9                 push    ebx
.text$mn:000029EA                 push    esi
.text$mn:000029EB                 push    edi
.text$mn:000029EC                 push    ecx
.text$mn:000029ED                 lea     edi, [ebp+var_D0]
.text$mn:000029F3                 mov     ecx, 34h ; '4'
.text$mn:000029F8                 mov     eax, 0CCCCCCCCh
.text$mn:000029FD                 rep stosd
.text$mn:000029FF                 pop     ecx
.text$mn:00002A00                 mov     [ebp+var_8], ecx
.text$mn:00002A03                 mov     eax, [ebp+var_8]
.text$mn:00002A06                 cmp     dword ptr [eax+4], 0
.text$mn:00002A0A                 jz      short loc_2A30
.text$mn:00002A0C                 mov     ecx, [ebp+var_8]
.text$mn:00002A0F                 mov     edx, [ecx+4]
.text$mn:00002A12                 mov     eax, [ebp+var_8]
.text$mn:00002A15                 mov     edx, [edx]
.text$mn:00002A17                 mov     esi, esp
.text$mn:00002A19                 mov     ecx, [eax+4]
.text$mn:00002A1C                 mov     eax, [edx+78h]
.text$mn:00002A1F                 call    eax
.text$mn:00002A21                 cmp     esi, esp
.text$mn:00002A23                 call    __RTC_CheckEsp
.text$mn:00002A28                 mov     [ebp+var_D0], eax
.text$mn:00002A2E                 jmp     short loc_2A3A
.text$mn:00002A30 ; ---------------------------------------------------------------------------
.text$mn:00002A30
.text$mn:00002A30 loc_2A30:                               ; CODE XREF: TabInfo::AsFixed(void)+2Aj
.text$mn:00002A30                 mov     [ebp+var_D0], 0
.text$mn:00002A3A
.text$mn:00002A3A loc_2A3A:                               ; CODE XREF: TabInfo::AsFixed(void)+4Ej
.text$mn:00002A3A                 mov     eax, [ebp+var_D0]
.text$mn:00002A40                 pop     edi
.text$mn:00002A41                 pop     esi
.text$mn:00002A42                 pop     ebx
.text$mn:00002A43                 add     esp, 0D0h
.text$mn:00002A49                 cmp     ebp, esp
.text$mn:00002A4B                 call    __RTC_CheckEsp
.text$mn:00002A50                 mov     esp, ebp
.text$mn:00002A52                 pop     ebp
.text$mn:00002A53                 retn
.text$mn:00002A53 ?AsFixed@TabInfo@@QBEPAVDisplayModel@@XZ endp
.text$mn:00002A53
.text$mn:00002A53 _text$mn        ends
.text$mn:00002A53
.text$mn:00002A54 ; ===========================================================================
.text$mn:00002A54
.text$mn:00002A54 ; Segment type: Pure code
.text$mn:00002A54 ; Segment permissions: Read/Execute
.text$mn:00002A54 _text$mn        segment para public 'CODE' use32
.text$mn:00002A54                 assume cs:_text$mn
.text$mn:00002A54                 ;org 2A54h
.text$mn:00002A54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A54
.text$mn:00002A54 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A54
.text$mn:00002A54 ; Attributes: bp-based frame
.text$mn:00002A54
.text$mn:00002A54 ; public: struct FileState * & __thiscall Vec<struct FileState *>::At(unsigned int)const
.text$mn:00002A54                 public ?At@?$Vec@PAUFileState@@@@QBEAAPAUFileState@@I@Z
.text$mn:00002A54 ?At@?$Vec@PAUFileState@@@@QBEAAPAUFileState@@I@Z proc near
.text$mn:00002A54                                         ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+DDp
.text$mn:00002A54
.text$mn:00002A54 var_D0          = byte ptr -0D0h
.text$mn:00002A54 var_CD          = byte ptr -0CDh
.text$mn:00002A54 var_8           = dword ptr -8
.text$mn:00002A54 arg_0           = dword ptr  8
.text$mn:00002A54
.text$mn:00002A54                 push    ebp
.text$mn:00002A55                 mov     ebp, esp
.text$mn:00002A57                 sub     esp, 0D0h
.text$mn:00002A5D                 push    ebx
.text$mn:00002A5E                 push    esi
.text$mn:00002A5F                 push    edi
.text$mn:00002A60                 push    ecx
.text$mn:00002A61                 lea     edi, [ebp+var_D0]
.text$mn:00002A67                 mov     ecx, 34h ; '4'
.text$mn:00002A6C                 mov     eax, 0CCCCCCCCh
.text$mn:00002A71                 rep stosd
.text$mn:00002A73                 pop     ecx
.text$mn:00002A74                 mov     [ebp+var_8], ecx
.text$mn:00002A77
.text$mn:00002A77 loc_2A77:                               ; CODE XREF: Vec<FileState *>::At(uint)+25j
.text$mn:00002A77                                         ; Vec<FileState *>::At(uint)+53j
.text$mn:00002A77                 xor     eax, eax
.text$mn:00002A79                 jnz     short loc_2A77
.text$mn:00002A7B                 mov     eax, [ebp+var_8]
.text$mn:00002A7E                 mov     ecx, [ebp+arg_0]
.text$mn:00002A81                 cmp     ecx, [eax]
.text$mn:00002A83                 jb      short loc_2A8E
.text$mn:00002A85                 mov     [ebp+var_CD], 1
.text$mn:00002A8C                 jmp     short loc_2A95
.text$mn:00002A8E ; ---------------------------------------------------------------------------
.text$mn:00002A8E
.text$mn:00002A8E loc_2A8E:                               ; CODE XREF: Vec<FileState *>::At(uint)+2Fj
.text$mn:00002A8E                 mov     [ebp+var_CD], 0
.text$mn:00002A95
.text$mn:00002A95 loc_2A95:                               ; CODE XREF: Vec<FileState *>::At(uint)+38j
.text$mn:00002A95                 movzx   edx, [ebp+var_CD]
.text$mn:00002A9C                 push    edx             ; bool
.text$mn:00002A9D                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00002AA2                 add     esp, 4
.text$mn:00002AA5                 xor     eax, eax
.text$mn:00002AA7                 jnz     short loc_2A77
.text$mn:00002AA9                 mov     eax, [ebp+var_8]
.text$mn:00002AAC                 mov     ecx, [eax+0Ch]
.text$mn:00002AAF                 mov     edx, [ebp+arg_0]
.text$mn:00002AB2                 lea     eax, [ecx+edx*4]
.text$mn:00002AB5                 pop     edi
.text$mn:00002AB6                 pop     esi
.text$mn:00002AB7                 pop     ebx
.text$mn:00002AB8                 add     esp, 0D0h
.text$mn:00002ABE                 cmp     ebp, esp
.text$mn:00002AC0                 call    __RTC_CheckEsp
.text$mn:00002AC5                 mov     esp, ebp
.text$mn:00002AC7                 pop     ebp
.text$mn:00002AC8                 retn    4
.text$mn:00002AC8 ?At@?$Vec@PAUFileState@@@@QBEAAPAUFileState@@I@Z endp
.text$mn:00002AC8
.text$mn:00002AC8 ; ---------------------------------------------------------------------------
.text$mn:00002ACB                 align 4
.text$mn:00002ACB _text$mn        ends
.text$mn:00002ACB
.text$mn:00002ACC ; ===========================================================================
.text$mn:00002ACC
.text$mn:00002ACC ; Segment type: Pure code
.text$mn:00002ACC ; Segment permissions: Read/Execute
.text$mn:00002ACC _text$mn        segment para public 'CODE' use32
.text$mn:00002ACC                 assume cs:_text$mn
.text$mn:00002ACC                 ;org 2ACCh
.text$mn:00002ACC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002ACC
.text$mn:00002ACC ; =============== S U B R O U T I N E =======================================
.text$mn:00002ACC
.text$mn:00002ACC ; Attributes: bp-based frame
.text$mn:00002ACC
.text$mn:00002ACC ; public: struct SessionData * & __thiscall Vec<struct SessionData *>::At(unsigned int)const
.text$mn:00002ACC                 public ?At@?$Vec@PAUSessionData@@@@QBEAAPAUSessionData@@I@Z
.text$mn:00002ACC ?At@?$Vec@PAUSessionData@@@@QBEAAPAUSessionData@@I@Z proc near
.text$mn:00002ACC                                         ; CODE XREF: Vec<SessionData *>::Iter::operator*(void)+2Fp
.text$mn:00002ACC
.text$mn:00002ACC var_D0          = byte ptr -0D0h
.text$mn:00002ACC var_CD          = byte ptr -0CDh
.text$mn:00002ACC var_8           = dword ptr -8
.text$mn:00002ACC arg_0           = dword ptr  8
.text$mn:00002ACC
.text$mn:00002ACC                 push    ebp
.text$mn:00002ACD                 mov     ebp, esp
.text$mn:00002ACF                 sub     esp, 0D0h
.text$mn:00002AD5                 push    ebx
.text$mn:00002AD6                 push    esi
.text$mn:00002AD7                 push    edi
.text$mn:00002AD8                 push    ecx
.text$mn:00002AD9                 lea     edi, [ebp+var_D0]
.text$mn:00002ADF                 mov     ecx, 34h ; '4'
.text$mn:00002AE4                 mov     eax, 0CCCCCCCCh
.text$mn:00002AE9                 rep stosd
.text$mn:00002AEB                 pop     ecx
.text$mn:00002AEC                 mov     [ebp+var_8], ecx
.text$mn:00002AEF
.text$mn:00002AEF loc_2AEF:                               ; CODE XREF: Vec<SessionData *>::At(uint)+25j
.text$mn:00002AEF                                         ; Vec<SessionData *>::At(uint)+53j
.text$mn:00002AEF                 xor     eax, eax
.text$mn:00002AF1                 jnz     short loc_2AEF
.text$mn:00002AF3                 mov     eax, [ebp+var_8]
.text$mn:00002AF6                 mov     ecx, [ebp+arg_0]
.text$mn:00002AF9                 cmp     ecx, [eax]
.text$mn:00002AFB                 jb      short loc_2B06
.text$mn:00002AFD                 mov     [ebp+var_CD], 1
.text$mn:00002B04                 jmp     short loc_2B0D
.text$mn:00002B06 ; ---------------------------------------------------------------------------
.text$mn:00002B06
.text$mn:00002B06 loc_2B06:                               ; CODE XREF: Vec<SessionData *>::At(uint)+2Fj
.text$mn:00002B06                 mov     [ebp+var_CD], 0
.text$mn:00002B0D
.text$mn:00002B0D loc_2B0D:                               ; CODE XREF: Vec<SessionData *>::At(uint)+38j
.text$mn:00002B0D                 movzx   edx, [ebp+var_CD]
.text$mn:00002B14                 push    edx             ; bool
.text$mn:00002B15                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00002B1A                 add     esp, 4
.text$mn:00002B1D                 xor     eax, eax
.text$mn:00002B1F                 jnz     short loc_2AEF
.text$mn:00002B21                 mov     eax, [ebp+var_8]
.text$mn:00002B24                 mov     ecx, [eax+0Ch]
.text$mn:00002B27                 mov     edx, [ebp+arg_0]
.text$mn:00002B2A                 lea     eax, [ecx+edx*4]
.text$mn:00002B2D                 pop     edi
.text$mn:00002B2E                 pop     esi
.text$mn:00002B2F                 pop     ebx
.text$mn:00002B30                 add     esp, 0D0h
.text$mn:00002B36                 cmp     ebp, esp
.text$mn:00002B38                 call    __RTC_CheckEsp
.text$mn:00002B3D                 mov     esp, ebp
.text$mn:00002B3F                 pop     ebp
.text$mn:00002B40                 retn    4
.text$mn:00002B40 ?At@?$Vec@PAUSessionData@@@@QBEAAPAUSessionData@@I@Z endp
.text$mn:00002B40
.text$mn:00002B40 ; ---------------------------------------------------------------------------
.text$mn:00002B43                 align 4
.text$mn:00002B43 _text$mn        ends
.text$mn:00002B43
.text$mn:00002B44 ; ===========================================================================
.text$mn:00002B44
.text$mn:00002B44 ; Segment type: Pure code
.text$mn:00002B44 ; Segment permissions: Read/Execute
.text$mn:00002B44 _text$mn        segment para public 'CODE' use32
.text$mn:00002B44                 assume cs:_text$mn
.text$mn:00002B44                 ;org 2B44h
.text$mn:00002B44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B44
.text$mn:00002B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B44
.text$mn:00002B44 ; Attributes: bp-based frame
.text$mn:00002B44
.text$mn:00002B44 ; public: struct TabState * & __thiscall Vec<struct TabState *>::At(unsigned int)const
.text$mn:00002B44                 public ?At@?$Vec@PAUTabState@@@@QBEAAPAUTabState@@I@Z
.text$mn:00002B44 ?At@?$Vec@PAUTabState@@@@QBEAAPAUTabState@@I@Z proc near
.text$mn:00002B44                                         ; CODE XREF: Vec<TabState *>::Iter::operator*(void)+2Fp
.text$mn:00002B44
.text$mn:00002B44 var_D0          = byte ptr -0D0h
.text$mn:00002B44 var_CD          = byte ptr -0CDh
.text$mn:00002B44 var_8           = dword ptr -8
.text$mn:00002B44 arg_0           = dword ptr  8
.text$mn:00002B44
.text$mn:00002B44                 push    ebp
.text$mn:00002B45                 mov     ebp, esp
.text$mn:00002B47                 sub     esp, 0D0h
.text$mn:00002B4D                 push    ebx
.text$mn:00002B4E                 push    esi
.text$mn:00002B4F                 push    edi
.text$mn:00002B50                 push    ecx
.text$mn:00002B51                 lea     edi, [ebp+var_D0]
.text$mn:00002B57                 mov     ecx, 34h ; '4'
.text$mn:00002B5C                 mov     eax, 0CCCCCCCCh
.text$mn:00002B61                 rep stosd
.text$mn:00002B63                 pop     ecx
.text$mn:00002B64                 mov     [ebp+var_8], ecx
.text$mn:00002B67
.text$mn:00002B67 loc_2B67:                               ; CODE XREF: Vec<TabState *>::At(uint)+25j
.text$mn:00002B67                                         ; Vec<TabState *>::At(uint)+53j
.text$mn:00002B67                 xor     eax, eax
.text$mn:00002B69                 jnz     short loc_2B67
.text$mn:00002B6B                 mov     eax, [ebp+var_8]
.text$mn:00002B6E                 mov     ecx, [ebp+arg_0]
.text$mn:00002B71                 cmp     ecx, [eax]
.text$mn:00002B73                 jb      short loc_2B7E
.text$mn:00002B75                 mov     [ebp+var_CD], 1
.text$mn:00002B7C                 jmp     short loc_2B85
.text$mn:00002B7E ; ---------------------------------------------------------------------------
.text$mn:00002B7E
.text$mn:00002B7E loc_2B7E:                               ; CODE XREF: Vec<TabState *>::At(uint)+2Fj
.text$mn:00002B7E                 mov     [ebp+var_CD], 0
.text$mn:00002B85
.text$mn:00002B85 loc_2B85:                               ; CODE XREF: Vec<TabState *>::At(uint)+38j
.text$mn:00002B85                 movzx   edx, [ebp+var_CD]
.text$mn:00002B8C                 push    edx             ; bool
.text$mn:00002B8D                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00002B92                 add     esp, 4
.text$mn:00002B95                 xor     eax, eax
.text$mn:00002B97                 jnz     short loc_2B67
.text$mn:00002B99                 mov     eax, [ebp+var_8]
.text$mn:00002B9C                 mov     ecx, [eax+0Ch]
.text$mn:00002B9F                 mov     edx, [ebp+arg_0]
.text$mn:00002BA2                 lea     eax, [ecx+edx*4]
.text$mn:00002BA5                 pop     edi
.text$mn:00002BA6                 pop     esi
.text$mn:00002BA7                 pop     ebx
.text$mn:00002BA8                 add     esp, 0D0h
.text$mn:00002BAE                 cmp     ebp, esp
.text$mn:00002BB0                 call    __RTC_CheckEsp
.text$mn:00002BB5                 mov     esp, ebp
.text$mn:00002BB7                 pop     ebp
.text$mn:00002BB8                 retn    4
.text$mn:00002BB8 ?At@?$Vec@PAUTabState@@@@QBEAAPAUTabState@@I@Z endp
.text$mn:00002BB8
.text$mn:00002BB8 ; ---------------------------------------------------------------------------
.text$mn:00002BBB                 align 4
.text$mn:00002BBB _text$mn        ends
.text$mn:00002BBB
.text$mn:00002BBC ; ===========================================================================
.text$mn:00002BBC
.text$mn:00002BBC ; Segment type: Pure code
.text$mn:00002BBC ; Segment permissions: Read/Execute
.text$mn:00002BBC _text$mn        segment para public 'CODE' use32
.text$mn:00002BBC                 assume cs:_text$mn
.text$mn:00002BBC                 ;org 2BBCh
.text$mn:00002BBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BBC
.text$mn:00002BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00002BBC
.text$mn:00002BBC ; Attributes: bp-based frame
.text$mn:00002BBC
.text$mn:00002BBC ; public: class WindowInfo * & __thiscall Vec<class WindowInfo *>::At(unsigned int)const
.text$mn:00002BBC                 public ?At@?$Vec@PAVWindowInfo@@@@QBEAAPAVWindowInfo@@I@Z
.text$mn:00002BBC ?At@?$Vec@PAVWindowInfo@@@@QBEAAPAVWindowInfo@@I@Z proc near
.text$mn:00002BBC                                         ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+A4p
.text$mn:00002BBC                                         ; FileExistenceChecker::HideMissingFiles(void)+C0p ...
.text$mn:00002BBC
.text$mn:00002BBC var_D0          = byte ptr -0D0h
.text$mn:00002BBC var_CD          = byte ptr -0CDh
.text$mn:00002BBC var_8           = dword ptr -8
.text$mn:00002BBC arg_0           = dword ptr  8
.text$mn:00002BBC
.text$mn:00002BBC                 push    ebp
.text$mn:00002BBD                 mov     ebp, esp
.text$mn:00002BBF                 sub     esp, 0D0h
.text$mn:00002BC5                 push    ebx
.text$mn:00002BC6                 push    esi
.text$mn:00002BC7                 push    edi
.text$mn:00002BC8                 push    ecx
.text$mn:00002BC9                 lea     edi, [ebp+var_D0]
.text$mn:00002BCF                 mov     ecx, 34h ; '4'
.text$mn:00002BD4                 mov     eax, 0CCCCCCCCh
.text$mn:00002BD9                 rep stosd
.text$mn:00002BDB                 pop     ecx
.text$mn:00002BDC                 mov     [ebp+var_8], ecx
.text$mn:00002BDF
.text$mn:00002BDF loc_2BDF:                               ; CODE XREF: Vec<WindowInfo *>::At(uint)+25j
.text$mn:00002BDF                                         ; Vec<WindowInfo *>::At(uint)+53j
.text$mn:00002BDF                 xor     eax, eax
.text$mn:00002BE1                 jnz     short loc_2BDF
.text$mn:00002BE3                 mov     eax, [ebp+var_8]
.text$mn:00002BE6                 mov     ecx, [ebp+arg_0]
.text$mn:00002BE9                 cmp     ecx, [eax]
.text$mn:00002BEB                 jb      short loc_2BF6
.text$mn:00002BED                 mov     [ebp+var_CD], 1
.text$mn:00002BF4                 jmp     short loc_2BFD
.text$mn:00002BF6 ; ---------------------------------------------------------------------------
.text$mn:00002BF6
.text$mn:00002BF6 loc_2BF6:                               ; CODE XREF: Vec<WindowInfo *>::At(uint)+2Fj
.text$mn:00002BF6                 mov     [ebp+var_CD], 0
.text$mn:00002BFD
.text$mn:00002BFD loc_2BFD:                               ; CODE XREF: Vec<WindowInfo *>::At(uint)+38j
.text$mn:00002BFD                 movzx   edx, [ebp+var_CD]
.text$mn:00002C04                 push    edx             ; bool
.text$mn:00002C05                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00002C0A                 add     esp, 4
.text$mn:00002C0D                 xor     eax, eax
.text$mn:00002C0F                 jnz     short loc_2BDF
.text$mn:00002C11                 mov     eax, [ebp+var_8]
.text$mn:00002C14                 mov     ecx, [eax+0Ch]
.text$mn:00002C17                 mov     edx, [ebp+arg_0]
.text$mn:00002C1A                 lea     eax, [ecx+edx*4]
.text$mn:00002C1D                 pop     edi
.text$mn:00002C1E                 pop     esi
.text$mn:00002C1F                 pop     ebx
.text$mn:00002C20                 add     esp, 0D0h
.text$mn:00002C26                 cmp     ebp, esp
.text$mn:00002C28                 call    __RTC_CheckEsp
.text$mn:00002C2D                 mov     esp, ebp
.text$mn:00002C2F                 pop     ebp
.text$mn:00002C30                 retn    4
.text$mn:00002C30 ?At@?$Vec@PAVWindowInfo@@@@QBEAAPAVWindowInfo@@I@Z endp
.text$mn:00002C30
.text$mn:00002C30 ; ---------------------------------------------------------------------------
.text$mn:00002C33                 align 4
.text$mn:00002C33 _text$mn        ends
.text$mn:00002C33
.text$mn:00002C34 ; ===========================================================================
.text$mn:00002C34
.text$mn:00002C34 ; Segment type: Pure code
.text$mn:00002C34 ; Segment permissions: Read/Execute
.text$mn:00002C34 _text$mn        segment para public 'CODE' use32
.text$mn:00002C34                 assume cs:_text$mn
.text$mn:00002C34                 ;org 2C34h
.text$mn:00002C34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C34
.text$mn:00002C34 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C34
.text$mn:00002C34 ; Attributes: bp-based frame
.text$mn:00002C34
.text$mn:00002C34 ; public: wchar_t * & __thiscall Vec<wchar_t *>::At(unsigned int)const
.text$mn:00002C34                 public ?At@?$Vec@PA_W@@QBEAAPA_WI@Z
.text$mn:00002C34 ?At@?$Vec@PA_W@@QBEAAPA_WI@Z proc near  ; CODE XREF: Vec<wchar_t *>::Iter::operator*(void)+2Fp
.text$mn:00002C34                                         ; WStrVec::Find(wchar_t const *,uint)+45p ...
.text$mn:00002C34
.text$mn:00002C34 var_D0          = byte ptr -0D0h
.text$mn:00002C34 var_CD          = byte ptr -0CDh
.text$mn:00002C34 var_8           = dword ptr -8
.text$mn:00002C34 arg_0           = dword ptr  8
.text$mn:00002C34
.text$mn:00002C34                 push    ebp
.text$mn:00002C35                 mov     ebp, esp
.text$mn:00002C37                 sub     esp, 0D0h
.text$mn:00002C3D                 push    ebx
.text$mn:00002C3E                 push    esi
.text$mn:00002C3F                 push    edi
.text$mn:00002C40                 push    ecx
.text$mn:00002C41                 lea     edi, [ebp+var_D0]
.text$mn:00002C47                 mov     ecx, 34h ; '4'
.text$mn:00002C4C                 mov     eax, 0CCCCCCCCh
.text$mn:00002C51                 rep stosd
.text$mn:00002C53                 pop     ecx
.text$mn:00002C54                 mov     [ebp+var_8], ecx
.text$mn:00002C57
.text$mn:00002C57 loc_2C57:                               ; CODE XREF: Vec<wchar_t *>::At(uint)+25j
.text$mn:00002C57                                         ; Vec<wchar_t *>::At(uint)+53j
.text$mn:00002C57                 xor     eax, eax
.text$mn:00002C59                 jnz     short loc_2C57
.text$mn:00002C5B                 mov     eax, [ebp+var_8]
.text$mn:00002C5E                 mov     ecx, [ebp+arg_0]
.text$mn:00002C61                 cmp     ecx, [eax]
.text$mn:00002C63                 jb      short loc_2C6E
.text$mn:00002C65                 mov     [ebp+var_CD], 1
.text$mn:00002C6C                 jmp     short loc_2C75
.text$mn:00002C6E ; ---------------------------------------------------------------------------
.text$mn:00002C6E
.text$mn:00002C6E loc_2C6E:                               ; CODE XREF: Vec<wchar_t *>::At(uint)+2Fj
.text$mn:00002C6E                 mov     [ebp+var_CD], 0
.text$mn:00002C75
.text$mn:00002C75 loc_2C75:                               ; CODE XREF: Vec<wchar_t *>::At(uint)+38j
.text$mn:00002C75                 movzx   edx, [ebp+var_CD]
.text$mn:00002C7C                 push    edx             ; bool
.text$mn:00002C7D                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00002C82                 add     esp, 4
.text$mn:00002C85                 xor     eax, eax
.text$mn:00002C87                 jnz     short loc_2C57
.text$mn:00002C89                 mov     eax, [ebp+var_8]
.text$mn:00002C8C                 mov     ecx, [eax+0Ch]
.text$mn:00002C8F                 mov     edx, [ebp+arg_0]
.text$mn:00002C92                 lea     eax, [ecx+edx*4]
.text$mn:00002C95                 pop     edi
.text$mn:00002C96                 pop     esi
.text$mn:00002C97                 pop     ebx
.text$mn:00002C98                 add     esp, 0D0h
.text$mn:00002C9E                 cmp     ebp, esp
.text$mn:00002CA0                 call    __RTC_CheckEsp
.text$mn:00002CA5                 mov     esp, ebp
.text$mn:00002CA7                 pop     ebp
.text$mn:00002CA8                 retn    4
.text$mn:00002CA8 ?At@?$Vec@PA_W@@QBEAAPA_WI@Z endp
.text$mn:00002CA8
.text$mn:00002CA8 ; ---------------------------------------------------------------------------
.text$mn:00002CAB                 align 4
.text$mn:00002CAB _text$mn        ends
.text$mn:00002CAB
.text$mn:00002CAC ; ===========================================================================
.text$mn:00002CAC
.text$mn:00002CAC ; Segment type: Pure code
.text$mn:00002CAC ; Segment permissions: Read/Execute
.text$mn:00002CAC _text$mn        segment para public 'CODE' use32
.text$mn:00002CAC                 assume cs:_text$mn
.text$mn:00002CAC                 ;org 2CACh
.text$mn:00002CAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CAC
.text$mn:00002CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00002CAC
.text$mn:00002CAC ; Attributes: bp-based frame
.text$mn:00002CAC
.text$mn:00002CAC ; bool __thiscall WStrVec::Contains(WStrVec *this, const wchar_t *)
.text$mn:00002CAC                 public ?Contains@WStrVec@@QBE_NPB_W@Z
.text$mn:00002CAC ?Contains@WStrVec@@QBE_NPB_W@Z proc near
.text$mn:00002CAC                                         ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+F3p
.text$mn:00002CAC
.text$mn:00002CAC var_D0          = dword ptr -0D0h
.text$mn:00002CAC var_8           = dword ptr -8
.text$mn:00002CAC arg_0           = dword ptr  8
.text$mn:00002CAC
.text$mn:00002CAC                 push    ebp
.text$mn:00002CAD                 mov     ebp, esp
.text$mn:00002CAF                 sub     esp, 0D0h
.text$mn:00002CB5                 push    ebx
.text$mn:00002CB6                 push    esi
.text$mn:00002CB7                 push    edi
.text$mn:00002CB8                 push    ecx
.text$mn:00002CB9                 lea     edi, [ebp+var_D0]
.text$mn:00002CBF                 mov     ecx, 34h ; '4'
.text$mn:00002CC4                 mov     eax, 0CCCCCCCCh
.text$mn:00002CC9                 rep stosd
.text$mn:00002CCB                 pop     ecx
.text$mn:00002CCC                 mov     [ebp+var_8], ecx
.text$mn:00002CCF                 push    0               ; unsigned int
.text$mn:00002CD1                 mov     eax, [ebp+arg_0]
.text$mn:00002CD4                 push    eax             ; wchar_t *
.text$mn:00002CD5                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002CD8                 call    ?Find@WStrVec@@QBEHPB_WI@Z ; WStrVec::Find(wchar_t const *,uint)
.text$mn:00002CDD                 cmp     eax, 0FFFFFFFFh
.text$mn:00002CE0                 jz      short loc_2CEE
.text$mn:00002CE2                 mov     [ebp+var_D0], 1
.text$mn:00002CEC                 jmp     short loc_2CF8
.text$mn:00002CEE ; ---------------------------------------------------------------------------
.text$mn:00002CEE
.text$mn:00002CEE loc_2CEE:                               ; CODE XREF: WStrVec::Contains(wchar_t const *)+34j
.text$mn:00002CEE                 mov     [ebp+var_D0], 0
.text$mn:00002CF8
.text$mn:00002CF8 loc_2CF8:                               ; CODE XREF: WStrVec::Contains(wchar_t const *)+40j
.text$mn:00002CF8                 mov     al, byte ptr [ebp+var_D0]
.text$mn:00002CFE                 pop     edi
.text$mn:00002CFF                 pop     esi
.text$mn:00002D00                 pop     ebx
.text$mn:00002D01                 add     esp, 0D0h
.text$mn:00002D07                 cmp     ebp, esp
.text$mn:00002D09                 call    __RTC_CheckEsp
.text$mn:00002D0E                 mov     esp, ebp
.text$mn:00002D10                 pop     ebp
.text$mn:00002D11                 retn    4
.text$mn:00002D11 ?Contains@WStrVec@@QBE_NPB_W@Z endp
.text$mn:00002D11
.text$mn:00002D11 _text$mn        ends
.text$mn:00002D11
.text$mn:00002D14 ; ===========================================================================
.text$mn:00002D14
.text$mn:00002D14 ; Segment type: Pure code
.text$mn:00002D14 ; Segment permissions: Read/Execute
.text$mn:00002D14 _text$mn        segment para public 'CODE' use32
.text$mn:00002D14                 assume cs:_text$mn
.text$mn:00002D14                 ;org 2D14h
.text$mn:00002D14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D14
.text$mn:00002D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D14
.text$mn:00002D14 ; Attributes: bp-based frame
.text$mn:00002D14
.text$mn:00002D14 ; public: unsigned int __thiscall Vec<struct FileState *>::Count(void)const
.text$mn:00002D14                 public ?Count@?$Vec@PAUFileState@@@@QBEIXZ
.text$mn:00002D14 ?Count@?$Vec@PAUFileState@@@@QBEIXZ proc near
.text$mn:00002D14                                         ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+C6p
.text$mn:00002D14
.text$mn:00002D14 var_CC          = byte ptr -0CCh
.text$mn:00002D14 var_8           = dword ptr -8
.text$mn:00002D14
.text$mn:00002D14                 push    ebp
.text$mn:00002D15                 mov     ebp, esp
.text$mn:00002D17                 sub     esp, 0CCh
.text$mn:00002D1D                 push    ebx
.text$mn:00002D1E                 push    esi
.text$mn:00002D1F                 push    edi
.text$mn:00002D20                 push    ecx
.text$mn:00002D21                 lea     edi, [ebp+var_CC]
.text$mn:00002D27                 mov     ecx, 33h ; '3'
.text$mn:00002D2C                 mov     eax, 0CCCCCCCCh
.text$mn:00002D31                 rep stosd
.text$mn:00002D33                 pop     ecx
.text$mn:00002D34                 mov     [ebp+var_8], ecx
.text$mn:00002D37                 mov     eax, [ebp+var_8]
.text$mn:00002D3A                 mov     eax, [eax]
.text$mn:00002D3C                 pop     edi
.text$mn:00002D3D                 pop     esi
.text$mn:00002D3E                 pop     ebx
.text$mn:00002D3F                 mov     esp, ebp
.text$mn:00002D41                 pop     ebp
.text$mn:00002D42                 retn
.text$mn:00002D42 ?Count@?$Vec@PAUFileState@@@@QBEIXZ endp
.text$mn:00002D42
.text$mn:00002D42 ; ---------------------------------------------------------------------------
.text$mn:00002D43                 align 4
.text$mn:00002D43 _text$mn        ends
.text$mn:00002D43
.text$mn:00002D44 ; ===========================================================================
.text$mn:00002D44
.text$mn:00002D44 ; Segment type: Pure code
.text$mn:00002D44 ; Segment permissions: Read/Execute
.text$mn:00002D44 _text$mn        segment para public 'CODE' use32
.text$mn:00002D44                 assume cs:_text$mn
.text$mn:00002D44                 ;org 2D44h
.text$mn:00002D44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D44
.text$mn:00002D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D44
.text$mn:00002D44 ; Attributes: bp-based frame
.text$mn:00002D44
.text$mn:00002D44 ; public: unsigned int __thiscall Vec<struct SessionData *>::Count(void)const
.text$mn:00002D44                 public ?Count@?$Vec@PAUSessionData@@@@QBEIXZ
.text$mn:00002D44 ?Count@?$Vec@PAUSessionData@@@@QBEIXZ proc near
.text$mn:00002D44                                         ; CODE XREF: WinMain(x,x,x,x)+52Ep
.text$mn:00002D44
.text$mn:00002D44 var_CC          = byte ptr -0CCh
.text$mn:00002D44 var_8           = dword ptr -8
.text$mn:00002D44
.text$mn:00002D44                 push    ebp
.text$mn:00002D45                 mov     ebp, esp
.text$mn:00002D47                 sub     esp, 0CCh
.text$mn:00002D4D                 push    ebx
.text$mn:00002D4E                 push    esi
.text$mn:00002D4F                 push    edi
.text$mn:00002D50                 push    ecx
.text$mn:00002D51                 lea     edi, [ebp+var_CC]
.text$mn:00002D57                 mov     ecx, 33h ; '3'
.text$mn:00002D5C                 mov     eax, 0CCCCCCCCh
.text$mn:00002D61                 rep stosd
.text$mn:00002D63                 pop     ecx
.text$mn:00002D64                 mov     [ebp+var_8], ecx
.text$mn:00002D67                 mov     eax, [ebp+var_8]
.text$mn:00002D6A                 mov     eax, [eax]
.text$mn:00002D6C                 pop     edi
.text$mn:00002D6D                 pop     esi
.text$mn:00002D6E                 pop     ebx
.text$mn:00002D6F                 mov     esp, ebp
.text$mn:00002D71                 pop     ebp
.text$mn:00002D72                 retn
.text$mn:00002D72 ?Count@?$Vec@PAUSessionData@@@@QBEIXZ endp
.text$mn:00002D72
.text$mn:00002D72 ; ---------------------------------------------------------------------------
.text$mn:00002D73                 align 4
.text$mn:00002D73 _text$mn        ends
.text$mn:00002D73
.text$mn:00002D74 ; ===========================================================================
.text$mn:00002D74
.text$mn:00002D74 ; Segment type: Pure code
.text$mn:00002D74 ; Segment permissions: Read/Execute
.text$mn:00002D74 _text$mn        segment para public 'CODE' use32
.text$mn:00002D74                 assume cs:_text$mn
.text$mn:00002D74                 ;org 2D74h
.text$mn:00002D74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D74
.text$mn:00002D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D74
.text$mn:00002D74 ; Attributes: bp-based frame
.text$mn:00002D74
.text$mn:00002D74 ; public: unsigned int __thiscall Vec<class WindowInfo *>::Count(void)const
.text$mn:00002D74                 public ?Count@?$Vec@PAVWindowInfo@@@@QBEIXZ
.text$mn:00002D74 ?Count@?$Vec@PAVWindowInfo@@@@QBEIXZ proc near
.text$mn:00002D74                                         ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+94p
.text$mn:00002D74                                         ; WinMain(x,x,x,x)+AA2p
.text$mn:00002D74
.text$mn:00002D74 var_CC          = byte ptr -0CCh
.text$mn:00002D74 var_8           = dword ptr -8
.text$mn:00002D74
.text$mn:00002D74                 push    ebp
.text$mn:00002D75                 mov     ebp, esp
.text$mn:00002D77                 sub     esp, 0CCh
.text$mn:00002D7D                 push    ebx
.text$mn:00002D7E                 push    esi
.text$mn:00002D7F                 push    edi
.text$mn:00002D80                 push    ecx
.text$mn:00002D81                 lea     edi, [ebp+var_CC]
.text$mn:00002D87                 mov     ecx, 33h ; '3'
.text$mn:00002D8C                 mov     eax, 0CCCCCCCCh
.text$mn:00002D91                 rep stosd
.text$mn:00002D93                 pop     ecx
.text$mn:00002D94                 mov     [ebp+var_8], ecx
.text$mn:00002D97                 mov     eax, [ebp+var_8]
.text$mn:00002D9A                 mov     eax, [eax]
.text$mn:00002D9C                 pop     edi
.text$mn:00002D9D                 pop     esi
.text$mn:00002D9E                 pop     ebx
.text$mn:00002D9F                 mov     esp, ebp
.text$mn:00002DA1                 pop     ebp
.text$mn:00002DA2                 retn
.text$mn:00002DA2 ?Count@?$Vec@PAVWindowInfo@@@@QBEIXZ endp
.text$mn:00002DA2
.text$mn:00002DA2 ; ---------------------------------------------------------------------------
.text$mn:00002DA3                 align 4
.text$mn:00002DA3 _text$mn        ends
.text$mn:00002DA3
.text$mn:00002DA4 ; ===========================================================================
.text$mn:00002DA4
.text$mn:00002DA4 ; Segment type: Pure code
.text$mn:00002DA4 ; Segment permissions: Read/Execute
.text$mn:00002DA4 _text$mn        segment para public 'CODE' use32
.text$mn:00002DA4                 assume cs:_text$mn
.text$mn:00002DA4                 ;org 2DA4h
.text$mn:00002DA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DA4
.text$mn:00002DA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DA4
.text$mn:00002DA4 ; Attributes: bp-based frame
.text$mn:00002DA4
.text$mn:00002DA4 ; public: unsigned int __thiscall Vec<wchar_t *>::Count(void)const
.text$mn:00002DA4                 public ?Count@?$Vec@PA_W@@QBEIXZ
.text$mn:00002DA4 ?Count@?$Vec@PA_W@@QBEIXZ proc near     ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+86p
.text$mn:00002DA4                                         ; FileExistenceChecker::Run(void)+45p ...
.text$mn:00002DA4
.text$mn:00002DA4 var_CC          = byte ptr -0CCh
.text$mn:00002DA4 var_8           = dword ptr -8
.text$mn:00002DA4
.text$mn:00002DA4                 push    ebp
.text$mn:00002DA5                 mov     ebp, esp
.text$mn:00002DA7                 sub     esp, 0CCh
.text$mn:00002DAD                 push    ebx
.text$mn:00002DAE                 push    esi
.text$mn:00002DAF                 push    edi
.text$mn:00002DB0                 push    ecx
.text$mn:00002DB1                 lea     edi, [ebp+var_CC]
.text$mn:00002DB7                 mov     ecx, 33h ; '3'
.text$mn:00002DBC                 mov     eax, 0CCCCCCCCh
.text$mn:00002DC1                 rep stosd
.text$mn:00002DC3                 pop     ecx
.text$mn:00002DC4                 mov     [ebp+var_8], ecx
.text$mn:00002DC7                 mov     eax, [ebp+var_8]
.text$mn:00002DCA                 mov     eax, [eax]
.text$mn:00002DCC                 pop     edi
.text$mn:00002DCD                 pop     esi
.text$mn:00002DCE                 pop     ebx
.text$mn:00002DCF                 mov     esp, ebp
.text$mn:00002DD1                 pop     ebp
.text$mn:00002DD2                 retn
.text$mn:00002DD2 ?Count@?$Vec@PA_W@@QBEIXZ endp
.text$mn:00002DD2
.text$mn:00002DD2 ; ---------------------------------------------------------------------------
.text$mn:00002DD3                 align 4
.text$mn:00002DD3 _text$mn        ends
.text$mn:00002DD3
.text$mn:00002DD4 ; ===========================================================================
.text$mn:00002DD4
.text$mn:00002DD4 ; Segment type: Pure code
.text$mn:00002DD4 ; Segment permissions: Read/Execute
.text$mn:00002DD4 _text$mn        segment para public 'CODE' use32
.text$mn:00002DD4                 assume cs:_text$mn
.text$mn:00002DD4                 ;org 2DD4h
.text$mn:00002DD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DD4
.text$mn:00002DD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DD4
.text$mn:00002DD4 ; Attributes: bp-based frame
.text$mn:00002DD4
.text$mn:00002DD4 ; void __cdecl CrashIfFunc(bool)
.text$mn:00002DD4                 public ?CrashIfFunc@@YAX_N@Z
.text$mn:00002DD4 ?CrashIfFunc@@YAX_N@Z proc near         ; CODE XREF: _lambda_b6f3cb1c717d8c8a816f87295491882e_::operator()(void)+35p
.text$mn:00002DD4                                         ; Vec<FileState *>::At(uint)+49p ...
.text$mn:00002DD4
.text$mn:00002DD4 var_C0          = byte ptr -0C0h
.text$mn:00002DD4 arg_0           = byte ptr  8
.text$mn:00002DD4
.text$mn:00002DD4                 push    ebp
.text$mn:00002DD5                 mov     ebp, esp
.text$mn:00002DD7                 sub     esp, 0C0h
.text$mn:00002DDD                 push    ebx
.text$mn:00002DDE                 push    esi
.text$mn:00002DDF                 push    edi
.text$mn:00002DE0                 lea     edi, [ebp+var_C0]
.text$mn:00002DE6                 mov     ecx, 30h ; '0'
.text$mn:00002DEB                 mov     eax, 0CCCCCCCCh
.text$mn:00002DF0                 rep stosd
.text$mn:00002DF2                 movzx   eax, [ebp+arg_0]
.text$mn:00002DF6                 test    eax, eax
.text$mn:00002DF8                 jz      short loc_2DFF
.text$mn:00002DFA                 call    ?CrashMe@@YAXXZ ; CrashMe(void)
.text$mn:00002DFF
.text$mn:00002DFF loc_2DFF:                               ; CODE XREF: CrashIfFunc(bool)+24j
.text$mn:00002DFF                 pop     edi
.text$mn:00002E00                 pop     esi
.text$mn:00002E01                 pop     ebx
.text$mn:00002E02                 add     esp, 0C0h
.text$mn:00002E08                 cmp     ebp, esp
.text$mn:00002E0A                 call    __RTC_CheckEsp
.text$mn:00002E0F                 mov     esp, ebp
.text$mn:00002E11                 pop     ebp
.text$mn:00002E12                 retn
.text$mn:00002E12 ?CrashIfFunc@@YAX_N@Z endp
.text$mn:00002E12
.text$mn:00002E12 ; ---------------------------------------------------------------------------
.text$mn:00002E13                 align 4
.text$mn:00002E13 _text$mn        ends
.text$mn:00002E13
.text$mn:00002E14 ; ===========================================================================
.text$mn:00002E14
.text$mn:00002E14 ; Segment type: Pure code
.text$mn:00002E14 ; Segment permissions: Read/Execute
.text$mn:00002E14 _text$mn        segment para public 'CODE' use32
.text$mn:00002E14                 assume cs:_text$mn
.text$mn:00002E14                 ;org 2E14h
.text$mn:00002E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E14
.text$mn:00002E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E14
.text$mn:00002E14 ; Attributes: bp-based frame
.text$mn:00002E14
.text$mn:00002E14 ; void __cdecl CrashMe()
.text$mn:00002E14                 public ?CrashMe@@YAXXZ
.text$mn:00002E14 ?CrashMe@@YAXXZ proc near               ; CODE XREF: CrashIfFunc(bool)+26p
.text$mn:00002E14                                         ; Vec<int>::EnsureCapCrash(uint)+3Ep ...
.text$mn:00002E14
.text$mn:00002E14 var_CC          = byte ptr -0CCh
.text$mn:00002E14 var_8           = dword ptr -8
.text$mn:00002E14
.text$mn:00002E14                 push    ebp
.text$mn:00002E15                 mov     ebp, esp
.text$mn:00002E17                 sub     esp, 0CCh
.text$mn:00002E1D                 push    ebx
.text$mn:00002E1E                 push    esi
.text$mn:00002E1F                 push    edi
.text$mn:00002E20                 lea     edi, [ebp+var_CC]
.text$mn:00002E26                 mov     ecx, 33h ; '3'
.text$mn:00002E2B                 mov     eax, 0CCCCCCCCh
.text$mn:00002E30                 rep stosd
.text$mn:00002E32                 mov     [ebp+var_8], 0
.text$mn:00002E39                 mov     eax, [ebp+var_8]
.text$mn:00002E3C                 mov     byte ptr [eax], 0
.text$mn:00002E3F                 pop     edi
.text$mn:00002E40                 pop     esi
.text$mn:00002E41                 pop     ebx
.text$mn:00002E42                 mov     esp, ebp
.text$mn:00002E44                 pop     ebp
.text$mn:00002E45                 retn
.text$mn:00002E45 ?CrashMe@@YAXXZ endp
.text$mn:00002E45
.text$mn:00002E45 ; ---------------------------------------------------------------------------
.text$mn:00002E46                 align 4
.text$mn:00002E46 _text$mn        ends
.text$mn:00002E46
.text$mn:00002E48 ; ===========================================================================
.text$mn:00002E48
.text$mn:00002E48 ; Segment type: Pure code
.text$mn:00002E48 ; Segment permissions: Read/Execute
.text$mn:00002E48 _text$mn        segment para public 'CODE' use32
.text$mn:00002E48                 assume cs:_text$mn
.text$mn:00002E48                 ;org 2E48h
.text$mn:00002E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E48
.text$mn:00002E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E48
.text$mn:00002E48 ; Attributes: bp-based frame
.text$mn:00002E48
.text$mn:00002E48 ; protected: void __thiscall Vec<int>::EnsureCapCrash(unsigned int)
.text$mn:00002E48                 public ?EnsureCapCrash@?$Vec@H@@IAEXI@Z
.text$mn:00002E48 ?EnsureCapCrash@?$Vec@H@@IAEXI@Z proc near
.text$mn:00002E48                                         ; CODE XREF: Vec<int>::operator=(Vec<int> const &)+35p
.text$mn:00002E48
.text$mn:00002E48 var_D8          = byte ptr -0D8h
.text$mn:00002E48 var_11          = byte ptr -11h
.text$mn:00002E48 var_8           = dword ptr -8
.text$mn:00002E48 arg_0           = dword ptr  8
.text$mn:00002E48
.text$mn:00002E48                 push    ebp
.text$mn:00002E49                 mov     ebp, esp
.text$mn:00002E4B                 sub     esp, 0D8h
.text$mn:00002E51                 push    ebx
.text$mn:00002E52                 push    esi
.text$mn:00002E53                 push    edi
.text$mn:00002E54                 push    ecx
.text$mn:00002E55                 lea     edi, [ebp+var_D8]
.text$mn:00002E5B                 mov     ecx, 36h ; '6'
.text$mn:00002E60                 mov     eax, 0CCCCCCCCh
.text$mn:00002E65                 rep stosd
.text$mn:00002E67                 pop     ecx
.text$mn:00002E68                 mov     [ebp+var_8], ecx
.text$mn:00002E6B                 mov     eax, [ebp+arg_0]
.text$mn:00002E6E                 push    eax
.text$mn:00002E6F                 mov     ecx, [ebp+var_8]
.text$mn:00002E72                 call    ?EnsureCapTry@?$Vec@H@@IAE_NI@Z ; Vec<int>::EnsureCapTry(uint)
.text$mn:00002E77                 mov     [ebp+var_11], al
.text$mn:00002E7A
.text$mn:00002E7A loc_2E7A:                               ; CODE XREF: Vec<int>::EnsureCapCrash(uint)+34j
.text$mn:00002E7A                                         ; Vec<int>::EnsureCapCrash(uint)+45j
.text$mn:00002E7A                 xor     eax, eax
.text$mn:00002E7C                 jnz     short loc_2E7A
.text$mn:00002E7E                 movzx   eax, [ebp+var_11]
.text$mn:00002E82                 test    eax, eax
.text$mn:00002E84                 jnz     short loc_2E8B
.text$mn:00002E86                 call    ?CrashMe@@YAXXZ ; CrashMe(void)
.text$mn:00002E8B
.text$mn:00002E8B loc_2E8B:                               ; CODE XREF: Vec<int>::EnsureCapCrash(uint)+3Cj
.text$mn:00002E8B                 xor     eax, eax
.text$mn:00002E8D                 jnz     short loc_2E7A
.text$mn:00002E8F                 pop     edi
.text$mn:00002E90                 pop     esi
.text$mn:00002E91                 pop     ebx
.text$mn:00002E92                 add     esp, 0D8h
.text$mn:00002E98                 cmp     ebp, esp
.text$mn:00002E9A                 call    __RTC_CheckEsp
.text$mn:00002E9F                 mov     esp, ebp
.text$mn:00002EA1                 pop     ebp
.text$mn:00002EA2                 retn    4
.text$mn:00002EA2 ?EnsureCapCrash@?$Vec@H@@IAEXI@Z endp
.text$mn:00002EA2
.text$mn:00002EA2 ; ---------------------------------------------------------------------------
.text$mn:00002EA5                 align 4
.text$mn:00002EA5 _text$mn        ends
.text$mn:00002EA5
.text$mn:00002EA8 ; ===========================================================================
.text$mn:00002EA8
.text$mn:00002EA8 ; Segment type: Pure code
.text$mn:00002EA8 ; Segment permissions: Read/Execute
.text$mn:00002EA8 _text$mn        segment para public 'CODE' use32
.text$mn:00002EA8                 assume cs:_text$mn
.text$mn:00002EA8                 ;org 2EA8h
.text$mn:00002EA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EA8
.text$mn:00002EA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EA8
.text$mn:00002EA8 ; Attributes: bp-based frame
.text$mn:00002EA8
.text$mn:00002EA8 ; protected: void __thiscall Vec<wchar_t *>::EnsureCapCrash(unsigned int)
.text$mn:00002EA8                 public ?EnsureCapCrash@?$Vec@PA_W@@IAEXI@Z
.text$mn:00002EA8 ?EnsureCapCrash@?$Vec@PA_W@@IAEXI@Z proc near
.text$mn:00002EA8                                         ; CODE XREF: Vec<wchar_t *>::MakeSpaceAt(uint,uint,bool)+4Ap
.text$mn:00002EA8
.text$mn:00002EA8 var_D8          = byte ptr -0D8h
.text$mn:00002EA8 var_11          = byte ptr -11h
.text$mn:00002EA8 var_8           = dword ptr -8
.text$mn:00002EA8 arg_0           = dword ptr  8
.text$mn:00002EA8
.text$mn:00002EA8                 push    ebp
.text$mn:00002EA9                 mov     ebp, esp
.text$mn:00002EAB                 sub     esp, 0D8h
.text$mn:00002EB1                 push    ebx
.text$mn:00002EB2                 push    esi
.text$mn:00002EB3                 push    edi
.text$mn:00002EB4                 push    ecx
.text$mn:00002EB5                 lea     edi, [ebp+var_D8]
.text$mn:00002EBB                 mov     ecx, 36h ; '6'
.text$mn:00002EC0                 mov     eax, 0CCCCCCCCh
.text$mn:00002EC5                 rep stosd
.text$mn:00002EC7                 pop     ecx
.text$mn:00002EC8                 mov     [ebp+var_8], ecx
.text$mn:00002ECB                 mov     eax, [ebp+arg_0]
.text$mn:00002ECE                 push    eax
.text$mn:00002ECF                 mov     ecx, [ebp+var_8]
.text$mn:00002ED2                 call    ?EnsureCapTry@?$Vec@PA_W@@IAE_NI@Z ; Vec<wchar_t *>::EnsureCapTry(uint)
.text$mn:00002ED7                 mov     [ebp+var_11], al
.text$mn:00002EDA
.text$mn:00002EDA loc_2EDA:                               ; CODE XREF: Vec<wchar_t *>::EnsureCapCrash(uint)+34j
.text$mn:00002EDA                                         ; Vec<wchar_t *>::EnsureCapCrash(uint)+45j
.text$mn:00002EDA                 xor     eax, eax
.text$mn:00002EDC                 jnz     short loc_2EDA
.text$mn:00002EDE                 movzx   eax, [ebp+var_11]
.text$mn:00002EE2                 test    eax, eax
.text$mn:00002EE4                 jnz     short loc_2EEB
.text$mn:00002EE6                 call    ?CrashMe@@YAXXZ ; CrashMe(void)
.text$mn:00002EEB
.text$mn:00002EEB loc_2EEB:                               ; CODE XREF: Vec<wchar_t *>::EnsureCapCrash(uint)+3Cj
.text$mn:00002EEB                 xor     eax, eax
.text$mn:00002EED                 jnz     short loc_2EDA
.text$mn:00002EEF                 pop     edi
.text$mn:00002EF0                 pop     esi
.text$mn:00002EF1                 pop     ebx
.text$mn:00002EF2                 add     esp, 0D8h
.text$mn:00002EF8                 cmp     ebp, esp
.text$mn:00002EFA                 call    __RTC_CheckEsp
.text$mn:00002EFF                 mov     esp, ebp
.text$mn:00002F01                 pop     ebp
.text$mn:00002F02                 retn    4
.text$mn:00002F02 ?EnsureCapCrash@?$Vec@PA_W@@IAEXI@Z endp
.text$mn:00002F02
.text$mn:00002F02 ; ---------------------------------------------------------------------------
.text$mn:00002F05                 align 4
.text$mn:00002F05 _text$mn        ends
.text$mn:00002F05
.text$mn:00002F08 ; ===========================================================================
.text$mn:00002F08
.text$mn:00002F08 ; Segment type: Pure code
.text$mn:00002F08 ; Segment permissions: Read/Execute
.text$mn:00002F08 _text$mn        segment para public 'CODE' use32
.text$mn:00002F08                 assume cs:_text$mn
.text$mn:00002F08                 ;org 2F08h
.text$mn:00002F08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F08
.text$mn:00002F08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F08
.text$mn:00002F08 ; Attributes: bp-based frame
.text$mn:00002F08
.text$mn:00002F08 ; protected: void __thiscall Vec<wchar_t>::EnsureCapCrash(unsigned int)
.text$mn:00002F08                 public ?EnsureCapCrash@?$Vec@_W@@IAEXI@Z
.text$mn:00002F08 ?EnsureCapCrash@?$Vec@_W@@IAEXI@Z proc near
.text$mn:00002F08                                         ; CODE XREF: Vec<wchar_t>::MakeSpaceAt(uint,uint,bool)+4Ap
.text$mn:00002F08
.text$mn:00002F08 var_D8          = byte ptr -0D8h
.text$mn:00002F08 var_11          = byte ptr -11h
.text$mn:00002F08 var_8           = dword ptr -8
.text$mn:00002F08 arg_0           = dword ptr  8
.text$mn:00002F08
.text$mn:00002F08                 push    ebp
.text$mn:00002F09                 mov     ebp, esp
.text$mn:00002F0B                 sub     esp, 0D8h
.text$mn:00002F11                 push    ebx
.text$mn:00002F12                 push    esi
.text$mn:00002F13                 push    edi
.text$mn:00002F14                 push    ecx
.text$mn:00002F15                 lea     edi, [ebp+var_D8]
.text$mn:00002F1B                 mov     ecx, 36h ; '6'
.text$mn:00002F20                 mov     eax, 0CCCCCCCCh
.text$mn:00002F25                 rep stosd
.text$mn:00002F27                 pop     ecx
.text$mn:00002F28                 mov     [ebp+var_8], ecx
.text$mn:00002F2B                 mov     eax, [ebp+arg_0]
.text$mn:00002F2E                 push    eax
.text$mn:00002F2F                 mov     ecx, [ebp+var_8]
.text$mn:00002F32                 call    ?EnsureCapTry@?$Vec@_W@@IAE_NI@Z ; Vec<wchar_t>::EnsureCapTry(uint)
.text$mn:00002F37                 mov     [ebp+var_11], al
.text$mn:00002F3A
.text$mn:00002F3A loc_2F3A:                               ; CODE XREF: Vec<wchar_t>::EnsureCapCrash(uint)+34j
.text$mn:00002F3A                                         ; Vec<wchar_t>::EnsureCapCrash(uint)+45j
.text$mn:00002F3A                 xor     eax, eax
.text$mn:00002F3C                 jnz     short loc_2F3A
.text$mn:00002F3E                 movzx   eax, [ebp+var_11]
.text$mn:00002F42                 test    eax, eax
.text$mn:00002F44                 jnz     short loc_2F4B
.text$mn:00002F46                 call    ?CrashMe@@YAXXZ ; CrashMe(void)
.text$mn:00002F4B
.text$mn:00002F4B loc_2F4B:                               ; CODE XREF: Vec<wchar_t>::EnsureCapCrash(uint)+3Cj
.text$mn:00002F4B                 xor     eax, eax
.text$mn:00002F4D                 jnz     short loc_2F3A
.text$mn:00002F4F                 pop     edi
.text$mn:00002F50                 pop     esi
.text$mn:00002F51                 pop     ebx
.text$mn:00002F52                 add     esp, 0D8h
.text$mn:00002F58                 cmp     ebp, esp
.text$mn:00002F5A                 call    __RTC_CheckEsp
.text$mn:00002F5F                 mov     esp, ebp
.text$mn:00002F61                 pop     ebp
.text$mn:00002F62                 retn    4
.text$mn:00002F62 ?EnsureCapCrash@?$Vec@_W@@IAEXI@Z endp
.text$mn:00002F62
.text$mn:00002F62 ; ---------------------------------------------------------------------------
.text$mn:00002F65                 align 4
.text$mn:00002F65 _text$mn        ends
.text$mn:00002F65
.text$mn:00002F68 ; ===========================================================================
.text$mn:00002F68
.text$mn:00002F68 ; Segment type: Pure code
.text$mn:00002F68 ; Segment permissions: Read/Execute
.text$mn:00002F68 _text$mn        segment para public 'CODE' use32
.text$mn:00002F68                 assume cs:_text$mn
.text$mn:00002F68                 ;org 2F68h
.text$mn:00002F68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F68
.text$mn:00002F68 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F68
.text$mn:00002F68 ; Attributes: bp-based frame
.text$mn:00002F68
.text$mn:00002F68 ; protected: bool __thiscall Vec<int>::EnsureCapTry(unsigned int)
.text$mn:00002F68                 public ?EnsureCapTry@?$Vec@H@@IAE_NI@Z
.text$mn:00002F68 ?EnsureCapTry@?$Vec@H@@IAE_NI@Z proc near
.text$mn:00002F68                                         ; CODE XREF: Vec<int>::EnsureCapCrash(uint)+2Ap
.text$mn:00002F68
.text$mn:00002F68 var_108         = byte ptr -108h
.text$mn:00002F68 var_44          = dword ptr -44h
.text$mn:00002F68 Size            = dword ptr -38h
.text$mn:00002F68 var_2C          = dword ptr -2Ch
.text$mn:00002F68 var_20          = dword ptr -20h
.text$mn:00002F68 var_14          = dword ptr -14h
.text$mn:00002F68 var_8           = dword ptr -8
.text$mn:00002F68 arg_0           = dword ptr  8
.text$mn:00002F68
.text$mn:00002F68                 push    ebp
.text$mn:00002F69                 mov     ebp, esp
.text$mn:00002F6B                 sub     esp, 108h
.text$mn:00002F71                 push    ebx
.text$mn:00002F72                 push    esi
.text$mn:00002F73                 push    edi
.text$mn:00002F74                 push    ecx
.text$mn:00002F75                 lea     edi, [ebp+var_108]
.text$mn:00002F7B                 mov     ecx, 42h ; 'B'
.text$mn:00002F80                 mov     eax, 0CCCCCCCCh
.text$mn:00002F85                 rep stosd
.text$mn:00002F87                 pop     ecx
.text$mn:00002F88                 mov     [ebp+var_8], ecx
.text$mn:00002F8B                 mov     eax, [ebp+var_8]
.text$mn:00002F8E                 mov     ecx, [eax+4]
.text$mn:00002F91                 cmp     ecx, [ebp+arg_0]
.text$mn:00002F94                 jb      short loc_2F9D
.text$mn:00002F96                 mov     al, 1
.text$mn:00002F98                 jmp     loc_309A
.text$mn:00002F9D ; ---------------------------------------------------------------------------
.text$mn:00002F9D
.text$mn:00002F9D loc_2F9D:                               ; CODE XREF: Vec<int>::EnsureCapTry(uint)+2Cj
.text$mn:00002F9D                 mov     eax, [ebp+var_8]
.text$mn:00002FA0                 mov     ecx, [eax+4]
.text$mn:00002FA3                 shl     ecx, 1
.text$mn:00002FA5                 mov     [ebp+var_14], ecx
.text$mn:00002FA8                 mov     eax, [ebp+arg_0]
.text$mn:00002FAB                 cmp     eax, [ebp+var_14]
.text$mn:00002FAE                 jbe     short loc_2FB6
.text$mn:00002FB0                 mov     eax, [ebp+arg_0]
.text$mn:00002FB3                 mov     [ebp+var_14], eax
.text$mn:00002FB6
.text$mn:00002FB6 loc_2FB6:                               ; CODE XREF: Vec<int>::EnsureCapTry(uint)+46j
.text$mn:00002FB6                 mov     eax, [ebp+var_8]
.text$mn:00002FB9                 mov     ecx, [ebp+var_14]
.text$mn:00002FBC                 cmp     ecx, [eax+8]
.text$mn:00002FBF                 jnb     short loc_2FCA
.text$mn:00002FC1                 mov     eax, [ebp+var_8]
.text$mn:00002FC4                 mov     ecx, [eax+8]
.text$mn:00002FC7                 mov     [ebp+var_14], ecx
.text$mn:00002FCA
.text$mn:00002FCA loc_2FCA:                               ; CODE XREF: Vec<int>::EnsureCapTry(uint)+57j
.text$mn:00002FCA                 mov     eax, [ebp+var_14]
.text$mn:00002FCD                 add     eax, 1
.text$mn:00002FD0                 mov     [ebp+var_20], eax
.text$mn:00002FD3                 cmp     [ebp+var_20], 3FFFFFFFh
.text$mn:00002FDA                 jb      short loc_2FE3
.text$mn:00002FDC                 xor     al, al
.text$mn:00002FDE                 jmp     loc_309A
.text$mn:00002FE3 ; ---------------------------------------------------------------------------
.text$mn:00002FE3
.text$mn:00002FE3 loc_2FE3:                               ; CODE XREF: Vec<int>::EnsureCapTry(uint)+72j
.text$mn:00002FE3                 cmp     [ebp+var_20], 7FFFFFFFh
.text$mn:00002FEA                 jbe     short loc_2FF3
.text$mn:00002FEC                 xor     al, al
.text$mn:00002FEE                 jmp     loc_309A
.text$mn:00002FF3 ; ---------------------------------------------------------------------------
.text$mn:00002FF3
.text$mn:00002FF3 loc_2FF3:                               ; CODE XREF: Vec<int>::EnsureCapTry(uint)+82j
.text$mn:00002FF3                 mov     eax, [ebp+var_20]
.text$mn:00002FF6                 shl     eax, 2
.text$mn:00002FF9                 mov     [ebp+var_2C], eax
.text$mn:00002FFC                 mov     eax, [ebp+var_8]
.text$mn:00002FFF                 mov     ecx, [eax]
.text$mn:00003001                 shl     ecx, 2
.text$mn:00003004                 mov     edx, [ebp+var_2C]
.text$mn:00003007                 sub     edx, ecx
.text$mn:00003009                 mov     [ebp+Size], edx
.text$mn:0000300C                 mov     eax, [ebp+var_8]
.text$mn:0000300F                 add     eax, 10h
.text$mn:00003012                 mov     ecx, [ebp+var_8]
.text$mn:00003015                 cmp     eax, [ecx+0Ch]
.text$mn:00003018                 jnz     short loc_3042
.text$mn:0000301A                 mov     eax, [ebp+Size]
.text$mn:0000301D                 push    eax             ; unsigned int
.text$mn:0000301E                 mov     ecx, [ebp+var_8]
.text$mn:00003021                 mov     edx, [ecx]
.text$mn:00003023                 shl     edx, 2
.text$mn:00003026                 push    edx             ; unsigned int
.text$mn:00003027                 mov     eax, [ebp+var_8]
.text$mn:0000302A                 add     eax, 10h
.text$mn:0000302D                 push    eax             ; void *
.text$mn:0000302E                 mov     ecx, [ebp+var_8]
.text$mn:00003031                 mov     edx, [ecx+50h]
.text$mn:00003034                 push    edx             ; struct Allocator *
.text$mn:00003035                 call    ?Dup@Allocator@@SAPAXPAV1@PBXII@Z ; Allocator::Dup(Allocator *,void const *,uint,uint)
.text$mn:0000303A                 add     esp, 10h
.text$mn:0000303D                 mov     [ebp+var_44], eax
.text$mn:00003040                 jmp     short loc_305F
.text$mn:00003042 ; ---------------------------------------------------------------------------
.text$mn:00003042
.text$mn:00003042 loc_3042:                               ; CODE XREF: Vec<int>::EnsureCapTry(uint)+B0j
.text$mn:00003042                 mov     eax, [ebp+var_2C]
.text$mn:00003045                 push    eax             ; unsigned int
.text$mn:00003046                 mov     ecx, [ebp+var_8]
.text$mn:00003049                 mov     edx, [ecx+0Ch]
.text$mn:0000304C                 push    edx             ; void *
.text$mn:0000304D                 mov     eax, [ebp+var_8]
.text$mn:00003050                 mov     ecx, [eax+50h]
.text$mn:00003053                 push    ecx             ; struct Allocator *
.text$mn:00003054                 call    ?Realloc@Allocator@@SAPAXPAV1@PAXI@Z ; Allocator::Realloc(Allocator *,void *,uint)
.text$mn:00003059                 add     esp, 0Ch
.text$mn:0000305C                 mov     [ebp+var_44], eax
.text$mn:0000305F
.text$mn:0000305F loc_305F:                               ; CODE XREF: Vec<int>::EnsureCapTry(uint)+D8j
.text$mn:0000305F                 cmp     [ebp+var_44], 0
.text$mn:00003063                 jnz     short loc_3069
.text$mn:00003065                 xor     al, al
.text$mn:00003067                 jmp     short loc_309A
.text$mn:00003069 ; ---------------------------------------------------------------------------
.text$mn:00003069
.text$mn:00003069 loc_3069:                               ; CODE XREF: Vec<int>::EnsureCapTry(uint)+FBj
.text$mn:00003069                 mov     eax, [ebp+var_8]
.text$mn:0000306C                 mov     ecx, [ebp+var_44]
.text$mn:0000306F                 mov     [eax+0Ch], ecx
.text$mn:00003072                 mov     eax, [ebp+Size]
.text$mn:00003075                 push    eax             ; Size
.text$mn:00003076                 push    0               ; Val
.text$mn:00003078                 mov     ecx, [ebp+var_8]
.text$mn:0000307B                 mov     edx, [ecx]
.text$mn:0000307D                 mov     eax, [ebp+var_8]
.text$mn:00003080                 mov     ecx, [eax+0Ch]
.text$mn:00003083                 lea     edx, [ecx+edx*4]
.text$mn:00003086                 push    edx             ; Dst
.text$mn:00003087                 call    _memset
.text$mn:0000308C                 add     esp, 0Ch
.text$mn:0000308F                 mov     eax, [ebp+var_8]
.text$mn:00003092                 mov     ecx, [ebp+var_14]
.text$mn:00003095                 mov     [eax+4], ecx
.text$mn:00003098                 mov     al, 1
.text$mn:0000309A
.text$mn:0000309A loc_309A:                               ; CODE XREF: Vec<int>::EnsureCapTry(uint)+30j
.text$mn:0000309A                                         ; Vec<int>::EnsureCapTry(uint)+76j ...
.text$mn:0000309A                 pop     edi
.text$mn:0000309B                 pop     esi
.text$mn:0000309C                 pop     ebx
.text$mn:0000309D                 add     esp, 108h
.text$mn:000030A3                 cmp     ebp, esp
.text$mn:000030A5                 call    __RTC_CheckEsp
.text$mn:000030AA                 mov     esp, ebp
.text$mn:000030AC                 pop     ebp
.text$mn:000030AD                 retn    4
.text$mn:000030AD ?EnsureCapTry@?$Vec@H@@IAE_NI@Z endp
.text$mn:000030AD
.text$mn:000030AD _text$mn        ends
.text$mn:000030AD
.text$mn:000030B0 ; ===========================================================================
.text$mn:000030B0
.text$mn:000030B0 ; Segment type: Pure code
.text$mn:000030B0 ; Segment permissions: Read/Execute
.text$mn:000030B0 _text$mn        segment para public 'CODE' use32
.text$mn:000030B0                 assume cs:_text$mn
.text$mn:000030B0                 ;org 30B0h
.text$mn:000030B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030B0
.text$mn:000030B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000030B0
.text$mn:000030B0 ; Attributes: bp-based frame
.text$mn:000030B0
.text$mn:000030B0 ; protected: bool __thiscall Vec<wchar_t *>::EnsureCapTry(unsigned int)
.text$mn:000030B0                 public ?EnsureCapTry@?$Vec@PA_W@@IAE_NI@Z
.text$mn:000030B0 ?EnsureCapTry@?$Vec@PA_W@@IAE_NI@Z proc near
.text$mn:000030B0                                         ; CODE XREF: Vec<wchar_t *>::EnsureCapCrash(uint)+2Ap
.text$mn:000030B0                                         ; Vec<wchar_t *>::MakeSpaceAt(uint,uint,bool)+58p
.text$mn:000030B0
.text$mn:000030B0 var_108         = byte ptr -108h
.text$mn:000030B0 var_44          = dword ptr -44h
.text$mn:000030B0 Size            = dword ptr -38h
.text$mn:000030B0 var_2C          = dword ptr -2Ch
.text$mn:000030B0 var_20          = dword ptr -20h
.text$mn:000030B0 var_14          = dword ptr -14h
.text$mn:000030B0 var_8           = dword ptr -8
.text$mn:000030B0 arg_0           = dword ptr  8
.text$mn:000030B0
.text$mn:000030B0                 push    ebp
.text$mn:000030B1                 mov     ebp, esp
.text$mn:000030B3                 sub     esp, 108h
.text$mn:000030B9                 push    ebx
.text$mn:000030BA                 push    esi
.text$mn:000030BB                 push    edi
.text$mn:000030BC                 push    ecx
.text$mn:000030BD                 lea     edi, [ebp+var_108]
.text$mn:000030C3                 mov     ecx, 42h ; 'B'
.text$mn:000030C8                 mov     eax, 0CCCCCCCCh
.text$mn:000030CD                 rep stosd
.text$mn:000030CF                 pop     ecx
.text$mn:000030D0                 mov     [ebp+var_8], ecx
.text$mn:000030D3                 mov     eax, [ebp+var_8]
.text$mn:000030D6                 mov     ecx, [eax+4]
.text$mn:000030D9                 cmp     ecx, [ebp+arg_0]
.text$mn:000030DC                 jb      short loc_30E5
.text$mn:000030DE                 mov     al, 1
.text$mn:000030E0                 jmp     loc_31E2
.text$mn:000030E5 ; ---------------------------------------------------------------------------
.text$mn:000030E5
.text$mn:000030E5 loc_30E5:                               ; CODE XREF: Vec<wchar_t *>::EnsureCapTry(uint)+2Cj
.text$mn:000030E5                 mov     eax, [ebp+var_8]
.text$mn:000030E8                 mov     ecx, [eax+4]
.text$mn:000030EB                 shl     ecx, 1
.text$mn:000030ED                 mov     [ebp+var_14], ecx
.text$mn:000030F0                 mov     eax, [ebp+arg_0]
.text$mn:000030F3                 cmp     eax, [ebp+var_14]
.text$mn:000030F6                 jbe     short loc_30FE
.text$mn:000030F8                 mov     eax, [ebp+arg_0]
.text$mn:000030FB                 mov     [ebp+var_14], eax
.text$mn:000030FE
.text$mn:000030FE loc_30FE:                               ; CODE XREF: Vec<wchar_t *>::EnsureCapTry(uint)+46j
.text$mn:000030FE                 mov     eax, [ebp+var_8]
.text$mn:00003101                 mov     ecx, [ebp+var_14]
.text$mn:00003104                 cmp     ecx, [eax+8]
.text$mn:00003107                 jnb     short loc_3112
.text$mn:00003109                 mov     eax, [ebp+var_8]
.text$mn:0000310C                 mov     ecx, [eax+8]
.text$mn:0000310F                 mov     [ebp+var_14], ecx
.text$mn:00003112
.text$mn:00003112 loc_3112:                               ; CODE XREF: Vec<wchar_t *>::EnsureCapTry(uint)+57j
.text$mn:00003112                 mov     eax, [ebp+var_14]
.text$mn:00003115                 add     eax, 1
.text$mn:00003118                 mov     [ebp+var_20], eax
.text$mn:0000311B                 cmp     [ebp+var_20], 3FFFFFFFh
.text$mn:00003122                 jb      short loc_312B
.text$mn:00003124                 xor     al, al
.text$mn:00003126                 jmp     loc_31E2
.text$mn:0000312B ; ---------------------------------------------------------------------------
.text$mn:0000312B
.text$mn:0000312B loc_312B:                               ; CODE XREF: Vec<wchar_t *>::EnsureCapTry(uint)+72j
.text$mn:0000312B                 cmp     [ebp+var_20], 7FFFFFFFh
.text$mn:00003132                 jbe     short loc_313B
.text$mn:00003134                 xor     al, al
.text$mn:00003136                 jmp     loc_31E2
.text$mn:0000313B ; ---------------------------------------------------------------------------
.text$mn:0000313B
.text$mn:0000313B loc_313B:                               ; CODE XREF: Vec<wchar_t *>::EnsureCapTry(uint)+82j
.text$mn:0000313B                 mov     eax, [ebp+var_20]
.text$mn:0000313E                 shl     eax, 2
.text$mn:00003141                 mov     [ebp+var_2C], eax
.text$mn:00003144                 mov     eax, [ebp+var_8]
.text$mn:00003147                 mov     ecx, [eax]
.text$mn:00003149                 shl     ecx, 2
.text$mn:0000314C                 mov     edx, [ebp+var_2C]
.text$mn:0000314F                 sub     edx, ecx
.text$mn:00003151                 mov     [ebp+Size], edx
.text$mn:00003154                 mov     eax, [ebp+var_8]
.text$mn:00003157                 add     eax, 10h
.text$mn:0000315A                 mov     ecx, [ebp+var_8]
.text$mn:0000315D                 cmp     eax, [ecx+0Ch]
.text$mn:00003160                 jnz     short loc_318A
.text$mn:00003162                 mov     eax, [ebp+Size]
.text$mn:00003165                 push    eax             ; unsigned int
.text$mn:00003166                 mov     ecx, [ebp+var_8]
.text$mn:00003169                 mov     edx, [ecx]
.text$mn:0000316B                 shl     edx, 2
.text$mn:0000316E                 push    edx             ; unsigned int
.text$mn:0000316F                 mov     eax, [ebp+var_8]
.text$mn:00003172                 add     eax, 10h
.text$mn:00003175                 push    eax             ; void *
.text$mn:00003176                 mov     ecx, [ebp+var_8]
.text$mn:00003179                 mov     edx, [ecx+50h]
.text$mn:0000317C                 push    edx             ; struct Allocator *
.text$mn:0000317D                 call    ?Dup@Allocator@@SAPAXPAV1@PBXII@Z ; Allocator::Dup(Allocator *,void const *,uint,uint)
.text$mn:00003182                 add     esp, 10h
.text$mn:00003185                 mov     [ebp+var_44], eax
.text$mn:00003188                 jmp     short loc_31A7
.text$mn:0000318A ; ---------------------------------------------------------------------------
.text$mn:0000318A
.text$mn:0000318A loc_318A:                               ; CODE XREF: Vec<wchar_t *>::EnsureCapTry(uint)+B0j
.text$mn:0000318A                 mov     eax, [ebp+var_2C]
.text$mn:0000318D                 push    eax             ; unsigned int
.text$mn:0000318E                 mov     ecx, [ebp+var_8]
.text$mn:00003191                 mov     edx, [ecx+0Ch]
.text$mn:00003194                 push    edx             ; void *
.text$mn:00003195                 mov     eax, [ebp+var_8]
.text$mn:00003198                 mov     ecx, [eax+50h]
.text$mn:0000319B                 push    ecx             ; struct Allocator *
.text$mn:0000319C                 call    ?Realloc@Allocator@@SAPAXPAV1@PAXI@Z ; Allocator::Realloc(Allocator *,void *,uint)
.text$mn:000031A1                 add     esp, 0Ch
.text$mn:000031A4                 mov     [ebp+var_44], eax
.text$mn:000031A7
.text$mn:000031A7 loc_31A7:                               ; CODE XREF: Vec<wchar_t *>::EnsureCapTry(uint)+D8j
.text$mn:000031A7                 cmp     [ebp+var_44], 0
.text$mn:000031AB                 jnz     short loc_31B1
.text$mn:000031AD                 xor     al, al
.text$mn:000031AF                 jmp     short loc_31E2
.text$mn:000031B1 ; ---------------------------------------------------------------------------
.text$mn:000031B1
.text$mn:000031B1 loc_31B1:                               ; CODE XREF: Vec<wchar_t *>::EnsureCapTry(uint)+FBj
.text$mn:000031B1                 mov     eax, [ebp+var_8]
.text$mn:000031B4                 mov     ecx, [ebp+var_44]
.text$mn:000031B7                 mov     [eax+0Ch], ecx
.text$mn:000031BA                 mov     eax, [ebp+Size]
.text$mn:000031BD                 push    eax             ; Size
.text$mn:000031BE                 push    0               ; Val
.text$mn:000031C0                 mov     ecx, [ebp+var_8]
.text$mn:000031C3                 mov     edx, [ecx]
.text$mn:000031C5                 mov     eax, [ebp+var_8]
.text$mn:000031C8                 mov     ecx, [eax+0Ch]
.text$mn:000031CB                 lea     edx, [ecx+edx*4]
.text$mn:000031CE                 push    edx             ; Dst
.text$mn:000031CF                 call    _memset
.text$mn:000031D4                 add     esp, 0Ch
.text$mn:000031D7                 mov     eax, [ebp+var_8]
.text$mn:000031DA                 mov     ecx, [ebp+var_14]
.text$mn:000031DD                 mov     [eax+4], ecx
.text$mn:000031E0                 mov     al, 1
.text$mn:000031E2
.text$mn:000031E2 loc_31E2:                               ; CODE XREF: Vec<wchar_t *>::EnsureCapTry(uint)+30j
.text$mn:000031E2                                         ; Vec<wchar_t *>::EnsureCapTry(uint)+76j ...
.text$mn:000031E2                 pop     edi
.text$mn:000031E3                 pop     esi
.text$mn:000031E4                 pop     ebx
.text$mn:000031E5                 add     esp, 108h
.text$mn:000031EB                 cmp     ebp, esp
.text$mn:000031ED                 call    __RTC_CheckEsp
.text$mn:000031F2                 mov     esp, ebp
.text$mn:000031F4                 pop     ebp
.text$mn:000031F5                 retn    4
.text$mn:000031F5 ?EnsureCapTry@?$Vec@PA_W@@IAE_NI@Z endp
.text$mn:000031F5
.text$mn:000031F5 _text$mn        ends
.text$mn:000031F5
.text$mn:000031F8 ; ===========================================================================
.text$mn:000031F8
.text$mn:000031F8 ; Segment type: Pure code
.text$mn:000031F8 ; Segment permissions: Read/Execute
.text$mn:000031F8 _text$mn        segment para public 'CODE' use32
.text$mn:000031F8                 assume cs:_text$mn
.text$mn:000031F8                 ;org 31F8h
.text$mn:000031F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031F8
.text$mn:000031F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000031F8
.text$mn:000031F8 ; Attributes: bp-based frame
.text$mn:000031F8
.text$mn:000031F8 ; protected: bool __thiscall Vec<wchar_t>::EnsureCapTry(unsigned int)
.text$mn:000031F8                 public ?EnsureCapTry@?$Vec@_W@@IAE_NI@Z
.text$mn:000031F8 ?EnsureCapTry@?$Vec@_W@@IAE_NI@Z proc near
.text$mn:000031F8                                         ; CODE XREF: Vec<wchar_t>::EnsureCapCrash(uint)+2Ap
.text$mn:000031F8                                         ; Vec<wchar_t>::MakeSpaceAt(uint,uint,bool)+58p
.text$mn:000031F8
.text$mn:000031F8 var_108         = byte ptr -108h
.text$mn:000031F8 var_44          = dword ptr -44h
.text$mn:000031F8 Size            = dword ptr -38h
.text$mn:000031F8 var_2C          = dword ptr -2Ch
.text$mn:000031F8 var_20          = dword ptr -20h
.text$mn:000031F8 var_14          = dword ptr -14h
.text$mn:000031F8 var_8           = dword ptr -8
.text$mn:000031F8 arg_0           = dword ptr  8
.text$mn:000031F8
.text$mn:000031F8                 push    ebp
.text$mn:000031F9                 mov     ebp, esp
.text$mn:000031FB                 sub     esp, 108h
.text$mn:00003201                 push    ebx
.text$mn:00003202                 push    esi
.text$mn:00003203                 push    edi
.text$mn:00003204                 push    ecx
.text$mn:00003205                 lea     edi, [ebp+var_108]
.text$mn:0000320B                 mov     ecx, 42h ; 'B'
.text$mn:00003210                 mov     eax, 0CCCCCCCCh
.text$mn:00003215                 rep stosd
.text$mn:00003217                 pop     ecx
.text$mn:00003218                 mov     [ebp+var_8], ecx
.text$mn:0000321B                 mov     eax, [ebp+var_8]
.text$mn:0000321E                 mov     ecx, [eax+4]
.text$mn:00003221                 cmp     ecx, [ebp+arg_0]
.text$mn:00003224                 jb      short loc_322D
.text$mn:00003226                 mov     al, 1
.text$mn:00003228                 jmp     loc_3327
.text$mn:0000322D ; ---------------------------------------------------------------------------
.text$mn:0000322D
.text$mn:0000322D loc_322D:                               ; CODE XREF: Vec<wchar_t>::EnsureCapTry(uint)+2Cj
.text$mn:0000322D                 mov     eax, [ebp+var_8]
.text$mn:00003230                 mov     ecx, [eax+4]
.text$mn:00003233                 shl     ecx, 1
.text$mn:00003235                 mov     [ebp+var_14], ecx
.text$mn:00003238                 mov     eax, [ebp+arg_0]
.text$mn:0000323B                 cmp     eax, [ebp+var_14]
.text$mn:0000323E                 jbe     short loc_3246
.text$mn:00003240                 mov     eax, [ebp+arg_0]
.text$mn:00003243                 mov     [ebp+var_14], eax
.text$mn:00003246
.text$mn:00003246 loc_3246:                               ; CODE XREF: Vec<wchar_t>::EnsureCapTry(uint)+46j
.text$mn:00003246                 mov     eax, [ebp+var_8]
.text$mn:00003249                 mov     ecx, [ebp+var_14]
.text$mn:0000324C                 cmp     ecx, [eax+8]
.text$mn:0000324F                 jnb     short loc_325A
.text$mn:00003251                 mov     eax, [ebp+var_8]
.text$mn:00003254                 mov     ecx, [eax+8]
.text$mn:00003257                 mov     [ebp+var_14], ecx
.text$mn:0000325A
.text$mn:0000325A loc_325A:                               ; CODE XREF: Vec<wchar_t>::EnsureCapTry(uint)+57j
.text$mn:0000325A                 mov     eax, [ebp+var_14]
.text$mn:0000325D                 add     eax, 1
.text$mn:00003260                 mov     [ebp+var_20], eax
.text$mn:00003263                 cmp     [ebp+var_20], 7FFFFFFFh
.text$mn:0000326A                 jb      short loc_3273
.text$mn:0000326C                 xor     al, al
.text$mn:0000326E                 jmp     loc_3327
.text$mn:00003273 ; ---------------------------------------------------------------------------
.text$mn:00003273
.text$mn:00003273 loc_3273:                               ; CODE XREF: Vec<wchar_t>::EnsureCapTry(uint)+72j
.text$mn:00003273                 cmp     [ebp+var_20], 7FFFFFFFh
.text$mn:0000327A                 jbe     short loc_3283
.text$mn:0000327C                 xor     al, al
.text$mn:0000327E                 jmp     loc_3327
.text$mn:00003283 ; ---------------------------------------------------------------------------
.text$mn:00003283
.text$mn:00003283 loc_3283:                               ; CODE XREF: Vec<wchar_t>::EnsureCapTry(uint)+82j
.text$mn:00003283                 mov     eax, [ebp+var_20]
.text$mn:00003286                 shl     eax, 1
.text$mn:00003288                 mov     [ebp+var_2C], eax
.text$mn:0000328B                 mov     eax, [ebp+var_8]
.text$mn:0000328E                 mov     ecx, [eax]
.text$mn:00003290                 shl     ecx, 1
.text$mn:00003292                 mov     edx, [ebp+var_2C]
.text$mn:00003295                 sub     edx, ecx
.text$mn:00003297                 mov     [ebp+Size], edx
.text$mn:0000329A                 mov     eax, [ebp+var_8]
.text$mn:0000329D                 add     eax, 10h
.text$mn:000032A0                 mov     ecx, [ebp+var_8]
.text$mn:000032A3                 cmp     eax, [ecx+0Ch]
.text$mn:000032A6                 jnz     short loc_32CF
.text$mn:000032A8                 mov     eax, [ebp+Size]
.text$mn:000032AB                 push    eax             ; unsigned int
.text$mn:000032AC                 mov     ecx, [ebp+var_8]
.text$mn:000032AF                 mov     edx, [ecx]
.text$mn:000032B1                 shl     edx, 1
.text$mn:000032B3                 push    edx             ; unsigned int
.text$mn:000032B4                 mov     eax, [ebp+var_8]
.text$mn:000032B7                 add     eax, 10h
.text$mn:000032BA                 push    eax             ; void *
.text$mn:000032BB                 mov     ecx, [ebp+var_8]
.text$mn:000032BE                 mov     edx, [ecx+30h]
.text$mn:000032C1                 push    edx             ; struct Allocator *
.text$mn:000032C2                 call    ?Dup@Allocator@@SAPAXPAV1@PBXII@Z ; Allocator::Dup(Allocator *,void const *,uint,uint)
.text$mn:000032C7                 add     esp, 10h
.text$mn:000032CA                 mov     [ebp+var_44], eax
.text$mn:000032CD                 jmp     short loc_32EC
.text$mn:000032CF ; ---------------------------------------------------------------------------
.text$mn:000032CF
.text$mn:000032CF loc_32CF:                               ; CODE XREF: Vec<wchar_t>::EnsureCapTry(uint)+AEj
.text$mn:000032CF                 mov     eax, [ebp+var_2C]
.text$mn:000032D2                 push    eax             ; unsigned int
.text$mn:000032D3                 mov     ecx, [ebp+var_8]
.text$mn:000032D6                 mov     edx, [ecx+0Ch]
.text$mn:000032D9                 push    edx             ; void *
.text$mn:000032DA                 mov     eax, [ebp+var_8]
.text$mn:000032DD                 mov     ecx, [eax+30h]
.text$mn:000032E0                 push    ecx             ; struct Allocator *
.text$mn:000032E1                 call    ?Realloc@Allocator@@SAPAXPAV1@PAXI@Z ; Allocator::Realloc(Allocator *,void *,uint)
.text$mn:000032E6                 add     esp, 0Ch
.text$mn:000032E9                 mov     [ebp+var_44], eax
.text$mn:000032EC
.text$mn:000032EC loc_32EC:                               ; CODE XREF: Vec<wchar_t>::EnsureCapTry(uint)+D5j
.text$mn:000032EC                 cmp     [ebp+var_44], 0
.text$mn:000032F0                 jnz     short loc_32F6
.text$mn:000032F2                 xor     al, al
.text$mn:000032F4                 jmp     short loc_3327
.text$mn:000032F6 ; ---------------------------------------------------------------------------
.text$mn:000032F6
.text$mn:000032F6 loc_32F6:                               ; CODE XREF: Vec<wchar_t>::EnsureCapTry(uint)+F8j
.text$mn:000032F6                 mov     eax, [ebp+var_8]
.text$mn:000032F9                 mov     ecx, [ebp+var_44]
.text$mn:000032FC                 mov     [eax+0Ch], ecx
.text$mn:000032FF                 mov     eax, [ebp+Size]
.text$mn:00003302                 push    eax             ; Size
.text$mn:00003303                 push    0               ; Val
.text$mn:00003305                 mov     ecx, [ebp+var_8]
.text$mn:00003308                 mov     edx, [ecx]
.text$mn:0000330A                 mov     eax, [ebp+var_8]
.text$mn:0000330D                 mov     ecx, [eax+0Ch]
.text$mn:00003310                 lea     edx, [ecx+edx*2]
.text$mn:00003313                 push    edx             ; Dst
.text$mn:00003314                 call    _memset
.text$mn:00003319                 add     esp, 0Ch
.text$mn:0000331C                 mov     eax, [ebp+var_8]
.text$mn:0000331F                 mov     ecx, [ebp+var_14]
.text$mn:00003322                 mov     [eax+4], ecx
.text$mn:00003325                 mov     al, 1
.text$mn:00003327
.text$mn:00003327 loc_3327:                               ; CODE XREF: Vec<wchar_t>::EnsureCapTry(uint)+30j
.text$mn:00003327                                         ; Vec<wchar_t>::EnsureCapTry(uint)+76j ...
.text$mn:00003327                 pop     edi
.text$mn:00003328                 pop     esi
.text$mn:00003329                 pop     ebx
.text$mn:0000332A                 add     esp, 108h
.text$mn:00003330                 cmp     ebp, esp
.text$mn:00003332                 call    __RTC_CheckEsp
.text$mn:00003337                 mov     esp, ebp
.text$mn:00003339                 pop     ebp
.text$mn:0000333A                 retn    4
.text$mn:0000333A ?EnsureCapTry@?$Vec@_W@@IAE_NI@Z endp
.text$mn:0000333A
.text$mn:0000333A ; ---------------------------------------------------------------------------
.text$mn:0000333D                 align 10h
.text$mn:0000333D _text$mn        ends
.text$mn:0000333D
.text$mn:00003340 ; ===========================================================================
.text$mn:00003340
.text$mn:00003340 ; Segment type: Pure code
.text$mn:00003340 ; Segment permissions: Read/Execute
.text$mn:00003340 _text$mn        segment para public 'CODE' use32
.text$mn:00003340                 assume cs:_text$mn
.text$mn:00003340                 ;org 3340h
.text$mn:00003340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003340
.text$mn:00003340 ; =============== S U B R O U T I N E =======================================
.text$mn:00003340
.text$mn:00003340 ; Attributes: bp-based frame
.text$mn:00003340
.text$mn:00003340 ; int __thiscall WStrVec::Find(WStrVec *this, const wchar_t *, unsigned int)
.text$mn:00003340                 public ?Find@WStrVec@@QBEHPB_WI@Z
.text$mn:00003340 ?Find@WStrVec@@QBEHPB_WI@Z proc near    ; CODE XREF: WStrVec::Contains(wchar_t const *)+2Cp
.text$mn:00003340
.text$mn:00003340 var_E4          = byte ptr -0E4h
.text$mn:00003340 var_20          = dword ptr -20h
.text$mn:00003340 var_14          = dword ptr -14h
.text$mn:00003340 var_8           = dword ptr -8
.text$mn:00003340 arg_0           = dword ptr  8
.text$mn:00003340 arg_4           = dword ptr  0Ch
.text$mn:00003340
.text$mn:00003340                 push    ebp
.text$mn:00003341                 mov     ebp, esp
.text$mn:00003343                 sub     esp, 0E4h
.text$mn:00003349                 push    ebx
.text$mn:0000334A                 push    esi
.text$mn:0000334B                 push    edi
.text$mn:0000334C                 push    ecx
.text$mn:0000334D                 lea     edi, [ebp+var_E4]
.text$mn:00003353                 mov     ecx, 39h ; '9'
.text$mn:00003358                 mov     eax, 0CCCCCCCCh
.text$mn:0000335D                 rep stosd
.text$mn:0000335F                 pop     ecx
.text$mn:00003360                 mov     [ebp+var_8], ecx
.text$mn:00003363                 mov     eax, [ebp+arg_4]
.text$mn:00003366                 mov     [ebp+var_14], eax
.text$mn:00003369                 jmp     short loc_3374
.text$mn:0000336B ; ---------------------------------------------------------------------------
.text$mn:0000336B
.text$mn:0000336B loc_336B:                               ; CODE XREF: WStrVec::Find(wchar_t const *,uint):loc_33ABj
.text$mn:0000336B                 mov     eax, [ebp+var_14]
.text$mn:0000336E                 add     eax, 1
.text$mn:00003371                 mov     [ebp+var_14], eax
.text$mn:00003374
.text$mn:00003374 loc_3374:                               ; CODE XREF: WStrVec::Find(wchar_t const *,uint)+29j
.text$mn:00003374                 mov     eax, [ebp+var_8]
.text$mn:00003377                 mov     ecx, [ebp+var_14]
.text$mn:0000337A                 cmp     ecx, [eax]
.text$mn:0000337C                 jnb     short loc_33AD
.text$mn:0000337E                 mov     eax, [ebp+var_14]
.text$mn:00003381                 push    eax
.text$mn:00003382                 mov     ecx, [ebp+var_8]
.text$mn:00003385                 call    ?At@?$Vec@PA_W@@QBEAAPA_WI@Z ; Vec<wchar_t *>::At(uint)
.text$mn:0000338A                 mov     ecx, [eax]
.text$mn:0000338C                 mov     [ebp+var_20], ecx
.text$mn:0000338F                 mov     eax, [ebp+var_20]
.text$mn:00003392                 push    eax             ; wchar_t *
.text$mn:00003393                 mov     ecx, [ebp+arg_0]
.text$mn:00003396                 push    ecx             ; this
.text$mn:00003397                 call    ?Eq@str@@YA_NPB_W0@Z ; str::Eq(wchar_t const *,wchar_t const *)
.text$mn:0000339C                 add     esp, 8
.text$mn:0000339F                 movzx   edx, al
.text$mn:000033A2                 test    edx, edx
.text$mn:000033A4                 jz      short loc_33AB
.text$mn:000033A6                 mov     eax, [ebp+var_14]
.text$mn:000033A9                 jmp     short loc_33B0
.text$mn:000033AB ; ---------------------------------------------------------------------------
.text$mn:000033AB
.text$mn:000033AB loc_33AB:                               ; CODE XREF: WStrVec::Find(wchar_t const *,uint)+64j
.text$mn:000033AB                 jmp     short loc_336B
.text$mn:000033AD ; ---------------------------------------------------------------------------
.text$mn:000033AD
.text$mn:000033AD loc_33AD:                               ; CODE XREF: WStrVec::Find(wchar_t const *,uint)+3Cj
.text$mn:000033AD                 or      eax, 0FFFFFFFFh
.text$mn:000033B0
.text$mn:000033B0 loc_33B0:                               ; CODE XREF: WStrVec::Find(wchar_t const *,uint)+69j
.text$mn:000033B0                 pop     edi
.text$mn:000033B1                 pop     esi
.text$mn:000033B2                 pop     ebx
.text$mn:000033B3                 add     esp, 0E4h
.text$mn:000033B9                 cmp     ebp, esp
.text$mn:000033BB                 call    __RTC_CheckEsp
.text$mn:000033C0                 mov     esp, ebp
.text$mn:000033C2                 pop     ebp
.text$mn:000033C3                 retn    8
.text$mn:000033C3 ?Find@WStrVec@@QBEHPB_WI@Z endp
.text$mn:000033C3
.text$mn:000033C3 ; ---------------------------------------------------------------------------
.text$mn:000033C6                 align 4
.text$mn:000033C6 _text$mn        ends
.text$mn:000033C6
.text$mn:000033C8 ; ===========================================================================
.text$mn:000033C8
.text$mn:000033C8 ; Segment type: Pure code
.text$mn:000033C8 ; Segment permissions: Read/Execute
.text$mn:000033C8 _text$mn        segment para public 'CODE' use32
.text$mn:000033C8                 assume cs:_text$mn
.text$mn:000033C8                 ;org 33C8h
.text$mn:000033C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033C8
.text$mn:000033C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000033C8
.text$mn:000033C8 ; Attributes: bp-based frame
.text$mn:000033C8
.text$mn:000033C8 ; const wchar_t *__cdecl str::Find(wchar_t *Str, const wchar_t *SubStr, const wchar_t *)
.text$mn:000033C8                 public ?Find@str@@YAPB_WPB_W0@Z
.text$mn:000033C8 ?Find@str@@YAPB_WPB_W0@Z proc near      ; CODE XREF: WStrVec::Split(wchar_t const *,wchar_t const *,bool)+33p
.text$mn:000033C8
.text$mn:000033C8 var_C0          = byte ptr -0C0h
.text$mn:000033C8 Str             = dword ptr  8
.text$mn:000033C8 SubStr          = dword ptr  0Ch
.text$mn:000033C8
.text$mn:000033C8                 push    ebp
.text$mn:000033C9                 mov     ebp, esp
.text$mn:000033CB                 sub     esp, 0C0h
.text$mn:000033D1                 push    ebx
.text$mn:000033D2                 push    esi
.text$mn:000033D3                 push    edi
.text$mn:000033D4                 lea     edi, [ebp+var_C0]
.text$mn:000033DA                 mov     ecx, 30h ; '0'
.text$mn:000033DF                 mov     eax, 0CCCCCCCCh
.text$mn:000033E4                 rep stosd
.text$mn:000033E6                 mov     eax, [ebp+SubStr]
.text$mn:000033E9                 push    eax             ; SubStr
.text$mn:000033EA                 mov     ecx, [ebp+Str]
.text$mn:000033ED                 push    ecx             ; Str
.text$mn:000033EE                 call    _wcsstr
.text$mn:000033F3                 add     esp, 8
.text$mn:000033F6                 pop     edi
.text$mn:000033F7                 pop     esi
.text$mn:000033F8                 pop     ebx
.text$mn:000033F9                 add     esp, 0C0h
.text$mn:000033FF                 cmp     ebp, esp
.text$mn:00003401                 call    __RTC_CheckEsp
.text$mn:00003406                 mov     esp, ebp
.text$mn:00003408                 pop     ebp
.text$mn:00003409                 retn
.text$mn:00003409 ?Find@str@@YAPB_WPB_W0@Z endp
.text$mn:00003409
.text$mn:00003409 ; ---------------------------------------------------------------------------
.text$mn:0000340A                 align 4
.text$mn:0000340A _text$mn        ends
.text$mn:0000340A
.text$mn:0000340C ; ===========================================================================
.text$mn:0000340C
.text$mn:0000340C ; Segment type: Pure code
.text$mn:0000340C ; Segment permissions: Read/Execute
.text$mn:0000340C _text$mn        segment para public 'CODE' use32
.text$mn:0000340C                 assume cs:_text$mn
.text$mn:0000340C                 ;org 340Ch
.text$mn:0000340C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000340C
.text$mn:0000340C ; =============== S U B R O U T I N E =======================================
.text$mn:0000340C
.text$mn:0000340C ; Attributes: bp-based frame
.text$mn:0000340C
.text$mn:0000340C ; wchar_t *__cdecl str::FindChar(wchar_t *Str, wchar_t *, wchar_t)
.text$mn:0000340C                 public ?FindChar@str@@YAPA_WPA_W_W@Z
.text$mn:0000340C ?FindChar@str@@YAPA_WPA_W_W@Z proc near ; CODE XREF: SetupPluginMode(CommandLineInfo &)+185p
.text$mn:0000340C                                         ; SetupPluginMode(CommandLineInfo &)+1A6p ...
.text$mn:0000340C
.text$mn:0000340C var_C0          = byte ptr -0C0h
.text$mn:0000340C Str             = dword ptr  8
.text$mn:0000340C arg_4           = dword ptr  0Ch
.text$mn:0000340C
.text$mn:0000340C                 push    ebp
.text$mn:0000340D                 mov     ebp, esp
.text$mn:0000340F                 sub     esp, 0C0h
.text$mn:00003415                 push    ebx
.text$mn:00003416                 push    esi
.text$mn:00003417                 push    edi
.text$mn:00003418                 lea     edi, [ebp+var_C0]
.text$mn:0000341E                 mov     ecx, 30h ; '0'
.text$mn:00003423                 mov     eax, 0CCCCCCCCh
.text$mn:00003428                 rep stosd
.text$mn:0000342A                 movzx   eax, word ptr [ebp+arg_4]
.text$mn:0000342E                 push    eax             ; wchar_t
.text$mn:0000342F                 mov     ecx, [ebp+Str]
.text$mn:00003432                 push    ecx             ; Str
.text$mn:00003433                 call    ?wcschr@@YAPA_WPA_W_W@Z ; wcschr(wchar_t *,wchar_t)
.text$mn:00003438                 add     esp, 8
.text$mn:0000343B                 pop     edi
.text$mn:0000343C                 pop     esi
.text$mn:0000343D                 pop     ebx
.text$mn:0000343E                 add     esp, 0C0h
.text$mn:00003444                 cmp     ebp, esp
.text$mn:00003446                 call    __RTC_CheckEsp
.text$mn:0000344B                 mov     esp, ebp
.text$mn:0000344D                 pop     ebp
.text$mn:0000344E                 retn
.text$mn:0000344E ?FindChar@str@@YAPA_WPA_W_W@Z endp
.text$mn:0000344E
.text$mn:0000344E ; ---------------------------------------------------------------------------
.text$mn:0000344F                 align 10h
.text$mn:0000344F _text$mn        ends
.text$mn:0000344F
.text$mn:00003450 ; ===========================================================================
.text$mn:00003450
.text$mn:00003450 ; Segment type: Pure code
.text$mn:00003450 ; Segment permissions: Read/Execute
.text$mn:00003450 _text$mn        segment para public 'CODE' use32
.text$mn:00003450                 assume cs:_text$mn
.text$mn:00003450                 ;org 3450h
.text$mn:00003450                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003450
.text$mn:00003450 ; =============== S U B R O U T I N E =======================================
.text$mn:00003450
.text$mn:00003450 ; Attributes: bp-based frame
.text$mn:00003450
.text$mn:00003450 ; struct HWND__ * __cdecl FindPrevInstWindow(void * *)
.text$mn:00003450 ?FindPrevInstWindow@@YAPAUHWND__@@PAPAX@Z proc near
.text$mn:00003450                                         ; CODE XREF: WinMain(x,x,x,x)+429p
.text$mn:00003450
.text$mn:00003450 var_160         = dword ptr -160h
.text$mn:00003450 var_158         = dword ptr -158h
.text$mn:00003450 var_14C         = dword ptr -14Ch
.text$mn:00003450 var_140         = dword ptr -140h
.text$mn:00003450 dwProcessId     = dword ptr -74h
.text$mn:00003450 hWndChildAfter  = dword ptr -68h
.text$mn:00003450 var_5C          = dword ptr -5Ch
.text$mn:00003450 lpBaseAddress   = dword ptr -50h
.text$mn:00003450 var_41          = byte ptr -41h
.text$mn:00003450 hFileMappingObject= dword ptr -38h
.text$mn:00003450 var_2C          = dword ptr -2Ch
.text$mn:00003450 var_20          = byte ptr -20h
.text$mn:00003450 var_14          = dword ptr -14h
.text$mn:00003450 var_8           = byte ptr -8
.text$mn:00003450 arg_0           = dword ptr  8
.text$mn:00003450
.text$mn:00003450                 push    ebp
.text$mn:00003451                 mov     ebp, esp
.text$mn:00003453                 sub     esp, 160h
.text$mn:00003459                 push    ebx
.text$mn:0000345A                 push    esi
.text$mn:0000345B                 push    edi             ; wchar_t *
.text$mn:0000345C                 lea     edi, [ebp+var_160]
.text$mn:00003462                 mov     ecx, 58h ; 'X'
.text$mn:00003467                 mov     eax, 0CCCCCCCCh
.text$mn:0000346C                 rep stosd
.text$mn:0000346E                 call    ?GetExePath@@YAPA_WXZ ; GetExePath(void)
.text$mn:00003473                 push    eax
.text$mn:00003474                 lea     ecx, [ebp+var_8]
.text$mn:00003477                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:0000347C                 lea     ecx, [ebp+var_8]
.text$mn:0000347F                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00003484                 push    eax             ; this
.text$mn:00003485                 call    ?ToLower@str@@YAXPA_W@Z ; str::ToLower(wchar_t *)
.text$mn:0000348A                 add     esp, 4
.text$mn:0000348D                 lea     ecx, [ebp+var_8]
.text$mn:00003490                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00003495                 push    eax             ; this
.text$mn:00003496                 call    ?Len@str@@YAIPB_W@Z ; str::Len(wchar_t const *)
.text$mn:0000349B                 add     esp, 4
.text$mn:0000349E                 shl     eax, 1
.text$mn:000034A0                 push    eax             ; unsigned int
.text$mn:000034A1                 lea     ecx, [ebp+var_8]
.text$mn:000034A4                 call    ?Get@?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::Get(void)
.text$mn:000034A9                 push    eax             ; void *
.text$mn:000034AA                 call    ?MurmurHash2@@YAIPBXI@Z ; MurmurHash2(void const *,uint)
.text$mn:000034AF                 add     esp, 8
.text$mn:000034B2                 mov     [ebp+var_14], eax
.text$mn:000034B5                 mov     eax, [ebp+var_14]
.text$mn:000034B8                 push    eax             ; wchar_t *
.text$mn:000034B9                 push    offset ??_C@_1CA@IEDCKEJO@?$AAS?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAP?$AAD?$AAF?$AA?9?$AA?$CF?$AA0?$AA8?$AAx?$AA?$AA@ ; "SumatraPDF-%08x"
.text$mn:000034BE                 call    ?Format@str@@YAPA_WPB_WZZ ; str::Format(wchar_t const *,...)
.text$mn:000034C3                 add     esp, 8
.text$mn:000034C6                 push    eax
.text$mn:000034C7                 lea     ecx, [ebp+var_20]
.text$mn:000034CA                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:000034CF                 mov     [ebp+var_2C], 3
.text$mn:000034D6
.text$mn:000034D6 $Retry$19:                              ; CODE XREF: FindPrevInstWindow(void * *)+273j
.text$mn:000034D6                 lea     ecx, [ebp+var_20]
.text$mn:000034D9                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:000034DE                 mov     esi, esp
.text$mn:000034E0                 push    eax             ; lpName
.text$mn:000034E1                 push    4               ; dwMaximumSizeLow
.text$mn:000034E3                 push    0               ; dwMaximumSizeHigh
.text$mn:000034E5                 push    4               ; flProtect
.text$mn:000034E7                 push    0               ; lpFileMappingAttributes
.text$mn:000034E9                 push    0FFFFFFFFh      ; hFile
.text$mn:000034EB                 call    dword ptr ds:__imp__CreateFileMappingW@24 ; CreateFileMappingW(x,x,x,x,x,x)
.text$mn:000034F1                 cmp     esi, esp
.text$mn:000034F3                 call    __RTC_CheckEsp
.text$mn:000034F8                 mov     [ebp+hFileMappingObject], eax
.text$mn:000034FB                 cmp     [ebp+hFileMappingObject], 0
.text$mn:000034FF                 jnz     short loc_3506
.text$mn:00003501                 jmp     $Error$20
.text$mn:00003506 ; ---------------------------------------------------------------------------
.text$mn:00003506
.text$mn:00003506 loc_3506:                               ; CODE XREF: FindPrevInstWindow(void * *)+AFj
.text$mn:00003506                 mov     esi, esp
.text$mn:00003508                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text$mn:0000350E                 cmp     esi, esp
.text$mn:00003510                 call    __RTC_CheckEsp
.text$mn:00003515                 cmp     eax, 0B7h ; '+'
.text$mn:0000351A                 jnz     short loc_3528
.text$mn:0000351C                 mov     [ebp+var_160], 1
.text$mn:00003526                 jmp     short loc_3532
.text$mn:00003528 ; ---------------------------------------------------------------------------
.text$mn:00003528
.text$mn:00003528 loc_3528:                               ; CODE XREF: FindPrevInstWindow(void * *)+CAj
.text$mn:00003528                 mov     [ebp+var_160], 0
.text$mn:00003532
.text$mn:00003532 loc_3532:                               ; CODE XREF: FindPrevInstWindow(void * *)+D6j
.text$mn:00003532                 mov     al, byte ptr [ebp+var_160]
.text$mn:00003538                 mov     [ebp+var_41], al
.text$mn:0000353B                 mov     esi, esp
.text$mn:0000353D                 push    4               ; dwNumberOfBytesToMap
.text$mn:0000353F                 push    0               ; dwFileOffsetLow
.text$mn:00003541                 push    0               ; dwFileOffsetHigh
.text$mn:00003543                 push    0F001Fh         ; dwDesiredAccess
.text$mn:00003548                 mov     eax, [ebp+hFileMappingObject]
.text$mn:0000354B                 push    eax             ; hFileMappingObject
.text$mn:0000354C                 call    dword ptr ds:__imp__MapViewOfFile@20 ; MapViewOfFile(x,x,x,x,x)
.text$mn:00003552                 cmp     esi, esp
.text$mn:00003554                 call    __RTC_CheckEsp
.text$mn:00003559                 mov     [ebp+lpBaseAddress], eax
.text$mn:0000355C                 cmp     [ebp+lpBaseAddress], 0
.text$mn:00003560                 jnz     short loc_357A
.text$mn:00003562                 mov     esi, esp
.text$mn:00003564                 mov     eax, [ebp+hFileMappingObject]
.text$mn:00003567                 push    eax             ; hObject
.text$mn:00003568                 call    dword ptr ds:__imp__CloseHandle@4 ; CloseHandle(x)
.text$mn:0000356E                 cmp     esi, esp
.text$mn:00003570                 call    __RTC_CheckEsp
.text$mn:00003575                 jmp     $Error$20
.text$mn:0000357A ; ---------------------------------------------------------------------------
.text$mn:0000357A
.text$mn:0000357A loc_357A:                               ; CODE XREF: FindPrevInstWindow(void * *)+110j
.text$mn:0000357A                 movzx   eax, [ebp+var_41]
.text$mn:0000357E                 test    eax, eax
.text$mn:00003580                 jnz     short loc_35D6
.text$mn:00003582                 mov     esi, esp
.text$mn:00003584                 call    dword ptr ds:__imp__GetCurrentProcessId@0 ; GetCurrentProcessId()
.text$mn:0000358A                 cmp     esi, esp
.text$mn:0000358C                 call    __RTC_CheckEsp
.text$mn:00003591                 mov     ecx, [ebp+lpBaseAddress]
.text$mn:00003594                 mov     [ecx], eax
.text$mn:00003596                 mov     esi, esp
.text$mn:00003598                 mov     eax, [ebp+lpBaseAddress]
.text$mn:0000359B                 push    eax             ; lpBaseAddress
.text$mn:0000359C                 call    dword ptr ds:__imp__UnmapViewOfFile@4 ; UnmapViewOfFile(x)
.text$mn:000035A2                 cmp     esi, esp
.text$mn:000035A4                 call    __RTC_CheckEsp
.text$mn:000035A9                 mov     eax, [ebp+arg_0]
.text$mn:000035AC                 mov     ecx, [ebp+hFileMappingObject]
.text$mn:000035AF                 mov     [eax], ecx
.text$mn:000035B1                 mov     [ebp+var_140], 0
.text$mn:000035BB                 lea     ecx, [ebp+var_20]
.text$mn:000035BE                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000035C3                 lea     ecx, [ebp+var_8]
.text$mn:000035C6                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000035CB                 mov     eax, [ebp+var_140]
.text$mn:000035D1                 jmp     loc_36D8
.text$mn:000035D6 ; ---------------------------------------------------------------------------
.text$mn:000035D6
.text$mn:000035D6 loc_35D6:                               ; CODE XREF: FindPrevInstWindow(void * *)+130j
.text$mn:000035D6                 mov     eax, [ebp+lpBaseAddress]
.text$mn:000035D9                 mov     ecx, [eax]
.text$mn:000035DB                 mov     [ebp+var_5C], ecx
.text$mn:000035DE                 mov     esi, esp
.text$mn:000035E0                 mov     eax, [ebp+lpBaseAddress]
.text$mn:000035E3                 push    eax             ; lpBaseAddress
.text$mn:000035E4                 call    dword ptr ds:__imp__UnmapViewOfFile@4 ; UnmapViewOfFile(x)
.text$mn:000035EA                 cmp     esi, esp
.text$mn:000035EC                 call    __RTC_CheckEsp
.text$mn:000035F1                 mov     esi, esp
.text$mn:000035F3                 mov     eax, [ebp+hFileMappingObject]
.text$mn:000035F6                 push    eax             ; hObject
.text$mn:000035F7                 call    dword ptr ds:__imp__CloseHandle@4 ; CloseHandle(x)
.text$mn:000035FD                 cmp     esi, esp
.text$mn:000035FF                 call    __RTC_CheckEsp
.text$mn:00003604                 mov     [ebp+hWndChildAfter], 0
.text$mn:0000360B
.text$mn:0000360B loc_360B:                               ; CODE XREF: FindPrevInstWindow(void * *):loc_3683j
.text$mn:0000360B                 mov     esi, esp
.text$mn:0000360D                 push    0               ; lpszWindow
.text$mn:0000360F                 push    offset ??_C@_1CE@PHGKLOIF@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA_?$AAP?$AAD?$AAF?$AA_?$AAF?$AAR?$AAA?$AAM?$AAE?$AA?$AA@ ; "SUMATRA_PDF_FRAME"
.text$mn:00003614                 mov     eax, [ebp+hWndChildAfter]
.text$mn:00003617                 push    eax             ; hWndChildAfter
.text$mn:00003618                 push    0               ; hWndParent
.text$mn:0000361A                 call    dword ptr ds:__imp__FindWindowExW@16 ; FindWindowExW(x,x,x,x)
.text$mn:00003620                 cmp     esi, esp
.text$mn:00003622                 call    __RTC_CheckEsp
.text$mn:00003627                 mov     [ebp+hWndChildAfter], eax
.text$mn:0000362A                 cmp     [ebp+hWndChildAfter], 0
.text$mn:0000362E                 jz      short $Error$20
.text$mn:00003630                 mov     esi, esp
.text$mn:00003632                 lea     eax, [ebp+dwProcessId]
.text$mn:00003635                 push    eax             ; lpdwProcessId
.text$mn:00003636                 mov     ecx, [ebp+hWndChildAfter]
.text$mn:00003639                 push    ecx             ; hWnd
.text$mn:0000363A                 call    dword ptr ds:__imp__GetWindowThreadProcessId@8 ; GetWindowThreadProcessId(x,x)
.text$mn:00003640                 cmp     esi, esp
.text$mn:00003642                 call    __RTC_CheckEsp
.text$mn:00003647                 mov     eax, [ebp+dwProcessId]
.text$mn:0000364A                 cmp     eax, [ebp+var_5C]
.text$mn:0000364D                 jnz     short loc_3683
.text$mn:0000364F                 mov     esi, esp
.text$mn:00003651                 mov     eax, [ebp+var_5C]
.text$mn:00003654                 push    eax             ; dwProcessId
.text$mn:00003655                 call    dword ptr ds:__imp__AllowSetForegroundWindow@4 ; AllowSetForegroundWindow(x)
.text$mn:0000365B                 cmp     esi, esp
.text$mn:0000365D                 call    __RTC_CheckEsp
.text$mn:00003662                 mov     eax, [ebp+hWndChildAfter]
.text$mn:00003665                 mov     [ebp+var_14C], eax
.text$mn:0000366B                 lea     ecx, [ebp+var_20]
.text$mn:0000366E                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:00003673                 lea     ecx, [ebp+var_8]
.text$mn:00003676                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:0000367B                 mov     eax, [ebp+var_14C]
.text$mn:00003681                 jmp     short loc_36D8
.text$mn:00003683 ; ---------------------------------------------------------------------------
.text$mn:00003683
.text$mn:00003683 loc_3683:                               ; CODE XREF: FindPrevInstWindow(void * *)+1FDj
.text$mn:00003683                 jmp     short loc_360B
.text$mn:00003685 ; ---------------------------------------------------------------------------
.text$mn:00003685
.text$mn:00003685 $Error$20:                              ; CODE XREF: FindPrevInstWindow(void * *)+B1j
.text$mn:00003685                                         ; FindPrevInstWindow(void * *)+125j ...
.text$mn:00003685                 mov     eax, [ebp+var_2C]
.text$mn:00003688                 sub     eax, 1
.text$mn:0000368B                 mov     [ebp+var_2C], eax
.text$mn:0000368E                 jns     short loc_36B2
.text$mn:00003690                 mov     [ebp+var_158], 0
.text$mn:0000369A                 lea     ecx, [ebp+var_20]
.text$mn:0000369D                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000036A2                 lea     ecx, [ebp+var_8]
.text$mn:000036A5                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000036AA                 mov     eax, [ebp+var_158]
.text$mn:000036B0                 jmp     short loc_36D8
.text$mn:000036B2 ; ---------------------------------------------------------------------------
.text$mn:000036B2
.text$mn:000036B2 loc_36B2:                               ; CODE XREF: FindPrevInstWindow(void * *)+23Ej
.text$mn:000036B2                 mov     esi, esp
.text$mn:000036B4                 push    64h ; 'd'       ; dwMilliseconds
.text$mn:000036B6                 call    dword ptr ds:__imp__Sleep@4 ; Sleep(x)
.text$mn:000036BC                 cmp     esi, esp
.text$mn:000036BE                 call    __RTC_CheckEsp
.text$mn:000036C3                 jmp     $Retry$19
.text$mn:000036C8 ; ---------------------------------------------------------------------------
.text$mn:000036C8                 lea     ecx, [ebp+var_20]
.text$mn:000036CB                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000036D0                 lea     ecx, [ebp+var_8]
.text$mn:000036D3                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000036D8
.text$mn:000036D8 loc_36D8:                               ; CODE XREF: FindPrevInstWindow(void * *)+181j
.text$mn:000036D8                                         ; FindPrevInstWindow(void * *)+231j ...
.text$mn:000036D8                 push    edx
.text$mn:000036D9                 mov     ecx, ebp
.text$mn:000036DB                 push    eax
.text$mn:000036DC                 lea     edx, $LN18
.text$mn:000036E2                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:000036E7                 pop     eax
.text$mn:000036E8                 pop     edx
.text$mn:000036E9                 pop     edi
.text$mn:000036EA                 pop     esi
.text$mn:000036EB                 pop     ebx
.text$mn:000036EC                 add     esp, 160h
.text$mn:000036F2                 cmp     ebp, esp
.text$mn:000036F4                 call    __RTC_CheckEsp
.text$mn:000036F9                 mov     esp, ebp
.text$mn:000036FB                 pop     ebp
.text$mn:000036FC                 retn
.text$mn:000036FC ?FindPrevInstWindow@@YAPAUHWND__@@PAPAX@Z endp
.text$mn:000036FC
.text$mn:000036FC ; ---------------------------------------------------------------------------
.text$mn:000036FD                 align 10h
.text$mn:00003700 $LN18           dd 3                    ; DATA XREF: FindPrevInstWindow(void * *)+28Co
.text$mn:00003704                 dd offset $LN17
.text$mn:00003708 $LN17           dd 0FFFFFFF8h, 4        ; DATA XREF: .text$mn:00003704o
.text$mn:00003710                 dd offset $LN14_1       ; "exePath"
.text$mn:00003714                 dd 0FFFFFFE0h, 4
.text$mn:0000371C                 dd offset $LN15_0       ; "mapId"
.text$mn:00003720                 dd 0FFFFFF8Ch, 4
.text$mn:00003728                 dd offset $LN16_0       ; "wndProcId"
.text$mn:0000372C $LN16_0         db 'wndProcId',0        ; DATA XREF: .text$mn:00003728o
.text$mn:00003736 $LN15_0         db 'mapId',0            ; DATA XREF: .text$mn:0000371Co
.text$mn:0000373C $LN14_1         db 'exePath',0          ; DATA XREF: .text$mn:00003710o
.text$mn:0000373C _text$mn        ends
.text$mn:0000373C
.text$mn:00003744 ; ===========================================================================
.text$mn:00003744
.text$mn:00003744 ; Segment type: Pure code
.text$mn:00003744 ; Segment permissions: Read/Execute
.text$mn:00003744 _text$mn        segment para public 'CODE' use32
.text$mn:00003744                 assume cs:_text$mn
.text$mn:00003744                 ;org 3744h
.text$mn:00003744                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003744
.text$mn:00003744 ; =============== S U B R O U T I N E =======================================
.text$mn:00003744
.text$mn:00003744 ; Attributes: bp-based frame
.text$mn:00003744
.text$mn:00003744 ; protected: void __thiscall Vec<struct FileState *>::FreeEls(void)
.text$mn:00003744                 public ?FreeEls@?$Vec@PAUFileState@@@@IAEXXZ
.text$mn:00003744 ?FreeEls@?$Vec@PAUFileState@@@@IAEXXZ proc near
.text$mn:00003744                                         ; CODE XREF: Vec<FileState *>::~Vec<FileState *>(void)+26p
.text$mn:00003744                                         ; Vec<FileState *>::Reset(void)+39p
.text$mn:00003744
.text$mn:00003744 var_CC          = byte ptr -0CCh
.text$mn:00003744 var_8           = dword ptr -8
.text$mn:00003744
.text$mn:00003744                 push    ebp
.text$mn:00003745                 mov     ebp, esp
.text$mn:00003747                 sub     esp, 0CCh
.text$mn:0000374D                 push    ebx
.text$mn:0000374E                 push    esi
.text$mn:0000374F                 push    edi
.text$mn:00003750                 push    ecx
.text$mn:00003751                 lea     edi, [ebp+var_CC]
.text$mn:00003757                 mov     ecx, 33h ; '3'
.text$mn:0000375C                 mov     eax, 0CCCCCCCCh
.text$mn:00003761                 rep stosd
.text$mn:00003763                 pop     ecx
.text$mn:00003764                 mov     [ebp+var_8], ecx
.text$mn:00003767                 mov     eax, [ebp+var_8]
.text$mn:0000376A                 add     eax, 10h
.text$mn:0000376D                 mov     ecx, [ebp+var_8]
.text$mn:00003770                 cmp     [ecx+0Ch], eax
.text$mn:00003773                 jz      short loc_378B
.text$mn:00003775                 mov     eax, [ebp+var_8]
.text$mn:00003778                 mov     ecx, [eax+0Ch]
.text$mn:0000377B                 push    ecx             ; void *
.text$mn:0000377C                 mov     edx, [ebp+var_8]
.text$mn:0000377F                 mov     eax, [edx+50h]
.text$mn:00003782                 push    eax             ; struct Allocator *
.text$mn:00003783                 call    ?Free@Allocator@@SAXPAV1@PAX@Z ; Allocator::Free(Allocator *,void *)
.text$mn:00003788                 add     esp, 8
.text$mn:0000378B
.text$mn:0000378B loc_378B:                               ; CODE XREF: Vec<FileState *>::FreeEls(void)+2Fj
.text$mn:0000378B                 pop     edi
.text$mn:0000378C                 pop     esi
.text$mn:0000378D                 pop     ebx
.text$mn:0000378E                 add     esp, 0CCh
.text$mn:00003794                 cmp     ebp, esp
.text$mn:00003796                 call    __RTC_CheckEsp
.text$mn:0000379B                 mov     esp, ebp
.text$mn:0000379D                 pop     ebp
.text$mn:0000379E                 retn
.text$mn:0000379E ?FreeEls@?$Vec@PAUFileState@@@@IAEXXZ endp
.text$mn:0000379E
.text$mn:0000379E ; ---------------------------------------------------------------------------
.text$mn:0000379F                 align 10h
.text$mn:0000379F _text$mn        ends
.text$mn:0000379F
.text$mn:000037A0 ; ===========================================================================
.text$mn:000037A0
.text$mn:000037A0 ; Segment type: Pure code
.text$mn:000037A0 ; Segment permissions: Read/Execute
.text$mn:000037A0 _text$mn        segment para public 'CODE' use32
.text$mn:000037A0                 assume cs:_text$mn
.text$mn:000037A0                 ;org 37A0h
.text$mn:000037A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037A0
.text$mn:000037A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000037A0
.text$mn:000037A0 ; Attributes: bp-based frame
.text$mn:000037A0
.text$mn:000037A0 ; protected: void __thiscall Vec<wchar_t *>::FreeEls(void)
.text$mn:000037A0                 public ?FreeEls@?$Vec@PA_W@@IAEXXZ
.text$mn:000037A0 ?FreeEls@?$Vec@PA_W@@IAEXXZ proc near   ; CODE XREF: Vec<wchar_t *>::~Vec<wchar_t *>(void)+26p
.text$mn:000037A0                                         ; Vec<wchar_t *>::Reset(void)+39p
.text$mn:000037A0
.text$mn:000037A0 var_CC          = byte ptr -0CCh
.text$mn:000037A0 var_8           = dword ptr -8
.text$mn:000037A0
.text$mn:000037A0                 push    ebp
.text$mn:000037A1                 mov     ebp, esp
.text$mn:000037A3                 sub     esp, 0CCh
.text$mn:000037A9                 push    ebx
.text$mn:000037AA                 push    esi
.text$mn:000037AB                 push    edi
.text$mn:000037AC                 push    ecx
.text$mn:000037AD                 lea     edi, [ebp+var_CC]
.text$mn:000037B3                 mov     ecx, 33h ; '3'
.text$mn:000037B8                 mov     eax, 0CCCCCCCCh
.text$mn:000037BD                 rep stosd
.text$mn:000037BF                 pop     ecx
.text$mn:000037C0                 mov     [ebp+var_8], ecx
.text$mn:000037C3                 mov     eax, [ebp+var_8]
.text$mn:000037C6                 add     eax, 10h
.text$mn:000037C9                 mov     ecx, [ebp+var_8]
.text$mn:000037CC                 cmp     [ecx+0Ch], eax
.text$mn:000037CF                 jz      short loc_37E7
.text$mn:000037D1                 mov     eax, [ebp+var_8]
.text$mn:000037D4                 mov     ecx, [eax+0Ch]
.text$mn:000037D7                 push    ecx             ; void *
.text$mn:000037D8                 mov     edx, [ebp+var_8]
.text$mn:000037DB                 mov     eax, [edx+50h]
.text$mn:000037DE                 push    eax             ; struct Allocator *
.text$mn:000037DF                 call    ?Free@Allocator@@SAXPAV1@PAX@Z ; Allocator::Free(Allocator *,void *)
.text$mn:000037E4                 add     esp, 8
.text$mn:000037E7
.text$mn:000037E7 loc_37E7:                               ; CODE XREF: Vec<wchar_t *>::FreeEls(void)+2Fj
.text$mn:000037E7                 pop     edi
.text$mn:000037E8                 pop     esi
.text$mn:000037E9                 pop     ebx
.text$mn:000037EA                 add     esp, 0CCh
.text$mn:000037F0                 cmp     ebp, esp
.text$mn:000037F2                 call    __RTC_CheckEsp
.text$mn:000037F7                 mov     esp, ebp
.text$mn:000037F9                 pop     ebp
.text$mn:000037FA                 retn
.text$mn:000037FA ?FreeEls@?$Vec@PA_W@@IAEXXZ endp
.text$mn:000037FA
.text$mn:000037FA ; ---------------------------------------------------------------------------
.text$mn:000037FB                 align 4
.text$mn:000037FB _text$mn        ends
.text$mn:000037FB
.text$mn:000037FC ; ===========================================================================
.text$mn:000037FC
.text$mn:000037FC ; Segment type: Pure code
.text$mn:000037FC ; Segment permissions: Read/Execute
.text$mn:000037FC _text$mn        segment para public 'CODE' use32
.text$mn:000037FC                 assume cs:_text$mn
.text$mn:000037FC                 ;org 37FCh
.text$mn:000037FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037FC
.text$mn:000037FC ; =============== S U B R O U T I N E =======================================
.text$mn:000037FC
.text$mn:000037FC ; Attributes: bp-based frame
.text$mn:000037FC
.text$mn:000037FC ; protected: void __thiscall Vec<class geomutil::RectT<int>>::FreeEls(void)
.text$mn:000037FC                 public ?FreeEls@?$Vec@V?$RectT@H@geomutil@@@@IAEXXZ
.text$mn:000037FC ?FreeEls@?$Vec@V?$RectT@H@geomutil@@@@IAEXXZ proc near
.text$mn:000037FC                                         ; CODE XREF: Vec<geomutil::RectT<int>>::~Vec<geomutil::RectT<int>>(void)+26p
.text$mn:000037FC                                         ; Vec<geomutil::RectT<int>>::Reset(void)+39p
.text$mn:000037FC
.text$mn:000037FC var_CC          = byte ptr -0CCh
.text$mn:000037FC var_8           = dword ptr -8
.text$mn:000037FC
.text$mn:000037FC                 push    ebp
.text$mn:000037FD                 mov     ebp, esp
.text$mn:000037FF                 sub     esp, 0CCh
.text$mn:00003805                 push    ebx
.text$mn:00003806                 push    esi
.text$mn:00003807                 push    edi
.text$mn:00003808                 push    ecx
.text$mn:00003809                 lea     edi, [ebp+var_CC]
.text$mn:0000380F                 mov     ecx, 33h ; '3'
.text$mn:00003814                 mov     eax, 0CCCCCCCCh
.text$mn:00003819                 rep stosd
.text$mn:0000381B                 pop     ecx
.text$mn:0000381C                 mov     [ebp+var_8], ecx
.text$mn:0000381F                 mov     eax, [ebp+var_8]
.text$mn:00003822                 add     eax, 10h
.text$mn:00003825                 mov     ecx, [ebp+var_8]
.text$mn:00003828                 cmp     [ecx+0Ch], eax
.text$mn:0000382B                 jz      short loc_3846
.text$mn:0000382D                 mov     eax, [ebp+var_8]
.text$mn:00003830                 mov     ecx, [eax+0Ch]
.text$mn:00003833                 push    ecx             ; void *
.text$mn:00003834                 mov     edx, [ebp+var_8]
.text$mn:00003837                 mov     eax, [edx+110h]
.text$mn:0000383D                 push    eax             ; struct Allocator *
.text$mn:0000383E                 call    ?Free@Allocator@@SAXPAV1@PAX@Z ; Allocator::Free(Allocator *,void *)
.text$mn:00003843                 add     esp, 8
.text$mn:00003846
.text$mn:00003846 loc_3846:                               ; CODE XREF: Vec<geomutil::RectT<int>>::FreeEls(void)+2Fj
.text$mn:00003846                 pop     edi
.text$mn:00003847                 pop     esi
.text$mn:00003848                 pop     ebx
.text$mn:00003849                 add     esp, 0CCh
.text$mn:0000384F                 cmp     ebp, esp
.text$mn:00003851                 call    __RTC_CheckEsp
.text$mn:00003856                 mov     esp, ebp
.text$mn:00003858                 pop     ebp
.text$mn:00003859                 retn
.text$mn:00003859 ?FreeEls@?$Vec@V?$RectT@H@geomutil@@@@IAEXXZ endp
.text$mn:00003859
.text$mn:00003859 ; ---------------------------------------------------------------------------
.text$mn:0000385A                 align 4
.text$mn:0000385A _text$mn        ends
.text$mn:0000385A
.text$mn:0000385C ; ===========================================================================
.text$mn:0000385C
.text$mn:0000385C ; Segment type: Pure code
.text$mn:0000385C ; Segment permissions: Read/Execute
.text$mn:0000385C _text$mn        segment para public 'CODE' use32
.text$mn:0000385C                 assume cs:_text$mn
.text$mn:0000385C                 ;org 385Ch
.text$mn:0000385C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000385C
.text$mn:0000385C ; =============== S U B R O U T I N E =======================================
.text$mn:0000385C
.text$mn:0000385C ; Attributes: bp-based frame
.text$mn:0000385C
.text$mn:0000385C ; protected: void __thiscall Vec<wchar_t>::FreeEls(void)
.text$mn:0000385C                 public ?FreeEls@?$Vec@_W@@IAEXXZ
.text$mn:0000385C ?FreeEls@?$Vec@_W@@IAEXXZ proc near     ; CODE XREF: Vec<wchar_t>::~Vec<wchar_t>(void)+26p
.text$mn:0000385C                                         ; Vec<wchar_t>::Reset(void)+39p
.text$mn:0000385C
.text$mn:0000385C var_CC          = byte ptr -0CCh
.text$mn:0000385C var_8           = dword ptr -8
.text$mn:0000385C
.text$mn:0000385C                 push    ebp
.text$mn:0000385D                 mov     ebp, esp
.text$mn:0000385F                 sub     esp, 0CCh
.text$mn:00003865                 push    ebx
.text$mn:00003866                 push    esi
.text$mn:00003867                 push    edi
.text$mn:00003868                 push    ecx
.text$mn:00003869                 lea     edi, [ebp+var_CC]
.text$mn:0000386F                 mov     ecx, 33h ; '3'
.text$mn:00003874                 mov     eax, 0CCCCCCCCh
.text$mn:00003879                 rep stosd
.text$mn:0000387B                 pop     ecx
.text$mn:0000387C                 mov     [ebp+var_8], ecx
.text$mn:0000387F                 mov     eax, [ebp+var_8]
.text$mn:00003882                 add     eax, 10h
.text$mn:00003885                 mov     ecx, [ebp+var_8]
.text$mn:00003888                 cmp     [ecx+0Ch], eax
.text$mn:0000388B                 jz      short loc_38A3
.text$mn:0000388D                 mov     eax, [ebp+var_8]
.text$mn:00003890                 mov     ecx, [eax+0Ch]
.text$mn:00003893                 push    ecx             ; void *
.text$mn:00003894                 mov     edx, [ebp+var_8]
.text$mn:00003897                 mov     eax, [edx+30h]
.text$mn:0000389A                 push    eax             ; struct Allocator *
.text$mn:0000389B                 call    ?Free@Allocator@@SAXPAV1@PAX@Z ; Allocator::Free(Allocator *,void *)
.text$mn:000038A0                 add     esp, 8
.text$mn:000038A3
.text$mn:000038A3 loc_38A3:                               ; CODE XREF: Vec<wchar_t>::FreeEls(void)+2Fj
.text$mn:000038A3                 pop     edi
.text$mn:000038A4                 pop     esi
.text$mn:000038A5                 pop     ebx
.text$mn:000038A6                 add     esp, 0CCh
.text$mn:000038AC                 cmp     ebp, esp
.text$mn:000038AE                 call    __RTC_CheckEsp
.text$mn:000038B3                 mov     esp, ebp
.text$mn:000038B5                 pop     ebp
.text$mn:000038B6                 retn
.text$mn:000038B6 ?FreeEls@?$Vec@_W@@IAEXXZ endp
.text$mn:000038B6
.text$mn:000038B6 ; ---------------------------------------------------------------------------
.text$mn:000038B7                 align 4
.text$mn:000038B7 _text$mn        ends
.text$mn:000038B7
.text$mn:000038B8 ; ===========================================================================
.text$mn:000038B8
.text$mn:000038B8 ; Segment type: Pure code
.text$mn:000038B8 ; Segment permissions: Read/Execute
.text$mn:000038B8 _text$mn        segment para public 'CODE' use32
.text$mn:000038B8                 assume cs:_text$mn
.text$mn:000038B8                 ;org 38B8h
.text$mn:000038B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038B8
.text$mn:000038B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038B8
.text$mn:000038B8 ; Attributes: bp-based frame
.text$mn:000038B8
.text$mn:000038B8 ; public: void __thiscall Vec<wchar_t *>::FreeMembers(void)
.text$mn:000038B8                 public ?FreeMembers@?$Vec@PA_W@@QAEXXZ
.text$mn:000038B8 ?FreeMembers@?$Vec@PA_W@@QAEXXZ proc near
.text$mn:000038B8                                         ; CODE XREF: WStrVec::~WStrVec(void)+26p
.text$mn:000038B8                                         ; WinMain(x,x,x,x)+62Bp
.text$mn:000038B8
.text$mn:000038B8 var_E4          = byte ptr -0E4h
.text$mn:000038B8 var_20          = dword ptr -20h
.text$mn:000038B8 var_14          = dword ptr -14h
.text$mn:000038B8 var_8           = dword ptr -8
.text$mn:000038B8
.text$mn:000038B8                 push    ebp
.text$mn:000038B9                 mov     ebp, esp
.text$mn:000038BB                 sub     esp, 0E4h
.text$mn:000038C1                 push    ebx
.text$mn:000038C2                 push    esi
.text$mn:000038C3                 push    edi
.text$mn:000038C4                 push    ecx
.text$mn:000038C5                 lea     edi, [ebp+var_E4]
.text$mn:000038CB                 mov     ecx, 39h ; '9'
.text$mn:000038D0                 mov     eax, 0CCCCCCCCh
.text$mn:000038D5                 rep stosd
.text$mn:000038D7                 pop     ecx
.text$mn:000038D8                 mov     [ebp+var_8], ecx
.text$mn:000038DB                 mov     [ebp+var_14], 0
.text$mn:000038E2                 jmp     short loc_38ED
.text$mn:000038E4 ; ---------------------------------------------------------------------------
.text$mn:000038E4
.text$mn:000038E4 loc_38E4:                               ; CODE XREF: Vec<wchar_t *>::FreeMembers(void)+5Cj
.text$mn:000038E4                 mov     eax, [ebp+var_14]
.text$mn:000038E7                 add     eax, 1
.text$mn:000038EA                 mov     [ebp+var_14], eax
.text$mn:000038ED
.text$mn:000038ED loc_38ED:                               ; CODE XREF: Vec<wchar_t *>::FreeMembers(void)+2Aj
.text$mn:000038ED                 mov     eax, [ebp+var_8]
.text$mn:000038F0                 mov     ecx, [ebp+var_14]
.text$mn:000038F3                 cmp     ecx, [eax]
.text$mn:000038F5                 jnb     short loc_3916
.text$mn:000038F7                 mov     eax, [ebp+var_8]
.text$mn:000038FA                 mov     ecx, [eax+0Ch]
.text$mn:000038FD                 mov     edx, [ebp+var_14]
.text$mn:00003900                 mov     eax, [ecx+edx*4]
.text$mn:00003903                 mov     [ebp+var_20], eax
.text$mn:00003906                 push    1
.text$mn:00003908                 mov     eax, [ebp+var_20]
.text$mn:0000390B                 push    eax
.text$mn:0000390C                 call    __free_dbg
.text$mn:00003911                 add     esp, 8
.text$mn:00003914                 jmp     short loc_38E4
.text$mn:00003916 ; ---------------------------------------------------------------------------
.text$mn:00003916
.text$mn:00003916 loc_3916:                               ; CODE XREF: Vec<wchar_t *>::FreeMembers(void)+3Dj
.text$mn:00003916                 mov     ecx, [ebp+var_8]
.text$mn:00003919                 call    ?Reset@?$Vec@PA_W@@QAEXXZ ; Vec<wchar_t *>::Reset(void)
.text$mn:0000391E                 pop     edi
.text$mn:0000391F                 pop     esi
.text$mn:00003920                 pop     ebx
.text$mn:00003921                 add     esp, 0E4h
.text$mn:00003927                 cmp     ebp, esp
.text$mn:00003929                 call    __RTC_CheckEsp
.text$mn:0000392E                 mov     esp, ebp
.text$mn:00003930                 pop     ebp
.text$mn:00003931                 retn
.text$mn:00003931 ?FreeMembers@?$Vec@PA_W@@QAEXXZ endp
.text$mn:00003931
.text$mn:00003931 ; ---------------------------------------------------------------------------
.text$mn:00003932                 align 4
.text$mn:00003932 _text$mn        ends
.text$mn:00003932
.text$mn:00003934 ; ===========================================================================
.text$mn:00003934
.text$mn:00003934 ; Segment type: Pure code
.text$mn:00003934 ; Segment permissions: Read/Execute
.text$mn:00003934 _text$mn        segment para public 'CODE' use32
.text$mn:00003934                 assume cs:_text$mn
.text$mn:00003934                 ;org 3934h
.text$mn:00003934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003934
.text$mn:00003934 ; =============== S U B R O U T I N E =======================================
.text$mn:00003934
.text$mn:00003934 ; Attributes: bp-based frame
.text$mn:00003934
.text$mn:00003934 ; public: wchar_t * __thiscall ScopedMem<wchar_t>::Get(void)const
.text$mn:00003934                 public ?Get@?$ScopedMem@_W@@QBEPA_WXZ
.text$mn:00003934 ?Get@?$ScopedMem@_W@@QBEPA_WXZ proc near
.text$mn:00003934                                         ; CODE XREF: FindPrevInstWindow(void * *)+54p
.text$mn:00003934
.text$mn:00003934 var_CC          = byte ptr -0CCh
.text$mn:00003934 var_8           = dword ptr -8
.text$mn:00003934
.text$mn:00003934                 push    ebp
.text$mn:00003935                 mov     ebp, esp
.text$mn:00003937                 sub     esp, 0CCh
.text$mn:0000393D                 push    ebx
.text$mn:0000393E                 push    esi
.text$mn:0000393F                 push    edi
.text$mn:00003940                 push    ecx
.text$mn:00003941                 lea     edi, [ebp+var_CC]
.text$mn:00003947                 mov     ecx, 33h ; '3'
.text$mn:0000394C                 mov     eax, 0CCCCCCCCh
.text$mn:00003951                 rep stosd
.text$mn:00003953                 pop     ecx
.text$mn:00003954                 mov     [ebp+var_8], ecx
.text$mn:00003957                 mov     eax, [ebp+var_8]
.text$mn:0000395A                 mov     eax, [eax]
.text$mn:0000395C                 pop     edi
.text$mn:0000395D                 pop     esi
.text$mn:0000395E                 pop     ebx
.text$mn:0000395F                 mov     esp, ebp
.text$mn:00003961                 pop     ebp
.text$mn:00003962                 retn
.text$mn:00003962 ?Get@?$ScopedMem@_W@@QBEPA_WXZ endp
.text$mn:00003962
.text$mn:00003962 ; ---------------------------------------------------------------------------
.text$mn:00003963                 align 4
.text$mn:00003963 _text$mn        ends
.text$mn:00003963
.text$mn:00003964 ; ===========================================================================
.text$mn:00003964
.text$mn:00003964 ; Segment type: Pure code
.text$mn:00003964 ; Segment permissions: Read/Execute
.text$mn:00003964 _text$mn        segment para public 'CODE' use32
.text$mn:00003964                 assume cs:_text$mn
.text$mn:00003964                 ;org 3964h
.text$mn:00003964                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003964
.text$mn:00003964 ; =============== S U B R O U T I N E =======================================
.text$mn:00003964
.text$mn:00003964 ; Attributes: bp-based frame
.text$mn:00003964
.text$mn:00003964 ; public: wchar_t * __thiscall str::Str<wchar_t>::Get(void)const
.text$mn:00003964                 public ?Get@?$Str@_W@str@@QBEPA_WXZ
.text$mn:00003964 ?Get@?$Str@_W@str@@QBEPA_WXZ proc near  ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+23Dp
.text$mn:00003964                                         ; OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+288p
.text$mn:00003964
.text$mn:00003964 var_CC          = byte ptr -0CCh
.text$mn:00003964 var_8           = dword ptr -8
.text$mn:00003964
.text$mn:00003964                 push    ebp
.text$mn:00003965                 mov     ebp, esp
.text$mn:00003967                 sub     esp, 0CCh
.text$mn:0000396D                 push    ebx
.text$mn:0000396E                 push    esi
.text$mn:0000396F                 push    edi
.text$mn:00003970                 push    ecx
.text$mn:00003971                 lea     edi, [ebp+var_CC]
.text$mn:00003977                 mov     ecx, 33h ; '3'
.text$mn:0000397C                 mov     eax, 0CCCCCCCCh
.text$mn:00003981                 rep stosd
.text$mn:00003983                 pop     ecx
.text$mn:00003984                 mov     [ebp+var_8], ecx
.text$mn:00003987                 mov     eax, [ebp+var_8]
.text$mn:0000398A                 mov     eax, [eax+0Ch]
.text$mn:0000398D                 pop     edi
.text$mn:0000398E                 pop     esi
.text$mn:0000398F                 pop     ebx
.text$mn:00003990                 mov     esp, ebp
.text$mn:00003992                 pop     ebp
.text$mn:00003993                 retn
.text$mn:00003993 ?Get@?$Str@_W@str@@QBEPA_WXZ endp
.text$mn:00003993
.text$mn:00003993 _text$mn        ends
.text$mn:00003993
.text$mn:00003994 ; ===========================================================================
.text$mn:00003994
.text$mn:00003994 ; Segment type: Pure code
.text$mn:00003994 ; Segment permissions: Read/Execute
.text$mn:00003994 _text$mn        segment para public 'CODE' use32
.text$mn:00003994                 assume cs:_text$mn
.text$mn:00003994                 ;org 3994h
.text$mn:00003994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003994
.text$mn:00003994 ; =============== S U B R O U T I N E =======================================
.text$mn:00003994
.text$mn:00003994 ; Attributes: bp-based frame
.text$mn:00003994
.text$mn:00003994 ; unsigned __int32 __cdecl GetAboutBgColor()
.text$mn:00003994                 public ?GetAboutBgColor@@YAKXZ
.text$mn:00003994 ?GetAboutBgColor@@YAKXZ proc near       ; CODE XREF: GetLogoBgColor(void)+1Ep
.text$mn:00003994
.text$mn:00003994 var_CC          = byte ptr -0CCh
.text$mn:00003994 var_8           = dword ptr -8
.text$mn:00003994
.text$mn:00003994                 push    ebp
.text$mn:00003995                 mov     ebp, esp
.text$mn:00003997                 sub     esp, 0CCh
.text$mn:0000399D                 push    ebx
.text$mn:0000399E                 push    esi
.text$mn:0000399F                 push    edi
.text$mn:000039A0                 lea     edi, [ebp+var_CC]
.text$mn:000039A6                 mov     ecx, 33h ; '3'
.text$mn:000039AB                 mov     eax, 0CCCCCCCCh
.text$mn:000039B0                 rep stosd
.text$mn:000039B2                 mov     [ebp+var_8], 0F2F2F2h
.text$mn:000039B9                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:000039BE                 cmp     dword ptr [eax], 8000F2FFh
.text$mn:000039C4                 jz      short loc_39D0
.text$mn:000039C6                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:000039CB                 mov     ecx, [eax]
.text$mn:000039CD                 mov     [ebp+var_8], ecx
.text$mn:000039D0
.text$mn:000039D0 loc_39D0:                               ; CODE XREF: GetAboutBgColor(void)+30j
.text$mn:000039D0                 mov     eax, [ebp+var_8]
.text$mn:000039D3                 pop     edi
.text$mn:000039D4                 pop     esi
.text$mn:000039D5                 pop     ebx
.text$mn:000039D6                 mov     esp, ebp
.text$mn:000039D8                 pop     ebp
.text$mn:000039D9                 retn
.text$mn:000039D9 ?GetAboutBgColor@@YAKXZ endp
.text$mn:000039D9
.text$mn:000039D9 ; ---------------------------------------------------------------------------
.text$mn:000039DA                 align 4
.text$mn:000039DA _text$mn        ends
.text$mn:000039DA
.text$mn:000039DC ; ===========================================================================
.text$mn:000039DC
.text$mn:000039DC ; Segment type: Pure code
.text$mn:000039DC ; Segment permissions: Read/Execute
.text$mn:000039DC _text$mn        segment para public 'CODE' use32
.text$mn:000039DC                 assume cs:_text$mn
.text$mn:000039DC                 ;org 39DCh
.text$mn:000039DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039DC
.text$mn:000039DC ; =============== S U B R O U T I N E =======================================
.text$mn:000039DC
.text$mn:000039DC ; Attributes: bp-based frame
.text$mn:000039DC
.text$mn:000039DC ; void __thiscall FileExistenceChecker::GetFilePathsToCheck(FileExistenceChecker *__hidden this)
.text$mn:000039DC                 public ?GetFilePathsToCheck@FileExistenceChecker@@AAEXXZ
.text$mn:000039DC ?GetFilePathsToCheck@FileExistenceChecker@@AAEXXZ proc near
.text$mn:000039DC                                         ; CODE XREF: FileExistenceChecker::FileExistenceChecker(void)+44p
.text$mn:000039DC
.text$mn:000039DC var_164         = byte ptr -164h
.text$mn:000039DC var_160         = dword ptr -160h
.text$mn:000039DC var_154         = dword ptr -154h
.text$mn:000039DC var_88          = dword ptr -88h
.text$mn:000039DC var_7C          = byte ptr -7Ch
.text$mn:000039DC var_20          = dword ptr -20h
.text$mn:000039DC var_14          = dword ptr -14h
.text$mn:000039DC var_8           = dword ptr -8
.text$mn:000039DC
.text$mn:000039DC                 push    ebp
.text$mn:000039DD                 mov     ebp, esp
.text$mn:000039DF                 sub     esp, 164h
.text$mn:000039E5                 push    ebx
.text$mn:000039E6                 push    esi
.text$mn:000039E7                 push    edi
.text$mn:000039E8                 push    ecx
.text$mn:000039E9                 lea     edi, [ebp+var_164]
.text$mn:000039EF                 mov     ecx, 59h ; 'Y'
.text$mn:000039F4                 mov     eax, 0CCCCCCCCh
.text$mn:000039F9                 rep stosd
.text$mn:000039FB                 pop     ecx
.text$mn:000039FC                 mov     [ebp+var_8], ecx
.text$mn:000039FF                 mov     [ebp+var_20], 0
.text$mn:00003A06                 jmp     short loc_3A11
.text$mn:00003A08 ; ---------------------------------------------------------------------------
.text$mn:00003A08
.text$mn:00003A08 loc_3A08:                               ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void):loc_3A5Fj
.text$mn:00003A08                 mov     eax, [ebp+var_20]
.text$mn:00003A0B                 add     eax, 1
.text$mn:00003A0E                 mov     [ebp+var_20], eax
.text$mn:00003A11
.text$mn:00003A11 loc_3A11:                               ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+2Aj
.text$mn:00003A11                 cmp     [ebp+var_20], 14h
.text$mn:00003A15                 jnb     short loc_3A61
.text$mn:00003A17                 mov     eax, [ebp+var_20]
.text$mn:00003A1A                 push    eax             ; unsigned int
.text$mn:00003A1B                 mov     ecx, offset ?gFileHistory@@3VFileHistory@@A ; this
.text$mn:00003A20                 call    ?Get@FileHistory@@QBEPAUFileState@@I@Z ; FileHistory::Get(uint)
.text$mn:00003A25                 mov     [ebp+var_14], eax
.text$mn:00003A28                 cmp     [ebp+var_14], 0
.text$mn:00003A2C                 jz      short loc_3A61
.text$mn:00003A2E                 mov     eax, [ebp+var_14]
.text$mn:00003A31                 movzx   ecx, byte ptr [eax+9]
.text$mn:00003A35                 test    ecx, ecx
.text$mn:00003A37                 jnz     short loc_3A5F
.text$mn:00003A39                 mov     eax, [ebp+var_14]
.text$mn:00003A3C                 mov     ecx, [eax]
.text$mn:00003A3E                 push    ecx             ; this
.text$mn:00003A3F                 call    ?Dup@str@@YAPA_WPB_W@Z ; str::Dup(wchar_t const *)
.text$mn:00003A44                 add     esp, 4
.text$mn:00003A47                 mov     [ebp+var_154], eax
.text$mn:00003A4D                 lea     edx, [ebp+var_154]
.text$mn:00003A53                 push    edx
.text$mn:00003A54                 mov     ecx, [ebp+var_8]
.text$mn:00003A57                 add     ecx, 14h
.text$mn:00003A5A                 call    ?Append@?$Vec@PA_W@@QAEXABQA_W@Z ; Vec<wchar_t *>::Append(wchar_t * const &)
.text$mn:00003A5F
.text$mn:00003A5F loc_3A5F:                               ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+5Bj
.text$mn:00003A5F                 jmp     short loc_3A08
.text$mn:00003A61 ; ---------------------------------------------------------------------------
.text$mn:00003A61
.text$mn:00003A61 loc_3A61:                               ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+39j
.text$mn:00003A61                                         ; FileExistenceChecker::GetFilePathsToCheck(void)+50j
.text$mn:00003A61                 push    0
.text$mn:00003A63                 push    0
.text$mn:00003A65                 lea     ecx, [ebp+var_7C]
.text$mn:00003A68                 call    ??0?$Vec@PAUFileState@@@@QAE@IPAVAllocator@@@Z ; Vec<FileState *>::Vec<FileState *>(uint,Allocator *)
.text$mn:00003A6D                 lea     eax, [ebp+var_7C]
.text$mn:00003A70                 push    eax
.text$mn:00003A71                 mov     ecx, offset ?gFileHistory@@3VFileHistory@@A ; FileHistory gFileHistory
.text$mn:00003A76                 call    ?GetFrequencyOrder@FileHistory@@QAEXAAV?$Vec@PAUFileState@@@@@Z ; FileHistory::GetFrequencyOrder(Vec<FileState *> &)
.text$mn:00003A7B                 mov     [ebp+var_88], 0
.text$mn:00003A85                 jmp     short loc_3A96
.text$mn:00003A87 ; ---------------------------------------------------------------------------
.text$mn:00003A87
.text$mn:00003A87 loc_3A87:                               ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void):loc_3B01j
.text$mn:00003A87                 mov     eax, [ebp+var_88]
.text$mn:00003A8D                 add     eax, 1
.text$mn:00003A90                 mov     [ebp+var_88], eax
.text$mn:00003A96
.text$mn:00003A96 loc_3A96:                               ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+A9j
.text$mn:00003A96                 cmp     [ebp+var_88], 14h
.text$mn:00003A9D                 jnb     short loc_3B03
.text$mn:00003A9F                 lea     ecx, [ebp+var_7C]
.text$mn:00003AA2                 call    ?Count@?$Vec@PAUFileState@@@@QBEIXZ ; Vec<FileState *>::Count(void)
.text$mn:00003AA7                 cmp     [ebp+var_88], eax
.text$mn:00003AAD                 jnb     short loc_3B03
.text$mn:00003AAF                 mov     eax, [ebp+var_88]
.text$mn:00003AB5                 push    eax
.text$mn:00003AB6                 lea     ecx, [ebp+var_7C]
.text$mn:00003AB9                 call    ?At@?$Vec@PAUFileState@@@@QBEAAPAUFileState@@I@Z ; Vec<FileState *>::At(uint)
.text$mn:00003ABE                 mov     ecx, [eax]
.text$mn:00003AC0                 mov     [ebp+var_14], ecx
.text$mn:00003AC3                 mov     eax, [ebp+var_14]
.text$mn:00003AC6                 mov     ecx, [eax]
.text$mn:00003AC8                 push    ecx             ; wchar_t *
.text$mn:00003AC9                 mov     ecx, [ebp+var_8]
.text$mn:00003ACC                 add     ecx, 14h        ; this
.text$mn:00003ACF                 call    ?Contains@WStrVec@@QBE_NPB_W@Z ; WStrVec::Contains(wchar_t const *)
.text$mn:00003AD4                 movzx   edx, al
.text$mn:00003AD7                 test    edx, edx
.text$mn:00003AD9                 jnz     short loc_3B01
.text$mn:00003ADB                 mov     eax, [ebp+var_14]
.text$mn:00003ADE                 mov     ecx, [eax]
.text$mn:00003AE0                 push    ecx             ; this
.text$mn:00003AE1                 call    ?Dup@str@@YAPA_WPB_W@Z ; str::Dup(wchar_t const *)
.text$mn:00003AE6                 add     esp, 4
.text$mn:00003AE9                 mov     [ebp+var_160], eax
.text$mn:00003AEF                 lea     edx, [ebp+var_160]
.text$mn:00003AF5                 push    edx
.text$mn:00003AF6                 mov     ecx, [ebp+var_8]
.text$mn:00003AF9                 add     ecx, 14h
.text$mn:00003AFC                 call    ?Append@?$Vec@PA_W@@QAEXABQA_W@Z ; Vec<wchar_t *>::Append(wchar_t * const &)
.text$mn:00003B01
.text$mn:00003B01 loc_3B01:                               ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+FDj
.text$mn:00003B01                 jmp     short loc_3A87
.text$mn:00003B03 ; ---------------------------------------------------------------------------
.text$mn:00003B03
.text$mn:00003B03 loc_3B03:                               ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+C1j
.text$mn:00003B03                                         ; FileExistenceChecker::GetFilePathsToCheck(void)+D1j
.text$mn:00003B03                 lea     ecx, [ebp+var_7C]
.text$mn:00003B06                 call    ??1?$Vec@PAUFileState@@@@QAE@XZ ; Vec<FileState *>::~Vec<FileState *>(void)
.text$mn:00003B0B                 push    edx
.text$mn:00003B0C                 mov     ecx, ebp
.text$mn:00003B0E                 push    eax
.text$mn:00003B0F                 lea     edx, $LN13
.text$mn:00003B15                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00003B1A                 pop     eax
.text$mn:00003B1B                 pop     edx
.text$mn:00003B1C                 pop     edi
.text$mn:00003B1D                 pop     esi
.text$mn:00003B1E                 pop     ebx
.text$mn:00003B1F                 add     esp, 164h
.text$mn:00003B25                 cmp     ebp, esp
.text$mn:00003B27                 call    __RTC_CheckEsp
.text$mn:00003B2C                 mov     esp, ebp
.text$mn:00003B2E                 pop     ebp
.text$mn:00003B2F                 retn
.text$mn:00003B2F ?GetFilePathsToCheck@FileExistenceChecker@@AAEXXZ endp
.text$mn:00003B2F
.text$mn:00003B2F ; ---------------------------------------------------------------------------
.text$mn:00003B30 $LN13           dd 1                    ; DATA XREF: FileExistenceChecker::GetFilePathsToCheck(void)+133o
.text$mn:00003B34                 dd offset $LN12
.text$mn:00003B38 $LN12           dd 0FFFFFF84h, 54h      ; DATA XREF: .text$mn:00003B34o
.text$mn:00003B40                 dd offset $LN11         ; "frequencyList"
.text$mn:00003B44 $LN11           db 'frequencyList',0    ; DATA XREF: .text$mn:00003B40o
.text$mn:00003B52                 align 4
.text$mn:00003B52 _text$mn        ends
.text$mn:00003B52
.text$mn:00003B54 ; ===========================================================================
.text$mn:00003B54
.text$mn:00003B54 ; Segment type: Pure code
.text$mn:00003B54 ; Segment permissions: Read/Execute
.text$mn:00003B54 _text$mn        segment para public 'CODE' use32
.text$mn:00003B54                 assume cs:_text$mn
.text$mn:00003B54                 ;org 3B54h
.text$mn:00003B54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B54
.text$mn:00003B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B54
.text$mn:00003B54 ; Attributes: bp-based frame
.text$mn:00003B54
.text$mn:00003B54 ; unsigned __int32 __cdecl GetLogoBgColor()
.text$mn:00003B54                 public ?GetLogoBgColor@@YAKXZ
.text$mn:00003B54 ?GetLogoBgColor@@YAKXZ proc near
.text$mn:00003B54
.text$mn:00003B54 var_C0          = byte ptr -0C0h
.text$mn:00003B54
.text$mn:00003B54                 push    ebp
.text$mn:00003B55                 mov     ebp, esp
.text$mn:00003B57                 sub     esp, 0C0h
.text$mn:00003B5D                 push    ebx
.text$mn:00003B5E                 push    esi
.text$mn:00003B5F                 push    edi
.text$mn:00003B60                 lea     edi, [ebp+var_C0]
.text$mn:00003B66                 mov     ecx, 30h ; '0'
.text$mn:00003B6B                 mov     eax, 0CCCCCCCCh
.text$mn:00003B70                 rep stosd
.text$mn:00003B72                 call    ?GetAboutBgColor@@YAKXZ ; GetAboutBgColor(void)
.text$mn:00003B77                 pop     edi
.text$mn:00003B78                 pop     esi
.text$mn:00003B79                 pop     ebx
.text$mn:00003B7A                 add     esp, 0C0h
.text$mn:00003B80                 cmp     ebp, esp
.text$mn:00003B82                 call    __RTC_CheckEsp
.text$mn:00003B87                 mov     esp, ebp
.text$mn:00003B89                 pop     ebp
.text$mn:00003B8A                 retn
.text$mn:00003B8A ?GetLogoBgColor@@YAKXZ endp
.text$mn:00003B8A
.text$mn:00003B8A ; ---------------------------------------------------------------------------
.text$mn:00003B8B                 align 4
.text$mn:00003B8B _text$mn        ends
.text$mn:00003B8B
.text$mn:00003B8C ; ===========================================================================
.text$mn:00003B8C
.text$mn:00003B8C ; Segment type: Pure code
.text$mn:00003B8C ; Segment permissions: Read/Execute
.text$mn:00003B8C _text$mn        segment para public 'CODE' use32
.text$mn:00003B8C                 assume cs:_text$mn
.text$mn:00003B8C                 ;org 3B8Ch
.text$mn:00003B8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B8C
.text$mn:00003B8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003B8C
.text$mn:00003B8C ; Attributes: bp-based frame
.text$mn:00003B8C
.text$mn:00003B8C ; unsigned __int32 __cdecl GetNoDocBgColor()
.text$mn:00003B8C                 public ?GetNoDocBgColor@@YAKXZ
.text$mn:00003B8C ?GetNoDocBgColor@@YAKXZ proc near
.text$mn:00003B8C
.text$mn:00003B8C var_D0          = dword ptr -0D0h
.text$mn:00003B8C var_5           = byte ptr -5
.text$mn:00003B8C
.text$mn:00003B8C                 push    ebp
.text$mn:00003B8D                 mov     ebp, esp
.text$mn:00003B8F                 sub     esp, 0D0h
.text$mn:00003B95                 push    ebx
.text$mn:00003B96                 push    esi
.text$mn:00003B97                 push    edi
.text$mn:00003B98                 lea     edi, [ebp+var_D0]
.text$mn:00003B9E                 mov     ecx, 34h ; '4'
.text$mn:00003BA3                 mov     eax, 0CCCCCCCCh
.text$mn:00003BA8                 rep stosd
.text$mn:00003BAA                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00003BAF                 movzx   ecx, byte ptr [eax+6]
.text$mn:00003BB3                 test    ecx, ecx
.text$mn:00003BB5                 jz      short loc_3BF0
.text$mn:00003BB7                 mov     esi, esp
.text$mn:00003BB9                 push    8               ; nIndex
.text$mn:00003BBB                 call    dword ptr ds:__imp__GetSysColor@4 ; GetSysColor(x)
.text$mn:00003BC1                 cmp     esi, esp
.text$mn:00003BC3                 call    __RTC_CheckEsp
.text$mn:00003BC8                 test    eax, eax
.text$mn:00003BCA                 jnz     short loc_3BE4
.text$mn:00003BCC                 mov     esi, esp
.text$mn:00003BCE                 push    5               ; nIndex
.text$mn:00003BD0                 call    dword ptr ds:__imp__GetSysColor@4 ; GetSysColor(x)
.text$mn:00003BD6                 cmp     esi, esp
.text$mn:00003BD8                 call    __RTC_CheckEsp
.text$mn:00003BDD                 cmp     eax, 0FFFFFFh
.text$mn:00003BE2                 jz      short loc_3BF0
.text$mn:00003BE4
.text$mn:00003BE4 loc_3BE4:                               ; CODE XREF: GetNoDocBgColor(void)+3Ej
.text$mn:00003BE4                 mov     [ebp+var_D0], 1
.text$mn:00003BEE                 jmp     short loc_3BFA
.text$mn:00003BF0 ; ---------------------------------------------------------------------------
.text$mn:00003BF0
.text$mn:00003BF0 loc_3BF0:                               ; CODE XREF: GetNoDocBgColor(void)+29j
.text$mn:00003BF0                                         ; GetNoDocBgColor(void)+56j
.text$mn:00003BF0                 mov     [ebp+var_D0], 0
.text$mn:00003BFA
.text$mn:00003BFA loc_3BFA:                               ; CODE XREF: GetNoDocBgColor(void)+62j
.text$mn:00003BFA                 mov     dl, byte ptr [ebp+var_D0]
.text$mn:00003C00                 mov     [ebp+var_5], dl
.text$mn:00003C03                 movzx   eax, [ebp+var_5]
.text$mn:00003C07                 test    eax, eax
.text$mn:00003C09                 jz      short loc_3C1E
.text$mn:00003C0B                 mov     esi, esp
.text$mn:00003C0D                 push    0Fh             ; nIndex
.text$mn:00003C0F                 call    dword ptr ds:__imp__GetSysColor@4 ; GetSysColor(x)
.text$mn:00003C15                 cmp     esi, esp
.text$mn:00003C17                 call    __RTC_CheckEsp
.text$mn:00003C1C                 jmp     short loc_3C23
.text$mn:00003C1E ; ---------------------------------------------------------------------------
.text$mn:00003C1E
.text$mn:00003C1E loc_3C1E:                               ; CODE XREF: GetNoDocBgColor(void)+7Dj
.text$mn:00003C1E                 mov     eax, 999999h
.text$mn:00003C23
.text$mn:00003C23 loc_3C23:                               ; CODE XREF: GetNoDocBgColor(void)+90j
.text$mn:00003C23                 pop     edi
.text$mn:00003C24                 pop     esi
.text$mn:00003C25                 pop     ebx
.text$mn:00003C26                 add     esp, 0D0h
.text$mn:00003C2C                 cmp     ebp, esp
.text$mn:00003C2E                 call    __RTC_CheckEsp
.text$mn:00003C33                 mov     esp, ebp
.text$mn:00003C35                 pop     ebp
.text$mn:00003C36                 retn
.text$mn:00003C36 ?GetNoDocBgColor@@YAKXZ endp
.text$mn:00003C36
.text$mn:00003C36 ; ---------------------------------------------------------------------------
.text$mn:00003C37                 align 4
.text$mn:00003C37 _text$mn        ends
.text$mn:00003C37
.text$mn:00003C38 ; ===========================================================================
.text$mn:00003C38
.text$mn:00003C38 ; Segment type: Pure code
.text$mn:00003C38 ; Segment permissions: Read/Execute
.text$mn:00003C38 _text$mn        segment para public 'CODE' use32
.text$mn:00003C38                 assume cs:_text$mn
.text$mn:00003C38                 ;org 3C38h
.text$mn:00003C38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C38
.text$mn:00003C38 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C38
.text$mn:00003C38 ; Attributes: bp-based frame
.text$mn:00003C38
.text$mn:00003C38 ; void __thiscall FileExistenceChecker::HideMissingFiles(FileExistenceChecker *__hidden this)
.text$mn:00003C38                 public ?HideMissingFiles@FileExistenceChecker@@AAEXXZ
.text$mn:00003C38 ?HideMissingFiles@FileExistenceChecker@@AAEXXZ proc near
.text$mn:00003C38                                         ; CODE XREF: _lambda_b6f3cb1c717d8c8a816f87295491882e_::operator()(void)+46p
.text$mn:00003C38
.text$mn:00003C38 var_104         = byte ptr -104h
.text$mn:00003C38 var_40          = dword ptr -40h
.text$mn:00003C38 var_34          = byte ptr -34h
.text$mn:00003C38 var_24          = byte ptr -24h
.text$mn:00003C38 var_14          = dword ptr -14h
.text$mn:00003C38 var_8           = dword ptr -8
.text$mn:00003C38
.text$mn:00003C38                 push    ebp
.text$mn:00003C39                 mov     ebp, esp
.text$mn:00003C3B                 sub     esp, 104h
.text$mn:00003C41                 push    ebx
.text$mn:00003C42                 push    esi
.text$mn:00003C43                 push    edi
.text$mn:00003C44                 push    ecx
.text$mn:00003C45                 lea     edi, [ebp+var_104]
.text$mn:00003C4B                 mov     ecx, 41h ; 'A'
.text$mn:00003C50                 mov     eax, 0CCCCCCCCh
.text$mn:00003C55                 rep stosd
.text$mn:00003C57                 pop     ecx
.text$mn:00003C58                 mov     [ebp+var_8], ecx
.text$mn:00003C5B                 mov     eax, [ebp+var_8]
.text$mn:00003C5E                 add     eax, 14h
.text$mn:00003C61                 mov     [ebp+var_14], eax
.text$mn:00003C64                 lea     eax, [ebp+var_24]
.text$mn:00003C67                 push    eax
.text$mn:00003C68                 mov     ecx, [ebp+var_14]
.text$mn:00003C6B                 call    ?begin@?$Vec@PA_W@@QAE?AVIter@1@XZ ; Vec<wchar_t *>::begin(void)
.text$mn:00003C70                 lea     eax, [ebp+var_34]
.text$mn:00003C73                 push    eax
.text$mn:00003C74                 mov     ecx, [ebp+var_14]
.text$mn:00003C77                 call    ?end@?$Vec@PA_W@@QAE?AVIter@1@XZ ; Vec<wchar_t *>::end(void)
.text$mn:00003C7C                 jmp     short loc_3C86
.text$mn:00003C7E ; ---------------------------------------------------------------------------
.text$mn:00003C7E
.text$mn:00003C7E loc_3C7E:                               ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+7Ej
.text$mn:00003C7E                 lea     ecx, [ebp+var_24]
.text$mn:00003C81                 call    ??EIter@?$Vec@PA_W@@QAEAAV01@XZ ; Vec<wchar_t *>::Iter::operator++(void)
.text$mn:00003C86
.text$mn:00003C86 loc_3C86:                               ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+44j
.text$mn:00003C86                 lea     eax, [ebp+var_34]
.text$mn:00003C89                 push    eax
.text$mn:00003C8A                 lea     ecx, [ebp+var_24]
.text$mn:00003C8D                 call    ??9Iter@?$Vec@PA_W@@QBE_NABV01@@Z ; Vec<wchar_t *>::Iter::operator!=(Vec<wchar_t *>::Iter const &)
.text$mn:00003C92                 movzx   ecx, al
.text$mn:00003C95                 test    ecx, ecx
.text$mn:00003C97                 jz      short loc_3CB8
.text$mn:00003C99                 lea     ecx, [ebp+var_24]
.text$mn:00003C9C                 call    ??DIter@?$Vec@PA_W@@QBEAAPA_WXZ ; Vec<wchar_t *>::Iter::operator*(void)
.text$mn:00003CA1                 mov     eax, [eax]
.text$mn:00003CA3                 mov     [ebp+var_40], eax
.text$mn:00003CA6                 push    1               ; bool
.text$mn:00003CA8                 mov     eax, [ebp+var_40]
.text$mn:00003CAB                 push    eax             ; wchar_t *
.text$mn:00003CAC                 mov     ecx, offset ?gFileHistory@@3VFileHistory@@A ; this
.text$mn:00003CB1                 call    ?MarkFileInexistent@FileHistory@@QAE_NPB_W_N@Z ; FileHistory::MarkFileInexistent(wchar_t const *,bool)
.text$mn:00003CB6                 jmp     short loc_3C7E
.text$mn:00003CB8 ; ---------------------------------------------------------------------------
.text$mn:00003CB8
.text$mn:00003CB8 loc_3CB8:                               ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+5Fj
.text$mn:00003CB8                 mov     ecx, [ebp+var_8]
.text$mn:00003CBB                 add     ecx, 14h
.text$mn:00003CBE                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00003CC3                 test    eax, eax
.text$mn:00003CC5                 jbe     short loc_3D04
.text$mn:00003CC7                 mov     ecx, offset ?gWindows@@3V?$Vec@PAVWindowInfo@@@@A ; Vec<WindowInfo *> gWindows
.text$mn:00003CCC                 call    ?Count@?$Vec@PAVWindowInfo@@@@QBEIXZ ; Vec<WindowInfo *>::Count(void)
.text$mn:00003CD1                 test    eax, eax
.text$mn:00003CD3                 jbe     short loc_3D04
.text$mn:00003CD5                 push    0
.text$mn:00003CD7                 mov     ecx, offset ?gWindows@@3V?$Vec@PAVWindowInfo@@@@A ; Vec<WindowInfo *> gWindows
.text$mn:00003CDC                 call    ?At@?$Vec@PAVWindowInfo@@@@QBEAAPAVWindowInfo@@I@Z ; Vec<WindowInfo *>::At(uint)
.text$mn:00003CE1                 mov     ecx, [eax]      ; this
.text$mn:00003CE3                 call    ?IsAboutWindow@WindowInfo@@QBE_NXZ ; WindowInfo::IsAboutWindow(void)
.text$mn:00003CE8                 movzx   eax, al
.text$mn:00003CEB                 test    eax, eax
.text$mn:00003CED                 jz      short loc_3D04
.text$mn:00003CEF                 push    1               ; bool
.text$mn:00003CF1                 push    0
.text$mn:00003CF3                 mov     ecx, offset ?gWindows@@3V?$Vec@PAVWindowInfo@@@@A ; Vec<WindowInfo *> gWindows
.text$mn:00003CF8                 call    ?At@?$Vec@PAVWindowInfo@@@@QBEAAPAVWindowInfo@@I@Z ; Vec<WindowInfo *>::At(uint)
.text$mn:00003CFD                 mov     ecx, [eax]      ; this
.text$mn:00003CFF                 call    ?RedrawAll@WindowInfo@@QAEX_N@Z ; WindowInfo::RedrawAll(bool)
.text$mn:00003D04
.text$mn:00003D04 loc_3D04:                               ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+8Dj
.text$mn:00003D04                                         ; FileExistenceChecker::HideMissingFiles(void)+9Bj ...
.text$mn:00003D04                 push    edx
.text$mn:00003D05                 mov     ecx, ebp
.text$mn:00003D07                 push    eax
.text$mn:00003D08                 lea     edx, $LN10
.text$mn:00003D0E                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00003D13                 pop     eax
.text$mn:00003D14                 pop     edx
.text$mn:00003D15                 pop     edi
.text$mn:00003D16                 pop     esi
.text$mn:00003D17                 pop     ebx
.text$mn:00003D18                 add     esp, 104h
.text$mn:00003D1E                 cmp     ebp, esp
.text$mn:00003D20                 call    __RTC_CheckEsp
.text$mn:00003D25                 mov     esp, ebp
.text$mn:00003D27                 pop     ebp
.text$mn:00003D28                 retn
.text$mn:00003D28 ?HideMissingFiles@FileExistenceChecker@@AAEXXZ endp
.text$mn:00003D28
.text$mn:00003D28 ; ---------------------------------------------------------------------------
.text$mn:00003D29                 align 4
.text$mn:00003D2C $LN10           dd 2                    ; DATA XREF: FileExistenceChecker::HideMissingFiles(void)+D0o
.text$mn:00003D30                 dd offset $LN9
.text$mn:00003D34 $LN9            dd 0FFFFFFDCh, 8        ; DATA XREF: .text$mn:00003D30o
.text$mn:00003D3C                 dd offset $LN7          ; "<begin>$L0"
.text$mn:00003D40                 db 0CCh
.text$mn:00003D41                 db 3 dup(0FFh)
.text$mn:00003D44                 dd 8
.text$mn:00003D48                 dd offset $LN8          ; "<end>$L0"
.text$mn:00003D4C $LN8            db '<end>$L0',0         ; DATA XREF: .text$mn:00003D48o
.text$mn:00003D55 $LN7            db '<begin>$L0',0       ; DATA XREF: .text$mn:00003D3Co
.text$mn:00003D55 _text$mn        ends
.text$mn:00003D55
.text$mn:00003D60 ; ===========================================================================
.text$mn:00003D60
.text$mn:00003D60 ; Segment type: Pure code
.text$mn:00003D60 ; Segment permissions: Read/Execute
.text$mn:00003D60 _text$mn        segment para public 'CODE' use32
.text$mn:00003D60                 assume cs:_text$mn
.text$mn:00003D60                 ;org 3D60h
.text$mn:00003D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D60
.text$mn:00003D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D60
.text$mn:00003D60 ; Attributes: bp-based frame
.text$mn:00003D60
.text$mn:00003D60 ; public: void __thiscall Vec<wchar_t *>::InsertAt(unsigned int, wchar_t * const &)
.text$mn:00003D60                 public ?InsertAt@?$Vec@PA_W@@QAEXIABQA_W@Z
.text$mn:00003D60 ?InsertAt@?$Vec@PA_W@@QAEXIABQA_W@Z proc near
.text$mn:00003D60                                         ; CODE XREF: Vec<wchar_t *>::Append(wchar_t * const &)+30p
.text$mn:00003D60
.text$mn:00003D60 var_CC          = byte ptr -0CCh
.text$mn:00003D60 var_8           = dword ptr -8
.text$mn:00003D60 arg_0           = dword ptr  8
.text$mn:00003D60 arg_4           = dword ptr  0Ch
.text$mn:00003D60
.text$mn:00003D60                 push    ebp
.text$mn:00003D61                 mov     ebp, esp
.text$mn:00003D63                 sub     esp, 0CCh
.text$mn:00003D69                 push    ebx
.text$mn:00003D6A                 push    esi
.text$mn:00003D6B                 push    edi
.text$mn:00003D6C                 push    ecx
.text$mn:00003D6D                 lea     edi, [ebp+var_CC]
.text$mn:00003D73                 mov     ecx, 33h ; '3'
.text$mn:00003D78                 mov     eax, 0CCCCCCCCh
.text$mn:00003D7D                 rep stosd
.text$mn:00003D7F                 pop     ecx
.text$mn:00003D80                 mov     [ebp+var_8], ecx
.text$mn:00003D83                 push    0
.text$mn:00003D85                 push    1
.text$mn:00003D87                 mov     eax, [ebp+arg_0]
.text$mn:00003D8A                 push    eax
.text$mn:00003D8B                 mov     ecx, [ebp+var_8]
.text$mn:00003D8E                 call    ?MakeSpaceAt@?$Vec@PA_W@@IAEPAPA_WII_N@Z ; Vec<wchar_t *>::MakeSpaceAt(uint,uint,bool)
.text$mn:00003D93                 mov     ecx, 4
.text$mn:00003D98                 imul    edx, ecx, 0
.text$mn:00003D9B                 mov     ecx, [ebp+arg_4]
.text$mn:00003D9E                 mov     ecx, [ecx]
.text$mn:00003DA0                 mov     [eax+edx], ecx
.text$mn:00003DA3                 pop     edi
.text$mn:00003DA4                 pop     esi
.text$mn:00003DA5                 pop     ebx
.text$mn:00003DA6                 add     esp, 0CCh
.text$mn:00003DAC                 cmp     ebp, esp
.text$mn:00003DAE                 call    __RTC_CheckEsp
.text$mn:00003DB3                 mov     esp, ebp
.text$mn:00003DB5                 pop     ebp
.text$mn:00003DB6                 retn    8
.text$mn:00003DB6 ?InsertAt@?$Vec@PA_W@@QAEXIABQA_W@Z endp
.text$mn:00003DB6
.text$mn:00003DB6 ; ---------------------------------------------------------------------------
.text$mn:00003DB9                 align 4
.text$mn:00003DB9 _text$mn        ends
.text$mn:00003DB9
.text$mn:00003DBC ; ===========================================================================
.text$mn:00003DBC
.text$mn:00003DBC ; Segment type: Pure code
.text$mn:00003DBC ; Segment permissions: Read/Execute
.text$mn:00003DBC _text$mn        segment para public 'CODE' use32
.text$mn:00003DBC                 assume cs:_text$mn
.text$mn:00003DBC                 ;org 3DBCh
.text$mn:00003DBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DBC
.text$mn:00003DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00003DBC
.text$mn:00003DBC ; Attributes: bp-based frame
.text$mn:00003DBC
.text$mn:00003DBC ; bool __cdecl InstanceInit(int)
.text$mn:00003DBC ?InstanceInit@@YA_NH@Z proc near        ; CODE XREF: WinMain(x,x,x,x)+2A5p
.text$mn:00003DBC
.text$mn:00003DBC var_C4          = byte ptr -0C4h
.text$mn:00003DBC var_C1          = byte ptr -0C1h
.text$mn:00003DBC
.text$mn:00003DBC                 push    ebp
.text$mn:00003DBD                 mov     ebp, esp
.text$mn:00003DBF                 sub     esp, 0C4h
.text$mn:00003DC5                 push    ebx
.text$mn:00003DC6                 push    esi
.text$mn:00003DC7                 push    edi
.text$mn:00003DC8                 lea     edi, [ebp+var_C4]
.text$mn:00003DCE                 mov     ecx, 31h ; '1'
.text$mn:00003DD3                 mov     eax, 0CCCCCCCCh
.text$mn:00003DD8                 rep stosd
.text$mn:00003DDA                 mov     esi, esp
.text$mn:00003DDC                 push    (offset loc_82+2) ; lpCursorName
.text$mn:00003DE1                 mov     edi, esp
.text$mn:00003DE3                 push    0               ; lpModuleName
.text$mn:00003DE5                 call    dword ptr ds:__imp__GetModuleHandleW@4 ; GetModuleHandleW(x)
.text$mn:00003DEB                 cmp     edi, esp
.text$mn:00003DED                 call    __RTC_CheckEsp
.text$mn:00003DF2                 push    eax             ; hInstance
.text$mn:00003DF3                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:00003DF9                 cmp     esi, esp
.text$mn:00003DFB                 call    __RTC_CheckEsp
.text$mn:00003E00                 mov     dword ptr ds:?gCursorDrag@@3PAUHICON__@@A, eax ; HICON__ * gCursorDrag
.text$mn:00003E05
.text$mn:00003E05 loc_3E05:                               ; CODE XREF: InstanceInit(int)+4Bj
.text$mn:00003E05                                         ; InstanceInit(int)+78j
.text$mn:00003E05                 xor     eax, eax
.text$mn:00003E07                 jnz     short loc_3E05
.text$mn:00003E09                 cmp     dword ptr ds:?gCursorDrag@@3PAUHICON__@@A, 0 ; HICON__ * gCursorDrag
.text$mn:00003E10                 jnz     short loc_3E1B
.text$mn:00003E12                 mov     [ebp+var_C1], 1
.text$mn:00003E19                 jmp     short loc_3E22
.text$mn:00003E1B ; ---------------------------------------------------------------------------
.text$mn:00003E1B
.text$mn:00003E1B loc_3E1B:                               ; CODE XREF: InstanceInit(int)+54j
.text$mn:00003E1B                 mov     [ebp+var_C1], 0
.text$mn:00003E22
.text$mn:00003E22 loc_3E22:                               ; CODE XREF: InstanceInit(int)+5Dj
.text$mn:00003E22                 movzx   eax, [ebp+var_C1]
.text$mn:00003E29                 push    eax             ; bool
.text$mn:00003E2A                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00003E2F                 add     esp, 4
.text$mn:00003E32                 xor     eax, eax
.text$mn:00003E34                 jnz     short loc_3E05
.text$mn:00003E36                 mov     esi, esp
.text$mn:00003E38                 push    (offset loc_7D9+1) ; lpBitmapName
.text$mn:00003E3D                 mov     edi, esp
.text$mn:00003E3F                 push    0               ; lpModuleName
.text$mn:00003E41                 call    dword ptr ds:__imp__GetModuleHandleW@4 ; GetModuleHandleW(x)
.text$mn:00003E47                 cmp     edi, esp
.text$mn:00003E49                 call    __RTC_CheckEsp
.text$mn:00003E4E                 push    eax             ; hInstance
.text$mn:00003E4F                 call    dword ptr ds:__imp__LoadBitmapW@8 ; LoadBitmapW(x,x)
.text$mn:00003E55                 cmp     esi, esp
.text$mn:00003E57                 call    __RTC_CheckEsp
.text$mn:00003E5C                 mov     dword ptr ds:?gBitmapReloadingCue@@3PAUHBITMAP__@@A, eax ; HBITMAP__ * gBitmapReloadingCue
.text$mn:00003E61
.text$mn:00003E61 loc_3E61:                               ; CODE XREF: InstanceInit(int)+A7j
.text$mn:00003E61                                         ; InstanceInit(int)+D4j
.text$mn:00003E61                 xor     eax, eax
.text$mn:00003E63                 jnz     short loc_3E61
.text$mn:00003E65                 cmp     dword ptr ds:?gBitmapReloadingCue@@3PAUHBITMAP__@@A, 0 ; HBITMAP__ * gBitmapReloadingCue
.text$mn:00003E6C                 jnz     short loc_3E77
.text$mn:00003E6E                 mov     [ebp+var_C1], 1
.text$mn:00003E75                 jmp     short loc_3E7E
.text$mn:00003E77 ; ---------------------------------------------------------------------------
.text$mn:00003E77
.text$mn:00003E77 loc_3E77:                               ; CODE XREF: InstanceInit(int)+B0j
.text$mn:00003E77                 mov     [ebp+var_C1], 0
.text$mn:00003E7E
.text$mn:00003E7E loc_3E7E:                               ; CODE XREF: InstanceInit(int)+B9j
.text$mn:00003E7E                 movzx   eax, [ebp+var_C1]
.text$mn:00003E85                 push    eax             ; bool
.text$mn:00003E86                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00003E8B                 add     esp, 4
.text$mn:00003E8E                 xor     eax, eax
.text$mn:00003E90                 jnz     short loc_3E61
.text$mn:00003E92                 mov     al, 1
.text$mn:00003E94                 pop     edi
.text$mn:00003E95                 pop     esi
.text$mn:00003E96                 pop     ebx
.text$mn:00003E97                 add     esp, 0C4h
.text$mn:00003E9D                 cmp     ebp, esp
.text$mn:00003E9F                 call    __RTC_CheckEsp
.text$mn:00003EA4                 mov     esp, ebp
.text$mn:00003EA6                 pop     ebp
.text$mn:00003EA7                 retn
.text$mn:00003EA7 ?InstanceInit@@YA_NH@Z endp
.text$mn:00003EA7
.text$mn:00003EA7 _text$mn        ends
.text$mn:00003EA7
.text$mn:00003EA8 ; ===========================================================================
.text$mn:00003EA8
.text$mn:00003EA8 ; Segment type: Pure code
.text$mn:00003EA8 ; Segment permissions: Read/Execute
.text$mn:00003EA8 _text$mn        segment para public 'CODE' use32
.text$mn:00003EA8                 assume cs:_text$mn
.text$mn:00003EA8                 ;org 3EA8h
.text$mn:00003EA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EA8
.text$mn:00003EA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EA8
.text$mn:00003EA8 ; Attributes: bp-based frame
.text$mn:00003EA8
.text$mn:00003EA8 ; class WindowInfo * __cdecl LoadOnStartup(wchar_t const *, class CommandLineInfo &, bool)
.text$mn:00003EA8 ?LoadOnStartup@@YAPAVWindowInfo@@PB_WAAVCommandLineInfo@@_N@Z proc near
.text$mn:00003EA8                                         ; CODE XREF: WinMain(x,x,x,x)+8CBp
.text$mn:00003EA8
.text$mn:00003EA8 var_270         = dword ptr -270h
.text$mn:00003EA8 var_258         = dword ptr -258h
.text$mn:00003EA8 var_190         = dword ptr -190h
.text$mn:00003EA8 var_184         = byte ptr -184h
.text$mn:00003EA8 var_178         = byte ptr -178h
.text$mn:00003EA8 var_5C          = dword ptr -5Ch
.text$mn:00003EA8 var_50          = dword ptr -50h
.text$mn:00003EA8 var_4C          = dword ptr -4Ch
.text$mn:00003EA8 var_48          = qword ptr -48h
.text$mn:00003EA8 var_40          = qword ptr -40h
.text$mn:00003EA8 var_30          = dword ptr -30h
.text$mn:00003EA8 var_24          = dword ptr -24h
.text$mn:00003EA8 var_18          = byte ptr -18h
.text$mn:00003EA8 var_10          = byte ptr -10h
.text$mn:00003EA8 var_4           = dword ptr -4
.text$mn:00003EA8 arg_0           = dword ptr  8
.text$mn:00003EA8 arg_4           = dword ptr  0Ch
.text$mn:00003EA8 arg_8           = byte ptr  10h
.text$mn:00003EA8
.text$mn:00003EA8                 push    ebp
.text$mn:00003EA9                 mov     ebp, esp
.text$mn:00003EAB                 sub     esp, 258h
.text$mn:00003EB1                 push    ebx
.text$mn:00003EB2                 push    esi
.text$mn:00003EB3                 push    edi             ; wchar_t *
.text$mn:00003EB4                 lea     edi, [ebp+var_258]
.text$mn:00003EBA                 mov     ecx, 96h ; ''
.text$mn:00003EBF                 mov     eax, 0CCCCCCCCh
.text$mn:00003EC4                 rep stosd
.text$mn:00003EC6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003ECB                 xor     eax, ebp
.text$mn:00003ECD                 mov     [ebp+var_4], eax
.text$mn:00003ED0                 push    0               ; struct WindowInfo *
.text$mn:00003ED2                 mov     eax, [ebp+arg_0]
.text$mn:00003ED5                 push    eax             ; wchar_t *
.text$mn:00003ED6                 lea     ecx, [ebp+var_18] ; this
.text$mn:00003ED9                 call    ??0LoadArgs@@QAE@PB_WPAVWindowInfo@@@Z ; LoadArgs::LoadArgs(wchar_t const *,WindowInfo *)
.text$mn:00003EDE                 mov     eax, [ebp+arg_4]
.text$mn:00003EE1                 movzx   ecx, byte ptr [eax+0AAh]
.text$mn:00003EE8                 test    ecx, ecx
.text$mn:00003EEA                 jz      short loc_3EFA
.text$mn:00003EEC                 mov     edx, [ebp+arg_4]
.text$mn:00003EEF                 movzx   eax, byte ptr [edx+0A9h]
.text$mn:00003EF6                 test    eax, eax
.text$mn:00003EF8                 jnz     short loc_3F0F
.text$mn:00003EFA
.text$mn:00003EFA loc_3EFA:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+42j
.text$mn:00003EFA                 cmp     dword ptr ds:?gPluginURL@@3PB_WB, 0 ; wchar_t const * const gPluginURL
.text$mn:00003F01                 jnz     short loc_3F0F
.text$mn:00003F03                 mov     [ebp+var_258], 1
.text$mn:00003F0D                 jmp     short loc_3F19
.text$mn:00003F0F ; ---------------------------------------------------------------------------
.text$mn:00003F0F
.text$mn:00003F0F loc_3F0F:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+50j
.text$mn:00003F0F                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+59j
.text$mn:00003F0F                 mov     [ebp+var_258], 0
.text$mn:00003F19
.text$mn:00003F19 loc_3F19:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+65j
.text$mn:00003F19                 mov     cl, byte ptr [ebp+var_258]
.text$mn:00003F1F                 mov     [ebp+var_10], cl
.text$mn:00003F22                 lea     eax, [ebp+var_18]
.text$mn:00003F25                 push    eax             ; struct LoadArgs *
.text$mn:00003F26                 call    ?LoadDocument@@YAPAVWindowInfo@@AAULoadArgs@@@Z ; LoadDocument(LoadArgs &)
.text$mn:00003F2B                 add     esp, 4
.text$mn:00003F2E                 mov     [ebp+var_24], eax
.text$mn:00003F31                 cmp     [ebp+var_24], 0
.text$mn:00003F35                 jnz     short loc_3F3F
.text$mn:00003F37                 mov     eax, [ebp+var_24]
.text$mn:00003F3A                 jmp     loc_42B8
.text$mn:00003F3F ; ---------------------------------------------------------------------------
.text$mn:00003F3F
.text$mn:00003F3F loc_3F3F:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+8Dj
.text$mn:00003F3F                 mov     ecx, [ebp+var_24] ; this
.text$mn:00003F42                 call    ?IsDocLoaded@WindowInfo@@QBE_NXZ ; WindowInfo::IsDocLoaded(void)
.text$mn:00003F47                 movzx   eax, al
.text$mn:00003F4A                 test    eax, eax
.text$mn:00003F4C                 jz      short loc_3F87
.text$mn:00003F4E                 mov     ecx, [ebp+arg_4]
.text$mn:00003F51                 add     ecx, 0C0h ; '+'
.text$mn:00003F57                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00003F5C                 test    eax, eax
.text$mn:00003F5E                 jz      short loc_3F87
.text$mn:00003F60                 movzx   eax, [ebp+arg_8]
.text$mn:00003F64                 test    eax, eax
.text$mn:00003F66                 jz      short loc_3F87
.text$mn:00003F68                 mov     ecx, [ebp+arg_4]
.text$mn:00003F6B                 add     ecx, 0C0h ; '+'
.text$mn:00003F71                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00003F76                 push    eax             ; wchar_t *
.text$mn:00003F77                 mov     eax, [ebp+var_24]
.text$mn:00003F7A                 mov     ecx, [eax+354h] ; this
.text$mn:00003F80                 call    ?GotoNamedDest@LinkHandler@@QAEXPB_W@Z ; LinkHandler::GotoNamedDest(wchar_t const *)
.text$mn:00003F85                 jmp     short loc_3FFB
.text$mn:00003F87 ; ---------------------------------------------------------------------------
.text$mn:00003F87
.text$mn:00003F87 loc_3F87:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+A4j
.text$mn:00003F87                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+B6j ...
.text$mn:00003F87                 mov     ecx, [ebp+var_24] ; this
.text$mn:00003F8A                 call    ?IsDocLoaded@WindowInfo@@QBE_NXZ ; WindowInfo::IsDocLoaded(void)
.text$mn:00003F8F                 movzx   eax, al
.text$mn:00003F92                 test    eax, eax
.text$mn:00003F94                 jz      short loc_3FFB
.text$mn:00003F96                 mov     eax, [ebp+arg_4]
.text$mn:00003F99                 cmp     dword ptr [eax+0C4h], 0
.text$mn:00003FA0                 jle     short loc_3FFB
.text$mn:00003FA2                 movzx   eax, [ebp+arg_8]
.text$mn:00003FA6                 test    eax, eax
.text$mn:00003FA8                 jz      short loc_3FFB
.text$mn:00003FAA                 mov     esi, esp
.text$mn:00003FAC                 mov     eax, [ebp+arg_4]
.text$mn:00003FAF                 mov     ecx, [eax+0C4h]
.text$mn:00003FB5                 push    ecx
.text$mn:00003FB6                 mov     edx, [ebp+var_24]
.text$mn:00003FB9                 mov     eax, [edx]
.text$mn:00003FBB                 mov     ecx, [ebp+var_24]
.text$mn:00003FBE                 mov     edx, [eax]
.text$mn:00003FC0                 mov     ecx, [ecx]
.text$mn:00003FC2                 mov     eax, [edx+64h]
.text$mn:00003FC5                 call    eax
.text$mn:00003FC7                 cmp     esi, esp
.text$mn:00003FC9                 call    __RTC_CheckEsp
.text$mn:00003FCE                 movzx   ecx, al
.text$mn:00003FD1                 test    ecx, ecx
.text$mn:00003FD3                 jz      short loc_3FFB
.text$mn:00003FD5                 mov     esi, esp
.text$mn:00003FD7                 push    0
.text$mn:00003FD9                 mov     eax, [ebp+arg_4]
.text$mn:00003FDC                 mov     ecx, [eax+0C4h]
.text$mn:00003FE2                 push    ecx
.text$mn:00003FE3                 mov     edx, [ebp+var_24]
.text$mn:00003FE6                 mov     eax, [edx]
.text$mn:00003FE8                 mov     ecx, [ebp+var_24]
.text$mn:00003FEB                 mov     edx, [eax]
.text$mn:00003FED                 mov     ecx, [ecx]
.text$mn:00003FEF                 mov     eax, [edx+18h]
.text$mn:00003FF2                 call    eax
.text$mn:00003FF4                 cmp     esi, esp
.text$mn:00003FF6                 call    __RTC_CheckEsp
.text$mn:00003FFB
.text$mn:00003FFB loc_3FFB:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+DDj
.text$mn:00003FFB                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+ECj ...
.text$mn:00003FFB                 mov     eax, [ebp+arg_4]
.text$mn:00003FFE                 cmp     dword ptr [eax+0E0h], 0
.text$mn:00004005                 jz      short loc_401D
.text$mn:00004007                 mov     eax, [ebp+arg_4]
.text$mn:0000400A                 mov     ecx, [eax+0E0h]
.text$mn:00004010                 push    ecx             ; hWnd
.text$mn:00004011                 mov     edx, [ebp+var_24]
.text$mn:00004014                 push    edx             ; int
.text$mn:00004015                 call    ?MakePluginWindow@@YAXAAVWindowInfo@@PAUHWND__@@@Z ; MakePluginWindow(WindowInfo &,HWND__ *)
.text$mn:0000401A                 add     esp, 8
.text$mn:0000401D
.text$mn:0000401D loc_401D:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+15Dj
.text$mn:0000401D                 mov     ecx, [ebp+var_24] ; this
.text$mn:00004020                 call    ?IsDocLoaded@WindowInfo@@QBE_NXZ ; WindowInfo::IsDocLoaded(void)
.text$mn:00004025                 movzx   eax, al
.text$mn:00004028                 test    eax, eax
.text$mn:0000402A                 jz      short loc_4034
.text$mn:0000402C                 movzx   eax, [ebp+arg_8]
.text$mn:00004030                 test    eax, eax
.text$mn:00004032                 jnz     short loc_403C
.text$mn:00004034
.text$mn:00004034 loc_4034:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+182j
.text$mn:00004034                 mov     eax, [ebp+var_24]
.text$mn:00004037                 jmp     loc_42B8
.text$mn:0000403C ; ---------------------------------------------------------------------------
.text$mn:0000403C
.text$mn:0000403C loc_403C:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+18Aj
.text$mn:0000403C                 mov     eax, [ebp+arg_4]
.text$mn:0000403F                 movzx   ecx, byte ptr [eax+0C9h]
.text$mn:00004046                 test    ecx, ecx
.text$mn:00004048                 jnz     short loc_4058
.text$mn:0000404A                 mov     eax, [ebp+arg_4]
.text$mn:0000404D                 movzx   ecx, byte ptr [eax+0CAh]
.text$mn:00004054                 test    ecx, ecx
.text$mn:00004056                 jz      short loc_40B1
.text$mn:00004058
.text$mn:00004058 loc_4058:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+1A0j
.text$mn:00004058                 mov     eax, [ebp+arg_4]
.text$mn:0000405B                 movzx   ecx, byte ptr [eax+0C9h]
.text$mn:00004062                 test    ecx, ecx
.text$mn:00004064                 jz      short loc_4074
.text$mn:00004066                 mov     eax, [ebp+var_24]
.text$mn:00004069                 movzx   ecx, byte ptr [eax+304h]
.text$mn:00004070                 test    ecx, ecx
.text$mn:00004072                 jnz     short loc_408E
.text$mn:00004074
.text$mn:00004074 loc_4074:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+1BCj
.text$mn:00004074                 mov     eax, [ebp+arg_4]
.text$mn:00004077                 movzx   ecx, byte ptr [eax+0CAh]
.text$mn:0000407E                 test    ecx, ecx
.text$mn:00004080                 jz      short loc_409A
.text$mn:00004082                 mov     eax, [ebp+var_24]
.text$mn:00004085                 cmp     dword ptr [eax+308h], 0
.text$mn:0000408C                 jz      short loc_409A
.text$mn:0000408E
.text$mn:0000408E loc_408E:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+1CAj
.text$mn:0000408E                 mov     eax, [ebp+var_24]
.text$mn:00004091                 push    eax             ; struct WindowInfo *
.text$mn:00004092                 call    ?ExitFullScreen@@YAXPAVWindowInfo@@@Z ; ExitFullScreen(WindowInfo *)
.text$mn:00004097                 add     esp, 4
.text$mn:0000409A
.text$mn:0000409A loc_409A:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+1D8j
.text$mn:0000409A                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+1E4j
.text$mn:0000409A                 mov     eax, [ebp+arg_4]
.text$mn:0000409D                 movzx   ecx, byte ptr [eax+0C9h]
.text$mn:000040A4                 push    ecx             ; bool
.text$mn:000040A5                 mov     edx, [ebp+var_24]
.text$mn:000040A8                 push    edx             ; struct WindowInfo *
.text$mn:000040A9                 call    ?EnterFullScreen@@YAXPAVWindowInfo@@_N@Z ; EnterFullScreen(WindowInfo *,bool)
.text$mn:000040AE                 add     esp, 8
.text$mn:000040B1
.text$mn:000040B1 loc_40B1:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+1AEj
.text$mn:000040B1                 mov     eax, [ebp+arg_4]
.text$mn:000040B4                 cmp     dword ptr [eax+0CCh], 0
.text$mn:000040BB                 jz      short loc_40D5
.text$mn:000040BD                 push    0
.text$mn:000040BF                 mov     eax, [ebp+arg_4]
.text$mn:000040C2                 mov     ecx, [eax+0CCh]
.text$mn:000040C8                 push    ecx
.text$mn:000040C9                 mov     edx, [ebp+var_24]
.text$mn:000040CC                 push    edx
.text$mn:000040CD                 call    ?SwitchToDisplayMode@@YAXPAVWindowInfo@@W4DisplayMode@@_N@Z ; SwitchToDisplayMode(WindowInfo *,DisplayMode,bool)
.text$mn:000040D2                 add     esp, 0Ch
.text$mn:000040D5
.text$mn:000040D5 loc_40D5:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+213j
.text$mn:000040D5                 mov     eax, [ebp+arg_4]
.text$mn:000040D8                 movss   xmm0, dword ptr [eax+0D0h]
.text$mn:000040E0                 ucomiss xmm0, ds:__real@c2c60000
.text$mn:000040E7                 lahf
.text$mn:000040E8                 test    ah, 44h
.text$mn:000040EB                 jnp     short loc_410E
.text$mn:000040ED                 push    0               ; bool
.text$mn:000040EF                 push    1               ; bool
.text$mn:000040F1                 mov     eax, [ebp+arg_4]
.text$mn:000040F4                 push    ecx             ; float
.text$mn:000040F5                 movss   xmm0, dword ptr [eax+0D0h]
.text$mn:000040FD                 movss   [esp+270h+var_270], xmm0
.text$mn:00004102                 mov     ecx, [ebp+var_24]
.text$mn:00004105                 push    ecx             ; struct WindowInfo *
.text$mn:00004106                 call    ?ZoomToSelection@@YAXPAVWindowInfo@@M_N1@Z ; ZoomToSelection(WindowInfo *,float,bool,bool)
.text$mn:0000410B                 add     esp, 10h
.text$mn:0000410E
.text$mn:0000410E loc_410E:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+243j
.text$mn:0000410E                 mov     eax, [ebp+arg_4]
.text$mn:00004111                 cmp     dword ptr [eax+0D4h], 0FFFFFFFFh
.text$mn:00004118                 jnz     short loc_4126
.text$mn:0000411A                 mov     eax, [ebp+arg_4]
.text$mn:0000411D                 cmp     dword ptr [eax+0D8h], 0FFFFFFFFh
.text$mn:00004124                 jz      short loc_4199
.text$mn:00004126
.text$mn:00004126 loc_4126:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+270j
.text$mn:00004126                 mov     ecx, [ebp+var_24] ; this
.text$mn:00004129                 call    ?AsFixed@WindowInfo@@QBEPAVDisplayModel@@XZ ; WindowInfo::AsFixed(void)
.text$mn:0000412E                 test    eax, eax
.text$mn:00004130                 jz      short loc_4199
.text$mn:00004132                 mov     ecx, [ebp+var_24] ; this
.text$mn:00004135                 call    ?AsFixed@WindowInfo@@QBEPAVDisplayModel@@XZ ; WindowInfo::AsFixed(void)
.text$mn:0000413A                 mov     [ebp+var_30], eax
.text$mn:0000413D                 lea     eax, [ebp+var_50]
.text$mn:00004140                 push    eax
.text$mn:00004141                 mov     ecx, [ebp+var_30]
.text$mn:00004144                 call    ?GetScrollState@DisplayModel@@QAE?AUScrollState@@XZ ; DisplayModel::GetScrollState(void)
.text$mn:00004149                 mov     eax, [ebp+arg_4]
.text$mn:0000414C                 cvtsi2sd xmm0, dword ptr [eax+0D4h]
.text$mn:00004154                 movsd   [ebp+var_48], xmm0
.text$mn:00004159                 mov     eax, [ebp+arg_4]
.text$mn:0000415C                 cvtsi2sd xmm0, dword ptr [eax+0D8h]
.text$mn:00004164                 movsd   [ebp+var_40], xmm0
.text$mn:00004169                 sub     esp, 18h
.text$mn:0000416C                 mov     eax, esp
.text$mn:0000416E                 mov     ecx, [ebp+var_50]
.text$mn:00004171                 mov     [eax], ecx
.text$mn:00004173                 mov     edx, [ebp+var_4C]
.text$mn:00004176                 mov     [eax+4], edx
.text$mn:00004179                 mov     ecx, dword ptr [ebp+var_48]
.text$mn:0000417C                 mov     [eax+8], ecx
.text$mn:0000417F                 mov     edx, dword ptr [ebp+var_48+4]
.text$mn:00004182                 mov     [eax+0Ch], edx
.text$mn:00004185                 mov     ecx, dword ptr [ebp+var_40]
.text$mn:00004188                 mov     [eax+10h], ecx
.text$mn:0000418B                 mov     edx, dword ptr [ebp+var_40+4]
.text$mn:0000418E                 mov     [eax+14h], edx
.text$mn:00004191                 mov     ecx, [ebp+var_30]
.text$mn:00004194                 call    ?SetScrollState@DisplayModel@@QAEXUScrollState@@@Z ; DisplayModel::SetScrollState(ScrollState)
.text$mn:00004199
.text$mn:00004199 loc_4199:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+27Cj
.text$mn:00004199                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+288j
.text$mn:00004199                 mov     ecx, [ebp+arg_4]
.text$mn:0000419C                 add     ecx, 0B4h ; ''
.text$mn:000041A2                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:000041A7                 test    eax, eax
.text$mn:000041A9                 jz      loc_42B5
.text$mn:000041AF                 mov     eax, [ebp+arg_4]
.text$mn:000041B2                 cmp     dword ptr [eax+0B8h], 0
.text$mn:000041B9                 jz      loc_42B5
.text$mn:000041BF                 mov     ecx, [ebp+var_24] ; this
.text$mn:000041C2                 call    ?AsFixed@WindowInfo@@QBEPAVDisplayModel@@XZ ; WindowInfo::AsFixed(void)
.text$mn:000041C7                 test    eax, eax
.text$mn:000041C9                 jz      loc_42B5
.text$mn:000041CF                 mov     ecx, [ebp+var_24] ; this
.text$mn:000041D2                 call    ?AsFixed@WindowInfo@@QBEPAVDisplayModel@@XZ ; WindowInfo::AsFixed(void)
.text$mn:000041D7                 cmp     dword ptr [eax+14h], 0
.text$mn:000041DB                 jz      loc_42B5
.text$mn:000041E1                 push    0
.text$mn:000041E3                 push    0
.text$mn:000041E5                 lea     ecx, [ebp+var_178]
.text$mn:000041EB                 call    ??0?$Vec@V?$RectT@H@geomutil@@@@QAE@IPAVAllocator@@@Z ; Vec<geomutil::RectT<int>>::Vec<geomutil::RectT<int>>(uint,Allocator *)
.text$mn:000041F0                 mov     ecx, [ebp+arg_4]
.text$mn:000041F3                 add     ecx, 0B4h ; ''
.text$mn:000041F9                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:000041FE                 push    eax             ; this
.text$mn:000041FF                 call    ?Normalize@path@@YAPA_WPB_W@Z ; path::Normalize(wchar_t const *)
.text$mn:00004204                 add     esp, 4
.text$mn:00004207                 push    eax
.text$mn:00004208                 lea     ecx, [ebp+var_184]
.text$mn:0000420E                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:00004213                 mov     ecx, [ebp+var_24] ; this
.text$mn:00004216                 call    ?AsFixed@WindowInfo@@QBEPAVDisplayModel@@XZ ; WindowInfo::AsFixed(void)
.text$mn:0000421B                 mov     eax, [eax+14h]
.text$mn:0000421E                 mov     [ebp+var_258], eax
.text$mn:00004224                 mov     esi, esp
.text$mn:00004226                 lea     ecx, [ebp+var_178]
.text$mn:0000422C                 push    ecx
.text$mn:0000422D                 lea     edx, [ebp+var_5C]
.text$mn:00004230                 push    edx
.text$mn:00004231                 push    0
.text$mn:00004233                 mov     eax, [ebp+arg_4]
.text$mn:00004236                 mov     ecx, [eax+0B8h]
.text$mn:0000423C                 push    ecx
.text$mn:0000423D                 lea     ecx, [ebp+var_184]
.text$mn:00004243                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00004248                 push    eax
.text$mn:00004249                 mov     edx, [ebp+var_258]
.text$mn:0000424F                 mov     eax, [edx]
.text$mn:00004251                 mov     ecx, [ebp+var_258]
.text$mn:00004257                 mov     edx, [eax+8]
.text$mn:0000425A                 call    edx
.text$mn:0000425C                 cmp     esi, esp
.text$mn:0000425E                 call    __RTC_CheckEsp
.text$mn:00004263                 mov     [ebp+var_190], eax
.text$mn:00004269                 lea     eax, [ebp+var_178]
.text$mn:0000426F                 push    eax
.text$mn:00004270                 mov     ecx, [ebp+var_5C]
.text$mn:00004273                 push    ecx
.text$mn:00004274                 mov     edx, [ebp+var_190]
.text$mn:0000427A                 push    edx
.text$mn:0000427B                 push    0
.text$mn:0000427D                 mov     eax, [ebp+arg_4]
.text$mn:00004280                 mov     ecx, [eax+0B8h]
.text$mn:00004286                 push    ecx
.text$mn:00004287                 lea     ecx, [ebp+var_184]
.text$mn:0000428D                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00004292                 push    eax
.text$mn:00004293                 mov     edx, [ebp+var_24]
.text$mn:00004296                 push    edx
.text$mn:00004297                 call    ?ShowForwardSearchResult@@YAXPAVWindowInfo@@PB_WIIIIAAV?$Vec@V?$RectT@H@geomutil@@@@@Z ; ShowForwardSearchResult(WindowInfo *,wchar_t const *,uint,uint,uint,uint,Vec<geomutil::RectT<int>> &)
.text$mn:0000429C                 add     esp, 1Ch
.text$mn:0000429F                 lea     ecx, [ebp+var_184]
.text$mn:000042A5                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000042AA                 lea     ecx, [ebp+var_178]
.text$mn:000042B0                 call    ??1?$Vec@V?$RectT@H@geomutil@@@@QAE@XZ ; Vec<geomutil::RectT<int>>::~Vec<geomutil::RectT<int>>(void)
.text$mn:000042B5
.text$mn:000042B5 loc_42B5:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+301j
.text$mn:000042B5                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+311j ...
.text$mn:000042B5                 mov     eax, [ebp+var_24]
.text$mn:000042B8
.text$mn:000042B8 loc_42B8:                               ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+92j
.text$mn:000042B8                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+18Fj
.text$mn:000042B8                 push    edx
.text$mn:000042B9                 mov     ecx, ebp
.text$mn:000042BB                 push    eax
.text$mn:000042BC                 lea     edx, $LN30
.text$mn:000042C2                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:000042C7                 pop     eax
.text$mn:000042C8                 pop     edx
.text$mn:000042C9                 pop     edi
.text$mn:000042CA                 pop     esi
.text$mn:000042CB                 pop     ebx
.text$mn:000042CC                 mov     ecx, [ebp+var_4]
.text$mn:000042CF                 xor     ecx, ebp
.text$mn:000042D1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000042D6                 add     esp, 258h
.text$mn:000042DC                 cmp     ebp, esp
.text$mn:000042DE                 call    __RTC_CheckEsp
.text$mn:000042E3                 mov     esp, ebp
.text$mn:000042E5                 pop     ebp
.text$mn:000042E6                 retn
.text$mn:000042E6 ?LoadOnStartup@@YAPAVWindowInfo@@PB_WAAVCommandLineInfo@@_N@Z endp ; sp-analysis failed
.text$mn:000042E6
.text$mn:000042E6 ; ---------------------------------------------------------------------------
.text$mn:000042E7                 align 4
.text$mn:000042E8 $LN30           dd 5                    ; DATA XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+414o
.text$mn:000042EC                 dd offset $LN29
.text$mn:000042F0 $LN29           dd 0FFFFFFE8h, 10h      ; DATA XREF: .text$mn:000042ECo
.text$mn:000042F8                 dd offset $LN24         ; "args"
.text$mn:000042FC                 dd 0FFFFFFB0h, 18h
.text$mn:00004304                 dd offset $LN25         ; "ss"
.text$mn:00004308                 dd 0FFFFFFA4h, 4
.text$mn:00004310                 dd offset $LN26         ; "page"
.text$mn:00004314                 dd 0FFFFFE88h, 114h
.text$mn:0000431C                 dd offset $LN27         ; "rects"
.text$mn:00004320                 dd 0FFFFFE7Ch, 4
.text$mn:00004328                 dd offset $LN28         ; "sourcePath"
.text$mn:0000432C $LN28           db 'sourcePath',0       ; DATA XREF: .text$mn:00004328o
.text$mn:00004337 $LN27           db 'rects',0            ; DATA XREF: .text$mn:0000431Co
.text$mn:0000433D $LN26           db 'page',0             ; DATA XREF: .text$mn:00004310o
.text$mn:00004342 $LN25           db 'ss',0               ; DATA XREF: .text$mn:00004304o
.text$mn:00004345 $LN24           db 'args',0             ; DATA XREF: .text$mn:000042F8o
.text$mn:0000434A                 align 4
.text$mn:0000434A _text$mn        ends
.text$mn:0000434A
.text$mn:0000434C ; ===========================================================================
.text$mn:0000434C
.text$mn:0000434C ; Segment type: Pure code
.text$mn:0000434C ; Segment permissions: Read/Execute
.text$mn:0000434C _text$mn        segment para public 'CODE' use32
.text$mn:0000434C                 assume cs:_text$mn
.text$mn:0000434C                 ;org 434Ch
.text$mn:0000434C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000434C
.text$mn:0000434C ; =============== S U B R O U T I N E =======================================
.text$mn:0000434C
.text$mn:0000434C ; Attributes: bp-based frame
.text$mn:0000434C
.text$mn:0000434C ; int __cdecl MakePluginWindow(int, HWND hWnd)
.text$mn:0000434C ?MakePluginWindow@@YAXAAVWindowInfo@@PAUHWND__@@@Z proc near
.text$mn:0000434C                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+16Dp
.text$mn:0000434C
.text$mn:0000434C var_FC          = byte ptr -0FCh
.text$mn:0000434C var_F8          = byte ptr -0F8h
.text$mn:0000434C var_E0          = dword ptr -0E0h
.text$mn:0000434C var_DC          = dword ptr -0DCh
.text$mn:0000434C var_D8          = dword ptr -0D8h
.text$mn:0000434C var_D4          = dword ptr -0D4h
.text$mn:0000434C dwNewLong       = dword ptr -8
.text$mn:0000434C arg_0           = dword ptr  8
.text$mn:0000434C hWnd            = dword ptr  0Ch
.text$mn:0000434C
.text$mn:0000434C                 push    ebp
.text$mn:0000434D                 mov     ebp, esp
.text$mn:0000434F                 sub     esp, 0FCh
.text$mn:00004355                 push    ebx
.text$mn:00004356                 push    esi
.text$mn:00004357                 push    edi
.text$mn:00004358                 lea     edi, [ebp+var_FC]
.text$mn:0000435E                 mov     ecx, 3Fh ; '?'
.text$mn:00004363                 mov     eax, 0CCCCCCCCh
.text$mn:00004368                 rep stosd
.text$mn:0000436A                 mov     esi, esp
.text$mn:0000436C                 mov     eax, [ebp+hWnd]
.text$mn:0000436F                 push    eax             ; hWnd
.text$mn:00004370                 call    dword ptr ds:__imp__IsWindow@4 ; IsWindow(x)
.text$mn:00004376                 cmp     esi, esp
.text$mn:00004378                 call    __RTC_CheckEsp
.text$mn:0000437D                 test    eax, eax
.text$mn:0000437F                 jnz     short loc_439D
.text$mn:00004381                 mov     ecx, ds:?__LINE__Var@?0??MakePluginWindow@@YAXAAVWindowInfo@@PAUHWND__@@@Z@4JA ; long `MakePluginWindow(WindowInfo &,HWND__ *)'::`1'::__LINE__Var
.text$mn:00004387                 add     ecx, 1
.text$mn:0000438A                 push    ecx             ; Line
.text$mn:0000438B                 push    offset ??_C@_1GM@OAGNGMKE@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAs?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAp?$AAd?$AAf?$AA?9?$AAm?$AAa?$AAs?$AAt?$AAe?$AAr?$AA?2?$AAs@ ; "c:\\workspace\\sumatrapdf-master\\src\\"...
.text$mn:00004390                 push    offset ??_C@_1CK@HMBMIIMN@?$AAI?$AAs?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$CI?$AAh?$AAw?$AAn?$AAd?$AAP?$AAa?$AAr?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@ ; "IsWindow(hwndParent)"
.text$mn:00004395                 call    __wassert
.text$mn:0000439A ; ---------------------------------------------------------------------------
.text$mn:0000439A                 add     esp, 0Ch
.text$mn:0000439D
.text$mn:0000439D loc_439D:                               ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+33j
.text$mn:0000439D                 cmp     dword ptr ds:?gPluginURL@@3PB_WB, 0 ; wchar_t const * const gPluginURL
.text$mn:000043A4                 jnz     short loc_43C1
.text$mn:000043A6                 mov     eax, ds:?__LINE__Var@?0??MakePluginWindow@@YAXAAVWindowInfo@@PAUHWND__@@@Z@4JA ; long `MakePluginWindow(WindowInfo &,HWND__ *)'::`1'::__LINE__Var
.text$mn:000043AB                 add     eax, 2
.text$mn:000043AE                 push    eax             ; Line
.text$mn:000043AF                 push    offset ??_C@_1GM@OAGNGMKE@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAs?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAp?$AAd?$AAf?$AA?9?$AAm?$AAa?$AAs?$AAt?$AAe?$AAr?$AA?2?$AAs@ ; "c:\\workspace\\sumatrapdf-master\\src\\"...
.text$mn:000043B4                 push    offset ??_C@_1BI@NNHHJJEP@?$AAg?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAM?$AAo?$AAd?$AAe?$AA?$AA@ ; "gPluginMode"
.text$mn:000043B9                 call    __wassert
.text$mn:000043BE ; ---------------------------------------------------------------------------
.text$mn:000043BE                 add     esp, 0Ch
.text$mn:000043C1
.text$mn:000043C1 loc_43C1:                               ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+58j
.text$mn:000043C1                 mov     esi, esp
.text$mn:000043C3                 push    0FFFFFFF0h      ; nIndex
.text$mn:000043C5                 mov     eax, [ebp+arg_0]
.text$mn:000043C8                 mov     ecx, [eax+5Ch]
.text$mn:000043CB                 push    ecx             ; hWnd
.text$mn:000043CC                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:000043D2                 cmp     esi, esp
.text$mn:000043D4                 call    __RTC_CheckEsp
.text$mn:000043D9                 mov     [ebp+dwNewLong], eax
.text$mn:000043DC                 mov     eax, [ebp+dwNewLong]
.text$mn:000043DF                 and     eax, 7F3BFFFFh
.text$mn:000043E4                 mov     [ebp+dwNewLong], eax
.text$mn:000043E7                 mov     eax, [ebp+dwNewLong]
.text$mn:000043EA                 or      eax, 40000000h
.text$mn:000043EF                 mov     [ebp+dwNewLong], eax
.text$mn:000043F2                 mov     esi, esp
.text$mn:000043F4                 mov     eax, [ebp+dwNewLong]
.text$mn:000043F7                 push    eax             ; dwNewLong
.text$mn:000043F8                 push    0FFFFFFF0h      ; nIndex
.text$mn:000043FA                 mov     ecx, [ebp+arg_0]
.text$mn:000043FD                 mov     edx, [ecx+5Ch]
.text$mn:00004400                 push    edx             ; Y
.text$mn:00004401                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00004407                 cmp     esi, esp
.text$mn:00004409                 call    __RTC_CheckEsp
.text$mn:0000440E                 mov     esi, esp
.text$mn:00004410                 mov     eax, [ebp+hWnd]
.text$mn:00004413                 push    eax             ; hWndNewParent
.text$mn:00004414                 mov     ecx, [ebp+arg_0]
.text$mn:00004417                 mov     edx, [ecx+5Ch]
.text$mn:0000441A                 push    edx             ; nWidth
.text$mn:0000441B                 call    dword ptr ds:__imp__SetParent@8 ; SetParent(x,x)
.text$mn:00004421                 cmp     esi, esp
.text$mn:00004423                 call    __RTC_CheckEsp
.text$mn:00004428                 mov     eax, [ebp+hWnd]
.text$mn:0000442B                 push    eax             ; nHeight
.text$mn:0000442C                 lea     ecx, [ebp+var_F8] ; this
.text$mn:00004432                 call    ??0ClientRect@@QAE@PAUHWND__@@@Z ; ClientRect::ClientRect(HWND__ *)
.text$mn:00004437                 mov     ecx, [eax]
.text$mn:00004439                 mov     [ebp+var_E0], ecx
.text$mn:0000443F                 mov     edx, [eax+4]
.text$mn:00004442                 mov     [ebp+var_DC], edx
.text$mn:00004448                 mov     ecx, [eax+8]
.text$mn:0000444B                 mov     [ebp+var_D8], ecx
.text$mn:00004451                 mov     edx, [eax+0Ch]
.text$mn:00004454                 mov     [ebp+var_D4], edx
.text$mn:0000445A                 sub     esp, 10h
.text$mn:0000445D                 mov     eax, esp
.text$mn:0000445F                 mov     ecx, [ebp+var_E0]
.text$mn:00004465                 mov     [eax], ecx
.text$mn:00004467                 mov     edx, [ebp+var_DC]
.text$mn:0000446D                 mov     [eax+4], edx
.text$mn:00004470                 mov     ecx, [ebp+var_D8]
.text$mn:00004476                 mov     [eax+8], ecx
.text$mn:00004479                 mov     edx, [ebp+var_D4]
.text$mn:0000447F                 mov     [eax+0Ch], edx
.text$mn:00004482                 mov     eax, [ebp+arg_0]
.text$mn:00004485                 mov     ecx, [eax+5Ch]
.text$mn:00004488                 push    ecx             ; hWnd
.text$mn:00004489                 call    ?MoveWindow@@YAXPAUHWND__@@V?$RectT@H@geomutil@@@Z ; MoveWindow(HWND__ *,geomutil::RectT<int>)
.text$mn:0000448E                 add     esp, 14h
.text$mn:00004491                 mov     esi, esp
.text$mn:00004493                 push    5               ; nCmdShow
.text$mn:00004495                 mov     eax, [ebp+arg_0]
.text$mn:00004498                 mov     ecx, [eax+5Ch]
.text$mn:0000449B                 push    ecx             ; hWnd
.text$mn:0000449C                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:000044A2                 cmp     esi, esp
.text$mn:000044A4                 call    __RTC_CheckEsp
.text$mn:000044A9                 mov     esi, esp
.text$mn:000044AB                 mov     eax, [ebp+arg_0]
.text$mn:000044AE                 mov     ecx, [eax+5Ch]
.text$mn:000044B1                 push    ecx             ; hWnd
.text$mn:000044B2                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:000044B8                 cmp     esi, esp
.text$mn:000044BA                 call    __RTC_CheckEsp
.text$mn:000044BF                 mov     esi, esp
.text$mn:000044C1                 mov     eax, [ebp+arg_0]
.text$mn:000044C4                 mov     ecx, [eax+5Ch]
.text$mn:000044C7                 push    ecx             ; hWnd
.text$mn:000044C8                 call    dword ptr ds:__imp__SetFocus@4 ; SetFocus(x)
.text$mn:000044CE                 cmp     esi, esp
.text$mn:000044D0                 call    __RTC_CheckEsp
.text$mn:000044D5                 pop     edi
.text$mn:000044D6                 pop     esi
.text$mn:000044D7                 pop     ebx
.text$mn:000044D8                 add     esp, 0FCh
.text$mn:000044DE                 cmp     ebp, esp
.text$mn:000044E0                 call    __RTC_CheckEsp
.text$mn:000044E5                 mov     esp, ebp
.text$mn:000044E7                 pop     ebp
.text$mn:000044E8                 retn
.text$mn:000044E8 ?MakePluginWindow@@YAXAAVWindowInfo@@PAUHWND__@@@Z endp
.text$mn:000044E8
.text$mn:000044E8 ; ---------------------------------------------------------------------------
.text$mn:000044E9                 align 4
.text$mn:000044E9 _text$mn        ends
.text$mn:000044E9
.text$mn:000044EC ; ===========================================================================
.text$mn:000044EC
.text$mn:000044EC ; Segment type: Pure code
.text$mn:000044EC ; Segment permissions: Read/Execute
.text$mn:000044EC _text$mn        segment para public 'CODE' use32
.text$mn:000044EC                 assume cs:_text$mn
.text$mn:000044EC                 ;org 44ECh
.text$mn:000044EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000044EC
.text$mn:000044EC ; =============== S U B R O U T I N E =======================================
.text$mn:000044EC
.text$mn:000044EC ; Attributes: bp-based frame
.text$mn:000044EC
.text$mn:000044EC ; protected: wchar_t * * __thiscall Vec<wchar_t *>::MakeSpaceAt(unsigned int, unsigned int, bool)
.text$mn:000044EC                 public ?MakeSpaceAt@?$Vec@PA_W@@IAEPAPA_WII_N@Z
.text$mn:000044EC ?MakeSpaceAt@?$Vec@PA_W@@IAEPAPA_WII_N@Z proc near
.text$mn:000044EC                                         ; CODE XREF: Vec<wchar_t *>::InsertAt(uint,wchar_t * const &)+2Ep
.text$mn:000044EC
.text$mn:000044EC var_FC          = byte ptr -0FCh
.text$mn:000044EC Dst             = dword ptr -38h
.text$mn:000044EC Src             = dword ptr -2Ch
.text$mn:000044EC var_20          = dword ptr -20h
.text$mn:000044EC var_14          = dword ptr -14h
.text$mn:000044EC var_8           = dword ptr -8
.text$mn:000044EC arg_0           = dword ptr  8
.text$mn:000044EC arg_4           = dword ptr  0Ch
.text$mn:000044EC arg_8           = byte ptr  10h
.text$mn:000044EC
.text$mn:000044EC                 push    ebp
.text$mn:000044ED                 mov     ebp, esp
.text$mn:000044EF                 sub     esp, 0FCh
.text$mn:000044F5                 push    ebx
.text$mn:000044F6                 push    esi
.text$mn:000044F7                 push    edi
.text$mn:000044F8                 push    ecx
.text$mn:000044F9                 lea     edi, [ebp+var_FC]
.text$mn:000044FF                 mov     ecx, 3Fh ; '?'
.text$mn:00004504                 mov     eax, 0CCCCCCCCh
.text$mn:00004509                 rep stosd
.text$mn:0000450B                 pop     ecx
.text$mn:0000450C                 mov     [ebp+var_8], ecx
.text$mn:0000450F                 lea     eax, [ebp+arg_0]
.text$mn:00004512                 push    eax
.text$mn:00004513                 mov     ecx, [ebp+var_8]
.text$mn:00004516                 push    ecx
.text$mn:00004517                 call    ??$max@I@std@@YAABIABI0@Z ; std::max<uint>(uint const &,uint const &)
.text$mn:0000451C                 add     esp, 8
.text$mn:0000451F                 mov     edx, [eax]
.text$mn:00004521                 add     edx, [ebp+arg_4]
.text$mn:00004524                 mov     [ebp+var_14], edx
.text$mn:00004527                 movzx   eax, [ebp+arg_8]
.text$mn:0000452B                 test    eax, eax
.text$mn:0000452D                 jnz     short loc_453D
.text$mn:0000452F                 mov     eax, [ebp+var_14]
.text$mn:00004532                 push    eax
.text$mn:00004533                 mov     ecx, [ebp+var_8]
.text$mn:00004536                 call    ?EnsureCapCrash@?$Vec@PA_W@@IAEXI@Z ; Vec<wchar_t *>::EnsureCapCrash(uint)
.text$mn:0000453B                 jmp     short loc_4554
.text$mn:0000453D ; ---------------------------------------------------------------------------
.text$mn:0000453D
.text$mn:0000453D loc_453D:                               ; CODE XREF: Vec<wchar_t *>::MakeSpaceAt(uint,uint,bool)+41j
.text$mn:0000453D                 mov     eax, [ebp+var_14]
.text$mn:00004540                 push    eax
.text$mn:00004541                 mov     ecx, [ebp+var_8]
.text$mn:00004544                 call    ?EnsureCapTry@?$Vec@PA_W@@IAE_NI@Z ; Vec<wchar_t *>::EnsureCapTry(uint)
.text$mn:00004549                 movzx   ecx, al
.text$mn:0000454C                 test    ecx, ecx
.text$mn:0000454E                 jnz     short loc_4554
.text$mn:00004550                 xor     eax, eax
.text$mn:00004552                 jmp     short loc_45B8
.text$mn:00004554 ; ---------------------------------------------------------------------------
.text$mn:00004554
.text$mn:00004554 loc_4554:                               ; CODE XREF: Vec<wchar_t *>::MakeSpaceAt(uint,uint,bool)+4Fj
.text$mn:00004554                                         ; Vec<wchar_t *>::MakeSpaceAt(uint,uint,bool)+62j
.text$mn:00004554                 mov     eax, [ebp+var_8]
.text$mn:00004557                 mov     ecx, [eax+0Ch]
.text$mn:0000455A                 mov     edx, [ebp+arg_0]
.text$mn:0000455D                 lea     eax, [ecx+edx*4]
.text$mn:00004560                 mov     [ebp+var_20], eax
.text$mn:00004563                 mov     eax, [ebp+var_8]
.text$mn:00004566                 mov     ecx, [eax]
.text$mn:00004568                 cmp     ecx, [ebp+arg_0]
.text$mn:0000456B                 jbe     short loc_45AD
.text$mn:0000456D                 mov     eax, [ebp+var_8]
.text$mn:00004570                 mov     ecx, [eax+0Ch]
.text$mn:00004573                 mov     edx, [ebp+arg_0]
.text$mn:00004576                 lea     eax, [ecx+edx*4]
.text$mn:00004579                 mov     [ebp+Src], eax
.text$mn:0000457C                 mov     eax, [ebp+var_8]
.text$mn:0000457F                 mov     ecx, [eax+0Ch]
.text$mn:00004582                 mov     edx, [ebp+arg_0]
.text$mn:00004585                 lea     eax, [ecx+edx*4]
.text$mn:00004588                 mov     ecx, [ebp+arg_4]
.text$mn:0000458B                 lea     edx, [eax+ecx*4]
.text$mn:0000458E                 mov     [ebp+Dst], edx
.text$mn:00004591                 mov     eax, [ebp+var_8]
.text$mn:00004594                 mov     ecx, [eax]
.text$mn:00004596                 sub     ecx, [ebp+arg_0]
.text$mn:00004599                 shl     ecx, 2
.text$mn:0000459C                 push    ecx             ; Size
.text$mn:0000459D                 mov     edx, [ebp+Src]
.text$mn:000045A0                 push    edx             ; Src
.text$mn:000045A1                 mov     eax, [ebp+Dst]
.text$mn:000045A4                 push    eax             ; Dst
.text$mn:000045A5                 call    _memmove
.text$mn:000045AA                 add     esp, 0Ch
.text$mn:000045AD
.text$mn:000045AD loc_45AD:                               ; CODE XREF: Vec<wchar_t *>::MakeSpaceAt(uint,uint,bool)+7Fj
.text$mn:000045AD                 mov     eax, [ebp+var_8]
.text$mn:000045B0                 mov     ecx, [ebp+var_14]
.text$mn:000045B3                 mov     [eax], ecx
.text$mn:000045B5                 mov     eax, [ebp+var_20]
.text$mn:000045B8
.text$mn:000045B8 loc_45B8:                               ; CODE XREF: Vec<wchar_t *>::MakeSpaceAt(uint,uint,bool)+66j
.text$mn:000045B8                 pop     edi
.text$mn:000045B9                 pop     esi
.text$mn:000045BA                 pop     ebx
.text$mn:000045BB                 add     esp, 0FCh
.text$mn:000045C1                 cmp     ebp, esp
.text$mn:000045C3                 call    __RTC_CheckEsp
.text$mn:000045C8                 mov     esp, ebp
.text$mn:000045CA                 pop     ebp
.text$mn:000045CB                 retn    0Ch
.text$mn:000045CB ?MakeSpaceAt@?$Vec@PA_W@@IAEPAPA_WII_N@Z endp
.text$mn:000045CB
.text$mn:000045CB ; ---------------------------------------------------------------------------
.text$mn:000045CE                 align 10h
.text$mn:000045CE _text$mn        ends
.text$mn:000045CE
.text$mn:000045D0 ; ===========================================================================
.text$mn:000045D0
.text$mn:000045D0 ; Segment type: Pure code
.text$mn:000045D0 ; Segment permissions: Read/Execute
.text$mn:000045D0 _text$mn        segment para public 'CODE' use32
.text$mn:000045D0                 assume cs:_text$mn
.text$mn:000045D0                 ;org 45D0h
.text$mn:000045D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045D0
.text$mn:000045D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000045D0
.text$mn:000045D0 ; Attributes: bp-based frame
.text$mn:000045D0
.text$mn:000045D0 ; protected: wchar_t * __thiscall Vec<wchar_t>::MakeSpaceAt(unsigned int, unsigned int, bool)
.text$mn:000045D0                 public ?MakeSpaceAt@?$Vec@_W@@IAEPA_WII_N@Z
.text$mn:000045D0 ?MakeSpaceAt@?$Vec@_W@@IAEPA_WII_N@Z proc near
.text$mn:000045D0                                         ; CODE XREF: Vec<wchar_t>::Append(wchar_t const *,uint)+3Ap
.text$mn:000045D0
.text$mn:000045D0 var_FC          = byte ptr -0FCh
.text$mn:000045D0 Dst             = dword ptr -38h
.text$mn:000045D0 Src             = dword ptr -2Ch
.text$mn:000045D0 var_20          = dword ptr -20h
.text$mn:000045D0 var_14          = dword ptr -14h
.text$mn:000045D0 var_8           = dword ptr -8
.text$mn:000045D0 arg_0           = dword ptr  8
.text$mn:000045D0 arg_4           = dword ptr  0Ch
.text$mn:000045D0 arg_8           = byte ptr  10h
.text$mn:000045D0
.text$mn:000045D0                 push    ebp
.text$mn:000045D1                 mov     ebp, esp
.text$mn:000045D3                 sub     esp, 0FCh
.text$mn:000045D9                 push    ebx
.text$mn:000045DA                 push    esi
.text$mn:000045DB                 push    edi
.text$mn:000045DC                 push    ecx
.text$mn:000045DD                 lea     edi, [ebp+var_FC]
.text$mn:000045E3                 mov     ecx, 3Fh ; '?'
.text$mn:000045E8                 mov     eax, 0CCCCCCCCh
.text$mn:000045ED                 rep stosd
.text$mn:000045EF                 pop     ecx
.text$mn:000045F0                 mov     [ebp+var_8], ecx
.text$mn:000045F3                 lea     eax, [ebp+arg_0]
.text$mn:000045F6                 push    eax
.text$mn:000045F7                 mov     ecx, [ebp+var_8]
.text$mn:000045FA                 push    ecx
.text$mn:000045FB                 call    ??$max@I@std@@YAABIABI0@Z ; std::max<uint>(uint const &,uint const &)
.text$mn:00004600                 add     esp, 8
.text$mn:00004603                 mov     edx, [eax]
.text$mn:00004605                 add     edx, [ebp+arg_4]
.text$mn:00004608                 mov     [ebp+var_14], edx
.text$mn:0000460B                 movzx   eax, [ebp+arg_8]
.text$mn:0000460F                 test    eax, eax
.text$mn:00004611                 jnz     short loc_4621
.text$mn:00004613                 mov     eax, [ebp+var_14]
.text$mn:00004616                 push    eax
.text$mn:00004617                 mov     ecx, [ebp+var_8]
.text$mn:0000461A                 call    ?EnsureCapCrash@?$Vec@_W@@IAEXI@Z ; Vec<wchar_t>::EnsureCapCrash(uint)
.text$mn:0000461F                 jmp     short loc_4638
.text$mn:00004621 ; ---------------------------------------------------------------------------
.text$mn:00004621
.text$mn:00004621 loc_4621:                               ; CODE XREF: Vec<wchar_t>::MakeSpaceAt(uint,uint,bool)+41j
.text$mn:00004621                 mov     eax, [ebp+var_14]
.text$mn:00004624                 push    eax
.text$mn:00004625                 mov     ecx, [ebp+var_8]
.text$mn:00004628                 call    ?EnsureCapTry@?$Vec@_W@@IAE_NI@Z ; Vec<wchar_t>::EnsureCapTry(uint)
.text$mn:0000462D                 movzx   ecx, al
.text$mn:00004630                 test    ecx, ecx
.text$mn:00004632                 jnz     short loc_4638
.text$mn:00004634                 xor     eax, eax
.text$mn:00004636                 jmp     short loc_469B
.text$mn:00004638 ; ---------------------------------------------------------------------------
.text$mn:00004638
.text$mn:00004638 loc_4638:                               ; CODE XREF: Vec<wchar_t>::MakeSpaceAt(uint,uint,bool)+4Fj
.text$mn:00004638                                         ; Vec<wchar_t>::MakeSpaceAt(uint,uint,bool)+62j
.text$mn:00004638                 mov     eax, [ebp+var_8]
.text$mn:0000463B                 mov     ecx, [eax+0Ch]
.text$mn:0000463E                 mov     edx, [ebp+arg_0]
.text$mn:00004641                 lea     eax, [ecx+edx*2]
.text$mn:00004644                 mov     [ebp+var_20], eax
.text$mn:00004647                 mov     eax, [ebp+var_8]
.text$mn:0000464A                 mov     ecx, [eax]
.text$mn:0000464C                 cmp     ecx, [ebp+arg_0]
.text$mn:0000464F                 jbe     short loc_4690
.text$mn:00004651                 mov     eax, [ebp+var_8]
.text$mn:00004654                 mov     ecx, [eax+0Ch]
.text$mn:00004657                 mov     edx, [ebp+arg_0]
.text$mn:0000465A                 lea     eax, [ecx+edx*2]
.text$mn:0000465D                 mov     [ebp+Src], eax
.text$mn:00004660                 mov     eax, [ebp+var_8]
.text$mn:00004663                 mov     ecx, [eax+0Ch]
.text$mn:00004666                 mov     edx, [ebp+arg_0]
.text$mn:00004669                 lea     eax, [ecx+edx*2]
.text$mn:0000466C                 mov     ecx, [ebp+arg_4]
.text$mn:0000466F                 lea     edx, [eax+ecx*2]
.text$mn:00004672                 mov     [ebp+Dst], edx
.text$mn:00004675                 mov     eax, [ebp+var_8]
.text$mn:00004678                 mov     ecx, [eax]
.text$mn:0000467A                 sub     ecx, [ebp+arg_0]
.text$mn:0000467D                 shl     ecx, 1
.text$mn:0000467F                 push    ecx             ; Size
.text$mn:00004680                 mov     edx, [ebp+Src]
.text$mn:00004683                 push    edx             ; Src
.text$mn:00004684                 mov     eax, [ebp+Dst]
.text$mn:00004687                 push    eax             ; Dst
.text$mn:00004688                 call    _memmove
.text$mn:0000468D                 add     esp, 0Ch
.text$mn:00004690
.text$mn:00004690 loc_4690:                               ; CODE XREF: Vec<wchar_t>::MakeSpaceAt(uint,uint,bool)+7Fj
.text$mn:00004690                 mov     eax, [ebp+var_8]
.text$mn:00004693                 mov     ecx, [ebp+var_14]
.text$mn:00004696                 mov     [eax], ecx
.text$mn:00004698                 mov     eax, [ebp+var_20]
.text$mn:0000469B
.text$mn:0000469B loc_469B:                               ; CODE XREF: Vec<wchar_t>::MakeSpaceAt(uint,uint,bool)+66j
.text$mn:0000469B                 pop     edi
.text$mn:0000469C                 pop     esi
.text$mn:0000469D                 pop     ebx
.text$mn:0000469E                 add     esp, 0FCh
.text$mn:000046A4                 cmp     ebp, esp
.text$mn:000046A6                 call    __RTC_CheckEsp
.text$mn:000046AB                 mov     esp, ebp
.text$mn:000046AD                 pop     ebp
.text$mn:000046AE                 retn    0Ch
.text$mn:000046AE ?MakeSpaceAt@?$Vec@_W@@IAEPA_WII_N@Z endp
.text$mn:000046AE
.text$mn:000046AE ; ---------------------------------------------------------------------------
.text$mn:000046B1                 align 4
.text$mn:000046B1 _text$mn        ends
.text$mn:000046B1
.text$mn:000046B4 ; ===========================================================================
.text$mn:000046B4
.text$mn:000046B4 ; Segment type: Pure code
.text$mn:000046B4 ; Segment permissions: Read/Execute
.text$mn:000046B4 _text$mn        segment para public 'CODE' use32
.text$mn:000046B4                 assume cs:_text$mn
.text$mn:000046B4                 ;org 46B4h
.text$mn:000046B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046B4
.text$mn:000046B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000046B4
.text$mn:000046B4 ; Attributes: bp-based frame
.text$mn:000046B4
.text$mn:000046B4 ; int __cdecl MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight)
.text$mn:000046B4                 public ?MoveWindow@@YAXPAUHWND__@@V?$RectT@H@geomutil@@@Z
.text$mn:000046B4 ?MoveWindow@@YAXPAUHWND__@@V?$RectT@H@geomutil@@@Z proc near
.text$mn:000046B4                                         ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+13Dp
.text$mn:000046B4
.text$mn:000046B4 var_C0          = byte ptr -0C0h
.text$mn:000046B4 hWnd            = dword ptr  8
.text$mn:000046B4 X               = dword ptr  0Ch
.text$mn:000046B4 Y               = dword ptr  10h
.text$mn:000046B4 nWidth          = dword ptr  14h
.text$mn:000046B4 nHeight         = dword ptr  18h
.text$mn:000046B4
.text$mn:000046B4                 push    ebp
.text$mn:000046B5                 mov     ebp, esp
.text$mn:000046B7                 sub     esp, 0C0h
.text$mn:000046BD                 push    ebx
.text$mn:000046BE                 push    esi
.text$mn:000046BF                 push    edi
.text$mn:000046C0                 lea     edi, [ebp+var_C0]
.text$mn:000046C6                 mov     ecx, 30h ; '0'
.text$mn:000046CB                 mov     eax, 0CCCCCCCCh
.text$mn:000046D0                 rep stosd
.text$mn:000046D2                 mov     esi, esp
.text$mn:000046D4                 push    1               ; bRepaint
.text$mn:000046D6                 mov     eax, [ebp+nHeight]
.text$mn:000046D9                 push    eax             ; nHeight
.text$mn:000046DA                 mov     ecx, [ebp+nWidth]
.text$mn:000046DD                 push    ecx             ; nWidth
.text$mn:000046DE                 mov     edx, [ebp+Y]
.text$mn:000046E1                 push    edx             ; Y
.text$mn:000046E2                 mov     eax, [ebp+X]
.text$mn:000046E5                 push    eax             ; X
.text$mn:000046E6                 mov     ecx, [ebp+hWnd]
.text$mn:000046E9                 push    ecx             ; hWnd
.text$mn:000046EA                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:000046F0                 cmp     esi, esp
.text$mn:000046F2                 call    __RTC_CheckEsp
.text$mn:000046F7                 pop     edi
.text$mn:000046F8                 pop     esi
.text$mn:000046F9                 pop     ebx
.text$mn:000046FA                 add     esp, 0C0h
.text$mn:00004700                 cmp     ebp, esp
.text$mn:00004702                 call    __RTC_CheckEsp
.text$mn:00004707                 mov     esp, ebp
.text$mn:00004709                 pop     ebp
.text$mn:0000470A                 retn
.text$mn:0000470A ?MoveWindow@@YAXPAUHWND__@@V?$RectT@H@geomutil@@@Z endp
.text$mn:0000470A
.text$mn:0000470A ; ---------------------------------------------------------------------------
.text$mn:0000470B                 align 4
.text$mn:0000470B _text$mn        ends
.text$mn:0000470B
.text$mn:0000470C ; ===========================================================================
.text$mn:0000470C
.text$mn:0000470C ; Segment type: Pure code
.text$mn:0000470C ; Segment permissions: Read/Execute
.text$mn:0000470C _text$mn        segment para public 'CODE' use32
.text$mn:0000470C                 assume cs:_text$mn
.text$mn:0000470C                 ;org 470Ch
.text$mn:0000470C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000470C
.text$mn:0000470C ; =============== S U B R O U T I N E =======================================
.text$mn:0000470C
.text$mn:0000470C ; Attributes: bp-based frame
.text$mn:0000470C
.text$mn:0000470C ; void __cdecl OpenUsingDde(struct HWND__ *, wchar_t const *, class CommandLineInfo &, bool)
.text$mn:0000470C ?OpenUsingDde@@YAXPAUHWND__@@PB_WAAVCommandLineInfo@@_N@Z proc near
.text$mn:0000470C                                         ; CODE XREF: WinMain(x,x,x,x)+4B6p
.text$mn:0000470C
.text$mn:0000470C var_364         = qword ptr -364h
.text$mn:0000470C var_348         = byte ptr -348h
.text$mn:0000470C var_284         = dword ptr -284h
.text$mn:0000470C lParam          = dword ptr -278h
.text$mn:0000470C var_274         = dword ptr -274h
.text$mn:0000470C var_270         = dword ptr -270h
.text$mn:0000470C var_264         = dword ptr -264h
.text$mn:0000470C var_258         = dword ptr -258h
.text$mn:0000470C var_24C         = byte ptr -24Ch
.text$mn:0000470C Buffer          = word ptr -210h
.text$mn:0000470C var_4           = dword ptr -4
.text$mn:0000470C hWnd            = dword ptr  8
.text$mn:0000470C lpFileName      = dword ptr  0Ch
.text$mn:0000470C arg_8           = dword ptr  10h
.text$mn:0000470C arg_C           = byte ptr  14h
.text$mn:0000470C
.text$mn:0000470C                 push    ebp
.text$mn:0000470D                 mov     ebp, esp
.text$mn:0000470F                 sub     esp, 348h
.text$mn:00004715                 push    ebx
.text$mn:00004716                 push    esi
.text$mn:00004717                 push    edi             ; wchar_t *
.text$mn:00004718                 lea     edi, [ebp+var_348]
.text$mn:0000471E                 mov     ecx, 0D2h ; '-'
.text$mn:00004723                 mov     eax, 0CCCCCCCCh
.text$mn:00004728                 rep stosd
.text$mn:0000472A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000472F                 xor     eax, ebp
.text$mn:00004731                 mov     [ebp+var_4], eax
.text$mn:00004734                 mov     esi, esp
.text$mn:00004736                 push    0               ; lpFilePart
.text$mn:00004738                 lea     eax, [ebp+Buffer]
.text$mn:0000473E                 push    eax             ; lpBuffer
.text$mn:0000473F                 push    104h            ; nBufferLength
.text$mn:00004744                 mov     ecx, [ebp+lpFileName]
.text$mn:00004747                 push    ecx             ; lpFileName
.text$mn:00004748                 call    dword ptr ds:__imp__GetFullPathNameW@16 ; GetFullPathNameW(x,x,x,x)
.text$mn:0000474E                 cmp     esi, esp
.text$mn:00004750                 call    __RTC_CheckEsp
.text$mn:00004755                 push    0
.text$mn:00004757                 push    0
.text$mn:00004759                 lea     ecx, [ebp+var_24C]
.text$mn:0000475F                 call    ??0?$Str@_W@str@@QAE@IPAVAllocator@@@Z ; str::Str<wchar_t>::Str<wchar_t>(uint,Allocator *)
.text$mn:00004764                 lea     eax, [ebp+Buffer]
.text$mn:0000476A                 push    eax
.text$mn:0000476B                 push    offset ??_C@_1CM@GPNKFOGI@?$AA?$FL?$AAO?$AAp?$AAe?$AAn?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$FN?$AA?$AA@ ; "[Open(\"%s\", 0, 1, 0)]"
.text$mn:00004770                 lea     ecx, [ebp+var_24C]
.text$mn:00004776                 push    ecx
.text$mn:00004777                 call    ?AppendFmt@?$Str@_W@str@@QAAXPB_WZZ ; str::Str<wchar_t>::AppendFmt(wchar_t const *,...)
.text$mn:0000477C                 add     esp, 0Ch
.text$mn:0000477F                 mov     ecx, [ebp+arg_8]
.text$mn:00004782                 add     ecx, 0C0h ; '+'
.text$mn:00004788                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:0000478D                 test    eax, eax
.text$mn:0000478F                 jz      short loc_47C0
.text$mn:00004791                 movzx   eax, [ebp+arg_C]
.text$mn:00004795                 test    eax, eax
.text$mn:00004797                 jz      short loc_47C0
.text$mn:00004799                 mov     eax, [ebp+arg_8]
.text$mn:0000479C                 mov     ecx, [eax+0C0h]
.text$mn:000047A2                 push    ecx
.text$mn:000047A3                 lea     edx, [ebp+Buffer]
.text$mn:000047A9                 push    edx
.text$mn:000047AA                 push    offset ??_C@_1DI@LKFLACJO@?$AA?$FL?$AAG?$AAo?$AAt?$AAo?$AAN?$AAa?$AAm?$AAe?$AAd?$AAD?$AAe?$AAs?$AAt?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$CJ?$AA?$FN?$AA?$AA@ ; "[GotoNamedDest(\"%s\", \"%s\")]"
.text$mn:000047AF                 lea     eax, [ebp+var_24C]
.text$mn:000047B5                 push    eax
.text$mn:000047B6                 call    ?AppendFmt@?$Str@_W@str@@QAAXPB_WZZ ; str::Str<wchar_t>::AppendFmt(wchar_t const *,...)
.text$mn:000047BB                 add     esp, 10h
.text$mn:000047BE                 jmp     short loc_47F9
.text$mn:000047C0 ; ---------------------------------------------------------------------------
.text$mn:000047C0
.text$mn:000047C0 loc_47C0:                               ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+83j
.text$mn:000047C0                                         ; OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+8Bj
.text$mn:000047C0                 mov     eax, [ebp+arg_8]
.text$mn:000047C3                 cmp     dword ptr [eax+0C4h], 0
.text$mn:000047CA                 jle     short loc_47F9
.text$mn:000047CC                 movzx   eax, [ebp+arg_C]
.text$mn:000047D0                 test    eax, eax
.text$mn:000047D2                 jz      short loc_47F9
.text$mn:000047D4                 mov     eax, [ebp+arg_8]
.text$mn:000047D7                 mov     ecx, [eax+0C4h]
.text$mn:000047DD                 push    ecx
.text$mn:000047DE                 lea     edx, [ebp+Buffer]
.text$mn:000047E4                 push    edx
.text$mn:000047E5                 push    offset ??_C@_1CK@JBMPFIK@?$AA?$FL?$AAG?$AAo?$AAt?$AAo?$AAP?$AAa?$AAg?$AAe?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$FN?$AA?$AA@ ; "[GotoPage(\"%s\", %d)]"
.text$mn:000047EA                 lea     eax, [ebp+var_24C]
.text$mn:000047F0                 push    eax
.text$mn:000047F1                 call    ?AppendFmt@?$Str@_W@str@@QAAXPB_WZZ ; str::Str<wchar_t>::AppendFmt(wchar_t const *,...)
.text$mn:000047F6                 add     esp, 10h
.text$mn:000047F9
.text$mn:000047F9 loc_47F9:                               ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+B2j
.text$mn:000047F9                                         ; OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+BEj ...
.text$mn:000047F9                 mov     eax, [ebp+arg_8]
.text$mn:000047FC                 cmp     dword ptr [eax+0CCh], 0
.text$mn:00004803                 jnz     short loc_4835
.text$mn:00004805                 mov     eax, [ebp+arg_8]
.text$mn:00004808                 movss   xmm0, dword ptr [eax+0D0h]
.text$mn:00004810                 ucomiss xmm0, ds:__real@c2c60000
.text$mn:00004817                 lahf
.text$mn:00004818                 test    ah, 44h
.text$mn:0000481B                 jp      short loc_4835
.text$mn:0000481D                 mov     eax, [ebp+arg_8]
.text$mn:00004820                 cmp     dword ptr [eax+0D4h], 0FFFFFFFFh
.text$mn:00004827                 jz      short loc_489E
.text$mn:00004829                 mov     eax, [ebp+arg_8]
.text$mn:0000482C                 cmp     dword ptr [eax+0D8h], 0FFFFFFFFh
.text$mn:00004833                 jz      short loc_489E
.text$mn:00004835
.text$mn:00004835 loc_4835:                               ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+F7j
.text$mn:00004835                                         ; OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+10Fj
.text$mn:00004835                 movzx   eax, [ebp+arg_C]
.text$mn:00004839                 test    eax, eax
.text$mn:0000483B                 jz      short loc_489E
.text$mn:0000483D                 mov     eax, [ebp+arg_8]
.text$mn:00004840                 mov     ecx, [eax+0CCh]
.text$mn:00004846                 push    ecx
.text$mn:00004847                 call    ?FromDisplayMode@conv@prefs@@YAPB_WW4DisplayMode@@@Z ; prefs::conv::FromDisplayMode(DisplayMode)
.text$mn:0000484C                 add     esp, 4
.text$mn:0000484F                 mov     [ebp+var_258], eax
.text$mn:00004855                 mov     eax, [ebp+arg_8]
.text$mn:00004858                 mov     ecx, [eax+0D8h]
.text$mn:0000485E                 push    ecx
.text$mn:0000485F                 mov     edx, [ebp+arg_8]
.text$mn:00004862                 mov     eax, [edx+0D4h]
.text$mn:00004868                 push    eax
.text$mn:00004869                 mov     ecx, [ebp+arg_8]
.text$mn:0000486C                 cvtss2sd xmm0, dword ptr [ecx+0D0h]
.text$mn:00004874                 sub     esp, 8
.text$mn:00004877                 movsd   [esp+364h+var_364], xmm0
.text$mn:0000487C                 mov     edx, [ebp+var_258]
.text$mn:00004882                 push    edx
.text$mn:00004883                 lea     eax, [ebp+Buffer]
.text$mn:00004889                 push    eax
.text$mn:0000488A                 push    offset ??_C@_1EI@KKJLKIFH@?$AA?$FL?$AAS?$AAe?$AAt?$AAV?$AAi?$AAe?$AAw?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CF?$AA?4?$AA2?$AAf?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF@ ; "[SetView(\"%s\", \"%s\", %.2f, %d, %d)]"
.text$mn:0000488F                 lea     ecx, [ebp+var_24C]
.text$mn:00004895                 push    ecx
.text$mn:00004896                 call    ?AppendFmt@?$Str@_W@str@@QAAXPB_WZZ ; str::Str<wchar_t>::AppendFmt(wchar_t const *,...)
.text$mn:0000489B                 add     esp, 20h
.text$mn:0000489E
.text$mn:0000489E loc_489E:                               ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+11Bj
.text$mn:0000489E                                         ; OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+127j ...
.text$mn:0000489E                 mov     ecx, [ebp+arg_8]
.text$mn:000048A1                 add     ecx, 0B4h ; ''
.text$mn:000048A7                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:000048AC                 test    eax, eax
.text$mn:000048AE                 jz      short loc_4916
.text$mn:000048B0                 mov     eax, [ebp+arg_8]
.text$mn:000048B3                 cmp     dword ptr [eax+0B8h], 0
.text$mn:000048BA                 jz      short loc_4916
.text$mn:000048BC                 mov     ecx, [ebp+arg_8]
.text$mn:000048BF                 add     ecx, 0B4h ; ''
.text$mn:000048C5                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:000048CA                 push    eax             ; this
.text$mn:000048CB                 call    ?Normalize@path@@YAPA_WPB_W@Z ; path::Normalize(wchar_t const *)
.text$mn:000048D0                 add     esp, 4
.text$mn:000048D3                 push    eax
.text$mn:000048D4                 lea     ecx, [ebp+var_264]
.text$mn:000048DA                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:000048DF                 mov     eax, [ebp+arg_8]
.text$mn:000048E2                 mov     ecx, [eax+0B8h]
.text$mn:000048E8                 push    ecx
.text$mn:000048E9                 mov     edx, [ebp+var_264]
.text$mn:000048EF                 push    edx
.text$mn:000048F0                 lea     eax, [ebp+Buffer]
.text$mn:000048F6                 push    eax
.text$mn:000048F7                 push    offset ??_C@_1FC@FIABJECI@?$AA?$FL?$AAF?$AAo?$AAr?$AAw?$AAa?$AAr?$AAd?$AAS?$AAe?$AAa?$AAr?$AAc?$AAh?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0@ ; "[ForwardSearch(\"%s\", \"%s\", %d, 0, 0"...
.text$mn:000048FC                 lea     ecx, [ebp+var_24C]
.text$mn:00004902                 push    ecx
.text$mn:00004903                 call    ?AppendFmt@?$Str@_W@str@@QAAXPB_WZZ ; str::Str<wchar_t>::AppendFmt(wchar_t const *,...)
.text$mn:00004908                 add     esp, 14h
.text$mn:0000490B                 lea     ecx, [ebp+var_264]
.text$mn:00004911                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:00004916
.text$mn:00004916 loc_4916:                               ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+1A2j
.text$mn:00004916                                         ; OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+1AEj
.text$mn:00004916                 mov     eax, [ebp+arg_8]
.text$mn:00004919                 movzx   ecx, byte ptr [eax+0BCh]
.text$mn:00004920                 test    ecx, ecx
.text$mn:00004922                 jnz     short loc_498E
.text$mn:00004924                 mov     [ebp+lParam], 44646557h
.text$mn:0000492E                 lea     ecx, [ebp+var_24C]
.text$mn:00004934                 call    ?Size@?$Vec@_W@@QBEIXZ ; Vec<wchar_t>::Size(void)
.text$mn:00004939                 lea     eax, [eax+eax+2]
.text$mn:0000493D                 mov     [ebp+var_274], eax
.text$mn:00004943                 lea     ecx, [ebp+var_24C]
.text$mn:00004949                 call    ?Get@?$Str@_W@str@@QBEPA_WXZ ; str::Str<wchar_t>::Get(void)
.text$mn:0000494E                 mov     [ebp+var_270], eax
.text$mn:00004954                 mov     esi, esp
.text$mn:00004956                 lea     eax, [ebp+lParam]
.text$mn:0000495C                 push    eax             ; lParam
.text$mn:0000495D                 push    0               ; wParam
.text$mn:0000495F                 push    4Ah ; 'J'       ; Msg
.text$mn:00004961                 mov     ecx, [ebp+hWnd]
.text$mn:00004964                 push    ecx             ; hWnd
.text$mn:00004965                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000496B                 cmp     esi, esp
.text$mn:0000496D                 call    __RTC_CheckEsp
.text$mn:00004972                 mov     [ebp+var_284], eax
.text$mn:00004978                 cmp     [ebp+var_284], 0
.text$mn:0000497F                 jz      short loc_498E
.text$mn:00004981                 lea     ecx, [ebp+var_24C]
.text$mn:00004987                 call    ??1?$Str@_W@str@@QAE@XZ ; str::Str<wchar_t>::~Str<wchar_t>(void)
.text$mn:0000498C                 jmp     short loc_49B7
.text$mn:0000498E ; ---------------------------------------------------------------------------
.text$mn:0000498E
.text$mn:0000498E loc_498E:                               ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+216j
.text$mn:0000498E                                         ; OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+273j
.text$mn:0000498E                 lea     ecx, [ebp+var_24C]
.text$mn:00004994                 call    ?Get@?$Str@_W@str@@QBEPA_WXZ ; str::Str<wchar_t>::Get(void)
.text$mn:00004999                 push    eax             ; wchar_t *
.text$mn:0000499A                 push    offset ??_C@_1BA@IBGCEPCN@?$AAc?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?$AA@ ; "control"
.text$mn:0000499F                 push    offset ??_C@_1BA@DNELNMNE@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA?$AA@ ; "SUMATRA"
.text$mn:000049A4                 call    ?DDEExecute@@YA_NPB_W00@Z ; DDEExecute(wchar_t const *,wchar_t const *,wchar_t const *)
.text$mn:000049A9                 add     esp, 0Ch
.text$mn:000049AC                 lea     ecx, [ebp+var_24C]
.text$mn:000049B2                 call    ??1?$Str@_W@str@@QAE@XZ ; str::Str<wchar_t>::~Str<wchar_t>(void)
.text$mn:000049B7
.text$mn:000049B7 loc_49B7:                               ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+280j
.text$mn:000049B7                 push    edx
.text$mn:000049B8                 mov     ecx, ebp
.text$mn:000049BA                 push    eax
.text$mn:000049BB                 lea     edx, $LN16
.text$mn:000049C1                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:000049C6                 pop     eax
.text$mn:000049C7                 pop     edx
.text$mn:000049C8                 pop     edi
.text$mn:000049C9                 pop     esi
.text$mn:000049CA                 pop     ebx
.text$mn:000049CB                 mov     ecx, [ebp+var_4]
.text$mn:000049CE                 xor     ecx, ebp
.text$mn:000049D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000049D5                 add     esp, 348h
.text$mn:000049DB                 cmp     ebp, esp
.text$mn:000049DD                 call    __RTC_CheckEsp
.text$mn:000049E2                 mov     esp, ebp
.text$mn:000049E4                 pop     ebp
.text$mn:000049E5                 retn
.text$mn:000049E5 ?OpenUsingDde@@YAXPAUHWND__@@PB_WAAVCommandLineInfo@@_N@Z endp
.text$mn:000049E5
.text$mn:000049E5 ; ---------------------------------------------------------------------------
.text$mn:000049E6                 align 4
.text$mn:000049E8 $LN16           dd 4                    ; DATA XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+2AFo
.text$mn:000049EC                 dd offset $LN15
.text$mn:000049F0 $LN15           dd 0FFFFFDF0h, 208h     ; DATA XREF: .text$mn:000049ECo
.text$mn:000049F8                 dd offset $LN11_0       ; "fullpath"
.text$mn:000049FC                 dd 0FFFFFDB4h, 34h
.text$mn:00004A04                 dd offset $LN12_0       ; "cmd"
.text$mn:00004A08                 dd 0FFFFFD9Ch, 4
.text$mn:00004A10                 dd offset $LN13_0       ; "sourcePath"
.text$mn:00004A14                 dd 0FFFFFD88h, 0Ch
.text$mn:00004A1C                 dd offset $LN14
.text$mn:00004A20 $LN14           dd 736463h              ; DATA XREF: .text$mn:00004A1Co
.text$mn:00004A24 $LN13_0         db 'sourcePath',0       ; DATA XREF: .text$mn:00004A10o
.text$mn:00004A2F $LN12_0         db 'cmd',0              ; DATA XREF: .text$mn:00004A04o
.text$mn:00004A33 $LN11_0         db 'fullpath',0         ; DATA XREF: .text$mn:000049F8o
.text$mn:00004A33 _text$mn        ends
.text$mn:00004A33
.text$mn:00004A3C ; ===========================================================================
.text$mn:00004A3C
.text$mn:00004A3C ; Segment type: Pure code
.text$mn:00004A3C ; Segment permissions: Read/Execute
.text$mn:00004A3C _text$mn        segment para public 'CODE' use32
.text$mn:00004A3C                 assume cs:_text$mn
.text$mn:00004A3C                 ;org 4A3Ch
.text$mn:00004A3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A3C
.text$mn:00004A3C ; =============== S U B R O U T I N E =======================================
.text$mn:00004A3C
.text$mn:00004A3C ; Attributes: bp-based frame
.text$mn:00004A3C
.text$mn:00004A3C ; public: wchar_t * __thiscall Vec<wchar_t *>::Pop(void)
.text$mn:00004A3C                 public ?Pop@?$Vec@PA_W@@QAEPA_WXZ
.text$mn:00004A3C ?Pop@?$Vec@PA_W@@QAEPA_WXZ proc near    ; CODE XREF: SetupPluginMode(CommandLineInfo &)+B5p
.text$mn:00004A3C                                         ; WinMain(x,x,x,x)+656p
.text$mn:00004A3C
.text$mn:00004A3C var_DC          = byte ptr -0DCh
.text$mn:00004A3C var_D9          = byte ptr -0D9h
.text$mn:00004A3C var_14          = dword ptr -14h
.text$mn:00004A3C var_8           = dword ptr -8
.text$mn:00004A3C
.text$mn:00004A3C                 push    ebp
.text$mn:00004A3D                 mov     ebp, esp
.text$mn:00004A3F                 sub     esp, 0DCh
.text$mn:00004A45                 push    ebx
.text$mn:00004A46                 push    esi
.text$mn:00004A47                 push    edi
.text$mn:00004A48                 push    ecx
.text$mn:00004A49                 lea     edi, [ebp+var_DC]
.text$mn:00004A4F                 mov     ecx, 37h ; '7'
.text$mn:00004A54                 mov     eax, 0CCCCCCCCh
.text$mn:00004A59                 rep stosd
.text$mn:00004A5B                 pop     ecx
.text$mn:00004A5C                 mov     [ebp+var_8], ecx
.text$mn:00004A5F
.text$mn:00004A5F loc_4A5F:                               ; CODE XREF: Vec<wchar_t *>::Pop(void)+25j
.text$mn:00004A5F                                         ; Vec<wchar_t *>::Pop(void)+51j
.text$mn:00004A5F                 xor     eax, eax
.text$mn:00004A61                 jnz     short loc_4A5F
.text$mn:00004A63                 mov     eax, [ebp+var_8]
.text$mn:00004A66                 cmp     dword ptr [eax], 0
.text$mn:00004A69                 jnz     short loc_4A74
.text$mn:00004A6B                 mov     [ebp+var_D9], 1
.text$mn:00004A72                 jmp     short loc_4A7B
.text$mn:00004A74 ; ---------------------------------------------------------------------------
.text$mn:00004A74
.text$mn:00004A74 loc_4A74:                               ; CODE XREF: Vec<wchar_t *>::Pop(void)+2Dj
.text$mn:00004A74                 mov     [ebp+var_D9], 0
.text$mn:00004A7B
.text$mn:00004A7B loc_4A7B:                               ; CODE XREF: Vec<wchar_t *>::Pop(void)+36j
.text$mn:00004A7B                 movzx   ecx, [ebp+var_D9]
.text$mn:00004A82                 push    ecx             ; bool
.text$mn:00004A83                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00004A88                 add     esp, 4
.text$mn:00004A8B                 xor     eax, eax
.text$mn:00004A8D                 jnz     short loc_4A5F
.text$mn:00004A8F                 mov     eax, [ebp+var_8]
.text$mn:00004A92                 mov     ecx, [eax]
.text$mn:00004A94                 sub     ecx, 1
.text$mn:00004A97                 push    ecx
.text$mn:00004A98                 mov     ecx, [ebp+var_8]
.text$mn:00004A9B                 call    ?At@?$Vec@PA_W@@QBEAAPA_WI@Z ; Vec<wchar_t *>::At(uint)
.text$mn:00004AA0                 mov     edx, [eax]
.text$mn:00004AA2                 mov     [ebp+var_14], edx
.text$mn:00004AA5                 mov     eax, [ebp+var_8]
.text$mn:00004AA8                 mov     ecx, [eax]
.text$mn:00004AAA                 sub     ecx, 1
.text$mn:00004AAD                 push    ecx
.text$mn:00004AAE                 mov     ecx, [ebp+var_8]
.text$mn:00004AB1                 call    ?RemoveAtFast@?$Vec@PA_W@@QAEXI@Z ; Vec<wchar_t *>::RemoveAtFast(uint)
.text$mn:00004AB6                 mov     eax, [ebp+var_14]
.text$mn:00004AB9                 pop     edi
.text$mn:00004ABA                 pop     esi
.text$mn:00004ABB                 pop     ebx
.text$mn:00004ABC                 add     esp, 0DCh
.text$mn:00004AC2                 cmp     ebp, esp
.text$mn:00004AC4                 call    __RTC_CheckEsp
.text$mn:00004AC9                 mov     esp, ebp
.text$mn:00004ACB                 pop     ebp
.text$mn:00004ACC                 retn
.text$mn:00004ACC ?Pop@?$Vec@PA_W@@QAEPA_WXZ endp
.text$mn:00004ACC
.text$mn:00004ACC ; ---------------------------------------------------------------------------
.text$mn:00004ACD                 align 10h
.text$mn:00004ACD _text$mn        ends
.text$mn:00004ACD
.text$mn:00004AD0 ; ===========================================================================
.text$mn:00004AD0
.text$mn:00004AD0 ; Segment type: Pure code
.text$mn:00004AD0 ; Segment permissions: Read/Execute
.text$mn:00004AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00004AD0                 assume cs:_text$mn
.text$mn:00004AD0                 ;org 4AD0h
.text$mn:00004AD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AD0
.text$mn:00004AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AD0
.text$mn:00004AD0 ; Attributes: bp-based frame
.text$mn:00004AD0
.text$mn:00004AD0 ; public: wchar_t * __thiscall Vec<wchar_t *>::PopAt(unsigned int)
.text$mn:00004AD0                 public ?PopAt@?$Vec@PA_W@@QAEPA_WI@Z
.text$mn:00004AD0 ?PopAt@?$Vec@PA_W@@QAEPA_WI@Z proc near ; CODE XREF: FileExistenceChecker::Run(void)+B0p
.text$mn:00004AD0
.text$mn:00004AD0 var_DC          = byte ptr -0DCh
.text$mn:00004AD0 var_D9          = byte ptr -0D9h
.text$mn:00004AD0 var_14          = dword ptr -14h
.text$mn:00004AD0 var_8           = dword ptr -8
.text$mn:00004AD0 arg_0           = dword ptr  8
.text$mn:00004AD0
.text$mn:00004AD0                 push    ebp
.text$mn:00004AD1                 mov     ebp, esp
.text$mn:00004AD3                 sub     esp, 0DCh
.text$mn:00004AD9                 push    ebx
.text$mn:00004ADA                 push    esi
.text$mn:00004ADB                 push    edi
.text$mn:00004ADC                 push    ecx
.text$mn:00004ADD                 lea     edi, [ebp+var_DC]
.text$mn:00004AE3                 mov     ecx, 37h ; '7'
.text$mn:00004AE8                 mov     eax, 0CCCCCCCCh
.text$mn:00004AED                 rep stosd
.text$mn:00004AEF                 pop     ecx
.text$mn:00004AF0                 mov     [ebp+var_8], ecx
.text$mn:00004AF3
.text$mn:00004AF3 loc_4AF3:                               ; CODE XREF: Vec<wchar_t *>::PopAt(uint)+25j
.text$mn:00004AF3                                         ; Vec<wchar_t *>::PopAt(uint)+53j
.text$mn:00004AF3                 xor     eax, eax
.text$mn:00004AF5                 jnz     short loc_4AF3
.text$mn:00004AF7                 mov     eax, [ebp+var_8]
.text$mn:00004AFA                 mov     ecx, [ebp+arg_0]
.text$mn:00004AFD                 cmp     ecx, [eax]
.text$mn:00004AFF                 jb      short loc_4B0A
.text$mn:00004B01                 mov     [ebp+var_D9], 1
.text$mn:00004B08                 jmp     short loc_4B11
.text$mn:00004B0A ; ---------------------------------------------------------------------------
.text$mn:00004B0A
.text$mn:00004B0A loc_4B0A:                               ; CODE XREF: Vec<wchar_t *>::PopAt(uint)+2Fj
.text$mn:00004B0A                 mov     [ebp+var_D9], 0
.text$mn:00004B11
.text$mn:00004B11 loc_4B11:                               ; CODE XREF: Vec<wchar_t *>::PopAt(uint)+38j
.text$mn:00004B11                 movzx   edx, [ebp+var_D9]
.text$mn:00004B18                 push    edx             ; bool
.text$mn:00004B19                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00004B1E                 add     esp, 4
.text$mn:00004B21                 xor     eax, eax
.text$mn:00004B23                 jnz     short loc_4AF3
.text$mn:00004B25                 mov     eax, [ebp+arg_0]
.text$mn:00004B28                 push    eax
.text$mn:00004B29                 mov     ecx, [ebp+var_8]
.text$mn:00004B2C                 call    ?At@?$Vec@PA_W@@QBEAAPA_WI@Z ; Vec<wchar_t *>::At(uint)
.text$mn:00004B31                 mov     ecx, [eax]
.text$mn:00004B33                 mov     [ebp+var_14], ecx
.text$mn:00004B36                 push    1
.text$mn:00004B38                 mov     eax, [ebp+arg_0]
.text$mn:00004B3B                 push    eax
.text$mn:00004B3C                 mov     ecx, [ebp+var_8]
.text$mn:00004B3F                 call    ?RemoveAt@?$Vec@PA_W@@QAEXII@Z ; Vec<wchar_t *>::RemoveAt(uint,uint)
.text$mn:00004B44                 mov     eax, [ebp+var_14]
.text$mn:00004B47                 pop     edi
.text$mn:00004B48                 pop     esi
.text$mn:00004B49                 pop     ebx
.text$mn:00004B4A                 add     esp, 0DCh
.text$mn:00004B50                 cmp     ebp, esp
.text$mn:00004B52                 call    __RTC_CheckEsp
.text$mn:00004B57                 mov     esp, ebp
.text$mn:00004B59                 pop     ebp
.text$mn:00004B5A                 retn    4
.text$mn:00004B5A ?PopAt@?$Vec@PA_W@@QAEPA_WI@Z endp
.text$mn:00004B5A
.text$mn:00004B5A ; ---------------------------------------------------------------------------
.text$mn:00004B5D                 align 10h
.text$mn:00004B5D _text$mn        ends
.text$mn:00004B5D
.text$mn:00004B60 ; ===========================================================================
.text$mn:00004B60
.text$mn:00004B60 ; Segment type: Pure code
.text$mn:00004B60 ; Segment permissions: Read/Execute
.text$mn:00004B60 _text$mn        segment para public 'CODE' use32
.text$mn:00004B60                 assume cs:_text$mn
.text$mn:00004B60                 ;org 4B60h
.text$mn:00004B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B60
.text$mn:00004B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B60
.text$mn:00004B60 ; Attributes: bp-based frame
.text$mn:00004B60
.text$mn:00004B60 ; bool __cdecl RegisterForPdfExtentions(struct HWND__ *)
.text$mn:00004B60 ?RegisterForPdfExtentions@@YA_NPAUHWND__@@@Z proc near
.text$mn:00004B60                                         ; CODE XREF: WinMain(x,x,x,x)+98Ep
.text$mn:00004B60
.text$mn:00004B60 var_D0          = dword ptr -0D0h
.text$mn:00004B60 var_8           = dword ptr -8
.text$mn:00004B60 arg_0           = dword ptr  8
.text$mn:00004B60
.text$mn:00004B60                 push    ebp
.text$mn:00004B61                 mov     ebp, esp
.text$mn:00004B63                 sub     esp, 0D0h
.text$mn:00004B69                 push    ebx
.text$mn:00004B6A                 push    esi
.text$mn:00004B6B                 push    edi             ; wchar_t *
.text$mn:00004B6C                 lea     edi, [ebp+var_D0]
.text$mn:00004B72                 mov     ecx, 34h ; '4'
.text$mn:00004B77                 mov     eax, 0CCCCCCCCh
.text$mn:00004B7C                 rep stosd
.text$mn:00004B7E                 call    ?IsRunningInPortableMode@@YA_NXZ ; IsRunningInPortableMode(void)
.text$mn:00004B83                 movzx   eax, al
.text$mn:00004B86                 test    eax, eax
.text$mn:00004B88                 jnz     short loc_4BA4
.text$mn:00004B8A                 push    8               ; int
.text$mn:00004B8C                 call    ?HasPermission@@YA_NH@Z ; HasPermission(int)
.text$mn:00004B91                 add     esp, 4
.text$mn:00004B94                 movzx   eax, al
.text$mn:00004B97                 test    eax, eax
.text$mn:00004B99                 jz      short loc_4BA4
.text$mn:00004B9B                 cmp     dword ptr ds:?gPluginURL@@3PB_WB, 0 ; wchar_t const * const gPluginURL
.text$mn:00004BA2                 jz      short loc_4BAB
.text$mn:00004BA4
.text$mn:00004BA4 loc_4BA4:                               ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+28j
.text$mn:00004BA4                                         ; RegisterForPdfExtentions(HWND__ *)+39j
.text$mn:00004BA4                 xor     al, al
.text$mn:00004BA6                 jmp     loc_4C4B
.text$mn:00004BAB ; ---------------------------------------------------------------------------
.text$mn:00004BAB
.text$mn:00004BAB loc_4BAB:                               ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+42j
.text$mn:00004BAB                 call    ?IsExeAssociatedWithPdfExtension@@YA_NXZ ; IsExeAssociatedWithPdfExtension(void)
.text$mn:00004BB0                 movzx   eax, al
.text$mn:00004BB3                 test    eax, eax
.text$mn:00004BB5                 jz      short loc_4BBE
.text$mn:00004BB7                 mov     al, 1
.text$mn:00004BB9                 jmp     loc_4C4B
.text$mn:00004BBE ; ---------------------------------------------------------------------------
.text$mn:00004BBE
.text$mn:00004BBE loc_4BBE:                               ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+55j
.text$mn:00004BBE                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00004BC3                 movzx   ecx, byte ptr [eax+0B4h]
.text$mn:00004BCA                 test    ecx, ecx
.text$mn:00004BCC                 jnz     short loc_4C20
.text$mn:00004BCE                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00004BD3                 add     eax, 0B4h ; ''
.text$mn:00004BD8                 push    eax             ; bool *
.text$mn:00004BD9                 mov     ecx, [ebp+arg_0]
.text$mn:00004BDC                 push    ecx             ; HWND
.text$mn:00004BDD                 call    ?Dialog_PdfAssociate@@YAHPAUHWND__@@PA_N@Z ; Dialog_PdfAssociate(HWND__ *,bool *)
.text$mn:00004BE2                 add     esp, 8
.text$mn:00004BE5                 mov     [ebp+var_8], eax
.text$mn:00004BE8                 cmp     [ebp+var_8], 6
.text$mn:00004BEC                 jnz     short loc_4BFA
.text$mn:00004BEE                 mov     [ebp+var_D0], offset ??_C@_19GMJJNAOJ@?$AA?4?$AAp?$AAd?$AAf?$AA?$AA@ ; ".pdf"
.text$mn:00004BF8                 jmp     short loc_4C04
.text$mn:00004BFA ; ---------------------------------------------------------------------------
.text$mn:00004BFA
.text$mn:00004BFA loc_4BFA:                               ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+8Cj
.text$mn:00004BFA                 mov     [ebp+var_D0], 0
.text$mn:00004C04
.text$mn:00004C04 loc_4C04:                               ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+98j
.text$mn:00004C04                 mov     eax, [ebp+var_D0]
.text$mn:00004C0A                 push    eax             ; wchar_t **
.text$mn:00004C0B                 mov     ecx, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00004C11                 add     ecx, 0B0h ; ''
.text$mn:00004C17                 push    ecx             ; this
.text$mn:00004C18                 call    ?ReplacePtr@str@@YAXPAPA_WPB_W@Z ; str::ReplacePtr(wchar_t * *,wchar_t const *)
.text$mn:00004C1D                 add     esp, 8
.text$mn:00004C20
.text$mn:00004C20 loc_4C20:                               ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+6Cj
.text$mn:00004C20                 push    offset ??_C@_19GMJJNAOJ@?$AA?4?$AAp?$AAd?$AAf?$AA?$AA@ ; ".pdf"
.text$mn:00004C25                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00004C2A                 mov     ecx, [eax+0B0h]
.text$mn:00004C30                 push    ecx             ; this
.text$mn:00004C31                 call    ?EqI@str@@YA_NPB_W0@Z ; str::EqI(wchar_t const *,wchar_t const *)
.text$mn:00004C36                 add     esp, 8
.text$mn:00004C39                 movzx   edx, al
.text$mn:00004C3C                 test    edx, edx
.text$mn:00004C3E                 jnz     short loc_4C44
.text$mn:00004C40                 xor     al, al
.text$mn:00004C42                 jmp     short loc_4C4B
.text$mn:00004C44 ; ---------------------------------------------------------------------------
.text$mn:00004C44
.text$mn:00004C44 loc_4C44:                               ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+DEj
.text$mn:00004C44                 call    ?AssociateExeWithPdfExtension@@YAXXZ ; AssociateExeWithPdfExtension(void)
.text$mn:00004C49                 mov     al, 1
.text$mn:00004C4B
.text$mn:00004C4B loc_4C4B:                               ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+46j
.text$mn:00004C4B                                         ; RegisterForPdfExtentions(HWND__ *)+59j ...
.text$mn:00004C4B                 pop     edi
.text$mn:00004C4C                 pop     esi
.text$mn:00004C4D                 pop     ebx
.text$mn:00004C4E                 add     esp, 0D0h
.text$mn:00004C54                 cmp     ebp, esp
.text$mn:00004C56                 call    __RTC_CheckEsp
.text$mn:00004C5B                 mov     esp, ebp
.text$mn:00004C5D                 pop     ebp
.text$mn:00004C5E                 retn
.text$mn:00004C5E ?RegisterForPdfExtentions@@YA_NPAUHWND__@@@Z endp
.text$mn:00004C5E
.text$mn:00004C5E ; ---------------------------------------------------------------------------
.text$mn:00004C5F                 align 10h
.text$mn:00004C5F _text$mn        ends
.text$mn:00004C5F
.text$mn:00004C60 ; ===========================================================================
.text$mn:00004C60
.text$mn:00004C60 ; Segment type: Pure code
.text$mn:00004C60 ; Segment permissions: Read/Execute
.text$mn:00004C60 _text$mn        segment para public 'CODE' use32
.text$mn:00004C60                 assume cs:_text$mn
.text$mn:00004C60                 ;org 4C60h
.text$mn:00004C60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C60
.text$mn:00004C60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C60
.text$mn:00004C60 ; Attributes: bp-based frame
.text$mn:00004C60
.text$mn:00004C60 ; bool __cdecl RegisterWinClass(void)
.text$mn:00004C60 ?RegisterWinClass@@YA_NXZ proc near     ; CODE XREF: WinMain(x,x,x,x)+252p
.text$mn:00004C60
.text$mn:00004C60 var_108         = byte ptr -108h
.text$mn:00004C60 var_105         = byte ptr -105h
.text$mn:00004C60 var_40          = word ptr -40h
.text$mn:00004C60 var_34          = WNDCLASSEXW ptr -34h
.text$mn:00004C60
.text$mn:00004C60                 push    ebp
.text$mn:00004C61                 mov     ebp, esp
.text$mn:00004C63                 sub     esp, 108h
.text$mn:00004C69                 push    ebx
.text$mn:00004C6A                 push    esi
.text$mn:00004C6B                 push    edi
.text$mn:00004C6C                 lea     edi, [ebp+var_108]
.text$mn:00004C72                 mov     ecx, 42h ; 'B'
.text$mn:00004C77                 mov     eax, 0CCCCCCCCh
.text$mn:00004C7C                 rep stosd
.text$mn:00004C7E                 push    offset ?WndProcFrame@@YGJPAUHWND__@@IIJ@Z ; __int32 (__stdcall *)(HWND, unsigned int, unsigned int, __int32)
.text$mn:00004C83                 push    offset ??_C@_1CE@PHGKLOIF@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA_?$AAP?$AAD?$AAF?$AA_?$AAF?$AAR?$AAA?$AAM?$AAE?$AA?$AA@ ; "SUMATRA_PDF_FRAME"
.text$mn:00004C88                 lea     eax, [ebp+var_34]
.text$mn:00004C8B                 push    eax             ; struct tagWNDCLASSEXW *
.text$mn:00004C8C                 call    ?FillWndClassEx@@YAXAAUtagWNDCLASSEXW@@PB_WP6GJPAUHWND__@@IIJ@Z@Z ; FillWndClassEx(tagWNDCLASSEXW &,wchar_t const *,long (*)(HWND__ *,uint,uint,long))
.text$mn:00004C91                 add     esp, 0Ch
.text$mn:00004C94                 mov     esi, esp
.text$mn:00004C96                 push    offset IconName ; lpIconName
.text$mn:00004C98                 mov     edi, esp
.text$mn:00004C9A                 push    0               ; lpModuleName
.text$mn:00004C9C                 call    dword ptr ds:__imp__GetModuleHandleW@4 ; GetModuleHandleW(x)
.text$mn:00004CA2                 cmp     edi, esp
.text$mn:00004CA4                 call    __RTC_CheckEsp
.text$mn:00004CA9                 push    eax             ; hInstance
.text$mn:00004CAA                 call    dword ptr ds:__imp__LoadIconW@8 ; LoadIconW(x,x)
.text$mn:00004CB0                 cmp     esi, esp
.text$mn:00004CB2                 call    __RTC_CheckEsp
.text$mn:00004CB7                 mov     [ebp+var_34.hIcon], eax
.text$mn:00004CBA
.text$mn:00004CBA loc_4CBA:                               ; CODE XREF: RegisterWinClass(void)+5Cj
.text$mn:00004CBA                                         ; RegisterWinClass(void)+86j
.text$mn:00004CBA                 xor     eax, eax
.text$mn:00004CBC                 jnz     short loc_4CBA
.text$mn:00004CBE                 cmp     [ebp+var_34.hIcon], 0
.text$mn:00004CC2                 jnz     short loc_4CCD
.text$mn:00004CC4                 mov     [ebp+var_105], 1
.text$mn:00004CCB                 jmp     short loc_4CD4
.text$mn:00004CCD ; ---------------------------------------------------------------------------
.text$mn:00004CCD
.text$mn:00004CCD loc_4CCD:                               ; CODE XREF: RegisterWinClass(void)+62j
.text$mn:00004CCD                 mov     [ebp+var_105], 0
.text$mn:00004CD4
.text$mn:00004CD4 loc_4CD4:                               ; CODE XREF: RegisterWinClass(void)+6Bj
.text$mn:00004CD4                 movzx   eax, [ebp+var_105]
.text$mn:00004CDB                 push    eax             ; bool
.text$mn:00004CDC                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00004CE1                 add     esp, 4
.text$mn:00004CE4                 xor     eax, eax
.text$mn:00004CE6                 jnz     short loc_4CBA
.text$mn:00004CE8                 mov     esi, esp
.text$mn:00004CEA                 push    4               ; i
.text$mn:00004CEC                 call    dword ptr ds:__imp__GetStockObject@4 ; GetStockObject(x)
.text$mn:00004CF2                 cmp     esi, esp
.text$mn:00004CF4                 call    __RTC_CheckEsp
.text$mn:00004CF9                 mov     [ebp+var_34.hbrBackground], eax
.text$mn:00004CFC                 mov     esi, esp
.text$mn:00004CFE                 lea     eax, [ebp+var_34]
.text$mn:00004D01                 push    eax             ; WNDCLASSEXW *
.text$mn:00004D02                 call    dword ptr ds:__imp__RegisterClassExW@4 ; RegisterClassExW(x)
.text$mn:00004D08                 cmp     esi, esp
.text$mn:00004D0A                 call    __RTC_CheckEsp
.text$mn:00004D0F                 mov     [ebp+var_40], ax
.text$mn:00004D13
.text$mn:00004D13 loc_4D13:                               ; CODE XREF: RegisterWinClass(void)+B5j
.text$mn:00004D13                                         ; RegisterWinClass(void)+E1j
.text$mn:00004D13                 xor     eax, eax
.text$mn:00004D15                 jnz     short loc_4D13
.text$mn:00004D17                 movzx   eax, [ebp+var_40]
.text$mn:00004D1B                 test    eax, eax
.text$mn:00004D1D                 jnz     short loc_4D28
.text$mn:00004D1F                 mov     [ebp+var_105], 1
.text$mn:00004D26                 jmp     short loc_4D2F
.text$mn:00004D28 ; ---------------------------------------------------------------------------
.text$mn:00004D28
.text$mn:00004D28 loc_4D28:                               ; CODE XREF: RegisterWinClass(void)+BDj
.text$mn:00004D28                 mov     [ebp+var_105], 0
.text$mn:00004D2F
.text$mn:00004D2F loc_4D2F:                               ; CODE XREF: RegisterWinClass(void)+C6j
.text$mn:00004D2F                 movzx   ecx, [ebp+var_105]
.text$mn:00004D36                 push    ecx             ; bool
.text$mn:00004D37                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00004D3C                 add     esp, 4
.text$mn:00004D3F                 xor     eax, eax
.text$mn:00004D41                 jnz     short loc_4D13
.text$mn:00004D43                 push    offset ?WndProcCanvas@@YGJPAUHWND__@@IIJ@Z ; __int32 (__stdcall *)(HWND, unsigned int, unsigned int, __int32)
.text$mn:00004D48                 push    offset ??_C@_1CG@HPLMACE@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA_?$AAP?$AAD?$AAF?$AA_?$AAC?$AAA?$AAN?$AAV?$AAA?$AAS?$AA?$AA@ ; "SUMATRA_PDF_CANVAS"
.text$mn:00004D4D                 lea     eax, [ebp+var_34]
.text$mn:00004D50                 push    eax             ; struct tagWNDCLASSEXW *
.text$mn:00004D51                 call    ?FillWndClassEx@@YAXAAUtagWNDCLASSEXW@@PB_WP6GJPAUHWND__@@IIJ@Z@Z ; FillWndClassEx(tagWNDCLASSEXW &,wchar_t const *,long (*)(HWND__ *,uint,uint,long))
.text$mn:00004D56                 add     esp, 0Ch
.text$mn:00004D59                 mov     eax, [ebp+var_34.style]
.text$mn:00004D5C                 or      eax, 8
.text$mn:00004D5F                 mov     [ebp+var_34.style], eax
.text$mn:00004D62                 mov     esi, esp
.text$mn:00004D64                 lea     eax, [ebp+var_34]
.text$mn:00004D67                 push    eax             ; WNDCLASSEXW *
.text$mn:00004D68                 call    dword ptr ds:__imp__RegisterClassExW@4 ; RegisterClassExW(x)
.text$mn:00004D6E                 cmp     esi, esp
.text$mn:00004D70                 call    __RTC_CheckEsp
.text$mn:00004D75                 mov     [ebp+var_40], ax
.text$mn:00004D79
.text$mn:00004D79 loc_4D79:                               ; CODE XREF: RegisterWinClass(void)+11Bj
.text$mn:00004D79                                         ; RegisterWinClass(void)+147j
.text$mn:00004D79                 xor     eax, eax
.text$mn:00004D7B                 jnz     short loc_4D79
.text$mn:00004D7D                 movzx   eax, [ebp+var_40]
.text$mn:00004D81                 test    eax, eax
.text$mn:00004D83                 jnz     short loc_4D8E
.text$mn:00004D85                 mov     [ebp+var_105], 1
.text$mn:00004D8C                 jmp     short loc_4D95
.text$mn:00004D8E ; ---------------------------------------------------------------------------
.text$mn:00004D8E
.text$mn:00004D8E loc_4D8E:                               ; CODE XREF: RegisterWinClass(void)+123j
.text$mn:00004D8E                 mov     [ebp+var_105], 0
.text$mn:00004D95
.text$mn:00004D95 loc_4D95:                               ; CODE XREF: RegisterWinClass(void)+12Cj
.text$mn:00004D95                 movzx   ecx, [ebp+var_105]
.text$mn:00004D9C                 push    ecx             ; bool
.text$mn:00004D9D                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00004DA2                 add     esp, 4
.text$mn:00004DA5                 xor     eax, eax
.text$mn:00004DA7                 jnz     short loc_4D79
.text$mn:00004DA9                 push    offset ?WndProcProperties@@YGJPAUHWND__@@IIJ@Z ; __int32 (__stdcall *)(HWND, unsigned int, unsigned int, __int32)
.text$mn:00004DAE                 push    offset ??_C@_1CO@JNHOBPBF@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA_?$AAP?$AAD?$AAF?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@ ; "SUMATRA_PDF_PROPERTIES"
.text$mn:00004DB3                 lea     eax, [ebp+var_34]
.text$mn:00004DB6                 push    eax             ; struct tagWNDCLASSEXW *
.text$mn:00004DB7                 call    ?FillWndClassEx@@YAXAAUtagWNDCLASSEXW@@PB_WP6GJPAUHWND__@@IIJ@Z@Z ; FillWndClassEx(tagWNDCLASSEXW &,wchar_t const *,long (*)(HWND__ *,uint,uint,long))
.text$mn:00004DBC                 add     esp, 0Ch
.text$mn:00004DBF                 mov     esi, esp
.text$mn:00004DC1                 push    offset IconName ; lpIconName
.text$mn:00004DC3                 mov     edi, esp
.text$mn:00004DC5                 push    0               ; lpModuleName
.text$mn:00004DC7                 call    dword ptr ds:__imp__GetModuleHandleW@4 ; GetModuleHandleW(x)
.text$mn:00004DCD                 cmp     edi, esp
.text$mn:00004DCF                 call    __RTC_CheckEsp
.text$mn:00004DD4                 push    eax             ; hInstance
.text$mn:00004DD5                 call    dword ptr ds:__imp__LoadIconW@8 ; LoadIconW(x,x)
.text$mn:00004DDB                 cmp     esi, esp
.text$mn:00004DDD                 call    __RTC_CheckEsp
.text$mn:00004DE2                 mov     [ebp+var_34.hIcon], eax
.text$mn:00004DE5
.text$mn:00004DE5 loc_4DE5:                               ; CODE XREF: RegisterWinClass(void)+187j
.text$mn:00004DE5                                         ; RegisterWinClass(void)+1B1j
.text$mn:00004DE5                 xor     eax, eax
.text$mn:00004DE7                 jnz     short loc_4DE5
.text$mn:00004DE9                 cmp     [ebp+var_34.hIcon], 0
.text$mn:00004DED                 jnz     short loc_4DF8
.text$mn:00004DEF                 mov     [ebp+var_105], 1
.text$mn:00004DF6                 jmp     short loc_4DFF
.text$mn:00004DF8 ; ---------------------------------------------------------------------------
.text$mn:00004DF8
.text$mn:00004DF8 loc_4DF8:                               ; CODE XREF: RegisterWinClass(void)+18Dj
.text$mn:00004DF8                 mov     [ebp+var_105], 0
.text$mn:00004DFF
.text$mn:00004DFF loc_4DFF:                               ; CODE XREF: RegisterWinClass(void)+196j
.text$mn:00004DFF                 movzx   eax, [ebp+var_105]
.text$mn:00004E06                 push    eax             ; bool
.text$mn:00004E07                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00004E0C                 add     esp, 4
.text$mn:00004E0F                 xor     eax, eax
.text$mn:00004E11                 jnz     short loc_4DE5
.text$mn:00004E13                 mov     esi, esp
.text$mn:00004E15                 lea     eax, [ebp+var_34]
.text$mn:00004E18                 push    eax             ; WNDCLASSEXW *
.text$mn:00004E19                 call    dword ptr ds:__imp__RegisterClassExW@4 ; RegisterClassExW(x)
.text$mn:00004E1F                 cmp     esi, esp
.text$mn:00004E21                 call    __RTC_CheckEsp
.text$mn:00004E26                 mov     [ebp+var_40], ax
.text$mn:00004E2A
.text$mn:00004E2A loc_4E2A:                               ; CODE XREF: RegisterWinClass(void)+1CCj
.text$mn:00004E2A                                         ; RegisterWinClass(void)+1F8j
.text$mn:00004E2A                 xor     eax, eax
.text$mn:00004E2C                 jnz     short loc_4E2A
.text$mn:00004E2E                 movzx   eax, [ebp+var_40]
.text$mn:00004E32                 test    eax, eax
.text$mn:00004E34                 jnz     short loc_4E3F
.text$mn:00004E36                 mov     [ebp+var_105], 1
.text$mn:00004E3D                 jmp     short loc_4E46
.text$mn:00004E3F ; ---------------------------------------------------------------------------
.text$mn:00004E3F
.text$mn:00004E3F loc_4E3F:                               ; CODE XREF: RegisterWinClass(void)+1D4j
.text$mn:00004E3F                 mov     [ebp+var_105], 0
.text$mn:00004E46
.text$mn:00004E46 loc_4E46:                               ; CODE XREF: RegisterWinClass(void)+1DDj
.text$mn:00004E46                 movzx   ecx, [ebp+var_105]
.text$mn:00004E4D                 push    ecx             ; bool
.text$mn:00004E4E                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00004E53                 add     esp, 4
.text$mn:00004E56                 xor     eax, eax
.text$mn:00004E58                 jnz     short loc_4E2A
.text$mn:00004E5A                 call    ?RegisterNotificationsWndClass@@YAXXZ ; RegisterNotificationsWndClass(void)
.text$mn:00004E5F                 call    ?RegisterSplitterWndClass@@YAXXZ ; RegisterSplitterWndClass(void)
.text$mn:00004E64                 call    ?RegisterLabelWithCloseWnd@@YAXXZ ; RegisterLabelWithCloseWnd(void)
.text$mn:00004E69                 call    ?RegisterCaptionWndClass@@YAXXZ ; RegisterCaptionWndClass(void)
.text$mn:00004E6E                 mov     al, 1
.text$mn:00004E70                 push    edx
.text$mn:00004E71                 mov     ecx, ebp
.text$mn:00004E73                 push    eax
.text$mn:00004E74                 lea     edx, $LN45
.text$mn:00004E7A                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00004E7F                 pop     eax
.text$mn:00004E80                 pop     edx
.text$mn:00004E81                 pop     edi
.text$mn:00004E82                 pop     esi
.text$mn:00004E83                 pop     ebx
.text$mn:00004E84                 add     esp, 108h
.text$mn:00004E8A                 cmp     ebp, esp
.text$mn:00004E8C                 call    __RTC_CheckEsp
.text$mn:00004E91                 mov     esp, ebp
.text$mn:00004E93                 pop     ebp
.text$mn:00004E94                 retn
.text$mn:00004E94 ?RegisterWinClass@@YA_NXZ endp
.text$mn:00004E94
.text$mn:00004E94 ; ---------------------------------------------------------------------------
.text$mn:00004E95                 align 4
.text$mn:00004E98 $LN45           dd 1                    ; DATA XREF: RegisterWinClass(void)+214o
.text$mn:00004E9C                 dd offset $LN44
.text$mn:00004EA0 $LN44           db 0CCh                 ; DATA XREF: .text$mn:00004E9Co
.text$mn:00004EA1                 db 3 dup(0FFh)
.text$mn:00004EA4                 dd offset ?GenericDefaultStringFormatBuffer@Gdiplus@@3PAEA ; uchar * Gdiplus::GenericDefaultStringFormatBuffer
.text$mn:00004EA8                 dd offset $LN43         ; "wcex"
.text$mn:00004EAC $LN43           db 'wcex',0             ; DATA XREF: .text$mn:00004EA8o
.text$mn:00004EB1                 align 4
.text$mn:00004EB1 _text$mn        ends
.text$mn:00004EB1
.text$mn:00004EB4 ; ===========================================================================
.text$mn:00004EB4
.text$mn:00004EB4 ; Segment type: Pure code
.text$mn:00004EB4 ; Segment permissions: Read/Execute
.text$mn:00004EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00004EB4                 assume cs:_text$mn
.text$mn:00004EB4                 ;org 4EB4h
.text$mn:00004EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EB4
.text$mn:00004EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EB4
.text$mn:00004EB4 ; Attributes: bp-based frame
.text$mn:00004EB4
.text$mn:00004EB4 ; public: void __thiscall Vec<wchar_t *>::RemoveAt(unsigned int, unsigned int)
.text$mn:00004EB4                 public ?RemoveAt@?$Vec@PA_W@@QAEXII@Z
.text$mn:00004EB4 ?RemoveAt@?$Vec@PA_W@@QAEXII@Z proc near
.text$mn:00004EB4                                         ; CODE XREF: Vec<wchar_t *>::PopAt(uint)+6Fp
.text$mn:00004EB4
.text$mn:00004EB4 var_E4          = byte ptr -0E4h
.text$mn:00004EB4 Src             = dword ptr -20h
.text$mn:00004EB4 Dst             = dword ptr -14h
.text$mn:00004EB4 var_8           = dword ptr -8
.text$mn:00004EB4 arg_0           = dword ptr  8
.text$mn:00004EB4 arg_4           = dword ptr  0Ch
.text$mn:00004EB4
.text$mn:00004EB4                 push    ebp
.text$mn:00004EB5                 mov     ebp, esp
.text$mn:00004EB7                 sub     esp, 0E4h
.text$mn:00004EBD                 push    ebx
.text$mn:00004EBE                 push    esi
.text$mn:00004EBF                 push    edi
.text$mn:00004EC0                 push    ecx
.text$mn:00004EC1                 lea     edi, [ebp+var_E4]
.text$mn:00004EC7                 mov     ecx, 39h ; '9'
.text$mn:00004ECC                 mov     eax, 0CCCCCCCCh
.text$mn:00004ED1                 rep stosd
.text$mn:00004ED3                 pop     ecx
.text$mn:00004ED4                 mov     [ebp+var_8], ecx
.text$mn:00004ED7                 mov     eax, [ebp+arg_0]
.text$mn:00004EDA                 add     eax, [ebp+arg_4]
.text$mn:00004EDD                 mov     ecx, [ebp+var_8]
.text$mn:00004EE0                 cmp     [ecx], eax
.text$mn:00004EE2                 jbe     short loc_4F27
.text$mn:00004EE4                 mov     eax, [ebp+var_8]
.text$mn:00004EE7                 mov     ecx, [eax+0Ch]
.text$mn:00004EEA                 mov     edx, [ebp+arg_0]
.text$mn:00004EED                 lea     eax, [ecx+edx*4]
.text$mn:00004EF0                 mov     [ebp+Dst], eax
.text$mn:00004EF3                 mov     eax, [ebp+var_8]
.text$mn:00004EF6                 mov     ecx, [eax+0Ch]
.text$mn:00004EF9                 mov     edx, [ebp+arg_0]
.text$mn:00004EFC                 lea     eax, [ecx+edx*4]
.text$mn:00004EFF                 mov     ecx, [ebp+arg_4]
.text$mn:00004F02                 lea     edx, [eax+ecx*4]
.text$mn:00004F05                 mov     [ebp+Src], edx
.text$mn:00004F08                 mov     eax, [ebp+var_8]
.text$mn:00004F0B                 mov     ecx, [eax]
.text$mn:00004F0D                 sub     ecx, [ebp+arg_0]
.text$mn:00004F10                 sub     ecx, [ebp+arg_4]
.text$mn:00004F13                 shl     ecx, 2
.text$mn:00004F16                 push    ecx             ; Size
.text$mn:00004F17                 mov     edx, [ebp+Src]
.text$mn:00004F1A                 push    edx             ; Src
.text$mn:00004F1B                 mov     eax, [ebp+Dst]
.text$mn:00004F1E                 push    eax             ; Dst
.text$mn:00004F1F                 call    _memmove
.text$mn:00004F24                 add     esp, 0Ch
.text$mn:00004F27
.text$mn:00004F27 loc_4F27:                               ; CODE XREF: Vec<wchar_t *>::RemoveAt(uint,uint)+2Ej
.text$mn:00004F27                 mov     eax, [ebp+var_8]
.text$mn:00004F2A                 mov     ecx, [eax]
.text$mn:00004F2C                 sub     ecx, [ebp+arg_4]
.text$mn:00004F2F                 mov     edx, [ebp+var_8]
.text$mn:00004F32                 mov     [edx], ecx
.text$mn:00004F34                 mov     eax, [ebp+arg_4]
.text$mn:00004F37                 shl     eax, 2
.text$mn:00004F3A                 push    eax             ; Size
.text$mn:00004F3B                 push    0               ; Val
.text$mn:00004F3D                 mov     ecx, [ebp+var_8]
.text$mn:00004F40                 mov     edx, [ecx]
.text$mn:00004F42                 mov     eax, [ebp+var_8]
.text$mn:00004F45                 mov     ecx, [eax+0Ch]
.text$mn:00004F48                 lea     edx, [ecx+edx*4]
.text$mn:00004F4B                 push    edx             ; Dst
.text$mn:00004F4C                 call    _memset
.text$mn:00004F51                 add     esp, 0Ch
.text$mn:00004F54                 pop     edi
.text$mn:00004F55                 pop     esi
.text$mn:00004F56                 pop     ebx
.text$mn:00004F57                 add     esp, 0E4h
.text$mn:00004F5D                 cmp     ebp, esp
.text$mn:00004F5F                 call    __RTC_CheckEsp
.text$mn:00004F64                 mov     esp, ebp
.text$mn:00004F66                 pop     ebp
.text$mn:00004F67                 retn    8
.text$mn:00004F67 ?RemoveAt@?$Vec@PA_W@@QAEXII@Z endp
.text$mn:00004F67
.text$mn:00004F67 ; ---------------------------------------------------------------------------
.text$mn:00004F6A                 align 4
.text$mn:00004F6A _text$mn        ends
.text$mn:00004F6A
.text$mn:00004F6C ; ===========================================================================
.text$mn:00004F6C
.text$mn:00004F6C ; Segment type: Pure code
.text$mn:00004F6C ; Segment permissions: Read/Execute
.text$mn:00004F6C _text$mn        segment para public 'CODE' use32
.text$mn:00004F6C                 assume cs:_text$mn
.text$mn:00004F6C                 ;org 4F6Ch
.text$mn:00004F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F6C
.text$mn:00004F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F6C
.text$mn:00004F6C ; Attributes: bp-based frame
.text$mn:00004F6C
.text$mn:00004F6C ; public: void __thiscall Vec<wchar_t *>::RemoveAtFast(unsigned int)
.text$mn:00004F6C                 public ?RemoveAtFast@?$Vec@PA_W@@QAEXI@Z
.text$mn:00004F6C ?RemoveAtFast@?$Vec@PA_W@@QAEXI@Z proc near
.text$mn:00004F6C                                         ; CODE XREF: Vec<wchar_t *>::Pop(void)+75p
.text$mn:00004F6C
.text$mn:00004F6C var_E8          = byte ptr -0E8h
.text$mn:00004F6C var_E5          = byte ptr -0E5h
.text$mn:00004F6C Src             = dword ptr -20h
.text$mn:00004F6C Dst             = dword ptr -14h
.text$mn:00004F6C var_8           = dword ptr -8
.text$mn:00004F6C arg_0           = dword ptr  8
.text$mn:00004F6C
.text$mn:00004F6C                 push    ebp
.text$mn:00004F6D                 mov     ebp, esp
.text$mn:00004F6F                 sub     esp, 0E8h
.text$mn:00004F75                 push    ebx
.text$mn:00004F76                 push    esi
.text$mn:00004F77                 push    edi
.text$mn:00004F78                 push    ecx
.text$mn:00004F79                 lea     edi, [ebp+var_E8]
.text$mn:00004F7F                 mov     ecx, 3Ah ; ':'
.text$mn:00004F84                 mov     eax, 0CCCCCCCCh
.text$mn:00004F89                 rep stosd
.text$mn:00004F8B                 pop     ecx
.text$mn:00004F8C                 mov     [ebp+var_8], ecx
.text$mn:00004F8F
.text$mn:00004F8F loc_4F8F:                               ; CODE XREF: Vec<wchar_t *>::RemoveAtFast(uint)+25j
.text$mn:00004F8F                                         ; Vec<wchar_t *>::RemoveAtFast(uint)+53j
.text$mn:00004F8F                 xor     eax, eax
.text$mn:00004F91                 jnz     short loc_4F8F
.text$mn:00004F93                 mov     eax, [ebp+var_8]
.text$mn:00004F96                 mov     ecx, [ebp+arg_0]
.text$mn:00004F99                 cmp     ecx, [eax]
.text$mn:00004F9B                 jb      short loc_4FA6
.text$mn:00004F9D                 mov     [ebp+var_E5], 1
.text$mn:00004FA4                 jmp     short loc_4FAD
.text$mn:00004FA6 ; ---------------------------------------------------------------------------
.text$mn:00004FA6
.text$mn:00004FA6 loc_4FA6:                               ; CODE XREF: Vec<wchar_t *>::RemoveAtFast(uint)+2Fj
.text$mn:00004FA6                 mov     [ebp+var_E5], 0
.text$mn:00004FAD
.text$mn:00004FAD loc_4FAD:                               ; CODE XREF: Vec<wchar_t *>::RemoveAtFast(uint)+38j
.text$mn:00004FAD                 movzx   edx, [ebp+var_E5]
.text$mn:00004FB4                 push    edx             ; bool
.text$mn:00004FB5                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00004FBA                 add     esp, 4
.text$mn:00004FBD                 xor     eax, eax
.text$mn:00004FBF                 jnz     short loc_4F8F
.text$mn:00004FC1                 mov     eax, [ebp+var_8]
.text$mn:00004FC4                 mov     ecx, [ebp+arg_0]
.text$mn:00004FC7                 cmp     ecx, [eax]
.text$mn:00004FC9                 jb      short loc_4FCD
.text$mn:00004FCB                 jmp     short loc_5025
.text$mn:00004FCD ; ---------------------------------------------------------------------------
.text$mn:00004FCD
.text$mn:00004FCD loc_4FCD:                               ; CODE XREF: Vec<wchar_t *>::RemoveAtFast(uint)+5Dj
.text$mn:00004FCD                 mov     eax, [ebp+var_8]
.text$mn:00004FD0                 mov     ecx, [eax+0Ch]
.text$mn:00004FD3                 mov     edx, [ebp+arg_0]
.text$mn:00004FD6                 lea     eax, [ecx+edx*4]
.text$mn:00004FD9                 mov     [ebp+Dst], eax
.text$mn:00004FDC                 mov     eax, [ebp+var_8]
.text$mn:00004FDF                 mov     ecx, [eax]
.text$mn:00004FE1                 mov     edx, [ebp+var_8]
.text$mn:00004FE4                 mov     eax, [edx+0Ch]
.text$mn:00004FE7                 lea     ecx, [eax+ecx*4-4]
.text$mn:00004FEB                 mov     [ebp+Src], ecx
.text$mn:00004FEE                 mov     eax, [ebp+Dst]
.text$mn:00004FF1                 cmp     eax, [ebp+Src]
.text$mn:00004FF4                 jz      short loc_5008
.text$mn:00004FF6                 push    4               ; Size
.text$mn:00004FF8                 mov     eax, [ebp+Src]
.text$mn:00004FFB                 push    eax             ; Src
.text$mn:00004FFC                 mov     ecx, [ebp+Dst]
.text$mn:00004FFF                 push    ecx             ; Dst
.text$mn:00005000                 call    _memcpy
.text$mn:00005005                 add     esp, 0Ch
.text$mn:00005008
.text$mn:00005008 loc_5008:                               ; CODE XREF: Vec<wchar_t *>::RemoveAtFast(uint)+88j
.text$mn:00005008                 push    4               ; Size
.text$mn:0000500A                 push    0               ; Val
.text$mn:0000500C                 mov     eax, [ebp+Src]
.text$mn:0000500F                 push    eax             ; Dst
.text$mn:00005010                 call    _memset
.text$mn:00005015                 add     esp, 0Ch
.text$mn:00005018                 mov     eax, [ebp+var_8]
.text$mn:0000501B                 mov     ecx, [eax]
.text$mn:0000501D                 sub     ecx, 1
.text$mn:00005020                 mov     edx, [ebp+var_8]
.text$mn:00005023                 mov     [edx], ecx
.text$mn:00005025
.text$mn:00005025 loc_5025:                               ; CODE XREF: Vec<wchar_t *>::RemoveAtFast(uint)+5Fj
.text$mn:00005025                 pop     edi
.text$mn:00005026                 pop     esi
.text$mn:00005027                 pop     ebx
.text$mn:00005028                 add     esp, 0E8h
.text$mn:0000502E                 cmp     ebp, esp
.text$mn:00005030                 call    __RTC_CheckEsp
.text$mn:00005035                 mov     esp, ebp
.text$mn:00005037                 pop     ebp
.text$mn:00005038                 retn    4
.text$mn:00005038 ?RemoveAtFast@?$Vec@PA_W@@QAEXI@Z endp
.text$mn:00005038
.text$mn:00005038 ; ---------------------------------------------------------------------------
.text$mn:0000503B                 align 4
.text$mn:0000503B _text$mn        ends
.text$mn:0000503B
.text$mn:0000503C ; ===========================================================================
.text$mn:0000503C
.text$mn:0000503C ; Segment type: Pure code
.text$mn:0000503C ; Segment permissions: Read/Execute
.text$mn:0000503C _text$mn        segment para public 'CODE' use32
.text$mn:0000503C                 assume cs:_text$mn
.text$mn:0000503C                 ;org 503Ch
.text$mn:0000503C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000503C
.text$mn:0000503C ; =============== S U B R O U T I N E =======================================
.text$mn:0000503C
.text$mn:0000503C ; Attributes: bp-based frame
.text$mn:0000503C
.text$mn:0000503C ; public: void __thiscall Vec<struct FileState *>::Reset(void)
.text$mn:0000503C                 public ?Reset@?$Vec@PAUFileState@@@@QAEXXZ
.text$mn:0000503C ?Reset@?$Vec@PAUFileState@@@@QAEXXZ proc near
.text$mn:0000503C                                         ; CODE XREF: Vec<FileState *>::Vec<FileState *>(uint,Allocator *)+44p
.text$mn:0000503C
.text$mn:0000503C var_CC          = byte ptr -0CCh
.text$mn:0000503C var_8           = dword ptr -8
.text$mn:0000503C
.text$mn:0000503C                 push    ebp
.text$mn:0000503D                 mov     ebp, esp
.text$mn:0000503F                 sub     esp, 0CCh
.text$mn:00005045                 push    ebx
.text$mn:00005046                 push    esi
.text$mn:00005047                 push    edi
.text$mn:00005048                 push    ecx
.text$mn:00005049                 lea     edi, [ebp+var_CC]
.text$mn:0000504F                 mov     ecx, 33h ; '3'
.text$mn:00005054                 mov     eax, 0CCCCCCCCh
.text$mn:00005059                 rep stosd
.text$mn:0000505B                 pop     ecx
.text$mn:0000505C                 mov     [ebp+var_8], ecx
.text$mn:0000505F                 mov     eax, [ebp+var_8]
.text$mn:00005062                 mov     dword ptr [eax], 0
.text$mn:00005068                 mov     eax, [ebp+var_8]
.text$mn:0000506B                 mov     dword ptr [eax+4], 0Fh
.text$mn:00005072                 mov     ecx, [ebp+var_8]
.text$mn:00005075                 call    ?FreeEls@?$Vec@PAUFileState@@@@IAEXXZ ; Vec<FileState *>::FreeEls(void)
.text$mn:0000507A                 mov     eax, [ebp+var_8]
.text$mn:0000507D                 add     eax, 10h
.text$mn:00005080                 mov     ecx, [ebp+var_8]
.text$mn:00005083                 mov     [ecx+0Ch], eax
.text$mn:00005086                 push    40h ; '@'       ; Size
.text$mn:00005088                 push    0               ; Val
.text$mn:0000508A                 mov     eax, [ebp+var_8]
.text$mn:0000508D                 add     eax, 10h
.text$mn:00005090                 push    eax             ; Dst
.text$mn:00005091                 call    _memset
.text$mn:00005096                 add     esp, 0Ch
.text$mn:00005099                 pop     edi
.text$mn:0000509A                 pop     esi
.text$mn:0000509B                 pop     ebx
.text$mn:0000509C                 add     esp, 0CCh
.text$mn:000050A2                 cmp     ebp, esp
.text$mn:000050A4                 call    __RTC_CheckEsp
.text$mn:000050A9                 mov     esp, ebp
.text$mn:000050AB                 pop     ebp
.text$mn:000050AC                 retn
.text$mn:000050AC ?Reset@?$Vec@PAUFileState@@@@QAEXXZ endp
.text$mn:000050AC
.text$mn:000050AC ; ---------------------------------------------------------------------------
.text$mn:000050AD                 align 10h
.text$mn:000050AD _text$mn        ends
.text$mn:000050AD
.text$mn:000050B0 ; ===========================================================================
.text$mn:000050B0
.text$mn:000050B0 ; Segment type: Pure code
.text$mn:000050B0 ; Segment permissions: Read/Execute
.text$mn:000050B0 _text$mn        segment para public 'CODE' use32
.text$mn:000050B0                 assume cs:_text$mn
.text$mn:000050B0                 ;org 50B0h
.text$mn:000050B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050B0
.text$mn:000050B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000050B0
.text$mn:000050B0 ; Attributes: bp-based frame
.text$mn:000050B0
.text$mn:000050B0 ; public: void __thiscall Vec<wchar_t *>::Reset(void)
.text$mn:000050B0                 public ?Reset@?$Vec@PA_W@@QAEXXZ
.text$mn:000050B0 ?Reset@?$Vec@PA_W@@QAEXXZ proc near     ; CODE XREF: Vec<wchar_t *>::Vec<wchar_t *>(uint,Allocator *)+44p
.text$mn:000050B0                                         ; Vec<wchar_t *>::FreeMembers(void)+61p
.text$mn:000050B0
.text$mn:000050B0 var_CC          = byte ptr -0CCh
.text$mn:000050B0 var_8           = dword ptr -8
.text$mn:000050B0
.text$mn:000050B0                 push    ebp
.text$mn:000050B1                 mov     ebp, esp
.text$mn:000050B3                 sub     esp, 0CCh
.text$mn:000050B9                 push    ebx
.text$mn:000050BA                 push    esi
.text$mn:000050BB                 push    edi
.text$mn:000050BC                 push    ecx
.text$mn:000050BD                 lea     edi, [ebp+var_CC]
.text$mn:000050C3                 mov     ecx, 33h ; '3'
.text$mn:000050C8                 mov     eax, 0CCCCCCCCh
.text$mn:000050CD                 rep stosd
.text$mn:000050CF                 pop     ecx
.text$mn:000050D0                 mov     [ebp+var_8], ecx
.text$mn:000050D3                 mov     eax, [ebp+var_8]
.text$mn:000050D6                 mov     dword ptr [eax], 0
.text$mn:000050DC                 mov     eax, [ebp+var_8]
.text$mn:000050DF                 mov     dword ptr [eax+4], 0Fh
.text$mn:000050E6                 mov     ecx, [ebp+var_8]
.text$mn:000050E9                 call    ?FreeEls@?$Vec@PA_W@@IAEXXZ ; Vec<wchar_t *>::FreeEls(void)
.text$mn:000050EE                 mov     eax, [ebp+var_8]
.text$mn:000050F1                 add     eax, 10h
.text$mn:000050F4                 mov     ecx, [ebp+var_8]
.text$mn:000050F7                 mov     [ecx+0Ch], eax
.text$mn:000050FA                 push    40h ; '@'       ; Size
.text$mn:000050FC                 push    0               ; Val
.text$mn:000050FE                 mov     eax, [ebp+var_8]
.text$mn:00005101                 add     eax, 10h
.text$mn:00005104                 push    eax             ; Dst
.text$mn:00005105                 call    _memset
.text$mn:0000510A                 add     esp, 0Ch
.text$mn:0000510D                 pop     edi
.text$mn:0000510E                 pop     esi
.text$mn:0000510F                 pop     ebx
.text$mn:00005110                 add     esp, 0CCh
.text$mn:00005116                 cmp     ebp, esp
.text$mn:00005118                 call    __RTC_CheckEsp
.text$mn:0000511D                 mov     esp, ebp
.text$mn:0000511F                 pop     ebp
.text$mn:00005120                 retn
.text$mn:00005120 ?Reset@?$Vec@PA_W@@QAEXXZ endp
.text$mn:00005120
.text$mn:00005120 ; ---------------------------------------------------------------------------
.text$mn:00005121                 align 4
.text$mn:00005121 _text$mn        ends
.text$mn:00005121
.text$mn:00005124 ; ===========================================================================
.text$mn:00005124
.text$mn:00005124 ; Segment type: Pure code
.text$mn:00005124 ; Segment permissions: Read/Execute
.text$mn:00005124 _text$mn        segment para public 'CODE' use32
.text$mn:00005124                 assume cs:_text$mn
.text$mn:00005124                 ;org 5124h
.text$mn:00005124                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005124
.text$mn:00005124 ; =============== S U B R O U T I N E =======================================
.text$mn:00005124
.text$mn:00005124 ; Attributes: bp-based frame
.text$mn:00005124
.text$mn:00005124 ; public: void __thiscall Vec<class geomutil::RectT<int>>::Reset(void)
.text$mn:00005124                 public ?Reset@?$Vec@V?$RectT@H@geomutil@@@@QAEXXZ
.text$mn:00005124 ?Reset@?$Vec@V?$RectT@H@geomutil@@@@QAEXXZ proc near
.text$mn:00005124                                         ; CODE XREF: Vec<geomutil::RectT<int>>::Vec<geomutil::RectT<int>>(uint,Allocator *)+5Cp
.text$mn:00005124
.text$mn:00005124 var_CC          = byte ptr -0CCh
.text$mn:00005124 var_8           = dword ptr -8
.text$mn:00005124
.text$mn:00005124                 push    ebp
.text$mn:00005125                 mov     ebp, esp
.text$mn:00005127                 sub     esp, 0CCh
.text$mn:0000512D                 push    ebx
.text$mn:0000512E                 push    esi
.text$mn:0000512F                 push    edi
.text$mn:00005130                 push    ecx
.text$mn:00005131                 lea     edi, [ebp+var_CC]
.text$mn:00005137                 mov     ecx, 33h ; '3'
.text$mn:0000513C                 mov     eax, 0CCCCCCCCh
.text$mn:00005141                 rep stosd
.text$mn:00005143                 pop     ecx
.text$mn:00005144                 mov     [ebp+var_8], ecx
.text$mn:00005147                 mov     eax, [ebp+var_8]
.text$mn:0000514A                 mov     dword ptr [eax], 0
.text$mn:00005150                 mov     eax, [ebp+var_8]
.text$mn:00005153                 mov     dword ptr [eax+4], 0Fh
.text$mn:0000515A                 mov     ecx, [ebp+var_8]
.text$mn:0000515D                 call    ?FreeEls@?$Vec@V?$RectT@H@geomutil@@@@IAEXXZ ; Vec<geomutil::RectT<int>>::FreeEls(void)
.text$mn:00005162                 mov     eax, [ebp+var_8]
.text$mn:00005165                 add     eax, 10h
.text$mn:00005168                 mov     ecx, [ebp+var_8]
.text$mn:0000516B                 mov     [ecx+0Ch], eax
.text$mn:0000516E                 push    100h            ; Size
.text$mn:00005173                 push    0               ; Val
.text$mn:00005175                 mov     eax, [ebp+var_8]
.text$mn:00005178                 add     eax, 10h
.text$mn:0000517B                 push    eax             ; Dst
.text$mn:0000517C                 call    _memset
.text$mn:00005181                 add     esp, 0Ch
.text$mn:00005184                 pop     edi
.text$mn:00005185                 pop     esi
.text$mn:00005186                 pop     ebx
.text$mn:00005187                 add     esp, 0CCh
.text$mn:0000518D                 cmp     ebp, esp
.text$mn:0000518F                 call    __RTC_CheckEsp
.text$mn:00005194                 mov     esp, ebp
.text$mn:00005196                 pop     ebp
.text$mn:00005197                 retn
.text$mn:00005197 ?Reset@?$Vec@V?$RectT@H@geomutil@@@@QAEXXZ endp
.text$mn:00005197
.text$mn:00005197 _text$mn        ends
.text$mn:00005197
.text$mn:00005198 ; ===========================================================================
.text$mn:00005198
.text$mn:00005198 ; Segment type: Pure code
.text$mn:00005198 ; Segment permissions: Read/Execute
.text$mn:00005198 _text$mn        segment para public 'CODE' use32
.text$mn:00005198                 assume cs:_text$mn
.text$mn:00005198                 ;org 5198h
.text$mn:00005198                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005198
.text$mn:00005198 ; =============== S U B R O U T I N E =======================================
.text$mn:00005198
.text$mn:00005198 ; Attributes: bp-based frame
.text$mn:00005198
.text$mn:00005198 ; public: void __thiscall Vec<wchar_t>::Reset(void)
.text$mn:00005198                 public ?Reset@?$Vec@_W@@QAEXXZ
.text$mn:00005198 ?Reset@?$Vec@_W@@QAEXXZ proc near       ; CODE XREF: Vec<wchar_t>::Vec<wchar_t>(uint,Allocator *)+44p
.text$mn:00005198
.text$mn:00005198 var_CC          = byte ptr -0CCh
.text$mn:00005198 var_8           = dword ptr -8
.text$mn:00005198
.text$mn:00005198                 push    ebp
.text$mn:00005199                 mov     ebp, esp
.text$mn:0000519B                 sub     esp, 0CCh
.text$mn:000051A1                 push    ebx
.text$mn:000051A2                 push    esi
.text$mn:000051A3                 push    edi
.text$mn:000051A4                 push    ecx
.text$mn:000051A5                 lea     edi, [ebp+var_CC]
.text$mn:000051AB                 mov     ecx, 33h ; '3'
.text$mn:000051B0                 mov     eax, 0CCCCCCCCh
.text$mn:000051B5                 rep stosd
.text$mn:000051B7                 pop     ecx
.text$mn:000051B8                 mov     [ebp+var_8], ecx
.text$mn:000051BB                 mov     eax, [ebp+var_8]
.text$mn:000051BE                 mov     dword ptr [eax], 0
.text$mn:000051C4                 mov     eax, [ebp+var_8]
.text$mn:000051C7                 mov     dword ptr [eax+4], 0Fh
.text$mn:000051CE                 mov     ecx, [ebp+var_8]
.text$mn:000051D1                 call    ?FreeEls@?$Vec@_W@@IAEXXZ ; Vec<wchar_t>::FreeEls(void)
.text$mn:000051D6                 mov     eax, [ebp+var_8]
.text$mn:000051D9                 add     eax, 10h
.text$mn:000051DC                 mov     ecx, [ebp+var_8]
.text$mn:000051DF                 mov     [ecx+0Ch], eax
.text$mn:000051E2                 push    20h ; ' '       ; Size
.text$mn:000051E4                 push    0               ; Val
.text$mn:000051E6                 mov     eax, [ebp+var_8]
.text$mn:000051E9                 add     eax, 10h
.text$mn:000051EC                 push    eax             ; Dst
.text$mn:000051ED                 call    _memset
.text$mn:000051F2                 add     esp, 0Ch
.text$mn:000051F5                 pop     edi
.text$mn:000051F6                 pop     esi
.text$mn:000051F7                 pop     ebx
.text$mn:000051F8                 add     esp, 0CCh
.text$mn:000051FE                 cmp     ebp, esp
.text$mn:00005200                 call    __RTC_CheckEsp
.text$mn:00005205                 mov     esp, ebp
.text$mn:00005207                 pop     ebp
.text$mn:00005208                 retn
.text$mn:00005208 ?Reset@?$Vec@_W@@QAEXXZ endp
.text$mn:00005208
.text$mn:00005208 ; ---------------------------------------------------------------------------
.text$mn:00005209                 align 4
.text$mn:00005209 _text$mn        ends
.text$mn:00005209
.text$mn:0000520C ; ===========================================================================
.text$mn:0000520C
.text$mn:0000520C ; Segment type: Pure code
.text$mn:0000520C ; Segment permissions: Read/Execute
.text$mn:0000520C _text$mn        segment para public 'CODE' use32
.text$mn:0000520C                 assume cs:_text$mn
.text$mn:0000520C                 ;org 520Ch
.text$mn:0000520C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000520C
.text$mn:0000520C ; =============== S U B R O U T I N E =======================================
.text$mn:0000520C
.text$mn:0000520C ; Attributes: bp-based frame
.text$mn:0000520C
.text$mn:0000520C ; int __cdecl RestoreTabOnStartup(struct WindowInfo *, int)
.text$mn:0000520C ?RestoreTabOnStartup@@YAXPAVWindowInfo@@PAUTabState@@@Z proc near
.text$mn:0000520C                                         ; CODE XREF: WinMain(x,x,x,x)+81Dp
.text$mn:0000520C
.text$mn:0000520C var_138         = dword ptr -138h
.text$mn:0000520C var_130         = qword ptr -130h
.text$mn:0000520C var_11C         = byte ptr -11Ch
.text$mn:0000520C var_118         = byte ptr -118h
.text$mn:0000520C var_38          = dword ptr -38h
.text$mn:0000520C var_2C          = dword ptr -2Ch
.text$mn:0000520C var_20          = dword ptr -20h
.text$mn:0000520C var_14          = byte ptr -14h
.text$mn:0000520C arg_0           = dword ptr  8
.text$mn:0000520C arg_4           = dword ptr  0Ch
.text$mn:0000520C
.text$mn:0000520C                 push    ebp
.text$mn:0000520D                 mov     ebp, esp
.text$mn:0000520F                 sub     esp, 11Ch
.text$mn:00005215                 push    ebx
.text$mn:00005216                 push    esi
.text$mn:00005217                 push    edi             ; float
.text$mn:00005218                 lea     edi, [ebp+var_11C]
.text$mn:0000521E                 mov     ecx, 47h ; 'G'
.text$mn:00005223                 mov     eax, 0CCCCCCCCh
.text$mn:00005228                 rep stosd
.text$mn:0000522A                 mov     eax, [ebp+arg_0]
.text$mn:0000522D                 push    eax             ; struct WindowInfo *
.text$mn:0000522E                 mov     ecx, [ebp+arg_4]
.text$mn:00005231                 mov     edx, [ecx]
.text$mn:00005233                 push    edx             ; wchar_t *
.text$mn:00005234                 lea     ecx, [ebp+var_14] ; this
.text$mn:00005237                 call    ??0LoadArgs@@QAE@PB_WPAVWindowInfo@@@Z ; LoadArgs::LoadArgs(wchar_t const *,WindowInfo *)
.text$mn:0000523C                 lea     eax, [ebp+var_14]
.text$mn:0000523F                 push    eax             ; struct LoadArgs *
.text$mn:00005240                 call    ?LoadDocument@@YAPAVWindowInfo@@AAULoadArgs@@@Z ; LoadDocument(LoadArgs &)
.text$mn:00005245                 add     esp, 4
.text$mn:00005248                 test    eax, eax
.text$mn:0000524A                 jnz     short loc_5251
.text$mn:0000524C                 jmp     loc_53FC
.text$mn:00005251 ; ---------------------------------------------------------------------------
.text$mn:00005251
.text$mn:00005251 loc_5251:                               ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+3Ej
.text$mn:00005251                 mov     eax, [ebp+arg_0]
.text$mn:00005254                 mov     ecx, [eax+58h]
.text$mn:00005257                 mov     [ebp+var_20], ecx
.text$mn:0000525A                 cmp     [ebp+var_20], 0
.text$mn:0000525E                 jz      short loc_5269
.text$mn:00005260                 mov     eax, [ebp+var_20]
.text$mn:00005263                 cmp     dword ptr [eax+4], 0
.text$mn:00005267                 jnz     short loc_526E
.text$mn:00005269
.text$mn:00005269 loc_5269:                               ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+52j
.text$mn:00005269                 jmp     loc_53FC
.text$mn:0000526E ; ---------------------------------------------------------------------------
.text$mn:0000526E
.text$mn:0000526E loc_526E:                               ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+5Bj
.text$mn:0000526E                 mov     eax, [ebp+arg_4]
.text$mn:00005271                 mov     ecx, [eax+20h]
.text$mn:00005274                 push    ecx
.text$mn:00005275                 mov     ecx, [ebp+var_20]
.text$mn:00005278                 add     ecx, 14h
.text$mn:0000527B                 call    ??4?$Vec@H@@QAEAAV0@ABV0@@Z ; Vec<int>::operator=(Vec<int> const &)
.text$mn:00005280                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00005285                 movzx   ecx, byte ptr [eax+0ADh]
.text$mn:0000528C                 push    ecx             ; bool
.text$mn:0000528D                 mov     edx, [ebp+arg_4]
.text$mn:00005290                 movzx   eax, byte ptr [edx+1Ch]
.text$mn:00005294                 push    eax             ; bool
.text$mn:00005295                 mov     ecx, [ebp+arg_0]
.text$mn:00005298                 push    ecx             ; struct WindowInfo *
.text$mn:00005299                 call    ?SetSidebarVisibility@@YAXPAVWindowInfo@@_N1@Z ; SetSidebarVisibility(WindowInfo *,bool,bool)
.text$mn:0000529E                 add     esp, 0Ch
.text$mn:000052A1                 push    0
.text$mn:000052A3                 mov     eax, [ebp+arg_4]
.text$mn:000052A6                 mov     ecx, [eax+4]
.text$mn:000052A9                 push    ecx
.text$mn:000052AA                 call    ?ToDisplayMode@conv@prefs@@YA?AW4DisplayMode@@PB_WW43@@Z ; prefs::conv::ToDisplayMode(wchar_t const *,DisplayMode)
.text$mn:000052AF                 add     esp, 8
.text$mn:000052B2                 mov     [ebp+var_2C], eax
.text$mn:000052B5                 cmp     [ebp+var_2C], 0
.text$mn:000052B9                 jz      short loc_52CD
.text$mn:000052BB                 push    0
.text$mn:000052BD                 mov     eax, [ebp+var_2C]
.text$mn:000052C0                 push    eax
.text$mn:000052C1                 mov     ecx, [ebp+arg_0]
.text$mn:000052C4                 push    ecx
.text$mn:000052C5                 call    ?SwitchToDisplayMode@@YAXPAVWindowInfo@@W4DisplayMode@@_N@Z ; SwitchToDisplayMode(WindowInfo *,DisplayMode,bool)
.text$mn:000052CA                 add     esp, 0Ch
.text$mn:000052CD
.text$mn:000052CD loc_52CD:                               ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+ADj
.text$mn:000052CD                 mov     ecx, [ebp+var_20] ; this
.text$mn:000052D0                 call    ?AsEbook@TabInfo@@QBEPAVEbookController@@XZ ; TabInfo::AsEbook(void)
.text$mn:000052D5                 test    eax, eax
.text$mn:000052D7                 jnz     short loc_52FE
.text$mn:000052D9                 mov     esi, esp
.text$mn:000052DB                 push    1
.text$mn:000052DD                 mov     eax, [ebp+arg_4]
.text$mn:000052E0                 mov     ecx, [eax+8]
.text$mn:000052E3                 push    ecx
.text$mn:000052E4                 mov     edx, [ebp+var_20]
.text$mn:000052E7                 mov     eax, [edx+4]
.text$mn:000052EA                 mov     ecx, [ebp+var_20]
.text$mn:000052ED                 mov     edx, [eax]
.text$mn:000052EF                 mov     ecx, [ecx+4]
.text$mn:000052F2                 mov     eax, [edx+18h]
.text$mn:000052F5                 call    eax
.text$mn:000052F7                 cmp     esi, esp
.text$mn:000052F9                 call    __RTC_CheckEsp
.text$mn:000052FE
.text$mn:000052FE loc_52FE:                               ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+CBj
.text$mn:000052FE                 push    ecx             ; char *
.text$mn:000052FF                 movss   xmm0, ds:__real@c2c60000
.text$mn:00005307                 movss   dword ptr [esp+12Ch+var_130+4], xmm0
.text$mn:0000530C                 mov     eax, [ebp+arg_4]
.text$mn:0000530F                 mov     ecx, [eax+0Ch]
.text$mn:00005312                 push    ecx             ; this
.text$mn:00005313                 call    ?ToZoom@conv@prefs@@YAMPBDM@Z ; prefs::conv::ToZoom(char const *,float)
.text$mn:00005318                 add     esp, 8
.text$mn:0000531B                 fstp    [ebp+var_38]
.text$mn:0000531E                 movss   xmm0, [ebp+var_38]
.text$mn:00005323                 ucomiss xmm0, ds:__real@c2c60000
.text$mn:0000532A                 lahf
.text$mn:0000532B                 test    ah, 44h
.text$mn:0000532E                 jnp     short loc_5388
.text$mn:00005330                 mov     ecx, [ebp+var_20] ; this
.text$mn:00005333                 call    ?AsFixed@TabInfo@@QBEPAVDisplayModel@@XZ ; TabInfo::AsFixed(void)
.text$mn:00005338                 test    eax, eax
.text$mn:0000533A                 jz      short loc_535F
.text$mn:0000533C                 mov     eax, [ebp+arg_4]
.text$mn:0000533F                 mov     ecx, [eax+10h]
.text$mn:00005342                 push    ecx             ; int
.text$mn:00005343                 push    ecx             ; float
.text$mn:00005344                 movss   xmm0, [ebp+var_38]
.text$mn:00005349                 movss   dword ptr [esp+130h+var_130], xmm0
.text$mn:0000534E                 mov     ecx, [ebp+var_20] ; this
.text$mn:00005351                 call    ?AsFixed@TabInfo@@QBEPAVDisplayModel@@XZ ; TabInfo::AsFixed(void)
.text$mn:00005356                 mov     ecx, eax        ; this
.text$mn:00005358                 call    ?Relayout@DisplayModel@@QAEXMH@Z ; DisplayModel::Relayout(float,int)
.text$mn:0000535D                 jmp     short loc_5388
.text$mn:0000535F ; ---------------------------------------------------------------------------
.text$mn:0000535F
.text$mn:0000535F loc_535F:                               ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+12Ej
.text$mn:0000535F                 mov     esi, esp
.text$mn:00005361                 push    0
.text$mn:00005363                 push    ecx             ; double
.text$mn:00005364                 movss   xmm0, [ebp+var_38]
.text$mn:00005369                 movss   dword ptr [esp+130h+var_130], xmm0
.text$mn:0000536E                 mov     eax, [ebp+var_20]
.text$mn:00005371                 mov     ecx, [eax+4]
.text$mn:00005374                 mov     edx, [ebp+var_20]
.text$mn:00005377                 mov     eax, [ecx]
.text$mn:00005379                 mov     ecx, [edx+4]
.text$mn:0000537C                 mov     edx, [eax+30h]
.text$mn:0000537F                 call    edx
.text$mn:00005381                 cmp     esi, esp
.text$mn:00005383                 call    __RTC_CheckEsp
.text$mn:00005388
.text$mn:00005388 loc_5388:                               ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+122j
.text$mn:00005388                                         ; RestoreTabOnStartup(WindowInfo *,TabState *)+151j
.text$mn:00005388                 mov     ecx, [ebp+var_20] ; this
.text$mn:0000538B                 call    ?AsFixed@TabInfo@@QBEPAVDisplayModel@@XZ ; TabInfo::AsFixed(void)
.text$mn:00005390                 test    eax, eax
.text$mn:00005392                 jz      short loc_53FC
.text$mn:00005394                 mov     eax, [ebp+arg_4]
.text$mn:00005397                 cvtsi2sd xmm0, dword ptr [eax+18h]
.text$mn:0000539C                 sub     esp, 8
.text$mn:0000539F                 movsd   [esp+130h+var_130], xmm0
.text$mn:000053A4                 mov     ecx, [ebp+arg_4]
.text$mn:000053A7                 cvtsi2sd xmm0, dword ptr [ecx+14h]
.text$mn:000053AC                 sub     esp, 8
.text$mn:000053AF                 movsd   qword ptr [esp+138h+var_138], xmm0
.text$mn:000053B4                 mov     edx, [ebp+arg_4]
.text$mn:000053B7                 mov     eax, [edx+8]
.text$mn:000053BA                 push    eax             ; int
.text$mn:000053BB                 lea     ecx, [ebp+var_118] ; this
.text$mn:000053C1                 call    ??0ScrollState@@QAE@HNN@Z ; ScrollState::ScrollState(int,double,double)
.text$mn:000053C6                 sub     esp, 18h
.text$mn:000053C9                 mov     ecx, esp
.text$mn:000053CB                 mov     edx, [eax]
.text$mn:000053CD                 mov     [ecx], edx
.text$mn:000053CF                 mov     edx, [eax+4]
.text$mn:000053D2                 mov     [ecx+4], edx
.text$mn:000053D5                 mov     edx, [eax+8]
.text$mn:000053D8                 mov     [ecx+8], edx
.text$mn:000053DB                 mov     edx, [eax+0Ch]
.text$mn:000053DE                 mov     [ecx+0Ch], edx
.text$mn:000053E1                 mov     edx, [eax+10h]
.text$mn:000053E4                 mov     [ecx+10h], edx
.text$mn:000053E7                 mov     eax, [eax+14h]
.text$mn:000053EA                 mov     [ecx+14h], eax
.text$mn:000053ED                 mov     ecx, [ebp+var_20] ; this
.text$mn:000053F0                 call    ?AsFixed@TabInfo@@QBEPAVDisplayModel@@XZ ; TabInfo::AsFixed(void)
.text$mn:000053F5                 mov     ecx, eax
.text$mn:000053F7                 call    ?SetScrollState@DisplayModel@@QAEXUScrollState@@@Z ; DisplayModel::SetScrollState(ScrollState)
.text$mn:000053FC
.text$mn:000053FC loc_53FC:                               ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+40j
.text$mn:000053FC                                         ; RestoreTabOnStartup(WindowInfo *,TabState *):loc_5269j ...
.text$mn:000053FC                 push    edx
.text$mn:000053FD                 mov     ecx, ebp
.text$mn:000053FF                 push    eax
.text$mn:00005400                 lea     edx, $LN14_0
.text$mn:00005406                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:0000540B                 pop     eax
.text$mn:0000540C                 pop     edx
.text$mn:0000540D                 pop     edi
.text$mn:0000540E                 pop     esi
.text$mn:0000540F                 pop     ebx
.text$mn:00005410                 add     esp, 11Ch
.text$mn:00005416                 cmp     ebp, esp
.text$mn:00005418                 call    __RTC_CheckEsp
.text$mn:0000541D                 mov     esp, ebp
.text$mn:0000541F                 pop     ebp
.text$mn:00005420                 retn
.text$mn:00005420 ?RestoreTabOnStartup@@YAXPAVWindowInfo@@PAUTabState@@@Z endp ; sp-analysis failed
.text$mn:00005420
.text$mn:00005420 ; ---------------------------------------------------------------------------
.text$mn:00005421                 align 4
.text$mn:00005424 $LN14_0         dd 1                    ; DATA XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+1F4o
.text$mn:00005428                 dd offset $LN13_1
.text$mn:0000542C $LN13_1         dd 0FFFFFFECh, 10h      ; DATA XREF: .text$mn:00005428o
.text$mn:00005434                 dd offset $LN12_1       ; "args"
.text$mn:00005438 $LN12_1         db 'args',0             ; DATA XREF: .text$mn:00005434o
.text$mn:0000543D                 align 10h
.text$mn:0000543D _text$mn        ends
.text$mn:0000543D
.text$mn:00005440 ; ===========================================================================
.text$mn:00005440
.text$mn:00005440 ; Segment type: Pure code
.text$mn:00005440 ; Segment permissions: Read/Execute
.text$mn:00005440 _text$mn        segment para public 'CODE' use32
.text$mn:00005440                 assume cs:_text$mn
.text$mn:00005440                 ;org 5440h
.text$mn:00005440                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005440
.text$mn:00005440 ; =============== S U B R O U T I N E =======================================
.text$mn:00005440
.text$mn:00005440 ; Attributes: bp-based frame
.text$mn:00005440
.text$mn:00005440 ; void __thiscall FileExistenceChecker::Run(FileExistenceChecker *__hidden this)
.text$mn:00005440                 public ?Run@FileExistenceChecker@@UAEXXZ
.text$mn:00005440 ?Run@FileExistenceChecker@@UAEXXZ proc near ; DATA XREF: .rdata:000074BCo
.text$mn:00005440
.text$mn:00005440 var_128         = dword ptr -128h
.text$mn:00005440 var_120         = byte ptr -120h
.text$mn:00005440 var_114         = byte ptr -114h
.text$mn:00005440 var_24          = dword ptr -24h
.text$mn:00005440 var_18          = dword ptr -18h
.text$mn:00005440 var_C           = dword ptr -0Ch
.text$mn:00005440 var_4           = dword ptr -4
.text$mn:00005440
.text$mn:00005440                 push    ebp
.text$mn:00005441                 mov     ebp, esp
.text$mn:00005443                 sub     esp, 128h
.text$mn:00005449                 push    ebx
.text$mn:0000544A                 push    esi
.text$mn:0000544B                 push    edi
.text$mn:0000544C                 push    ecx
.text$mn:0000544D                 lea     edi, [ebp+var_128]
.text$mn:00005453                 mov     ecx, 4Ah ; 'J'
.text$mn:00005458                 mov     eax, 0CCCCCCCCh
.text$mn:0000545D                 rep stosd
.text$mn:0000545F                 pop     ecx
.text$mn:00005460                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005465                 xor     eax, ebp
.text$mn:00005467                 mov     [ebp+var_4], eax
.text$mn:0000546A                 mov     [ebp+var_C], ecx
.text$mn:0000546D                 mov     [ebp+var_18], 0
.text$mn:00005474                 jmp     short loc_547F
.text$mn:00005476 ; ---------------------------------------------------------------------------
.text$mn:00005476
.text$mn:00005476 loc_5476:                               ; CODE XREF: FileExistenceChecker::Run(void):loc_54FEj
.text$mn:00005476                 mov     eax, [ebp+var_18]
.text$mn:00005479                 add     eax, 1
.text$mn:0000547C                 mov     [ebp+var_18], eax
.text$mn:0000547F
.text$mn:0000547F loc_547F:                               ; CODE XREF: FileExistenceChecker::Run(void)+34j
.text$mn:0000547F                 mov     ecx, [ebp+var_C]
.text$mn:00005482                 add     ecx, 14h
.text$mn:00005485                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:0000548A                 cmp     [ebp+var_18], eax
.text$mn:0000548D                 jnb     short loc_5503
.text$mn:0000548F                 mov     eax, [ebp+var_18]
.text$mn:00005492                 push    eax
.text$mn:00005493                 mov     ecx, [ebp+var_C]
.text$mn:00005496                 add     ecx, 14h
.text$mn:00005499                 call    ?At@?$Vec@PA_W@@QBEAAPA_WI@Z ; Vec<wchar_t *>::At(uint)
.text$mn:0000549E                 mov     ecx, [eax]
.text$mn:000054A0                 mov     [ebp+var_24], ecx
.text$mn:000054A3                 cmp     [ebp+var_24], 0
.text$mn:000054A7                 jz      short loc_54CF
.text$mn:000054A9                 mov     eax, [ebp+var_24]
.text$mn:000054AC                 push    eax             ; this
.text$mn:000054AD                 call    ?IsOnFixedDrive@path@@YA_NPB_W@Z ; path::IsOnFixedDrive(wchar_t const *)
.text$mn:000054B2                 add     esp, 4
.text$mn:000054B5                 movzx   ecx, al
.text$mn:000054B8                 test    ecx, ecx
.text$mn:000054BA                 jz      short loc_54CF
.text$mn:000054BC                 mov     eax, [ebp+var_24]
.text$mn:000054BF                 push    eax             ; wchar_t *
.text$mn:000054C0                 call    ?DocumentPathExists@@YA_NPB_W@Z ; DocumentPathExists(wchar_t const *)
.text$mn:000054C5                 add     esp, 4
.text$mn:000054C8                 movzx   ecx, al
.text$mn:000054CB                 test    ecx, ecx
.text$mn:000054CD                 jz      short loc_54FE
.text$mn:000054CF
.text$mn:000054CF loc_54CF:                               ; CODE XREF: FileExistenceChecker::Run(void)+67j
.text$mn:000054CF                                         ; FileExistenceChecker::Run(void)+7Aj
.text$mn:000054CF                 mov     eax, [ebp+var_18]
.text$mn:000054D2                 mov     [ebp+var_128], eax
.text$mn:000054D8                 mov     ecx, [ebp+var_18]
.text$mn:000054DB                 sub     ecx, 1
.text$mn:000054DE                 mov     [ebp+var_18], ecx
.text$mn:000054E1                 push    1
.text$mn:000054E3                 mov     edx, [ebp+var_128]
.text$mn:000054E9                 push    edx
.text$mn:000054EA                 mov     ecx, [ebp+var_C]
.text$mn:000054ED                 add     ecx, 14h
.text$mn:000054F0                 call    ?PopAt@?$Vec@PA_W@@QAEPA_WI@Z ; Vec<wchar_t *>::PopAt(uint)
.text$mn:000054F5                 push    eax
.text$mn:000054F6                 call    __free_dbg
.text$mn:000054FB                 add     esp, 8
.text$mn:000054FE
.text$mn:000054FE loc_54FE:                               ; CODE XREF: FileExistenceChecker::Run(void)+8Dj
.text$mn:000054FE                 jmp     loc_5476
.text$mn:00005503 ; ---------------------------------------------------------------------------
.text$mn:00005503
.text$mn:00005503 loc_5503:                               ; CODE XREF: FileExistenceChecker::Run(void)+4Dj
.text$mn:00005503                 mov     eax, [ebp+var_C]
.text$mn:00005506                 push    eax
.text$mn:00005507                 lea     ecx, [ebp+var_120]
.text$mn:0000550D                 call    ??0_lambda_b6f3cb1c717d8c8a816f87295491882e_@@QAE@QAVFileExistenceChecker@@@Z ; _lambda_b6f3cb1c717d8c8a816f87295491882e_::_lambda_b6f3cb1c717d8c8a816f87295491882e_(FileExistenceChecker * const)
.text$mn:00005512                 mov     ecx, [eax]
.text$mn:00005514                 push    ecx
.text$mn:00005515                 lea     ecx, [ebp+var_114]
.text$mn:0000551B                 call    ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@?$function@$$A6AXXZ@std@@QAE@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z ; std::function<void (void)>::function<void (void)>(_lambda_b6f3cb1c717d8c8a816f87295491882e_)
.text$mn:00005520                 lea     edx, [ebp+var_114]
.text$mn:00005526                 push    edx
.text$mn:00005527                 call    ?Post@uitask@@YAXABV?$function@$$A6AXXZ@std@@@Z ; uitask::Post(std::function<void (void)> const &)
.text$mn:0000552C                 add     esp, 4
.text$mn:0000552F                 lea     ecx, [ebp+var_114]
.text$mn:00005535                 call    ??1?$function@$$A6AXXZ@std@@QAE@XZ ; std::function<void (void)>::~function<void (void)>(void)
.text$mn:0000553A                 pop     edi
.text$mn:0000553B                 pop     esi
.text$mn:0000553C                 pop     ebx
.text$mn:0000553D                 mov     ecx, [ebp+var_4]
.text$mn:00005540                 xor     ecx, ebp
.text$mn:00005542                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00005547                 add     esp, 128h
.text$mn:0000554D                 cmp     ebp, esp
.text$mn:0000554F                 call    __RTC_CheckEsp
.text$mn:00005554                 mov     esp, ebp
.text$mn:00005556                 pop     ebp
.text$mn:00005557                 retn
.text$mn:00005557 ?Run@FileExistenceChecker@@UAEXXZ endp
.text$mn:00005557
.text$mn:00005557 _text$mn        ends
.text$mn:00005557
.text$mn:00005558 ; ===========================================================================
.text$mn:00005558
.text$mn:00005558 ; Segment type: Pure code
.text$mn:00005558 ; Segment permissions: Read/Execute
.text$mn:00005558 _text$mn        segment para public 'CODE' use32
.text$mn:00005558                 assume cs:_text$mn
.text$mn:00005558                 ;org 5558h
.text$mn:00005558                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005558
.text$mn:00005558 ; =============== S U B R O U T I N E =======================================
.text$mn:00005558
.text$mn:00005558 ; Attributes: bp-based frame
.text$mn:00005558
.text$mn:00005558 ; int __cdecl RunMessageLoop(void)
.text$mn:00005558 ?RunMessageLoop@@YAHXZ proc near        ; CODE XREF: WinMain(x,x,x,x)+A74p
.text$mn:00005558
.text$mn:00005558 var_10C         = dword ptr -10Ch
.text$mn:00005558 hWnd            = dword ptr -44h
.text$mn:00005558 var_38          = dword ptr -38h
.text$mn:00005558 Msg             = tagMSG ptr -2Ch
.text$mn:00005558 hAccTable       = dword ptr -8
.text$mn:00005558
.text$mn:00005558                 push    ebp
.text$mn:00005559                 mov     ebp, esp
.text$mn:0000555B                 sub     esp, 10Ch
.text$mn:00005561                 push    ebx
.text$mn:00005562                 push    esi
.text$mn:00005563                 push    edi
.text$mn:00005564                 lea     edi, [ebp+var_10C]
.text$mn:0000556A                 mov     ecx, 43h ; 'C'
.text$mn:0000556F                 mov     eax, 0CCCCCCCCh
.text$mn:00005574                 rep stosd
.text$mn:00005576                 mov     esi, esp
.text$mn:00005578                 push    (offset loc_F9F+1) ; lpTableName
.text$mn:0000557D                 mov     edi, esp
.text$mn:0000557F                 push    0               ; lpModuleName
.text$mn:00005581                 call    dword ptr ds:__imp__GetModuleHandleW@4 ; GetModuleHandleW(x)
.text$mn:00005587                 cmp     edi, esp
.text$mn:00005589                 call    __RTC_CheckEsp
.text$mn:0000558E                 push    eax             ; hInstance
.text$mn:0000558F                 call    dword ptr ds:__imp__LoadAcceleratorsW@8 ; LoadAcceleratorsW(x,x)
.text$mn:00005595                 cmp     esi, esp
.text$mn:00005597                 call    __RTC_CheckEsp
.text$mn:0000559C                 mov     [ebp+hAccTable], eax
.text$mn:0000559F                 mov     [ebp+Msg.hwnd], 0
.text$mn:000055A6                 xor     eax, eax
.text$mn:000055A8                 mov     [ebp+Msg.message], eax
.text$mn:000055AB                 mov     [ebp+Msg.wParam], eax
.text$mn:000055AE                 mov     [ebp+Msg.lParam], eax
.text$mn:000055B1                 mov     [ebp+Msg.time], eax
.text$mn:000055B4                 mov     [ebp+Msg.pt.x], eax
.text$mn:000055B7                 mov     [ebp+Msg.pt.y], eax
.text$mn:000055BA
.text$mn:000055BA loc_55BA:                               ; CODE XREF: RunMessageLoop(void)+D7j
.text$mn:000055BA                                         ; RunMessageLoop(void)+FFj
.text$mn:000055BA                 mov     esi, esp
.text$mn:000055BC                 push    0               ; wMsgFilterMax
.text$mn:000055BE                 push    0               ; wMsgFilterMin
.text$mn:000055C0                 push    0               ; hWnd
.text$mn:000055C2                 lea     eax, [ebp+Msg]
.text$mn:000055C5                 push    eax             ; lpMsg
.text$mn:000055C6                 call    dword ptr ds:__imp__GetMessageW@16 ; GetMessageW(x,x,x,x)
.text$mn:000055CC                 cmp     esi, esp
.text$mn:000055CE                 call    __RTC_CheckEsp
.text$mn:000055D3                 test    eax, eax
.text$mn:000055D5                 jz      loc_565C
.text$mn:000055DB                 mov     eax, [ebp+Msg.hwnd]
.text$mn:000055DE                 push    eax             ; HWND
.text$mn:000055DF                 call    ?FindWindowInfoByHwnd@@YAPAVWindowInfo@@PAUHWND__@@@Z ; FindWindowInfoByHwnd(HWND__ *)
.text$mn:000055E4                 add     esp, 4
.text$mn:000055E7                 mov     [ebp+var_38], eax
.text$mn:000055EA                 cmp     [ebp+var_38], 0
.text$mn:000055EE                 jz      short loc_55FE
.text$mn:000055F0                 mov     eax, [ebp+var_38]
.text$mn:000055F3                 mov     ecx, [eax+5Ch]
.text$mn:000055F6                 mov     [ebp+var_10C], ecx
.text$mn:000055FC                 jmp     short loc_5607
.text$mn:000055FE ; ---------------------------------------------------------------------------
.text$mn:000055FE
.text$mn:000055FE loc_55FE:                               ; CODE XREF: RunMessageLoop(void)+96j
.text$mn:000055FE                 mov     edx, [ebp+Msg.hwnd]
.text$mn:00005601                 mov     [ebp+var_10C], edx
.text$mn:00005607
.text$mn:00005607 loc_5607:                               ; CODE XREF: RunMessageLoop(void)+A4j
.text$mn:00005607                 mov     eax, [ebp+var_10C]
.text$mn:0000560D                 mov     [ebp+hWnd], eax
.text$mn:00005610                 mov     esi, esp
.text$mn:00005612                 lea     eax, [ebp+Msg]
.text$mn:00005615                 push    eax             ; lpMsg
.text$mn:00005616                 mov     ecx, [ebp+hAccTable]
.text$mn:00005619                 push    ecx             ; hAccTable
.text$mn:0000561A                 mov     edx, [ebp+hWnd]
.text$mn:0000561D                 push    edx             ; hWnd
.text$mn:0000561E                 call    dword ptr ds:__imp__TranslateAcceleratorW@12 ; TranslateAcceleratorW(x,x,x)
.text$mn:00005624                 cmp     esi, esp
.text$mn:00005626                 call    __RTC_CheckEsp
.text$mn:0000562B                 test    eax, eax
.text$mn:0000562D                 jz      short loc_5631
.text$mn:0000562F                 jmp     short loc_55BA
.text$mn:00005631 ; ---------------------------------------------------------------------------
.text$mn:00005631
.text$mn:00005631 loc_5631:                               ; CODE XREF: RunMessageLoop(void)+D5j
.text$mn:00005631                 mov     esi, esp
.text$mn:00005633                 lea     eax, [ebp+Msg]
.text$mn:00005636                 push    eax             ; lpMsg
.text$mn:00005637                 call    dword ptr ds:__imp__TranslateMessage@4 ; TranslateMessage(x)
.text$mn:0000563D                 cmp     esi, esp
.text$mn:0000563F                 call    __RTC_CheckEsp
.text$mn:00005644                 mov     esi, esp
.text$mn:00005646                 lea     eax, [ebp+Msg]
.text$mn:00005649                 push    eax             ; lpMsg
.text$mn:0000564A                 call    dword ptr ds:__imp__DispatchMessageW@4 ; DispatchMessageW(x)
.text$mn:00005650                 cmp     esi, esp
.text$mn:00005652                 call    __RTC_CheckEsp
.text$mn:00005657                 jmp     loc_55BA
.text$mn:0000565C ; ---------------------------------------------------------------------------
.text$mn:0000565C
.text$mn:0000565C loc_565C:                               ; CODE XREF: RunMessageLoop(void)+7Dj
.text$mn:0000565C                 mov     eax, [ebp+Msg.wParam]
.text$mn:0000565F                 push    edx
.text$mn:00005660                 mov     ecx, ebp
.text$mn:00005662                 push    eax
.text$mn:00005663                 lea     edx, $LN11_1
.text$mn:00005669                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:0000566E                 pop     eax
.text$mn:0000566F                 pop     edx
.text$mn:00005670                 pop     edi
.text$mn:00005671                 pop     esi
.text$mn:00005672                 pop     ebx
.text$mn:00005673                 add     esp, 10Ch
.text$mn:00005679                 cmp     ebp, esp
.text$mn:0000567B                 call    __RTC_CheckEsp
.text$mn:00005680                 mov     esp, ebp
.text$mn:00005682                 pop     ebp
.text$mn:00005683                 retn
.text$mn:00005683 ?RunMessageLoop@@YAHXZ endp
.text$mn:00005683
.text$mn:00005683 ; ---------------------------------------------------------------------------
.text$mn:00005684 $LN11_1         dd 1                    ; DATA XREF: RunMessageLoop(void)+10Bo
.text$mn:00005688                 dd offset $LN10_0
.text$mn:0000568C $LN10_0         dd 0FFFFFFD4h, 1Ch      ; DATA XREF: .text$mn:00005688o
.text$mn:00005694                 dd offset $LN9_1
.text$mn:00005698 $LN9_1          dd 67736Dh              ; DATA XREF: .text$mn:00005694o
.text$mn:00005698 _text$mn        ends
.text$mn:00005698
.text$mn:0000569C ; ===========================================================================
.text$mn:0000569C
.text$mn:0000569C ; Segment type: Pure code
.text$mn:0000569C ; Segment permissions: Read/Execute
.text$mn:0000569C _text$mn        segment para public 'CODE' use32
.text$mn:0000569C                 assume cs:_text$mn
.text$mn:0000569C                 ;org 569Ch
.text$mn:0000569C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000569C
.text$mn:0000569C ; =============== S U B R O U T I N E =======================================
.text$mn:0000569C
.text$mn:0000569C ; Attributes: bp-based frame
.text$mn:0000569C
.text$mn:0000569C ; public: void __thiscall ScopedMem<wchar_t>::Set(wchar_t *)
.text$mn:0000569C                 public ?Set@?$ScopedMem@_W@@QAEXPA_W@Z
.text$mn:0000569C ?Set@?$ScopedMem@_W@@QAEXPA_W@Z proc near
.text$mn:0000569C                                         ; CODE XREF: SetupCrashHandler(void)+5Fp
.text$mn:0000569C                                         ; SetupCrashHandler(void)+77p ...
.text$mn:0000569C
.text$mn:0000569C var_CC          = byte ptr -0CCh
.text$mn:0000569C var_8           = dword ptr -8
.text$mn:0000569C arg_0           = dword ptr  8
.text$mn:0000569C
.text$mn:0000569C                 push    ebp
.text$mn:0000569D                 mov     ebp, esp
.text$mn:0000569F                 sub     esp, 0CCh
.text$mn:000056A5                 push    ebx
.text$mn:000056A6                 push    esi
.text$mn:000056A7                 push    edi
.text$mn:000056A8                 push    ecx
.text$mn:000056A9                 lea     edi, [ebp+var_CC]
.text$mn:000056AF                 mov     ecx, 33h ; '3'
.text$mn:000056B4                 mov     eax, 0CCCCCCCCh
.text$mn:000056B9                 rep stosd
.text$mn:000056BB                 pop     ecx
.text$mn:000056BC                 mov     [ebp+var_8], ecx
.text$mn:000056BF                 push    1
.text$mn:000056C1                 mov     eax, [ebp+var_8]
.text$mn:000056C4                 mov     ecx, [eax]
.text$mn:000056C6                 push    ecx
.text$mn:000056C7                 call    __free_dbg
.text$mn:000056CC                 add     esp, 8
.text$mn:000056CF                 mov     eax, [ebp+var_8]
.text$mn:000056D2                 mov     ecx, [ebp+arg_0]
.text$mn:000056D5                 mov     [eax], ecx
.text$mn:000056D7                 pop     edi
.text$mn:000056D8                 pop     esi
.text$mn:000056D9                 pop     ebx
.text$mn:000056DA                 add     esp, 0CCh
.text$mn:000056E0                 cmp     ebp, esp
.text$mn:000056E2                 call    __RTC_CheckEsp
.text$mn:000056E7                 mov     esp, ebp
.text$mn:000056E9                 pop     ebp
.text$mn:000056EA                 retn    4
.text$mn:000056EA ?Set@?$ScopedMem@_W@@QAEXPA_W@Z endp
.text$mn:000056EA
.text$mn:000056EA ; ---------------------------------------------------------------------------
.text$mn:000056ED                 align 10h
.text$mn:000056ED _text$mn        ends
.text$mn:000056ED
.text$mn:000056F0 ; ===========================================================================
.text$mn:000056F0
.text$mn:000056F0 ; Segment type: Pure code
.text$mn:000056F0 ; Segment permissions: Read/Execute
.text$mn:000056F0 _text$mn        segment para public 'CODE' use32
.text$mn:000056F0                 assume cs:_text$mn
.text$mn:000056F0                 ;org 56F0h
.text$mn:000056F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056F0
.text$mn:000056F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000056F0
.text$mn:000056F0 ; Attributes: bp-based frame
.text$mn:000056F0
.text$mn:000056F0 ; void __cdecl SetupCrashHandler(void)
.text$mn:000056F0 ?SetupCrashHandler@@YAXXZ proc near     ; CODE XREF: WinMain(x,x,x,x)+F9p
.text$mn:000056F0
.text$mn:000056F0 var_E4          = byte ptr -0E4h
.text$mn:000056F0 var_20          = byte ptr -20h
.text$mn:000056F0 var_14          = byte ptr -14h
.text$mn:000056F0 var_8           = byte ptr -8
.text$mn:000056F0
.text$mn:000056F0                 push    ebp
.text$mn:000056F1                 mov     ebp, esp
.text$mn:000056F3                 sub     esp, 0E4h
.text$mn:000056F9                 push    ebx
.text$mn:000056FA                 push    esi
.text$mn:000056FB                 push    edi             ; wchar_t *
.text$mn:000056FC                 lea     edi, [ebp+var_E4]
.text$mn:00005702                 mov     ecx, 39h ; '9'
.text$mn:00005707                 mov     eax, 0CCCCCCCCh
.text$mn:0000570C                 rep stosd
.text$mn:0000570E                 lea     ecx, [ebp+var_8]
.text$mn:00005711                 call    ??0?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(void)
.text$mn:00005716                 push    0               ; this
.text$mn:00005718                 call    ?GetTempPathW@path@@YAPA_WPB_W@Z ; path::GetTempPathW(wchar_t const *)
.text$mn:0000571D                 add     esp, 4
.text$mn:00005720                 push    eax
.text$mn:00005721                 lea     ecx, [ebp+var_14]
.text$mn:00005724                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:00005729                 lea     ecx, [ebp+var_14]
.text$mn:0000572C                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00005731                 test    eax, eax
.text$mn:00005733                 jz      short loc_5756
.text$mn:00005735                 push    offset ??_C@_1CG@PBNBCKFL@?$AAS?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAP?$AAD?$AAF?$AA?9?$AAs?$AAy?$AAm?$AAb?$AAo?$AAl?$AAs?$AA?$AA@ ; "SumatraPDF-symbols"
.text$mn:0000573A                 lea     ecx, [ebp+var_14]
.text$mn:0000573D                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00005742                 push    eax             ; this
.text$mn:00005743                 call    ?Join@path@@YAPA_WPB_W0@Z ; path::Join(wchar_t const *,wchar_t const *)
.text$mn:00005748                 add     esp, 8
.text$mn:0000574B                 push    eax
.text$mn:0000574C                 lea     ecx, [ebp+var_8]
.text$mn:0000574F                 call    ?Set@?$ScopedMem@_W@@QAEXPA_W@Z ; ScopedMem<wchar_t>::Set(wchar_t *)
.text$mn:00005754                 jmp     short loc_576C
.text$mn:00005756 ; ---------------------------------------------------------------------------
.text$mn:00005756
.text$mn:00005756 loc_5756:                               ; CODE XREF: SetupCrashHandler(void)+43j
.text$mn:00005756                 push    offset ??_C@_1CG@PBNBCKFL@?$AAS?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAP?$AAD?$AAF?$AA?9?$AAs?$AAy?$AAm?$AAb?$AAo?$AAl?$AAs?$AA?$AA@ ; "SumatraPDF-symbols"
.text$mn:0000575B                 call    ?AppGenDataFilename@@YAPA_WPB_W@Z ; AppGenDataFilename(wchar_t const *)
.text$mn:00005760                 add     esp, 4
.text$mn:00005763                 push    eax
.text$mn:00005764                 lea     ecx, [ebp+var_8]
.text$mn:00005767                 call    ?Set@?$ScopedMem@_W@@QAEXPA_W@Z ; ScopedMem<wchar_t>::Set(wchar_t *)
.text$mn:0000576C
.text$mn:0000576C loc_576C:                               ; CODE XREF: SetupCrashHandler(void)+64j
.text$mn:0000576C                 push    offset ??_C@_1CI@KINBKILN@?$AAs?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAp?$AAd?$AAf?$AAc?$AAr?$AAa?$AAs?$AAh?$AA?4?$AAd?$AAm?$AAp?$AA?$AA@ ; "sumatrapdfcrash.dmp"
.text$mn:00005771                 call    ?AppGenDataFilename@@YAPA_WPB_W@Z ; AppGenDataFilename(wchar_t const *)
.text$mn:00005776                 add     esp, 4
.text$mn:00005779                 push    eax
.text$mn:0000577A                 lea     ecx, [ebp+var_20]
.text$mn:0000577D                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:00005782                 lea     ecx, [ebp+var_8]
.text$mn:00005785                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:0000578A                 push    eax             ; wchar_t *
.text$mn:0000578B                 lea     ecx, [ebp+var_20]
.text$mn:0000578E                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00005793                 push    eax             ; wchar_t *
.text$mn:00005794                 call    ?InstallCrashHandler@@YAXPB_W0@Z ; InstallCrashHandler(wchar_t const *,wchar_t const *)
.text$mn:00005799                 add     esp, 8
.text$mn:0000579C                 lea     ecx, [ebp+var_20]
.text$mn:0000579F                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000057A4                 lea     ecx, [ebp+var_14]
.text$mn:000057A7                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000057AC                 lea     ecx, [ebp+var_8]
.text$mn:000057AF                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:000057B4                 push    edx
.text$mn:000057B5                 mov     ecx, ebp
.text$mn:000057B7                 push    eax
.text$mn:000057B8                 lea     edx, $LN9_0
.text$mn:000057BE                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:000057C3                 pop     eax
.text$mn:000057C4                 pop     edx
.text$mn:000057C5                 pop     edi
.text$mn:000057C6                 pop     esi
.text$mn:000057C7                 pop     ebx
.text$mn:000057C8                 add     esp, 0E4h
.text$mn:000057CE                 cmp     ebp, esp
.text$mn:000057D0                 call    __RTC_CheckEsp
.text$mn:000057D5                 mov     esp, ebp
.text$mn:000057D7                 pop     ebp
.text$mn:000057D8                 retn
.text$mn:000057D8 ?SetupCrashHandler@@YAXXZ endp
.text$mn:000057D8
.text$mn:000057D8 ; ---------------------------------------------------------------------------
.text$mn:000057D9                 align 4
.text$mn:000057DC $LN9_0          dd 3                    ; DATA XREF: SetupCrashHandler(void)+C8o
.text$mn:000057E0                 dd offset $LN8_0
.text$mn:000057E4 $LN8_0          dd 0FFFFFFF8h, 4        ; DATA XREF: .text$mn:000057E0o
.text$mn:000057EC                 dd offset $LN5_1        ; "symDir"
.text$mn:000057F0                 dd 0FFFFFFECh, 4
.text$mn:000057F8                 dd offset $LN6_1        ; "tmpDir"
.text$mn:000057FC                 dd 0FFFFFFE0h, 4
.text$mn:00005804                 dd offset $LN7_0        ; "crashDumpPath"
.text$mn:00005808 $LN7_0          db 'crashDumpPath',0    ; DATA XREF: .text$mn:00005804o
.text$mn:00005816 $LN6_1          db 'tmpDir',0           ; DATA XREF: .text$mn:000057F8o
.text$mn:0000581D $LN5_1          db 'symDir',0           ; DATA XREF: .text$mn:000057ECo
.text$mn:0000581D _text$mn        ends
.text$mn:0000581D
.text$mn:00005824 ; ===========================================================================
.text$mn:00005824
.text$mn:00005824 ; Segment type: Pure code
.text$mn:00005824 ; Segment permissions: Read/Execute
.text$mn:00005824 _text$mn        segment para public 'CODE' use32
.text$mn:00005824                 assume cs:_text$mn
.text$mn:00005824                 ;org 5824h
.text$mn:00005824                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005824
.text$mn:00005824 ; =============== S U B R O U T I N E =======================================
.text$mn:00005824
.text$mn:00005824 ; Attributes: bp-based frame
.text$mn:00005824
.text$mn:00005824 ; bool __cdecl SetupPluginMode(class CommandLineInfo &)
.text$mn:00005824 ?SetupPluginMode@@YA_NAAVCommandLineInfo@@@Z proc near
.text$mn:00005824                                         ; CODE XREF: WinMain(x,x,x,x)+2C9p
.text$mn:00005824
.text$mn:00005824 var_14C         = byte ptr -14Ch
.text$mn:00005824 var_88          = word ptr -88h
.text$mn:00005824 Str             = dword ptr -7Ch
.text$mn:00005824 var_70          = dword ptr -70h
.text$mn:00005824 var_64          = byte ptr -64h
.text$mn:00005824 var_8           = byte ptr -8
.text$mn:00005824 arg_0           = dword ptr  8
.text$mn:00005824
.text$mn:00005824                 push    ebp
.text$mn:00005825                 mov     ebp, esp
.text$mn:00005827                 sub     esp, 14Ch
.text$mn:0000582D                 push    ebx
.text$mn:0000582E                 push    esi
.text$mn:0000582F                 push    edi
.text$mn:00005830                 lea     edi, [ebp+var_14C]
.text$mn:00005836                 mov     ecx, 53h ; 'S'
.text$mn:0000583B                 mov     eax, 0CCCCCCCCh
.text$mn:00005840                 rep stosd
.text$mn:00005842                 mov     esi, esp
.text$mn:00005844                 mov     eax, [ebp+arg_0]
.text$mn:00005847                 mov     ecx, [eax+0E0h]
.text$mn:0000584D                 push    ecx             ; hWnd
.text$mn:0000584E                 call    dword ptr ds:__imp__IsWindow@4 ; IsWindow(x)
.text$mn:00005854                 cmp     esi, esp
.text$mn:00005856                 call    __RTC_CheckEsp
.text$mn:0000585B                 test    eax, eax
.text$mn:0000585D                 jz      short loc_586B
.text$mn:0000585F                 mov     ecx, [ebp+arg_0]
.text$mn:00005862                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00005867                 test    eax, eax
.text$mn:00005869                 jnz     short loc_5872
.text$mn:0000586B
.text$mn:0000586B loc_586B:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+39j
.text$mn:0000586B                 xor     al, al
.text$mn:0000586D                 jmp     loc_5B43
.text$mn:00005872 ; ---------------------------------------------------------------------------
.text$mn:00005872
.text$mn:00005872 loc_5872:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+45j
.text$mn:00005872                 mov     ecx, [ebp+arg_0]
.text$mn:00005875                 add     ecx, 0E4h ; 'S'
.text$mn:0000587B                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00005880                 mov     dword ptr ds:?gPluginURL@@3PB_WB, eax ; wchar_t const * const gPluginURL
.text$mn:00005885                 cmp     dword ptr ds:?gPluginURL@@3PB_WB, 0 ; wchar_t const * const gPluginURL
.text$mn:0000588C                 jnz     short loc_589F
.text$mn:0000588E                 push    0
.text$mn:00005890                 mov     ecx, [ebp+arg_0]
.text$mn:00005893                 call    ?At@?$Vec@PA_W@@QBEAAPA_WI@Z ; Vec<wchar_t *>::At(uint)
.text$mn:00005898                 mov     eax, [eax]
.text$mn:0000589A                 mov     dword ptr ds:?gPluginURL@@3PB_WB, eax ; wchar_t const * const gPluginURL
.text$mn:0000589F
.text$mn:0000589F loc_589F:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+68j
.text$mn:0000589F                 mov     ecx, [ebp+arg_0]
.text$mn:000058A2                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:000058A7                 cmp     eax, 1
.text$mn:000058AA                 jz      short loc_58C7
.text$mn:000058AC                 mov     eax, ds:?__LINE__Var@?0??SetupPluginMode@@YA_NAAVCommandLineInfo@@@Z@4JA ; long `SetupPluginMode(CommandLineInfo &)'::`1'::__LINE__Var
.text$mn:000058B1                 add     eax, 8
.text$mn:000058B4                 push    eax             ; Line
.text$mn:000058B5                 push    offset ??_C@_1GM@OAGNGMKE@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAs?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAp?$AAd?$AAf?$AA?9?$AAm?$AAa?$AAs?$AAt?$AAe?$AAr?$AA?2?$AAs@ ; "c:\\workspace\\sumatrapdf-master\\src\\"...
.text$mn:000058BA                 push    offset ??_C@_1DC@NHINHEEK@?$AAi?$AA?4?$AAf?$AAi?$AAl?$AAe?$AAN?$AAa?$AAm?$AAe?$AAs?$AA?4?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; "i.fileNames.Count() == 1"
.text$mn:000058BF                 call    __wassert
.text$mn:000058C4 ; ---------------------------------------------------------------------------
.text$mn:000058C4                 add     esp, 0Ch
.text$mn:000058C7
.text$mn:000058C7 loc_58C7:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+86j
.text$mn:000058C7                                         ; SetupPluginMode(CommandLineInfo &)+C3j
.text$mn:000058C7                 mov     ecx, [ebp+arg_0]
.text$mn:000058CA                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:000058CF                 cmp     eax, 1
.text$mn:000058D2                 jbe     short loc_58E9
.text$mn:000058D4                 push    1
.text$mn:000058D6                 mov     ecx, [ebp+arg_0]
.text$mn:000058D9                 call    ?Pop@?$Vec@PA_W@@QAEPA_WXZ ; Vec<wchar_t *>::Pop(void)
.text$mn:000058DE                 push    eax
.text$mn:000058DF                 call    __free_dbg
.text$mn:000058E4                 add     esp, 8
.text$mn:000058E7                 jmp     short loc_58C7
.text$mn:000058E9 ; ---------------------------------------------------------------------------
.text$mn:000058E9
.text$mn:000058E9 loc_58E9:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+AEj
.text$mn:000058E9                 push    44h ; 'D'       ; int
.text$mn:000058EB                 call    ?RestrictPolicies@@YAXH@Z ; RestrictPolicies(int)
.text$mn:000058F0                 add     esp, 4
.text$mn:000058F3                 mov     eax, [ebp+arg_0]
.text$mn:000058F6                 mov     byte ptr [eax+0A9h], 0
.text$mn:000058FD                 mov     ecx, [ebp+arg_0]
.text$mn:00005900                 mov     byte ptr [ecx+0BCh], 0
.text$mn:00005907                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:0000590C                 mov     byte ptr [eax+5], 0
.text$mn:00005910                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00005915                 mov     byte ptr [eax+0F1h], 0
.text$mn:0000591C                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00005921                 mov     byte ptr [eax+0ACh], 1
.text$mn:00005928                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:0000592D                 mov     byte ptr [eax+4], 0
.text$mn:00005931                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00005936                 mov     byte ptr [eax+0E4h], 0
.text$mn:0000593D                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00005942                 cmp     dword ptr [eax+114h], 0
.text$mn:00005949                 jnz     short loc_596F
.text$mn:0000594B                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00005950                 mov     dword ptr [eax+114h], 4
.text$mn:0000595A                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:0000595F                 movss   xmm0, ds:__real@c0000000
.text$mn:00005967                 movss   dword ptr [eax+118h], xmm0
.text$mn:0000596F
.text$mn:0000596F loc_596F:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+125j
.text$mn:0000596F                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00005974                 mov     byte ptr [eax+68h], 1
.text$mn:00005978                 mov     ecx, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:0000597E                 mov     byte ptr [ecx+48h], 1
.text$mn:00005982                 mov     ecx, [ebp+arg_0]
.text$mn:00005985                 add     ecx, 0E4h ; 'S'
.text$mn:0000598B                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00005990                 test    eax, eax
.text$mn:00005992                 jz      loc_5B41
.text$mn:00005998                 push    offset unk_23   ; wchar_t *
.text$mn:0000599A                 mov     ecx, [ebp+arg_0]
.text$mn:0000599D                 add     ecx, 0E4h ; 'S'
.text$mn:000059A3                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:000059A8                 push    eax             ; Str
.text$mn:000059A9                 call    ?FindChar@str@@YAPA_WPA_W_W@Z ; str::FindChar(wchar_t *,wchar_t)
.text$mn:000059AE                 add     esp, 8
.text$mn:000059B1                 test    eax, eax
.text$mn:000059B3                 jz      loc_5B41
.text$mn:000059B9                 push    offset unk_23   ; wchar_t *
.text$mn:000059BB                 mov     ecx, [ebp+arg_0]
.text$mn:000059BE                 add     ecx, 0E4h ; 'S'
.text$mn:000059C4                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:000059C9                 push    eax             ; Str
.text$mn:000059CA                 call    ?FindChar@str@@YAPA_WPA_W_W@Z ; str::FindChar(wchar_t *,wchar_t)
.text$mn:000059CF                 add     esp, 8
.text$mn:000059D2                 add     eax, 2
.text$mn:000059D5                 push    eax             ; this
.text$mn:000059D6                 call    ?Dup@str@@YAPA_WPB_W@Z ; str::Dup(wchar_t const *)
.text$mn:000059DB                 add     esp, 4
.text$mn:000059DE                 push    eax
.text$mn:000059DF                 lea     ecx, [ebp+var_8]
.text$mn:000059E2                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:000059E7                 push    offset ??_C@_13FLOCNAAB@?$AA?$CG?$AA?$AA@ ; wchar_t *
.text$mn:000059EC                 push    offset ??_C@_13GMDMCADD@?$AA?$CD?$AA?$AA@ ; wchar_t *
.text$mn:000059F1                 lea     ecx, [ebp+var_8]
.text$mn:000059F4                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:000059F9                 push    eax             ; this
.text$mn:000059FA                 call    ?TransChars@str@@YAIPA_WPB_W1@Z ; str::TransChars(wchar_t *,wchar_t const *,wchar_t const *)
.text$mn:000059FF                 add     esp, 0Ch
.text$mn:00005A02                 lea     ecx, [ebp+var_64] ; this
.text$mn:00005A05                 call    ??0WStrVec@@QAE@XZ ; WStrVec::WStrVec(void)
.text$mn:00005A0A                 push    1               ; bool
.text$mn:00005A0C                 push    offset ??_C@_13FLOCNAAB@?$AA?$CG?$AA?$AA@ ; wchar_t *
.text$mn:00005A11                 lea     ecx, [ebp+var_8]
.text$mn:00005A14                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00005A19                 push    eax             ; wchar_t *
.text$mn:00005A1A                 lea     ecx, [ebp+var_64] ; this
.text$mn:00005A1D                 call    ?Split@WStrVec@@QAEIPB_W0_N@Z ; WStrVec::Split(wchar_t const *,wchar_t const *,bool)
.text$mn:00005A22                 mov     [ebp+var_70], 0
.text$mn:00005A29                 jmp     short loc_5A34
.text$mn:00005A2B ; ---------------------------------------------------------------------------
.text$mn:00005A2B
.text$mn:00005A2B loc_5A2B:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &):loc_5B2Cj
.text$mn:00005A2B                 mov     eax, [ebp+var_70]
.text$mn:00005A2E                 add     eax, 1
.text$mn:00005A31                 mov     [ebp+var_70], eax
.text$mn:00005A34
.text$mn:00005A34 loc_5A34:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+205j
.text$mn:00005A34                 lea     ecx, [ebp+var_64]
.text$mn:00005A37                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00005A3C                 cmp     [ebp+var_70], eax
.text$mn:00005A3F                 jnb     loc_5B31
.text$mn:00005A45                 mov     eax, [ebp+var_70]
.text$mn:00005A48                 push    eax
.text$mn:00005A49                 lea     ecx, [ebp+var_64]
.text$mn:00005A4C                 call    ?At@?$Vec@PA_W@@QBEAAPA_WI@Z ; Vec<wchar_t *>::At(uint)
.text$mn:00005A51                 mov     ecx, [eax]
.text$mn:00005A53                 mov     [ebp+Str], ecx
.text$mn:00005A56                 push    offset ??_C@_1M@BOBDMABN@?$AAp?$AAa?$AAg?$AAe?$AA?$DN?$AA?$AA@ ; "page="
.text$mn:00005A5B                 mov     eax, [ebp+Str]
.text$mn:00005A5E                 push    eax             ; this
.text$mn:00005A5F                 call    ?StartsWithI@str@@YA_NPB_W0@Z ; str::StartsWithI(wchar_t const *,wchar_t const *)
.text$mn:00005A64                 add     esp, 8
.text$mn:00005A67                 movzx   ecx, al
.text$mn:00005A6A                 test    ecx, ecx
.text$mn:00005A6C                 jz      short loc_5AA1
.text$mn:00005A6E                 lea     eax, [ebp+var_88]
.text$mn:00005A74                 push    eax             ; wchar_t *
.text$mn:00005A75                 push    offset ??_C@_1M@ILEIMEED@?$AA?$DN?$AA?$CF?$AAd?$AA?$CF?$AA$?$AA?$AA@ ; "=%d%$"
.text$mn:00005A7A                 mov     ecx, [ebp+Str]
.text$mn:00005A7D                 add     ecx, 8
.text$mn:00005A80                 push    ecx             ; this
.text$mn:00005A81                 call    ?Parse@str@@YAPB_WPB_W0ZZ ; str::Parse(wchar_t const *,wchar_t const *,...)
.text$mn:00005A86                 add     esp, 0Ch
.text$mn:00005A89                 test    eax, eax
.text$mn:00005A8B                 jz      short loc_5AA1
.text$mn:00005A8D                 mov     eax, [ebp+arg_0]
.text$mn:00005A90                 mov     ecx, dword ptr [ebp+var_88]
.text$mn:00005A96                 mov     [eax+0C4h], ecx
.text$mn:00005A9C                 jmp     loc_5B2C
.text$mn:00005AA1 ; ---------------------------------------------------------------------------
.text$mn:00005AA1
.text$mn:00005AA1 loc_5AA1:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+248j
.text$mn:00005AA1                                         ; SetupPluginMode(CommandLineInfo &)+267j
.text$mn:00005AA1                 push    offset ??_C@_1BG@PKGIHOED@?$AAn?$AAa?$AAm?$AAe?$AAd?$AAd?$AAe?$AAs?$AAt?$AA?$DN?$AA?$AA@ ; "nameddest="
.text$mn:00005AA6                 mov     eax, [ebp+Str]
.text$mn:00005AA9                 push    eax             ; this
.text$mn:00005AAA                 call    ?StartsWithI@str@@YA_NPB_W0@Z ; str::StartsWithI(wchar_t const *,wchar_t const *)
.text$mn:00005AAF                 add     esp, 8
.text$mn:00005AB2                 movzx   ecx, al
.text$mn:00005AB5                 test    ecx, ecx
.text$mn:00005AB7                 jz      short loc_5AEC
.text$mn:00005AB9                 mov     eax, 2
.text$mn:00005ABE                 imul    ecx, eax, 0Ah
.text$mn:00005AC1                 mov     edx, [ebp+Str]
.text$mn:00005AC4                 movzx   eax, word ptr [edx+ecx]
.text$mn:00005AC8                 test    eax, eax
.text$mn:00005ACA                 jz      short loc_5AEC
.text$mn:00005ACC                 mov     eax, [ebp+Str]
.text$mn:00005ACF                 add     eax, 14h
.text$mn:00005AD2                 push    eax             ; this
.text$mn:00005AD3                 call    ?Dup@str@@YAPA_WPB_W@Z ; str::Dup(wchar_t const *)
.text$mn:00005AD8                 add     esp, 4
.text$mn:00005ADB                 push    eax
.text$mn:00005ADC                 mov     ecx, [ebp+arg_0]
.text$mn:00005ADF                 add     ecx, 0C0h ; '+'
.text$mn:00005AE5                 call    ?Set@?$ScopedMem@_W@@QAEXPA_W@Z ; ScopedMem<wchar_t>::Set(wchar_t *)
.text$mn:00005AEA                 jmp     short loc_5B2C
.text$mn:00005AEC ; ---------------------------------------------------------------------------
.text$mn:00005AEC
.text$mn:00005AEC loc_5AEC:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+293j
.text$mn:00005AEC                                         ; SetupPluginMode(CommandLineInfo &)+2A6j
.text$mn:00005AEC                 push    (offset loc_3B+2) ; wchar_t *
.text$mn:00005AEE                 mov     eax, [ebp+Str]
.text$mn:00005AF1                 push    eax             ; Str
.text$mn:00005AF2                 call    ?FindChar@str@@YAPA_WPA_W_W@Z ; str::FindChar(wchar_t *,wchar_t)
.text$mn:00005AF7                 add     esp, 8
.text$mn:00005AFA                 test    eax, eax
.text$mn:00005AFC                 jnz     short loc_5B2C
.text$mn:00005AFE                 mov     eax, 2
.text$mn:00005B03                 imul    ecx, eax, 0
.text$mn:00005B06                 mov     edx, [ebp+Str]
.text$mn:00005B09                 movzx   eax, word ptr [edx+ecx]
.text$mn:00005B0D                 test    eax, eax
.text$mn:00005B0F                 jz      short loc_5B2C
.text$mn:00005B11                 mov     eax, [ebp+Str]
.text$mn:00005B14                 push    eax             ; this
.text$mn:00005B15                 call    ?Dup@str@@YAPA_WPB_W@Z ; str::Dup(wchar_t const *)
.text$mn:00005B1A                 add     esp, 4
.text$mn:00005B1D                 push    eax
.text$mn:00005B1E                 mov     ecx, [ebp+arg_0]
.text$mn:00005B21                 add     ecx, 0C0h ; '+'
.text$mn:00005B27                 call    ?Set@?$ScopedMem@_W@@QAEXPA_W@Z ; ScopedMem<wchar_t>::Set(wchar_t *)
.text$mn:00005B2C
.text$mn:00005B2C loc_5B2C:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+278j
.text$mn:00005B2C                                         ; SetupPluginMode(CommandLineInfo &)+2C6j ...
.text$mn:00005B2C                 jmp     loc_5A2B
.text$mn:00005B31 ; ---------------------------------------------------------------------------
.text$mn:00005B31
.text$mn:00005B31 loc_5B31:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+21Bj
.text$mn:00005B31                 lea     ecx, [ebp+var_64] ; this
.text$mn:00005B34                 call    ??1WStrVec@@QAE@XZ ; WStrVec::~WStrVec(void)
.text$mn:00005B39                 lea     ecx, [ebp+var_8]
.text$mn:00005B3C                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:00005B41
.text$mn:00005B41 loc_5B41:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+16Ej
.text$mn:00005B41                                         ; SetupPluginMode(CommandLineInfo &)+18Fj
.text$mn:00005B41                 mov     al, 1
.text$mn:00005B43
.text$mn:00005B43 loc_5B43:                               ; CODE XREF: SetupPluginMode(CommandLineInfo &)+49j
.text$mn:00005B43                 push    edx
.text$mn:00005B44                 mov     ecx, ebp
.text$mn:00005B46                 push    eax
.text$mn:00005B47                 lea     edx, $LN23
.text$mn:00005B4D                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00005B52                 pop     eax
.text$mn:00005B53                 pop     edx
.text$mn:00005B54                 pop     edi
.text$mn:00005B55                 pop     esi
.text$mn:00005B56                 pop     ebx
.text$mn:00005B57                 add     esp, 14Ch
.text$mn:00005B5D                 cmp     ebp, esp
.text$mn:00005B5F                 call    __RTC_CheckEsp
.text$mn:00005B64                 mov     esp, ebp
.text$mn:00005B66                 pop     ebp
.text$mn:00005B67                 retn
.text$mn:00005B67 ?SetupPluginMode@@YA_NAAVCommandLineInfo@@@Z endp
.text$mn:00005B67
.text$mn:00005B67 ; ---------------------------------------------------------------------------
.text$mn:00005B68 $LN23           dd 3                    ; DATA XREF: SetupPluginMode(CommandLineInfo &)+323o
.text$mn:00005B6C                 dd offset $LN22
.text$mn:00005B70 $LN22           dd 0FFFFFFF8h, 4        ; DATA XREF: .text$mn:00005B6Co
.text$mn:00005B78                 dd offset $LN19         ; "args"
.text$mn:00005B7C                 dd 0FFFFFF9Ch, 54h
.text$mn:00005B84                 dd offset $LN20         ; "parts"
.text$mn:00005B88                 dd 0FFFFFF78h, 4
.text$mn:00005B90                 dd offset $LN21         ; "pageNo"
.text$mn:00005B94 $LN21           db 'pageNo',0           ; DATA XREF: .text$mn:00005B90o
.text$mn:00005B9B $LN20           db 'parts',0            ; DATA XREF: .text$mn:00005B84o
.text$mn:00005BA1 $LN19           db 'args',0             ; DATA XREF: .text$mn:00005B78o
.text$mn:00005BA6                 align 4
.text$mn:00005BA6 _text$mn        ends
.text$mn:00005BA6
.text$mn:00005BA8 ; ===========================================================================
.text$mn:00005BA8
.text$mn:00005BA8 ; Segment type: Pure code
.text$mn:00005BA8 ; Segment permissions: Read/Execute
.text$mn:00005BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00005BA8                 assume cs:_text$mn
.text$mn:00005BA8                 ;org 5BA8h
.text$mn:00005BA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005BA8
.text$mn:00005BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BA8
.text$mn:00005BA8 ; Attributes: bp-based frame
.text$mn:00005BA8
.text$mn:00005BA8 ; public: unsigned int __thiscall Vec<wchar_t>::Size(void)const
.text$mn:00005BA8                 public ?Size@?$Vec@_W@@QBEIXZ
.text$mn:00005BA8 ?Size@?$Vec@_W@@QBEIXZ proc near        ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+228p
.text$mn:00005BA8
.text$mn:00005BA8 var_CC          = byte ptr -0CCh
.text$mn:00005BA8 var_8           = dword ptr -8
.text$mn:00005BA8
.text$mn:00005BA8                 push    ebp
.text$mn:00005BA9                 mov     ebp, esp
.text$mn:00005BAB                 sub     esp, 0CCh
.text$mn:00005BB1                 push    ebx
.text$mn:00005BB2                 push    esi
.text$mn:00005BB3                 push    edi
.text$mn:00005BB4                 push    ecx
.text$mn:00005BB5                 lea     edi, [ebp+var_CC]
.text$mn:00005BBB                 mov     ecx, 33h ; '3'
.text$mn:00005BC0                 mov     eax, 0CCCCCCCCh
.text$mn:00005BC5                 rep stosd
.text$mn:00005BC7                 pop     ecx
.text$mn:00005BC8                 mov     [ebp+var_8], ecx
.text$mn:00005BCB                 mov     eax, [ebp+var_8]
.text$mn:00005BCE                 mov     eax, [eax]
.text$mn:00005BD0                 pop     edi
.text$mn:00005BD1                 pop     esi
.text$mn:00005BD2                 pop     ebx
.text$mn:00005BD3                 mov     esp, ebp
.text$mn:00005BD5                 pop     ebp
.text$mn:00005BD6                 retn
.text$mn:00005BD6 ?Size@?$Vec@_W@@QBEIXZ endp
.text$mn:00005BD6
.text$mn:00005BD6 ; ---------------------------------------------------------------------------
.text$mn:00005BD7                 align 4
.text$mn:00005BD7 _text$mn        ends
.text$mn:00005BD7
.text$mn:00005BD8 ; ===========================================================================
.text$mn:00005BD8
.text$mn:00005BD8 ; Segment type: Pure code
.text$mn:00005BD8 ; Segment permissions: Read/Execute
.text$mn:00005BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00005BD8                 assume cs:_text$mn
.text$mn:00005BD8                 ;org 5BD8h
.text$mn:00005BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005BD8
.text$mn:00005BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BD8
.text$mn:00005BD8 ; Attributes: bp-based frame
.text$mn:00005BD8
.text$mn:00005BD8 ; unsigned int __thiscall WStrVec::Split(WStrVec *__hidden this, const wchar_t *, const wchar_t *, bool)
.text$mn:00005BD8                 public ?Split@WStrVec@@QAEIPB_W0_N@Z
.text$mn:00005BD8 ?Split@WStrVec@@QAEIPB_W0_N@Z proc near ; CODE XREF: SetupPluginMode(CommandLineInfo &)+1F9p
.text$mn:00005BD8
.text$mn:00005BD8 var_FC          = byte ptr -0FCh
.text$mn:00005BD8 var_F8          = dword ptr -0F8h
.text$mn:00005BD8 var_EC          = dword ptr -0ECh
.text$mn:00005BD8 var_20          = dword ptr -20h
.text$mn:00005BD8 var_14          = dword ptr -14h
.text$mn:00005BD8 var_8           = dword ptr -8
.text$mn:00005BD8 Str             = dword ptr  8
.text$mn:00005BD8 SubStr          = dword ptr  0Ch
.text$mn:00005BD8 arg_8           = byte ptr  10h
.text$mn:00005BD8
.text$mn:00005BD8                 push    ebp
.text$mn:00005BD9                 mov     ebp, esp
.text$mn:00005BDB                 sub     esp, 0FCh
.text$mn:00005BE1                 push    ebx
.text$mn:00005BE2                 push    esi
.text$mn:00005BE3                 push    edi             ; wchar_t *
.text$mn:00005BE4                 push    ecx
.text$mn:00005BE5                 lea     edi, [ebp+var_FC]
.text$mn:00005BEB                 mov     ecx, 3Fh ; '?'
.text$mn:00005BF0                 mov     eax, 0CCCCCCCCh
.text$mn:00005BF5                 rep stosd
.text$mn:00005BF7                 pop     ecx
.text$mn:00005BF8                 mov     [ebp+var_8], ecx
.text$mn:00005BFB                 mov     eax, [ebp+var_8]
.text$mn:00005BFE                 mov     ecx, [eax]
.text$mn:00005C00                 mov     [ebp+var_14], ecx
.text$mn:00005C03
.text$mn:00005C03 loc_5C03:                               ; CODE XREF: WStrVec::Split(wchar_t const *,wchar_t const *,bool)+93j
.text$mn:00005C03                 mov     eax, [ebp+SubStr]
.text$mn:00005C06                 push    eax             ; SubStr
.text$mn:00005C07                 mov     ecx, [ebp+Str]
.text$mn:00005C0A                 push    ecx             ; Str
.text$mn:00005C0B                 call    ?Find@str@@YAPB_WPB_W0@Z ; str::Find(wchar_t const *,wchar_t const *)
.text$mn:00005C10                 add     esp, 8
.text$mn:00005C13                 mov     [ebp+var_20], eax
.text$mn:00005C16                 cmp     [ebp+var_20], 0
.text$mn:00005C1A                 jz      short loc_5C6D
.text$mn:00005C1C                 movzx   eax, [ebp+arg_8]
.text$mn:00005C20                 test    eax, eax
.text$mn:00005C22                 jz      short loc_5C2C
.text$mn:00005C24                 mov     eax, [ebp+var_20]
.text$mn:00005C27                 cmp     eax, [ebp+Str]
.text$mn:00005C2A                 jbe     short loc_5C56
.text$mn:00005C2C
.text$mn:00005C2C loc_5C2C:                               ; CODE XREF: WStrVec::Split(wchar_t const *,wchar_t const *,bool)+4Aj
.text$mn:00005C2C                 mov     eax, [ebp+var_20]
.text$mn:00005C2F                 sub     eax, [ebp+Str]
.text$mn:00005C32                 sar     eax, 1
.text$mn:00005C34                 push    eax             ; wchar_t *
.text$mn:00005C35                 mov     ecx, [ebp+Str]
.text$mn:00005C38                 push    ecx             ; this
.text$mn:00005C39                 call    ?DupN@str@@YAPA_WPB_WI@Z ; str::DupN(wchar_t const *,uint)
.text$mn:00005C3E                 add     esp, 8
.text$mn:00005C41                 mov     [ebp+var_EC], eax
.text$mn:00005C47                 lea     edx, [ebp+var_EC]
.text$mn:00005C4D                 push    edx
.text$mn:00005C4E                 mov     ecx, [ebp+var_8]
.text$mn:00005C51                 call    ?Append@?$Vec@PA_W@@QAEXABQA_W@Z ; Vec<wchar_t *>::Append(wchar_t * const &)
.text$mn:00005C56
.text$mn:00005C56 loc_5C56:                               ; CODE XREF: WStrVec::Split(wchar_t const *,wchar_t const *,bool)+52j
.text$mn:00005C56                 mov     eax, [ebp+SubStr]
.text$mn:00005C59                 push    eax             ; this
.text$mn:00005C5A                 call    ?Len@str@@YAIPB_W@Z ; str::Len(wchar_t const *)
.text$mn:00005C5F                 add     esp, 4
.text$mn:00005C62                 mov     ecx, [ebp+var_20]
.text$mn:00005C65                 lea     edx, [ecx+eax*2]
.text$mn:00005C68                 mov     [ebp+Str], edx
.text$mn:00005C6B                 jmp     short loc_5C03
.text$mn:00005C6D ; ---------------------------------------------------------------------------
.text$mn:00005C6D
.text$mn:00005C6D loc_5C6D:                               ; CODE XREF: WStrVec::Split(wchar_t const *,wchar_t const *,bool)+42j
.text$mn:00005C6D                 movzx   eax, [ebp+arg_8]
.text$mn:00005C71                 test    eax, eax
.text$mn:00005C73                 jz      short loc_5C7F
.text$mn:00005C75                 mov     eax, [ebp+Str]
.text$mn:00005C78                 movzx   ecx, word ptr [eax]
.text$mn:00005C7B                 test    ecx, ecx
.text$mn:00005C7D                 jz      short loc_5CA0
.text$mn:00005C7F
.text$mn:00005C7F loc_5C7F:                               ; CODE XREF: WStrVec::Split(wchar_t const *,wchar_t const *,bool)+9Bj
.text$mn:00005C7F                 mov     eax, [ebp+Str]
.text$mn:00005C82                 push    eax             ; this
.text$mn:00005C83                 call    ?Dup@str@@YAPA_WPB_W@Z ; str::Dup(wchar_t const *)
.text$mn:00005C88                 add     esp, 4
.text$mn:00005C8B                 mov     [ebp+var_F8], eax
.text$mn:00005C91                 lea     ecx, [ebp+var_F8]
.text$mn:00005C97                 push    ecx
.text$mn:00005C98                 mov     ecx, [ebp+var_8]
.text$mn:00005C9B                 call    ?Append@?$Vec@PA_W@@QAEXABQA_W@Z ; Vec<wchar_t *>::Append(wchar_t * const &)
.text$mn:00005CA0
.text$mn:00005CA0 loc_5CA0:                               ; CODE XREF: WStrVec::Split(wchar_t const *,wchar_t const *,bool)+A5j
.text$mn:00005CA0                 mov     eax, [ebp+var_8]
.text$mn:00005CA3                 mov     eax, [eax]
.text$mn:00005CA5                 sub     eax, [ebp+var_14]
.text$mn:00005CA8                 pop     edi
.text$mn:00005CA9                 pop     esi
.text$mn:00005CAA                 pop     ebx
.text$mn:00005CAB                 add     esp, 0FCh
.text$mn:00005CB1                 cmp     ebp, esp
.text$mn:00005CB3                 call    __RTC_CheckEsp
.text$mn:00005CB8                 mov     esp, ebp
.text$mn:00005CBA                 pop     ebp
.text$mn:00005CBB                 retn    0Ch
.text$mn:00005CBB ?Split@WStrVec@@QAEIPB_W0_N@Z endp
.text$mn:00005CBB
.text$mn:00005CBB ; ---------------------------------------------------------------------------
.text$mn:00005CBE                 align 10h
.text$mn:00005CBE _text$mn        ends
.text$mn:00005CBE
.text$mn:00005CC0 ; ===========================================================================
.text$mn:00005CC0
.text$mn:00005CC0 ; Segment type: Pure code
.text$mn:00005CC0 ; Segment permissions: Read/Execute
.text$mn:00005CC0 _text$mn        segment para public 'CODE' use32
.text$mn:00005CC0                 assume cs:_text$mn
.text$mn:00005CC0                 ;org 5CC0h
.text$mn:00005CC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005CC0
.text$mn:00005CC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CC0
.text$mn:00005CC0 ; Attributes: bp-based frame
.text$mn:00005CC0
.text$mn:00005CC0 ; void __thiscall FileExistenceChecker::Terminate(FileExistenceChecker *__hidden this)
.text$mn:00005CC0                 public ?Terminate@FileExistenceChecker@@AAEXXZ
.text$mn:00005CC0 ?Terminate@FileExistenceChecker@@AAEXXZ proc near
.text$mn:00005CC0                                         ; CODE XREF: _lambda_b6f3cb1c717d8c8a816f87295491882e_::operator()(void)+50p
.text$mn:00005CC0
.text$mn:00005CC0 var_E8          = dword ptr -0E8h
.text$mn:00005CC0 var_E0          = dword ptr -0E0h
.text$mn:00005CC0 var_D4          = dword ptr -0D4h
.text$mn:00005CC0 var_8           = dword ptr -8
.text$mn:00005CC0
.text$mn:00005CC0                 push    ebp
.text$mn:00005CC1                 mov     ebp, esp
.text$mn:00005CC3                 sub     esp, 0E8h
.text$mn:00005CC9                 push    ebx
.text$mn:00005CCA                 push    esi
.text$mn:00005CCB                 push    edi
.text$mn:00005CCC                 push    ecx
.text$mn:00005CCD                 lea     edi, [ebp+var_E8]
.text$mn:00005CD3                 mov     ecx, 3Ah ; ':'
.text$mn:00005CD8                 mov     eax, 0CCCCCCCCh
.text$mn:00005CDD                 rep stosd
.text$mn:00005CDF                 pop     ecx
.text$mn:00005CE0                 mov     [ebp+var_8], ecx
.text$mn:00005CE3                 mov     ds:?gFileExistenceChecker@@3PAVFileExistenceChecker@@A, 0 ; FileExistenceChecker * gFileExistenceChecker
.text$mn:00005CED                 push    0FFFFFFFFh      ; unsigned __int32
.text$mn:00005CEF                 mov     ecx, [ebp+var_8] ; this
.text$mn:00005CF2                 call    ?Join@ThreadBase@@QAE_NK@Z ; ThreadBase::Join(ulong)
.text$mn:00005CF7                 mov     eax, [ebp+var_8]
.text$mn:00005CFA                 mov     [ebp+var_E0], eax
.text$mn:00005D00                 mov     ecx, [ebp+var_E0]
.text$mn:00005D06                 mov     [ebp+var_D4], ecx
.text$mn:00005D0C                 cmp     [ebp+var_D4], 0
.text$mn:00005D13                 jz      short loc_5D3A
.text$mn:00005D15                 mov     esi, esp
.text$mn:00005D17                 push    1
.text$mn:00005D19                 mov     edx, [ebp+var_D4]
.text$mn:00005D1F                 mov     eax, [edx]
.text$mn:00005D21                 mov     ecx, [ebp+var_D4]
.text$mn:00005D27                 mov     edx, [eax]
.text$mn:00005D29                 call    edx
.text$mn:00005D2B                 cmp     esi, esp
.text$mn:00005D2D                 call    __RTC_CheckEsp
.text$mn:00005D32                 mov     [ebp+var_E8], eax
.text$mn:00005D38                 jmp     short loc_5D44
.text$mn:00005D3A ; ---------------------------------------------------------------------------
.text$mn:00005D3A
.text$mn:00005D3A loc_5D3A:                               ; CODE XREF: FileExistenceChecker::Terminate(void)+53j
.text$mn:00005D3A                 mov     [ebp+var_E8], 0
.text$mn:00005D44
.text$mn:00005D44 loc_5D44:                               ; CODE XREF: FileExistenceChecker::Terminate(void)+78j
.text$mn:00005D44                 pop     edi
.text$mn:00005D45                 pop     esi
.text$mn:00005D46                 pop     ebx
.text$mn:00005D47                 add     esp, 0E8h
.text$mn:00005D4D                 cmp     ebp, esp
.text$mn:00005D4F                 call    __RTC_CheckEsp
.text$mn:00005D54                 mov     esp, ebp
.text$mn:00005D56                 pop     ebp
.text$mn:00005D57                 retn
.text$mn:00005D57 ?Terminate@FileExistenceChecker@@AAEXXZ endp
.text$mn:00005D57
.text$mn:00005D57 _text$mn        ends
.text$mn:00005D57
.text$mn:00005D58 ; ===========================================================================
.text$mn:00005D58
.text$mn:00005D58 ; Segment type: Pure code
.text$mn:00005D58 ; Segment permissions: Read/Execute
.text$mn:00005D58 _text$mn        segment para public 'CODE' use32
.text$mn:00005D58                 assume cs:_text$mn
.text$mn:00005D58                 ;org 5D58h
.text$mn:00005D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D58
.text$mn:00005D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D58
.text$mn:00005D58 ; Attributes: bp-based frame
.text$mn:00005D58
.text$mn:00005D58 ; bool __cdecl TryLoadMemTrace(void)
.text$mn:00005D58 ?TryLoadMemTrace@@YA_NXZ proc near      ; CODE XREF: WinMain(x,x,x,x)+6Bp
.text$mn:00005D58
.text$mn:00005D58 var_E4          = byte ptr -0E4h
.text$mn:00005D58 var_DD          = byte ptr -0DDh
.text$mn:00005D58 var_D1          = byte ptr -0D1h
.text$mn:00005D58 var_8           = byte ptr -8
.text$mn:00005D58
.text$mn:00005D58                 push    ebp
.text$mn:00005D59                 mov     ebp, esp
.text$mn:00005D5B                 sub     esp, 0E4h
.text$mn:00005D61                 push    ebx
.text$mn:00005D62                 push    esi
.text$mn:00005D63                 push    edi             ; wchar_t *
.text$mn:00005D64                 lea     edi, [ebp+var_E4]
.text$mn:00005D6A                 mov     ecx, 39h ; '9'
.text$mn:00005D6F                 mov     eax, 0CCCCCCCCh
.text$mn:00005D74                 rep stosd
.text$mn:00005D76                 push    offset ??_C@_1BK@JCIKOMDH@?$AAm?$AAe?$AAm?$AAt?$AAr?$AAa?$AAc?$AAe?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; "memtrace.dll"
.text$mn:00005D7B                 call    ?GetAppPath@path@@YAPA_WPB_W@Z ; path::GetAppPath(wchar_t const *)
.text$mn:00005D80                 add     esp, 4
.text$mn:00005D83                 push    eax
.text$mn:00005D84                 lea     ecx, [ebp+var_8]
.text$mn:00005D87                 call    ??0?$ScopedMem@_W@@QAE@PA_W@Z ; ScopedMem<wchar_t>::ScopedMem<wchar_t>(wchar_t *)
.text$mn:00005D8C                 lea     ecx, [ebp+var_8]
.text$mn:00005D8F                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00005D94                 mov     esi, esp
.text$mn:00005D96                 push    eax             ; lpLibFileName
.text$mn:00005D97                 call    dword ptr ds:__imp__LoadLibraryW@4 ; LoadLibraryW(x)
.text$mn:00005D9D                 cmp     esi, esp
.text$mn:00005D9F                 call    __RTC_CheckEsp
.text$mn:00005DA4                 test    eax, eax
.text$mn:00005DA6                 jnz     short loc_5DBF
.text$mn:00005DA8                 mov     [ebp+var_D1], 0
.text$mn:00005DAF                 lea     ecx, [ebp+var_8]
.text$mn:00005DB2                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:00005DB7                 mov     al, [ebp+var_D1]
.text$mn:00005DBD                 jmp     short loc_5DD4
.text$mn:00005DBF ; ---------------------------------------------------------------------------
.text$mn:00005DBF
.text$mn:00005DBF loc_5DBF:                               ; CODE XREF: TryLoadMemTrace(void)+4Ej
.text$mn:00005DBF                 mov     [ebp+var_DD], 1
.text$mn:00005DC6                 lea     ecx, [ebp+var_8]
.text$mn:00005DC9                 call    ??1?$ScopedMem@_W@@QAE@XZ ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)
.text$mn:00005DCE                 mov     al, [ebp+var_DD]
.text$mn:00005DD4
.text$mn:00005DD4 loc_5DD4:                               ; CODE XREF: TryLoadMemTrace(void)+65j
.text$mn:00005DD4                 push    edx
.text$mn:00005DD5                 mov     ecx, ebp
.text$mn:00005DD7                 push    eax
.text$mn:00005DD8                 lea     edx, $LN6_0
.text$mn:00005DDE                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00005DE3                 pop     eax
.text$mn:00005DE4                 pop     edx
.text$mn:00005DE5                 pop     edi
.text$mn:00005DE6                 pop     esi
.text$mn:00005DE7                 pop     ebx
.text$mn:00005DE8                 add     esp, 0E4h
.text$mn:00005DEE                 cmp     ebp, esp
.text$mn:00005DF0                 call    __RTC_CheckEsp
.text$mn:00005DF5                 mov     esp, ebp
.text$mn:00005DF7                 pop     ebp
.text$mn:00005DF8                 retn
.text$mn:00005DF8 ?TryLoadMemTrace@@YA_NXZ endp
.text$mn:00005DF8
.text$mn:00005DF8 ; ---------------------------------------------------------------------------
.text$mn:00005DF9                 align 4
.text$mn:00005DFC $LN6_0          dd 1                    ; DATA XREF: TryLoadMemTrace(void)+80o
.text$mn:00005E00                 dd offset $LN5_0
.text$mn:00005E04 $LN5_0          dd 0FFFFFFF8h, 4        ; DATA XREF: .text$mn:00005E00o
.text$mn:00005E0C                 dd offset $LN4_0        ; "dllPath"
.text$mn:00005E10 $LN4_0          db 'dllPath',0          ; DATA XREF: .text$mn:00005E0Co
.text$mn:00005E10 _text$mn        ends
.text$mn:00005E10
.text$mn:00005E18 ; ===========================================================================
.text$mn:00005E18
.text$mn:00005E18 ; Segment type: Pure code
.text$mn:00005E18 ; Segment permissions: Read/Execute
.text$mn:00005E18 _text$mn        segment para public 'CODE' use32
.text$mn:00005E18                 assume cs:_text$mn
.text$mn:00005E18                 ;org 5E18h
.text$mn:00005E18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E18
.text$mn:00005E18 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E18
.text$mn:00005E18 ; Attributes: bp-based frame
.text$mn:00005E18
.text$mn:00005E18 ; public: void __thiscall FileHistory::UpdateStatesSource(class Vec<struct FileState *> *)
.text$mn:00005E18                 public ?UpdateStatesSource@FileHistory@@QAEXPAV?$Vec@PAUFileState@@@@@Z
.text$mn:00005E18 ?UpdateStatesSource@FileHistory@@QAEXPAV?$Vec@PAUFileState@@@@@Z proc near
.text$mn:00005E18                                         ; CODE XREF: WinMain(x,x,x,x)+B3Ep
.text$mn:00005E18
.text$mn:00005E18 var_CC          = byte ptr -0CCh
.text$mn:00005E18 var_8           = dword ptr -8
.text$mn:00005E18 arg_0           = dword ptr  8
.text$mn:00005E18
.text$mn:00005E18                 push    ebp
.text$mn:00005E19                 mov     ebp, esp
.text$mn:00005E1B                 sub     esp, 0CCh
.text$mn:00005E21                 push    ebx
.text$mn:00005E22                 push    esi
.text$mn:00005E23                 push    edi
.text$mn:00005E24                 push    ecx
.text$mn:00005E25                 lea     edi, [ebp+var_CC]
.text$mn:00005E2B                 mov     ecx, 33h ; '3'
.text$mn:00005E30                 mov     eax, 0CCCCCCCCh
.text$mn:00005E35                 rep stosd
.text$mn:00005E37                 pop     ecx
.text$mn:00005E38                 mov     [ebp+var_8], ecx
.text$mn:00005E3B                 mov     eax, [ebp+var_8]
.text$mn:00005E3E                 mov     ecx, [ebp+arg_0]
.text$mn:00005E41                 mov     [eax], ecx
.text$mn:00005E43                 pop     edi
.text$mn:00005E44                 pop     esi
.text$mn:00005E45                 pop     ebx
.text$mn:00005E46                 mov     esp, ebp
.text$mn:00005E48                 pop     ebp
.text$mn:00005E49                 retn    4
.text$mn:00005E49 ?UpdateStatesSource@FileHistory@@QAEXPAV?$Vec@PAUFileState@@@@@Z endp
.text$mn:00005E49
.text$mn:00005E49 _text$mn        ends
.text$mn:00005E49
.text$mn:00005E4C ; ===========================================================================
.text$mn:00005E4C
.text$mn:00005E4C ; Segment type: Pure code
.text$mn:00005E4C ; Segment permissions: Read/Execute
.text$mn:00005E4C _text$mn        segment para public 'CODE' use32
.text$mn:00005E4C                 assume cs:_text$mn
.text$mn:00005E4C                 ;org 5E4Ch
.text$mn:00005E4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E4C
.text$mn:00005E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00005E4C
.text$mn:00005E4C ; Attributes: bp-based frame
.text$mn:00005E4C
.text$mn:00005E4C ; bool __thiscall ThreadBase::WasCancelRequested(ThreadBase *__hidden this)
.text$mn:00005E4C                 public ?WasCancelRequested@ThreadBase@@IAE_NXZ
.text$mn:00005E4C ?WasCancelRequested@ThreadBase@@IAE_NXZ proc near
.text$mn:00005E4C                                         ; CODE XREF: _lambda_b6f3cb1c717d8c8a816f87295491882e_::operator()(void)+2Cp
.text$mn:00005E4C
.text$mn:00005E4C var_CC          = byte ptr -0CCh
.text$mn:00005E4C var_8           = dword ptr -8
.text$mn:00005E4C
.text$mn:00005E4C                 push    ebp
.text$mn:00005E4D                 mov     ebp, esp
.text$mn:00005E4F                 sub     esp, 0CCh
.text$mn:00005E55                 push    ebx
.text$mn:00005E56                 push    esi
.text$mn:00005E57                 push    edi
.text$mn:00005E58                 push    ecx
.text$mn:00005E59                 lea     edi, [ebp+var_CC]
.text$mn:00005E5F                 mov     ecx, 33h ; '3'
.text$mn:00005E64                 mov     eax, 0CCCCCCCCh
.text$mn:00005E69                 rep stosd
.text$mn:00005E6B                 pop     ecx
.text$mn:00005E6C                 mov     [ebp+var_8], ecx
.text$mn:00005E6F                 mov     eax, [ebp+var_8]
.text$mn:00005E72                 mov     al, [eax+0Ch]
.text$mn:00005E75                 pop     edi
.text$mn:00005E76                 pop     esi
.text$mn:00005E77                 pop     ebx
.text$mn:00005E78                 mov     esp, ebp
.text$mn:00005E7A                 pop     ebp
.text$mn:00005E7B                 retn
.text$mn:00005E7B ?WasCancelRequested@ThreadBase@@IAE_NXZ endp
.text$mn:00005E7B
.text$mn:00005E7B _text$mn        ends
.text$mn:00005E7B
.text$mn:00005E7C ; ===========================================================================
.text$mn:00005E7C
.text$mn:00005E7C ; Segment type: Pure code
.text$mn:00005E7C ; Segment permissions: Read/Execute
.text$mn:00005E7C _text$mn        segment para public 'CODE' use32
.text$mn:00005E7C                 assume cs:_text$mn
.text$mn:00005E7C                 ;org 5E7Ch
.text$mn:00005E7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E7C
.text$mn:00005E7C ; =============== S U B R O U T I N E =======================================
.text$mn:00005E7C
.text$mn:00005E7C ; Attributes: bp-based frame
.text$mn:00005E7C
.text$mn:00005E7C                 public ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ
.text$mn:00005E7C ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ proc near
.text$mn:00005E7C                                         ; CODE XREF: ?_Do_call@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEXXZ+26p
.text$mn:00005E7C                                         ; ?_Move@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEPAV?$_Func_base@X$$V@2@PAX@Z+4Fp
.text$mn:00005E7C
.text$mn:00005E7C var_CC          = byte ptr -0CCh
.text$mn:00005E7C var_8           = dword ptr -8
.text$mn:00005E7C
.text$mn:00005E7C                 push    ebp
.text$mn:00005E7D                 mov     ebp, esp
.text$mn:00005E7F                 sub     esp, 0CCh
.text$mn:00005E85                 push    ebx
.text$mn:00005E86                 push    esi
.text$mn:00005E87                 push    edi
.text$mn:00005E88                 push    ecx
.text$mn:00005E89                 lea     edi, [ebp+var_CC]
.text$mn:00005E8F                 mov     ecx, 33h ; '3'
.text$mn:00005E94                 mov     eax, 0CCCCCCCCh
.text$mn:00005E99                 rep stosd
.text$mn:00005E9B                 pop     ecx
.text$mn:00005E9C                 mov     [ebp+var_8], ecx
.text$mn:00005E9F                 mov     ecx, [ebp+var_8]
.text$mn:00005EA2                 add     ecx, 4
.text$mn:00005EA5                 call    ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAEAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Get_second(void)
.text$mn:00005EAA                 pop     edi
.text$mn:00005EAB                 pop     esi
.text$mn:00005EAC                 pop     ebx
.text$mn:00005EAD                 add     esp, 0CCh
.text$mn:00005EB3                 cmp     ebp, esp
.text$mn:00005EB5                 call    __RTC_CheckEsp
.text$mn:00005EBA                 mov     esp, ebp
.text$mn:00005EBC                 pop     ebp
.text$mn:00005EBD                 retn
.text$mn:00005EBD ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ endp
.text$mn:00005EBD
.text$mn:00005EBD ; ---------------------------------------------------------------------------
.text$mn:00005EBE                 align 10h
.text$mn:00005EBE _text$mn        ends
.text$mn:00005EBE
.text$mn:00005EC0 ; ===========================================================================
.text$mn:00005EC0
.text$mn:00005EC0 ; Segment type: Pure code
.text$mn:00005EC0 ; Segment permissions: Read/Execute
.text$mn:00005EC0 _text$mn        segment para public 'CODE' use32
.text$mn:00005EC0                 assume cs:_text$mn
.text$mn:00005EC0                 ;org 5EC0h
.text$mn:00005EC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EC0
.text$mn:00005EC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EC0
.text$mn:00005EC0 ; Attributes: bp-based frame
.text$mn:00005EC0
.text$mn:00005EC0                 public ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ
.text$mn:00005EC0 ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ proc near
.text$mn:00005EC0                                         ; CODE XREF: ??$_Clone@X@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEPAV?$_Func_base@X$$V@1@PAXU?$integral_constant@_N$0A@@1@@Z+46p
.text$mn:00005EC0                                         ; ?_Get@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEPBXXZ+26p
.text$mn:00005EC0
.text$mn:00005EC0 var_CC          = byte ptr -0CCh
.text$mn:00005EC0 var_8           = dword ptr -8
.text$mn:00005EC0
.text$mn:00005EC0                 push    ebp
.text$mn:00005EC1                 mov     ebp, esp
.text$mn:00005EC3                 sub     esp, 0CCh
.text$mn:00005EC9                 push    ebx
.text$mn:00005ECA                 push    esi
.text$mn:00005ECB                 push    edi
.text$mn:00005ECC                 push    ecx
.text$mn:00005ECD                 lea     edi, [ebp+var_CC]
.text$mn:00005ED3                 mov     ecx, 33h ; '3'
.text$mn:00005ED8                 mov     eax, 0CCCCCCCCh
.text$mn:00005EDD                 rep stosd
.text$mn:00005EDF                 pop     ecx
.text$mn:00005EE0                 mov     [ebp+var_8], ecx
.text$mn:00005EE3                 mov     ecx, [ebp+var_8]
.text$mn:00005EE6                 add     ecx, 4
.text$mn:00005EE9                 call    ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QBEABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Get_second(void)
.text$mn:00005EEE                 pop     edi
.text$mn:00005EEF                 pop     esi
.text$mn:00005EF0                 pop     ebx
.text$mn:00005EF1                 add     esp, 0CCh
.text$mn:00005EF7                 cmp     ebp, esp
.text$mn:00005EF9                 call    __RTC_CheckEsp
.text$mn:00005EFE                 mov     esp, ebp
.text$mn:00005F00                 pop     ebp
.text$mn:00005F01                 retn
.text$mn:00005F01 ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ endp
.text$mn:00005F01
.text$mn:00005F01 ; ---------------------------------------------------------------------------
.text$mn:00005F02                 align 4
.text$mn:00005F02 _text$mn        ends
.text$mn:00005F02
.text$mn:00005F04 ; ===========================================================================
.text$mn:00005F04
.text$mn:00005F04 ; Segment type: Pure code
.text$mn:00005F04 ; Segment permissions: Read/Execute
.text$mn:00005F04 _text$mn        segment para public 'CODE' use32
.text$mn:00005F04                 assume cs:_text$mn
.text$mn:00005F04                 ;org 5F04h
.text$mn:00005F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F04
.text$mn:00005F04 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F04
.text$mn:00005F04 ; Attributes: bp-based frame
.text$mn:00005F04
.text$mn:00005F04                 public ?_Copy@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEPAV?$_Func_base@X$$V@2@PAX@Z
.text$mn:00005F04 ?_Copy@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEPAV?$_Func_base@X$$V@2@PAX@Z proc near
.text$mn:00005F04                                         ; DATA XREF: .rdata:??_7?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@6B@o
.text$mn:00005F04
.text$mn:00005F04 var_E4          = byte ptr -0E4h
.text$mn:00005F04 var_DD          = byte ptr -0DDh
.text$mn:00005F04 var_8           = dword ptr -8
.text$mn:00005F04 arg_0           = dword ptr  8
.text$mn:00005F04
.text$mn:00005F04                 push    ebp
.text$mn:00005F05                 mov     ebp, esp
.text$mn:00005F07                 sub     esp, 0E4h
.text$mn:00005F0D                 push    ebx
.text$mn:00005F0E                 push    esi
.text$mn:00005F0F                 push    edi
.text$mn:00005F10                 push    ecx
.text$mn:00005F11                 lea     edi, [ebp+var_E4]
.text$mn:00005F17                 mov     ecx, 39h ; '9'
.text$mn:00005F1C                 mov     eax, 0CCCCCCCCh
.text$mn:00005F21                 rep stosd
.text$mn:00005F23                 pop     ecx
.text$mn:00005F24                 mov     [ebp+var_8], ecx
.text$mn:00005F27                 movzx   eax, [ebp+var_DD]
.text$mn:00005F2E                 push    eax
.text$mn:00005F2F                 mov     ecx, [ebp+arg_0]
.text$mn:00005F32                 push    ecx
.text$mn:00005F33                 mov     ecx, [ebp+var_8]
.text$mn:00005F36                 call    ??$_Clone@X@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEPAV?$_Func_base@X$$V@1@PAXU?$integral_constant@_N$0A@@1@@Z
.text$mn:00005F3B                 pop     edi
.text$mn:00005F3C                 pop     esi
.text$mn:00005F3D                 pop     ebx
.text$mn:00005F3E                 add     esp, 0E4h
.text$mn:00005F44                 cmp     ebp, esp
.text$mn:00005F46                 call    __RTC_CheckEsp
.text$mn:00005F4B                 mov     esp, ebp
.text$mn:00005F4D                 pop     ebp
.text$mn:00005F4E                 retn    4
.text$mn:00005F4E ?_Copy@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEPAV?$_Func_base@X$$V@2@PAX@Z endp
.text$mn:00005F4E
.text$mn:00005F4E ; ---------------------------------------------------------------------------
.text$mn:00005F51                 align 4
.text$mn:00005F51 _text$mn        ends
.text$mn:00005F51
.text$mn:00005F54 ; ===========================================================================
.text$mn:00005F54
.text$mn:00005F54 ; Segment type: Pure code
.text$mn:00005F54 ; Segment permissions: Read/Execute
.text$mn:00005F54 _text$mn        segment para public 'CODE' use32
.text$mn:00005F54                 assume cs:_text$mn
.text$mn:00005F54                 ;org 5F54h
.text$mn:00005F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F54
.text$mn:00005F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F54
.text$mn:00005F54 ; Attributes: bp-based frame
.text$mn:00005F54
.text$mn:00005F54                 public ?_Delete_this@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEX_N@Z
.text$mn:00005F54 ?_Delete_this@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEX_N@Z proc near
.text$mn:00005F54                                         ; DATA XREF: .rdata:0000796Co
.text$mn:00005F54
.text$mn:00005F54 var_D8          = byte ptr -0D8h
.text$mn:00005F54 var_11          = byte ptr -11h
.text$mn:00005F54 var_8           = dword ptr -8
.text$mn:00005F54 arg_0           = byte ptr  8
.text$mn:00005F54
.text$mn:00005F54                 push    ebp
.text$mn:00005F55                 mov     ebp, esp
.text$mn:00005F57                 sub     esp, 0D8h
.text$mn:00005F5D                 push    ebx
.text$mn:00005F5E                 push    esi
.text$mn:00005F5F                 push    edi
.text$mn:00005F60                 push    ecx
.text$mn:00005F61                 lea     edi, [ebp+var_D8]
.text$mn:00005F67                 mov     ecx, 36h ; '6'
.text$mn:00005F6C                 mov     eax, 0CCCCCCCCh
.text$mn:00005F71                 rep stosd
.text$mn:00005F73                 pop     ecx
.text$mn:00005F74                 mov     [ebp+var_8], ecx
.text$mn:00005F77                 mov     ecx, [ebp+var_8]
.text$mn:00005F7A                 call    ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV?$allocator@H@2@XZ
.text$mn:00005F7F                 push    eax
.text$mn:00005F80                 lea     ecx, [ebp+var_11]
.text$mn:00005F83                 call    ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@AAV?$allocator@H@1@@Z
.text$mn:00005F88                 mov     eax, [ebp+var_8]
.text$mn:00005F8B                 push    eax
.text$mn:00005F8C                 lea     ecx, [ebp+var_11]
.text$mn:00005F8F                 call    ??$destroy@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@@Z
.text$mn:00005F94                 movzx   eax, [ebp+arg_0]
.text$mn:00005F98                 test    eax, eax
.text$mn:00005F9A                 jz      short loc_5FAA
.text$mn:00005F9C                 push    1               ; int
.text$mn:00005F9E                 mov     eax, [ebp+var_8]
.text$mn:00005FA1                 push    eax             ; void *
.text$mn:00005FA2                 lea     ecx, [ebp+var_11]
.text$mn:00005FA5                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@2@I@Z
.text$mn:00005FAA
.text$mn:00005FAA loc_5FAA:                               ; CODE XREF: ?_Delete_this@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEX_N@Z+46j
.text$mn:00005FAA                 push    edx
.text$mn:00005FAB                 mov     ecx, ebp
.text$mn:00005FAD                 push    eax
.text$mn:00005FAE                 lea     edx, $LN6_3
.text$mn:00005FB4                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00005FB9                 pop     eax
.text$mn:00005FBA                 pop     edx
.text$mn:00005FBB                 pop     edi
.text$mn:00005FBC                 pop     esi
.text$mn:00005FBD                 pop     ebx
.text$mn:00005FBE                 add     esp, 0D8h
.text$mn:00005FC4                 cmp     ebp, esp
.text$mn:00005FC6                 call    __RTC_CheckEsp
.text$mn:00005FCB                 mov     esp, ebp
.text$mn:00005FCD                 pop     ebp
.text$mn:00005FCE                 retn    4
.text$mn:00005FCE ?_Delete_this@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEX_N@Z endp
.text$mn:00005FCE
.text$mn:00005FCE ; ---------------------------------------------------------------------------
.text$mn:00005FD1                 align 4
.text$mn:00005FD4 $LN6_3          dd 1                    ; DATA XREF: ?_Delete_this@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEX_N@Z+5Ao
.text$mn:00005FD8                 dd offset $LN5_5
.text$mn:00005FDC $LN5_5          dd 0FFFFFFEFh, 1        ; DATA XREF: .text$mn:00005FD8o
.text$mn:00005FE4                 dd offset $LN4_4
.text$mn:00005FE8 $LN4_4          dd 6C415Fh              ; DATA XREF: .text$mn:00005FE4o
.text$mn:00005FE8 _text$mn        ends
.text$mn:00005FE8
.text$mn:00005FEC ; ===========================================================================
.text$mn:00005FEC
.text$mn:00005FEC ; Segment type: Pure code
.text$mn:00005FEC ; Segment permissions: Read/Execute
.text$mn:00005FEC _text$mn        segment para public 'CODE' use32
.text$mn:00005FEC                 assume cs:_text$mn
.text$mn:00005FEC                 ;org 5FECh
.text$mn:00005FEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FEC
.text$mn:00005FEC ; =============== S U B R O U T I N E =======================================
.text$mn:00005FEC
.text$mn:00005FEC ; Attributes: bp-based frame
.text$mn:00005FEC
.text$mn:00005FEC                 public ?_Do_call@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEXXZ
.text$mn:00005FEC ?_Do_call@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEXXZ proc near
.text$mn:00005FEC                                         ; DATA XREF: .rdata:00007964o
.text$mn:00005FEC
.text$mn:00005FEC var_D8          = byte ptr -0D8h
.text$mn:00005FEC var_D1          = byte ptr -0D1h
.text$mn:00005FEC var_8           = dword ptr -8
.text$mn:00005FEC
.text$mn:00005FEC                 push    ebp
.text$mn:00005FED                 mov     ebp, esp
.text$mn:00005FEF                 sub     esp, 0D8h
.text$mn:00005FF5                 push    ebx
.text$mn:00005FF6                 push    esi
.text$mn:00005FF7                 push    edi
.text$mn:00005FF8                 push    ecx
.text$mn:00005FF9                 lea     edi, [ebp+var_D8]
.text$mn:00005FFF                 mov     ecx, 36h ; '6'
.text$mn:00006004                 mov     eax, 0CCCCCCCCh
.text$mn:00006009                 rep stosd
.text$mn:0000600B                 pop     ecx
.text$mn:0000600C                 mov     [ebp+var_8], ecx
.text$mn:0000600F                 mov     ecx, [ebp+var_8]
.text$mn:00006012                 call    ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ
.text$mn:00006017                 push    eax
.text$mn:00006018                 movzx   eax, [ebp+var_D1]
.text$mn:0000601F                 push    eax
.text$mn:00006020                 call    ??$_Invoke_ret@XAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAXU?$_Forced@X$00@0@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@Z ; std::_Invoke_ret<void,_lambda_b6f3cb1c717d8c8a816f87295491882e_ &>(std::_Forced<void,1>,_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00006025                 add     esp, 8
.text$mn:00006028                 pop     edi
.text$mn:00006029                 pop     esi
.text$mn:0000602A                 pop     ebx
.text$mn:0000602B                 add     esp, 0D8h
.text$mn:00006031                 cmp     ebp, esp
.text$mn:00006033                 call    __RTC_CheckEsp
.text$mn:00006038                 mov     esp, ebp
.text$mn:0000603A                 pop     ebp
.text$mn:0000603B                 retn
.text$mn:0000603B ?_Do_call@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEXXZ endp
.text$mn:0000603B
.text$mn:0000603B _text$mn        ends
.text$mn:0000603B
.text$mn:0000603C ; ===========================================================================
.text$mn:0000603C
.text$mn:0000603C ; Segment type: Pure code
.text$mn:0000603C ; Segment permissions: Read/Execute
.text$mn:0000603C _text$mn        segment para public 'CODE' use32
.text$mn:0000603C                 assume cs:_text$mn
.text$mn:0000603C                 ;org 603Ch
.text$mn:0000603C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000603C
.text$mn:0000603C ; =============== S U B R O U T I N E =======================================
.text$mn:0000603C
.text$mn:0000603C ; Attributes: bp-based frame
.text$mn:0000603C
.text$mn:0000603C                 public ?_Empty@?$_Func_class@X$$V@std@@IBE_NXZ
.text$mn:0000603C ?_Empty@?$_Func_class@X$$V@std@@IBE_NXZ proc near
.text$mn:0000603C                                         ; CODE XREF: ?_Tidy@?$_Func_class@X$$V@std@@IAEXXZ+26p
.text$mn:0000603C
.text$mn:0000603C var_D0          = dword ptr -0D0h
.text$mn:0000603C var_8           = dword ptr -8
.text$mn:0000603C
.text$mn:0000603C                 push    ebp
.text$mn:0000603D                 mov     ebp, esp
.text$mn:0000603F                 sub     esp, 0D0h
.text$mn:00006045                 push    ebx
.text$mn:00006046                 push    esi
.text$mn:00006047                 push    edi
.text$mn:00006048                 push    ecx
.text$mn:00006049                 lea     edi, [ebp+var_D0]
.text$mn:0000604F                 mov     ecx, 34h ; '4'
.text$mn:00006054                 mov     eax, 0CCCCCCCCh
.text$mn:00006059                 rep stosd
.text$mn:0000605B                 pop     ecx
.text$mn:0000605C                 mov     [ebp+var_8], ecx
.text$mn:0000605F                 mov     ecx, [ebp+var_8]
.text$mn:00006062                 call    ?_Getimpl@?$_Func_class@X$$V@std@@ABEPAV?$_Func_base@X$$V@2@XZ
.text$mn:00006067                 test    eax, eax
.text$mn:00006069                 jnz     short loc_6077
.text$mn:0000606B                 mov     [ebp+var_D0], 1
.text$mn:00006075                 jmp     short loc_6081
.text$mn:00006077 ; ---------------------------------------------------------------------------
.text$mn:00006077
.text$mn:00006077 loc_6077:                               ; CODE XREF: ?_Empty@?$_Func_class@X$$V@std@@IBE_NXZ+2Dj
.text$mn:00006077                 mov     [ebp+var_D0], 0
.text$mn:00006081
.text$mn:00006081 loc_6081:                               ; CODE XREF: ?_Empty@?$_Func_class@X$$V@std@@IBE_NXZ+39j
.text$mn:00006081                 mov     al, byte ptr [ebp+var_D0]
.text$mn:00006087                 pop     edi
.text$mn:00006088                 pop     esi
.text$mn:00006089                 pop     ebx
.text$mn:0000608A                 add     esp, 0D0h
.text$mn:00006090                 cmp     ebp, esp
.text$mn:00006092                 call    __RTC_CheckEsp
.text$mn:00006097                 mov     esp, ebp
.text$mn:00006099                 pop     ebp
.text$mn:0000609A                 retn
.text$mn:0000609A ?_Empty@?$_Func_class@X$$V@std@@IBE_NXZ endp
.text$mn:0000609A
.text$mn:0000609A ; ---------------------------------------------------------------------------
.text$mn:0000609B                 align 4
.text$mn:0000609B _text$mn        ends
.text$mn:0000609B
.text$mn:0000609C ; ===========================================================================
.text$mn:0000609C
.text$mn:0000609C ; Segment type: Pure code
.text$mn:0000609C ; Segment permissions: Read/Execute
.text$mn:0000609C _text$mn        segment para public 'CODE' use32
.text$mn:0000609C                 assume cs:_text$mn
.text$mn:0000609C                 ;org 609Ch
.text$mn:0000609C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000609C
.text$mn:0000609C ; =============== S U B R O U T I N E =======================================
.text$mn:0000609C
.text$mn:0000609C ; Attributes: bp-based frame
.text$mn:0000609C
.text$mn:0000609C                 public ?_Get@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEPBXXZ
.text$mn:0000609C ?_Get@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEPBXXZ proc near
.text$mn:0000609C                                         ; DATA XREF: .rdata:00007970o
.text$mn:0000609C
.text$mn:0000609C var_CC          = byte ptr -0CCh
.text$mn:0000609C var_8           = dword ptr -8
.text$mn:0000609C
.text$mn:0000609C                 push    ebp
.text$mn:0000609D                 mov     ebp, esp
.text$mn:0000609F                 sub     esp, 0CCh
.text$mn:000060A5                 push    ebx
.text$mn:000060A6                 push    esi
.text$mn:000060A7                 push    edi
.text$mn:000060A8                 push    ecx
.text$mn:000060A9                 lea     edi, [ebp+var_CC]
.text$mn:000060AF                 mov     ecx, 33h ; '3'
.text$mn:000060B4                 mov     eax, 0CCCCCCCCh
.text$mn:000060B9                 rep stosd
.text$mn:000060BB                 pop     ecx
.text$mn:000060BC                 mov     [ebp+var_8], ecx
.text$mn:000060BF                 mov     ecx, [ebp+var_8]
.text$mn:000060C2                 call    ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ
.text$mn:000060C7                 push    eax
.text$mn:000060C8                 call    ??$addressof@$$CBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YAPBV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV1@@Z ; std::addressof<_lambda_b6f3cb1c717d8c8a816f87295491882e_ const>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)
.text$mn:000060CD                 add     esp, 4
.text$mn:000060D0                 pop     edi
.text$mn:000060D1                 pop     esi
.text$mn:000060D2                 pop     ebx
.text$mn:000060D3                 add     esp, 0CCh
.text$mn:000060D9                 cmp     ebp, esp
.text$mn:000060DB                 call    __RTC_CheckEsp
.text$mn:000060E0                 mov     esp, ebp
.text$mn:000060E2                 pop     ebp
.text$mn:000060E3                 retn
.text$mn:000060E3 ?_Get@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEPBXXZ endp
.text$mn:000060E3
.text$mn:000060E3 _text$mn        ends
.text$mn:000060E3
.text$mn:000060E4 ; ===========================================================================
.text$mn:000060E4
.text$mn:000060E4 ; Segment type: Pure code
.text$mn:000060E4 ; Segment permissions: Read/Execute
.text$mn:000060E4 _text$mn        segment para public 'CODE' use32
.text$mn:000060E4                 assume cs:_text$mn
.text$mn:000060E4                 ;org 60E4h
.text$mn:000060E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060E4
.text$mn:000060E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000060E4
.text$mn:000060E4 ; Attributes: bp-based frame
.text$mn:000060E4
.text$mn:000060E4 ; public: class std::allocator<int> & __thiscall std::_Compressed_pair<class std::allocator<int>, class _lambda_b6f3cb1c717d8c8a816f87295491882e_, 1>::_Get_first(void)
.text$mn:000060E4                 public ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAEAAV?$allocator@H@2@XZ
.text$mn:000060E4 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAEAAV?$allocator@H@2@XZ proc near
.text$mn:000060E4                                         ; CODE XREF: ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV?$allocator@H@2@XZ+29p
.text$mn:000060E4
.text$mn:000060E4 var_CC          = byte ptr -0CCh
.text$mn:000060E4 var_8           = dword ptr -8
.text$mn:000060E4
.text$mn:000060E4                 push    ebp
.text$mn:000060E5                 mov     ebp, esp
.text$mn:000060E7                 sub     esp, 0CCh
.text$mn:000060ED                 push    ebx
.text$mn:000060EE                 push    esi
.text$mn:000060EF                 push    edi
.text$mn:000060F0                 push    ecx
.text$mn:000060F1                 lea     edi, [ebp+var_CC]
.text$mn:000060F7                 mov     ecx, 33h ; '3'
.text$mn:000060FC                 mov     eax, 0CCCCCCCCh
.text$mn:00006101                 rep stosd
.text$mn:00006103                 pop     ecx
.text$mn:00006104                 mov     [ebp+var_8], ecx
.text$mn:00006107                 mov     eax, [ebp+var_8]
.text$mn:0000610A                 pop     edi
.text$mn:0000610B                 pop     esi
.text$mn:0000610C                 pop     ebx
.text$mn:0000610D                 mov     esp, ebp
.text$mn:0000610F                 pop     ebp
.text$mn:00006110                 retn
.text$mn:00006110 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAEAAV?$allocator@H@2@XZ endp
.text$mn:00006110
.text$mn:00006110 ; ---------------------------------------------------------------------------
.text$mn:00006111                 align 4
.text$mn:00006111 _text$mn        ends
.text$mn:00006111
.text$mn:00006114 ; ===========================================================================
.text$mn:00006114
.text$mn:00006114 ; Segment type: Pure code
.text$mn:00006114 ; Segment permissions: Read/Execute
.text$mn:00006114 _text$mn        segment para public 'CODE' use32
.text$mn:00006114                 assume cs:_text$mn
.text$mn:00006114                 ;org 6114h
.text$mn:00006114                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006114
.text$mn:00006114 ; =============== S U B R O U T I N E =======================================
.text$mn:00006114
.text$mn:00006114 ; Attributes: bp-based frame
.text$mn:00006114
.text$mn:00006114 ; public: class std::allocator<int> const & __thiscall std::_Compressed_pair<class std::allocator<int>, class _lambda_b6f3cb1c717d8c8a816f87295491882e_, 1>::_Get_first(void)const
.text$mn:00006114                 public ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QBEABV?$allocator@H@2@XZ
.text$mn:00006114 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QBEABV?$allocator@H@2@XZ proc near
.text$mn:00006114                                         ; CODE XREF: ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV?$allocator@H@2@XZ+29p
.text$mn:00006114
.text$mn:00006114 var_CC          = byte ptr -0CCh
.text$mn:00006114 var_8           = dword ptr -8
.text$mn:00006114
.text$mn:00006114                 push    ebp
.text$mn:00006115                 mov     ebp, esp
.text$mn:00006117                 sub     esp, 0CCh
.text$mn:0000611D                 push    ebx
.text$mn:0000611E                 push    esi
.text$mn:0000611F                 push    edi
.text$mn:00006120                 push    ecx
.text$mn:00006121                 lea     edi, [ebp+var_CC]
.text$mn:00006127                 mov     ecx, 33h ; '3'
.text$mn:0000612C                 mov     eax, 0CCCCCCCCh
.text$mn:00006131                 rep stosd
.text$mn:00006133                 pop     ecx
.text$mn:00006134                 mov     [ebp+var_8], ecx
.text$mn:00006137                 mov     eax, [ebp+var_8]
.text$mn:0000613A                 pop     edi
.text$mn:0000613B                 pop     esi
.text$mn:0000613C                 pop     ebx
.text$mn:0000613D                 mov     esp, ebp
.text$mn:0000613F                 pop     ebp
.text$mn:00006140                 retn
.text$mn:00006140 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QBEABV?$allocator@H@2@XZ endp
.text$mn:00006140
.text$mn:00006140 ; ---------------------------------------------------------------------------
.text$mn:00006141                 align 4
.text$mn:00006141 _text$mn        ends
.text$mn:00006141
.text$mn:00006144 ; ===========================================================================
.text$mn:00006144
.text$mn:00006144 ; Segment type: Pure code
.text$mn:00006144 ; Segment permissions: Read/Execute
.text$mn:00006144 _text$mn        segment para public 'CODE' use32
.text$mn:00006144                 assume cs:_text$mn
.text$mn:00006144                 ;org 6144h
.text$mn:00006144                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006144
.text$mn:00006144 ; =============== S U B R O U T I N E =======================================
.text$mn:00006144
.text$mn:00006144 ; Attributes: bp-based frame
.text$mn:00006144
.text$mn:00006144 ; public: class _lambda_b6f3cb1c717d8c8a816f87295491882e_ & __thiscall std::_Compressed_pair<class std::allocator<int>, class _lambda_b6f3cb1c717d8c8a816f87295491882e_, 1>::_Get_second(void)
.text$mn:00006144                 public ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAEAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ
.text$mn:00006144 ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAEAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ proc near
.text$mn:00006144                                         ; CODE XREF: ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ+29p
.text$mn:00006144
.text$mn:00006144 var_CC          = byte ptr -0CCh
.text$mn:00006144 var_8           = dword ptr -8
.text$mn:00006144
.text$mn:00006144                 push    ebp
.text$mn:00006145                 mov     ebp, esp
.text$mn:00006147                 sub     esp, 0CCh
.text$mn:0000614D                 push    ebx
.text$mn:0000614E                 push    esi
.text$mn:0000614F                 push    edi
.text$mn:00006150                 push    ecx
.text$mn:00006151                 lea     edi, [ebp+var_CC]
.text$mn:00006157                 mov     ecx, 33h ; '3'
.text$mn:0000615C                 mov     eax, 0CCCCCCCCh
.text$mn:00006161                 rep stosd
.text$mn:00006163                 pop     ecx
.text$mn:00006164                 mov     [ebp+var_8], ecx
.text$mn:00006167                 mov     eax, [ebp+var_8]
.text$mn:0000616A                 pop     edi
.text$mn:0000616B                 pop     esi
.text$mn:0000616C                 pop     ebx
.text$mn:0000616D                 mov     esp, ebp
.text$mn:0000616F                 pop     ebp
.text$mn:00006170                 retn
.text$mn:00006170 ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAEAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ endp
.text$mn:00006170
.text$mn:00006170 ; ---------------------------------------------------------------------------
.text$mn:00006171                 align 4
.text$mn:00006171 _text$mn        ends
.text$mn:00006171
.text$mn:00006174 ; ===========================================================================
.text$mn:00006174
.text$mn:00006174 ; Segment type: Pure code
.text$mn:00006174 ; Segment permissions: Read/Execute
.text$mn:00006174 _text$mn        segment para public 'CODE' use32
.text$mn:00006174                 assume cs:_text$mn
.text$mn:00006174                 ;org 6174h
.text$mn:00006174                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006174
.text$mn:00006174 ; =============== S U B R O U T I N E =======================================
.text$mn:00006174
.text$mn:00006174 ; Attributes: bp-based frame
.text$mn:00006174
.text$mn:00006174 ; public: class _lambda_b6f3cb1c717d8c8a816f87295491882e_ const & __thiscall std::_Compressed_pair<class std::allocator<int>, class _lambda_b6f3cb1c717d8c8a816f87295491882e_, 1>::_Get_second(void)const
.text$mn:00006174                 public ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QBEABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ
.text$mn:00006174 ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QBEABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ proc near
.text$mn:00006174                                         ; CODE XREF: ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ+29p
.text$mn:00006174
.text$mn:00006174 var_CC          = byte ptr -0CCh
.text$mn:00006174 var_8           = dword ptr -8
.text$mn:00006174
.text$mn:00006174                 push    ebp
.text$mn:00006175                 mov     ebp, esp
.text$mn:00006177                 sub     esp, 0CCh
.text$mn:0000617D                 push    ebx
.text$mn:0000617E                 push    esi
.text$mn:0000617F                 push    edi
.text$mn:00006180                 push    ecx
.text$mn:00006181                 lea     edi, [ebp+var_CC]
.text$mn:00006187                 mov     ecx, 33h ; '3'
.text$mn:0000618C                 mov     eax, 0CCCCCCCCh
.text$mn:00006191                 rep stosd
.text$mn:00006193                 pop     ecx
.text$mn:00006194                 mov     [ebp+var_8], ecx
.text$mn:00006197                 mov     eax, [ebp+var_8]
.text$mn:0000619A                 pop     edi
.text$mn:0000619B                 pop     esi
.text$mn:0000619C                 pop     ebx
.text$mn:0000619D                 mov     esp, ebp
.text$mn:0000619F                 pop     ebp
.text$mn:000061A0                 retn
.text$mn:000061A0 ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QBEABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ endp
.text$mn:000061A0
.text$mn:000061A0 ; ---------------------------------------------------------------------------
.text$mn:000061A1                 align 4
.text$mn:000061A1 _text$mn        ends
.text$mn:000061A1
.text$mn:000061A4 ; ===========================================================================
.text$mn:000061A4
.text$mn:000061A4 ; Segment type: Pure code
.text$mn:000061A4 ; Segment permissions: Read/Execute
.text$mn:000061A4 _text$mn        segment para public 'CODE' use32
.text$mn:000061A4                 assume cs:_text$mn
.text$mn:000061A4                 ;org 61A4h
.text$mn:000061A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000061A4
.text$mn:000061A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000061A4
.text$mn:000061A4 ; Attributes: bp-based frame
.text$mn:000061A4
.text$mn:000061A4                 public ?_Getimpl@?$_Func_class@X$$V@std@@ABEPAV?$_Func_base@X$$V@2@XZ
.text$mn:000061A4 ?_Getimpl@?$_Func_class@X$$V@std@@ABEPAV?$_Func_base@X$$V@2@XZ proc near
.text$mn:000061A4                                         ; CODE XREF: ?_Empty@?$_Func_class@X$$V@std@@IBE_NXZ+26p
.text$mn:000061A4                                         ; ?_Local@?$_Func_class@X$$V@std@@ABE_NXZ+26p ...
.text$mn:000061A4
.text$mn:000061A4 var_CC          = byte ptr -0CCh
.text$mn:000061A4 var_8           = dword ptr -8
.text$mn:000061A4
.text$mn:000061A4                 push    ebp
.text$mn:000061A5                 mov     ebp, esp
.text$mn:000061A7                 sub     esp, 0CCh
.text$mn:000061AD                 push    ebx
.text$mn:000061AE                 push    esi
.text$mn:000061AF                 push    edi
.text$mn:000061B0                 push    ecx
.text$mn:000061B1                 lea     edi, [ebp+var_CC]
.text$mn:000061B7                 mov     ecx, 33h ; '3'
.text$mn:000061BC                 mov     eax, 0CCCCCCCCh
.text$mn:000061C1                 rep stosd
.text$mn:000061C3                 pop     ecx
.text$mn:000061C4                 mov     [ebp+var_8], ecx
.text$mn:000061C7                 mov     eax, 4
.text$mn:000061CC                 imul    ecx, eax, 9
.text$mn:000061CF                 mov     edx, [ebp+var_8]
.text$mn:000061D2                 mov     eax, [edx+ecx]
.text$mn:000061D5                 pop     edi
.text$mn:000061D6                 pop     esi
.text$mn:000061D7                 pop     ebx
.text$mn:000061D8                 mov     esp, ebp
.text$mn:000061DA                 pop     ebp
.text$mn:000061DB                 retn
.text$mn:000061DB ?_Getimpl@?$_Func_class@X$$V@std@@ABEPAV?$_Func_base@X$$V@2@XZ endp
.text$mn:000061DB
.text$mn:000061DB _text$mn        ends
.text$mn:000061DB
.text$mn:000061DC ; ===========================================================================
.text$mn:000061DC
.text$mn:000061DC ; Segment type: Pure code
.text$mn:000061DC ; Segment permissions: Read/Execute
.text$mn:000061DC _text$mn        segment para public 'CODE' use32
.text$mn:000061DC                 assume cs:_text$mn
.text$mn:000061DC                 ;org 61DCh
.text$mn:000061DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000061DC
.text$mn:000061DC ; =============== S U B R O U T I N E =======================================
.text$mn:000061DC
.text$mn:000061DC ; Attributes: bp-based frame
.text$mn:000061DC
.text$mn:000061DC                 public ?_Getspace@?$_Func_class@X$$V@std@@AAEPAXXZ
.text$mn:000061DC ?_Getspace@?$_Func_class@X$$V@std@@AAEPAXXZ proc near
.text$mn:000061DC                                         ; CODE XREF: ??$_Reset_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@3@U?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@3@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@AAU?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@1@U?$integral_constant@_N$0A@@1@@Z+26p
.text$mn:000061DC
.text$mn:000061DC var_CC          = byte ptr -0CCh
.text$mn:000061DC var_8           = dword ptr -8
.text$mn:000061DC
.text$mn:000061DC                 push    ebp
.text$mn:000061DD                 mov     ebp, esp
.text$mn:000061DF                 sub     esp, 0CCh
.text$mn:000061E5                 push    ebx
.text$mn:000061E6                 push    esi
.text$mn:000061E7                 push    edi
.text$mn:000061E8                 push    ecx
.text$mn:000061E9                 lea     edi, [ebp+var_CC]
.text$mn:000061EF                 mov     ecx, 33h ; '3'
.text$mn:000061F4                 mov     eax, 0CCCCCCCCh
.text$mn:000061F9                 rep stosd
.text$mn:000061FB                 pop     ecx
.text$mn:000061FC                 mov     [ebp+var_8], ecx
.text$mn:000061FF                 mov     eax, [ebp+var_8]
.text$mn:00006202                 pop     edi
.text$mn:00006203                 pop     esi
.text$mn:00006204                 pop     ebx
.text$mn:00006205                 mov     esp, ebp
.text$mn:00006207                 pop     ebp
.text$mn:00006208                 retn
.text$mn:00006208 ?_Getspace@?$_Func_class@X$$V@std@@AAEPAXXZ endp
.text$mn:00006208
.text$mn:00006208 ; ---------------------------------------------------------------------------
.text$mn:00006209                 align 4
.text$mn:00006209 _text$mn        ends
.text$mn:00006209
.text$mn:0000620C ; ===========================================================================
.text$mn:0000620C
.text$mn:0000620C ; Segment type: Pure code
.text$mn:0000620C ; Segment permissions: Read/Execute
.text$mn:0000620C _text$mn        segment para public 'CODE' use32
.text$mn:0000620C                 assume cs:_text$mn
.text$mn:0000620C                 ;org 620Ch
.text$mn:0000620C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000620C
.text$mn:0000620C ; =============== S U B R O U T I N E =======================================
.text$mn:0000620C
.text$mn:0000620C ; Attributes: bp-based frame
.text$mn:0000620C
.text$mn:0000620C                 public ?_Getspace@?$_Func_class@X$$V@std@@ABEPBXXZ
.text$mn:0000620C ?_Getspace@?$_Func_class@X$$V@std@@ABEPBXXZ proc near
.text$mn:0000620C                                         ; CODE XREF: ?_Local@?$_Func_class@X$$V@std@@ABE_NXZ+30p
.text$mn:0000620C
.text$mn:0000620C var_CC          = byte ptr -0CCh
.text$mn:0000620C var_8           = dword ptr -8
.text$mn:0000620C
.text$mn:0000620C                 push    ebp
.text$mn:0000620D                 mov     ebp, esp
.text$mn:0000620F                 sub     esp, 0CCh
.text$mn:00006215                 push    ebx
.text$mn:00006216                 push    esi
.text$mn:00006217                 push    edi
.text$mn:00006218                 push    ecx
.text$mn:00006219                 lea     edi, [ebp+var_CC]
.text$mn:0000621F                 mov     ecx, 33h ; '3'
.text$mn:00006224                 mov     eax, 0CCCCCCCCh
.text$mn:00006229                 rep stosd
.text$mn:0000622B                 pop     ecx
.text$mn:0000622C                 mov     [ebp+var_8], ecx
.text$mn:0000622F                 mov     eax, [ebp+var_8]
.text$mn:00006232                 pop     edi
.text$mn:00006233                 pop     esi
.text$mn:00006234                 pop     ebx
.text$mn:00006235                 mov     esp, ebp
.text$mn:00006237                 pop     ebp
.text$mn:00006238                 retn
.text$mn:00006238 ?_Getspace@?$_Func_class@X$$V@std@@ABEPBXXZ endp
.text$mn:00006238
.text$mn:00006238 ; ---------------------------------------------------------------------------
.text$mn:00006239                 align 4
.text$mn:00006239 _text$mn        ends
.text$mn:00006239
.text$mn:0000623C ; ===========================================================================
.text$mn:0000623C
.text$mn:0000623C ; Segment type: Pure code
.text$mn:0000623C ; Segment permissions: Read/Execute
.text$mn:0000623C _text$mn        segment para public 'CODE' use32
.text$mn:0000623C                 assume cs:_text$mn
.text$mn:0000623C                 ;org 623Ch
.text$mn:0000623C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000623C
.text$mn:0000623C ; =============== S U B R O U T I N E =======================================
.text$mn:0000623C
.text$mn:0000623C ; Attributes: bp-based frame
.text$mn:0000623C
.text$mn:0000623C                 public ?_Local@?$_Func_class@X$$V@std@@ABE_NXZ
.text$mn:0000623C ?_Local@?$_Func_class@X$$V@std@@ABE_NXZ proc near
.text$mn:0000623C                                         ; CODE XREF: ?_Tidy@?$_Func_class@X$$V@std@@IAEXXZ+35p
.text$mn:0000623C
.text$mn:0000623C var_D0          = dword ptr -0D0h
.text$mn:0000623C var_8           = dword ptr -8
.text$mn:0000623C
.text$mn:0000623C                 push    ebp
.text$mn:0000623D                 mov     ebp, esp
.text$mn:0000623F                 sub     esp, 0D0h
.text$mn:00006245                 push    ebx
.text$mn:00006246                 push    esi
.text$mn:00006247                 push    edi
.text$mn:00006248                 push    ecx
.text$mn:00006249                 lea     edi, [ebp+var_D0]
.text$mn:0000624F                 mov     ecx, 34h ; '4'
.text$mn:00006254                 mov     eax, 0CCCCCCCCh
.text$mn:00006259                 rep stosd
.text$mn:0000625B                 pop     ecx
.text$mn:0000625C                 mov     [ebp+var_8], ecx
.text$mn:0000625F                 mov     ecx, [ebp+var_8]
.text$mn:00006262                 call    ?_Getimpl@?$_Func_class@X$$V@std@@ABEPAV?$_Func_base@X$$V@2@XZ
.text$mn:00006267                 mov     esi, eax
.text$mn:00006269                 mov     ecx, [ebp+var_8]
.text$mn:0000626C                 call    ?_Getspace@?$_Func_class@X$$V@std@@ABEPBXXZ
.text$mn:00006271                 cmp     esi, eax
.text$mn:00006273                 jnz     short loc_6281
.text$mn:00006275                 mov     [ebp+var_D0], 1
.text$mn:0000627F                 jmp     short loc_628B
.text$mn:00006281 ; ---------------------------------------------------------------------------
.text$mn:00006281
.text$mn:00006281 loc_6281:                               ; CODE XREF: ?_Local@?$_Func_class@X$$V@std@@ABE_NXZ+37j
.text$mn:00006281                 mov     [ebp+var_D0], 0
.text$mn:0000628B
.text$mn:0000628B loc_628B:                               ; CODE XREF: ?_Local@?$_Func_class@X$$V@std@@ABE_NXZ+43j
.text$mn:0000628B                 mov     al, byte ptr [ebp+var_D0]
.text$mn:00006291                 pop     edi
.text$mn:00006292                 pop     esi
.text$mn:00006293                 pop     ebx
.text$mn:00006294                 add     esp, 0D0h
.text$mn:0000629A                 cmp     ebp, esp
.text$mn:0000629C                 call    __RTC_CheckEsp
.text$mn:000062A1                 mov     esp, ebp
.text$mn:000062A3                 pop     ebp
.text$mn:000062A4                 retn
.text$mn:000062A4 ?_Local@?$_Func_class@X$$V@std@@ABE_NXZ endp
.text$mn:000062A4
.text$mn:000062A4 ; ---------------------------------------------------------------------------
.text$mn:000062A5                 align 4
.text$mn:000062A5 _text$mn        ends
.text$mn:000062A5
.text$mn:000062A8 ; ===========================================================================
.text$mn:000062A8
.text$mn:000062A8 ; Segment type: Pure code
.text$mn:000062A8 ; Segment permissions: Read/Execute
.text$mn:000062A8 _text$mn        segment para public 'CODE' use32
.text$mn:000062A8                 assume cs:_text$mn
.text$mn:000062A8                 ;org 62A8h
.text$mn:000062A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000062A8
.text$mn:000062A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000062A8
.text$mn:000062A8 ; Attributes: bp-based frame
.text$mn:000062A8
.text$mn:000062A8                 public ?_Move@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEPAV?$_Func_base@X$$V@2@PAX@Z
.text$mn:000062A8 ?_Move@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEPAV?$_Func_base@X$$V@2@PAX@Z proc near
.text$mn:000062A8                                         ; DATA XREF: .rdata:00007960o
.text$mn:000062A8
.text$mn:000062A8 var_E4          = byte ptr -0E4h
.text$mn:000062A8 var_20          = dword ptr -20h
.text$mn:000062A8 var_11          = byte ptr -11h
.text$mn:000062A8 var_8           = dword ptr -8
.text$mn:000062A8 arg_0           = dword ptr  8
.text$mn:000062A8
.text$mn:000062A8                 push    ebp
.text$mn:000062A9                 mov     ebp, esp
.text$mn:000062AB                 sub     esp, 0E4h
.text$mn:000062B1                 push    ebx
.text$mn:000062B2                 push    esi
.text$mn:000062B3                 push    edi
.text$mn:000062B4                 push    ecx
.text$mn:000062B5                 lea     edi, [ebp+var_E4]
.text$mn:000062BB                 mov     ecx, 39h ; '9'
.text$mn:000062C0                 mov     eax, 0CCCCCCCCh
.text$mn:000062C5                 rep stosd
.text$mn:000062C7                 pop     ecx
.text$mn:000062C8                 mov     [ebp+var_8], ecx
.text$mn:000062CB                 mov     ecx, [ebp+var_8]
.text$mn:000062CE                 call    ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV?$allocator@H@2@XZ
.text$mn:000062D3                 push    eax
.text$mn:000062D4                 lea     ecx, [ebp+var_11]
.text$mn:000062D7                 call    ??$?0V?$allocator@H@std@@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAE@AAV?$allocator@H@1@@Z
.text$mn:000062DC                 mov     eax, [ebp+arg_0]
.text$mn:000062DF                 mov     [ebp+var_20], eax
.text$mn:000062E2                 mov     ecx, [ebp+var_8]
.text$mn:000062E5                 call    ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV?$allocator@H@2@XZ
.text$mn:000062EA                 push    eax
.text$mn:000062EB                 call    ??$move@AAV?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::move<std::allocator<int> &>(std::allocator<int> &)
.text$mn:000062F0                 add     esp, 4
.text$mn:000062F3                 push    eax             ; int
.text$mn:000062F4                 mov     ecx, [ebp+var_8]
.text$mn:000062F7                 call    ?_Callee@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@XZ
.text$mn:000062FC                 push    eax
.text$mn:000062FD                 call    ??$move@AAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@std@@YA$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@AAV1@@Z ; std::move<_lambda_b6f3cb1c717d8c8a816f87295491882e_ &>(_lambda_b6f3cb1c717d8c8a816f87295491882e_ &)
.text$mn:00006302                 add     esp, 4
.text$mn:00006305                 push    eax             ; int
.text$mn:00006306                 mov     eax, [ebp+var_20]
.text$mn:00006309                 push    eax             ; void *
.text$mn:0000630A                 lea     ecx, [ebp+var_11]
.text$mn:0000630D                 call    ??$construct@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@2@@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$$QAV?$allocator@H@1@@Z
.text$mn:00006312                 mov     eax, [ebp+var_20]
.text$mn:00006315                 push    edx
.text$mn:00006316                 mov     ecx, ebp
.text$mn:00006318                 push    eax
.text$mn:00006319                 lea     edx, $LN5_4
.text$mn:0000631F                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00006324                 pop     eax
.text$mn:00006325                 pop     edx
.text$mn:00006326                 pop     edi
.text$mn:00006327                 pop     esi
.text$mn:00006328                 pop     ebx
.text$mn:00006329                 add     esp, 0E4h
.text$mn:0000632F                 cmp     ebp, esp
.text$mn:00006331                 call    __RTC_CheckEsp
.text$mn:00006336                 mov     esp, ebp
.text$mn:00006338                 pop     ebp
.text$mn:00006339                 retn    4
.text$mn:00006339 ?_Move@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEPAV?$_Func_base@X$$V@2@PAX@Z endp
.text$mn:00006339
.text$mn:00006339 ; ---------------------------------------------------------------------------
.text$mn:0000633C $LN5_4          dd 1                    ; DATA XREF: ?_Move@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEPAV?$_Func_base@X$$V@2@PAX@Z+71o
.text$mn:00006340                 dd offset $LN4_3
.text$mn:00006344 $LN4_3          dd 0FFFFFFEFh, 1        ; DATA XREF: .text$mn:00006340o
.text$mn:0000634C                 dd offset $LN3_0
.text$mn:00006350 $LN3_0          dd 6C415Fh              ; DATA XREF: .text$mn:0000634Co
.text$mn:00006350 _text$mn        ends
.text$mn:00006350
.text$mn:00006354 ; ===========================================================================
.text$mn:00006354
.text$mn:00006354 ; Segment type: Pure code
.text$mn:00006354 ; Segment permissions: Read/Execute
.text$mn:00006354 _text$mn        segment para public 'CODE' use32
.text$mn:00006354                 assume cs:_text$mn
.text$mn:00006354                 ;org 6354h
.text$mn:00006354                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006354
.text$mn:00006354 ; =============== S U B R O U T I N E =======================================
.text$mn:00006354
.text$mn:00006354 ; Attributes: bp-based frame
.text$mn:00006354
.text$mn:00006354                 public ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV?$allocator@H@2@XZ
.text$mn:00006354 ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV?$allocator@H@2@XZ proc near
.text$mn:00006354                                         ; CODE XREF: ?_Delete_this@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEX_N@Z+26p
.text$mn:00006354                                         ; ?_Move@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEPAV?$_Func_base@X$$V@2@PAX@Z+26p ...
.text$mn:00006354
.text$mn:00006354 var_CC          = byte ptr -0CCh
.text$mn:00006354 var_8           = dword ptr -8
.text$mn:00006354
.text$mn:00006354                 push    ebp
.text$mn:00006355                 mov     ebp, esp
.text$mn:00006357                 sub     esp, 0CCh
.text$mn:0000635D                 push    ebx
.text$mn:0000635E                 push    esi
.text$mn:0000635F                 push    edi
.text$mn:00006360                 push    ecx
.text$mn:00006361                 lea     edi, [ebp+var_CC]
.text$mn:00006367                 mov     ecx, 33h ; '3'
.text$mn:0000636C                 mov     eax, 0CCCCCCCCh
.text$mn:00006371                 rep stosd
.text$mn:00006373                 pop     ecx
.text$mn:00006374                 mov     [ebp+var_8], ecx
.text$mn:00006377                 mov     ecx, [ebp+var_8]
.text$mn:0000637A                 add     ecx, 4
.text$mn:0000637D                 call    ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Get_first(void)
.text$mn:00006382                 pop     edi
.text$mn:00006383                 pop     esi
.text$mn:00006384                 pop     ebx
.text$mn:00006385                 add     esp, 0CCh
.text$mn:0000638B                 cmp     ebp, esp
.text$mn:0000638D                 call    __RTC_CheckEsp
.text$mn:00006392                 mov     esp, ebp
.text$mn:00006394                 pop     ebp
.text$mn:00006395                 retn
.text$mn:00006395 ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@AAEAAV?$allocator@H@2@XZ endp
.text$mn:00006395
.text$mn:00006395 ; ---------------------------------------------------------------------------
.text$mn:00006396                 align 4
.text$mn:00006396 _text$mn        ends
.text$mn:00006396
.text$mn:00006398 ; ===========================================================================
.text$mn:00006398
.text$mn:00006398 ; Segment type: Pure code
.text$mn:00006398 ; Segment permissions: Read/Execute
.text$mn:00006398 _text$mn        segment para public 'CODE' use32
.text$mn:00006398                 assume cs:_text$mn
.text$mn:00006398                 ;org 6398h
.text$mn:00006398                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006398
.text$mn:00006398 ; =============== S U B R O U T I N E =======================================
.text$mn:00006398
.text$mn:00006398 ; Attributes: bp-based frame
.text$mn:00006398
.text$mn:00006398                 public ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV?$allocator@H@2@XZ
.text$mn:00006398 ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV?$allocator@H@2@XZ proc near
.text$mn:00006398                                         ; CODE XREF: ??$_Clone@X@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEPAV?$_Func_base@X$$V@1@PAXU?$integral_constant@_N$0A@@1@@Z+26p
.text$mn:00006398                                         ; ??$_Clone@X@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEPAV?$_Func_base@X$$V@1@PAXU?$integral_constant@_N$0A@@1@@Z+3Dp
.text$mn:00006398
.text$mn:00006398 var_CC          = byte ptr -0CCh
.text$mn:00006398 var_8           = dword ptr -8
.text$mn:00006398
.text$mn:00006398                 push    ebp
.text$mn:00006399                 mov     ebp, esp
.text$mn:0000639B                 sub     esp, 0CCh
.text$mn:000063A1                 push    ebx
.text$mn:000063A2                 push    esi
.text$mn:000063A3                 push    edi
.text$mn:000063A4                 push    ecx
.text$mn:000063A5                 lea     edi, [ebp+var_CC]
.text$mn:000063AB                 mov     ecx, 33h ; '3'
.text$mn:000063B0                 mov     eax, 0CCCCCCCCh
.text$mn:000063B5                 rep stosd
.text$mn:000063B7                 pop     ecx
.text$mn:000063B8                 mov     [ebp+var_8], ecx
.text$mn:000063BB                 mov     ecx, [ebp+var_8]
.text$mn:000063BE                 add     ecx, 4
.text$mn:000063C1                 call    ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Get_first(void)
.text$mn:000063C6                 pop     edi
.text$mn:000063C7                 pop     esi
.text$mn:000063C8                 pop     ebx
.text$mn:000063C9                 add     esp, 0CCh
.text$mn:000063CF                 cmp     ebp, esp
.text$mn:000063D1                 call    __RTC_CheckEsp
.text$mn:000063D6                 mov     esp, ebp
.text$mn:000063D8                 pop     ebp
.text$mn:000063D9                 retn
.text$mn:000063D9 ?_Myax@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEABV?$allocator@H@2@XZ endp
.text$mn:000063D9
.text$mn:000063D9 ; ---------------------------------------------------------------------------
.text$mn:000063DA                 align 4
.text$mn:000063DA _text$mn        ends
.text$mn:000063DA
.text$mn:000063DC ; ===========================================================================
.text$mn:000063DC
.text$mn:000063DC ; Segment type: Pure code
.text$mn:000063DC ; Segment permissions: Read/Execute
.text$mn:000063DC _text$mn        segment para public 'CODE' use32
.text$mn:000063DC                 assume cs:_text$mn
.text$mn:000063DC                 ;org 63DCh
.text$mn:000063DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000063DC
.text$mn:000063DC ; =============== S U B R O U T I N E =======================================
.text$mn:000063DC
.text$mn:000063DC ; Attributes: bp-based frame
.text$mn:000063DC
.text$mn:000063DC                 public ?_Set@?$_Func_class@X$$V@std@@AAEXPAV?$_Func_base@X$$V@2@@Z
.text$mn:000063DC ?_Set@?$_Func_class@X$$V@std@@AAEXPAV?$_Func_base@X$$V@2@@Z proc near
.text$mn:000063DC                                         ; CODE XREF: ??$_Reset_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@3@U?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@3@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@PAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@1@AAU?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@1@U?$integral_constant@_N$0A@@1@@Z+52p
.text$mn:000063DC                                         ; ??0?$_Func_class@X$$V@std@@QAE@XZ+28p ...
.text$mn:000063DC
.text$mn:000063DC var_CC          = byte ptr -0CCh
.text$mn:000063DC var_8           = dword ptr -8
.text$mn:000063DC arg_0           = dword ptr  8
.text$mn:000063DC
.text$mn:000063DC                 push    ebp
.text$mn:000063DD                 mov     ebp, esp
.text$mn:000063DF                 sub     esp, 0CCh
.text$mn:000063E5                 push    ebx
.text$mn:000063E6                 push    esi
.text$mn:000063E7                 push    edi
.text$mn:000063E8                 push    ecx
.text$mn:000063E9                 lea     edi, [ebp+var_CC]
.text$mn:000063EF                 mov     ecx, 33h ; '3'
.text$mn:000063F4                 mov     eax, 0CCCCCCCCh
.text$mn:000063F9                 rep stosd
.text$mn:000063FB                 pop     ecx
.text$mn:000063FC                 mov     [ebp+var_8], ecx
.text$mn:000063FF                 mov     eax, 4
.text$mn:00006404                 imul    ecx, eax, 9
.text$mn:00006407                 mov     edx, [ebp+var_8]
.text$mn:0000640A                 mov     eax, [ebp+arg_0]
.text$mn:0000640D                 mov     [edx+ecx], eax
.text$mn:00006410                 pop     edi
.text$mn:00006411                 pop     esi
.text$mn:00006412                 pop     ebx
.text$mn:00006413                 mov     esp, ebp
.text$mn:00006415                 pop     ebp
.text$mn:00006416                 retn    4
.text$mn:00006416 ?_Set@?$_Func_class@X$$V@std@@AAEXPAV?$_Func_base@X$$V@2@@Z endp
.text$mn:00006416
.text$mn:00006416 ; ---------------------------------------------------------------------------
.text$mn:00006419                 align 4
.text$mn:00006419 _text$mn        ends
.text$mn:00006419
.text$mn:0000641C ; ===========================================================================
.text$mn:0000641C
.text$mn:0000641C ; Segment type: Pure code
.text$mn:0000641C ; Segment permissions: Read/Execute
.text$mn:0000641C _text$mn        segment para public 'CODE' use32
.text$mn:0000641C                 assume cs:_text$mn
.text$mn:0000641C                 ;org 641Ch
.text$mn:0000641C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000641C
.text$mn:0000641C ; =============== S U B R O U T I N E =======================================
.text$mn:0000641C
.text$mn:0000641C ; Attributes: bp-based frame
.text$mn:0000641C
.text$mn:0000641C                 public ?_Target_type@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEABVtype_info@@XZ
.text$mn:0000641C ?_Target_type@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEABVtype_info@@XZ proc near
.text$mn:0000641C                                         ; DATA XREF: .rdata:00007968o
.text$mn:0000641C
.text$mn:0000641C var_CC          = byte ptr -0CCh
.text$mn:0000641C var_8           = dword ptr -8
.text$mn:0000641C
.text$mn:0000641C                 push    ebp
.text$mn:0000641D                 mov     ebp, esp
.text$mn:0000641F                 sub     esp, 0CCh
.text$mn:00006425                 push    ebx
.text$mn:00006426                 push    esi
.text$mn:00006427                 push    edi
.text$mn:00006428                 push    ecx
.text$mn:00006429                 lea     edi, [ebp+var_CC]
.text$mn:0000642F                 mov     ecx, 33h ; '3'
.text$mn:00006434                 mov     eax, 0CCCCCCCCh
.text$mn:00006439                 rep stosd
.text$mn:0000643B                 pop     ecx
.text$mn:0000643C                 mov     [ebp+var_8], ecx
.text$mn:0000643F                 mov     eax, offset ??_R0?AV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@8 ; _lambda_b6f3cb1c717d8c8a816f87295491882e_ `RTTI Type Descriptor'
.text$mn:00006444                 pop     edi
.text$mn:00006445                 pop     esi
.text$mn:00006446                 pop     ebx
.text$mn:00006447                 mov     esp, ebp
.text$mn:00006449                 pop     ebp
.text$mn:0000644A                 retn
.text$mn:0000644A ?_Target_type@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEABVtype_info@@XZ endp
.text$mn:0000644A
.text$mn:0000644A ; ---------------------------------------------------------------------------
.text$mn:0000644B                 align 4
.text$mn:0000644B _text$mn        ends
.text$mn:0000644B
.text$mn:0000644C ; ===========================================================================
.text$mn:0000644C
.text$mn:0000644C ; Segment type: Pure code
.text$mn:0000644C ; Segment permissions: Read/Execute
.text$mn:0000644C _text$mn        segment para public 'CODE' use32
.text$mn:0000644C                 assume cs:_text$mn
.text$mn:0000644C                 ;org 644Ch
.text$mn:0000644C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000644C
.text$mn:0000644C ; =============== S U B R O U T I N E =======================================
.text$mn:0000644C
.text$mn:0000644C ; Attributes: bp-based frame
.text$mn:0000644C
.text$mn:0000644C                 public ?_Tidy@?$_Func_class@X$$V@std@@IAEXXZ
.text$mn:0000644C ?_Tidy@?$_Func_class@X$$V@std@@IAEXXZ proc near
.text$mn:0000644C                                         ; CODE XREF: ??1?$_Func_class@X$$V@std@@QAE@XZ+26p
.text$mn:0000644C
.text$mn:0000644C var_D4          = dword ptr -0D4h
.text$mn:0000644C var_CD          = byte ptr -0CDh
.text$mn:0000644C var_8           = dword ptr -8
.text$mn:0000644C
.text$mn:0000644C                 push    ebp
.text$mn:0000644D                 mov     ebp, esp
.text$mn:0000644F                 sub     esp, 0D4h
.text$mn:00006455                 push    ebx
.text$mn:00006456                 push    esi
.text$mn:00006457                 push    edi
.text$mn:00006458                 push    ecx
.text$mn:00006459                 lea     edi, [ebp+var_D4]
.text$mn:0000645F                 mov     ecx, 35h ; '5'
.text$mn:00006464                 mov     eax, 0CCCCCCCCh
.text$mn:00006469                 rep stosd
.text$mn:0000646B                 pop     ecx
.text$mn:0000646C                 mov     [ebp+var_8], ecx
.text$mn:0000646F                 mov     ecx, [ebp+var_8]
.text$mn:00006472                 call    ?_Empty@?$_Func_class@X$$V@std@@IBE_NXZ
.text$mn:00006477                 movzx   eax, al
.text$mn:0000647A                 test    eax, eax
.text$mn:0000647C                 jnz     short loc_64D9
.text$mn:0000647E                 mov     ecx, [ebp+var_8]
.text$mn:00006481                 call    ?_Local@?$_Func_class@X$$V@std@@ABE_NXZ
.text$mn:00006486                 movzx   eax, al
.text$mn:00006489                 test    eax, eax
.text$mn:0000648B                 jnz     short loc_6496
.text$mn:0000648D                 mov     [ebp+var_CD], 1
.text$mn:00006494                 jmp     short loc_649D
.text$mn:00006496 ; ---------------------------------------------------------------------------
.text$mn:00006496
.text$mn:00006496 loc_6496:                               ; CODE XREF: ?_Tidy@?$_Func_class@X$$V@std@@IAEXXZ+3Fj
.text$mn:00006496                 mov     [ebp+var_CD], 0
.text$mn:0000649D
.text$mn:0000649D loc_649D:                               ; CODE XREF: ?_Tidy@?$_Func_class@X$$V@std@@IAEXXZ+48j
.text$mn:0000649D                 mov     ecx, [ebp+var_8]
.text$mn:000064A0                 call    ?_Getimpl@?$_Func_class@X$$V@std@@ABEPAV?$_Func_base@X$$V@2@XZ
.text$mn:000064A5                 mov     [ebp+var_D4], eax
.text$mn:000064AB                 mov     esi, esp
.text$mn:000064AD                 movzx   ecx, [ebp+var_CD]
.text$mn:000064B4                 push    ecx
.text$mn:000064B5                 mov     edx, [ebp+var_D4]
.text$mn:000064BB                 mov     eax, [edx]
.text$mn:000064BD                 mov     ecx, [ebp+var_D4]
.text$mn:000064C3                 mov     edx, [eax+10h]
.text$mn:000064C6                 call    edx
.text$mn:000064C8                 cmp     esi, esp
.text$mn:000064CA                 call    __RTC_CheckEsp
.text$mn:000064CF                 push    0
.text$mn:000064D1                 mov     ecx, [ebp+var_8]
.text$mn:000064D4                 call    ?_Set@?$_Func_class@X$$V@std@@AAEXPAV?$_Func_base@X$$V@2@@Z
.text$mn:000064D9
.text$mn:000064D9 loc_64D9:                               ; CODE XREF: ?_Tidy@?$_Func_class@X$$V@std@@IAEXXZ+30j
.text$mn:000064D9                 pop     edi
.text$mn:000064DA                 pop     esi
.text$mn:000064DB                 pop     ebx
.text$mn:000064DC                 add     esp, 0D4h
.text$mn:000064E2                 cmp     ebp, esp
.text$mn:000064E4                 call    __RTC_CheckEsp
.text$mn:000064E9                 mov     esp, ebp
.text$mn:000064EB                 pop     ebp
.text$mn:000064EC                 retn
.text$mn:000064EC ?_Tidy@?$_Func_class@X$$V@std@@IAEXXZ endp
.text$mn:000064EC
.text$mn:000064EC ; ---------------------------------------------------------------------------
.text$mn:000064ED                 align 10h
.text$mn:000064ED _text$mn        ends
.text$mn:000064ED
.text$mn:000064F0 ; ===========================================================================
.text$mn:000064F0
.text$mn:000064F0 ; Segment type: Pure code
.text$mn:000064F0 ; Segment permissions: Read/Execute
.text$mn:000064F0 _text$mn        segment para public 'CODE' use32
.text$mn:000064F0                 assume cs:_text$mn
.text$mn:000064F0                 ;org 64F0h
.text$mn:000064F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000064F0
.text$mn:000064F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000064F0
.text$mn:000064F0 ; Attributes: bp-based frame
.text$mn:000064F0
.text$mn:000064F0 ; void __cdecl __empty_global_delete(void *)
.text$mn:000064F0                 public ?__empty_global_delete@@YAXPAX@Z
.text$mn:000064F0 ?__empty_global_delete@@YAXPAX@Z proc near
.text$mn:000064F0
.text$mn:000064F0 var_C0          = byte ptr -0C0h
.text$mn:000064F0
.text$mn:000064F0                 push    ebp
.text$mn:000064F1                 mov     ebp, esp
.text$mn:000064F3                 sub     esp, 0C0h
.text$mn:000064F9                 push    ebx
.text$mn:000064FA                 push    esi
.text$mn:000064FB                 push    edi
.text$mn:000064FC                 lea     edi, [ebp+var_C0]
.text$mn:00006502                 mov     ecx, 30h ; '0'
.text$mn:00006507                 mov     eax, 0CCCCCCCCh
.text$mn:0000650C                 rep stosd
.text$mn:0000650E                 pop     edi
.text$mn:0000650F                 pop     esi
.text$mn:00006510                 pop     ebx
.text$mn:00006511                 mov     esp, ebp
.text$mn:00006513                 pop     ebp
.text$mn:00006514                 retn
.text$mn:00006514 ?__empty_global_delete@@YAXPAX@Z endp
.text$mn:00006514
.text$mn:00006514 ; ---------------------------------------------------------------------------
.text$mn:00006515                 align 4
.text$mn:00006515 _text$mn        ends
.text$mn:00006515
.text$mn:00006518 ; ===========================================================================
.text$mn:00006518
.text$mn:00006518 ; Segment type: Pure code
.text$mn:00006518 ; Segment permissions: Read/Execute
.text$mn:00006518 _text$mn        segment para public 'CODE' use32
.text$mn:00006518                 assume cs:_text$mn
.text$mn:00006518                 ;org 6518h
.text$mn:00006518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006518
.text$mn:00006518 ; =============== S U B R O U T I N E =======================================
.text$mn:00006518
.text$mn:00006518 ; Attributes: bp-based frame
.text$mn:00006518
.text$mn:00006518 ; void __cdecl __empty_global_delete(void *, unsigned int)
.text$mn:00006518                 public ?__empty_global_delete@@YAXPAXI@Z
.text$mn:00006518 ?__empty_global_delete@@YAXPAXI@Z proc near
.text$mn:00006518
.text$mn:00006518 var_C0          = byte ptr -0C0h
.text$mn:00006518
.text$mn:00006518                 push    ebp
.text$mn:00006519                 mov     ebp, esp
.text$mn:0000651B                 sub     esp, 0C0h
.text$mn:00006521                 push    ebx
.text$mn:00006522                 push    esi
.text$mn:00006523                 push    edi
.text$mn:00006524                 lea     edi, [ebp+var_C0]
.text$mn:0000652A                 mov     ecx, 30h ; '0'
.text$mn:0000652F                 mov     eax, 0CCCCCCCCh
.text$mn:00006534                 rep stosd
.text$mn:00006536                 pop     edi
.text$mn:00006537                 pop     esi
.text$mn:00006538                 pop     ebx
.text$mn:00006539                 mov     esp, ebp
.text$mn:0000653B                 pop     ebp
.text$mn:0000653C                 retn
.text$mn:0000653C ?__empty_global_delete@@YAXPAXI@Z endp
.text$mn:0000653C
.text$mn:0000653C ; ---------------------------------------------------------------------------
.text$mn:0000653D                 align 10h
.text$mn:0000653D _text$mn        ends
.text$mn:0000653D
.text$mn:00006540 ; ===========================================================================
.text$mn:00006540
.text$mn:00006540 ; Segment type: Pure code
.text$mn:00006540 ; Segment permissions: Read/Execute
.text$mn:00006540 _text$mn        segment para public 'CODE' use32
.text$mn:00006540                 assume cs:_text$mn
.text$mn:00006540                 ;org 6540h
.text$mn:00006540                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006540
.text$mn:00006540 ; =============== S U B R O U T I N E =======================================
.text$mn:00006540
.text$mn:00006540 ; Attributes: bp-based frame
.text$mn:00006540
.text$mn:00006540 ; public: class Vec<struct SessionData *>::Iter __thiscall Vec<struct SessionData *>::begin(void)
.text$mn:00006540                 public ?begin@?$Vec@PAUSessionData@@@@QAE?AVIter@1@XZ
.text$mn:00006540 ?begin@?$Vec@PAUSessionData@@@@QAE?AVIter@1@XZ proc near
.text$mn:00006540                                         ; CODE XREF: WinMain(x,x,x,x)+73Bp
.text$mn:00006540
.text$mn:00006540 var_CC          = byte ptr -0CCh
.text$mn:00006540 var_8           = dword ptr -8
.text$mn:00006540 arg_0           = dword ptr  8
.text$mn:00006540
.text$mn:00006540                 push    ebp
.text$mn:00006541                 mov     ebp, esp
.text$mn:00006543                 sub     esp, 0CCh
.text$mn:00006549                 push    ebx
.text$mn:0000654A                 push    esi
.text$mn:0000654B                 push    edi
.text$mn:0000654C                 push    ecx
.text$mn:0000654D                 lea     edi, [ebp+var_CC]
.text$mn:00006553                 mov     ecx, 33h ; '3'
.text$mn:00006558                 mov     eax, 0CCCCCCCCh
.text$mn:0000655D                 rep stosd
.text$mn:0000655F                 pop     ecx
.text$mn:00006560                 mov     [ebp+var_8], ecx
.text$mn:00006563                 push    0
.text$mn:00006565                 mov     eax, [ebp+var_8]
.text$mn:00006568                 push    eax
.text$mn:00006569                 mov     ecx, [ebp+arg_0]
.text$mn:0000656C                 call    ??0Iter@?$Vec@PAUSessionData@@@@QAE@PAV1@I@Z ; Vec<SessionData *>::Iter::Iter(Vec<SessionData *> *,uint)
.text$mn:00006571                 mov     eax, [ebp+arg_0]
.text$mn:00006574                 pop     edi
.text$mn:00006575                 pop     esi
.text$mn:00006576                 pop     ebx
.text$mn:00006577                 add     esp, 0CCh
.text$mn:0000657D                 cmp     ebp, esp
.text$mn:0000657F                 call    __RTC_CheckEsp
.text$mn:00006584                 mov     esp, ebp
.text$mn:00006586                 pop     ebp
.text$mn:00006587                 retn    4
.text$mn:00006587 ?begin@?$Vec@PAUSessionData@@@@QAE?AVIter@1@XZ endp
.text$mn:00006587
.text$mn:00006587 ; ---------------------------------------------------------------------------
.text$mn:0000658A                 align 4
.text$mn:0000658A _text$mn        ends
.text$mn:0000658A
.text$mn:0000658C ; ===========================================================================
.text$mn:0000658C
.text$mn:0000658C ; Segment type: Pure code
.text$mn:0000658C ; Segment permissions: Read/Execute
.text$mn:0000658C _text$mn        segment para public 'CODE' use32
.text$mn:0000658C                 assume cs:_text$mn
.text$mn:0000658C                 ;org 658Ch
.text$mn:0000658C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000658C
.text$mn:0000658C ; =============== S U B R O U T I N E =======================================
.text$mn:0000658C
.text$mn:0000658C ; Attributes: bp-based frame
.text$mn:0000658C
.text$mn:0000658C ; public: class Vec<struct TabState *>::Iter __thiscall Vec<struct TabState *>::begin(void)
.text$mn:0000658C                 public ?begin@?$Vec@PAUTabState@@@@QAE?AVIter@1@XZ
.text$mn:0000658C ?begin@?$Vec@PAUTabState@@@@QAE?AVIter@1@XZ proc near
.text$mn:0000658C                                         ; CODE XREF: WinMain(x,x,x,x)+7BFp
.text$mn:0000658C
.text$mn:0000658C var_CC          = byte ptr -0CCh
.text$mn:0000658C var_8           = dword ptr -8
.text$mn:0000658C arg_0           = dword ptr  8
.text$mn:0000658C
.text$mn:0000658C                 push    ebp
.text$mn:0000658D                 mov     ebp, esp
.text$mn:0000658F                 sub     esp, 0CCh
.text$mn:00006595                 push    ebx
.text$mn:00006596                 push    esi
.text$mn:00006597                 push    edi
.text$mn:00006598                 push    ecx
.text$mn:00006599                 lea     edi, [ebp+var_CC]
.text$mn:0000659F                 mov     ecx, 33h ; '3'
.text$mn:000065A4                 mov     eax, 0CCCCCCCCh
.text$mn:000065A9                 rep stosd
.text$mn:000065AB                 pop     ecx
.text$mn:000065AC                 mov     [ebp+var_8], ecx
.text$mn:000065AF                 push    0
.text$mn:000065B1                 mov     eax, [ebp+var_8]
.text$mn:000065B4                 push    eax
.text$mn:000065B5                 mov     ecx, [ebp+arg_0]
.text$mn:000065B8                 call    ??0Iter@?$Vec@PAUTabState@@@@QAE@PAV1@I@Z ; Vec<TabState *>::Iter::Iter(Vec<TabState *> *,uint)
.text$mn:000065BD                 mov     eax, [ebp+arg_0]
.text$mn:000065C0                 pop     edi
.text$mn:000065C1                 pop     esi
.text$mn:000065C2                 pop     ebx
.text$mn:000065C3                 add     esp, 0CCh
.text$mn:000065C9                 cmp     ebp, esp
.text$mn:000065CB                 call    __RTC_CheckEsp
.text$mn:000065D0                 mov     esp, ebp
.text$mn:000065D2                 pop     ebp
.text$mn:000065D3                 retn    4
.text$mn:000065D3 ?begin@?$Vec@PAUTabState@@@@QAE?AVIter@1@XZ endp
.text$mn:000065D3
.text$mn:000065D3 ; ---------------------------------------------------------------------------
.text$mn:000065D6                 align 4
.text$mn:000065D6 _text$mn        ends
.text$mn:000065D6
.text$mn:000065D8 ; ===========================================================================
.text$mn:000065D8
.text$mn:000065D8 ; Segment type: Pure code
.text$mn:000065D8 ; Segment permissions: Read/Execute
.text$mn:000065D8 _text$mn        segment para public 'CODE' use32
.text$mn:000065D8                 assume cs:_text$mn
.text$mn:000065D8                 ;org 65D8h
.text$mn:000065D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000065D8
.text$mn:000065D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000065D8
.text$mn:000065D8 ; Attributes: bp-based frame
.text$mn:000065D8
.text$mn:000065D8 ; public: class Vec<wchar_t *>::Iter __thiscall Vec<wchar_t *>::begin(void)
.text$mn:000065D8                 public ?begin@?$Vec@PA_W@@QAE?AVIter@1@XZ
.text$mn:000065D8 ?begin@?$Vec@PA_W@@QAE?AVIter@1@XZ proc near
.text$mn:000065D8                                         ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+33p
.text$mn:000065D8
.text$mn:000065D8 var_CC          = byte ptr -0CCh
.text$mn:000065D8 var_8           = dword ptr -8
.text$mn:000065D8 arg_0           = dword ptr  8
.text$mn:000065D8
.text$mn:000065D8                 push    ebp
.text$mn:000065D9                 mov     ebp, esp
.text$mn:000065DB                 sub     esp, 0CCh
.text$mn:000065E1                 push    ebx
.text$mn:000065E2                 push    esi
.text$mn:000065E3                 push    edi
.text$mn:000065E4                 push    ecx
.text$mn:000065E5                 lea     edi, [ebp+var_CC]
.text$mn:000065EB                 mov     ecx, 33h ; '3'
.text$mn:000065F0                 mov     eax, 0CCCCCCCCh
.text$mn:000065F5                 rep stosd
.text$mn:000065F7                 pop     ecx
.text$mn:000065F8                 mov     [ebp+var_8], ecx
.text$mn:000065FB                 push    0
.text$mn:000065FD                 mov     eax, [ebp+var_8]
.text$mn:00006600                 push    eax
.text$mn:00006601                 mov     ecx, [ebp+arg_0]
.text$mn:00006604                 call    ??0Iter@?$Vec@PA_W@@QAE@PAV1@I@Z ; Vec<wchar_t *>::Iter::Iter(Vec<wchar_t *> *,uint)
.text$mn:00006609                 mov     eax, [ebp+arg_0]
.text$mn:0000660C                 pop     edi
.text$mn:0000660D                 pop     esi
.text$mn:0000660E                 pop     ebx
.text$mn:0000660F                 add     esp, 0CCh
.text$mn:00006615                 cmp     ebp, esp
.text$mn:00006617                 call    __RTC_CheckEsp
.text$mn:0000661C                 mov     esp, ebp
.text$mn:0000661E                 pop     ebp
.text$mn:0000661F                 retn    4
.text$mn:0000661F ?begin@?$Vec@PA_W@@QAE?AVIter@1@XZ endp
.text$mn:0000661F
.text$mn:0000661F ; ---------------------------------------------------------------------------
.text$mn:00006622                 align 4
.text$mn:00006622 _text$mn        ends
.text$mn:00006622
.text$mn:00006624 ; ===========================================================================
.text$mn:00006624
.text$mn:00006624 ; Segment type: Pure code
.text$mn:00006624 ; Segment permissions: Read/Execute
.text$mn:00006624 _text$mn        segment para public 'CODE' use32
.text$mn:00006624                 assume cs:_text$mn
.text$mn:00006624                 ;org 6624h
.text$mn:00006624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006624
.text$mn:00006624 ; =============== S U B R O U T I N E =======================================
.text$mn:00006624
.text$mn:00006624 ; Attributes: bp-based frame
.text$mn:00006624
.text$mn:00006624 ; int __stdcall _deallocate____Wrap_alloc_V__allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std___std__QAEXPAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_2_I_Z(void *, int)
.text$mn:00006624                 public ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@2@I@Z
.text$mn:00006624 ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@2@I@Z proc near
.text$mn:00006624                                         ; CODE XREF: ?_Delete_this@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEX_N@Z+51p
.text$mn:00006624
.text$mn:00006624 var_CC          = byte ptr -0CCh
.text$mn:00006624 var_8           = dword ptr -8
.text$mn:00006624 arg_0           = dword ptr  8
.text$mn:00006624 arg_4           = dword ptr  0Ch
.text$mn:00006624
.text$mn:00006624                 push    ebp
.text$mn:00006625                 mov     ebp, esp
.text$mn:00006627                 sub     esp, 0CCh
.text$mn:0000662D                 push    ebx
.text$mn:0000662E                 push    esi
.text$mn:0000662F                 push    edi
.text$mn:00006630                 push    ecx
.text$mn:00006631                 lea     edi, [ebp+var_CC]
.text$mn:00006637                 mov     ecx, 33h ; '3'
.text$mn:0000663C                 mov     eax, 0CCCCCCCCh
.text$mn:00006641                 rep stosd
.text$mn:00006643                 pop     ecx
.text$mn:00006644                 mov     [ebp+var_8], ecx
.text$mn:00006647                 mov     eax, [ebp+arg_4]
.text$mn:0000664A                 push    eax             ; int
.text$mn:0000664B                 mov     ecx, [ebp+arg_0]
.text$mn:0000664E                 push    ecx             ; void *
.text$mn:0000664F                 mov     ecx, [ebp+var_8]
.text$mn:00006652                 call    ?deallocate@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@2@I@Z
.text$mn:00006657                 pop     edi
.text$mn:00006658                 pop     esi
.text$mn:00006659                 pop     ebx
.text$mn:0000665A                 add     esp, 0CCh
.text$mn:00006660                 cmp     ebp, esp
.text$mn:00006662                 call    __RTC_CheckEsp
.text$mn:00006667                 mov     esp, ebp
.text$mn:00006669                 pop     ebp
.text$mn:0000666A                 retn    8
.text$mn:0000666A ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@2@I@Z endp
.text$mn:0000666A
.text$mn:0000666A ; ---------------------------------------------------------------------------
.text$mn:0000666D                 align 10h
.text$mn:0000666D _text$mn        ends
.text$mn:0000666D
.text$mn:00006670 ; ===========================================================================
.text$mn:00006670
.text$mn:00006670 ; Segment type: Pure code
.text$mn:00006670 ; Segment permissions: Read/Execute
.text$mn:00006670 _text$mn        segment para public 'CODE' use32
.text$mn:00006670                 assume cs:_text$mn
.text$mn:00006670                 ;org 6670h
.text$mn:00006670                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006670
.text$mn:00006670 ; =============== S U B R O U T I N E =======================================
.text$mn:00006670
.text$mn:00006670 ; Attributes: bp-based frame
.text$mn:00006670
.text$mn:00006670 ; int __stdcall _deallocate___allocator_V___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_std___std__QAEXPAV___Func_impl_V_lambda_b6f3cb1c717d8c8a816f87295491882e___V__allocator_H_std__X__V_2_I_Z(void *, int)
.text$mn:00006670                 public ?deallocate@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@2@I@Z
.text$mn:00006670 ?deallocate@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@2@I@Z proc near
.text$mn:00006670                                         ; CODE XREF: ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@2@I@Z+2Ep
.text$mn:00006670
.text$mn:00006670 var_CC          = byte ptr -0CCh
.text$mn:00006670 var_8           = dword ptr -8
.text$mn:00006670 arg_0           = dword ptr  8
.text$mn:00006670 arg_4           = dword ptr  0Ch
.text$mn:00006670
.text$mn:00006670                 push    ebp
.text$mn:00006671                 mov     ebp, esp
.text$mn:00006673                 sub     esp, 0CCh
.text$mn:00006679                 push    ebx
.text$mn:0000667A                 push    esi
.text$mn:0000667B                 push    edi
.text$mn:0000667C                 push    ecx
.text$mn:0000667D                 lea     edi, [ebp+var_CC]
.text$mn:00006683                 mov     ecx, 33h ; '3'
.text$mn:00006688                 mov     eax, 0CCCCCCCCh
.text$mn:0000668D                 rep stosd
.text$mn:0000668F                 pop     ecx
.text$mn:00006690                 mov     [ebp+var_8], ecx
.text$mn:00006693                 mov     eax, [ebp+arg_4]
.text$mn:00006696                 push    eax             ; int
.text$mn:00006697                 mov     ecx, [ebp+arg_0]
.text$mn:0000669A                 push    ecx             ; void *
.text$mn:0000669B                 call    ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z
.text$mn:000066A0                 add     esp, 8
.text$mn:000066A3                 pop     edi
.text$mn:000066A4                 pop     esi
.text$mn:000066A5                 pop     ebx
.text$mn:000066A6                 add     esp, 0CCh
.text$mn:000066AC                 cmp     ebp, esp
.text$mn:000066AE                 call    __RTC_CheckEsp
.text$mn:000066B3                 mov     esp, ebp
.text$mn:000066B5                 pop     ebp
.text$mn:000066B6                 retn    8
.text$mn:000066B6 ?deallocate@?$allocator@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@QAEXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@2@I@Z endp
.text$mn:000066B6
.text$mn:000066B6 ; ---------------------------------------------------------------------------
.text$mn:000066B9                 align 4
.text$mn:000066B9 _text$mn        ends
.text$mn:000066B9
.text$mn:000066BC ; ===========================================================================
.text$mn:000066BC
.text$mn:000066BC ; Segment type: Pure code
.text$mn:000066BC ; Segment permissions: Read/Execute
.text$mn:000066BC _text$mn        segment para public 'CODE' use32
.text$mn:000066BC                 assume cs:_text$mn
.text$mn:000066BC                 ;org 66BCh
.text$mn:000066BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066BC
.text$mn:000066BC ; =============== S U B R O U T I N E =======================================
.text$mn:000066BC
.text$mn:000066BC ; Attributes: bp-based frame
.text$mn:000066BC
.text$mn:000066BC ; public: class Vec<struct SessionData *>::Iter __thiscall Vec<struct SessionData *>::end(void)
.text$mn:000066BC                 public ?end@?$Vec@PAUSessionData@@@@QAE?AVIter@1@XZ
.text$mn:000066BC ?end@?$Vec@PAUSessionData@@@@QAE?AVIter@1@XZ proc near
.text$mn:000066BC                                         ; CODE XREF: WinMain(x,x,x,x)+74Dp
.text$mn:000066BC
.text$mn:000066BC var_CC          = byte ptr -0CCh
.text$mn:000066BC var_8           = dword ptr -8
.text$mn:000066BC arg_0           = dword ptr  8
.text$mn:000066BC
.text$mn:000066BC                 push    ebp
.text$mn:000066BD                 mov     ebp, esp
.text$mn:000066BF                 sub     esp, 0CCh
.text$mn:000066C5                 push    ebx
.text$mn:000066C6                 push    esi
.text$mn:000066C7                 push    edi
.text$mn:000066C8                 push    ecx
.text$mn:000066C9                 lea     edi, [ebp+var_CC]
.text$mn:000066CF                 mov     ecx, 33h ; '3'
.text$mn:000066D4                 mov     eax, 0CCCCCCCCh
.text$mn:000066D9                 rep stosd
.text$mn:000066DB                 pop     ecx
.text$mn:000066DC                 mov     [ebp+var_8], ecx
.text$mn:000066DF                 mov     eax, [ebp+var_8]
.text$mn:000066E2                 mov     ecx, [eax]
.text$mn:000066E4                 push    ecx
.text$mn:000066E5                 mov     edx, [ebp+var_8]
.text$mn:000066E8                 push    edx
.text$mn:000066E9                 mov     ecx, [ebp+arg_0]
.text$mn:000066EC                 call    ??0Iter@?$Vec@PAUSessionData@@@@QAE@PAV1@I@Z ; Vec<SessionData *>::Iter::Iter(Vec<SessionData *> *,uint)
.text$mn:000066F1                 mov     eax, [ebp+arg_0]
.text$mn:000066F4                 pop     edi
.text$mn:000066F5                 pop     esi
.text$mn:000066F6                 pop     ebx
.text$mn:000066F7                 add     esp, 0CCh
.text$mn:000066FD                 cmp     ebp, esp
.text$mn:000066FF                 call    __RTC_CheckEsp
.text$mn:00006704                 mov     esp, ebp
.text$mn:00006706                 pop     ebp
.text$mn:00006707                 retn    4
.text$mn:00006707 ?end@?$Vec@PAUSessionData@@@@QAE?AVIter@1@XZ endp
.text$mn:00006707
.text$mn:00006707 ; ---------------------------------------------------------------------------
.text$mn:0000670A                 align 4
.text$mn:0000670A _text$mn        ends
.text$mn:0000670A
.text$mn:0000670C ; ===========================================================================
.text$mn:0000670C
.text$mn:0000670C ; Segment type: Pure code
.text$mn:0000670C ; Segment permissions: Read/Execute
.text$mn:0000670C _text$mn        segment para public 'CODE' use32
.text$mn:0000670C                 assume cs:_text$mn
.text$mn:0000670C                 ;org 670Ch
.text$mn:0000670C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000670C
.text$mn:0000670C ; =============== S U B R O U T I N E =======================================
.text$mn:0000670C
.text$mn:0000670C ; Attributes: bp-based frame
.text$mn:0000670C
.text$mn:0000670C ; public: class Vec<struct TabState *>::Iter __thiscall Vec<struct TabState *>::end(void)
.text$mn:0000670C                 public ?end@?$Vec@PAUTabState@@@@QAE?AVIter@1@XZ
.text$mn:0000670C ?end@?$Vec@PAUTabState@@@@QAE?AVIter@1@XZ proc near
.text$mn:0000670C                                         ; CODE XREF: WinMain(x,x,x,x)+7D1p
.text$mn:0000670C
.text$mn:0000670C var_CC          = byte ptr -0CCh
.text$mn:0000670C var_8           = dword ptr -8
.text$mn:0000670C arg_0           = dword ptr  8
.text$mn:0000670C
.text$mn:0000670C                 push    ebp
.text$mn:0000670D                 mov     ebp, esp
.text$mn:0000670F                 sub     esp, 0CCh
.text$mn:00006715                 push    ebx
.text$mn:00006716                 push    esi
.text$mn:00006717                 push    edi
.text$mn:00006718                 push    ecx
.text$mn:00006719                 lea     edi, [ebp+var_CC]
.text$mn:0000671F                 mov     ecx, 33h ; '3'
.text$mn:00006724                 mov     eax, 0CCCCCCCCh
.text$mn:00006729                 rep stosd
.text$mn:0000672B                 pop     ecx
.text$mn:0000672C                 mov     [ebp+var_8], ecx
.text$mn:0000672F                 mov     eax, [ebp+var_8]
.text$mn:00006732                 mov     ecx, [eax]
.text$mn:00006734                 push    ecx
.text$mn:00006735                 mov     edx, [ebp+var_8]
.text$mn:00006738                 push    edx
.text$mn:00006739                 mov     ecx, [ebp+arg_0]
.text$mn:0000673C                 call    ??0Iter@?$Vec@PAUTabState@@@@QAE@PAV1@I@Z ; Vec<TabState *>::Iter::Iter(Vec<TabState *> *,uint)
.text$mn:00006741                 mov     eax, [ebp+arg_0]
.text$mn:00006744                 pop     edi
.text$mn:00006745                 pop     esi
.text$mn:00006746                 pop     ebx
.text$mn:00006747                 add     esp, 0CCh
.text$mn:0000674D                 cmp     ebp, esp
.text$mn:0000674F                 call    __RTC_CheckEsp
.text$mn:00006754                 mov     esp, ebp
.text$mn:00006756                 pop     ebp
.text$mn:00006757                 retn    4
.text$mn:00006757 ?end@?$Vec@PAUTabState@@@@QAE?AVIter@1@XZ endp
.text$mn:00006757
.text$mn:00006757 ; ---------------------------------------------------------------------------
.text$mn:0000675A                 align 4
.text$mn:0000675A _text$mn        ends
.text$mn:0000675A
.text$mn:0000675C ; ===========================================================================
.text$mn:0000675C
.text$mn:0000675C ; Segment type: Pure code
.text$mn:0000675C ; Segment permissions: Read/Execute
.text$mn:0000675C _text$mn        segment para public 'CODE' use32
.text$mn:0000675C                 assume cs:_text$mn
.text$mn:0000675C                 ;org 675Ch
.text$mn:0000675C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000675C
.text$mn:0000675C ; =============== S U B R O U T I N E =======================================
.text$mn:0000675C
.text$mn:0000675C ; Attributes: bp-based frame
.text$mn:0000675C
.text$mn:0000675C ; public: class Vec<wchar_t *>::Iter __thiscall Vec<wchar_t *>::end(void)
.text$mn:0000675C                 public ?end@?$Vec@PA_W@@QAE?AVIter@1@XZ
.text$mn:0000675C ?end@?$Vec@PA_W@@QAE?AVIter@1@XZ proc near
.text$mn:0000675C                                         ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+3Fp
.text$mn:0000675C
.text$mn:0000675C var_CC          = byte ptr -0CCh
.text$mn:0000675C var_8           = dword ptr -8
.text$mn:0000675C arg_0           = dword ptr  8
.text$mn:0000675C
.text$mn:0000675C                 push    ebp
.text$mn:0000675D                 mov     ebp, esp
.text$mn:0000675F                 sub     esp, 0CCh
.text$mn:00006765                 push    ebx
.text$mn:00006766                 push    esi
.text$mn:00006767                 push    edi
.text$mn:00006768                 push    ecx
.text$mn:00006769                 lea     edi, [ebp+var_CC]
.text$mn:0000676F                 mov     ecx, 33h ; '3'
.text$mn:00006774                 mov     eax, 0CCCCCCCCh
.text$mn:00006779                 rep stosd
.text$mn:0000677B                 pop     ecx
.text$mn:0000677C                 mov     [ebp+var_8], ecx
.text$mn:0000677F                 mov     eax, [ebp+var_8]
.text$mn:00006782                 mov     ecx, [eax]
.text$mn:00006784                 push    ecx
.text$mn:00006785                 mov     edx, [ebp+var_8]
.text$mn:00006788                 push    edx
.text$mn:00006789                 mov     ecx, [ebp+arg_0]
.text$mn:0000678C                 call    ??0Iter@?$Vec@PA_W@@QAE@PAV1@I@Z ; Vec<wchar_t *>::Iter::Iter(Vec<wchar_t *> *,uint)
.text$mn:00006791                 mov     eax, [ebp+arg_0]
.text$mn:00006794                 pop     edi
.text$mn:00006795                 pop     esi
.text$mn:00006796                 pop     ebx
.text$mn:00006797                 add     esp, 0CCh
.text$mn:0000679D                 cmp     ebp, esp
.text$mn:0000679F                 call    __RTC_CheckEsp
.text$mn:000067A4                 mov     esp, ebp
.text$mn:000067A6                 pop     ebp
.text$mn:000067A7                 retn    4
.text$mn:000067A7 ?end@?$Vec@PA_W@@QAE?AVIter@1@XZ endp
.text$mn:000067A7
.text$mn:000067A7 ; ---------------------------------------------------------------------------
.text$mn:000067AA                 align 4
.text$mn:000067AA _text$mn        ends
.text$mn:000067AA
.text$mn:000067AC ; ===========================================================================
.text$mn:000067AC
.text$mn:000067AC ; Segment type: Pure code
.text$mn:000067AC ; Segment permissions: Read/Execute
.text$mn:000067AC _text$mn        segment para public 'CODE' use32
.text$mn:000067AC                 assume cs:_text$mn
.text$mn:000067AC                 ;org 67ACh
.text$mn:000067AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000067AC
.text$mn:000067AC ; =============== S U B R O U T I N E =======================================
.text$mn:000067AC
.text$mn:000067AC ; Attributes: bp-based frame
.text$mn:000067AC
.text$mn:000067AC ; wchar_t *__cdecl wcschr(wchar_t *Str, wchar_t)
.text$mn:000067AC                 public ?wcschr@@YAPA_WPA_W_W@Z
.text$mn:000067AC ?wcschr@@YAPA_WPA_W_W@Z proc near       ; CODE XREF: str::FindChar(wchar_t *,wchar_t)+27p
.text$mn:000067AC
.text$mn:000067AC var_C0          = byte ptr -0C0h
.text$mn:000067AC Str             = dword ptr  8
.text$mn:000067AC arg_4           = word ptr  0Ch
.text$mn:000067AC
.text$mn:000067AC                 push    ebp
.text$mn:000067AD                 mov     ebp, esp
.text$mn:000067AF                 sub     esp, 0C0h
.text$mn:000067B5                 push    ebx
.text$mn:000067B6                 push    esi
.text$mn:000067B7                 push    edi
.text$mn:000067B8                 lea     edi, [ebp+var_C0]
.text$mn:000067BE                 mov     ecx, 30h ; '0'
.text$mn:000067C3                 mov     eax, 0CCCCCCCCh
.text$mn:000067C8                 rep stosd
.text$mn:000067CA                 movzx   eax, [ebp+arg_4]
.text$mn:000067CE                 push    eax             ; Ch
.text$mn:000067CF                 mov     ecx, [ebp+Str]
.text$mn:000067D2                 push    ecx             ; Str
.text$mn:000067D3                 call    _wcschr
.text$mn:000067D8                 add     esp, 8
.text$mn:000067DB                 pop     edi
.text$mn:000067DC                 pop     esi
.text$mn:000067DD                 pop     ebx
.text$mn:000067DE                 add     esp, 0C0h
.text$mn:000067E4                 cmp     ebp, esp
.text$mn:000067E6                 call    __RTC_CheckEsp
.text$mn:000067EB                 mov     esp, ebp
.text$mn:000067ED                 pop     ebp
.text$mn:000067EE                 retn
.text$mn:000067EE ?wcschr@@YAPA_WPA_W_W@Z endp
.text$mn:000067EE
.text$mn:000067EE ; ---------------------------------------------------------------------------
.text$mn:000067EF                 align 10h
.text$mn:000067EF _text$mn        ends
.text$mn:000067EF
.text$mn:000067F0 ; ===========================================================================
.text$mn:000067F0
.text$mn:000067F0 ; Segment type: Pure code
.text$mn:000067F0 ; Segment permissions: Read/Execute
.text$mn:000067F0 _text$mn        segment para public 'CODE' use32
.text$mn:000067F0                 assume cs:_text$mn
.text$mn:000067F0                 ;org 67F0h
.text$mn:000067F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000067F0
.text$mn:000067F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000067F0
.text$mn:000067F0 ; Attributes: bp-based frame
.text$mn:000067F0
.text$mn:000067F0 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
.text$mn:000067F0                 public _WinMain@16
.text$mn:000067F0 _WinMain@16     proc near
.text$mn:000067F0
.text$mn:000067F0 var_638         = dword ptr -638h
.text$mn:000067F0 var_630         = dword ptr -630h
.text$mn:000067F0 var_624         = dword ptr -624h
.text$mn:000067F0 var_618         = dword ptr -618h
.text$mn:000067F0 var_54C         = dword ptr -54Ch
.text$mn:000067F0 var_540         = dword ptr -540h
.text$mn:000067F0 var_534         = byte ptr -534h
.text$mn:000067F0 var_524         = byte ptr -524h
.text$mn:000067F0 var_514         = dword ptr -514h
.text$mn:000067F0 var_508         = dword ptr -508h
.text$mn:000067F0 var_4FC         = byte ptr -4FCh
.text$mn:000067F0 var_4EC         = byte ptr -4ECh
.text$mn:000067F0 var_4DC         = dword ptr -4DCh
.text$mn:000067F0 var_4D0         = dword ptr -4D0h
.text$mn:000067F0 psfi            = SHFILEINFOW ptr -4C4h
.text$mn:000067F0 var_205         = byte ptr -205h
.text$mn:000067F0 var_1F9         = byte ptr -1F9h
.text$mn:000067F0 var_1F0         = dword ptr -1F0h
.text$mn:000067F0 hWnd            = dword ptr -1E4h
.text$mn:000067F0 var_1D8         = dword ptr -1D8h
.text$mn:000067F0 var_1C9         = byte ptr -1C9h
.text$mn:000067F0 var_1C0         = dword ptr -1C0h
.text$mn:000067F0 var_1B4         = byte ptr -1B4h
.text$mn:000067F0 var_160         = byte ptr -160h
.text$mn:000067F0 var_10C         = byte ptr -10Ch
.text$mn:000067F0 var_10B         = byte ptr -10Bh
.text$mn:000067F0 var_10A         = byte ptr -10Ah
.text$mn:000067F0 var_108         = byte ptr -108h
.text$mn:000067F0 var_104         = byte ptr -104h
.text$mn:000067F0 var_F8          = byte ptr -0F8h
.text$mn:000067F0 var_EC          = byte ptr -0ECh
.text$mn:000067F0 var_D8          = byte ptr -0D8h
.text$mn:000067F0 var_D4          = dword ptr -0D4h
.text$mn:000067F0 var_CC          = byte ptr -0CCh
.text$mn:000067F0 var_CB          = byte ptr -0CBh
.text$mn:000067F0 var_C8          = byte ptr -0C8h
.text$mn:000067F0 var_BC          = byte ptr -0BCh
.text$mn:000067F0 var_A7          = byte ptr -0A7h
.text$mn:000067F0 var_A4          = byte ptr -0A4h
.text$mn:000067F0 var_44          = byte ptr -44h
.text$mn:000067F0 var_15          = byte ptr -15h
.text$mn:000067F0 var_C           = dword ptr -0Ch
.text$mn:000067F0 var_4           = dword ptr -4
.text$mn:000067F0 hInstance       = dword ptr  8
.text$mn:000067F0 hPrevInstance   = dword ptr  0Ch
.text$mn:000067F0 lpCmdLine       = dword ptr  10h
.text$mn:000067F0 nShowCmd        = dword ptr  14h
.text$mn:000067F0
.text$mn:000067F0                 push    ebp
.text$mn:000067F1                 mov     ebp, esp
.text$mn:000067F3                 sub     esp, 638h
.text$mn:000067F9                 push    ebx
.text$mn:000067FA                 push    esi
.text$mn:000067FB                 push    edi             ; wchar_t *
.text$mn:000067FC                 lea     edi, [ebp+var_638]
.text$mn:00006802                 mov     ecx, 18Eh
.text$mn:00006807                 mov     eax, 0CCCCCCCCh
.text$mn:0000680C                 rep stosd
.text$mn:0000680E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006813                 xor     eax, ebp
.text$mn:00006815                 mov     [ebp+var_4], eax
.text$mn:00006818                 mov     [ebp+var_C], 1
.text$mn:0000681F
.text$mn:0000681F loc_681F:                               ; CODE XREF: WinMain(x,x,x,x)+31j
.text$mn:0000681F                                         ; WinMain(x,x,x,x)+5Fj
.text$mn:0000681F                 xor     eax, eax
.text$mn:00006821                 jnz     short loc_681F
.text$mn:00006823                 call    ?GetInstance@@YAPAUHINSTANCE__@@XZ ; GetInstance(void)
.text$mn:00006828                 cmp     [ebp+hInstance], eax
.text$mn:0000682B                 jz      short loc_6836
.text$mn:0000682D                 mov     byte ptr [ebp+var_638+3], 1
.text$mn:00006834                 jmp     short loc_683D
.text$mn:00006836 ; ---------------------------------------------------------------------------
.text$mn:00006836
.text$mn:00006836 loc_6836:                               ; CODE XREF: WinMain(x,x,x,x)+3Bj
.text$mn:00006836                 mov     byte ptr [ebp+var_638+3], 0
.text$mn:0000683D
.text$mn:0000683D loc_683D:                               ; CODE XREF: WinMain(x,x,x,x)+44j
.text$mn:0000683D                 movzx   eax, byte ptr [ebp+var_638+3]
.text$mn:00006844                 push    eax             ; bool
.text$mn:00006845                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:0000684A                 add     esp, 4
.text$mn:0000684D                 xor     eax, eax
.text$mn:0000684F                 jnz     short loc_681F
.text$mn:00006851                 push    1
.text$mn:00006853                 call    __CrtSetDbgFlag
.text$mn:00006858                 add     esp, 4
.text$mn:0000685B                 call    ?TryLoadMemTrace@@YA_NXZ ; TryLoadMemTrace(void)
.text$mn:00006860                 call    ?DisableDataExecution@@YAXXZ ; DisableDataExecution(void)
.text$mn:00006865                 push    offset ??_C@_01GFHCPBMG@C?$AA@ ; `string'
.text$mn:0000686A                 push    0
.text$mn:0000686C                 call    _setlocale
.text$mn:00006871                 add     esp, 8
.text$mn:00006874                 mov     esi, esp
.text$mn:00006876                 push    8001h           ; uMode
.text$mn:0000687B                 call    dword ptr ds:__imp__SetErrorMode@4 ; SetErrorMode(x)
.text$mn:00006881                 cmp     esi, esp
.text$mn:00006883                 call    __RTC_CheckEsp
.text$mn:00006888                 push    offset ??_C@_07PDKPIFNG@?1tester?$AA@ ; "/tester"
.text$mn:0000688D                 mov     eax, [ebp+lpCmdLine]
.text$mn:00006890                 push    eax
.text$mn:00006891                 call    ??$StartsWith@D@str@@YA_NPBD0@Z ; str::StartsWith<char>(char const *,char const *)
.text$mn:00006896                 add     esp, 8
.text$mn:00006899                 movzx   ecx, al
.text$mn:0000689C                 test    ecx, ecx
.text$mn:0000689E                 jz      short loc_68AA
.text$mn:000068A0                 call    ?TesterMain@@YAHXZ ; TesterMain(void)
.text$mn:000068A5                 jmp     loc_7371
.text$mn:000068AA ; ---------------------------------------------------------------------------
.text$mn:000068AA
.text$mn:000068AA loc_68AA:                               ; CODE XREF: WinMain(x,x,x,x)+AEj
.text$mn:000068AA                 push    offset ??_C@_08LLPLCEMM@?1regress?$AA@ ; "/regress"
.text$mn:000068AF                 mov     eax, [ebp+lpCmdLine]
.text$mn:000068B2                 push    eax
.text$mn:000068B3                 call    ??$StartsWith@D@str@@YA_NPBD0@Z ; str::StartsWith<char>(char const *,char const *)
.text$mn:000068B8                 add     esp, 8
.text$mn:000068BB                 movzx   ecx, al
.text$mn:000068BE                 test    ecx, ecx
.text$mn:000068C0                 jz      short loc_68CC
.text$mn:000068C2                 call    ?RegressMain@@YAHXZ ; RegressMain(void)
.text$mn:000068C7                 jmp     loc_7371
.text$mn:000068CC ; ---------------------------------------------------------------------------
.text$mn:000068CC
.text$mn:000068CC loc_68CC:                               ; CODE XREF: WinMain(x,x,x,x)+D0j
.text$mn:000068CC                 push    0               ; Time
.text$mn:000068CE                 call    _time
.text$mn:000068D3                 add     esp, 4
.text$mn:000068D6                 push    eax             ; Seed
.text$mn:000068D7                 call    _srand
.text$mn:000068DC                 add     esp, 4
.text$mn:000068DF                 call    ?Initialize@uia@@YAXXZ ; uia::Initialize(void)
.text$mn:000068E4                 call    ?RememberCallstackLogs@dbghelp@@YAXXZ ; dbghelp::RememberCallstackLogs(void)
.text$mn:000068E9                 call    ?SetupCrashHandler@@YAXXZ ; SetupCrashHandler(void)
.text$mn:000068EE                 lea     ecx, [ebp+var_15] ; this
.text$mn:000068F1                 call    ??0ScopedOle@@QAE@XZ ; ScopedOle::ScopedOle(void)
.text$mn:000068F6                 call    ?InitAllCommonControls@@YAXXZ ; InitAllCommonControls(void)
.text$mn:000068FB                 push    1               ; bool
.text$mn:000068FD                 lea     ecx, [ebp+var_44] ; this
.text$mn:00006900                 call    ??0ScopedGdiPlus@@QAE@_N@Z ; ScopedGdiPlus::ScopedGdiPlus(bool)
.text$mn:00006905                 call    ?Initialize@mui@@YAXXZ ; mui::Initialize(void)
.text$mn:0000690A                 call    ?Initialize@uitask@@YAXXZ ; uitask::Initialize(void)
.text$mn:0000690F                 lea     ecx, [ebp+var_1B4]
.text$mn:00006915                 call    ??0CommandLineInfo@@QAE@XZ ; CommandLineInfo::CommandLineInfo(void)
.text$mn:0000691A                 mov     esi, esp
.text$mn:0000691C                 call    dword ptr ds:__imp__GetCommandLineW@0 ; GetCommandLineW()
.text$mn:00006922                 cmp     esi, esp
.text$mn:00006924                 call    __RTC_CheckEsp
.text$mn:00006929                 push    eax             ; wchar_t *
.text$mn:0000692A                 lea     ecx, [ebp+var_1B4] ; this
.text$mn:00006930                 call    ?ParseCommandLine@CommandLineInfo@@QAEXPB_W@Z ; CommandLineInfo::ParseCommandLine(wchar_t const *)
.text$mn:00006935                 movzx   eax, [ebp+var_EC]
.text$mn:0000693C                 push    eax             ; bool
.text$mn:0000693D                 call    ?InitializePolicies@@YAX_N@Z ; InitializePolicies(bool)
.text$mn:00006942                 add     esp, 4
.text$mn:00006945                 lea     ecx, [ebp+var_C8]
.text$mn:0000694B                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00006950                 test    eax, eax
.text$mn:00006952                 jz      short loc_6968
.text$mn:00006954                 lea     ecx, [ebp+var_C8]
.text$mn:0000695A                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:0000695F                 push    eax             ; wchar_t *
.text$mn:00006960                 call    ?SetAppDataPath@@YAXPB_W@Z ; SetAppDataPath(wchar_t const *)
.text$mn:00006965                 add     esp, 4
.text$mn:00006968
.text$mn:00006968 loc_6968:                               ; CODE XREF: WinMain(x,x,x,x)+162j
.text$mn:00006968                 call    ?Load@prefs@@YA_NXZ ; prefs::Load(void)
.text$mn:0000696D                 lea     ecx, [ebp+var_1B4] ; this
.text$mn:00006973                 call    ?UpdateGlobalPrefs@CommandLineInfo@@QAEXXZ ; CommandLineInfo::UpdateGlobalPrefs(void)
.text$mn:00006978                 lea     ecx, [ebp+var_A4]
.text$mn:0000697E                 call    ??B?$ScopedMem@D@@QBEPADXZ ; ScopedMem<char>::operator char *(void)
.text$mn:00006983                 test    eax, eax
.text$mn:00006985                 jz      short loc_699A
.text$mn:00006987                 lea     ecx, [ebp+var_A4]
.text$mn:0000698D                 call    ??B?$ScopedMem@D@@QBEPADXZ ; ScopedMem<char>::operator char *(void)
.text$mn:00006992                 mov     [ebp+var_638], eax
.text$mn:00006998                 jmp     short loc_69AB
.text$mn:0000699A ; ---------------------------------------------------------------------------
.text$mn:0000699A
.text$mn:0000699A loc_699A:                               ; CODE XREF: WinMain(x,x,x,x)+195j
.text$mn:0000699A                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:0000699F                 mov     ecx, [eax+0A8h]
.text$mn:000069A5                 mov     [ebp+var_638], ecx
.text$mn:000069AB
.text$mn:000069AB loc_69AB:                               ; CODE XREF: WinMain(x,x,x,x)+1A8j
.text$mn:000069AB                 mov     edx, [ebp+var_638]
.text$mn:000069B1                 push    edx             ; char *
.text$mn:000069B2                 call    ?SetCurrentLang@@YAXPBD@Z ; SetCurrentLang(char const *)
.text$mn:000069B7                 add     esp, 4
.text$mn:000069BA                 movzx   eax, [ebp+var_D8]
.text$mn:000069C1                 test    eax, eax
.text$mn:000069C3                 jz      short loc_69CF
.text$mn:000069C5                 call    ?RedirectIOToConsole@@YAXXZ ; RedirectIOToConsole(void)
.text$mn:000069CA                 call    _fz_redirect_dll_io_to_console
.text$mn:000069CF
.text$mn:000069CF loc_69CF:                               ; CODE XREF: WinMain(x,x,x,x)+1D3j
.text$mn:000069CF                 movzx   eax, [ebp+var_10C]
.text$mn:000069D6                 test    eax, eax
.text$mn:000069D8                 jz      short loc_69DF
.text$mn:000069DA                 call    ?AssociateExeWithPdfExtension@@YAXXZ ; AssociateExeWithPdfExtension(void)
.text$mn:000069DF
.text$mn:000069DF loc_69DF:                               ; CODE XREF: WinMain(x,x,x,x)+1E8j
.text$mn:000069DF                 lea     ecx, [ebp+var_160]
.text$mn:000069E5                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:000069EA                 test    eax, eax
.text$mn:000069EC                 jbe     short loc_6A15
.text$mn:000069EE                 lea     eax, [ebp+var_160]
.text$mn:000069F4                 push    eax             ; struct WStrVec *
.text$mn:000069F5                 call    ?BenchFileOrDir@@YAXAAVWStrVec@@@Z ; BenchFileOrDir(WStrVec &)
.text$mn:000069FA                 add     esp, 4
.text$mn:000069FD                 movzx   eax, [ebp+var_D8]
.text$mn:00006A04                 test    eax, eax
.text$mn:00006A06                 jz      short loc_6A15
.text$mn:00006A08                 push    offset ??_C@_05PDJBBECF@pause?$AA@ ; "pause"
.text$mn:00006A0D                 call    _system
.text$mn:00006A12                 add     esp, 4
.text$mn:00006A15
.text$mn:00006A15 loc_6A15:                               ; CODE XREF: WinMain(x,x,x,x)+1FCj
.text$mn:00006A15                                         ; WinMain(x,x,x,x)+216j
.text$mn:00006A15                 movzx   eax, [ebp+var_CC]
.text$mn:00006A1C                 test    eax, eax
.text$mn:00006A1E                 jz      short loc_6A25
.text$mn:00006A20                 jmp     $Exit$113
.text$mn:00006A25 ; ---------------------------------------------------------------------------
.text$mn:00006A25
.text$mn:00006A25 loc_6A25:                               ; CODE XREF: WinMain(x,x,x,x)+22Ej
.text$mn:00006A25                 mov     al, [ebp+var_A7]
.text$mn:00006A2B                 mov     byte ptr ds:?gCrashOnOpen@@3_NA, al ; bool gCrashOnOpen
.text$mn:00006A30                 push    (offset ?gRenderCache@@3VRenderCache@@A+394h) ; unsigned __int32 *
.text$mn:00006A35                 push    (offset ?gRenderCache@@3VRenderCache@@A+390h) ; unsigned __int32 *
.text$mn:00006A3A                 call    ?GetFixedPageUiColors@@YAXAAK0@Z ; GetFixedPageUiColors(ulong &,ulong &)
.text$mn:00006A3F                 add     esp, 8
.text$mn:00006A42                 call    ?RegisterWinClass@@YA_NXZ ; RegisterWinClass(void)
.text$mn:00006A47                 movzx   eax, al
.text$mn:00006A4A                 test    eax, eax
.text$mn:00006A4C                 jnz     short loc_6A53
.text$mn:00006A4E                 jmp     $Exit$113
.text$mn:00006A53 ; ---------------------------------------------------------------------------
.text$mn:00006A53
.text$mn:00006A53 loc_6A53:                               ; CODE XREF: WinMain(x,x,x,x)+25Cj
.text$mn:00006A53                                         ; WinMain(x,x,x,x)+265j ...
.text$mn:00006A53                 xor     eax, eax
.text$mn:00006A55                 jnz     short loc_6A53
.text$mn:00006A57                 mov     esi, esp
.text$mn:00006A59                 push    0               ; lpModuleName
.text$mn:00006A5B                 call    dword ptr ds:__imp__GetModuleHandleW@4 ; GetModuleHandleW(x)
.text$mn:00006A61                 cmp     esi, esp
.text$mn:00006A63                 call    __RTC_CheckEsp
.text$mn:00006A68                 cmp     [ebp+hInstance], eax
.text$mn:00006A6B                 jz      short loc_6A76
.text$mn:00006A6D                 mov     byte ptr [ebp+var_638+3], 1
.text$mn:00006A74                 jmp     short loc_6A7D
.text$mn:00006A76 ; ---------------------------------------------------------------------------
.text$mn:00006A76
.text$mn:00006A76 loc_6A76:                               ; CODE XREF: WinMain(x,x,x,x)+27Bj
.text$mn:00006A76                 mov     byte ptr [ebp+var_638+3], 0
.text$mn:00006A7D
.text$mn:00006A7D loc_6A7D:                               ; CODE XREF: WinMain(x,x,x,x)+284j
.text$mn:00006A7D                 movzx   eax, byte ptr [ebp+var_638+3]
.text$mn:00006A84                 push    eax             ; bool
.text$mn:00006A85                 call    ?CrashIfFunc@@YAX_N@Z ; CrashIfFunc(bool)
.text$mn:00006A8A                 add     esp, 4
.text$mn:00006A8D                 xor     eax, eax
.text$mn:00006A8F                 jnz     short loc_6A53
.text$mn:00006A91                 mov     eax, [ebp+nShowCmd]
.text$mn:00006A94                 push    eax
.text$mn:00006A95                 call    ?InstanceInit@@YA_NH@Z ; InstanceInit(int)
.text$mn:00006A9A                 add     esp, 4
.text$mn:00006A9D                 movzx   ecx, al
.text$mn:00006AA0                 test    ecx, ecx
.text$mn:00006AA2                 jnz     short loc_6AA9
.text$mn:00006AA4                 jmp     $Exit$113
.text$mn:00006AA9 ; ---------------------------------------------------------------------------
.text$mn:00006AA9
.text$mn:00006AA9 loc_6AA9:                               ; CODE XREF: WinMain(x,x,x,x)+2B2j
.text$mn:00006AA9                 cmp     [ebp+var_D4], 0
.text$mn:00006AB0                 jz      short loc_6ACD
.text$mn:00006AB2                 lea     eax, [ebp+var_1B4]
.text$mn:00006AB8                 push    eax
.text$mn:00006AB9                 call    ?SetupPluginMode@@YA_NAAVCommandLineInfo@@@Z ; SetupPluginMode(CommandLineInfo &)
.text$mn:00006ABE                 add     esp, 4
.text$mn:00006AC1                 movzx   ecx, al
.text$mn:00006AC4                 test    ecx, ecx
.text$mn:00006AC6                 jnz     short loc_6ACD
.text$mn:00006AC8                 jmp     $Exit$113
.text$mn:00006ACD ; ---------------------------------------------------------------------------
.text$mn:00006ACD
.text$mn:00006ACD loc_6ACD:                               ; CODE XREF: WinMain(x,x,x,x)+2C0j
.text$mn:00006ACD                                         ; WinMain(x,x,x,x)+2D6j
.text$mn:00006ACD                 lea     ecx, [ebp+var_108]
.text$mn:00006AD3                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00006AD8                 test    eax, eax
.text$mn:00006ADA                 jz      loc_6B93
.text$mn:00006AE0                 mov     [ebp+var_1C0], 0
.text$mn:00006AEA                 jmp     short loc_6AFB
.text$mn:00006AEC ; ---------------------------------------------------------------------------
.text$mn:00006AEC
.text$mn:00006AEC loc_6AEC:                               ; CODE XREF: WinMain(x,x,x,x):loc_6B80j
.text$mn:00006AEC                 mov     eax, [ebp+var_1C0]
.text$mn:00006AF2                 add     eax, 1
.text$mn:00006AF5                 mov     [ebp+var_1C0], eax
.text$mn:00006AFB
.text$mn:00006AFB loc_6AFB:                               ; CODE XREF: WinMain(x,x,x,x)+2FAj
.text$mn:00006AFB                 lea     ecx, [ebp+var_1B4]
.text$mn:00006B01                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00006B06                 cmp     [ebp+var_1C0], eax
.text$mn:00006B0C                 jnb     short loc_6B85
.text$mn:00006B0E                 movzx   eax, [ebp+var_CB]
.text$mn:00006B15                 test    eax, eax
.text$mn:00006B17                 jnz     short loc_6B22
.text$mn:00006B19                 mov     byte ptr [ebp+var_638+3], 1
.text$mn:00006B20                 jmp     short loc_6B29
.text$mn:00006B22 ; ---------------------------------------------------------------------------
.text$mn:00006B22
.text$mn:00006B22 loc_6B22:                               ; CODE XREF: WinMain(x,x,x,x)+327j
.text$mn:00006B22                 mov     byte ptr [ebp+var_638+3], 0
.text$mn:00006B29
.text$mn:00006B29 loc_6B29:                               ; CODE XREF: WinMain(x,x,x,x)+330j
.text$mn:00006B29                 lea     ecx, [ebp+var_104]
.text$mn:00006B2F                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00006B34                 push    eax             ; wchar_t *
.text$mn:00006B35                 movzx   ecx, byte ptr [ebp+var_638+3]
.text$mn:00006B3C                 push    ecx             ; bool
.text$mn:00006B3D                 lea     ecx, [ebp+var_108]
.text$mn:00006B43                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00006B48                 push    eax             ; wchar_t *
.text$mn:00006B49                 mov     edx, [ebp+var_1C0]
.text$mn:00006B4F                 push    edx
.text$mn:00006B50                 lea     ecx, [ebp+var_1B4]
.text$mn:00006B56                 call    ?At@?$Vec@PA_W@@QBEAAPA_WI@Z ; Vec<wchar_t *>::At(uint)
.text$mn:00006B5B                 mov     eax, [eax]
.text$mn:00006B5D                 push    eax             ; wchar_t *
.text$mn:00006B5E                 call    ?PrintFile@@YA_NPB_WPA_W_N0@Z ; PrintFile(wchar_t const *,wchar_t *,bool,wchar_t const *)
.text$mn:00006B63                 add     esp, 10h
.text$mn:00006B66                 mov     [ebp+var_1C9], al
.text$mn:00006B6C                 movzx   eax, [ebp+var_1C9]
.text$mn:00006B73                 test    eax, eax
.text$mn:00006B75                 jnz     short loc_6B80
.text$mn:00006B77                 mov     eax, [ebp+var_C]
.text$mn:00006B7A                 add     eax, 1
.text$mn:00006B7D                 mov     [ebp+var_C], eax
.text$mn:00006B80
.text$mn:00006B80 loc_6B80:                               ; CODE XREF: WinMain(x,x,x,x)+385j
.text$mn:00006B80                 jmp     loc_6AEC
.text$mn:00006B85 ; ---------------------------------------------------------------------------
.text$mn:00006B85
.text$mn:00006B85 loc_6B85:                               ; CODE XREF: WinMain(x,x,x,x)+31Cj
.text$mn:00006B85                 mov     eax, [ebp+var_C]
.text$mn:00006B88                 sub     eax, 1
.text$mn:00006B8B                 mov     [ebp+var_C], eax
.text$mn:00006B8E                 jmp     $Exit$113
.text$mn:00006B93 ; ---------------------------------------------------------------------------
.text$mn:00006B93
.text$mn:00006B93 loc_6B93:                               ; CODE XREF: WinMain(x,x,x,x)+2EAj
.text$mn:00006B93                 mov     [ebp+var_1D8], 0
.text$mn:00006B9D                 mov     [ebp+hWnd], 0
.text$mn:00006BA7                 movzx   eax, [ebp+var_10A]
.text$mn:00006BAE                 test    eax, eax
.text$mn:00006BB0                 jnz     short loc_6BCA
.text$mn:00006BB2                 lea     ecx, [ebp+var_BC]
.text$mn:00006BB8                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00006BBD                 test    eax, eax
.text$mn:00006BBF                 jnz     short loc_6BCA
.text$mn:00006BC1                 cmp     dword ptr ds:?gPluginURL@@3PB_WB, 0 ; wchar_t const * const gPluginURL
.text$mn:00006BC8                 jz      short loc_6BCC
.text$mn:00006BCA
.text$mn:00006BCA loc_6BCA:                               ; CODE XREF: WinMain(x,x,x,x)+3C0j
.text$mn:00006BCA                                         ; WinMain(x,x,x,x)+3CFj
.text$mn:00006BCA                 jmp     short loc_6C27
.text$mn:00006BCC ; ---------------------------------------------------------------------------
.text$mn:00006BCC
.text$mn:00006BCC loc_6BCC:                               ; CODE XREF: WinMain(x,x,x,x)+3D8j
.text$mn:00006BCC                 movzx   eax, [ebp+var_F8]
.text$mn:00006BD3                 test    eax, eax
.text$mn:00006BD5                 jz      short loc_6BF5
.text$mn:00006BD7                 mov     esi, esp
.text$mn:00006BD9                 push    0               ; lpWindowName
.text$mn:00006BDB                 push    offset ??_C@_1CE@PHGKLOIF@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA_?$AAP?$AAD?$AAF?$AA_?$AAF?$AAR?$AAA?$AAM?$AAE?$AA?$AA@ ; "SUMATRA_PDF_FRAME"
.text$mn:00006BE0                 call    dword ptr ds:__imp__FindWindowW@8 ; FindWindowW(x,x)
.text$mn:00006BE6                 cmp     esi, esp
.text$mn:00006BE8                 call    __RTC_CheckEsp
.text$mn:00006BED                 mov     [ebp+hWnd], eax
.text$mn:00006BF3                 jmp     short loc_6C27
.text$mn:00006BF5 ; ---------------------------------------------------------------------------
.text$mn:00006BF5
.text$mn:00006BF5 loc_6BF5:                               ; CODE XREF: WinMain(x,x,x,x)+3E5j
.text$mn:00006BF5                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006BFA                 movzx   ecx, byte ptr [eax+5]
.text$mn:00006BFE                 test    ecx, ecx
.text$mn:00006C00                 jnz     short loc_6C12
.text$mn:00006C02                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006C07                 movzx   ecx, byte ptr [eax+0F1h]
.text$mn:00006C0E                 test    ecx, ecx
.text$mn:00006C10                 jz      short loc_6C27
.text$mn:00006C12
.text$mn:00006C12 loc_6C12:                               ; CODE XREF: WinMain(x,x,x,x)+410j
.text$mn:00006C12                 lea     eax, [ebp+var_1D8]
.text$mn:00006C18                 push    eax
.text$mn:00006C19                 call    ?FindPrevInstWindow@@YAPAUHWND__@@PAPAX@Z ; FindPrevInstWindow(void * *)
.text$mn:00006C1E                 add     esp, 4
.text$mn:00006C21                 mov     [ebp+hWnd], eax
.text$mn:00006C27
.text$mn:00006C27 loc_6C27:                               ; CODE XREF: WinMain(x,x,x,x):loc_6BCAj
.text$mn:00006C27                                         ; WinMain(x,x,x,x)+403j ...
.text$mn:00006C27                 cmp     [ebp+hWnd], 0
.text$mn:00006C2E                 jz      loc_6D0C
.text$mn:00006C34                 mov     [ebp+var_1F0], 0
.text$mn:00006C3E                 jmp     short loc_6C4F
.text$mn:00006C40 ; ---------------------------------------------------------------------------
.text$mn:00006C40
.text$mn:00006C40 loc_6C40:                               ; CODE XREF: WinMain(x,x,x,x)+4BEj
.text$mn:00006C40                 mov     eax, [ebp+var_1F0]
.text$mn:00006C46                 add     eax, 1
.text$mn:00006C49                 mov     [ebp+var_1F0], eax
.text$mn:00006C4F
.text$mn:00006C4F loc_6C4F:                               ; CODE XREF: WinMain(x,x,x,x)+44Ej
.text$mn:00006C4F                 lea     ecx, [ebp+var_1B4]
.text$mn:00006C55                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00006C5A                 cmp     [ebp+var_1F0], eax
.text$mn:00006C60                 jnb     short loc_6CB0
.text$mn:00006C62                 cmp     [ebp+var_1F0], 0
.text$mn:00006C69                 jnz     short loc_6C74
.text$mn:00006C6B                 mov     byte ptr [ebp+var_638+3], 1
.text$mn:00006C72                 jmp     short loc_6C7B
.text$mn:00006C74 ; ---------------------------------------------------------------------------
.text$mn:00006C74
.text$mn:00006C74 loc_6C74:                               ; CODE XREF: WinMain(x,x,x,x)+479j
.text$mn:00006C74                 mov     byte ptr [ebp+var_638+3], 0
.text$mn:00006C7B
.text$mn:00006C7B loc_6C7B:                               ; CODE XREF: WinMain(x,x,x,x)+482j
.text$mn:00006C7B                 movzx   eax, byte ptr [ebp+var_638+3]
.text$mn:00006C82                 push    eax
.text$mn:00006C83                 lea     ecx, [ebp+var_1B4]
.text$mn:00006C89                 push    ecx
.text$mn:00006C8A                 mov     edx, [ebp+var_1F0]
.text$mn:00006C90                 push    edx
.text$mn:00006C91                 lea     ecx, [ebp+var_1B4]
.text$mn:00006C97                 call    ?At@?$Vec@PA_W@@QBEAAPA_WI@Z ; Vec<wchar_t *>::At(uint)
.text$mn:00006C9C                 mov     eax, [eax]
.text$mn:00006C9E                 push    eax
.text$mn:00006C9F                 mov     ecx, [ebp+hWnd]
.text$mn:00006CA5                 push    ecx
.text$mn:00006CA6                 call    ?OpenUsingDde@@YAXPAUHWND__@@PB_WAAVCommandLineInfo@@_N@Z ; OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)
.text$mn:00006CAB                 add     esp, 10h
.text$mn:00006CAE                 jmp     short loc_6C40
.text$mn:00006CB0 ; ---------------------------------------------------------------------------
.text$mn:00006CB0
.text$mn:00006CB0 loc_6CB0:                               ; CODE XREF: WinMain(x,x,x,x)+470j
.text$mn:00006CB0                 lea     ecx, [ebp+var_1B4]
.text$mn:00006CB6                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00006CBB                 test    eax, eax
.text$mn:00006CBD                 jnz     short loc_6D07
.text$mn:00006CBF                 mov     esi, esp
.text$mn:00006CC1                 mov     eax, [ebp+hWnd]
.text$mn:00006CC7                 push    eax             ; hWnd
.text$mn:00006CC8                 call    dword ptr ds:__imp__IsIconic@4 ; IsIconic(x)
.text$mn:00006CCE                 cmp     esi, esp
.text$mn:00006CD0                 call    __RTC_CheckEsp
.text$mn:00006CD5                 test    eax, eax
.text$mn:00006CD7                 jz      short loc_6CF1
.text$mn:00006CD9                 mov     esi, esp
.text$mn:00006CDB                 push    9               ; nCmdShow
.text$mn:00006CDD                 mov     eax, [ebp+hWnd]
.text$mn:00006CE3                 push    eax             ; hWnd
.text$mn:00006CE4                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:00006CEA                 cmp     esi, esp
.text$mn:00006CEC                 call    __RTC_CheckEsp
.text$mn:00006CF1
.text$mn:00006CF1 loc_6CF1:                               ; CODE XREF: WinMain(x,x,x,x)+4E7j
.text$mn:00006CF1                 mov     esi, esp
.text$mn:00006CF3                 mov     eax, [ebp+hWnd]
.text$mn:00006CF9                 push    eax             ; hWnd
.text$mn:00006CFA                 call    dword ptr ds:__imp__SetForegroundWindow@4 ; SetForegroundWindow(x)
.text$mn:00006D00                 cmp     esi, esp
.text$mn:00006D02                 call    __RTC_CheckEsp
.text$mn:00006D07
.text$mn:00006D07 loc_6D07:                               ; CODE XREF: WinMain(x,x,x,x)+4CDj
.text$mn:00006D07                 jmp     $Exit$113
.text$mn:00006D0C ; ---------------------------------------------------------------------------
.text$mn:00006D0C
.text$mn:00006D0C loc_6D0C:                               ; CODE XREF: WinMain(x,x,x,x)+43Ej
.text$mn:00006D0C                 mov     [ebp+var_1F9], 0
.text$mn:00006D13                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006D18                 mov     ecx, [eax+0F8h]
.text$mn:00006D1E                 call    ?Count@?$Vec@PAUSessionData@@@@QBEIXZ ; Vec<SessionData *>::Count(void)
.text$mn:00006D23                 test    eax, eax
.text$mn:00006D25                 jbe     loc_6DAD
.text$mn:00006D2B                 cmp     dword ptr ds:?gPluginURL@@3PB_WB, 0 ; wchar_t const * const gPluginURL
.text$mn:00006D32                 jnz     short loc_6DAD
.text$mn:00006D34                 push    offset ??_C@_03ICICOMAL@yes?$AA@ ; "yes"
.text$mn:00006D39                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006D3E                 mov     ecx, [eax+8]
.text$mn:00006D41                 push    ecx             ; this
.text$mn:00006D42                 call    ?EqI@str@@YA_NPBD0@Z ; str::EqI(char const *,char const *)
.text$mn:00006D47                 add     esp, 8
.text$mn:00006D4A                 movzx   edx, al
.text$mn:00006D4D                 test    edx, edx
.text$mn:00006D4F                 jnz     short loc_6D97
.text$mn:00006D51                 push    offset ??_C@_04LOAJBDKD@true?$AA@ ; "true"
.text$mn:00006D56                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006D5B                 mov     ecx, [eax+8]
.text$mn:00006D5E                 push    ecx             ; this
.text$mn:00006D5F                 call    ?EqI@str@@YA_NPBD0@Z ; str::EqI(char const *,char const *)
.text$mn:00006D64                 add     esp, 8
.text$mn:00006D67                 movzx   edx, al
.text$mn:00006D6A                 test    edx, edx
.text$mn:00006D6C                 jnz     short loc_6D97
.text$mn:00006D6E                 push    offset ??_C@_04HAPDLBFF@auto?$AA@ ; "auto"
.text$mn:00006D73                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006D78                 mov     ecx, [eax+8]
.text$mn:00006D7B                 push    ecx             ; this
.text$mn:00006D7C                 call    ?EqI@str@@YA_NPBD0@Z ; str::EqI(char const *,char const *)
.text$mn:00006D81                 add     esp, 8
.text$mn:00006D84                 movzx   edx, al
.text$mn:00006D87                 test    edx, edx
.text$mn:00006D89                 jnz     short loc_6D97
.text$mn:00006D8B                 mov     [ebp+var_638], 0
.text$mn:00006D95                 jmp     short loc_6DA1
.text$mn:00006D97 ; ---------------------------------------------------------------------------
.text$mn:00006D97
.text$mn:00006D97 loc_6D97:                               ; CODE XREF: WinMain(x,x,x,x)+55Fj
.text$mn:00006D97                                         ; WinMain(x,x,x,x)+57Cj ...
.text$mn:00006D97                 mov     [ebp+var_638], 1
.text$mn:00006DA1
.text$mn:00006DA1 loc_6DA1:                               ; CODE XREF: WinMain(x,x,x,x)+5A5j
.text$mn:00006DA1                 mov     al, byte ptr [ebp+var_638]
.text$mn:00006DA7                 mov     [ebp+var_1F9], al
.text$mn:00006DAD
.text$mn:00006DAD loc_6DAD:                               ; CODE XREF: WinMain(x,x,x,x)+535j
.text$mn:00006DAD                                         ; WinMain(x,x,x,x)+542j
.text$mn:00006DAD                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006DB2                 mov     ecx, [eax+0FCh]
.text$mn:00006DB8                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00006DBD                 test    eax, eax
.text$mn:00006DBF                 jbe     loc_6E65
.text$mn:00006DC5                 cmp     dword ptr ds:?gPluginURL@@3PB_WB, 0 ; wchar_t const * const gPluginURL
.text$mn:00006DCC                 jnz     loc_6E65
.text$mn:00006DD2                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006DD7                 mov     ecx, [eax+0FCh]
.text$mn:00006DDD                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00006DE2                 cmp     eax, 1
.text$mn:00006DE5                 jnz     short loc_6E27
.text$mn:00006DE7                 push    offset ??_C@_1BI@HAGDNPLN@?$AAS?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn?$AAD?$AAa?$AAt?$AAa?$AA?$AA@ ; "SessionData"
.text$mn:00006DEC                 push    0
.text$mn:00006DEE                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006DF3                 mov     ecx, [eax+0FCh]
.text$mn:00006DF9                 call    ?At@?$Vec@PA_W@@QBEAAPA_WI@Z ; Vec<wchar_t *>::At(uint)
.text$mn:00006DFE                 mov     ecx, [eax]
.text$mn:00006E00                 push    ecx             ; this
.text$mn:00006E01                 call    ?EqI@str@@YA_NPB_W0@Z ; str::EqI(wchar_t const *,wchar_t const *)
.text$mn:00006E06                 add     esp, 8
.text$mn:00006E09                 movzx   edx, al
.text$mn:00006E0C                 test    edx, edx
.text$mn:00006E0E                 jz      short loc_6E27
.text$mn:00006E10                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006E15                 mov     ecx, [eax+0FCh]
.text$mn:00006E1B                 call    ?FreeMembers@?$Vec@PA_W@@QAEXXZ ; Vec<wchar_t *>::FreeMembers(void)
.text$mn:00006E20                 mov     [ebp+var_1F9], 1
.text$mn:00006E27
.text$mn:00006E27 loc_6E27:                               ; CODE XREF: WinMain(x,x,x,x)+5F5j
.text$mn:00006E27                                         ; WinMain(x,x,x,x)+61Ej ...
.text$mn:00006E27                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006E2C                 mov     ecx, [eax+0FCh]
.text$mn:00006E32                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00006E37                 test    eax, eax
.text$mn:00006E39                 jbe     short loc_6E65
.text$mn:00006E3B                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006E40                 mov     ecx, [eax+0FCh]
.text$mn:00006E46                 call    ?Pop@?$Vec@PA_W@@QAEPA_WXZ ; Vec<wchar_t *>::Pop(void)
.text$mn:00006E4B                 mov     [ebp+var_618], eax
.text$mn:00006E51                 lea     ecx, [ebp+var_618]
.text$mn:00006E57                 push    ecx
.text$mn:00006E58                 lea     ecx, [ebp+var_1B4]
.text$mn:00006E5E                 call    ?Append@?$Vec@PA_W@@QAEXABQA_W@Z ; Vec<wchar_t *>::Append(wchar_t * const &)
.text$mn:00006E63                 jmp     short loc_6E27
.text$mn:00006E65 ; ---------------------------------------------------------------------------
.text$mn:00006E65
.text$mn:00006E65 loc_6E65:                               ; CODE XREF: WinMain(x,x,x,x)+5CFj
.text$mn:00006E65                                         ; WinMain(x,x,x,x)+5DCj ...
.text$mn:00006E65                 movzx   eax, [ebp+var_1F9]
.text$mn:00006E6C                 test    eax, eax
.text$mn:00006E6E                 jnz     short loc_6EAC
.text$mn:00006E70                 lea     ecx, [ebp+var_1B4]
.text$mn:00006E76                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00006E7B                 test    eax, eax
.text$mn:00006E7D                 jnz     short loc_6EAC
.text$mn:00006E7F                 mov     ecx, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006E85                 movzx   edx, byte ptr [ecx+0BCh]
.text$mn:00006E8C                 test    edx, edx
.text$mn:00006E8E                 jz      short loc_6EAC
.text$mn:00006E90                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006E95                 movzx   ecx, byte ptr [eax+0F0h]
.text$mn:00006E9C                 test    ecx, ecx
.text$mn:00006E9E                 jz      short loc_6EAC
.text$mn:00006EA0                 mov     [ebp+var_638], 1
.text$mn:00006EAA                 jmp     short loc_6EB6
.text$mn:00006EAC ; ---------------------------------------------------------------------------
.text$mn:00006EAC
.text$mn:00006EAC loc_6EAC:                               ; CODE XREF: WinMain(x,x,x,x)+67Ej
.text$mn:00006EAC                                         ; WinMain(x,x,x,x)+68Dj ...
.text$mn:00006EAC                 mov     [ebp+var_638], 0
.text$mn:00006EB6
.text$mn:00006EB6 loc_6EB6:                               ; CODE XREF: WinMain(x,x,x,x)+6BAj
.text$mn:00006EB6                 mov     dl, byte ptr [ebp+var_638]
.text$mn:00006EBC                 mov     [ebp+var_205], dl
.text$mn:00006EC2                 movzx   eax, [ebp+var_205]
.text$mn:00006EC9                 test    eax, eax
.text$mn:00006ECB                 jz      short loc_6EF4
.text$mn:00006ECD                 mov     esi, esp
.text$mn:00006ECF                 push    4011h           ; uFlags
.text$mn:00006ED4                 push    2B4h            ; cbFileInfo
.text$mn:00006ED9                 lea     eax, [ebp+psfi]
.text$mn:00006EDF                 push    eax             ; psfi
.text$mn:00006EE0                 push    0               ; dwFileAttributes
.text$mn:00006EE2                 push    offset ??_C@_19GMJJNAOJ@?$AA?4?$AAp?$AAd?$AAf?$AA?$AA@ ; ".pdf"
.text$mn:00006EE7                 call    dword ptr ds:__imp__SHGetFileInfoW@20 ; SHGetFileInfoW(x,x,x,x,x)
.text$mn:00006EED                 cmp     esi, esp
.text$mn:00006EEF                 call    __RTC_CheckEsp
.text$mn:00006EF4
.text$mn:00006EF4 loc_6EF4:                               ; CODE XREF: WinMain(x,x,x,x)+6DBj
.text$mn:00006EF4                 mov     [ebp+var_4D0], 0
.text$mn:00006EFE                 movzx   eax, [ebp+var_1F9]
.text$mn:00006F05                 test    eax, eax
.text$mn:00006F07                 jz      loc_7038
.text$mn:00006F0D                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:00006F12                 mov     ecx, [eax+0F8h]
.text$mn:00006F18                 mov     [ebp+var_4DC], ecx
.text$mn:00006F1E                 lea     eax, [ebp+var_4EC]
.text$mn:00006F24                 push    eax
.text$mn:00006F25                 mov     ecx, [ebp+var_4DC]
.text$mn:00006F2B                 call    ?begin@?$Vec@PAUSessionData@@@@QAE?AVIter@1@XZ ; Vec<SessionData *>::begin(void)
.text$mn:00006F30                 lea     eax, [ebp+var_4FC]
.text$mn:00006F36                 push    eax
.text$mn:00006F37                 mov     ecx, [ebp+var_4DC]
.text$mn:00006F3D                 call    ?end@?$Vec@PAUSessionData@@@@QAE?AVIter@1@XZ ; Vec<SessionData *>::end(void)
.text$mn:00006F42                 jmp     short loc_6F4F
.text$mn:00006F44 ; ---------------------------------------------------------------------------
.text$mn:00006F44
.text$mn:00006F44 loc_6F44:                               ; CODE XREF: WinMain(x,x,x,x)+843j
.text$mn:00006F44                 lea     ecx, [ebp+var_4EC]
.text$mn:00006F4A                 call    ??EIter@?$Vec@PAUSessionData@@@@QAEAAV01@XZ ; Vec<SessionData *>::Iter::operator++(void)
.text$mn:00006F4F
.text$mn:00006F4F loc_6F4F:                               ; CODE XREF: WinMain(x,x,x,x)+752j
.text$mn:00006F4F                 lea     eax, [ebp+var_4FC]
.text$mn:00006F55                 push    eax
.text$mn:00006F56                 lea     ecx, [ebp+var_4EC]
.text$mn:00006F5C                 call    ??9Iter@?$Vec@PAUSessionData@@@@QBE_NABV01@@Z ; Vec<SessionData *>::Iter::operator!=(Vec<SessionData *>::Iter const &)
.text$mn:00006F61                 movzx   ecx, al
.text$mn:00006F64                 test    ecx, ecx
.text$mn:00006F66                 jz      loc_7038
.text$mn:00006F6C                 lea     ecx, [ebp+var_4EC]
.text$mn:00006F72                 call    ??DIter@?$Vec@PAUSessionData@@@@QBEAAPAUSessionData@@XZ ; Vec<SessionData *>::Iter::operator*(void)
.text$mn:00006F77                 mov     eax, [eax]
.text$mn:00006F79                 mov     [ebp+var_508], eax
.text$mn:00006F7F                 mov     eax, [ebp+var_508]
.text$mn:00006F85                 push    eax             ; struct SessionData *
.text$mn:00006F86                 call    ?CreateAndShowWindowInfo@@YAPAVWindowInfo@@PAUSessionData@@@Z ; CreateAndShowWindowInfo(SessionData *)
.text$mn:00006F8B                 add     esp, 4
.text$mn:00006F8E                 mov     [ebp+var_4D0], eax
.text$mn:00006F94                 mov     eax, [ebp+var_508]
.text$mn:00006F9A                 mov     ecx, [eax]
.text$mn:00006F9C                 mov     [ebp+var_514], ecx
.text$mn:00006FA2                 lea     eax, [ebp+var_524]
.text$mn:00006FA8                 push    eax
.text$mn:00006FA9                 mov     ecx, [ebp+var_514]
.text$mn:00006FAF                 call    ?begin@?$Vec@PAUTabState@@@@QAE?AVIter@1@XZ ; Vec<TabState *>::begin(void)
.text$mn:00006FB4                 lea     eax, [ebp+var_534]
.text$mn:00006FBA                 push    eax
.text$mn:00006FBB                 mov     ecx, [ebp+var_514]
.text$mn:00006FC1                 call    ?end@?$Vec@PAUTabState@@@@QAE?AVIter@1@XZ ; Vec<TabState *>::end(void)
.text$mn:00006FC6                 jmp     short loc_6FD3
.text$mn:00006FC8 ; ---------------------------------------------------------------------------
.text$mn:00006FC8
.text$mn:00006FC8 loc_6FC8:                               ; CODE XREF: WinMain(x,x,x,x)+825j
.text$mn:00006FC8                 lea     ecx, [ebp+var_524]
.text$mn:00006FCE                 call    ??EIter@?$Vec@PAUTabState@@@@QAEAAV01@XZ ; Vec<TabState *>::Iter::operator++(void)
.text$mn:00006FD3
.text$mn:00006FD3 loc_6FD3:                               ; CODE XREF: WinMain(x,x,x,x)+7D6j
.text$mn:00006FD3                 lea     eax, [ebp+var_534]
.text$mn:00006FD9                 push    eax
.text$mn:00006FDA                 lea     ecx, [ebp+var_524]
.text$mn:00006FE0                 call    ??9Iter@?$Vec@PAUTabState@@@@QBE_NABV01@@Z ; Vec<TabState *>::Iter::operator!=(Vec<TabState *>::Iter const &)
.text$mn:00006FE5                 movzx   ecx, al
.text$mn:00006FE8                 test    ecx, ecx
.text$mn:00006FEA                 jz      short loc_7017
.text$mn:00006FEC                 lea     ecx, [ebp+var_524]
.text$mn:00006FF2                 call    ??DIter@?$Vec@PAUTabState@@@@QBEAAPAUTabState@@XZ ; Vec<TabState *>::Iter::operator*(void)
.text$mn:00006FF7                 mov     eax, [eax]
.text$mn:00006FF9                 mov     [ebp+var_540], eax
.text$mn:00006FFF                 mov     eax, [ebp+var_540]
.text$mn:00007005                 push    eax             ; int
.text$mn:00007006                 mov     ecx, [ebp+var_4D0]
.text$mn:0000700C                 push    ecx             ; struct WindowInfo *
.text$mn:0000700D                 call    ?RestoreTabOnStartup@@YAXPAVWindowInfo@@PAUTabState@@@Z ; RestoreTabOnStartup(WindowInfo *,TabState *)
.text$mn:00007012                 add     esp, 8
.text$mn:00007015                 jmp     short loc_6FC8
.text$mn:00007017 ; ---------------------------------------------------------------------------
.text$mn:00007017
.text$mn:00007017 loc_7017:                               ; CODE XREF: WinMain(x,x,x,x)+7FAj
.text$mn:00007017                 mov     eax, [ebp+var_508]
.text$mn:0000701D                 mov     ecx, [eax+4]
.text$mn:00007020                 sub     ecx, 1
.text$mn:00007023                 push    ecx             ; int
.text$mn:00007024                 mov     edx, [ebp+var_4D0]
.text$mn:0000702A                 push    edx             ; struct WindowInfo *
.text$mn:0000702B                 call    ?TabsSelect@@YAXPAVWindowInfo@@H@Z ; TabsSelect(WindowInfo *,int)
.text$mn:00007030                 add     esp, 8
.text$mn:00007033                 jmp     loc_6F44
.text$mn:00007038 ; ---------------------------------------------------------------------------
.text$mn:00007038
.text$mn:00007038 loc_7038:                               ; CODE XREF: WinMain(x,x,x,x)+717j
.text$mn:00007038                                         ; WinMain(x,x,x,x)+776j
.text$mn:00007038                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:0000703D                 mov     ecx, [eax+0F8h]
.text$mn:00007043                 push    ecx
.text$mn:00007044                 call    ?ResetSessionState@@YAXPAV?$Vec@PAUSessionData@@@@@Z ; ResetSessionState(Vec<SessionData *> *)
.text$mn:00007049                 add     esp, 4
.text$mn:0000704C                 mov     [ebp+var_54C], 0
.text$mn:00007056                 jmp     short loc_7067
.text$mn:00007058 ; ---------------------------------------------------------------------------
.text$mn:00007058
.text$mn:00007058 loc_7058:                               ; CODE XREF: WinMain(x,x,x,x)+8EBj
.text$mn:00007058                                         ; WinMain(x,x,x,x):loc_7102j
.text$mn:00007058                 mov     eax, [ebp+var_54C]
.text$mn:0000705E                 add     eax, 1
.text$mn:00007061                 mov     [ebp+var_54C], eax
.text$mn:00007067
.text$mn:00007067 loc_7067:                               ; CODE XREF: WinMain(x,x,x,x)+866j
.text$mn:00007067                 lea     ecx, [ebp+var_1B4]
.text$mn:0000706D                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00007072                 cmp     [ebp+var_54C], eax
.text$mn:00007078                 jnb     loc_7107
.text$mn:0000707E                 cmp     [ebp+var_4D0], 0
.text$mn:00007085                 jnz     short loc_7090
.text$mn:00007087                 mov     byte ptr [ebp+var_638+3], 1
.text$mn:0000708E                 jmp     short loc_7097
.text$mn:00007090 ; ---------------------------------------------------------------------------
.text$mn:00007090
.text$mn:00007090 loc_7090:                               ; CODE XREF: WinMain(x,x,x,x)+895j
.text$mn:00007090                 mov     byte ptr [ebp+var_638+3], 0
.text$mn:00007097
.text$mn:00007097 loc_7097:                               ; CODE XREF: WinMain(x,x,x,x)+89Ej
.text$mn:00007097                 movzx   eax, byte ptr [ebp+var_638+3]
.text$mn:0000709E                 push    eax
.text$mn:0000709F                 lea     ecx, [ebp+var_1B4]
.text$mn:000070A5                 push    ecx
.text$mn:000070A6                 mov     edx, [ebp+var_54C]
.text$mn:000070AC                 push    edx
.text$mn:000070AD                 lea     ecx, [ebp+var_1B4]
.text$mn:000070B3                 call    ?At@?$Vec@PA_W@@QBEAAPA_WI@Z ; Vec<wchar_t *>::At(uint)
.text$mn:000070B8                 mov     eax, [eax]
.text$mn:000070BA                 push    eax
.text$mn:000070BB                 call    ?LoadOnStartup@@YAPAVWindowInfo@@PB_WAAVCommandLineInfo@@_N@Z ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)
.text$mn:000070C0                 add     esp, 0Ch
.text$mn:000070C3                 mov     [ebp+var_4D0], eax
.text$mn:000070C9                 cmp     [ebp+var_4D0], 0
.text$mn:000070D0                 jnz     short loc_70E0
.text$mn:000070D2                 mov     eax, [ebp+var_C]
.text$mn:000070D5                 add     eax, 1
.text$mn:000070D8                 mov     [ebp+var_C], eax
.text$mn:000070DB                 jmp     loc_7058
.text$mn:000070E0 ; ---------------------------------------------------------------------------
.text$mn:000070E0
.text$mn:000070E0 loc_70E0:                               ; CODE XREF: WinMain(x,x,x,x)+8E0j
.text$mn:000070E0                 movzx   eax, [ebp+var_10A]
.text$mn:000070E7                 test    eax, eax
.text$mn:000070E9                 jz      short loc_7102
.text$mn:000070EB                 movzx   eax, [ebp+var_10B]
.text$mn:000070F2                 push    eax             ; bool
.text$mn:000070F3                 mov     ecx, [ebp+var_4D0]
.text$mn:000070F9                 push    ecx             ; struct WindowInfo *
.text$mn:000070FA                 call    ?OnMenuPrint@@YAXPAVWindowInfo@@_N@Z ; OnMenuPrint(WindowInfo *,bool)
.text$mn:000070FF                 add     esp, 8
.text$mn:00007102
.text$mn:00007102 loc_7102:                               ; CODE XREF: WinMain(x,x,x,x)+8F9j
.text$mn:00007102                 jmp     loc_7058
.text$mn:00007107 ; ---------------------------------------------------------------------------
.text$mn:00007107
.text$mn:00007107 loc_7107:                               ; CODE XREF: WinMain(x,x,x,x)+888j
.text$mn:00007107                 lea     ecx, [ebp+var_1B4]
.text$mn:0000710D                 call    ?Count@?$Vec@PA_W@@QBEIXZ ; Vec<wchar_t *>::Count(void)
.text$mn:00007112                 test    eax, eax
.text$mn:00007114                 jbe     short loc_7124
.text$mn:00007116                 cmp     [ebp+var_4D0], 0
.text$mn:0000711D                 jnz     short loc_7124
.text$mn:0000711F                 jmp     $Exit$113
.text$mn:00007124 ; ---------------------------------------------------------------------------
.text$mn:00007124
.text$mn:00007124 loc_7124:                               ; CODE XREF: WinMain(x,x,x,x)+924j
.text$mn:00007124                                         ; WinMain(x,x,x,x)+92Dj
.text$mn:00007124                 movzx   eax, [ebp+var_10A]
.text$mn:0000712B                 test    eax, eax
.text$mn:0000712D                 jz      short loc_713F
.text$mn:0000712F                 movzx   eax, [ebp+var_10B]
.text$mn:00007136                 test    eax, eax
.text$mn:00007138                 jz      short loc_713F
.text$mn:0000713A                 jmp     $Exit$113
.text$mn:0000713F ; ---------------------------------------------------------------------------
.text$mn:0000713F
.text$mn:0000713F loc_713F:                               ; CODE XREF: WinMain(x,x,x,x)+93Dj
.text$mn:0000713F                                         ; WinMain(x,x,x,x)+948j
.text$mn:0000713F                 cmp     [ebp+var_4D0], 0
.text$mn:00007146                 jnz     short loc_7166
.text$mn:00007148                 push    0               ; struct SessionData *
.text$mn:0000714A                 call    ?CreateAndShowWindowInfo@@YAPAVWindowInfo@@PAUSessionData@@@Z ; CreateAndShowWindowInfo(SessionData *)
.text$mn:0000714F                 add     esp, 4
.text$mn:00007152                 mov     [ebp+var_4D0], eax
.text$mn:00007158                 cmp     [ebp+var_4D0], 0
.text$mn:0000715F                 jnz     short loc_7166
.text$mn:00007161                 jmp     $Exit$113
.text$mn:00007166 ; ---------------------------------------------------------------------------
.text$mn:00007166
.text$mn:00007166 loc_7166:                               ; CODE XREF: WinMain(x,x,x,x)+956j
.text$mn:00007166                                         ; WinMain(x,x,x,x)+96Fj
.text$mn:00007166                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:0000716B                 cmp     dword ptr [eax+0B0h], 0
.text$mn:00007172                 jz      short loc_7186
.text$mn:00007174                 mov     eax, [ebp+var_4D0]
.text$mn:0000717A                 mov     ecx, [eax+5Ch]
.text$mn:0000717D                 push    ecx
.text$mn:0000717E                 call    ?RegisterForPdfExtentions@@YA_NPAUHWND__@@@Z ; RegisterForPdfExtentions(HWND__ *)
.text$mn:00007183                 add     esp, 4
.text$mn:00007186
.text$mn:00007186 loc_7186:                               ; CODE XREF: WinMain(x,x,x,x)+982j
.text$mn:00007186                 lea     ecx, [ebp+var_BC]
.text$mn:0000718C                 call    ??B?$ScopedMem@_W@@QBEPA_WXZ ; ScopedMem<wchar_t>::operator wchar_t *(void)
.text$mn:00007191                 test    eax, eax
.text$mn:00007193                 jz      short loc_71C4
.text$mn:00007195                 push    4               ; int
.text$mn:00007197                 call    ?RestrictPolicies@@YAXH@Z ; RestrictPolicies(int)
.text$mn:0000719C                 add     esp, 4
.text$mn:0000719F                 mov     eax, [ebp+var_4D0]
.text$mn:000071A5                 push    eax             ; struct WindowInfo *
.text$mn:000071A6                 call    ?RebuildMenuBarForWindow@@YAXPAVWindowInfo@@@Z ; RebuildMenuBarForWindow(WindowInfo *)
.text$mn:000071AB                 add     esp, 4
.text$mn:000071AE                 mov     eax, [ebp+var_4D0]
.text$mn:000071B4                 push    eax             ; struct WindowInfo *
.text$mn:000071B5                 lea     ecx, [ebp+var_1B4]
.text$mn:000071BB                 push    ecx             ; struct CommandLineInfo *
.text$mn:000071BC                 call    ?StartStressTest@@YAXPAVCommandLineInfo@@PAVWindowInfo@@@Z ; StartStressTest(CommandLineInfo *,WindowInfo *)
.text$mn:000071C1                 add     esp, 8
.text$mn:000071C4
.text$mn:000071C4 loc_71C4:                               ; CODE XREF: WinMain(x,x,x,x)+9A3j
.text$mn:000071C4                 mov     eax, dword ptr ds:?gGlobalPrefs@@3PAUGlobalPrefs@@A ; GlobalPrefs * gGlobalPrefs
.text$mn:000071C9                 movzx   ecx, byte ptr [eax+0B5h]
.text$mn:000071D0                 test    ecx, ecx
.text$mn:000071D2                 jz      short loc_71E5
.text$mn:000071D4                 push    1               ; bool
.text$mn:000071D6                 mov     eax, [ebp+var_4D0]
.text$mn:000071DC                 push    eax             ; struct WindowInfo *
.text$mn:000071DD                 call    ?UpdateCheckAsync@@YAXPAVWindowInfo@@_N@Z ; UpdateCheckAsync(WindowInfo *,bool)
.text$mn:000071E2                 add     esp, 8
.text$mn:000071E5
.text$mn:000071E5 loc_71E5:                               ; CODE XREF: WinMain(x,x,x,x)+9E2j
.text$mn:000071E5                 movzx   eax, [ebp+var_205]
.text$mn:000071EC                 test    eax, eax
.text$mn:000071EE                 jz      short loc_725F
.text$mn:000071F0                 push    0               ; unsigned int
.text$mn:000071F2                 mov     ecx, offset ?gFileHistory@@3VFileHistory@@A ; this
.text$mn:000071F7                 call    ?Get@FileHistory@@QBEPAUFileState@@I@Z ; FileHistory::Get(uint)
.text$mn:000071FC                 test    eax, eax
.text$mn:000071FE                 jz      short loc_725F
.text$mn:00007200                 mov     eax, ds:?__LINE__Var@?0??WinMain@@9@16@4JA
.text$mn:00007205                 add     eax, 0DFh ; ''
.text$mn:0000720A                 push    eax             ; int
.text$mn:0000720B                 push    offset ??_C@_0DG@CPCMILPH@c?3?2workspace?2sumatrapdf?9master?2s@ ; "c:\\workspace\\sumatrapdf-master\\src\\"...
.text$mn:00007210                 push    1               ; int
.text$mn:00007212                 push    68h ; 'h'       ; unsigned int
.text$mn:00007214                 call    ??2@YAPAXIHPBDH@Z ; operator new(uint,int,char const *,int)
.text$mn:00007219                 add     esp, 10h
.text$mn:0000721C                 mov     [ebp+var_624], eax
.text$mn:00007222                 cmp     [ebp+var_624], 0
.text$mn:00007229                 jz      short loc_723E
.text$mn:0000722B                 mov     ecx, [ebp+var_624]
.text$mn:00007231                 call    ??0FileExistenceChecker@@QAE@XZ ; FileExistenceChecker::FileExistenceChecker(void)
.text$mn:00007236                 mov     [ebp+var_638], eax
.text$mn:0000723C                 jmp     short loc_7248
.text$mn:0000723E ; ---------------------------------------------------------------------------
.text$mn:0000723E
.text$mn:0000723E loc_723E:                               ; CODE XREF: WinMain(x,x,x,x)+A39j
.text$mn:0000723E                 mov     [ebp+var_638], 0
.text$mn:00007248
.text$mn:00007248 loc_7248:                               ; CODE XREF: WinMain(x,x,x,x)+A4Cj
.text$mn:00007248                 mov     ecx, [ebp+var_638]
.text$mn:0000724E                 mov     ds:?gFileExistenceChecker@@3PAVFileExistenceChecker@@A, ecx ; FileExistenceChecker * gFileExistenceChecker
.text$mn:00007254                 mov     ecx, ds:?gFileExistenceChecker@@3PAVFileExistenceChecker@@A ; this
.text$mn:0000725A                 call    ?Start@ThreadBase@@QAEXXZ ; ThreadBase::Start(void)
.text$mn:0000725F
.text$mn:0000725F loc_725F:                               ; CODE XREF: WinMain(x,x,x,x)+9FEj
.text$mn:0000725F                                         ; WinMain(x,x,x,x)+A0Ej
.text$mn:0000725F                 call    ?RegisterForFileChanges@prefs@@YAXXZ ; prefs::RegisterForFileChanges(void)
.text$mn:00007264                 call    ?RunMessageLoop@@YAHXZ ; RunMessageLoop(void)
.text$mn:00007269                 mov     [ebp+var_C], eax
.text$mn:0000726C                 lea     eax, [ebp+var_1D8]
.text$mn:00007272                 push    eax             ; void **
.text$mn:00007273                 call    ?SafeCloseHandle@@YAHPAPAX@Z ; SafeCloseHandle(void * *)
.text$mn:00007278                 add     esp, 4
.text$mn:0000727B                 push    offset ?gFileHistory@@3VFileHistory@@A ; struct FileHistory *
.text$mn:00007280                 call    ?CleanUpThumbnailCache@@YAXAAVFileHistory@@@Z ; CleanUpThumbnailCache(FileHistory &)
.text$mn:00007285                 add     esp, 4
.text$mn:00007288
.text$mn:00007288 $Exit$113:                              ; CODE XREF: WinMain(x,x,x,x)+230j
.text$mn:00007288                                         ; WinMain(x,x,x,x)+25Ej ...
.text$mn:00007288                 call    ?UnregisterForFileChanges@prefs@@YAXXZ ; prefs::UnregisterForFileChanges(void)
.text$mn:0000728D
.text$mn:0000728D loc_728D:                               ; CODE XREF: WinMain(x,x,x,x)+AC2j
.text$mn:0000728D                 mov     ecx, offset ?gWindows@@3V?$Vec@PAVWindowInfo@@@@A ; Vec<WindowInfo *> gWindows
.text$mn:00007292                 call    ?Count@?$Vec@PAVWindowInfo@@@@QBEIXZ ; Vec<WindowInfo *>::Count(void)
.text$mn:00007297                 test    eax, eax
.text$mn:00007299                 jbe     short loc_72B4
.text$mn:0000729B                 push    0
.text$mn:0000729D                 mov     ecx, offset ?gWindows@@3V?$Vec@PAVWindowInfo@@@@A ; Vec<WindowInfo *> gWindows
.text$mn:000072A2                 call    ?At@?$Vec@PAVWindowInfo@@@@QBEAAPAVWindowInfo@@I@Z ; Vec<WindowInfo *>::At(uint)
.text$mn:000072A7                 mov     eax, [eax]
.text$mn:000072A9                 push    eax             ; struct WindowInfo *
.text$mn:000072AA                 call    ?DeleteWindowInfo@@YAXPAVWindowInfo@@@Z ; DeleteWindowInfo(WindowInfo *)
.text$mn:000072AF                 add     esp, 4
.text$mn:000072B2                 jmp     short loc_728D
.text$mn:000072B4 ; ---------------------------------------------------------------------------
.text$mn:000072B4
.text$mn:000072B4 loc_72B4:                               ; CODE XREF: WinMain(x,x,x,x)+AA9j
.text$mn:000072B4                 call    ?GetDefaultGuiFont@@YAPAUHFONT__@@XZ ; GetDefaultGuiFont(void)
.text$mn:000072B9                 mov     esi, esp
.text$mn:000072BB                 push    eax             ; ho
.text$mn:000072BC                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:000072C2                 cmp     esi, esp
.text$mn:000072C4                 call    __RTC_CheckEsp
.text$mn:000072C9                 mov     esi, esp
.text$mn:000072CB                 mov     eax, dword ptr ds:?gBitmapReloadingCue@@3PAUHBITMAP__@@A ; HBITMAP__ * gBitmapReloadingCue
.text$mn:000072D0                 push    eax             ; ho
.text$mn:000072D1                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:000072D7                 cmp     esi, esp
.text$mn:000072D9                 call    __RTC_CheckEsp
.text$mn:000072DE                 call    ?DeleteSplitterBrush@@YAXXZ ; DeleteSplitterBrush(void)
.text$mn:000072E3
.text$mn:000072E3 loc_72E3:                               ; CODE XREF: WinMain(x,x,x,x)+B12j
.text$mn:000072E3                 cmp     ds:?gFileExistenceChecker@@3PAVFileExistenceChecker@@A, 0 ; FileExistenceChecker * gFileExistenceChecker
.text$mn:000072EA                 jz      short loc_7304
.text$mn:000072EC                 mov     esi, esp
.text$mn:000072EE                 push    0Ah             ; dwMilliseconds
.text$mn:000072F0                 call    dword ptr ds:__imp__Sleep@4 ; Sleep(x)
.text$mn:000072F6                 cmp     esi, esp
.text$mn:000072F8                 call    __RTC_CheckEsp
.text$mn:000072FD                 call    ?DrainQueue@uitask@@YAXXZ ; uitask::DrainQueue(void)
.text$mn:00007302                 jmp     short loc_72E3
.text$mn:00007304 ; ---------------------------------------------------------------------------
.text$mn:00007304
.text$mn:00007304 loc_7304:                               ; CODE XREF: WinMain(x,x,x,x)+AFAj
.text$mn:00007304                 call    ?Destroy@mui@@YAXXZ ; mui::Destroy(void)
.text$mn:00007309                 call    ?Destroy@uitask@@YAXXZ ; uitask::Destroy(void)
.text$mn:0000730E                 call    ?Destroy@trans@@YAXXZ ; trans::Destroy(void)
.text$mn:00007313                 call    ?DpiRemoveAll@@YAXXZ ; DpiRemoveAll(void)
.text$mn:00007318                 call    ?FileWatcherWaitForShutdown@@YAXXZ ; FileWatcherWaitForShutdown(void)
.text$mn:0000731D                 call    ?SaveCallstackLogs@@YAXXZ ; SaveCallstackLogs(void)
.text$mn:00007322                 call    ?FreeCallstackLogs@dbghelp@@YAXXZ ; dbghelp::FreeCallstackLogs(void)
.text$mn:00007327                 push    0
.text$mn:00007329                 mov     ecx, offset ?gFileHistory@@3VFileHistory@@A ; FileHistory gFileHistory
.text$mn:0000732E                 call    ?UpdateStatesSource@FileHistory@@QAEXPAV?$Vec@PAUFileState@@@@@Z ; FileHistory::UpdateStatesSource(Vec<FileState *> *)
.text$mn:00007333                 call    ?CleanUp@prefs@@YAXXZ ; prefs::CleanUp(void)
.text$mn:00007338                 call    ?UninstallCrashHandler@@YAXXZ ; UninstallCrashHandler(void)
.text$mn:0000733D                 push    21h ; '!'
.text$mn:0000733F                 call    __CrtSetDbgFlag
.text$mn:00007344                 add     esp, 4
.text$mn:00007347                 mov     eax, [ebp+var_C]
.text$mn:0000734A                 mov     [ebp+var_630], eax
.text$mn:00007350                 lea     ecx, [ebp+var_1B4] ; this
.text$mn:00007356                 call    ??1CommandLineInfo@@QAE@XZ ; CommandLineInfo::~CommandLineInfo(void)
.text$mn:0000735B                 lea     ecx, [ebp+var_44] ; this
.text$mn:0000735E                 call    ??1ScopedGdiPlus@@QAE@XZ ; ScopedGdiPlus::~ScopedGdiPlus(void)
.text$mn:00007363                 lea     ecx, [ebp+var_15] ; this
.text$mn:00007366                 call    ??1ScopedOle@@QAE@XZ ; ScopedOle::~ScopedOle(void)
.text$mn:0000736B                 mov     eax, [ebp+var_630]
.text$mn:00007371
.text$mn:00007371 loc_7371:                               ; CODE XREF: WinMain(x,x,x,x)+B5j
.text$mn:00007371                                         ; WinMain(x,x,x,x)+D7j
.text$mn:00007371                 push    edx
.text$mn:00007372                 mov     ecx, ebp
.text$mn:00007374                 push    eax
.text$mn:00007375                 lea     edx, $LN112
.text$mn:0000737B                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text$mn:00007380                 pop     eax
.text$mn:00007381                 pop     edx
.text$mn:00007382                 pop     edi
.text$mn:00007383                 pop     esi
.text$mn:00007384                 pop     ebx
.text$mn:00007385                 mov     ecx, [ebp+var_4]
.text$mn:00007388                 xor     ecx, ebp
.text$mn:0000738A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000738F                 add     esp, 638h
.text$mn:00007395                 cmp     ebp, esp
.text$mn:00007397                 call    __RTC_CheckEsp
.text$mn:0000739C                 mov     esp, ebp
.text$mn:0000739E                 pop     ebp
.text$mn:0000739F                 retn    10h
.text$mn:0000739F _WinMain@16     endp
.text$mn:0000739F
.text$mn:0000739F ; ---------------------------------------------------------------------------
.text$mn:000073A2                 align 4
.text$mn:000073A4 $LN112          dd 9                    ; DATA XREF: WinMain(x,x,x,x)+B85o
.text$mn:000073A8                 dd offset $LN111
.text$mn:000073AC $LN111          dd 0FFFFFFEBh, 1        ; DATA XREF: .text$mn:000073A8o
.text$mn:000073B4                 dd offset $LN102        ; "ole"
.text$mn:000073B8                 dd 0FFFFFFBCh, 24h
.text$mn:000073C0                 dd offset $LN103        ; "gdiPlus"
.text$mn:000073C4                 dd 0FFFFFE4Ch, 168h
.text$mn:000073CC                 dd offset $LN104        ; "i"
.text$mn:000073D0                 dd 0FFFFFE28h, 4
.text$mn:000073D8                 dd offset $LN105        ; "hMutex"
.text$mn:000073DC                 dd 0FFFFFB3Ch, 2B4h
.text$mn:000073E4                 dd offset $LN106        ; "sfi"
.text$mn:000073E8                 dd 0FFFFFB14h, 8
.text$mn:000073F0                 dd offset $LN107        ; "<begin>$L0"
.text$mn:000073F4                 dd 0FFFFFB04h, 8
.text$mn:000073FC                 dd offset $LN108        ; "<end>$L0"
.text$mn:00007400                 dd 0FFFFFADCh, 8
.text$mn:00007408                 dd offset $LN109        ; "<begin>$L1"
.text$mn:0000740C                 db 0CCh
.text$mn:0000740D                 db 0FAh, 2 dup(0FFh)
.text$mn:00007410                 dd 8
.text$mn:00007414                 dd offset $LN110        ; "<end>$L1"
.text$mn:00007418 $LN110          db '<end>$L1',0         ; DATA XREF: .text$mn:00007414o
.text$mn:00007421 $LN109          db '<begin>$L1',0       ; DATA XREF: .text$mn:00007408o
.text$mn:0000742C $LN108          db '<end>$L0',0         ; DATA XREF: .text$mn:000073FCo
.text$mn:00007435 $LN107          db '<begin>$L0',0       ; DATA XREF: .text$mn:000073F0o
.text$mn:00007440 $LN106          db 'sfi',0              ; DATA XREF: .text$mn:000073E4o
.text$mn:00007444 $LN105          db 'hMutex',0           ; DATA XREF: .text$mn:000073D8o
.text$mn:0000744B $LN104          db 'i',0                ; DATA XREF: .text$mn:000073CCo
.text$mn:0000744D $LN103          db 'gdiPlus',0          ; DATA XREF: .text$mn:000073C0o
.text$mn:00007455 $LN102          db 'ole',0              ; DATA XREF: .text$mn:000073B4o
.text$mn:00007459                 align 4
.text$mn:00007459 _text$mn        ends
.text$mn:00007459
.text$mn:0000745C ; ===========================================================================
.text$mn:0000745C
.text$mn:0000745C ; Segment type: Pure code
.text$mn:0000745C ; Segment permissions: Read/Execute
.text$mn:0000745C _text$mn        segment para public 'CODE' use32
.text$mn:0000745C                 assume cs:_text$mn
.text$mn:0000745C                 ;org 745Ch
.text$mn:0000745C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000745C
.text$mn:0000745C ; =============== S U B R O U T I N E =======================================
.text$mn:0000745C
.text$mn:0000745C ; Attributes: bp-based frame
.text$mn:0000745C
.text$mn:0000745C ; time_t __cdecl static time(time_t *Time)
.text$mn:0000745C _time           proc near               ; CODE XREF: WinMain(x,x,x,x)+DEp
.text$mn:0000745C
.text$mn:0000745C var_C0          = byte ptr -0C0h
.text$mn:0000745C Time            = dword ptr  8
.text$mn:0000745C
.text$mn:0000745C                 push    ebp
.text$mn:0000745D                 mov     ebp, esp
.text$mn:0000745F                 sub     esp, 0C0h
.text$mn:00007465                 push    ebx
.text$mn:00007466                 push    esi
.text$mn:00007467                 push    edi
.text$mn:00007468                 lea     edi, [ebp+var_C0]
.text$mn:0000746E                 mov     ecx, 30h ; '0'
.text$mn:00007473                 mov     eax, 0CCCCCCCCh
.text$mn:00007478                 rep stosd
.text$mn:0000747A                 mov     eax, [ebp+Time]
.text$mn:0000747D                 push    eax             ; Time
.text$mn:0000747E                 call    __time64
.text$mn:00007483                 add     esp, 4
.text$mn:00007486                 pop     edi
.text$mn:00007487                 pop     esi
.text$mn:00007488                 pop     ebx
.text$mn:00007489                 add     esp, 0C0h
.text$mn:0000748F                 cmp     ebp, esp
.text$mn:00007491                 call    __RTC_CheckEsp
.text$mn:00007496                 mov     esp, ebp
.text$mn:00007498                 pop     ebp
.text$mn:00007499                 retn
.text$mn:00007499 _time           endp
.text$mn:00007499
.text$mn:00007499 ; ---------------------------------------------------------------------------
.text$mn:0000749A                 align 4
.text$mn:0000749A _text$mn        ends
.text$mn:0000749A
.rdata:0000749C ; ===========================================================================
.rdata:0000749C
.rdata:0000749C ; Segment type: Pure data
.rdata:0000749C ; Segment permissions: Read
.rdata:0000749C _rdata          segment dword public 'DATA' use32
.rdata:0000749C                 assume cs:_rdata
.rdata:0000749C                 ;org 749Ch
.rdata:0000749C                 public ??_C@_1BK@JCIKOMDH@?$AAm?$AAe?$AAm?$AAt?$AAr?$AAa?$AAc?$AAe?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
.rdata:0000749C ; path `string'
.rdata:0000749C ??_C@_1BK@JCIKOMDH@?$AAm?$AAe?$AAm?$AAt?$AAr?$AAa?$AAc?$AAe?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@:
.rdata:0000749C                                         ; DATA XREF: TryLoadMemTrace(void)+1Eo
.rdata:0000749C                 unicode 0, <memtrace.dll>,0
.rdata:000074B6                 align 4
.rdata:000074B6 _rdata          ends
.rdata:000074B6
.rdata:000074B8 ; ===========================================================================
.rdata:000074B8
.rdata:000074B8 ; Segment type: Pure data
.rdata:000074B8 ; Segment permissions: Read
.rdata:000074B8 _rdata          segment dword public 'DATA' use32
.rdata:000074B8                 assume cs:_rdata
.rdata:000074B8                 ;org 74B8h
.rdata:000074B8                 public ??_7FileExistenceChecker@@6B@
.rdata:000074B8 ; const FileExistenceChecker::`vftable'
.rdata:000074B8 ??_7FileExistenceChecker@@6B@ dd offset ??_EFileExistenceChecker@@UAEPAXI@Z
.rdata:000074B8                                         ; DATA XREF: FileExistenceChecker::FileExistenceChecker(void)+30o
.rdata:000074B8                                         ; FileExistenceChecker::`vector deleting destructor'(uint)
.rdata:000074BC                 dd offset ?Run@FileExistenceChecker@@UAEXXZ ; FileExistenceChecker::Run(void)
.rdata:000074BC _rdata          ends
.rdata:000074BC
.data:000074C0 ; ===========================================================================
.data:000074C0
.data:000074C0 ; Segment type: Pure data
.data:000074C0 ; Segment permissions: Read/Write
.data:000074C0 _data           segment dword public 'DATA' use32
.data:000074C0                 assume cs:_data
.data:000074C0                 ;org 74C0h
.data:000074C0                 public ?__LINE__Var@?0??MakePluginWindow@@YAXAAVWindowInfo@@PAUHWND__@@@Z@4JA
.data:000074C0 ; long `void __cdecl MakePluginWindow(class WindowInfo &, struct HWND__ *)'::`1'::__LINE__Var
.data:000074C0 ?__LINE__Var@?0??MakePluginWindow@@YAXAAVWindowInfo@@PAUHWND__@@@Z@4JA dd 98h
.data:000074C0                                         ; DATA XREF: MakePluginWindow(WindowInfo &,HWND__ *)+35r
.data:000074C0                                         ; MakePluginWindow(WindowInfo &,HWND__ *)+5Ar
.data:000074C0 _data           ends
.data:000074C0
.rdata:000074C4 ; ===========================================================================
.rdata:000074C4
.rdata:000074C4 ; Segment type: Pure data
.rdata:000074C4 ; Segment permissions: Read
.rdata:000074C4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000074C4 _rdata          segment para public 'DATA' use32
.rdata:000074C4                 assume cs:_rdata
.rdata:000074C4                 ;org 74C4h
.rdata:000074C4                 public ??_C@_1GM@OAGNGMKE@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAs?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAp?$AAd?$AAf?$AA?9?$AAm?$AAa?$AAs?$AAt?$AAe?$AAr?$AA?2?$AAs@
.rdata:000074C4 ; wchar_t `string'
.rdata:000074C4 ??_C@_1GM@OAGNGMKE@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAs?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAp?$AAd?$AAf?$AA?9?$AAm?$AAa?$AAs?$AAt?$AAe?$AAr?$AA?2?$AAs@:
.rdata:000074C4                                         ; DATA XREF: MakePluginWindow(WindowInfo &,HWND__ *)+3Fo
.rdata:000074C4                                         ; MakePluginWindow(WindowInfo &,HWND__ *)+63o ...
.rdata:000074C4                 unicode 0, <c:\workspace\sumatrapdf-master\src\sumatrastartup.cpp>,0
.rdata:000074C4 _rdata          ends
.rdata:000074C4
.rdata:00007530 ; ===========================================================================
.rdata:00007530
.rdata:00007530 ; Segment type: Pure data
.rdata:00007530 ; Segment permissions: Read
.rdata:00007530 _rdata          segment dword public 'DATA' use32
.rdata:00007530                 assume cs:_rdata
.rdata:00007530                 ;org 7530h
.rdata:00007530                 public ??_C@_1CK@HMBMIIMN@?$AAI?$AAs?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$CI?$AAh?$AAw?$AAn?$AAd?$AAP?$AAa?$AAr?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
.rdata:00007530 ; wchar_t `string'
.rdata:00007530 ??_C@_1CK@HMBMIIMN@?$AAI?$AAs?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$CI?$AAh?$AAw?$AAn?$AAd?$AAP?$AAa?$AAr?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@:
.rdata:00007530                                         ; DATA XREF: MakePluginWindow(WindowInfo &,HWND__ *)+44o
.rdata:00007530                 unicode 0, <IsWindow(hwndParent)>,0
.rdata:0000755A                 align 4
.rdata:0000755A _rdata          ends
.rdata:0000755A
.rdata:0000755C ; ===========================================================================
.rdata:0000755C
.rdata:0000755C ; Segment type: Pure data
.rdata:0000755C ; Segment permissions: Read
.rdata:0000755C _rdata          segment dword public 'DATA' use32
.rdata:0000755C                 assume cs:_rdata
.rdata:0000755C                 ;org 755Ch
.rdata:0000755C                 public ??_C@_1BI@NNHHJJEP@?$AAg?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAM?$AAo?$AAd?$AAe?$AA?$AA@
.rdata:0000755C ; wchar_t `string'
.rdata:0000755C ??_C@_1BI@NNHHJJEP@?$AAg?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAM?$AAo?$AAd?$AAe?$AA?$AA@:
.rdata:0000755C                                         ; DATA XREF: MakePluginWindow(WindowInfo &,HWND__ *)+68o
.rdata:0000755C                 unicode 0, <gPluginMode>,0
.rdata:0000755C _rdata          ends
.rdata:0000755C
.rdata:00007574 ; ===========================================================================
.rdata:00007574
.rdata:00007574 ; Segment type: Pure data
.rdata:00007574 ; Segment permissions: Read
.rdata:00007574 _rdata          segment dword public 'DATA' use32
.rdata:00007574                 assume cs:_rdata
.rdata:00007574                 ;org 7574h
.rdata:00007574                 public ??_C@_1CE@PHGKLOIF@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA_?$AAP?$AAD?$AAF?$AA_?$AAF?$AAR?$AAA?$AAM?$AAE?$AA?$AA@
.rdata:00007574 ; const WCHAR `string'
.rdata:00007574 ??_C@_1CE@PHGKLOIF@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA_?$AAP?$AAD?$AAF?$AA_?$AAF?$AAR?$AAA?$AAM?$AAE?$AA?$AA@:
.rdata:00007574                                         ; DATA XREF: FindPrevInstWindow(void * *)+1BFo
.rdata:00007574                                         ; RegisterWinClass(void)+23o ...
.rdata:00007574                 unicode 0, <SUMATRA_PDF_FRAME>,0
.rdata:00007574 _rdata          ends
.rdata:00007574
.rdata:00007598 ; ===========================================================================
.rdata:00007598
.rdata:00007598 ; Segment type: Pure data
.rdata:00007598 ; Segment permissions: Read
.rdata:00007598 _rdata          segment dword public 'DATA' use32
.rdata:00007598                 assume cs:_rdata
.rdata:00007598                 ;org 7598h
.rdata:00007598                 public ??_C@_1CG@HPLMACE@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA_?$AAP?$AAD?$AAF?$AA_?$AAC?$AAA?$AAN?$AAV?$AAA?$AAS?$AA?$AA@
.rdata:00007598 ; wchar_t `string'
.rdata:00007598 ??_C@_1CG@HPLMACE@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA_?$AAP?$AAD?$AAF?$AA_?$AAC?$AAA?$AAN?$AAV?$AAA?$AAS?$AA?$AA@:
.rdata:00007598                                         ; DATA XREF: RegisterWinClass(void)+E8o
.rdata:00007598                 unicode 0, <SUMATRA_PDF_CANVAS>,0
.rdata:000075BE                 align 10h
.rdata:000075BE _rdata          ends
.rdata:000075BE
.rdata:000075C0 ; ===========================================================================
.rdata:000075C0
.rdata:000075C0 ; Segment type: Pure data
.rdata:000075C0 ; Segment permissions: Read
.rdata:000075C0 _rdata          segment dword public 'DATA' use32
.rdata:000075C0                 assume cs:_rdata
.rdata:000075C0                 ;org 75C0h
.rdata:000075C0                 public ??_C@_1CO@JNHOBPBF@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA_?$AAP?$AAD?$AAF?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@
.rdata:000075C0 ; wchar_t `string'
.rdata:000075C0 ??_C@_1CO@JNHOBPBF@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA_?$AAP?$AAD?$AAF?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@:
.rdata:000075C0                                         ; DATA XREF: RegisterWinClass(void)+14Eo
.rdata:000075C0                 unicode 0, <SUMATRA_PDF_PROPERTIES>,0
.rdata:000075EE                 align 10h
.rdata:000075EE _rdata          ends
.rdata:000075EE
.rdata:000075F0 ; ===========================================================================
.rdata:000075F0
.rdata:000075F0 ; Segment type: Pure data
.rdata:000075F0 ; Segment permissions: Read
.rdata:000075F0 _rdata          segment dword public 'DATA' use32
.rdata:000075F0                 assume cs:_rdata
.rdata:000075F0                 ;org 75F0h
.rdata:000075F0                 public ??_C@_1CM@GPNKFOGI@?$AA?$FL?$AAO?$AAp?$AAe?$AAn?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$FN?$AA?$AA@
.rdata:000075F0 ; `string'
.rdata:000075F0 ??_C@_1CM@GPNKFOGI@?$AA?$FL?$AAO?$AAp?$AAe?$AAn?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$FN?$AA?$AA@:
.rdata:000075F0                                         ; DATA XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+5Fo
.rdata:000075F0                 unicode 0, <[Open("%s", 0, 1, 0)]>,0
.rdata:000075F0 _rdata          ends
.rdata:000075F0
.rdata:0000761C ; ===========================================================================
.rdata:0000761C
.rdata:0000761C ; Segment type: Pure data
.rdata:0000761C ; Segment permissions: Read
.rdata:0000761C _rdata          segment dword public 'DATA' use32
.rdata:0000761C                 assume cs:_rdata
.rdata:0000761C                 ;org 761Ch
.rdata:0000761C                 public ??_C@_1DI@LKFLACJO@?$AA?$FL?$AAG?$AAo?$AAt?$AAo?$AAN?$AAa?$AAm?$AAe?$AAd?$AAD?$AAe?$AAs?$AAt?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$CJ?$AA?$FN?$AA?$AA@
.rdata:0000761C ; `string'
.rdata:0000761C ??_C@_1DI@LKFLACJO@?$AA?$FL?$AAG?$AAo?$AAt?$AAo?$AAN?$AAa?$AAm?$AAe?$AAd?$AAD?$AAe?$AAs?$AAt?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$CJ?$AA?$FN?$AA?$AA@:
.rdata:0000761C                                         ; DATA XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+9Eo
.rdata:0000761C                 unicode 0, <[GotoNamedDest("%s", "%s")]>,0
.rdata:0000761C _rdata          ends
.rdata:0000761C
.rdata:00007654 ; ===========================================================================
.rdata:00007654
.rdata:00007654 ; Segment type: Pure data
.rdata:00007654 ; Segment permissions: Read
.rdata:00007654 _rdata          segment dword public 'DATA' use32
.rdata:00007654                 assume cs:_rdata
.rdata:00007654                 ;org 7654h
.rdata:00007654                 public ??_C@_1CK@JBMPFIK@?$AA?$FL?$AAG?$AAo?$AAt?$AAo?$AAP?$AAa?$AAg?$AAe?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$FN?$AA?$AA@
.rdata:00007654 ; `string'
.rdata:00007654 ??_C@_1CK@JBMPFIK@?$AA?$FL?$AAG?$AAo?$AAt?$AAo?$AAP?$AAa?$AAg?$AAe?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$FN?$AA?$AA@:
.rdata:00007654                                         ; DATA XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+D9o
.rdata:00007654                 unicode 0, <[GotoPage("%s", %d)]>,0
.rdata:0000767E                 align 10h
.rdata:0000767E _rdata          ends
.rdata:0000767E
.rdata:00007680 ; ===========================================================================
.rdata:00007680
.rdata:00007680 ; Segment type: Pure data
.rdata:00007680 ; Segment permissions: Read
.rdata:00007680 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007680 _rdata          segment para public 'DATA' use32
.rdata:00007680                 assume cs:_rdata
.rdata:00007680                 ;org 7680h
.rdata:00007680                 public ??_C@_1EI@KKJLKIFH@?$AA?$FL?$AAS?$AAe?$AAt?$AAV?$AAi?$AAe?$AAw?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CF?$AA?4?$AA2?$AAf?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF@
.rdata:00007680 ; `string'
.rdata:00007680 ??_C@_1EI@KKJLKIFH@?$AA?$FL?$AAS?$AAe?$AAt?$AAV?$AAi?$AAe?$AAw?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CF?$AA?4?$AA2?$AAf?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF@:
.rdata:00007680                                         ; DATA XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+17Eo
.rdata:00007680                 unicode 0, <[SetView("%s", "%s", %.2f, %d, %d)]>,0
.rdata:00007680 _rdata          ends
.rdata:00007680
.rdata:000076C8 ; ===========================================================================
.rdata:000076C8
.rdata:000076C8 ; Segment type: Pure data
.rdata:000076C8 ; Segment permissions: Read
.rdata:000076C8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000076C8 _rdata          segment para public 'DATA' use32
.rdata:000076C8                 assume cs:_rdata
.rdata:000076C8                 ;org 76C8h
.rdata:000076C8                 public ??_C@_1FC@FIABJECI@?$AA?$FL?$AAF?$AAo?$AAr?$AAw?$AAa?$AAr?$AAd?$AAS?$AAe?$AAa?$AAr?$AAc?$AAh?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0@
.rdata:000076C8 ; `string'
.rdata:000076C8 ??_C@_1FC@FIABJECI@?$AA?$FL?$AAF?$AAo?$AAr?$AAw?$AAa?$AAr?$AAd?$AAS?$AAe?$AAa?$AAr?$AAc?$AAh?$AA?$CI?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0@:
.rdata:000076C8                                         ; DATA XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+1EBo
.rdata:000076C8                 unicode 0, <[ForwardSearch("%s", "%s", %d, 0, 0, 1)]>,0
.rdata:0000771A                 align 4
.rdata:0000771A _rdata          ends
.rdata:0000771A
.rdata:0000771C ; ===========================================================================
.rdata:0000771C
.rdata:0000771C ; Segment type: Pure data
.rdata:0000771C ; Segment permissions: Read
.rdata:0000771C _rdata          segment dword public 'DATA' use32
.rdata:0000771C                 assume cs:_rdata
.rdata:0000771C                 ;org 771Ch
.rdata:0000771C                 public ??_C@_1BA@IBGCEPCN@?$AAc?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?$AA@
.rdata:0000771C ; wchar_t `string'
.rdata:0000771C ??_C@_1BA@IBGCEPCN@?$AAc?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?$AA@:
.rdata:0000771C                                         ; DATA XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+28Eo
.rdata:0000771C                 unicode 0, <control>,0
.rdata:0000771C _rdata          ends
.rdata:0000771C
.rdata:0000772C ; ===========================================================================
.rdata:0000772C
.rdata:0000772C ; Segment type: Pure data
.rdata:0000772C ; Segment permissions: Read
.rdata:0000772C _rdata          segment dword public 'DATA' use32
.rdata:0000772C                 assume cs:_rdata
.rdata:0000772C                 ;org 772Ch
.rdata:0000772C                 public ??_C@_1BA@DNELNMNE@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA?$AA@
.rdata:0000772C ; wchar_t `string'
.rdata:0000772C ??_C@_1BA@DNELNMNE@?$AAS?$AAU?$AAM?$AAA?$AAT?$AAR?$AAA?$AA?$AA@:
.rdata:0000772C                                         ; DATA XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+293o
.rdata:0000772C                 unicode 0, <SUMATRA>,0
.rdata:0000772C _rdata          ends
.rdata:0000772C
.data:0000773C ; ===========================================================================
.data:0000773C
.data:0000773C ; Segment type: Pure data
.data:0000773C ; Segment permissions: Read/Write
.data:0000773C _data           segment dword public 'DATA' use32
.data:0000773C                 assume cs:_data
.data:0000773C                 ;org 773Ch
.data:0000773C                 public ?__LINE__Var@?0??SetupPluginMode@@YA_NAAVCommandLineInfo@@@Z@4JA
.data:0000773C ; long `bool __cdecl SetupPluginMode(class CommandLineInfo &)'::`1'::__LINE__Var
.data:0000773C ?__LINE__Var@?0??SetupPluginMode@@YA_NAAVCommandLineInfo@@@Z@4JA dd 163h
.data:0000773C                                         ; DATA XREF: SetupPluginMode(CommandLineInfo &)+88r
.data:0000773C _data           ends
.data:0000773C
.rdata:00007740 ; ===========================================================================
.rdata:00007740
.rdata:00007740 ; Segment type: Pure data
.rdata:00007740 ; Segment permissions: Read
.rdata:00007740 _rdata          segment dword public 'DATA' use32
.rdata:00007740                 assume cs:_rdata
.rdata:00007740                 ;org 7740h
.rdata:00007740                 public ??_C@_1DC@NHINHEEK@?$AAi?$AA?4?$AAf?$AAi?$AAl?$AAe?$AAN?$AAa?$AAm?$AAe?$AAs?$AA?4?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
.rdata:00007740 ; wchar_t `string'
.rdata:00007740 ??_C@_1DC@NHINHEEK@?$AAi?$AA?4?$AAf?$AAi?$AAl?$AAe?$AAN?$AAa?$AAm?$AAe?$AAs?$AA?4?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@:
.rdata:00007740                                         ; DATA XREF: SetupPluginMode(CommandLineInfo &)+96o
.rdata:00007740                 unicode 0, <i.fileNames.Count() == 1>,0
.rdata:00007772                 align 4
.rdata:00007772 _rdata          ends
.rdata:00007772
.rdata:00007774 ; ===========================================================================
.rdata:00007774
.rdata:00007774 ; Segment type: Pure data
.rdata:00007774 ; Segment permissions: Read
.rdata:00007774 _rdata          segment dword public 'DATA' use32
.rdata:00007774                 assume cs:_rdata
.rdata:00007774                 ;org 7774h
.rdata:00007774                 public ??_C@_13FLOCNAAB@?$AA?$CG?$AA?$AA@
.rdata:00007774 ; wchar_t `string'
.rdata:00007774 ??_C@_13FLOCNAAB@?$AA?$CG?$AA?$AA@ dd offset ?gFileExistenceChecker@@3PAVFileExistenceChecker@@A+2
.rdata:00007774                                         ; DATA XREF: SetupPluginMode(CommandLineInfo &)+1C3o
.rdata:00007774                                         ; SetupPluginMode(CommandLineInfo &)+1E8o
.rdata:00007774 _rdata          ends
.rdata:00007774
.rdata:00007778 ; ===========================================================================
.rdata:00007778
.rdata:00007778 ; Segment type: Pure data
.rdata:00007778 ; Segment permissions: Read
.rdata:00007778 _rdata          segment dword public 'DATA' use32
.rdata:00007778                 assume cs:_rdata
.rdata:00007778                 ;org 7778h
.rdata:00007778                 public ??_C@_13GMDMCADD@?$AA?$CD?$AA?$AA@
.rdata:00007778 ; wchar_t `string'
.rdata:00007778 ??_C@_13GMDMCADD@?$AA?$CD?$AA?$AA@ dd offset unk_23
.rdata:00007778                                         ; DATA XREF: SetupPluginMode(CommandLineInfo &)+1C8o
.rdata:00007778 _rdata          ends
.rdata:00007778
.rdata:0000777C ; ===========================================================================
.rdata:0000777C
.rdata:0000777C ; Segment type: Pure data
.rdata:0000777C ; Segment permissions: Read
.rdata:0000777C _rdata          segment dword public 'DATA' use32
.rdata:0000777C                 assume cs:_rdata
.rdata:0000777C                 ;org 777Ch
.rdata:0000777C                 public ??_C@_1M@BOBDMABN@?$AAp?$AAa?$AAg?$AAe?$AA?$DN?$AA?$AA@
.rdata:0000777C ; wchar_t `string'
.rdata:0000777C ??_C@_1M@BOBDMABN@?$AAp?$AAa?$AAg?$AAe?$AA?$DN?$AA?$AA@:
.rdata:0000777C                                         ; DATA XREF: SetupPluginMode(CommandLineInfo &)+232o
.rdata:0000777C                 unicode 0, <page=>,0
.rdata:0000777C _rdata          ends
.rdata:0000777C
.rdata:00007788 ; ===========================================================================
.rdata:00007788
.rdata:00007788 ; Segment type: Pure data
.rdata:00007788 ; Segment permissions: Read
.rdata:00007788 _rdata          segment dword public 'DATA' use32
.rdata:00007788                 assume cs:_rdata
.rdata:00007788                 ;org 7788h
.rdata:00007788                 public ??_C@_1M@ILEIMEED@?$AA?$DN?$AA?$CF?$AAd?$AA?$CF?$AA$?$AA?$AA@
.rdata:00007788 ; wchar_t `string'
.rdata:00007788 ??_C@_1M@ILEIMEED@?$AA?$DN?$AA?$CF?$AAd?$AA?$CF?$AA$?$AA?$AA@:
.rdata:00007788                                         ; DATA XREF: SetupPluginMode(CommandLineInfo &)+251o
.rdata:00007788                 unicode 0, <=%d%$>,0
.rdata:00007788 _rdata          ends
.rdata:00007788
.rdata:00007794 ; ===========================================================================
.rdata:00007794
.rdata:00007794 ; Segment type: Pure data
.rdata:00007794 ; Segment permissions: Read
.rdata:00007794 _rdata          segment dword public 'DATA' use32
.rdata:00007794                 assume cs:_rdata
.rdata:00007794                 ;org 7794h
.rdata:00007794                 public ??_C@_1BG@PKGIHOED@?$AAn?$AAa?$AAm?$AAe?$AAd?$AAd?$AAe?$AAs?$AAt?$AA?$DN?$AA?$AA@
.rdata:00007794 ; wchar_t `string'
.rdata:00007794 ??_C@_1BG@PKGIHOED@?$AAn?$AAa?$AAm?$AAe?$AAd?$AAd?$AAe?$AAs?$AAt?$AA?$DN?$AA?$AA@:
.rdata:00007794                                         ; DATA XREF: SetupPluginMode(CommandLineInfo &):loc_5AA1o
.rdata:00007794                 unicode 0, <nameddest=>,0
.rdata:000077AA                 align 4
.rdata:000077AA _rdata          ends
.rdata:000077AA
.rdata:000077AC ; ===========================================================================
.rdata:000077AC
.rdata:000077AC ; Segment type: Pure data
.rdata:000077AC ; Segment permissions: Read
.rdata:000077AC _rdata          segment dword public 'DATA' use32
.rdata:000077AC                 assume cs:_rdata
.rdata:000077AC                 ;org 77ACh
.rdata:000077AC                 public ??_C@_1CG@PBNBCKFL@?$AAS?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAP?$AAD?$AAF?$AA?9?$AAs?$AAy?$AAm?$AAb?$AAo?$AAl?$AAs?$AA?$AA@
.rdata:000077AC ; wchar_t `string'
.rdata:000077AC ??_C@_1CG@PBNBCKFL@?$AAS?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAP?$AAD?$AAF?$AA?9?$AAs?$AAy?$AAm?$AAb?$AAo?$AAl?$AAs?$AA?$AA@:
.rdata:000077AC                                         ; DATA XREF: SetupCrashHandler(void)+45o
.rdata:000077AC                                         ; SetupCrashHandler(void):loc_5756o
.rdata:000077AC                 unicode 0, <SumatraPDF-symbols>,0
.rdata:000077D2                 align 4
.rdata:000077D2 _rdata          ends
.rdata:000077D2
.rdata:000077D4 ; ===========================================================================
.rdata:000077D4
.rdata:000077D4 ; Segment type: Pure data
.rdata:000077D4 ; Segment permissions: Read
.rdata:000077D4 _rdata          segment dword public 'DATA' use32
.rdata:000077D4                 assume cs:_rdata
.rdata:000077D4                 ;org 77D4h
.rdata:000077D4                 public ??_C@_1CI@KINBKILN@?$AAs?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAp?$AAd?$AAf?$AAc?$AAr?$AAa?$AAs?$AAh?$AA?4?$AAd?$AAm?$AAp?$AA?$AA@
.rdata:000077D4 ; wchar_t `string'
.rdata:000077D4 ??_C@_1CI@KINBKILN@?$AAs?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAp?$AAd?$AAf?$AAc?$AAr?$AAa?$AAs?$AAh?$AA?4?$AAd?$AAm?$AAp?$AA?$AA@:
.rdata:000077D4                                         ; DATA XREF: SetupCrashHandler(void):loc_576Co
.rdata:000077D4                 unicode 0, <sumatrapdfcrash.dmp>,0
.rdata:000077D4 _rdata          ends
.rdata:000077D4
.rdata:000077FC ; ===========================================================================
.rdata:000077FC
.rdata:000077FC ; Segment type: Pure data
.rdata:000077FC ; Segment permissions: Read
.rdata:000077FC _rdata          segment dword public 'DATA' use32
.rdata:000077FC                 assume cs:_rdata
.rdata:000077FC                 ;org 77FCh
.rdata:000077FC                 public ??_C@_1CA@IEDCKEJO@?$AAS?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAP?$AAD?$AAF?$AA?9?$AA?$CF?$AA0?$AA8?$AAx?$AA?$AA@
.rdata:000077FC ; str `string'
.rdata:000077FC ??_C@_1CA@IEDCKEJO@?$AAS?$AAu?$AAm?$AAa?$AAt?$AAr?$AAa?$AAP?$AAD?$AAF?$AA?9?$AA?$CF?$AA0?$AA8?$AAx?$AA?$AA@:
.rdata:000077FC                                         ; DATA XREF: FindPrevInstWindow(void * *)+69o
.rdata:000077FC                 unicode 0, <SumatraPDF-%08x>,0
.rdata:000077FC _rdata          ends
.rdata:000077FC
.rdata:0000781C ; ===========================================================================
.rdata:0000781C
.rdata:0000781C ; Segment type: Pure data
.rdata:0000781C ; Segment permissions: Read
.rdata:0000781C _rdata          segment dword public 'DATA' use32
.rdata:0000781C                 assume cs:_rdata
.rdata:0000781C                 ;org 781Ch
.rdata:0000781C                 public ??_C@_19GMJJNAOJ@?$AA?4?$AAp?$AAd?$AAf?$AA?$AA@
.rdata:0000781C ; const WCHAR `string'
.rdata:0000781C ??_C@_19GMJJNAOJ@?$AA?4?$AAp?$AAd?$AAf?$AA?$AA@:
.rdata:0000781C                                         ; DATA XREF: RegisterForPdfExtentions(HWND__ *)+8Eo
.rdata:0000781C                                         ; RegisterForPdfExtentions(HWND__ *):loc_4C20o ...
.rdata:0000781C                 unicode 0, <.pdf>,0
.rdata:00007826                 align 4
.rdata:00007826 _rdata          ends
.rdata:00007826
.data:00007828 ; ===========================================================================
.data:00007828
.data:00007828 ; Segment type: Pure data
.data:00007828 ; Segment permissions: Read/Write
.data:00007828 _data           segment dword public 'DATA' use32
.data:00007828                 assume cs:_data
.data:00007828                 ;org 7828h
.data:00007828                 public ?__LINE__Var@?0??WinMain@@9@16@4JA
.data:00007828 ?__LINE__Var@?0??WinMain@@9@16@4JA dd 23Fh ; DATA XREF: WinMain(x,x,x,x)+A10r
.data:00007828 _data           ends
.data:00007828
.rdata:0000782C ; ===========================================================================
.rdata:0000782C
.rdata:0000782C ; Segment type: Pure data
.rdata:0000782C ; Segment permissions: Read
.rdata:0000782C _rdata          segment dword public 'DATA' use32
.rdata:0000782C                 assume cs:_rdata
.rdata:0000782C                 ;org 782Ch
.rdata:0000782C                 public ??_C@_01GFHCPBMG@C?$AA@
.rdata:0000782C ; `string'
.rdata:0000782C ??_C@_01GFHCPBMG@C?$AA@ db  43h ; C     ; DATA XREF: WinMain(x,x,x,x)+75o
.rdata:0000782D                 db    0
.rdata:0000782E                 align 10h
.rdata:0000782E _rdata          ends
.rdata:0000782E
.rdata:00007830 ; ===========================================================================
.rdata:00007830
.rdata:00007830 ; Segment type: Pure data
.rdata:00007830 ; Segment permissions: Read
.rdata:00007830 _rdata          segment dword public 'DATA' use32
.rdata:00007830                 assume cs:_rdata
.rdata:00007830                 ;org 7830h
.rdata:00007830                 public ??_C@_07PDKPIFNG@?1tester?$AA@
.rdata:00007830 ; `string'
.rdata:00007830 ??_C@_07PDKPIFNG@?1tester?$AA@ db '/tester',0
.rdata:00007830                                         ; DATA XREF: WinMain(x,x,x,x)+98o
.rdata:00007830 _rdata          ends
.rdata:00007830
.rdata:00007838 ; ===========================================================================
.rdata:00007838
.rdata:00007838 ; Segment type: Pure data
.rdata:00007838 ; Segment permissions: Read
.rdata:00007838 _rdata          segment dword public 'DATA' use32
.rdata:00007838                 assume cs:_rdata
.rdata:00007838                 ;org 7838h
.rdata:00007838                 public ??_C@_08LLPLCEMM@?1regress?$AA@
.rdata:00007838 ; `string'
.rdata:00007838 ??_C@_08LLPLCEMM@?1regress?$AA@ db '/regress',0
.rdata:00007838                                         ; DATA XREF: WinMain(x,x,x,x):loc_68AAo
.rdata:00007841                 align 4
.rdata:00007841 _rdata          ends
.rdata:00007841
.rdata:00007844 ; ===========================================================================
.rdata:00007844
.rdata:00007844 ; Segment type: Pure data
.rdata:00007844 ; Segment permissions: Read
.rdata:00007844 _rdata          segment dword public 'DATA' use32
.rdata:00007844                 assume cs:_rdata
.rdata:00007844                 ;org 7844h
.rdata:00007844                 public ??_C@_05PDJBBECF@pause?$AA@
.rdata:00007844 ; char `string'[]
.rdata:00007844 ??_C@_05PDJBBECF@pause?$AA@ db 'pause',0 ; DATA XREF: WinMain(x,x,x,x)+218o
.rdata:0000784A                 align 4
.rdata:0000784A _rdata          ends
.rdata:0000784A
.rdata:0000784C ; ===========================================================================
.rdata:0000784C
.rdata:0000784C ; Segment type: Pure data
.rdata:0000784C ; Segment permissions: Read
.rdata:0000784C _rdata          segment dword public 'DATA' use32
.rdata:0000784C                 assume cs:_rdata
.rdata:0000784C                 ;org 784Ch
.rdata:0000784C                 public ??_C@_03ICICOMAL@yes?$AA@
.rdata:0000784C ; char `string'[4]
.rdata:0000784C ??_C@_03ICICOMAL@yes?$AA@ db 'yes',0    ; DATA XREF: WinMain(x,x,x,x)+544o
.rdata:0000784C _rdata          ends
.rdata:0000784C
.rdata:00007850 ; ===========================================================================
.rdata:00007850
.rdata:00007850 ; Segment type: Pure data
.rdata:00007850 ; Segment permissions: Read
.rdata:00007850 _rdata          segment dword public 'DATA' use32
.rdata:00007850                 assume cs:_rdata
.rdata:00007850                 ;org 7850h
.rdata:00007850                 public ??_C@_04LOAJBDKD@true?$AA@
.rdata:00007850 ; char `string'[]
.rdata:00007850 ??_C@_04LOAJBDKD@true?$AA@ db 'true',0  ; DATA XREF: WinMain(x,x,x,x)+561o
.rdata:00007855                 align 4
.rdata:00007855 _rdata          ends
.rdata:00007855
.rdata:00007858 ; ===========================================================================
.rdata:00007858
.rdata:00007858 ; Segment type: Pure data
.rdata:00007858 ; Segment permissions: Read
.rdata:00007858 _rdata          segment dword public 'DATA' use32
.rdata:00007858                 assume cs:_rdata
.rdata:00007858                 ;org 7858h
.rdata:00007858                 public ??_C@_04HAPDLBFF@auto?$AA@
.rdata:00007858 ; char `string'[]
.rdata:00007858 ??_C@_04HAPDLBFF@auto?$AA@ db 'auto',0  ; DATA XREF: WinMain(x,x,x,x)+57Eo
.rdata:0000785D                 align 10h
.rdata:0000785D _rdata          ends
.rdata:0000785D
.rdata:00007860 ; ===========================================================================
.rdata:00007860
.rdata:00007860 ; Segment type: Pure data
.rdata:00007860 ; Segment permissions: Read
.rdata:00007860 _rdata          segment dword public 'DATA' use32
.rdata:00007860                 assume cs:_rdata
.rdata:00007860                 ;org 7860h
.rdata:00007860                 public ??_C@_1BI@HAGDNPLN@?$AAS?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn?$AAD?$AAa?$AAt?$AAa?$AA?$AA@
.rdata:00007860 ; wchar_t `string'
.rdata:00007860 ??_C@_1BI@HAGDNPLN@?$AAS?$AAe?$AAs?$AAs?$AAi?$AAo?$AAn?$AAD?$AAa?$AAt?$AAa?$AA?$AA@:
.rdata:00007860                                         ; DATA XREF: WinMain(x,x,x,x)+5F7o
.rdata:00007860                 unicode 0, <SessionData>,0
.rdata:00007860 _rdata          ends
.rdata:00007860
.rdata:00007878 ; ===========================================================================
.rdata:00007878
.rdata:00007878 ; Segment type: Pure data
.rdata:00007878 ; Segment permissions: Read
.rdata:00007878 _rdata          segment dword public 'DATA' use32
.rdata:00007878                 assume cs:_rdata
.rdata:00007878                 ;org 7878h
.rdata:00007878                 public ??_C@_0DG@CPCMILPH@c?3?2workspace?2sumatrapdf?9master?2s@
.rdata:00007878 ; char `string'[]
.rdata:00007878 ??_C@_0DG@CPCMILPH@c?3?2workspace?2sumatrapdf?9master?2s@ db 'c:\workspace\sumatrapdf-master\src\sumatrastartup.cpp',0
.rdata:00007878                                         ; DATA XREF: WinMain(x,x,x,x)+A1Bo
.rdata:000078AE                 align 10h
.rdata:000078AE _rdata          ends
.rdata:000078AE
.rdata:000078B0 ; ===========================================================================
.rdata:000078B0
.rdata:000078B0 ; Segment type: Pure data
.rdata:000078B0 ; Segment permissions: Read
.rdata:000078B0 _rdata          segment dword public 'DATA' use32
.rdata:000078B0                 assume cs:_rdata
.rdata:000078B0                 ;org 78B0h
.rdata:000078B0                 public ??_7?$_Func_base@X$$V@std@@6B@
.rdata:000078B0 ??_7?$_Func_base@X$$V@std@@6B@ dd offset __purecall
.rdata:000078B0                                         ; DATA XREF: ??0?$_Func_base@X$$V@std@@QAE@XZ+26o
.rdata:000078B0                                         ; ??1?$_Func_base@X$$V@std@@QAE@XZ+26o
.rdata:000078B4                 dd offset __purecall
.rdata:000078B8                 dd offset __purecall
.rdata:000078BC                 dd offset __purecall
.rdata:000078C0                 dd offset __purecall
.rdata:000078C4                 dd offset __purecall
.rdata:000078C4 _rdata          ends
.rdata:000078C4
.rdata:000078C8 ; ===========================================================================
.rdata:000078C8
.rdata:000078C8 ; Segment type: Pure data
.rdata:000078C8 ; Segment permissions: Read
.rdata:000078C8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000078C8 _rdata          segment para public 'DATA' use32
.rdata:000078C8                 assume cs:_rdata
.rdata:000078C8                 ;org 78C8h
.rdata:000078C8                 public ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000078C8 ; wchar_t `string'
.rdata:000078C8 ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000078C8                                         ; DATA XREF: std::max<uint>(uint const &,uint const &)+23o
.rdata:000078C8                 unicode 0, <c:\program files (x86)\microsoft visual studio 14.0\vc\in>
.rdata:000078C8                 unicode 0, <clude\algorithm>,0
.rdata:0000795A                 align 4
.rdata:0000795A _rdata          ends
.rdata:0000795A
.rdata:0000795C ; ===========================================================================
.rdata:0000795C
.rdata:0000795C ; Segment type: Pure data
.rdata:0000795C ; Segment permissions: Read
.rdata:0000795C _rdata          segment dword public 'DATA' use32
.rdata:0000795C                 assume cs:_rdata
.rdata:0000795C                 ;org 795Ch
.rdata:0000795C                 public ??_7?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@6B@
.rdata:0000795C ??_7?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@6B@ dd offset ?_Copy@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEPAV?$_Func_base@X$$V@2@PAX@Z
.rdata:0000795C                                         ; DATA XREF: ??$?0ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+2Eo
.rdata:0000795C                                         ; ??$?0V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+2Eo ...
.rdata:00007960                 dd offset ?_Move@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEPAV?$_Func_base@X$$V@2@PAX@Z
.rdata:00007964                 dd offset ?_Do_call@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEXXZ
.rdata:00007968                 dd offset ?_Target_type@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEABVtype_info@@XZ
.rdata:0000796C                 dd offset ?_Delete_this@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EAEX_N@Z
.rdata:00007970                 dd offset ?_Get@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEPBXXZ
.rdata:00007970 _rdata          ends
.rdata:00007970
.rdata:00007974 ; ===========================================================================
.rdata:00007974
.rdata:00007974 ; Segment type: Pure data
.rdata:00007974 ; Segment permissions: Read
.rdata:00007974 _rdata          segment dword public 'DATA' use32
.rdata:00007974                 assume cs:_rdata
.rdata:00007974                 ;org 7974h
.rdata:00007974                 public ??_C@_1CG@LEJCKCBB@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$AA@
.rdata:00007974 ; wchar_t `string'
.rdata:00007974 ??_C@_1CG@LEJCKCBB@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$AA@:
.rdata:00007974                                         ; DATA XREF: std::_Debug_lt_pred<std::less<void>,uint const &,uint const &>(std::less<void>,uint const &,uint const &,wchar_t const *,uint)+5Do
.rdata:00007974                 unicode 0, <invalid comparator>,0
.rdata:0000799A                 align 4
.rdata:0000799A _rdata          ends
.rdata:0000799A
.data$r:0000799C ; ===========================================================================
.data$r:0000799C
.data$r:0000799C ; Segment type: Pure data
.data$r:0000799C ; Segment permissions: Read/Write
.data$r:0000799C _data$r         segment dword public 'DATA' use32
.data$r:0000799C                 assume cs:_data$r
.data$r:0000799C                 ;org 799Ch
.data$r:0000799C                 public ??_R0?AV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@8
.data$r:0000799C ; class _lambda_b6f3cb1c717d8c8a816f87295491882e_ `RTTI Type Descriptor'
.data$r:0000799C ??_R0?AV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@@8 dd offset ??_7type_info@@6B@
.data$r:0000799C                                         ; DATA XREF: ?_Target_type@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@EBEABVtype_info@@XZ+23o
.data$r:0000799C                                         ; const type_info::`vftable'
.data$r:000079A0                 db    0
.data$r:000079A1                 db    0
.data$r:000079A2                 db    0
.data$r:000079A3                 db    0
.data$r:000079A4                 db  2Eh ; .
.data$r:000079A5                 db  3Fh ; ?
.data$r:000079A6                 db  41h ; A
.data$r:000079A7                 db  56h ; V
.data$r:000079A8                 db  3Ch ; <
.data$r:000079A9                 db  6Ch ; l
.data$r:000079AA                 db  61h ; a
.data$r:000079AB                 db  6Dh ; m
.data$r:000079AC                 db  62h ; b
.data$r:000079AD                 db  64h ; d
.data$r:000079AE                 db  61h ; a
.data$r:000079AF                 db  5Fh ; _
.data$r:000079B0                 db  62h ; b
.data$r:000079B1                 db  36h ; 6
.data$r:000079B2                 db  66h ; f
.data$r:000079B3                 db  33h ; 3
.data$r:000079B4                 db  63h ; c
.data$r:000079B5                 db  62h ; b
.data$r:000079B6                 db  31h ; 1
.data$r:000079B7                 db  63h ; c
.data$r:000079B8                 db  37h ; 7
.data$r:000079B9                 db  31h ; 1
.data$r:000079BA                 db  37h ; 7
.data$r:000079BB                 db  64h ; d
.data$r:000079BC                 db  38h ; 8
.data$r:000079BD                 db  63h ; c
.data$r:000079BE                 db  38h ; 8
.data$r:000079BF                 db  61h ; a
.data$r:000079C0                 db  38h ; 8
.data$r:000079C1                 db  31h ; 1
.data$r:000079C2                 db  36h ; 6
.data$r:000079C3                 db  66h ; f
.data$r:000079C4                 db  38h ; 8
.data$r:000079C5                 db  37h ; 7
.data$r:000079C6                 db  32h ; 2
.data$r:000079C7                 db  39h ; 9
.data$r:000079C8                 db  35h ; 5
.data$r:000079C9                 db  34h ; 4
.data$r:000079CA                 db  39h ; 9
.data$r:000079CB                 db  31h ; 1
.data$r:000079CC                 db  38h ; 8
.data$r:000079CD                 db  38h ; 8
.data$r:000079CE                 db  32h ; 2
.data$r:000079CF                 db  65h ; e
.data$r:000079D0                 db  3Eh ; >
.data$r:000079D1                 db  40h ; @
.data$r:000079D2                 db  40h ; @
.data$r:000079D3                 db    0
.data$r:000079D3 _data$r         ends
.data$r:000079D3
.rdata:000079D4 ; ===========================================================================
.rdata:000079D4
.rdata:000079D4 ; Segment type: Pure data
.rdata:000079D4 ; Segment permissions: Read
.rdata:000079D4 _rdata          segment dword public 'DATA' use32
.rdata:000079D4                 assume cs:_rdata
.rdata:000079D4                 ;org 79D4h
.rdata:000079D4                 public ??_C@_0CG@FHBDFCGK@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5sizeof?5@
.rdata:000079D4 ; `string'
.rdata:000079D4 ??_C@_0CG@FHBDFCGK@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5sizeof?5@ db '_Count <= (size_t)(-1) / sizeof (_Ty)',0
.rdata:000079D4                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+27o
.rdata:000079FA                 align 4
.rdata:000079FA _rdata          ends
.rdata:000079FA
.rdata:000079FC ; ===========================================================================
.rdata:000079FC
.rdata:000079FC ; Segment type: Pure data
.rdata:000079FC ; Segment permissions: Read
.rdata:000079FC ; Segment alignment 'qword' can not be represented in assembly
.rdata:000079FC _rdata          segment para public 'DATA' use32
.rdata:000079FC                 assume cs:_rdata
.rdata:000079FC                 ;org 79FCh
.rdata:000079FC                 public ??_C@_1FK@EJGLHMGC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf@
.rdata:000079FC ; `string'
.rdata:000079FC ??_C@_1FK@EJGLHMGC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf@:
.rdata:000079FC                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z:loc_5D8o
.rdata:000079FC                 unicode 0, <"_Count >
.rdata:000079FC                 dw 3Ch
.rdata:000079FC                 unicode 0, <= (size_t)(-1) / sizeof (_Ty)" && 0>,0
.rdata:00007A56                 align 4
.rdata:00007A56 _rdata          ends
.rdata:00007A56
.rdata:00007A58 ; ===========================================================================
.rdata:00007A58
.rdata:00007A58 ; Segment type: Pure data
.rdata:00007A58 ; Segment permissions: Read
.rdata:00007A58 _rdata          segment dword public 'DATA' use32
.rdata:00007A58                 assume cs:_rdata
.rdata:00007A58                 ;org 7A58h
.rdata:00007A58                 public ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
.rdata:00007A58 ; `string'
.rdata:00007A58 ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@:
.rdata:00007A58                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+39o
.rdata:00007A58                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+A8o ...
.rdata:00007A58                 unicode 0, <%ls>,0
.rdata:00007A58 _rdata          ends
.rdata:00007A58
.rdata:00007A60 ; ===========================================================================
.rdata:00007A60
.rdata:00007A60 ; Segment type: Pure data
.rdata:00007A60 ; Segment permissions: Read
.rdata:00007A60 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007A60 _rdata          segment para public 'DATA' use32
.rdata:00007A60                 assume cs:_rdata
.rdata:00007A60                 ;org 7A60h
.rdata:00007A60                 public ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00007A60 ; `string'
.rdata:00007A60 ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00007A60                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+42o
.rdata:00007A60                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+5Bo ...
.rdata:00007A60                 unicode 0, <c:\program files (x86)\microsoft visual studio 14.0\vc\in>
.rdata:00007A60                 unicode 0, <clude\xmemory0>,0
.rdata:00007A60 _rdata          ends
.rdata:00007A60
.rdata:00007AF0 ; ===========================================================================
.rdata:00007AF0
.rdata:00007AF0 ; Segment type: Pure data
.rdata:00007AF0 ; Segment permissions: Read
.rdata:00007AF0 _rdata          segment dword public 'DATA' use32
.rdata:00007AF0                 assume cs:_rdata
.rdata:00007AF0                 ;org 7AF0h
.rdata:00007AF0                 public ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
.rdata:00007AF0 ; `string'
.rdata:00007AF0 ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@:
.rdata:00007AF0                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+60o
.rdata:00007AF0                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+CFo ...
.rdata:00007AF0                 unicode 0, <std::_Deallocate>,0
.rdata:00007B12                 align 4
.rdata:00007B12 _rdata          ends
.rdata:00007B12
.rdata:00007B14 ; ===========================================================================
.rdata:00007B14
.rdata:00007B14 ; Segment type: Pure data
.rdata:00007B14 ; Segment permissions: Read
.rdata:00007B14 _rdata          segment dword public 'DATA' use32
.rdata:00007B14                 assume cs:_rdata
.rdata:00007B14                 ;org 7B14h
.rdata:00007B14                 public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
.rdata:00007B14 ; `string'
.rdata:00007B14 ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
.rdata:00007B14                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+65o
.rdata:00007B14                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+D4o ...
.rdata:00007B14                 unicode 0, <"invalid argument">,0
.rdata:00007B3A                 align 4
.rdata:00007B3A _rdata          ends
.rdata:00007B3A
.rdata:00007B3C ; ===========================================================================
.rdata:00007B3C
.rdata:00007B3C ; Segment type: Pure data
.rdata:00007B3C ; Segment permissions: Read
.rdata:00007B3C _rdata          segment dword public 'DATA' use32
.rdata:00007B3C                 assume cs:_rdata
.rdata:00007B3C                 ;org 7B3Ch
.rdata:00007B3C                 public ??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@
.rdata:00007B3C ; `string'
.rdata:00007B3C ??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@ db '(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0',0
.rdata:00007B3C                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+96o
.rdata:00007B6F                 align 10h
.rdata:00007B6F _rdata          ends
.rdata:00007B6F
.rdata:00007B70 ; ===========================================================================
.rdata:00007B70
.rdata:00007B70 ; Segment type: Pure data
.rdata:00007B70 ; Segment permissions: Read
.rdata:00007B70 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007B70 _rdata          segment para public 'DATA' use32
.rdata:00007B70                 assume cs:_rdata
.rdata:00007B70                 ;org 7B70h
.rdata:00007B70                 public ??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@
.rdata:00007B70 ; `string'
.rdata:00007B70 ??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@:
.rdata:00007B70                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z:loc_647o
.rdata:00007B70                 unicode 0, <"(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0" && 0>
.rdata:00007B70 _rdata          ends
.rdata:00007B70
.rdata:00007BE4 ; ===========================================================================
.rdata:00007BE4
.rdata:00007BE4 ; Segment type: Pure data
.rdata:00007BE4 ; Segment permissions: Read
.rdata:00007BE4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007BE4 _rdata          segment para public 'DATA' use32
.rdata:00007BE4                 assume cs:_rdata
.rdata:00007BE4                 ;org 7BE4h
.rdata:00007BE4                 public ??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@
.rdata:00007BE4 ; `string'
.rdata:00007BE4 ??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@ db 'reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == _BIG_ALLOCATION_SE'
.rdata:00007BE4                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+106o
.rdata:00007BE4                 db 'NTINEL',0
.rdata:00007BE4 _rdata          ends
.rdata:00007BE4
.rdata:00007C2C ; ===========================================================================
.rdata:00007C2C
.rdata:00007C2C ; Segment type: Pure data
.rdata:00007C2C ; Segment permissions: Read
.rdata:00007C2C ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007C2C _rdata          segment para public 'DATA' use32
.rdata:00007C2C                 assume cs:_rdata
.rdata:00007C2C                 ;org 7C2Ch
.rdata:00007C2C                 public ??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@
.rdata:00007C2C ; `string'
.rdata:00007C2C ??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@:
.rdata:00007C2C                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z:loc_6B7o
.rdata:00007C2C                 unicode 0, <"reinterpret_cast>
.rdata:00007C2C                 dw 3Ch
.rdata:00007C2C                 unicode 0, <uintptr_t *>
.rdata:00007C2C                 dw 3Eh
.rdata:00007C2C                 unicode 0, <(_Ptr_ptr)[-1] == _BIG_ALLOCATION_SENTINEL" && 0>,0
.rdata:00007CCA                 align 4
.rdata:00007CCA _rdata          ends
.rdata:00007CCA
.rdata:00007CCC ; ===========================================================================
.rdata:00007CCC
.rdata:00007CCC ; Segment type: Pure data
.rdata:00007CCC ; Segment permissions: Read
.rdata:00007CCC _rdata          segment dword public 'DATA' use32
.rdata:00007CCC                 assume cs:_rdata
.rdata:00007CCC                 ;org 7CCCh
.rdata:00007CCC                 public ??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@
.rdata:00007CCC ; `string'
.rdata:00007CCC ??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@ db '_Ptr_container < _Ptr_user',0
.rdata:00007CCC                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+159o
.rdata:00007CE7                 align 4
.rdata:00007CE7 _rdata          ends
.rdata:00007CE7
.rdata:00007CE8 ; ===========================================================================
.rdata:00007CE8
.rdata:00007CE8 ; Segment type: Pure data
.rdata:00007CE8 ; Segment permissions: Read
.rdata:00007CE8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007CE8 _rdata          segment para public 'DATA' use32
.rdata:00007CE8                 assume cs:_rdata
.rdata:00007CE8                 ;org 7CE8h
.rdata:00007CE8                 public ??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
.rdata:00007CE8 ; `string'
.rdata:00007CE8 ??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@:
.rdata:00007CE8                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z:loc_70Ao
.rdata:00007CE8                 unicode 0, <"_Ptr_container >
.rdata:00007CE8                 dw 3Ch
.rdata:00007CE8                 unicode 0, < _Ptr_user" && 0>,0
.rdata:00007CE8 _rdata          ends
.rdata:00007CE8
.rdata:00007D2C ; ===========================================================================
.rdata:00007D2C
.rdata:00007D2C ; Segment type: Pure data
.rdata:00007D2C ; Segment permissions: Read
.rdata:00007D2C _rdata          segment dword public 'DATA' use32
.rdata:00007D2C                 assume cs:_rdata
.rdata:00007D2C                 ;org 7D2Ch
.rdata:00007D2C                 public ??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@
.rdata:00007D2C ; `string'
.rdata:00007D2C ??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@ db '2 * sizeof(void *) <= _Ptr_user - _Ptr_container',0
.rdata:00007D2C                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+1AFo
.rdata:00007D5D                 align 10h
.rdata:00007D5D _rdata          ends
.rdata:00007D5D
.rdata:00007D60 ; ===========================================================================
.rdata:00007D60
.rdata:00007D60 ; Segment type: Pure data
.rdata:00007D60 ; Segment permissions: Read
.rdata:00007D60 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007D60 _rdata          segment para public 'DATA' use32
.rdata:00007D60                 assume cs:_rdata
.rdata:00007D60                 ;org 7D60h
.rdata:00007D60                 public ??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@
.rdata:00007D60 ; `string'
.rdata:00007D60 ??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@:
.rdata:00007D60                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z:loc_760o
.rdata:00007D60                 unicode 0, <"2 * sizeof(void *) >
.rdata:00007D60                 dw 3Ch
.rdata:00007D60                 unicode 0, <= _Ptr_user - _Ptr_container" && 0>,0
.rdata:00007D60 _rdata          ends
.rdata:00007D60
.rdata:00007DD0 ; ===========================================================================
.rdata:00007DD0
.rdata:00007DD0 ; Segment type: Pure data
.rdata:00007DD0 ; Segment permissions: Read
.rdata:00007DD0 _rdata          segment dword public 'DATA' use32
.rdata:00007DD0                 assume cs:_rdata
.rdata:00007DD0                 ;org 7DD0h
.rdata:00007DD0                 public ??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@
.rdata:00007DD0 ; `string'
.rdata:00007DD0 ??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@ db '_Ptr_user - _Ptr_container <= _NON_USER_SIZE',0
.rdata:00007DD0                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+205o
.rdata:00007DFD                 align 10h
.rdata:00007DFD _rdata          ends
.rdata:00007DFD
.rdata:00007E00 ; ===========================================================================
.rdata:00007E00
.rdata:00007E00 ; Segment type: Pure data
.rdata:00007E00 ; Segment permissions: Read
.rdata:00007E00 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007E00 _rdata          segment para public 'DATA' use32
.rdata:00007E00                 assume cs:_rdata
.rdata:00007E00                 ;org 7E00h
.rdata:00007E00                 public ??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@
.rdata:00007E00 ; `string'
.rdata:00007E00 ??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@:
.rdata:00007E00                                         ; DATA XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z:loc_7B6o
.rdata:00007E00                 unicode 0, <"_Ptr_user - _Ptr_container >
.rdata:00007E00                 dw 3Ch
.rdata:00007E00                 unicode 0, <= _NON_USER_SIZE" && 0>,0
.rdata:00007E00 _rdata          ends
.rdata:00007E00
.rtc$IMZ:00007E68 ; ===========================================================================
.rtc$IMZ:00007E68
.rtc$IMZ:00007E68 ; Segment type: Pure data
.rtc$IMZ:00007E68 ; Segment permissions: Read
.rtc$IMZ:00007E68 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00007E68                 assume cs:_rtc$IMZ
.rtc$IMZ:00007E68                 ;org 7E68h
.rtc$IMZ:00007E68 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00007E68 _rtc$IMZ        ends
.rtc$IMZ:00007E68
.rtc$TMZ:00007E6C ; ===========================================================================
.rtc$TMZ:00007E6C
.rtc$TMZ:00007E6C ; Segment type: Pure data
.rtc$TMZ:00007E6C ; Segment permissions: Read
.rtc$TMZ:00007E6C _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00007E6C                 assume cs:_rtc$TMZ
.rtc$TMZ:00007E6C                 ;org 7E6Ch
.rtc$TMZ:00007E6C __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00007E6C _rtc$TMZ        ends
.rtc$TMZ:00007E6C
.rdata:00007E70 ; ===========================================================================
.rdata:00007E70
.rdata:00007E70 ; Segment type: Pure data
.rdata:00007E70 ; Segment permissions: Read
.rdata:00007E70 _rdata          segment dword public 'DATA' use32
.rdata:00007E70                 assume cs:_rdata
.rdata:00007E70                 ;org 7E70h
.rdata:00007E70                 public __real@c0000000
.rdata:00007E70 __real@c0000000 dd 0C0000000h           ; DATA XREF: SetupPluginMode(CommandLineInfo &)+13Br
.rdata:00007E70 _rdata          ends
.rdata:00007E70
.rdata:00007E74 ; ===========================================================================
.rdata:00007E74
.rdata:00007E74 ; Segment type: Pure data
.rdata:00007E74 ; Segment permissions: Read
.rdata:00007E74 _rdata          segment dword public 'DATA' use32
.rdata:00007E74                 assume cs:_rdata
.rdata:00007E74                 ;org 7E74h
.rdata:00007E74                 public __real@c2c60000
.rdata:00007E74 __real@c2c60000 dd 0C2C60000h           ; DATA XREF: CommandLineInfo::CommandLineInfo(void)+E6r
.rdata:00007E74                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+238r ...
.rdata:00007E74 _rdata          ends
.rdata:00007E74
UNDEF:00007E80 ; ===========================================================================
UNDEF:00007E80
UNDEF:00007E80 ; Segment type: Externs
UNDEF:00007E80 ; UNDEF
UNDEF:00007E80                 extrn __purecall:near   ; DATA XREF: .rdata:??_7?$_Func_base@X$$V@std@@6B@o
UNDEF:00007E80                                         ; .rdata:000078B4o ...
UNDEF:00007E84 ; void __cdecl operator delete(void *)
UNDEF:00007E84                 extrn ??3@YAXPAX@Z:near ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+260p
UNDEF:00007E88 ; void __cdecl operator delete(void *)
UNDEF:00007E88                 extrn ??3@YAXPAXI@Z:near
UNDEF:00007E88                                         ; CODE XREF: ??_G?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAEPAXI@Z+39p
UNDEF:00007E88                                         ; FileExistenceChecker::`scalar deleting destructor'(uint)+39p
UNDEF:00007E8C                 extrn __invalid_parameter:near
UNDEF:00007E8C                                         ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+6Ap
UNDEF:00007E8C                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+D9p ...
UNDEF:00007E90 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00007E90                 extrn _memcpy:near      ; CODE XREF: Vec<int>::operator=(Vec<int> const &)+5Bp
UNDEF:00007E90                                         ; Vec<wchar_t>::Append(wchar_t const *,uint)+50p ...
UNDEF:00007E94 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00007E94                 extrn _memmove:near     ; CODE XREF: Vec<wchar_t *>::MakeSpaceAt(uint,uint,bool)+B9p
UNDEF:00007E94                                         ; Vec<wchar_t>::MakeSpaceAt(uint,uint,bool)+B8p ...
UNDEF:00007E98 ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:00007E98                 extrn _memset:near      ; CODE XREF: Vec<int>::operator=(Vec<int> const &)+83p
UNDEF:00007E98                                         ; Vec<int>::EnsureCapTry(uint)+11Fp ...
UNDEF:00007E9C ; wchar_t *__cdecl wcschr(const wchar_t *Str, wchar_t Ch)
UNDEF:00007E9C                 extrn _wcschr:near      ; CODE XREF: wcschr(wchar_t *,wchar_t)+27p
UNDEF:00007EA0 ; wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr)
UNDEF:00007EA0                 extrn _wcsstr:near      ; CODE XREF: str::Find(wchar_t const *,wchar_t const *)+26p
UNDEF:00007EA4 ; DWORD __stdcall GetCurrentProcessId()
UNDEF:00007EA4                 extrn __imp__GetCurrentProcessId@0:near
UNDEF:00007EA4                                         ; CODE XREF: FindPrevInstWindow(void * *)+134p
UNDEF:00007EA4                                         ; DATA XREF: FindPrevInstWindow(void * *)+134r
UNDEF:00007EA8 ; DWORD __stdcall GetLastError()
UNDEF:00007EA8                 extrn __imp__GetLastError@0:near
UNDEF:00007EA8                                         ; CODE XREF: FindPrevInstWindow(void * *)+B8p
UNDEF:00007EA8                                         ; DATA XREF: FindPrevInstWindow(void * *)+B8r
UNDEF:00007EAC ; UINT __stdcall SetErrorMode(UINT uMode)
UNDEF:00007EAC                 extrn __imp__SetErrorMode@4:near
UNDEF:00007EAC                                         ; CODE XREF: WinMain(x,x,x,x)+8Bp
UNDEF:00007EAC                                         ; DATA XREF: WinMain(x,x,x,x)+8Br
UNDEF:00007EB0 ; void __stdcall Sleep(DWORD dwMilliseconds)
UNDEF:00007EB0                 extrn __imp__Sleep@4:near
UNDEF:00007EB0                                         ; CODE XREF: FindPrevInstWindow(void * *)+266p
UNDEF:00007EB0                                         ; WinMain(x,x,x,x)+B00p
UNDEF:00007EB0                                         ; DATA XREF: ...
UNDEF:00007EB4 ; BOOL __stdcall CloseHandle(HANDLE hObject)
UNDEF:00007EB4                 extrn __imp__CloseHandle@4:near
UNDEF:00007EB4                                         ; CODE XREF: FindPrevInstWindow(void * *)+118p
UNDEF:00007EB4                                         ; FindPrevInstWindow(void * *)+1A7p
UNDEF:00007EB4                                         ; DATA XREF: ...
UNDEF:00007EB8 ; LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
UNDEF:00007EB8                 extrn __imp__MapViewOfFile@20:near
UNDEF:00007EB8                                         ; CODE XREF: FindPrevInstWindow(void * *)+FCp
UNDEF:00007EB8                                         ; DATA XREF: FindPrevInstWindow(void * *)+FCr
UNDEF:00007EBC ; BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress)
UNDEF:00007EBC                 extrn __imp__UnmapViewOfFile@4:near
UNDEF:00007EBC                                         ; CODE XREF: FindPrevInstWindow(void * *)+14Cp
UNDEF:00007EBC                                         ; FindPrevInstWindow(void * *)+194p
UNDEF:00007EBC                                         ; DATA XREF: ...
UNDEF:00007EC0 ; HANDLE __stdcall CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
UNDEF:00007EC0                 extrn __imp__CreateFileMappingW@24:near
UNDEF:00007EC0                                         ; CODE XREF: FindPrevInstWindow(void * *)+9Bp
UNDEF:00007EC0                                         ; DATA XREF: FindPrevInstWindow(void * *)+9Br
UNDEF:00007EC4 ; HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName)
UNDEF:00007EC4                 extrn __imp__LoadLibraryW@4:near
UNDEF:00007EC4                                         ; CODE XREF: TryLoadMemTrace(void)+3Fp
UNDEF:00007EC4                                         ; DATA XREF: TryLoadMemTrace(void)+3Fr
UNDEF:00007EC8 ; HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName)
UNDEF:00007EC8                 extrn __imp__GetModuleHandleW@4:near
UNDEF:00007EC8                                         ; CODE XREF: InstanceInit(int)+29p
UNDEF:00007EC8                                         ; InstanceInit(int)+85p ...
UNDEF:00007ECC ; LPWSTR __stdcall GetCommandLineW()
UNDEF:00007ECC                 extrn __imp__GetCommandLineW@0:near
UNDEF:00007ECC                                         ; CODE XREF: WinMain(x,x,x,x)+12Cp
UNDEF:00007ECC                                         ; DATA XREF: WinMain(x,x,x,x)+12Cr
UNDEF:00007ED0 ; DWORD __stdcall GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
UNDEF:00007ED0                 extrn __imp__GetFullPathNameW@16:near
UNDEF:00007ED0                                         ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+3Cp
UNDEF:00007ED0                                         ; DATA XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+3Cr
UNDEF:00007ED4 ; BOOL __stdcall DeleteObject(HGDIOBJ ho)
UNDEF:00007ED4                 extrn __imp__DeleteObject@4:near
UNDEF:00007ED4                                         ; CODE XREF: WinMain(x,x,x,x)+ACCp
UNDEF:00007ED4                                         ; WinMain(x,x,x,x)+AE1p
UNDEF:00007ED4                                         ; DATA XREF: ...
UNDEF:00007ED8 ; HGDIOBJ __stdcall GetStockObject(int i)
UNDEF:00007ED8                 extrn __imp__GetStockObject@4:near
UNDEF:00007ED8                                         ; CODE XREF: RegisterWinClass(void)+8Cp
UNDEF:00007ED8                                         ; DATA XREF: RegisterWinClass(void)+8Cr
UNDEF:00007EDC ; BOOL __stdcall GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
UNDEF:00007EDC                 extrn __imp__GetMessageW@16:near
UNDEF:00007EDC                                         ; CODE XREF: RunMessageLoop(void)+6Ep
UNDEF:00007EDC                                         ; DATA XREF: RunMessageLoop(void)+6Er
UNDEF:00007EE0 ; BOOL __stdcall TranslateMessage(const MSG *lpMsg)
UNDEF:00007EE0                 extrn __imp__TranslateMessage@4:near
UNDEF:00007EE0                                         ; CODE XREF: RunMessageLoop(void)+DFp
UNDEF:00007EE0                                         ; DATA XREF: RunMessageLoop(void)+DFr
UNDEF:00007EE4 ; LRESULT __stdcall DispatchMessageW(const MSG *lpMsg)
UNDEF:00007EE4                 extrn __imp__DispatchMessageW@4:near
UNDEF:00007EE4                                         ; CODE XREF: RunMessageLoop(void)+F2p
UNDEF:00007EE4                                         ; DATA XREF: RunMessageLoop(void)+F2r
UNDEF:00007EE8 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00007EE8                 extrn __imp__SendMessageW@16:near
UNDEF:00007EE8                                         ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+259p
UNDEF:00007EE8                                         ; DATA XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+259r
UNDEF:00007EEC ; ATOM __stdcall RegisterClassExW(const WNDCLASSEXW *)
UNDEF:00007EEC                 extrn __imp__RegisterClassExW@4:near
UNDEF:00007EEC                                         ; CODE XREF: RegisterWinClass(void)+A2p
UNDEF:00007EEC                                         ; RegisterWinClass(void)+108p ...
UNDEF:00007EF0 ; BOOL __stdcall IsWindow(HWND hWnd)
UNDEF:00007EF0                 extrn __imp__IsWindow@4:near
UNDEF:00007EF0                                         ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+24p
UNDEF:00007EF0                                         ; SetupPluginMode(CommandLineInfo &)+2Ap
UNDEF:00007EF0                                         ; DATA XREF: ...
UNDEF:00007EF4 ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:00007EF4                 extrn __imp__ShowWindow@8:near
UNDEF:00007EF4                                         ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+150p
UNDEF:00007EF4                                         ; WinMain(x,x,x,x)+4F4p
UNDEF:00007EF4                                         ; DATA XREF: ...
UNDEF:00007EF8 ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:00007EF8                 extrn __imp__MoveWindow@24:near
UNDEF:00007EF8                                         ; CODE XREF: MoveWindow(HWND__ *,geomutil::RectT<int>)+36p
UNDEF:00007EF8                                         ; DATA XREF: MoveWindow(HWND__ *,geomutil::RectT<int>)+36r
UNDEF:00007EFC ; BOOL __stdcall IsIconic(HWND hWnd)
UNDEF:00007EFC                 extrn __imp__IsIconic@4:near
UNDEF:00007EFC                                         ; CODE XREF: WinMain(x,x,x,x)+4D8p
UNDEF:00007EFC                                         ; DATA XREF: WinMain(x,x,x,x)+4D8r
UNDEF:00007F00 ; HWND __stdcall SetFocus(HWND hWnd)
UNDEF:00007F00                 extrn __imp__SetFocus@4:near
UNDEF:00007F00                                         ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+17Cp
UNDEF:00007F00                                         ; DATA XREF: MakePluginWindow(WindowInfo &,HWND__ *)+17Cr
UNDEF:00007F04 ; HACCEL __stdcall LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
UNDEF:00007F04                 extrn __imp__LoadAcceleratorsW@8:near
UNDEF:00007F04                                         ; CODE XREF: RunMessageLoop(void)+37p
UNDEF:00007F04                                         ; DATA XREF: RunMessageLoop(void)+37r
UNDEF:00007F08 ; int __stdcall TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
UNDEF:00007F08                 extrn __imp__TranslateAcceleratorW@12:near
UNDEF:00007F08                                         ; CODE XREF: RunMessageLoop(void)+C6p
UNDEF:00007F08                                         ; DATA XREF: RunMessageLoop(void)+C6r
UNDEF:00007F0C ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:00007F0C                 extrn __imp__UpdateWindow@4:near
UNDEF:00007F0C                                         ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+166p
UNDEF:00007F0C                                         ; DATA XREF: MakePluginWindow(WindowInfo &,HWND__ *)+166r
UNDEF:00007F10 ; BOOL __stdcall SetForegroundWindow(HWND hWnd)
UNDEF:00007F10                 extrn __imp__SetForegroundWindow@4:near
UNDEF:00007F10                                         ; CODE XREF: WinMain(x,x,x,x)+50Ap
UNDEF:00007F10                                         ; DATA XREF: WinMain(x,x,x,x)+50Ar
UNDEF:00007F14 ; BOOL __stdcall AllowSetForegroundWindow(DWORD dwProcessId)
UNDEF:00007F14                 extrn __imp__AllowSetForegroundWindow@4:near
UNDEF:00007F14                                         ; CODE XREF: FindPrevInstWindow(void * *)+205p
UNDEF:00007F14                                         ; DATA XREF: FindPrevInstWindow(void * *)+205r
UNDEF:00007F18 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:00007F18                 extrn __imp__GetClientRect@8:near
UNDEF:00007F18                                         ; CODE XREF: ClientRect::ClientRect(HWND__ *)+3Fp
UNDEF:00007F18                                         ; DATA XREF: ClientRect::ClientRect(HWND__ *)+3Fr
UNDEF:00007F1C ; DWORD __stdcall GetSysColor(int nIndex)
UNDEF:00007F1C                 extrn __imp__GetSysColor@4:near
UNDEF:00007F1C                                         ; CODE XREF: GetNoDocBgColor(void)+2Fp
UNDEF:00007F1C                                         ; GetNoDocBgColor(void)+44p ...
UNDEF:00007F20 ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00007F20                 extrn __imp__GetWindowLongW@8:near
UNDEF:00007F20                                         ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+80p
UNDEF:00007F20                                         ; DATA XREF: MakePluginWindow(WindowInfo &,HWND__ *)+80r
UNDEF:00007F24 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00007F24                 extrn __imp__SetWindowLongW@12:near
UNDEF:00007F24                                         ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+B5p
UNDEF:00007F24                                         ; DATA XREF: MakePluginWindow(WindowInfo &,HWND__ *)+B5r
UNDEF:00007F28 ; HWND __stdcall SetParent(HWND hWndChild, HWND hWndNewParent)
UNDEF:00007F28                 extrn __imp__SetParent@8:near
UNDEF:00007F28                                         ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+CFp
UNDEF:00007F28                                         ; DATA XREF: MakePluginWindow(WindowInfo &,HWND__ *)+CFr
UNDEF:00007F2C ; HWND __stdcall FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
UNDEF:00007F2C                 extrn __imp__FindWindowW@8:near
UNDEF:00007F2C                                         ; CODE XREF: WinMain(x,x,x,x)+3F0p
UNDEF:00007F2C                                         ; DATA XREF: WinMain(x,x,x,x)+3F0r
UNDEF:00007F30 ; HWND __stdcall FindWindowExW(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow)
UNDEF:00007F30                 extrn __imp__FindWindowExW@16:near
UNDEF:00007F30                                         ; CODE XREF: FindPrevInstWindow(void * *)+1CAp
UNDEF:00007F30                                         ; DATA XREF: FindPrevInstWindow(void * *)+1CAr
UNDEF:00007F34 ; DWORD __stdcall GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId)
UNDEF:00007F34                 extrn __imp__GetWindowThreadProcessId@8:near
UNDEF:00007F34                                         ; CODE XREF: FindPrevInstWindow(void * *)+1EAp
UNDEF:00007F34                                         ; DATA XREF: FindPrevInstWindow(void * *)+1EAr
UNDEF:00007F38 ; HBITMAP __stdcall LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
UNDEF:00007F38                 extrn __imp__LoadBitmapW@8:near
UNDEF:00007F38                                         ; CODE XREF: InstanceInit(int)+93p
UNDEF:00007F38                                         ; DATA XREF: InstanceInit(int)+93r
UNDEF:00007F3C ; HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
UNDEF:00007F3C                 extrn __imp__LoadCursorW@8:near
UNDEF:00007F3C                                         ; CODE XREF: InstanceInit(int)+37p
UNDEF:00007F3C                                         ; DATA XREF: InstanceInit(int)+37r
UNDEF:00007F40 ; HICON __stdcall LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName)
UNDEF:00007F40                 extrn __imp__LoadIconW@8:near
UNDEF:00007F40                                         ; CODE XREF: RegisterWinClass(void)+4Ap
UNDEF:00007F40                                         ; RegisterWinClass(void)+175p
UNDEF:00007F40                                         ; DATA XREF: ...
UNDEF:00007F44 ; DWORD_PTR __stdcall SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags)
UNDEF:00007F44                 extrn __imp__SHGetFileInfoW@20:near
UNDEF:00007F44                                         ; CODE XREF: WinMain(x,x,x,x)+6F7p
UNDEF:00007F44                                         ; DATA XREF: WinMain(x,x,x,x)+6F7r
UNDEF:00007F48 ; void __cdecl srand(unsigned int Seed)
UNDEF:00007F48                 extrn _srand:near       ; CODE XREF: WinMain(x,x,x,x)+E7p
UNDEF:00007F4C ; int __cdecl system(const char *Command)
UNDEF:00007F4C                 extrn _system:near      ; CODE XREF: WinMain(x,x,x,x)+21Dp
UNDEF:00007F50 ; HRESULT __stdcall OleInitialize(LPVOID pvReserved)
UNDEF:00007F50                 extrn __imp__OleInitialize@4:near
UNDEF:00007F50                                         ; CODE XREF: ScopedOle::ScopedOle(void)+27p
UNDEF:00007F50                                         ; DATA XREF: ScopedOle::ScopedOle(void)+27r
UNDEF:00007F54 ; void __stdcall OleUninitialize()
UNDEF:00007F54                 extrn __imp__OleUninitialize@0:near
UNDEF:00007F54                                         ; CODE XREF: ScopedOle::~ScopedOle(void)+25p
UNDEF:00007F54                                         ; DATA XREF: ScopedOle::~ScopedOle(void)+25r
UNDEF:00007F58 ; __stdcall GdiplusStartup(x, x, x)
UNDEF:00007F58                 extrn _GdiplusStartup@12:near
UNDEF:00007F58                                         ; CODE XREF: ScopedGdiPlus::ScopedGdiPlus(bool)+59p
UNDEF:00007F5C ; __stdcall GdiplusShutdown(x)
UNDEF:00007F5C                 extrn _GdiplusShutdown@4:near
UNDEF:00007F5C                                         ; CODE XREF: ScopedGdiPlus::~ScopedGdiPlus(void)+4Dp
UNDEF:00007F60 ; void *__cdecl operator new(unsigned int, int, const char *, int)
UNDEF:00007F60                 extrn ??2@YAPAXIHPBDH@Z:near
UNDEF:00007F60                                         ; CODE XREF: WinMain(x,x,x,x)+A24p
UNDEF:00007F64                 extrn __CrtSetDbgFlag:near ; CODE XREF: WinMain(x,x,x,x)+63p
UNDEF:00007F64                                         ; WinMain(x,x,x,x)+B4Fp
UNDEF:00007F68                 extrn __free_dbg:near   ; CODE XREF: ScopedMem<char>::~ScopedMem<char>(void)+2Bp
UNDEF:00007F68                                         ; ScopedMem<wchar_t>::~ScopedMem<wchar_t>(void)+2Bp ...
UNDEF:00007F6C                 extrn __CrtDbgReportW:near
UNDEF:00007F6C                                         ; CODE XREF: ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+49p
UNDEF:00007F6C                                         ; ??$_Deallocate@V?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@@std@@YAXPAV?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@0@I@Z+B8p ...
UNDEF:00007F70 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00007F70                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00007F70                                         ; CODE XREF: std::_Debug_lt_pred<std::less<void>,uint const &,uint const &>(std::less<void>,uint const &,uint const &,wchar_t const *,uint)+62p
UNDEF:00007F74 ; void __cdecl _wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
UNDEF:00007F74                 extrn __wassert:near    ; CODE XREF: MakePluginWindow(WindowInfo &,HWND__ *)+49p
UNDEF:00007F74                                         ; MakePluginWindow(WindowInfo &,HWND__ *)+6Dp ...
UNDEF:00007F78 ; __time64_t __cdecl _time64(__time64_t *Time)
UNDEF:00007F78                 extrn __time64:near     ; CODE XREF: _time+22p
UNDEF:00007F7C                 extrn _setlocale:near   ; CODE XREF: WinMain(x,x,x,x)+7Cp
UNDEF:00007F80 ; unsigned int __cdecl MurmurHash2(const void *, unsigned int)
UNDEF:00007F80                 extrn ?MurmurHash2@@YAIPBXI@Z:near
UNDEF:00007F80                                         ; CODE XREF: FindPrevInstWindow(void * *)+5Ap
UNDEF:00007F84 ; void __cdecl static Allocator::Free(struct Allocator *, void *)
UNDEF:00007F84                 extrn ?Free@Allocator@@SAXPAV1@PAX@Z:near
UNDEF:00007F84                                         ; CODE XREF: Vec<FileState *>::FreeEls(void)+3Fp
UNDEF:00007F84                                         ; Vec<wchar_t *>::FreeEls(void)+3Fp ...
UNDEF:00007F88 ; void *__cdecl static Allocator::Realloc(struct Allocator *, void *, unsigned int)
UNDEF:00007F88                 extrn ?Realloc@Allocator@@SAPAXPAV1@PAXI@Z:near
UNDEF:00007F88                                         ; CODE XREF: Vec<int>::EnsureCapTry(uint)+ECp
UNDEF:00007F88                                         ; Vec<wchar_t *>::EnsureCapTry(uint)+ECp ...
UNDEF:00007F8C ; void *__cdecl static Allocator::Dup(struct Allocator *, const void *, unsigned int, unsigned int)
UNDEF:00007F8C                 extrn ?Dup@Allocator@@SAPAXPAV1@PBXII@Z:near
UNDEF:00007F8C                                         ; CODE XREF: Vec<int>::EnsureCapTry(uint)+CDp
UNDEF:00007F8C                                         ; Vec<wchar_t *>::EnsureCapTry(uint)+CDp ...
UNDEF:00007F90 ; unsigned int __cdecl str::Len(str *__hidden this, const char *)
UNDEF:00007F90                 extrn ?Len@str@@YAIPBD@Z:near
UNDEF:00007F90                                         ; CODE XREF: str::StartsWith<char>(char const *,char const *)+22p
UNDEF:00007F94 ; unsigned int __cdecl str::Len(str *__hidden this, const wchar_t *)
UNDEF:00007F94                 extrn ?Len@str@@YAIPB_W@Z:near
UNDEF:00007F94                                         ; CODE XREF: str::Str<wchar_t>::Append(wchar_t const *,uint)+2Dp
UNDEF:00007F94                                         ; FindPrevInstWindow(void * *)+46p ...
UNDEF:00007F98 ; wchar_t *__cdecl str::Dup(str *__hidden this, const wchar_t *)
UNDEF:00007F98                 extrn ?Dup@str@@YAPA_WPB_W@Z:near
UNDEF:00007F98                                         ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+63p
UNDEF:00007F98                                         ; FileExistenceChecker::GetFilePathsToCheck(void)+105p ...
UNDEF:00007F9C ; void __cdecl str::ReplacePtr(str *__hidden this, wchar_t **, const wchar_t *)
UNDEF:00007F9C                 extrn ?ReplacePtr@str@@YAXPAPA_WPB_W@Z:near
UNDEF:00007F9C                                         ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+B8p
UNDEF:00007FA0 ; bool __cdecl str::Eq(str *__hidden this, const wchar_t *, const wchar_t *)
UNDEF:00007FA0                 extrn ?Eq@str@@YA_NPB_W0@Z:near
UNDEF:00007FA0                                         ; CODE XREF: WStrVec::Find(wchar_t const *,uint)+57p
UNDEF:00007FA4 ; bool __cdecl str::EqI(str *__hidden this, const char *, const char *)
UNDEF:00007FA4                 extrn ?EqI@str@@YA_NPBD0@Z:near
UNDEF:00007FA4                                         ; CODE XREF: WinMain(x,x,x,x)+552p
UNDEF:00007FA4                                         ; WinMain(x,x,x,x)+56Fp ...
UNDEF:00007FA8 ; bool __cdecl str::EqI(str *__hidden this, const wchar_t *, const wchar_t *)
UNDEF:00007FA8                 extrn ?EqI@str@@YA_NPB_W0@Z:near
UNDEF:00007FA8                                         ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+D1p
UNDEF:00007FA8                                         ; WinMain(x,x,x,x)+611p
UNDEF:00007FAC ; bool __cdecl str::EqN(str *__hidden this, const char *, const char *, unsigned int)
UNDEF:00007FAC                 extrn ?EqN@str@@YA_NPBD0I@Z:near
UNDEF:00007FAC                                         ; CODE XREF: str::StartsWith<char>(char const *,char const *)+33p
UNDEF:00007FB0 ; bool __cdecl str::StartsWithI(str *__hidden this, const wchar_t *, const wchar_t *)
UNDEF:00007FB0                 extrn ?StartsWithI@str@@YA_NPB_W0@Z:near
UNDEF:00007FB0                                         ; CODE XREF: SetupPluginMode(CommandLineInfo &)+23Bp
UNDEF:00007FB0                                         ; SetupPluginMode(CommandLineInfo &)+286p
UNDEF:00007FB4 ; wchar_t *__cdecl str::DupN(str *__hidden this, const wchar_t *, unsigned int)
UNDEF:00007FB4                 extrn ?DupN@str@@YAPA_WPB_WI@Z:near
UNDEF:00007FB4                                         ; CODE XREF: WStrVec::Split(wchar_t const *,wchar_t const *,bool)+61p
UNDEF:00007FB8 ; void __cdecl str::ToLower(str *__hidden this, wchar_t *)
UNDEF:00007FB8                 extrn ?ToLower@str@@YAXPA_W@Z:near
UNDEF:00007FB8                                         ; CODE XREF: FindPrevInstWindow(void * *)+35p
UNDEF:00007FBC ; wchar_t *__cdecl str::FmtV(str *__hidden this, const wchar_t *, char *)
UNDEF:00007FBC                 extrn ?FmtV@str@@YAPA_WPB_WPAD@Z:near
UNDEF:00007FBC                                         ; CODE XREF: str::Str<wchar_t>::AppendFmt(wchar_t const *,...)+31p
UNDEF:00007FC0 ; wchar_t *str::Format(str *__hidden this, const wchar_t *, ...)
UNDEF:00007FC0                 extrn ?Format@str@@YAPA_WPB_WZZ:near
UNDEF:00007FC0                                         ; CODE XREF: FindPrevInstWindow(void * *)+6Ep
UNDEF:00007FC4 ; unsigned int __cdecl str::TransChars(str *__hidden this, wchar_t *, const wchar_t *, const wchar_t *)
UNDEF:00007FC4                 extrn ?TransChars@str@@YAIPA_WPB_W1@Z:near
UNDEF:00007FC4                                         ; CODE XREF: SetupPluginMode(CommandLineInfo &)+1D6p
UNDEF:00007FC8 ; const wchar_t *str::Parse(str *__hidden this, const wchar_t *, const wchar_t *, ...)
UNDEF:00007FC8                 extrn ?Parse@str@@YAPB_WPB_W0ZZ:near
UNDEF:00007FC8                                         ; CODE XREF: SetupPluginMode(CommandLineInfo &)+25Dp
UNDEF:00007FCC ; void __cdecl dbghelp::RememberCallstackLogs(dbghelp *__hidden this)
UNDEF:00007FCC                 extrn ?RememberCallstackLogs@dbghelp@@YAXXZ:near
UNDEF:00007FCC                                         ; CODE XREF: WinMain(x,x,x,x)+F4p
UNDEF:00007FD0 ; void __cdecl dbghelp::FreeCallstackLogs(dbghelp *__hidden this)
UNDEF:00007FD0                 extrn ?FreeCallstackLogs@dbghelp@@YAXXZ:near
UNDEF:00007FD0                                         ; CODE XREF: WinMain(x,x,x,x)+B32p
UNDEF:00007FD4 ; void __cdecl DpiRemoveAll()
UNDEF:00007FD4                 extrn ?DpiRemoveAll@@YAXXZ:near
UNDEF:00007FD4                                         ; CODE XREF: WinMain(x,x,x,x)+B23p
UNDEF:00007FD8 ; wchar_t *__cdecl path::Join(path *__hidden this, const wchar_t *, const wchar_t *)
UNDEF:00007FD8                 extrn ?Join@path@@YAPA_WPB_W0@Z:near
UNDEF:00007FD8                                         ; CODE XREF: SetupCrashHandler(void)+53p
UNDEF:00007FDC ; wchar_t *__cdecl path::Normalize(path *__hidden this, const wchar_t *)
UNDEF:00007FDC                 extrn ?Normalize@path@@YAPA_WPB_W@Z:near
UNDEF:00007FDC                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+357p
UNDEF:00007FDC                                         ; OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+1BFp
UNDEF:00007FE0 ; bool __cdecl path::IsOnFixedDrive(path *__hidden this, const wchar_t *)
UNDEF:00007FE0                 extrn ?IsOnFixedDrive@path@@YA_NPB_W@Z:near
UNDEF:00007FE0                                         ; CODE XREF: FileExistenceChecker::Run(void)+6Dp
UNDEF:00007FE4 ; wchar_t *__cdecl path::GetTempPathW(path *__hidden this, const wchar_t *)
UNDEF:00007FE4                 extrn ?GetTempPathW@path@@YAPA_WPB_W@Z:near
UNDEF:00007FE4                                         ; CODE XREF: SetupCrashHandler(void)+28p
UNDEF:00007FE8 ; wchar_t *__cdecl path::GetAppPath(path *__hidden this, const wchar_t *)
UNDEF:00007FE8                 extrn ?GetAppPath@path@@YAPA_WPB_W@Z:near
UNDEF:00007FE8                                         ; CODE XREF: TryLoadMemTrace(void)+23p
UNDEF:00007FEC ; HINSTANCE __cdecl GetInstance()
UNDEF:00007FEC                 extrn ?GetInstance@@YAPAUHINSTANCE__@@XZ:near
UNDEF:00007FEC                                         ; CODE XREF: WinMain(x,x,x,x)+33p
UNDEF:00007FF0 ; void __cdecl FileWatcherWaitForShutdown()
UNDEF:00007FF0                 extrn ?FileWatcherWaitForShutdown@@YAXXZ:near
UNDEF:00007FF0                                         ; CODE XREF: WinMain(x,x,x,x)+B28p
UNDEF:00007FF4 ; void __cdecl RegisterLabelWithCloseWnd()
UNDEF:00007FF4                 extrn ?RegisterLabelWithCloseWnd@@YAXXZ:near
UNDEF:00007FF4                                         ; CODE XREF: RegisterWinClass(void)+204p
UNDEF:00007FF8 ; void __cdecl mui::Initialize(mui *__hidden this)
UNDEF:00007FF8                 extrn ?Initialize@mui@@YAXXZ:near
UNDEF:00007FF8                                         ; CODE XREF: WinMain(x,x,x,x)+115p
UNDEF:00007FFC ; void __cdecl mui::Destroy(mui *__hidden this)
UNDEF:00007FFC                 extrn ?Destroy@mui@@YAXXZ:near
UNDEF:00007FFC                                         ; CODE XREF: WinMain(x,x,x,x):loc_7304p
UNDEF:00008000 ; void __cdecl RegisterSplitterWndClass()
UNDEF:00008000                 extrn ?RegisterSplitterWndClass@@YAXXZ:near
UNDEF:00008000                                         ; CODE XREF: RegisterWinClass(void)+1FFp
UNDEF:00008004 ; void __cdecl DeleteSplitterBrush()
UNDEF:00008004                 extrn ?DeleteSplitterBrush@@YAXXZ:near
UNDEF:00008004                                         ; CODE XREF: WinMain(x,x,x,x)+AEEp
UNDEF:00008008 ; _DWORD __thiscall ThreadBase::~ThreadBase(ThreadBase *__hidden this)
UNDEF:00008008                 extrn ??1ThreadBase@@MAE@XZ:near
UNDEF:00008008                                         ; CODE XREF: FileExistenceChecker::~FileExistenceChecker(void)+31p
UNDEF:0000800C ; public: __thiscall ThreadBase::ThreadBase(char const *)
UNDEF:0000800C                 extrn ??0ThreadBase@@QAE@PBD@Z:near
UNDEF:0000800C                                         ; CODE XREF: FileExistenceChecker::FileExistenceChecker(void)+28p
UNDEF:00008010 ; void __thiscall ThreadBase::Start(ThreadBase *__hidden this)
UNDEF:00008010                 extrn ?Start@ThreadBase@@QAEXXZ:near
UNDEF:00008010                                         ; CODE XREF: WinMain(x,x,x,x)+A6Ap
UNDEF:00008014 ; bool __thiscall ThreadBase::Join(ThreadBase *__hidden this, unsigned __int32)
UNDEF:00008014                 extrn ?Join@ThreadBase@@QAE_NK@Z:near
UNDEF:00008014                                         ; CODE XREF: FileExistenceChecker::Terminate(void)+32p
UNDEF:00008018 ; void __cdecl uitask::Initialize(uitask *__hidden this)
UNDEF:00008018                 extrn ?Initialize@uitask@@YAXXZ:near
UNDEF:00008018                                         ; CODE XREF: WinMain(x,x,x,x)+11Ap
UNDEF:0000801C ; void __cdecl uitask::Destroy(uitask *__hidden this)
UNDEF:0000801C                 extrn ?Destroy@uitask@@YAXXZ:near
UNDEF:0000801C                                         ; CODE XREF: WinMain(x,x,x,x)+B19p
UNDEF:00008020 ; void __cdecl uitask::DrainQueue(uitask *__hidden this)
UNDEF:00008020                 extrn ?DrainQueue@uitask@@YAXXZ:near
UNDEF:00008020                                         ; CODE XREF: WinMain(x,x,x,x)+B0Dp
UNDEF:00008024 ; void __cdecl uitask::Post(class std::function<void __cdecl (void)> const &)
UNDEF:00008024                 extrn ?Post@uitask@@YAXABV?$function@$$A6AXXZ@std@@@Z:near
UNDEF:00008024                                         ; CODE XREF: FileExistenceChecker::Run(void)+E7p
UNDEF:00008028 ; int __cdecl SafeCloseHandle(void **)
UNDEF:00008028                 extrn ?SafeCloseHandle@@YAHPAPAX@Z:near
UNDEF:00008028                                         ; CODE XREF: WinMain(x,x,x,x)+A83p
UNDEF:0000802C ; void __cdecl FillWndClassEx(struct tagWNDCLASSEXW *, const wchar_t *, __int32 (__stdcall *)(HWND, unsigned int, unsigned int, __int32))
UNDEF:0000802C                 extrn ?FillWndClassEx@@YAXAAUtagWNDCLASSEXW@@PB_WP6GJPAUHWND__@@IIJ@Z@Z:near
UNDEF:0000802C                                         ; CODE XREF: RegisterWinClass(void)+2Cp
UNDEF:0000802C                                         ; RegisterWinClass(void)+F1p ...
UNDEF:00008030 ; void __cdecl DisableDataExecution()
UNDEF:00008030                 extrn ?DisableDataExecution@@YAXXZ:near
UNDEF:00008030                                         ; CODE XREF: WinMain(x,x,x,x)+70p
UNDEF:00008034 ; void __cdecl RedirectIOToConsole()
UNDEF:00008034                 extrn ?RedirectIOToConsole@@YAXXZ:near
UNDEF:00008034                                         ; CODE XREF: WinMain(x,x,x,x)+1D5p
UNDEF:00008038 ; wchar_t *__cdecl GetExePath()
UNDEF:00008038                 extrn ?GetExePath@@YAPA_WXZ:near
UNDEF:00008038                                         ; CODE XREF: FindPrevInstWindow(void * *)+1Ep
UNDEF:0000803C ; HFONT __cdecl GetDefaultGuiFont()
UNDEF:0000803C                 extrn ?GetDefaultGuiFont@@YAPAUHFONT__@@XZ:near
UNDEF:0000803C                                         ; CODE XREF: WinMain(x,x,x,x):loc_72B4p
UNDEF:00008040 ; void __cdecl InitAllCommonControls()
UNDEF:00008040                 extrn ?InitAllCommonControls@@YAXXZ:near
UNDEF:00008040                                         ; CODE XREF: WinMain(x,x,x,x)+106p
UNDEF:00008044 ; bool __cdecl DDEExecute(const wchar_t *, const wchar_t *, const wchar_t *)
UNDEF:00008044                 extrn ?DDEExecute@@YA_NPB_W00@Z:near
UNDEF:00008044                                         ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+298p
UNDEF:00008048 ; void __thiscall DisplayModel::Relayout(DisplayModel *__hidden this, float, int)
UNDEF:00008048                 extrn ?Relayout@DisplayModel@@QAEXMH@Z:near
UNDEF:00008048                                         ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+14Cp
UNDEF:0000804C ; struct ScrollState __thiscall __high DisplayModel::GetScrollState()
UNDEF:0000804C                 extrn ?GetScrollState@DisplayModel@@QAE?AUScrollState@@XZ:near
UNDEF:0000804C                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+29Cp
UNDEF:00008050 ; void __thiscall __high DisplayModel::SetScrollState(struct ScrollState)
UNDEF:00008050                 extrn ?SetScrollState@DisplayModel@@QAEXUScrollState@@@Z:near
UNDEF:00008050                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+2ECp
UNDEF:00008050                                         ; RestoreTabOnStartup(WindowInfo *,TabState *)+1EBp
UNDEF:00008054 ; struct FileState *__thiscall FileHistory::Get(FileHistory *__hidden this, unsigned int)
UNDEF:00008054                 extrn ?Get@FileHistory@@QBEPAUFileState@@I@Z:near
UNDEF:00008054                                         ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+44p
UNDEF:00008054                                         ; WinMain(x,x,x,x)+A07p
UNDEF:00008058 ; bool __thiscall FileHistory::MarkFileInexistent(FileHistory *__hidden this, const wchar_t *, bool)
UNDEF:00008058                 extrn ?MarkFileInexistent@FileHistory@@QAE_NPB_W_N@Z:near
UNDEF:00008058                                         ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+79p
UNDEF:0000805C ; public: void __thiscall FileHistory::GetFrequencyOrder(class Vec<struct FileState *> &)
UNDEF:0000805C                 extrn ?GetFrequencyOrder@FileHistory@@QAEXAAV?$Vec@PAUFileState@@@@@Z:near
UNDEF:0000805C                                         ; CODE XREF: FileExistenceChecker::GetFilePathsToCheck(void)+9Ap
UNDEF:00008060 ; void __cdecl ResetSessionState(class Vec<struct SessionData *> *)
UNDEF:00008060                 extrn ?ResetSessionState@@YAXPAV?$Vec@PAUSessionData@@@@@Z:near
UNDEF:00008060                                         ; CODE XREF: WinMain(x,x,x,x)+854p
UNDEF:00008064 ; const wchar_t *__cdecl __high prefs::conv::FromDisplayMode(enum DisplayMode)
UNDEF:00008064                 extrn ?FromDisplayMode@conv@prefs@@YAPB_WW4DisplayMode@@@Z:near
UNDEF:00008064                                         ; CODE XREF: OpenUsingDde(HWND__ *,wchar_t const *,CommandLineInfo &,bool)+13Bp
UNDEF:00008068 ; enum DisplayMode __cdecl __high prefs::conv::ToDisplayMode(const wchar_t *, enum DisplayMode)
UNDEF:00008068                 extrn ?ToDisplayMode@conv@prefs@@YA?AW4DisplayMode@@PB_WW43@@Z:near
UNDEF:00008068                                         ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+9Ep
UNDEF:0000806C ; float __cdecl prefs::conv::ToZoom(prefs::conv *__hidden this, const char *, float)
UNDEF:0000806C                 extrn ?ToZoom@conv@prefs@@YAMPBDM@Z:near
UNDEF:0000806C                                         ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+107p
UNDEF:00008070 ; void __cdecl InitializePolicies(bool)
UNDEF:00008070                 extrn ?InitializePolicies@@YAX_N@Z:near
UNDEF:00008070                                         ; CODE XREF: WinMain(x,x,x,x)+14Dp
UNDEF:00008074 ; void __cdecl RestrictPolicies(int)
UNDEF:00008074                 extrn ?RestrictPolicies@@YAXH@Z:near
UNDEF:00008074                                         ; CODE XREF: SetupPluginMode(CommandLineInfo &)+C7p
UNDEF:00008074                                         ; WinMain(x,x,x,x)+9A7p
UNDEF:00008078 ; bool __cdecl HasPermission(int)
UNDEF:00008078                 extrn ?HasPermission@@YA_NH@Z:near
UNDEF:00008078                                         ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+2Cp
UNDEF:0000807C ; void __cdecl AssociateExeWithPdfExtension()
UNDEF:0000807C                 extrn ?AssociateExeWithPdfExtension@@YAXXZ:near
UNDEF:0000807C                                         ; CODE XREF: RegisterForPdfExtentions(HWND__ *):loc_4C44p
UNDEF:0000807C                                         ; WinMain(x,x,x,x)+1EAp
UNDEF:00008080 ; void __cdecl SetSidebarVisibility(struct WindowInfo *, bool, bool)
UNDEF:00008080                 extrn ?SetSidebarVisibility@@YAXPAVWindowInfo@@_N1@Z:near
UNDEF:00008080                                         ; CODE XREF: RestoreTabOnStartup(WindowInfo *,TabState *)+8Dp
UNDEF:00008084 ; struct WindowInfo *__cdecl FindWindowInfoByHwnd(HWND)
UNDEF:00008084                 extrn ?FindWindowInfoByHwnd@@YAPAVWindowInfo@@PAUHWND__@@@Z:near
UNDEF:00008084                                         ; CODE XREF: RunMessageLoop(void)+87p
UNDEF:00008088 ; struct WindowInfo *__cdecl LoadDocument(struct LoadArgs *)
UNDEF:00008088                 extrn ?LoadDocument@@YAPAVWindowInfo@@AAULoadArgs@@@Z:near
UNDEF:00008088                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+7Ep
UNDEF:00008088                                         ; RestoreTabOnStartup(WindowInfo *,TabState *)+34p
UNDEF:0000808C ; struct WindowInfo *__cdecl CreateAndShowWindowInfo(struct SessionData *)
UNDEF:0000808C                 extrn ?CreateAndShowWindowInfo@@YAPAVWindowInfo@@PAUSessionData@@@Z:near
UNDEF:0000808C                                         ; CODE XREF: WinMain(x,x,x,x)+796p
UNDEF:0000808C                                         ; WinMain(x,x,x,x)+95Ap
UNDEF:00008090 ; bool __cdecl DocumentPathExists(const wchar_t *)
UNDEF:00008090                 extrn ?DocumentPathExists@@YA_NPB_W@Z:near
UNDEF:00008090                                         ; CODE XREF: FileExistenceChecker::Run(void)+80p
UNDEF:00008094 ; void __cdecl EnterFullScreen(struct WindowInfo *, bool)
UNDEF:00008094                 extrn ?EnterFullScreen@@YAXPAVWindowInfo@@_N@Z:near
UNDEF:00008094                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+201p
UNDEF:00008098 ; void __cdecl ExitFullScreen(struct WindowInfo *)
UNDEF:00008098                 extrn ?ExitFullScreen@@YAXPAVWindowInfo@@@Z:near
UNDEF:00008098                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+1EAp
UNDEF:0000809C ; void __cdecl SetCurrentLang(const char *)
UNDEF:0000809C                 extrn ?SetCurrentLang@@YAXPBD@Z:near
UNDEF:0000809C                                         ; CODE XREF: WinMain(x,x,x,x)+1C2p
UNDEF:000080A0 ; void __cdecl GetFixedPageUiColors(unsigned __int32 *, unsigned __int32 *)
UNDEF:000080A0                 extrn ?GetFixedPageUiColors@@YAXAAK0@Z:near
UNDEF:000080A0                                         ; CODE XREF: WinMain(x,x,x,x)+24Ap
UNDEF:000080A4 ; void __cdecl RebuildMenuBarForWindow(struct WindowInfo *)
UNDEF:000080A4                 extrn ?RebuildMenuBarForWindow@@YAXPAVWindowInfo@@@Z:near
UNDEF:000080A4                                         ; CODE XREF: WinMain(x,x,x,x)+9B6p
UNDEF:000080A8 ; void __cdecl UpdateCheckAsync(struct WindowInfo *, bool)
UNDEF:000080A8                 extrn ?UpdateCheckAsync@@YAXPAVWindowInfo@@_N@Z:near
UNDEF:000080A8                                         ; CODE XREF: WinMain(x,x,x,x)+9EDp
UNDEF:000080AC ; void __cdecl DeleteWindowInfo(struct WindowInfo *)
UNDEF:000080AC                 extrn ?DeleteWindowInfo@@YAXPAVWindowInfo@@@Z:near
UNDEF:000080AC                                         ; CODE XREF: WinMain(x,x,x,x)+ABAp
UNDEF:000080B0 ; __int32 __stdcall WndProcFrame(HWND, unsigned int, unsigned int, __int32)
UNDEF:000080B0                 extrn ?WndProcFrame@@YGJPAUHWND__@@IIJ@Z:near
UNDEF:000080B0                                         ; DATA XREF: RegisterWinClass(void)+1Eo
UNDEF:000080B4 ; bool __thiscall WindowInfo::IsAboutWindow(WindowInfo *__hidden this)
UNDEF:000080B4                 extrn ?IsAboutWindow@WindowInfo@@QBE_NXZ:near
UNDEF:000080B4                                         ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+ABp
UNDEF:000080B8 ; bool __thiscall WindowInfo::IsDocLoaded(WindowInfo *__hidden this)
UNDEF:000080B8                 extrn ?IsDocLoaded@WindowInfo@@QBE_NXZ:near
UNDEF:000080B8                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+9Ap
UNDEF:000080B8                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+E2p ...
UNDEF:000080BC ; struct DisplayModel *__thiscall WindowInfo::AsFixed(WindowInfo *__hidden this)
UNDEF:000080BC                 extrn ?AsFixed@WindowInfo@@QBEPAVDisplayModel@@XZ:near
UNDEF:000080BC                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+281p
UNDEF:000080BC                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+28Dp ...
UNDEF:000080C0 ; void __thiscall WindowInfo::RedrawAll(WindowInfo *__hidden this, bool)
UNDEF:000080C0                 extrn ?RedrawAll@WindowInfo@@QAEX_N@Z:near
UNDEF:000080C0                                         ; CODE XREF: FileExistenceChecker::HideMissingFiles(void)+C7p
UNDEF:000080C4 ; void __thiscall LinkHandler::GotoNamedDest(LinkHandler *__hidden this, const wchar_t *)
UNDEF:000080C4                 extrn ?GotoNamedDest@LinkHandler@@QAEXPB_W@Z:near
UNDEF:000080C4                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+D8p
UNDEF:000080C8 ; void __cdecl __high SwitchToDisplayMode(struct WindowInfo *, enum DisplayMode, bool)
UNDEF:000080C8                 extrn ?SwitchToDisplayMode@@YAXPAVWindowInfo@@W4DisplayMode@@_N@Z:near
UNDEF:000080C8                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+225p
UNDEF:000080C8                                         ; RestoreTabOnStartup(WindowInfo *,TabState *)+B9p
UNDEF:000080CC ; bool __cdecl prefs::Load(prefs *__hidden this)
UNDEF:000080CC                 extrn ?Load@prefs@@YA_NXZ:near
UNDEF:000080CC                                         ; CODE XREF: WinMain(x,x,x,x):loc_6968p
UNDEF:000080D0 ; void __cdecl prefs::CleanUp(prefs *__hidden this)
UNDEF:000080D0                 extrn ?CleanUp@prefs@@YAXXZ:near
UNDEF:000080D0                                         ; CODE XREF: WinMain(x,x,x,x)+B43p
UNDEF:000080D4 ; void __cdecl prefs::RegisterForFileChanges(prefs *__hidden this)
UNDEF:000080D4                 extrn ?RegisterForFileChanges@prefs@@YAXXZ:near
UNDEF:000080D4                                         ; CODE XREF: WinMain(x,x,x,x):loc_725Fp
UNDEF:000080D8 ; void __cdecl prefs::UnregisterForFileChanges(prefs *__hidden this)
UNDEF:000080D8                 extrn ?UnregisterForFileChanges@prefs@@YAXXZ:near
UNDEF:000080D8                                         ; CODE XREF: WinMain(x,x,x,x):$Exit$113p
UNDEF:000080DC ; bool __cdecl IsRunningInPortableMode()
UNDEF:000080DC                 extrn ?IsRunningInPortableMode@@YA_NXZ:near
UNDEF:000080DC                                         ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+1Ep
UNDEF:000080E0 ; wchar_t *__cdecl AppGenDataFilename(const wchar_t *)
UNDEF:000080E0                 extrn ?AppGenDataFilename@@YAPA_WPB_W@Z:near
UNDEF:000080E0                                         ; CODE XREF: SetupCrashHandler(void)+6Bp
UNDEF:000080E0                                         ; SetupCrashHandler(void)+81p
UNDEF:000080E4 ; void __cdecl SetAppDataPath(const wchar_t *)
UNDEF:000080E4                 extrn ?SetAppDataPath@@YAXPB_W@Z:near
UNDEF:000080E4                                         ; CODE XREF: WinMain(x,x,x,x)+170p
UNDEF:000080E8 ; bool __cdecl IsExeAssociatedWithPdfExtension()
UNDEF:000080E8                 extrn ?IsExeAssociatedWithPdfExtension@@YA_NXZ:near
UNDEF:000080E8                                         ; CODE XREF: RegisterForPdfExtentions(HWND__ *):loc_4BABp
UNDEF:000080EC ; void __cdecl SaveCallstackLogs()
UNDEF:000080EC                 extrn ?SaveCallstackLogs@@YAXXZ:near
UNDEF:000080EC                                         ; CODE XREF: WinMain(x,x,x,x)+B2Dp
UNDEF:000080F0 ; __int32 __stdcall WndProcCanvas(HWND, unsigned int, unsigned int, __int32)
UNDEF:000080F0                 extrn ?WndProcCanvas@@YGJPAUHWND__@@IIJ@Z:near
UNDEF:000080F0                                         ; DATA XREF: RegisterWinClass(void)+E3o
UNDEF:000080F4 ; void __cdecl RegisterCaptionWndClass()
UNDEF:000080F4                 extrn ?RegisterCaptionWndClass@@YAXXZ:near
UNDEF:000080F4                                         ; CODE XREF: RegisterWinClass(void)+209p
UNDEF:000080F8 ; void __cdecl InstallCrashHandler(const wchar_t *, const wchar_t *)
UNDEF:000080F8                 extrn ?InstallCrashHandler@@YAXPB_W0@Z:near
UNDEF:000080F8                                         ; CODE XREF: SetupCrashHandler(void)+A4p
UNDEF:000080FC ; void __cdecl UninstallCrashHandler()
UNDEF:000080FC                 extrn ?UninstallCrashHandler@@YAXXZ:near
UNDEF:000080FC                                         ; CODE XREF: WinMain(x,x,x,x)+B48p
UNDEF:00008100 ; void __cdecl CleanUpThumbnailCache(struct FileHistory *)
UNDEF:00008100                 extrn ?CleanUpThumbnailCache@@YAXAAVFileHistory@@@Z:near
UNDEF:00008100                                         ; CODE XREF: WinMain(x,x,x,x)+A90p
UNDEF:00008104 ; void __cdecl RegisterNotificationsWndClass()
UNDEF:00008104                 extrn ?RegisterNotificationsWndClass@@YAXXZ:near
UNDEF:00008104                                         ; CODE XREF: RegisterWinClass(void)+1FAp
UNDEF:00008108 ; void __thiscall CommandLineInfo::ParseCommandLine(CommandLineInfo *__hidden this, const wchar_t *)
UNDEF:00008108                 extrn ?ParseCommandLine@CommandLineInfo@@QAEXPB_W@Z:near
UNDEF:00008108                                         ; CODE XREF: WinMain(x,x,x,x)+140p
UNDEF:0000810C ; void __thiscall CommandLineInfo::UpdateGlobalPrefs(CommandLineInfo *__hidden this)
UNDEF:0000810C                 extrn ?UpdateGlobalPrefs@CommandLineInfo@@QAEXXZ:near
UNDEF:0000810C                                         ; CODE XREF: WinMain(x,x,x,x)+183p
UNDEF:00008110 ; bool __cdecl PrintFile(const wchar_t *, wchar_t *, bool, const wchar_t *)
UNDEF:00008110                 extrn ?PrintFile@@YA_NPB_WPA_W_N0@Z:near
UNDEF:00008110                                         ; CODE XREF: WinMain(x,x,x,x)+36Ep
UNDEF:00008114 ; void __cdecl OnMenuPrint(struct WindowInfo *, bool)
UNDEF:00008114                 extrn ?OnMenuPrint@@YAXPAVWindowInfo@@_N@Z:near
UNDEF:00008114                                         ; CODE XREF: WinMain(x,x,x,x)+90Ap
UNDEF:00008118 ; void __cdecl ShowForwardSearchResult(class WindowInfo *, wchar_t const *, unsigned int, unsigned int, unsigned int, unsigned int, class Vec<class geomutil::RectT<int>> &)
UNDEF:00008118                 extrn ?ShowForwardSearchResult@@YAXPAVWindowInfo@@PB_WIIIIAAV?$Vec@V?$RectT@H@geomutil@@@@@Z:near
UNDEF:00008118                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+3EFp
UNDEF:0000811C ; void __cdecl ZoomToSelection(struct WindowInfo *, float, bool, bool)
UNDEF:0000811C                 extrn ?ZoomToSelection@@YAXPAVWindowInfo@@M_N1@Z:near
UNDEF:0000811C                                         ; CODE XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+25Ep
UNDEF:00008120 ; int __cdecl Dialog_PdfAssociate(HWND, bool *)
UNDEF:00008120                 extrn ?Dialog_PdfAssociate@@YAHPAUHWND__@@PA_N@Z:near
UNDEF:00008120                                         ; CODE XREF: RegisterForPdfExtentions(HWND__ *)+7Dp
UNDEF:00008124 ; __int32 __stdcall WndProcProperties(HWND, unsigned int, unsigned int, __int32)
UNDEF:00008124                 extrn ?WndProcProperties@@YGJPAUHWND__@@IIJ@Z:near
UNDEF:00008124                                         ; DATA XREF: RegisterWinClass(void)+149o
UNDEF:00008128 ; void __cdecl TabsSelect(struct WindowInfo *, int)
UNDEF:00008128                 extrn ?TabsSelect@@YAXPAVWindowInfo@@H@Z:near
UNDEF:00008128                                         ; CODE XREF: WinMain(x,x,x,x)+83Bp
UNDEF:0000812C ; void __cdecl trans::Destroy(trans *__hidden this)
UNDEF:0000812C                 extrn ?Destroy@trans@@YAXXZ:near
UNDEF:0000812C                                         ; CODE XREF: WinMain(x,x,x,x)+B1Ep
UNDEF:00008130 ; void __cdecl uia::Initialize(uia *__hidden this)
UNDEF:00008130                 extrn ?Initialize@uia@@YAXXZ:near
UNDEF:00008130                                         ; CODE XREF: WinMain(x,x,x,x)+EFp
UNDEF:00008134 ; void __cdecl BenchFileOrDir(struct WStrVec *)
UNDEF:00008134                 extrn ?BenchFileOrDir@@YAXAAVWStrVec@@@Z:near
UNDEF:00008134                                         ; CODE XREF: WinMain(x,x,x,x)+205p
UNDEF:00008138 ; void __cdecl StartStressTest(struct CommandLineInfo *, struct WindowInfo *)
UNDEF:00008138                 extrn ?StartStressTest@@YAXPAVCommandLineInfo@@PAVWindowInfo@@@Z:near
UNDEF:00008138                                         ; CODE XREF: WinMain(x,x,x,x)+9CCp
UNDEF:0000813C ; public: virtual void * __thiscall FileExistenceChecker::`vector deleting destructor'(unsigned int)
UNDEF:0000813C                 extrn ??_EFileExistenceChecker@@UAEPAXI@Z:near ; weak
UNDEF:0000813C                                         ; DATA XREF: .rdata:const FileExistenceChecker::`vftable'o
UNDEF:00008140                 extrn _fz_redirect_dll_io_to_console:near
UNDEF:00008140                                         ; CODE XREF: WinMain(x,x,x,x)+1DAp
UNDEF:00008144 ; int __cdecl TesterMain()
UNDEF:00008144                 extrn ?TesterMain@@YAHXZ:near
UNDEF:00008144                                         ; CODE XREF: WinMain(x,x,x,x)+B0p
UNDEF:00008148 ; int __cdecl RegressMain()
UNDEF:00008148                 extrn ?RegressMain@@YAHXZ:near
UNDEF:00008148                                         ; CODE XREF: WinMain(x,x,x,x)+D2p
UNDEF:0000814C ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:0000814C                 extrn @_RTC_CheckStackVars@8:near
UNDEF:0000814C                                         ; CODE XREF: ??$_Clone@X@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@ABEPAV?$_Func_base@X$$V@1@PAXU?$integral_constant@_N$0A@@1@@Z+65p
UNDEF:0000814C                                         ; ??$_Reset_alloc@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@@?$_Func_class@X$$V@std@@IAEX$$QAV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+7Ep ...
UNDEF:00008150 ; __fastcall __security_check_cookie(x)
UNDEF:00008150                 extrn @__security_check_cookie@4:near
UNDEF:00008150                                         ; CODE XREF: ClientRect::ClientRect(HWND__ *)+95p
UNDEF:00008150                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+429p ...
UNDEF:00008154                 extrn __RTC_CheckEsp:near
UNDEF:00008154                                         ; CODE XREF: ??$?0ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@std@@@?$_Func_impl@V_lambda_b6f3cb1c717d8c8a816f87295491882e_@@V?$allocator@H@std@@X$$V@std@@QAE@ABV_lambda_b6f3cb1c717d8c8a816f87295491882e_@@ABV?$allocator@H@1@@Z+6Fp
UNDEF:00008154                                         ; std::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>::_Compressed_pair<std::allocator<int>,_lambda_b6f3cb1c717d8c8a816f87295491882e_,1>(std::_One_then_variadic_args_t,std::allocator<int> const &,_lambda_b6f3cb1c717d8c8a816f87295491882e_ const &)+59p ...
UNDEF:00008158                 extrn __RTC_InitBase:near
UNDEF:00008158                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:0000815C                 extrn __RTC_Shutdown:near
UNDEF:0000815C                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00008160 ; const type_info::`vftable'
UNDEF:00008160                 extrn ??_7type_info@@6B@:near
UNDEF:00008160                                         ; DATA XREF: .data$r:_lambda_b6f3cb1c717d8c8a816f87295491882e_ `RTTI Type Descriptor'o
UNDEF:00008164 ; struct GlobalPrefs * gGlobalPrefs
UNDEF:00008164                 extrn ?gGlobalPrefs@@3PAUGlobalPrefs@@A:near
UNDEF:00008164                                         ; DATA XREF: GetAboutBgColor(void)+25r
UNDEF:00008164                                         ; GetAboutBgColor(void)+32r ...
UNDEF:00008168 ; wchar_t const * const gPluginURL
UNDEF:00008168                 extrn ?gPluginURL@@3PB_WB:near
UNDEF:00008168                                         ; DATA XREF: LoadOnStartup(wchar_t const *,CommandLineInfo &,bool):loc_3EFAr
UNDEF:00008168                                         ; MakePluginWindow(WindowInfo &,HWND__ *):loc_439Dr ...
UNDEF:0000816C ; class Vec<class WindowInfo *> gWindows
UNDEF:0000816C                 extrn ?gWindows@@3V?$Vec@PAVWindowInfo@@@@A:near
UNDEF:0000816C                                         ; DATA XREF: FileExistenceChecker::HideMissingFiles(void)+8Fo
UNDEF:0000816C                                         ; FileExistenceChecker::HideMissingFiles(void)+9Fo ...
UNDEF:00008170 ; FileHistory gFileHistory
UNDEF:00008170                 extrn ?gFileHistory@@3VFileHistory@@A:near
UNDEF:00008170                                         ; DATA XREF: FileExistenceChecker::GetFilePathsToCheck(void)+3Fo
UNDEF:00008170                                         ; FileExistenceChecker::GetFilePathsToCheck(void)+95o ...
UNDEF:00008174 ; class RenderCache gRenderCache
UNDEF:00008174                 extrn ?gRenderCache@@3VRenderCache@@A:near
UNDEF:00008174                                         ; DATA XREF: WinMain(x,x,x,x)+240o
UNDEF:00008174                                         ; WinMain(x,x,x,x)+245o
UNDEF:00008178 ; HGDIOBJ gBitmapReloadingCue
UNDEF:00008178                 extrn ?gBitmapReloadingCue@@3PAUHBITMAP__@@A:near
UNDEF:00008178                                         ; DATA XREF: InstanceInit(int)+A0w
UNDEF:00008178                                         ; InstanceInit(int)+A9r ...
UNDEF:0000817C ; struct HICON__ * gCursorDrag
UNDEF:0000817C                 extrn ?gCursorDrag@@3PAUHICON__@@A:near
UNDEF:0000817C                                         ; DATA XREF: InstanceInit(int)+44w
UNDEF:0000817C                                         ; InstanceInit(int)+4Dr
UNDEF:00008180 ; bool gCrashOnOpen
UNDEF:00008180                 extrn ?gCrashOnOpen@@3_NA:near
UNDEF:00008180                                         ; DATA XREF: WinMain(x,x,x,x)+23Bw
UNDEF:00008184                 extrn ___security_cookie:near
UNDEF:00008184                                         ; DATA XREF: ClientRect::ClientRect(HWND__ *)+20r
UNDEF:00008184                                         ; LoadOnStartup(wchar_t const *,CommandLineInfo &,bool)+1Er ...
UNDEF:00008188                 extrn __fltused:near
UNDEF:00008188
UNDEF:00008188
UNDEF:00008188                 end