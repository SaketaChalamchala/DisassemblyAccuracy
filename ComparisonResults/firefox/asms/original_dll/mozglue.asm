;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	87311EAF60CFD9D49FC95894B96DF13A
; Input	CRC32 :	D77CC5C3

; File Name   :	C:\compspace\compare\firefox\dlls\original\mozglue.dll
; Format      :	Portable executable for	80386 (PE)
; Imagebase   :	10000000
; Section 1. (virtual address 00001000)
; Virtual size			: 00014008 (  81928.)
; Section size in file		: 00014200 (  82432.)
; Offset to raw	data for section: 00000400
; Flags	60000020: Text Executable Readable
; Alignment	: default
; PDB File Name	: c:\builds\moz2_slave\rel-m-rel-w32_bld-000000000000\build\obj-firefox\mozglue\build\mozglue.pdb
; OS type	  :  MS	Windows
; Application type:  DLL 32bit

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10001000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001000	proc near		; DATA XREF: .rdata:1001621Co

var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		xor	ecx, ecx
		push	ebx
		cpuid
		push	esi
		lea	esi, [ebp+var_14]
		mov	[esi], eax
		xor	eax, eax
		mov	[esi+4], ebx
		inc	eax
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		cmp	[ebp+var_14], eax
		jnb	short loc_10001032
		xor	al, al
		jmp	short loc_1000104C
; ---------------------------------------------------------------------------

loc_10001032:				; CODE XREF: sub_10001000+2Cj
		lea	esi, [ebp+var_14]
		xor	ecx, ecx
		cpuid
		mov	[esi], eax
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		mov	eax, [ebp+var_8]
		shr	eax, 17h
		and	al, 1

loc_1000104C:				; CODE XREF: sub_10001000+30j
		mov	ecx, [ebp+var_4]
		pop	esi
		xor	ecx, ebp
		mov	?mmx_enabled@sse_private@mozilla@@3_NA,	al ; bool mozilla::sse_private::mmx_enabled
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_10001000	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001061	proc near		; DATA XREF: .rdata:10016224o

var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		xor	ecx, ecx
		push	ebx
		cpuid
		push	esi
		lea	esi, [ebp+var_14]
		mov	[esi], eax
		xor	eax, eax
		mov	[esi+4], ebx
		inc	eax
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		cmp	[ebp+var_14], eax
		jnb	short loc_10001093
		xor	al, al
		jmp	short loc_100010AD
; ---------------------------------------------------------------------------

loc_10001093:				; CODE XREF: sub_10001061+2Cj
		lea	esi, [ebp+var_14]
		xor	ecx, ecx
		cpuid
		mov	[esi], eax
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		mov	eax, [ebp+var_8]
		shr	eax, 1Ah
		and	al, 1

loc_100010AD:				; CODE XREF: sub_10001061+30j
		mov	ecx, [ebp+var_4]
		pop	esi
		xor	ecx, ebp
		mov	?sse2_enabled@sse_private@mozilla@@3_NA, al ; bool mozilla::sse_private::sse2_enabled
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_10001061	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100010C2	proc near		; DATA XREF: .rdata:10016228o

var_14		= dword	ptr -14h
var_C		= byte ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		xor	ecx, ecx
		push	ebx
		cpuid
		push	esi
		lea	esi, [ebp+var_14]
		mov	[esi], eax
		xor	eax, eax
		mov	[esi+4], ebx
		inc	eax
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		cmp	[ebp+var_14], eax
		jnb	short loc_100010F4
		xor	al, al
		jmp	short loc_1000110B
; ---------------------------------------------------------------------------

loc_100010F4:				; CODE XREF: sub_100010C2+2Cj
		lea	esi, [ebp+var_14]
		xor	ecx, ecx
		cpuid
		mov	[esi], eax
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		mov	al, [ebp+var_C]
		and	al, 1

loc_1000110B:				; CODE XREF: sub_100010C2+30j
		mov	ecx, [ebp+var_4]
		pop	esi
		xor	ecx, ebp
		mov	?sse3_enabled@sse_private@mozilla@@3_NA, al ; bool mozilla::sse_private::sse3_enabled
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_100010C2	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001120	proc near		; DATA XREF: .rdata:10016234o

var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		xor	ecx, ecx
		push	ebx
		cpuid
		push	esi
		lea	esi, [ebp+var_14]
		mov	[esi], eax
		xor	eax, eax
		mov	[esi+4], ebx
		inc	eax
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		cmp	[ebp+var_14], eax
		jnb	short loc_10001152
		xor	al, al
		jmp	short loc_1000116C
; ---------------------------------------------------------------------------

loc_10001152:				; CODE XREF: sub_10001120+2Cj
		lea	esi, [ebp+var_14]
		xor	ecx, ecx
		cpuid
		mov	[esi], eax
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		mov	eax, [ebp+var_C]
		shr	eax, 13h
		and	al, 1

loc_1000116C:				; CODE XREF: sub_10001120+30j
		mov	ecx, [ebp+var_4]
		pop	esi
		xor	ecx, ebp
		mov	?sse4_1_enabled@sse_private@mozilla@@3_NA, al ;	bool mozilla::sse_private::sse4_1_enabled
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_10001120	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001181	proc near		; DATA XREF: .rdata:10016238o

var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		xor	ecx, ecx
		push	ebx
		cpuid
		push	esi
		lea	esi, [ebp+var_14]
		mov	[esi], eax
		xor	eax, eax
		mov	[esi+4], ebx
		inc	eax
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		cmp	[ebp+var_14], eax
		jnb	short loc_100011B3
		xor	al, al
		jmp	short loc_100011CD
; ---------------------------------------------------------------------------

loc_100011B3:				; CODE XREF: sub_10001181+2Cj
		lea	esi, [ebp+var_14]
		xor	ecx, ecx
		cpuid
		mov	[esi], eax
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		mov	eax, [ebp+var_C]
		shr	eax, 14h
		and	al, 1

loc_100011CD:				; CODE XREF: sub_10001181+30j
		mov	ecx, [ebp+var_4]
		pop	esi
		xor	ecx, ebp
		mov	?sse4_2_enabled@sse_private@mozilla@@3_NA, al ;	bool mozilla::sse_private::sse4_2_enabled
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_10001181	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100011E2	proc near		; DATA XREF: .rdata:10016230o

var_14		= dword	ptr -14h
var_C		= byte ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		push	ebx
		xor	ecx, ecx
		mov	eax, 80000000h
		cpuid
		push	esi
		lea	esi, [ebp+var_14]
		mov	[esi], eax
		mov	eax, 80000001h
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		cmp	[ebp+var_14], eax
		jnb	short loc_10001219
		xor	al, al
		jmp	short loc_10001233
; ---------------------------------------------------------------------------

loc_10001219:				; CODE XREF: sub_100011E2+31j
		lea	esi, [ebp+var_14]
		xor	ecx, ecx
		cpuid
		mov	[esi], eax
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		mov	al, [ebp+var_C]
		shr	al, 6
		and	al, 1

loc_10001233:				; CODE XREF: sub_100011E2+35j
		mov	ecx, [ebp+var_4]
		pop	esi
		xor	ecx, ebp
		mov	?sse4a_enabled@sse_private@mozilla@@3_NA, al ; bool mozilla::sse_private::sse4a_enabled
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_100011E2	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001248	proc near		; DATA XREF: .rdata:10016220o

var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		xor	ecx, ecx
		push	ebx
		cpuid
		push	esi
		lea	esi, [ebp+var_14]
		mov	[esi], eax
		xor	eax, eax
		mov	[esi+4], ebx
		inc	eax
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		cmp	[ebp+var_14], eax
		jnb	short loc_1000127A
		xor	al, al
		jmp	short loc_10001294
; ---------------------------------------------------------------------------

loc_1000127A:				; CODE XREF: sub_10001248+2Cj
		lea	esi, [ebp+var_14]
		xor	ecx, ecx
		cpuid
		mov	[esi], eax
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		mov	eax, [ebp+var_8]
		shr	eax, 19h
		and	al, 1

loc_10001294:				; CODE XREF: sub_10001248+30j
		mov	ecx, [ebp+var_4]
		pop	esi
		xor	ecx, ebp
		mov	?sse_enabled@sse_private@mozilla@@3_NA,	al ; bool mozilla::sse_private::sse_enabled
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_10001248	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100012A9	proc near		; DATA XREF: .rdata:1001622Co

var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		xor	ecx, ecx
		push	ebx
		cpuid
		push	esi
		lea	esi, [ebp+var_14]
		mov	[esi], eax
		xor	eax, eax
		mov	[esi+4], ebx
		inc	eax
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		cmp	[ebp+var_14], eax
		jnb	short loc_100012DB
		xor	al, al
		jmp	short loc_100012F5
; ---------------------------------------------------------------------------

loc_100012DB:				; CODE XREF: sub_100012A9+2Cj
		lea	esi, [ebp+var_14]
		xor	ecx, ecx
		cpuid
		mov	[esi], eax
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		mov	eax, [ebp+var_C]
		shr	eax, 9
		and	al, 1

loc_100012F5:				; CODE XREF: sub_100012A9+30j
		mov	ecx, [ebp+var_4]
		pop	esi
		xor	ecx, ebp
		mov	?ssse3_enabled@sse_private@mozilla@@3_NA, al ; bool mozilla::sse_private::ssse3_enabled
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_100012A9	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000130A	proc near		; DATA XREF: .rdata:1001623Co
		call	sub_10001452
		push	offset sub_1000BF93 ; _onexit_t
		call	sub_1000B0B4
		pop	ecx
		retn
sub_1000130A	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000131B	proc near		; DATA XREF: .rdata:10016240o
		call	sub_10006DC5
		push	offset j_?Shutdown@TimeStamp@mozilla@@SAXXZ ; _onexit_t
		call	sub_1000B0B4
		pop	ecx
		retn
sub_1000131B	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000132C	proc near		; DATA XREF: .rdata:10016244o
		push	offset sub_1000BF9D ; _onexit_t
		call	sub_1000B0B4
		pop	ecx
		retn
sub_1000132C	endp


; =============== S U B	R O U T	I N E =======================================


sub_10001338	proc near		; DATA XREF: .rdata:10016248o
		call	sub_1000AF76
		push	offset sub_1000BFA8 ; _onexit_t
		call	sub_1000B0B4
		pop	ecx
		retn
sub_10001338	endp


; =============== S U B	R O U T	I N E =======================================


sub_10001349	proc near		; DATA XREF: .rdata:1001624Co
		call	sub_1000AF86
		push	offset sub_1000BFB3 ; _onexit_t
		call	sub_1000B0B4
		pop	ecx
		retn
sub_10001349	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000135A	proc near		; DATA XREF: .rdata:10016250o
		xor	eax, eax
		mov	ecx, offset ?gChaosModeCounter@detail@mozilla@@3V?$Atomic@I$01X@2@A ; mozilla::Atomic<uint,2,void> mozilla::detail::gChaosModeCounter
		xchg	eax, [ecx]
		retn
sub_1000135A	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  31. ?DllBlocklist_Initialize@@YAXXZ

; =============== S U B	R O U T	I N E =======================================


; void __cdecl DllBlocklist_Initialize()
		public ?DllBlocklist_Initialize@@YAXXZ
?DllBlocklist_Initialize@@YAXXZ	proc near ; DATA XREF: .rdata:off_100175A8o

; FUNCTION CHUNK AT 1000BFBE SIZE 00000032 BYTES

		push	offset ModuleName ; "user32.dll"
		call	ds:GetModuleHandleA
		test	eax, eax
		jz	short loc_10001386
		mov	byte_1001AAA0, 1

loc_10001386:				; CODE XREF: DllBlocklist_Initialize(void)+Dj
		push	esi
		push	edi
		xor	edi, edi
		cmp	lpLibFileName, edi
		jnz	short loc_100013B0
		push	edi		; dwFlags
		mov	eax, offset LibFileName	; "ntdll.dll"
		mov	dword_1001AA4C,	edi
		push	edi		; hFile
		push	eax		; lpLibFileName
		mov	lpLibFileName, eax
		call	ds:LoadLibraryExA
		mov	dword_1001A830,	eax

loc_100013B0:				; CODE XREF: DllBlocklist_Initialize(void)+20j
		push	offset CriticalSection ; lpCriticalSection
		call	ds:InitializeCriticalSection
		push	8
		call	moz_xmalloc
		mov	esi, eax
		pop	ecx
		test	esi, esi
		jnz	loc_1000BFBE
		mov	dword_1001A804,	edi
		jmp	short loc_100013E5
; ---------------------------------------------------------------------------

loc_100013D5:				; CODE XREF: DllBlocklist_Initialize(void)+AC7Bj
		mov	[ecx], eax

loc_100013D7:				; CODE XREF: DllBlocklist_Initialize(void)+AC75j
		mov	word ptr [eax+0Ch], 101h
		mov	[esi], eax
		mov	dword_1001A804,	esi

loc_100013E5:				; CODE XREF: DllBlocklist_Initialize(void)+63j
		sub	esp, 0Ch
		call	sub_1000141A
		test	al, al
		jz	short loc_100013F4

loc_100013F1:				; CODE XREF: DllBlocklist_Initialize(void)+8Bj
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_100013F4:				; CODE XREF: DllBlocklist_Initialize(void)+7Fj
		mov	byte_1001AAA1, 1
		jmp	short loc_100013F1
?DllBlocklist_Initialize@@YAXXZ	endp


; =============== S U B	R O U T	I N E =======================================


sub_100013FD	proc near		; CODE XREF: sub_1000BF93j

flOldProtect	= dword	ptr -4

; FUNCTION CHUNK AT 1000BFF0 SIZE 00000066 BYTES

		push	ecx
		push	esi
		mov	ecx, offset dword_1001AA38
		call	sub_1000162E
		xor	esi, esi
		cmp	dword_1001AA34,	esi
		jg	loc_1000BFF0

loc_10001417:				; CODE XREF: sub_100013FD+AC54j
		pop	esi
		pop	ecx
		retn
sub_100013FD	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000141A	proc near		; CODE XREF: DllBlocklist_Initialize(void)+78p
		mov	eax, lpLibFileName
		test	eax, eax
		jz	short loc_1000144E
		cmp	dword_1001AA38,	0
		push	esi
		mov	esi, offset dword_1001AA38
		jnz	short loc_10001440
		push	dword_1001AA4C	; int
		mov	ecx, esi
		push	eax		; lpLibFileName
		call	sub_100015D3

loc_10001440:				; CODE XREF: sub_1000141A+16j
		sub	esp, 0Ch
		mov	ecx, esi
		call	sub_1000158C
		pop	esi

locret_1000144B:			; CODE XREF: sub_1000141A+36j
		retn	0Ch
; ---------------------------------------------------------------------------

loc_1000144E:				; CODE XREF: sub_1000141A+7j
		xor	al, al
		jmp	short locret_1000144B
sub_1000141A	endp


; =============== S U B	R O U T	I N E =======================================


sub_10001452	proc near		; CODE XREF: sub_1000130Ap
		xor	eax, eax
		mov	dword_1001A830,	eax
		mov	dword_1001AA34,	eax
		mov	dword_1001AA38,	eax
		mov	dword_1001AA3C,	eax
		mov	dword_1001AA40,	eax
		mov	dword_1001AA44,	eax
		mov	lpLibFileName, eax
		mov	dword_1001AA4C,	eax
		mov	eax, offset dword_1001A830
		retn
sub_10001452	endp


; =============== S U B	R O U T	I N E =======================================


; int __stdcall	sub_10001482(void *lpAddress, int, int)
sub_10001482	proc near		; CODE XREF: sub_1000158C+23p

lpAddress	= dword	ptr  4

; FUNCTION CHUNK AT 1000C056 SIZE 00000076 BYTES

		push	esi
		xor	esi, esi
		mov	dword_1001A800,	esi
		mov	eax, [ecx+0Ch]
		cmp	eax, [ecx+8]
		jge	loc_10001555
		push	edi
		mov	edi, eax
		lea	eax, [eax+1]
		shl	edi, 7
		mov	[ecx+0Ch], eax
		add	edi, [ecx+4]
		jz	loc_10001554
		push	ebx
		mov	ebx, [esp+0Ch+lpAddress]
		push	ebp
		or	ebp, 0FFFFFFFFh

loc_100014B5:				; CODE XREF: sub_10001482+5Ej
		mov	cl, [esi+ebx]
		cmp	cl, 88h
		jb	loc_10001559
		cmp	cl, 8Bh
		ja	loc_10001559
		mov	cl, [esi+ebx+1]
		mov	al, cl
		and	al, 0C0h
		cmp	al, 0C0h
		jnz	loc_1000C056

loc_100014DA:				; CODE XREF: sub_10001482+ABE5j
					; sub_10001482+AC1Cj
		add	esi, 2

loc_100014DD:				; CODE XREF: sub_10001482+F7j
					; sub_10001482+FFj ...
		cmp	esi, 5
		jl	short loc_100014B5
		cmp	esi, 64h
		jg	short loc_10001552
		push	esi		; size_t
		mov	[edi], ebx
		add	edi, 4
		push	ebx		; void *
		push	edi		; void *
		call	memcpy
		mov	eax, ebx
		add	esp, 0Ch
		sub	eax, edi
		test	ebp, ebp
		jns	loc_10001586
		sub	eax, 5
		mov	byte ptr [esi+edi], 0E9h
		mov	[esi+edi+1], eax

loc_1000150E:				; CODE XREF: sub_10001482+108j
		lea	eax, [esp+10h+lpAddress]
		mov	dword_1001A800,	edi
		mov	edi, ds:GetCurrentProcess
		push	eax		; lpflOldProtect
		push	40h		; flNewProtect
		push	esi		; dwSize
		push	ebx		; lpAddress
		call	edi ; GetCurrentProcess
		mov	ebp, ds:VirtualProtectEx
		push	eax		; hProcess
		call	ebp ; VirtualProtectEx
		test	eax, eax
		jz	short loc_10001552
		mov	eax, offset sub_1000A8A8
		mov	byte ptr [ebx],	0E9h
		sub	eax, ebx
		sub	eax, 5
		mov	[ebx+1], eax
		lea	eax, [esp+10h+lpAddress]
		push	eax		; lpflOldProtect
		push	[esp+14h+lpAddress] ; flNewProtect
		push	esi		; dwSize
		push	ebx		; lpAddress
		call	edi ; GetCurrentProcess
		push	eax		; hProcess
		call	ebp ; VirtualProtectEx

loc_10001552:				; CODE XREF: sub_10001482+63j
					; sub_10001482+AEj ...
		pop	ebp
		pop	ebx

loc_10001554:				; CODE XREF: sub_10001482+24j
		pop	edi

loc_10001555:				; CODE XREF: sub_10001482+Fj
		pop	esi
		retn	0Ch
; ---------------------------------------------------------------------------

loc_10001559:				; CODE XREF: sub_10001482+39j
					; sub_10001482+42j
		cmp	cl, 0B8h
		jz	short loc_1000157E
		cmp	cl, 83h
		jz	loc_1000C085
		cmp	cl, 68h
		jz	short loc_1000157E
		mov	al, cl
		and	al, 0F0h
		cmp	al, 50h
		jnz	loc_1000C09B
		inc	esi
		jmp	loc_100014DD
; ---------------------------------------------------------------------------

loc_1000157E:				; CODE XREF: sub_10001482+DAj
					; sub_10001482+E8j ...
		add	esi, 5
		jmp	loc_100014DD
; ---------------------------------------------------------------------------

loc_10001586:				; CODE XREF: sub_10001482+7Bj
		add	[edi+ebp+1], eax
		jmp	short loc_1000150E
sub_10001482	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000158C	proc near		; CODE XREF: sub_1000141A+2Bp
		push	esi
		mov	esi, ecx
		cmp	dword ptr [esi], 0
		jz	short loc_100015C2
		push	offset ProcName	; "LdrLoadDll"
		push	dword ptr [esi]	; hModule
		call	ds:GetProcAddress
		test	eax, eax
		jz	short loc_100015C2
		cmp	byte ptr [eax],	0FFh
		jz	short loc_100015C6

loc_100015AA:				; CODE XREF: sub_1000158C+3Ej
					; sub_1000158C+45j
		push	ecx		; int
		push	ecx		; int
		push	eax		; lpAddress
		mov	ecx, esi
		call	sub_10001482
		cmp	dword_1001A800,	0
		setnz	al

loc_100015BE:				; CODE XREF: sub_1000158C+38j
		pop	esi
		retn	0Ch
; ---------------------------------------------------------------------------

loc_100015C2:				; CODE XREF: sub_1000158C+6j
					; sub_1000158C+17j
		xor	al, al
		jmp	short loc_100015BE
; ---------------------------------------------------------------------------

loc_100015C6:				; CODE XREF: sub_1000158C+1Cj
		cmp	byte ptr [eax+1], 25h
		jnz	short loc_100015AA
		mov	eax, [eax+2]
		mov	eax, [eax]
		jmp	short loc_100015AA
sub_1000158C	endp


; =============== S U B	R O U T	I N E =======================================


; int __stdcall	sub_100015D3(LPCSTR lpLibFileName, int)
sub_100015D3	proc near		; CODE XREF: sub_1000141A+21p

lpLibFileName	= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, ecx
		push	edi
		xor	edi, edi
		cmp	[esi], edi
		jnz	short loc_10001625
		push	edi		; dwFlags
		push	edi		; hFile
		push	[esp+10h+lpLibFileName]	; lpLibFileName
		call	ds:LoadLibraryExA
		mov	[esi], eax
		test	eax, eax
		jz	short loc_10001625
		mov	ecx, [esp+8+arg_4]
		push	20h
		pop	eax
		test	ecx, ecx
		jnz	short loc_100015FC
		mov	ecx, eax

loc_100015FC:				; CODE XREF: sub_100015D3+25j
		cdq
		idiv	ecx
		push	40h		; flProtect
		push	3000h		; flAllocationType
		lea	eax, [edx+ecx]
		mov	[esi+8], eax
		shl	eax, 7
		push	eax		; dwSize
		push	edi		; lpAddress
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:VirtualAllocEx
		mov	[esi+4], eax
		test	eax, eax
		jz	short loc_1000162A

loc_10001625:				; CODE XREF: sub_100015D3+8j
					; sub_100015D3+1Aj ...
		pop	edi
		pop	esi
		retn	8
; ---------------------------------------------------------------------------

loc_1000162A:				; CODE XREF: sub_100015D3+50j
		mov	[esi], edi
		jmp	short loc_10001625
sub_100015D3	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000162E	proc near		; CODE XREF: sub_100013FD+7p

flOldProtect	= dword	ptr -4

		push	ecx
		push	ebx
		mov	ebx, ecx
		push	esi
		xor	esi, esi
		push	edi
		mov	edi, [ebx+4]
		cmp	[ebx+0Ch], esi
		jle	short loc_10001687
		push	ebp

loc_1000163F:				; CODE XREF: sub_1000162E+56j
		mov	ebp, [edi]
		lea	eax, [esp+14h+flOldProtect]
		push	eax		; lpflOldProtect
		push	40h		; flNewProtect
		push	5		; dwSize
		push	ebp		; lpAddress
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:VirtualProtectEx
		test	eax, eax
		jz	short loc_1000167D
		mov	eax, edi
		sub	eax, ebp
		dec	eax
		mov	[ebp+1], eax
		lea	eax, [esp+14h+flOldProtect]
		push	eax		; lpflOldProtect
		push	[esp+18h+flOldProtect] ; flNewProtect
		push	5		; dwSize
		push	ebp		; lpAddress
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:VirtualProtectEx

loc_1000167D:				; CODE XREF: sub_1000162E+2Cj
		inc	esi
		sub	edi, 0FFFFFF80h
		cmp	esi, [ebx+0Ch]
		jl	short loc_1000163F
		pop	ebp

loc_10001687:				; CODE XREF: sub_1000162E+Ej
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
sub_1000162E	endp

; Exported entry 103. _wcsdup
; Exported entry 127. wcsdup

; =============== S U B	R O U T	I N E =======================================


; int __cdecl wcsdup(wchar_t *)
		public wcsdup
wcsdup		proc near		; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

		push	esi		; _wcsdup
		mov	esi, [esp+4+arg_0]
		push	edi
		lea	ecx, [esi+2]

loc_10001695:				; CODE XREF: wcsdup+12j
		mov	ax, [esi]
		add	esi, 2
		test	ax, ax
		jnz	short loc_10001695
		sub	esi, ecx
		sar	esi, 1
		lea	eax, ds:2[esi*2]
		push	eax
		call	malloc
		mov	edi, eax
		pop	ecx
		test	edi, edi
		jz	short loc_100016CA
		lea	ecx, [esi+1]
		push	ecx		; size_t
		push	[esp+0Ch+arg_0]	; wchar_t *
		push	edi		; wchar_t *
		call	ds:wcsncpy
		add	esp, 0Ch

loc_100016CA:				; CODE XREF: wcsdup+2Aj
		mov	eax, edi
		pop	edi
		pop	esi
		retn
wcsdup		endp


; =============== S U B	R O U T	I N E =======================================


sub_100016CF	proc near		; CODE XREF: sub_1000172B:loc_1000179Ap
					; strdup:loc_10002875p	...

; FUNCTION CHUNK AT 1000C0CC SIZE 0000004A BYTES

		cmp	dword_1001AB2C,	1
		push	esi
		ja	loc_1000C0CC
		mov	eax, dword_1001AB00
		mov	esi, [eax]

loc_100016E4:				; CODE XREF: sub_100016CF+AA42j
		push	esi		; lpTlsValue
		push	dwTlsIndex	; dwTlsIndex
		call	ds:TlsSetValue
		mov	eax, esi
		pop	esi
		retn
sub_100016CF	endp

; Exported entry 123. posix_memalign

; =============== S U B	R O U T	I N E =======================================


		public posix_memalign
posix_memalign	proc near		; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

; FUNCTION CHUNK AT 1000C116 SIZE 00000002 BYTES

		mov	ecx, [esp+arg_4]
		lea	eax, [ecx-1]
		test	ecx, eax
		jnz	short loc_10001724
		cmp	ecx, 4
		jb	short loc_10001724
		mov	edx, [esp+arg_8]
		call	sub_1000172B
		mov	ecx, eax
		test	ecx, ecx
		jz	short loc_1000171D
		mov	eax, [esp+arg_0]
		mov	[eax], ecx
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1000171D:				; CODE XREF: posix_memalign+1Dj
		push	0Ch
		jmp	loc_1000C116
; ---------------------------------------------------------------------------

loc_10001724:				; CODE XREF: posix_memalign+9j
					; posix_memalign+Ej
		push	16h
		jmp	loc_1000C116
posix_memalign	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000172B	proc near		; CODE XREF: posix_memalign+14p
					; _aligned_malloc+8j

; FUNCTION CHUNK AT 1000C118 SIZE 00000079 BYTES

		test	edx, edx
		jz	short loc_10001739

loc_1000172F:				; CODE XREF: sub_1000172B+11j
		cmp	ecx, 4
		jb	short loc_1000173E

loc_10001734:				; CODE XREF: sub_1000172B+16j
		jmp	loc_10001743
; ---------------------------------------------------------------------------

loc_10001739:				; CODE XREF: sub_1000172B+2j
		xor	edx, edx
		inc	edx
		jmp	short loc_1000172F
; ---------------------------------------------------------------------------

loc_1000173E:				; CODE XREF: sub_1000172B+7j
		push	4
		pop	ecx
		jmp	short loc_10001734
; ---------------------------------------------------------------------------

loc_10001743:				; CODE XREF: sub_1000172B:loc_10001734j
		push	esi
		lea	esi, [edx-1]
		mov	eax, ecx
		add	esi, ecx
		neg	eax
		and	esi, eax
		cmp	esi, edx
		jb	short loc_10001796
		push	ebx
		mov	eax, 1000h
		push	ebp
		push	edi
		cmp	esi, eax
		ja	short loc_10001780

loc_1000175F:				; CODE XREF: sub_1000172B+64j
		push	dwTlsIndex	; dwTlsIndex
		call	ds:TlsGetValue
		test	eax, eax
		jz	short loc_1000179A

loc_1000176F:				; CODE XREF: sub_1000172B+74j
		push	0
		mov	edx, esi
		mov	ecx, eax
		call	sub_100017A1

loc_1000177A:				; CODE XREF: sub_1000172B+AA41j
					; sub_1000172B+AA5Aj
		pop	ecx

loc_1000177B:				; CODE XREF: sub_1000172B+AA61j
		pop	edi
		pop	ebp
		pop	ebx
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_10001780:				; CODE XREF: sub_1000172B+32j
		mov	ebp, 0FF000h
		cmp	ecx, eax
		ja	loc_1000C118
		cmp	esi, ebp
		jbe	short loc_1000175F
		jmp	loc_1000C118
; ---------------------------------------------------------------------------

loc_10001796:				; CODE XREF: sub_1000172B+26j
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1000179A:				; CODE XREF: sub_1000172B+42j
		call	sub_100016CF
		jmp	short loc_1000176F
sub_1000172B	endp


; =============== S U B	R O U T	I N E =======================================


sub_100017A1	proc near		; CODE XREF: sub_1000172B+4Ap
		cmp	edx, 800h
		jbe	sub_100028A0
		jmp	sub_10003C40
sub_100017A1	endp

; Exported entry 119. moz_xcalloc

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public moz_xcalloc
moz_xcalloc	proc near		; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

; FUNCTION CHUNK AT 1000C191 SIZE 0000001D BYTES

		push	ebp
		mov	ebp, esp
		push	[ebp+arg_4]	; int
		push	[ebp+arg_0]	; size_t
		call	calloc
		pop	ecx
		pop	ecx
		test	eax, eax
		jz	loc_1000C191

loc_100017CA:				; CODE XREF: moz_xcalloc+A9E3j
					; moz_xcalloc+A9EDj
		pop	ebp
		retn
moz_xcalloc	endp


; =============== S U B	R O U T	I N E =======================================


; int __usercall sub_100017CC@<eax>(int@<ecx>, int)
sub_100017CC	proc near		; CODE XREF: moz_xrealloc+38Bp
					; realloc+4F1p

lpCriticalSection= dword ptr  4

		push	ebp
		push	esi
		mov	esi, [esp+8+lpCriticalSection]
		mov	ebp, ecx
		push	edi
		lea	edi, [edx+0FFFh]
		and	edi, 0FFFFF000h
		cmp	edi, esi
		jz	short loc_10001834
		push	ebx
		mov	ebx, ebp
		and	ebx, 0FFF00000h
		mov	eax, [ebx]
		mov	[esp+10h+lpCriticalSection], eax
		cmp	edi, esi
		jb	short loc_1000180C
		push	esi		; int
		push	edi		; int
		push	ebp		; int
		mov	edx, ebx
		mov	ecx, eax	; lpCriticalSection
		call	sub_10001850
		add	esp, 0Ch

loc_10001807:				; CODE XREF: sub_100017CC+66j
		pop	ebx

loc_10001808:				; CODE XREF: sub_100017CC+82j
		pop	edi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000180C:				; CODE XREF: sub_100017CC+2Aj
		mov	eax, esi
		sub	eax, edx
		push	eax		; size_t
		lea	eax, [edx+ebp]
		push	0E5h		; int
		push	eax		; void *
		call	memset
		mov	ecx, [esp+1Ch+lpCriticalSection] ; lpCriticalSection
		mov	edx, ebx
		push	esi		; int
		push	edi		; int
		push	ebp		; int
		call	sub_100058DC
		add	esp, 18h
		xor	eax, eax
		jmp	short loc_10001807
; ---------------------------------------------------------------------------

loc_10001834:				; CODE XREF: sub_100017CC+17j
		cmp	edx, esi
		jnb	short loc_1000184C
		sub	esi, edx
		lea	eax, [edx+ebp]
		push	esi		; size_t
		push	0E5h		; int
		push	eax		; void *
		call	memset
		add	esp, 0Ch

loc_1000184C:				; CODE XREF: sub_100017CC+6Aj
		xor	eax, eax
		jmp	short loc_10001808
sub_100017CC	endp


; =============== S U B	R O U T	I N E =======================================


; int __usercall sub_10001850@<eax>(LPCRITICAL_SECTION lpCriticalSection@<ecx>,	int, int, int)
sub_10001850	proc near		; CODE XREF: sub_100017CC+33p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+0Ch+arg_8]
		mov	ebp, edx
		push	edi
		mov	edi, [esp+10h+arg_0]
		mov	ebx, ecx
		sub	edi, ebp
		shr	esi, 0Ch
		push	ebx		; lpCriticalSection
		shr	edi, 0Ch
		call	ds:EnterCriticalSection
		lea	edx, [esi+edi]
		cmp	edx, 100h
		jnb	short loc_1000188B
		lea	eax, [edx+2]
		imul	eax, 0Ch
		mov	[esp+10h+arg_0], eax
		mov	eax, [eax+ebp]
		test	al, 1
		jz	short loc_1000189C

loc_1000188B:				; CODE XREF: sub_10001850+28j
					; sub_10001850+5Bj
		xor	esi, esi
		inc	esi

loc_1000188E:				; CODE XREF: sub_10001850+96j
		push	ebx		; lpCriticalSection
		call	ds:LeaveCriticalSection
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1000189C:				; CODE XREF: sub_10001850+39j
		mov	ecx, [esp+10h+arg_4]
		and	eax, 0FFFFF000h
		sub	ecx, [esp+10h+arg_8]
		cmp	eax, ecx
		jb	short loc_1000188B
		xor	esi, esi
		shl	edx, 0Ch
		push	esi
		push	1
		push	ecx
		add	edx, ebp
		mov	ecx, ebx
		call	sub_10003DC0
		add	esp, 0Ch
		mov	edx, [esp+10h+arg_4]
		mov	ecx, edx
		or	ecx, 3
		lea	eax, [edi+2]
		imul	eax, 0Ch
		mov	[eax+ebp], ecx
		mov	eax, [esp+10h+arg_0]
		mov	dword ptr [eax+ebp], 3
		sub	edx, [esp+10h+arg_8]
		add	[ebx+68h], edx
		jmp	short loc_1000188E
sub_10001850	endp


; =============== S U B	R O U T	I N E =======================================


sub_100018E8	proc near		; CODE XREF: sub_100028A0+E1p
		push	esi
		push	edi
		mov	edi, edx
		call	sub_10002E20
		mov	esi, eax
		mov	[edi], esi
		test	esi, esi
		jz	short loc_10001908
		mov	edx, edi
		mov	ecx, esi
		call	sub_100035A0
		dec	dword ptr [esi+8]

loc_10001905:				; CODE XREF: sub_100018E8+22j
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_10001908:				; CODE XREF: sub_100018E8+Fj
		xor	eax, eax
		jmp	short loc_10001905
sub_100018E8	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 121. moz_xrealloc

; =============== S U B	R O U T	I N E =======================================


; int __cdecl moz_xrealloc(void	*, size_t)
		public moz_xrealloc
moz_xrealloc	proc near		; DATA XREF: .rdata:off_100175A8o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
lpCriticalSection= dword ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

; FUNCTION CHUNK AT 1000C1AE SIZE 00000108 BYTES
; FUNCTION CHUNK AT 1000C2CA SIZE 0000001B BYTES

		sub	esp, 18h
		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+24h+arg_4]
		mov	esi, edi
		test	edi, edi
		jz	loc_10001D0A

loc_10001924:				; CODE XREF: moz_xrealloc+3FFj
		mov	ebx, [esp+24h+arg_0]
		test	ebx, ebx
		jz	loc_10001CF4
		push	ebp
		mov	ecx, ebx
		call	sub_100023C0
		mov	ebp, eax
		cmp	esi, 0FF000h
		ja	sub_1000C2B6
		cmp	esi, 9
		jb	loc_1000C1AE
		cmp	esi, 200h
		ja	loc_10001B47
		lea	eax, [ebp-9]
		cmp	eax, 1F7h
		ja	short loc_10001979
		lea	ecx, [ebp+0Fh]
		lea	eax, [esi+0Fh]
		xor	ecx, eax
		test	ecx, 0FFFFFFF0h
		jz	loc_10001AFC

loc_10001979:				; CODE XREF: moz_xrealloc+53j
					; moz_xrealloc+249j ...
		push	dwTlsIndex	; dwTlsIndex
		call	ds:TlsGetValue
		mov	edx, eax
		mov	[esp+28h+lpCriticalSection], edx
		test	edx, edx
		jz	loc_1000C22C

loc_10001993:				; CODE XREF: moz_xrealloc+A927j
		cmp	esi, 800h
		ja	loc_10001CB0
		cmp	esi, 9
		jb	loc_1000C23C
		cmp	esi, 200h
		ja	loc_10001BC8
		lea	eax, [esi+0Fh]
		and	eax, 0FFFFFFF0h
		mov	[esp+28h+var_C], eax
		shr	eax, 4
		lea	eax, [eax+eax*8]
		lea	eax, [eax+29h]

loc_100019C7:				; CODE XREF: moz_xrealloc+2F8j
		lea	eax, [edx+eax*8]
		mov	[esp+28h+var_14], eax

loc_100019CE:				; CODE XREF: moz_xrealloc+A975j
					; moz_xrealloc+A983j
		push	edx		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	ecx, [esp+28h+var_14]
		mov	eax, [ecx]
		mov	[esp+28h+var_10], eax
		test	eax, eax
		jz	loc_10001B16
		cmp	dword ptr [eax+8], 0
		jbe	loc_10001B16
		mov	edx, [eax+4]
		lea	ebx, [eax+0Ch]
		cmp	dword ptr [ebx+edx*4], 0
		lea	ebx, [ebx+edx*4]
		mov	[esp+28h+var_4], ebx
		jz	loc_10001C0D
		mov	ecx, ebx
		mov	eax, [ecx]
		bsf	eax, eax
		jz	loc_10001D1B
		lea	ecx, [eax+1]

loc_10001A18:				; CODE XREF: moz_xrealloc+40Dj
		mov	eax, [esp+28h+var_14]
		dec	ecx
		mov	ebx, [esp+28h+var_4]
		shl	edx, 5
		add	edx, ecx
		imul	edx, [eax+14h]
		add	edx, [eax+24h]
		mov	eax, 1
		add	edx, [esp+28h+var_10]
		shl	eax, cl
		mov	ecx, ebx
		xor	eax, [ebx]
		mov	[ecx], eax
		mov	eax, [esp+28h+var_10]

loc_10001A42:				; CODE XREF: moz_xrealloc+369j
					; moz_xrealloc+3CDj
		mov	ebx, [esp+28h+arg_0]

loc_10001A46:				; CODE XREF: moz_xrealloc+232j
		dec	dword ptr [eax+8]
		mov	[esp+28h+var_18], edx
		test	edx, edx
		jz	loc_1000C298
		mov	eax, [esp+28h+var_14]
		mov	ecx, [esp+28h+var_C]
		add	dword ptr [eax+28h], 1
		adc	dword ptr [eax+2Ch], 0
		mov	eax, [esp+28h+lpCriticalSection]
		push	eax		; lpCriticalSection
		add	dword ptr [eax+58h], 1
		adc	dword ptr [eax+5Ch], 0
		add	[eax+54h], ecx
		mov	eax, ds:LeaveCriticalSection
		call	eax ; LeaveCriticalSection
		mov	eax, [esp+28h+var_18]

loc_10001A80:				; CODE XREF: moz_xrealloc+3B4j
		test	eax, eax
		jz	loc_10001D29
		cmp	esi, ebp
		jb	short loc_10001A8E
		mov	esi, ebp

loc_10001A8E:				; CODE XREF: moz_xrealloc+17Aj
		push	esi		; size_t
		push	ebx		; void *
		push	eax		; void *
		call	memcpy
		mov	eax, ebx
		add	esp, 0Ch
		and	eax, 0FFFFFh
		jz	loc_1000C2AA
		mov	esi, ebx
		sub	esi, eax
		shr	eax, 0Ch
		mov	ebp, [esi]
		lea	eax, [eax+eax*2]
		lea	eax, [eax+4]
		test	byte ptr [esi+eax*4+8],	2
		lea	eax, [esi+eax*4]
		mov	[esp+28h+arg_4], eax
		jnz	loc_10001CE2
		push	ebp		; lpCriticalSection
		call	ds:EnterCriticalSection
		push	[esp+28h+arg_4]	; int
		mov	edx, esi
		mov	ecx, ebp
		push	ebx		; void *
		call	sub_10002410
		add	esp, 8
		push	ebp		; lpCriticalSection
		call	ds:LeaveCriticalSection

loc_10001AE6:				; CODE XREF: moz_xrealloc+3DFj
					; moz_xrealloc+A9A1j
		mov	ebx, [esp+28h+var_18]

loc_10001AEA:				; CODE XREF: moz_xrealloc+1EEj
					; moz_xrealloc+204j ...
		pop	ebp
		test	ebx, ebx
		jz	loc_1000C2CA

loc_10001AF3:				; CODE XREF: moz_xrealloc+3EFj
					; moz_xrealloc+A9C8j
		pop	edi
		pop	esi
		mov	eax, ebx
		pop	ebx
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_10001AFC:				; CODE XREF: moz_xrealloc+63j
					; moz_xrealloc+2B3j ...
		cmp	esi, ebp
		jnb	short loc_10001AEA
		sub	ebp, esi
		lea	eax, [esi+ebx]
		push	ebp		; size_t
		push	0E5h		; int
		push	eax		; void *
		call	memset
		add	esp, 0Ch
		jmp	short loc_10001AEA
; ---------------------------------------------------------------------------

loc_10001B16:				; CODE XREF: moz_xrealloc+D1j
					; moz_xrealloc+DBj
		mov	edx, ecx
		mov	ecx, [esp+28h+lpCriticalSection]
		call	sub_10002E20
		mov	ecx, eax
		mov	eax, [esp+28h+var_14]
		mov	[esp+28h+arg_4], ecx
		mov	[eax], ecx
		test	ecx, ecx
		jz	loc_1000C298
		mov	edx, eax
		call	sub_100035A0
		mov	edx, eax
		mov	eax, [esp+28h+arg_4]
		jmp	loc_10001A46
; ---------------------------------------------------------------------------

loc_10001B47:				; CODE XREF: moz_xrealloc+45j
		cmp	esi, 800h
		ja	loc_10001C7E
		cmp	ebp, 200h
		jbe	loc_10001979
		cmp	ebp, 800h
		ja	loc_10001979
		lea	edi, [esi-1]
		mov	eax, edi
		lea	edx, [ebp-1]
		shr	eax, 1
		or	edi, eax
		mov	eax, edi
		shr	eax, 2
		or	edi, eax
		mov	eax, edi
		shr	eax, 4
		or	edi, eax
		mov	eax, edi
		shr	eax, 8
		or	edi, eax
		mov	eax, edx
		shr	eax, 1
		or	edx, eax
		mov	eax, edx
		shr	eax, 2
		or	edx, eax
		mov	eax, edx
		shr	eax, 4
		or	edx, eax
		mov	eax, edx
		shr	eax, 8
		or	edx, eax
		mov	eax, edi
		mov	ecx, edx
		shr	eax, 10h
		shr	ecx, 10h
		or	eax, edi
		mov	edi, [esp+28h+arg_4]
		or	ecx, edx
		inc	ecx
		inc	eax
		cmp	eax, ecx
		jnz	loc_10001979
		jmp	loc_10001AFC
; ---------------------------------------------------------------------------

loc_10001BC8:				; CODE XREF: moz_xrealloc+9Ej
		lea	ecx, [esi-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 10h
		or	eax, ecx
		inc	eax
		mov	[esp+28h+var_C], eax
		shr	eax, 9
		bsf	eax, eax
		jz	loc_10001D14
		inc	eax

loc_10001BFF:				; CODE XREF: moz_xrealloc+406j
		lea	eax, [eax+eax*8]
		lea	eax, [eax+140h]
		jmp	loc_100019C7
; ---------------------------------------------------------------------------

loc_10001C0D:				; CODE XREF: moz_xrealloc+F2j
		mov	ecx, [ecx+20h]
		inc	edx
		mov	[esp+28h+var_18], edx
		mov	[esp+28h+var_4], ecx
		cmp	edx, ecx
		jnb	loc_10001CDB
		lea	ecx, [eax+0Ch]
		lea	ecx, [ecx+edx*4]
		jmp	short loc_10001C30
; ---------------------------------------------------------------------------
		align 10h

loc_10001C30:				; CODE XREF: moz_xrealloc+317j
					; moz_xrealloc+3C5j
		mov	ebx, [ecx]
		test	ebx, ebx
		jz	loc_10001CC9
		bsf	eax, ebx
		jz	loc_10001D22
		lea	ecx, [eax+1]

loc_10001C46:				; CODE XREF: moz_xrealloc+414j
		mov	eax, [esp+28h+var_14]
		dec	ecx
		mov	edi, [esp+28h+var_10]
		shl	edx, 5
		add	edx, ecx
		imul	edx, [eax+14h]
		add	edx, [eax+24h]
		mov	eax, 1
		add	edx, [esp+28h+var_10]
		shl	eax, cl
		mov	ecx, [esp+28h+var_18]
		xor	eax, ebx
		mov	[edi+ecx*4+0Ch], eax
		mov	eax, edi
		mov	edi, [esp+28h+arg_4]
		mov	[eax+4], ecx
		jmp	loc_10001A42
; ---------------------------------------------------------------------------

loc_10001C7E:				; CODE XREF: moz_xrealloc+23Dj
		cmp	ebp, 800h
		jbe	loc_10001979
		cmp	ebp, 0FF000h
		ja	loc_10001979
		push	ebp		; int
		mov	edx, esi
		mov	ecx, ebx	; int
		call	sub_100017CC
		add	esp, 4
		test	eax, eax
		jnz	loc_10001979
		jmp	loc_10001AEA
; ---------------------------------------------------------------------------

loc_10001CB0:				; CODE XREF: moz_xrealloc+89j
		mov	ecx, [esp+28h+lpCriticalSection] ; lpCriticalSection
		mov	edx, esi
		push	0		; int
		call	sub_10003C40
		add	esp, 4

loc_10001CC0:				; CODE XREF: moz_xrealloc+A995j
		mov	[esp+28h+var_18], eax
		jmp	loc_10001A80
; ---------------------------------------------------------------------------

loc_10001CC9:				; CODE XREF: moz_xrealloc+324j
		inc	edx
		add	ecx, 4
		mov	[esp+28h+var_18], edx
		cmp	edx, [esp+28h+var_4]
		jb	loc_10001C30

loc_10001CDB:				; CODE XREF: moz_xrealloc+30Bj
		xor	edx, edx
		jmp	loc_10001A42
; ---------------------------------------------------------------------------

loc_10001CE2:				; CODE XREF: moz_xrealloc+1B1j
		push	ebx		; void *
		mov	edx, esi
		mov	ecx, ebp	; lpCriticalSection
		call	sub_100049E0
		add	esp, 4
		jmp	loc_10001AE6
; ---------------------------------------------------------------------------

loc_10001CF4:				; CODE XREF: moz_xrealloc+1Aj
		mov	ecx, esi
		call	sub_100025C0
		mov	ebx, eax
		test	ebx, ebx
		jnz	loc_10001AF3
		jmp	loc_1000C2CA
; ---------------------------------------------------------------------------

loc_10001D0A:				; CODE XREF: moz_xrealloc+Ej
		mov	esi, 1
		jmp	loc_10001924
; ---------------------------------------------------------------------------

loc_10001D14:				; CODE XREF: moz_xrealloc+2E8j
		xor	eax, eax
		jmp	loc_10001BFF
; ---------------------------------------------------------------------------

loc_10001D1B:				; CODE XREF: moz_xrealloc+FFj
		xor	ecx, ecx
		jmp	loc_10001A18
; ---------------------------------------------------------------------------

loc_10001D22:				; CODE XREF: moz_xrealloc+32Dj
		xor	ecx, ecx
		jmp	loc_10001C46
; ---------------------------------------------------------------------------

loc_10001D29:				; CODE XREF: moz_xrealloc+172j
		xor	ebx, ebx
		jmp	loc_10001AEA
moz_xrealloc	endp

; Exported entry 124. realloc

; =============== S U B	R O U T	I N E =======================================


; int __cdecl realloc(void *, size_t)
		public realloc
realloc		proc near		; CODE XREF: _recalloc+23p
					; DATA XREF: .rdata:off_100175A8o

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

; FUNCTION CHUNK AT 1000C2E5 SIZE 00000039 BYTES

		sub	esp, 10h
		push	ebx
		mov	ebx, [esp+14h+arg_4]
		push	esi
		test	ebx, ebx
		jz	loc_10002381

loc_10001D41:				; CODE XREF: realloc+656j
		mov	esi, [esp+18h+arg_0]
		test	esi, esi
		jz	loc_10001F85
		push	ebp
		mov	ecx, esi
		call	sub_100023C0
		mov	ebp, eax
		mov	[esp+1Ch+var_4], ebp
		cmp	ebx, 0FF000h
		ja	loc_1000236D
		push	edi
		cmp	ebx, 9
		jb	loc_1000212F
		cmp	ebx, 200h
		ja	loc_10001F97
		lea	eax, [ebp-9]
		cmp	eax, 1F7h
		ja	short loc_10001D9B
		lea	ecx, [ebp+0Fh]
		lea	eax, [ebx+0Fh]
		xor	ecx, eax
		test	ecx, 0FFFFFFF0h
		jz	loc_1000200F

loc_10001D9B:				; CODE XREF: realloc+55j realloc+279j	...
		push	dwTlsIndex	; dwTlsIndex
		call	ds:TlsGetValue
		mov	edi, eax
		test	edi, edi
		jz	loc_1000C2E5

loc_10001DB1:				; CODE XREF: realloc+A5BCj
		cmp	ebx, 800h
		ja	loc_100022A2
		cmp	ebx, 9
		jb	loc_100021AD
		cmp	ebx, 200h
		ja	loc_10002030
		lea	eax, [ebx+0Fh]
		and	eax, 0FFFFFFF0h
		mov	[esp+20h+arg_0], eax
		shr	eax, 4
		lea	ebp, ds:29h[eax*8]
		add	ebp, eax

loc_10001DE8:				; CODE XREF: realloc+33Dj
		lea	ebp, [edi+ebp*8]
		mov	[esp+20h+arg_4], ebp

loc_10001DEF:				; CODE XREF: realloc+4C9j
					; realloc+A5C9j
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	edx, [ebp+0]
		mov	[esp+20h+var_10], edx
		test	edx, edx
		jz	loc_10002100
		cmp	dword ptr [edx+8], 0
		jbe	loc_10002100
		mov	ebp, [edx+4]
		lea	eax, [ebp+3]
		lea	eax, [edx+eax*4]
		mov	[esp+20h+var_C], eax
		mov	eax, [eax]
		test	eax, eax
		jz	loc_10002236
		bsf	eax, eax
		jz	loc_100023A0
		lea	ecx, [eax+1]

loc_10001E32:				; CODE XREF: realloc+672j
		mov	eax, [esp+20h+arg_4]
		dec	ecx
		shl	ebp, 5
		add	ebp, ecx
		imul	ebp, [eax+14h]
		add	ebp, [eax+24h]
		mov	eax, 1
		shl	eax, cl
		add	ebp, edx
		mov	ecx, [esp+20h+var_C]
		xor	[ecx], eax

loc_10001E52:				; CODE XREF: realloc+56Dj realloc+5D4j
		dec	dword ptr [edx+8]

loc_10001E55:				; CODE XREF: realloc+3FAj
		test	ebp, ebp
		jz	loc_1000C2FE
		mov	eax, [esp+20h+arg_4]
		push	edi		; lpCriticalSection
		add	dword ptr [eax+28h], 1
		adc	dword ptr [eax+2Ch], 0
		add	dword ptr [edi+58h], 1
		mov	eax, [esp+24h+arg_0]
		adc	dword ptr [edi+5Ch], 0
		add	[edi+54h], eax
		mov	eax, ds:LeaveCriticalSection
		call	eax ; LeaveCriticalSection

loc_10001E80:				; CODE XREF: realloc+582j
					; realloc+A5D8j
		test	ebp, ebp
		jz	loc_100023AE
		mov	eax, [esp+20h+var_4]
		cmp	ebx, eax
		jb	short loc_10001E92
		mov	ebx, eax

loc_10001E92:				; CODE XREF: realloc+15Ej
		push	ebx		; size_t
		push	esi		; void *
		push	ebp		; void *
		call	memcpy
		mov	eax, esi
		add	esp, 0Ch
		mov	ecx, esi
		and	eax, 0FFFFFh
		jz	loc_100023B5
		sub	ecx, eax
		shr	eax, 0Ch
		mov	[esp+20h+var_C], ecx
		mov	edi, [ecx]
		lea	eax, [eax+eax*2]
		test	byte ptr [ecx+eax*4+18h], 2
		lea	ebx, [ecx+eax*4]
		jnz	loc_100022BF
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	eax, [ebx+18h]
		and	eax, 0FFFFF000h
		mov	[esp+20h+arg_4], eax
		mov	eax, [eax]
		mov	[esp+20h+arg_0], eax
		mov	ebx, [eax+14h]
		push	ebx		; size_t
		push	0E5h		; int
		push	esi		; void *
		call	memset
		mov	eax, [esp+2Ch+arg_0]
		add	esp, 0Ch
		mov	edx, [esp+20h+arg_4]
		sub	esi, [eax+24h]
		lea	eax, [ebx-1]
		sub	esi, edx
		test	ebx, eax
		jnz	loc_100020DD
		cmp	ebx, 80h
		ja	loc_10002072
		mov	cl, ds:byte_1001680F[ebx]
		shr	esi, cl

loc_10001F1F:				; CODE XREF: realloc+35Fj realloc+3CBj ...
		mov	ecx, esi
		shr	ecx, 5
		cmp	ecx, [edx+4]
		jb	loc_100022B7

loc_10001F2D:				; CODE XREF: realloc+58Aj
		lea	eax, [edx+ecx*4]
		shl	ecx, 5
		sub	esi, ecx
		mov	ecx, esi
		mov	esi, 1
		shl	esi, cl
		or	[eax+0Ch], esi
		mov	esi, [esp+20h+arg_0]
		inc	dword ptr [edx+8]
		mov	eax, [edx+8]
		mov	ecx, [esi+1Ch]
		cmp	eax, ecx
		jz	loc_10002309
		cmp	eax, 1
		jz	loc_10002094

loc_10001F5F:				; CODE XREF: realloc+368j realloc+3A8j ...
		sub	[edi+54h], ebx
		add	dword ptr [edi+60h], 1
		push	edi		; lpCriticalSection
		adc	dword ptr [edi+64h], 0
		call	ds:LeaveCriticalSection

loc_10001F71:				; CODE XREF: realloc+59Cj realloc+68Aj
		mov	esi, ebp

loc_10001F73:				; CODE XREF: realloc+2E1j realloc+2FBj ...
		pop	edi

loc_10001F74:				; CODE XREF: realloc+64Cj
		pop	ebp
		test	esi, esi
		jz	loc_1000C30D

loc_10001F7D:				; CODE XREF: realloc+260j
					; realloc+A5E9j
		mov	eax, esi
		pop	esi
		pop	ebx
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_10001F85:				; CODE XREF: realloc+17j
		mov	ecx, ebx
		call	sub_100025C0
		mov	esi, eax
		test	esi, esi
		jnz	short loc_10001F7D
		jmp	loc_1000C30D
; ---------------------------------------------------------------------------

loc_10001F97:				; CODE XREF: realloc+47j
		cmp	ebx, 800h
		ja	loc_10002204
		cmp	ebp, 200h
		jbe	loc_10001D9B
		cmp	ebp, 800h
		ja	loc_10001D9B
		lea	edi, [ebx-1]
		mov	eax, edi
		lea	edx, [ebp-1]
		shr	eax, 1
		or	edi, eax
		mov	eax, edi
		shr	eax, 2
		or	edi, eax
		mov	eax, edi
		shr	eax, 4
		or	edi, eax
		mov	eax, edi
		shr	eax, 8
		or	edi, eax
		mov	eax, edx
		shr	eax, 1
		or	edx, eax
		mov	eax, edx
		shr	eax, 2
		or	edx, eax
		mov	eax, edx
		shr	eax, 4
		or	edx, eax
		mov	eax, edx
		shr	eax, 8
		or	edx, eax
		mov	eax, edi
		mov	ecx, edx
		shr	eax, 10h
		shr	ecx, 10h
		or	eax, edi
		or	ecx, edx
		inc	eax
		inc	ecx
		cmp	eax, ecx
		jnz	loc_10001D9B

loc_1000200F:				; CODE XREF: realloc+65j realloc+478j
		cmp	ebx, ebp
		jnb	loc_10001F73
		sub	ebp, ebx
		lea	eax, [esi+ebx]
		push	ebp		; size_t
		push	0E5h		; int
		push	eax		; void *
		call	memset
		add	esp, 0Ch
		jmp	loc_10001F73
; ---------------------------------------------------------------------------

loc_10002030:				; CODE XREF: realloc+9Cj
		lea	ecx, [ebx-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 10h
		or	eax, ecx
		inc	eax
		mov	[esp+20h+arg_0], eax
		shr	eax, 9
		bsf	eax, eax
		jz	loc_10002399
		inc	eax

loc_10002067:				; CODE XREF: realloc+66Bj
		lea	ebp, [eax+28h]
		lea	ebp, [eax+ebp*8]
		jmp	loc_10001DE8
; ---------------------------------------------------------------------------

loc_10002072:				; CODE XREF: realloc+1E1j
		cmp	ebx, 8000h
		ja	loc_1000232E
		mov	eax, ebx
		shr	eax, 8
		movzx	ecx, ds:byte_1001680F[eax]
		add	ecx, 8
		shr	esi, cl
		jmp	loc_10001F1F
; ---------------------------------------------------------------------------

loc_10002094:				; CODE XREF: realloc+229j
		mov	eax, [esi]
		cmp	edx, eax
		jz	loc_10001F5F
		test	eax, eax
		jz	loc_1000233F
		cmp	edx, eax
		jnb	loc_100022D1
		cmp	dword ptr [eax+8], 0
		jbe	short loc_100020D6
		mov	ecx, eax
		and	ecx, 0FFF00000h
		sub	eax, ecx
		shr	eax, 0Ch
		lea	edx, [eax+2]
		lea	edx, [eax+edx*2]
		lea	edx, [ecx+edx*4]
		lea	ecx, [esi+4]
		call	sub_10004840
		mov	edx, [esp+20h+arg_4]

loc_100020D6:				; CODE XREF: realloc+382j
		mov	[esi], edx
		jmp	loc_10001F5F
; ---------------------------------------------------------------------------

loc_100020DD:				; CODE XREF: realloc+1D5j
		cmp	ebx, 1D2h
		ja	loc_1000232E
		mov	eax, ebx
		shr	eax, 4
		mov	eax, ds:dword_10016884[eax*4]
		imul	esi, eax
		shr	esi, 15h
		jmp	loc_10001F1F
; ---------------------------------------------------------------------------

loc_10002100:				; CODE XREF: realloc+CFj realloc+D9j
		mov	edx, ebp
		mov	ecx, edi
		call	sub_10002E20
		mov	[esp+20h+var_8], eax
		mov	[ebp+0], eax
		test	eax, eax
		jz	loc_1000C2FE
		mov	edx, ebp
		mov	ecx, eax
		call	sub_100035A0
		mov	ebp, eax
		mov	eax, [esp+20h+var_8]
		dec	dword ptr [eax+8]
		jmp	loc_10001E55
; ---------------------------------------------------------------------------

loc_1000212F:				; CODE XREF: realloc+3Bj
		cmp	ebp, 9
		jnb	loc_10001D9B
		lea	ecx, [ebx-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 10h
		or	eax, ecx
		inc	eax
		shr	eax, 2
		bsf	eax, eax
		jz	loc_1000238B
		lea	edx, [eax+1]

loc_1000216D:				; CODE XREF: realloc+65Dj
		lea	ecx, [ebp-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 10h
		or	eax, ecx
		inc	eax
		shr	eax, 2
		bsf	eax, eax
		jz	loc_10002327
		inc	eax

loc_100021A0:				; CODE XREF: realloc+5F9j
		cmp	edx, eax
		jnz	loc_10001D9B
		jmp	loc_1000200F
; ---------------------------------------------------------------------------

loc_100021AD:				; CODE XREF: realloc+90j
		lea	ecx, [ebx-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	edx, ecx
		shr	edx, 10h
		or	edx, ecx
		inc	edx
		mov	eax, edx
		mov	[esp+20h+arg_0], edx
		shr	eax, 2
		bsf	eax, eax
		jz	loc_10002392
		inc	eax

loc_100021E6:				; CODE XREF: realloc+664j
		lea	ebp, ds:17h[eax*8]
		add	ebp, eax
		lea	ebp, [edi+ebp*8]
		mov	[esp+20h+arg_4], ebp
		cmp	edx, 2
		jnb	loc_10001DEF
		jmp	loc_1000C2F1
; ---------------------------------------------------------------------------

loc_10002204:				; CODE XREF: realloc+26Dj
		cmp	ebp, 800h
		jbe	loc_10001D9B
		cmp	ebp, 0FF000h
		ja	loc_10001D9B
		push	ebp		; int
		mov	edx, ebx
		mov	ecx, esi	; int
		call	sub_100017CC
		add	esp, 4
		test	eax, eax
		jnz	loc_10001D9B
		jmp	loc_10001F73
; ---------------------------------------------------------------------------

loc_10002236:				; CODE XREF: realloc+F0j
		mov	eax, [esp+20h+arg_4]
		inc	ebp
		mov	eax, [eax+20h]
		mov	[esp+20h+var_8], eax
		cmp	ebp, eax
		jnb	loc_10002302
		lea	ecx, [ebp+3]
		lea	ecx, [edx+ecx*4]
		mov	[esp+20h+var_C], ecx

loc_10002254:				; CODE XREF: realloc+5CCj
		mov	eax, [ecx]
		test	eax, eax
		jz	loc_100022F0
		bsf	eax, eax
		jz	loc_100023A7
		lea	ecx, [eax+1]

loc_1000226A:				; CODE XREF: realloc+679j
		mov	eax, [esp+20h+arg_4]
		dec	ecx
		mov	edx, ebp
		shl	edx, 5
		add	edx, ecx
		imul	edx, [eax+14h]
		add	edx, [eax+24h]
		mov	eax, 1
		add	edx, [esp+20h+var_10]
		shl	eax, cl
		mov	ecx, [esp+20h+var_C]
		xor	eax, [ecx]
		mov	ecx, [esp+20h+var_10]
		mov	[ecx+ebp*4+0Ch], eax
		mov	[ecx+4], ebp
		mov	ebp, edx
		mov	edx, ecx
		jmp	loc_10001E52
; ---------------------------------------------------------------------------

loc_100022A2:				; CODE XREF: realloc+87j
		push	0		; int
		mov	edx, ebx
		mov	ecx, edi	; lpCriticalSection
		call	sub_10003C40
		add	esp, 4
		mov	ebp, eax
		jmp	loc_10001E80
; ---------------------------------------------------------------------------

loc_100022B7:				; CODE XREF: realloc+1F7j
		mov	[edx+4], ecx
		jmp	loc_10001F2D
; ---------------------------------------------------------------------------

loc_100022BF:				; CODE XREF: realloc+192j
		mov	edx, ecx
		mov	ecx, edi	; lpCriticalSection
		push	esi		; void *
		call	sub_100049E0
		add	esp, 4
		jmp	loc_10001F71
; ---------------------------------------------------------------------------

loc_100022D1:				; CODE XREF: realloc+378j
		mov	ecx, [esp+20h+var_C]
		sub	edx, ecx
		shr	edx, 0Ch
		lea	edx, [edx+edx*2]
		lea	edx, [edx+4]
		lea	edx, [ecx+edx*4]
		lea	ecx, [esi+4]
		call	sub_10004840
		jmp	loc_10001F5F
; ---------------------------------------------------------------------------

loc_100022F0:				; CODE XREF: realloc+528j
		inc	ebp
		add	ecx, 4
		mov	[esp+20h+var_C], ecx
		cmp	ebp, [esp+20h+var_8]
		jb	loc_10002254

loc_10002302:				; CODE XREF: realloc+514j
		xor	ebp, ebp
		jmp	loc_10001E52
; ---------------------------------------------------------------------------

loc_10002309:				; CODE XREF: realloc+220j
		cmp	edx, [esi]
		jnz	short loc_10002346
		mov	dword ptr [esi], 0

loc_10002313:				; CODE XREF: realloc+619j realloc+63Bj
		push	1
		mov	ecx, edi
		call	sub_10004A40
		add	esp, 4
		dec	dword ptr [esi+44h]
		jmp	loc_10001F5F
; ---------------------------------------------------------------------------

loc_10002327:				; CODE XREF: realloc+469j
		xor	eax, eax
		jmp	loc_100021A0
; ---------------------------------------------------------------------------

loc_1000232E:				; CODE XREF: realloc+348j realloc+3B3j
		mov	eax, esi
		xor	edx, edx
		div	ebx
		mov	edx, [esp+20h+arg_4]
		mov	esi, eax
		jmp	loc_10001F1F
; ---------------------------------------------------------------------------

loc_1000233F:				; CODE XREF: realloc+370j
		mov	[esi], edx
		jmp	loc_10001F5F
; ---------------------------------------------------------------------------

loc_10002346:				; CODE XREF: realloc+5DBj
		cmp	ecx, 1
		jz	short loc_10002313
		mov	ecx, [esp+20h+var_C]
		mov	eax, edx
		sub	eax, ecx
		shr	eax, 0Ch
		lea	edx, [eax+2]
		lea	edx, [eax+edx*2]
		lea	edx, [ecx+edx*4]
		lea	ecx, [esi+4]
		call	sub_10003640
		mov	edx, [esp+20h+arg_4]
		jmp	short loc_10002313
; ---------------------------------------------------------------------------

loc_1000236D:				; CODE XREF: realloc+31j
		push	ebp		; int
		mov	edx, ebx	; size_t
		mov	ecx, esi	; void *
		call	sub_10006906
		add	esp, 4
		mov	esi, eax
		jmp	loc_10001F74
; ---------------------------------------------------------------------------

loc_10002381:				; CODE XREF: realloc+Bj
		mov	ebx, 1
		jmp	loc_10001D41
; ---------------------------------------------------------------------------

loc_1000238B:				; CODE XREF: realloc+434j
		xor	edx, edx
		jmp	loc_1000216D
; ---------------------------------------------------------------------------

loc_10002392:				; CODE XREF: realloc+4AFj
		xor	eax, eax
		jmp	loc_100021E6
; ---------------------------------------------------------------------------

loc_10002399:				; CODE XREF: realloc+330j
		xor	eax, eax
		jmp	loc_10002067
; ---------------------------------------------------------------------------

loc_100023A0:				; CODE XREF: realloc+F9j
		xor	ecx, ecx
		jmp	loc_10001E32
; ---------------------------------------------------------------------------

loc_100023A7:				; CODE XREF: realloc+531j
		xor	ecx, ecx
		jmp	loc_1000226A
; ---------------------------------------------------------------------------

loc_100023AE:				; CODE XREF: realloc+152j
		xor	esi, esi
		jmp	loc_10001F73
; ---------------------------------------------------------------------------

loc_100023B5:				; CODE XREF: realloc+176j
		call	sub_10006073
		jmp	loc_10001F71
realloc		endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


sub_100023C0	proc near		; CODE XREF: moz_xrealloc+23p
					; realloc+20p ...

var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch

; FUNCTION CHUNK AT 1000C31E SIZE 0000002D BYTES

		sub	esp, 1Ch
		push	esi
		mov	esi, ecx
		mov	eax, esi
		and	eax, 0FFF00000h
		cmp	eax, esi
		jz	loc_1000C31E
		and	ecx, 0FFF00000h
		sub	esi, ecx
		shr	esi, 0Ch
		add	esi, 2
		lea	eax, [esi+esi*2]
		mov	ecx, [ecx+eax*4]
		test	cl, 2
		jnz	short loc_10002400
		and	ecx, 0FFFFF000h
		mov	eax, [ecx]
		mov	ecx, [eax+14h]

loc_100023F9:				; CODE XREF: sub_100023C0+46j
		mov	eax, ecx

loc_100023FB:				; CODE XREF: sub_100023C0+9F86j
		pop	esi
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_10002400:				; CODE XREF: sub_100023C0+2Cj
		and	ecx, 0FFFFF000h
		jmp	short loc_100023F9
sub_100023C0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_10002410(void	*, int)
sub_10002410	proc near		; CODE XREF: moz_xrealloc+1C7p
					; sub_1000695C+6B97p

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

; FUNCTION CHUNK AT 1000C34B SIZE 0000000D BYTES

		push	ecx
		mov	eax, [esp+4+arg_4]
		push	ebx
		push	ebp
		push	esi
		mov	ebx, [eax+8]
		mov	esi, ecx
		and	ebx, 0FFFFF000h
		mov	[esp+10h+var_4], edx
		push	edi
		mov	edi, [esp+14h+arg_0]
		mov	eax, [ebx]
		mov	[esp+14h+arg_4], eax
		mov	ebp, [eax+14h]
		push	ebp		; size_t
		push	0E5h		; int
		push	edi		; void *
		call	memset
		mov	eax, [esp+20h+arg_4]
		add	esp, 0Ch
		sub	edi, [eax+24h]
		lea	eax, [ebp-1]
		sub	edi, ebx
		test	ebp, eax
		jnz	loc_1000252C
		cmp	ebp, 80h
		ja	loc_10002502
		mov	cl, ss:byte_1001680F[ebp]
		shr	edi, cl

loc_1000246C:				; CODE XREF: sub_10002410+10Fj
					; sub_10002410+13Aj ...
		mov	eax, edi
		shr	eax, 5
		cmp	eax, [ebx+4]
		jb	loc_10002524

loc_1000247A:				; CODE XREF: sub_10002410+117j
		lea	edx, [ebx+eax*4]
		shl	eax, 5
		sub	edi, eax
		mov	eax, 1
		mov	ecx, edi
		mov	edi, [esp+14h+arg_4]
		shl	eax, cl
		or	[edx+0Ch], eax
		inc	dword ptr [ebx+8]
		mov	eax, [ebx+8]
		mov	ecx, [edi+1Ch]
		cmp	eax, ecx
		jz	loc_1000256E
		cmp	eax, 1
		jz	short loc_100024B9

loc_100024A8:				; CODE XREF: sub_10002410+ADj
					; sub_10002410+159j
		sub	[esi+54h], ebp
		add	dword ptr [esi+60h], 1
		pop	edi
		adc	dword ptr [esi+64h], 0
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_100024B9:				; CODE XREF: sub_10002410+96j
		mov	eax, [edi]
		cmp	ebx, eax
		jz	short loc_100024A8
		test	eax, eax
		jz	short loc_100024EF
		cmp	ebx, eax
		jnb	loc_1000254F
		cmp	dword ptr [eax+8], 0
		jbe	short loc_100024EF
		mov	ecx, eax
		and	ecx, 0FFF00000h
		sub	eax, ecx
		shr	eax, 0Ch
		lea	edx, [eax+2]
		lea	edx, [eax+edx*2]
		lea	edx, [ecx+edx*4]
		lea	ecx, [edi+4]
		call	sub_10004840

loc_100024EF:				; CODE XREF: sub_10002410+B1j
					; sub_10002410+BFj
		mov	[edi], ebx
		sub	[esi+54h], ebp
		add	dword ptr [esi+60h], 1
		pop	edi
		adc	dword ptr [esi+64h], 0
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_10002502:				; CODE XREF: sub_10002410+4Ej
		cmp	ebp, 8000h
		ja	loc_1000C34B
		mov	eax, ebp
		shr	eax, 8
		movzx	ecx, ds:byte_1001680F[eax]
		add	ecx, 8
		shr	edi, cl
		jmp	loc_1000246C
; ---------------------------------------------------------------------------

loc_10002524:				; CODE XREF: sub_10002410+64j
		mov	[ebx+4], eax
		jmp	loc_1000247A
; ---------------------------------------------------------------------------

loc_1000252C:				; CODE XREF: sub_10002410+42j
		cmp	ebp, 1D2h
		ja	loc_1000C34B
		mov	eax, ebp
		shr	eax, 4
		mov	eax, ds:dword_10016884[eax*4]
		imul	edi, eax
		shr	edi, 15h
		jmp	loc_1000246C
; ---------------------------------------------------------------------------

loc_1000254F:				; CODE XREF: sub_10002410+B5j
		mov	ecx, [esp+14h+var_4]
		sub	ebx, ecx
		shr	ebx, 0Ch
		lea	edx, [ebx+2]
		lea	edx, [ebx+edx*2]
		lea	edx, [ecx+edx*4]
		lea	ecx, [edi+4]
		call	sub_10004840
		jmp	loc_100024A8
; ---------------------------------------------------------------------------

loc_1000256E:				; CODE XREF: sub_10002410+8Dj
		cmp	ebx, [edi]
		jnz	short loc_1000259A
		mov	dword ptr [edi], 0

loc_10002578:				; CODE XREF: sub_10002410+18Dj
					; sub_10002410+1ABj
		push	1
		mov	edx, ebx
		mov	ecx, esi
		call	sub_10004A40
		dec	dword ptr [edi+44h]
		add	esp, 4
		sub	[esi+54h], ebp
		add	dword ptr [esi+60h], 1
		adc	dword ptr [esi+64h], 0
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1000259A:				; CODE XREF: sub_10002410+160j
		cmp	ecx, 1
		jz	short loc_10002578
		mov	ecx, [esp+14h+var_4]
		mov	eax, ebx
		sub	eax, ecx
		shr	eax, 0Ch
		lea	edx, [eax+2]
		lea	edx, [eax+edx*2]
		lea	edx, [ecx+edx*4]
		lea	ecx, [edi+4]
		call	sub_10003640
		jmp	short loc_10002578
sub_10002410	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


sub_100025C0	proc near		; CODE XREF: moz_xrealloc+3E6p
					; realloc+257p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

; FUNCTION CHUNK AT 1000C358 SIZE 0000002E BYTES

		sub	esp, 8
		push	edi
		mov	edi, ecx
		cmp	edi, 0FF000h
		ja	loc_1000C372
		push	esi
		push	dwTlsIndex	; dwTlsIndex
		call	ds:TlsGetValue
		mov	esi, eax
		test	esi, esi
		jz	loc_1000C358

loc_100025E9:				; CODE XREF: sub_100025C0+9D9Fj
		cmp	edi, 800h
		ja	loc_100026CE
		push	ebx
		push	ebp
		cmp	edi, 9
		jb	loc_1000277E
		cmp	edi, 200h
		ja	loc_10002742
		lea	ebp, [edi+0Fh]
		and	ebp, 0FFFFFFF0h
		mov	eax, ebp
		shr	eax, 4
		lea	edi, ds:29h[eax*8]
		add	edi, eax

loc_10002620:				; CODE XREF: sub_100025C0+1B9j
		lea	edi, [esi+edi*8]

loc_10002623:				; CODE XREF: sub_100025C0+1FFj
					; sub_100025C0+20Aj
		push	esi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	ebx, [edi]
		test	ebx, ebx
		jz	short loc_100026AC
		cmp	dword ptr [ebx+8], 0
		jbe	short loc_100026AC
		mov	edx, [ebx+4]
		lea	eax, [edx+3]
		lea	eax, [ebx+eax*4]
		mov	[esp+18h+var_4], eax
		mov	eax, [eax]
		test	eax, eax
		jz	loc_100026E0
		bsf	eax, eax
		jz	loc_100027F2
		lea	ecx, [eax+1]

loc_10002659:				; CODE XREF: sub_100025C0+234j
		shl	edx, 5
		dec	ecx
		add	edx, ecx
		mov	eax, 1
		imul	edx, [edi+14h]
		shl	eax, cl
		mov	ecx, [esp+18h+var_4]
		add	edx, [edi+24h]
		add	edx, ebx
		xor	[ecx], eax

loc_10002675:				; CODE XREF: sub_100025C0+10Cj
					; sub_100025C0+17Dj ...
		dec	dword ptr [ebx+8]
		mov	[esp+18h+var_8], edx
		test	edx, edx
		jz	loc_1000C364
		add	dword ptr [edi+28h], 1
		push	esi		; lpCriticalSection
		adc	dword ptr [edi+2Ch], 0
		add	dword ptr [esi+58h], 1
		adc	dword ptr [esi+5Ch], 0
		add	[esi+54h], ebp
		call	ds:LeaveCriticalSection
		mov	ecx, [esp+18h+var_8]

loc_100026A2:				; CODE XREF: sub_100025C0+9DADj
		pop	ebp
		pop	ebx

loc_100026A4:				; CODE XREF: sub_100025C0+11Ej
		mov	eax, ecx
		pop	esi

loc_100026A7:				; CODE XREF: sub_100025C0+9DC1j
		pop	edi
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_100026AC:				; CODE XREF: sub_100025C0+6Ej
					; sub_100025C0+74j
		mov	edx, edi
		mov	ecx, esi
		call	sub_10002E20
		mov	ebx, eax
		mov	[edi], ebx
		test	ebx, ebx
		jz	loc_1000C364
		mov	edx, edi
		mov	ecx, ebx
		call	sub_100035A0
		mov	edx, eax
		jmp	short loc_10002675
; ---------------------------------------------------------------------------

loc_100026CE:				; CODE XREF: sub_100025C0+2Fj
		push	0		; int
		mov	edx, edi
		mov	ecx, esi	; lpCriticalSection
		call	sub_10003C40
		add	esp, 4
		mov	ecx, eax
		jmp	short loc_100026A4
; ---------------------------------------------------------------------------

loc_100026E0:				; CODE XREF: sub_100025C0+87j
		inc	edx
		mov	[esp+18h+var_8], edx
		cmp	edx, [edi+20h]
		jnb	loc_100027E4
		lea	ecx, [edx+3]
		lea	ecx, [ebx+ecx*4]
		mov	[esp+18h+var_4], ecx
		jmp	short loc_10002700
; ---------------------------------------------------------------------------
		align 10h

loc_10002700:				; CODE XREF: sub_100025C0+138j
					; sub_100025C0+21Ej
		mov	eax, [ecx]
		test	eax, eax
		jz	loc_100027CF
		bsf	eax, eax
		jz	loc_100027F9
		lea	ecx, [eax+1]

loc_10002716:				; CODE XREF: sub_100025C0+23Bj
		dec	ecx
		shl	edx, 5
		add	edx, ecx
		mov	eax, 1
		imul	edx, [edi+14h]
		shl	eax, cl
		mov	ecx, [esp+18h+var_4]
		add	edx, [edi+24h]
		add	edx, ebx
		xor	eax, [ecx]
		mov	ecx, [esp+18h+var_8]
		mov	[ebx+ecx*4+0Ch], eax
		mov	[ebx+4], ecx
		jmp	loc_10002675
; ---------------------------------------------------------------------------

loc_10002742:				; CODE XREF: sub_100025C0+46j
		lea	ecx, [edi-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	ebp, ecx
		shr	ebp, 10h
		or	ebp, ecx
		inc	ebp
		mov	eax, ebp
		shr	eax, 9
		bsf	eax, eax
		jz	short loc_100027EE
		inc	eax

loc_10002773:				; CODE XREF: sub_100025C0+230j
		lea	edi, [eax+28h]
		lea	edi, [eax+edi*8]
		jmp	loc_10002620
; ---------------------------------------------------------------------------

loc_1000277E:				; CODE XREF: sub_100025C0+3Aj
		lea	ecx, [edi-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	ebp, ecx
		shr	ebp, 10h
		or	ebp, ecx
		inc	ebp
		mov	eax, ebp
		shr	eax, 2
		bsf	eax, eax
		jnz	short loc_100027EB
		xor	eax, eax

loc_100027B0:				; CODE XREF: sub_100025C0+22Cj
		lea	edi, ds:17h[eax*8]
		add	edi, eax
		lea	edi, [esi+edi*8]
		cmp	ebp, 2
		jnb	loc_10002623
		mov	ebp, 2
		jmp	loc_10002623
; ---------------------------------------------------------------------------

loc_100027CF:				; CODE XREF: sub_100025C0+144j
		inc	edx
		add	ecx, 4
		mov	[esp+18h+var_8], edx
		mov	[esp+18h+var_4], ecx
		cmp	edx, [edi+20h]
		jb	loc_10002700

loc_100027E4:				; CODE XREF: sub_100025C0+128j
		xor	edx, edx
		jmp	loc_10002675
; ---------------------------------------------------------------------------

loc_100027EB:				; CODE XREF: sub_100025C0+1ECj
		inc	eax
		jmp	short loc_100027B0
; ---------------------------------------------------------------------------

loc_100027EE:				; CODE XREF: sub_100025C0+1B0j
		xor	eax, eax
		jmp	short loc_10002773
; ---------------------------------------------------------------------------

loc_100027F2:				; CODE XREF: sub_100025C0+90j
		xor	ecx, ecx
		jmp	loc_10002659
; ---------------------------------------------------------------------------

loc_100027F9:				; CODE XREF: sub_100025C0+14Dj
		xor	ecx, ecx
		jmp	loc_10002716
sub_100025C0	endp

; Exported entry 102. _strdup
; Exported entry 125. strdup

; =============== S U B	R O U T	I N E =======================================


; int __cdecl strdup(char *)
		public strdup
strdup		proc near		; CODE XREF: moz_xstrdup+4p
					; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000C386 SIZE 00000013 BYTES

		push	ebx		; _strdup
		mov	ebx, [esp+4+arg_0]
		push	esi
		mov	esi, ebx
		push	edi
		lea	ecx, [esi+1]
		lea	esp, [esp+0]

loc_10002810:				; CODE XREF: strdup+15j
		mov	al, [esi]
		inc	esi
		test	al, al
		jnz	short loc_10002810
		sub	esi, ecx
		lea	edi, [esi+1]
		test	edi, edi
		jz	short loc_1000286E
		cmp	edi, 0FF000h
		ja	loc_1000C386

loc_1000282C:				; CODE XREF: strdup+73j
		push	dwTlsIndex	; dwTlsIndex
		call	ds:TlsGetValue
		test	eax, eax
		jz	short loc_10002875

loc_1000283C:				; CODE XREF: strdup+7Aj
		mov	edx, edi
		mov	ecx, eax	; lpCriticalSection
		push	0		; int
		cmp	edi, 800h
		ja	short loc_1000287C
		call	sub_100028A0

loc_1000284F:				; CODE XREF: strdup+81j strdup+9B94j
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	short loc_10002883
		push	esi		; size_t
		push	ebx		; char *
		push	edi		; char *
		call	ds:strncpy
		add	esp, 0Ch
		mov	byte ptr [edi+esi], 0

loc_10002868:				; CODE XREF: strdup+8Fj
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1000286E:				; CODE XREF: strdup+1Ej
		mov	edi, 1
		jmp	short loc_1000282C
; ---------------------------------------------------------------------------

loc_10002875:				; CODE XREF: strdup+3Aj
		call	sub_100016CF
		jmp	short loc_1000283C
; ---------------------------------------------------------------------------

loc_1000287C:				; CODE XREF: strdup+48j
		call	sub_10003C40
		jmp	short loc_1000284F
; ---------------------------------------------------------------------------

loc_10002883:				; CODE XREF: strdup+56j
		call	ds:_errno
		mov	dword ptr [eax], 0Ch
		jmp	short loc_10002868
strdup		endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


; int __usercall sub_100028A0@<eax>(LPCRITICAL_SECTION lpCriticalSection@<ecx>,	int)
sub_100028A0	proc near		; CODE XREF: sub_100017A1+6j
					; strdup+4Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000C399 SIZE 0000002B BYTES

		push	ecx
		push	ebp
		push	esi
		mov	esi, ecx
		push	edi
		cmp	edx, 9
		jnb	loc_10002958
		lea	ecx, [edx-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	ebp, ecx
		shr	ebp, 10h
		or	ebp, ecx
		inc	ebp
		mov	eax, ebp
		mov	[esp+10h+var_4], ebp
		shr	eax, 2
		bsf	eax, eax
		jz	loc_100029C5
		inc	eax

loc_100028E8:				; CODE XREF: sub_100028A0+127j
		lea	edi, ds:17h[eax*8]
		add	edi, eax
		lea	edi, [esi+edi*8]
		cmp	ebp, 2
		jb	loc_1000C399

loc_100028FD:				; CODE XREF: sub_100028A0+DBj
					; sub_100028A0+9B01j
		push	ebx
		push	esi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	ebx, [edi]
		test	ebx, ebx
		jz	short loc_1000297D
		cmp	dword ptr [ebx+8], 0
		jbe	short loc_1000297D
		mov	edx, edi
		mov	ecx, ebx
		call	sub_100035A0
		dec	dword ptr [ebx+8]

loc_1000291D:				; CODE XREF: sub_100028A0+E6j
		mov	ebp, eax
		pop	ebx
		push	esi		; lpCriticalSection
		test	ebp, ebp
		jz	loc_1000C3A6
		add	dword ptr [edi+28h], 1
		adc	dword ptr [edi+2Ch], 0
		add	dword ptr [esi+58h], 1
		mov	edi, [esp+14h+var_4]
		adc	dword ptr [esi+5Ch], 0
		add	[esi+54h], edi
		call	ds:LeaveCriticalSection
		cmp	[esp+10h+arg_0], 0
		jnz	loc_1000C3B3

loc_10002951:				; CODE XREF: sub_100028A0+9B1Fj
		mov	eax, ebp

loc_10002953:				; CODE XREF: sub_100028A0+9B0Ej
		pop	edi
		pop	esi
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_10002958:				; CODE XREF: sub_100028A0+9j
		cmp	edx, 200h
		ja	short loc_10002988
		lea	ebp, [edx+0Fh]
		and	ebp, 0FFFFFFF0h
		mov	eax, ebp
		mov	[esp+10h+var_4], ebp
		shr	eax, 4
		lea	edi, ds:29h[eax*8]
		add	edi, eax

loc_10002978:				; CODE XREF: sub_100028A0+123j
		lea	edi, [esi+edi*8]
		jmp	short loc_100028FD
; ---------------------------------------------------------------------------

loc_1000297D:				; CODE XREF: sub_100028A0+69j
					; sub_100028A0+6Fj
		mov	edx, edi
		mov	ecx, esi
		call	sub_100018E8
		jmp	short loc_1000291D
; ---------------------------------------------------------------------------

loc_10002988:				; CODE XREF: sub_100028A0+BEj
		lea	ecx, [edx-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	ebp, ecx
		shr	ebp, 10h
		or	ebp, ecx
		inc	ebp
		mov	eax, ebp
		mov	[esp+10h+var_4], ebp
		shr	eax, 9
		bsf	eax, eax
		jz	short loc_100029CC
		inc	eax

loc_100029BD:				; CODE XREF: sub_100028A0+12Ej
		lea	edi, [eax+28h]
		lea	edi, [eax+edi*8]
		jmp	short loc_10002978
; ---------------------------------------------------------------------------

loc_100029C5:				; CODE XREF: sub_100028A0+41j
		xor	eax, eax
		jmp	loc_100028E8
; ---------------------------------------------------------------------------

loc_100029CC:				; CODE XREF: sub_100028A0+11Aj
		xor	eax, eax
		jmp	short loc_100029BD
sub_100028A0	endp


; =============== S U B	R O U T	I N E =======================================


sub_100029D0	proc near		; CODE XREF: sub_10002E20+49p
					; moz_xmalloc+274p ...

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= byte ptr -0Ch
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

; FUNCTION CHUNK AT 1000C3C4 SIZE 00000018 BYTES

		sub	esp, 14h
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, ecx
		xor	esi, esi
		mov	ecx, [esp+24h+arg_0]
		lea	ebp, [edi+0A8h]
		mov	eax, [ebp+0]
		lea	ebx, [ebp+4]
		or	ecx, 10h
		mov	[esp+24h+var_14], edi
		mov	[esp+24h+var_10], ecx
		cmp	eax, ebx
		jz	loc_10002AAE
		mov	edi, ecx
		and	edi, 0FFFFF000h
		jmp	short loc_10002A10
; ---------------------------------------------------------------------------
		align 10h

loc_10002A10:				; CODE XREF: sub_100029D0+36j
					; sub_100029D0+63j
		mov	ecx, [eax+8]
		and	ecx, 0FFFFF000h
		cmp	ecx, edi
		sbb	edx, edx
		neg	edx
		cmp	edi, ecx
		sbb	ecx, ecx
		neg	ecx
		sub	edx, ecx
		jz	short loc_10002A7C

loc_10002A29:				; CODE XREF: sub_100029D0+CAj
		test	edx, edx
		jns	short loc_10002A9C
		mov	esi, eax
		mov	eax, [eax]

loc_10002A31:				; CODE XREF: sub_100029D0+D8j
		cmp	eax, ebx
		jnz	short loc_10002A10

loc_10002A35:				; CODE XREF: sub_100029D0+175j
		test	esi, esi
		jz	short loc_10002AAA
		push	[esp+24h+arg_8]
		mov	ecx, esi
		mov	eax, 0AAAAAAABh
		push	[esp+28h+arg_4]
		and	ecx, 0FFF00000h
		sub	esi, ecx
		sub	esi, 10h
		mul	esi
		mov	eax, [esp+2Ch+arg_0]
		mov	esi, edx
		shr	esi, 3
		shl	esi, 0Ch
		add	esi, ecx
		mov	ecx, [esp+2Ch+var_14]
		push	eax
		mov	edx, esi
		call	sub_10003DC0
		mov	eax, esi

loc_10002A71:				; CODE XREF: sub_100029D0+167j
		add	esp, 0Ch

loc_10002A74:				; CODE XREF: sub_100029D0+17Cj
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_10002A7C:				; CODE XREF: sub_100029D0+57j
		test	byte ptr [esp+24h+var_10], 10h
		jz	loc_1000C3C4
		xor	ecx, ecx

loc_10002A89:				; CODE XREF: sub_100029D0+99FCj
		xor	edx, edx

loc_10002A8B:				; CODE XREF: sub_100029D0+9A07j
		cmp	ecx, eax
		jnb	loc_10002B3C
		mov	ecx, 1

loc_10002A98:				; CODE XREF: sub_100029D0+16Ej
		sub	edx, ecx
		jmp	short loc_10002A29
; ---------------------------------------------------------------------------

loc_10002A9C:				; CODE XREF: sub_100029D0+5Bj
		jle	loc_10002B43
		mov	eax, [eax+4]
		and	eax, 0FFFFFFFEh
		jmp	short loc_10002A31
; ---------------------------------------------------------------------------

loc_10002AAA:				; CODE XREF: sub_100029D0+67j
		mov	edi, [esp+24h+var_14]

loc_10002AAE:				; CODE XREF: sub_100029D0+28j
		mov	edx, [edi+0A0h]
		test	edx, edx
		jz	short loc_10002AF5
		lea	esi, [edx+1000h]
		mov	dword ptr [edi+0A0h], 0
		add	edx, 1Ch
		mov	ecx, ebp
		call	sub_10004C50
		push	[esp+24h+arg_8]
		mov	eax, [esp+28h+arg_0]
		mov	edx, esi
		push	[esp+28h+arg_4]
		mov	ecx, edi
		push	eax
		call	sub_10003DC0
		add	esp, 0Ch
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_10002AF5:				; CODE XREF: sub_100029D0+E6j
		mov	edx, 100000h
		push	1		; char
		push	0		; int
		mov	ecx, edx	; dwSize
		call	sub_100059AC
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jz	short loc_10002B4A
		mov	edx, esi
		mov	ecx, edi
		call	sub_10005917
		push	[esp+24h+arg_8]
		mov	eax, [esp+28h+arg_0]
		lea	edx, [esi+1000h]
		push	[esp+28h+arg_4]
		mov	ecx, edi
		push	eax
		call	sub_10003DC0
		lea	eax, [esi+1000h]
		jmp	loc_10002A71
; ---------------------------------------------------------------------------

loc_10002B3C:				; CODE XREF: sub_100029D0+BDj
		xor	ecx, ecx
		jmp	loc_10002A98
; ---------------------------------------------------------------------------

loc_10002B43:				; CODE XREF: sub_100029D0:loc_10002A9Cj
		mov	esi, eax
		jmp	loc_10002A35
; ---------------------------------------------------------------------------

loc_10002B4A:				; CODE XREF: sub_100029D0+13Cj
		xor	eax, eax
		jmp	loc_10002A74
sub_100029D0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 104. calloc

; =============== S U B	R O U T	I N E =======================================


; int __cdecl calloc(size_t, int)
		public calloc
calloc		proc near		; CODE XREF: moz_xcalloc+9p
					; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

; FUNCTION CHUNK AT 1000C3DC SIZE 0000001F BYTES

		mov	ecx, [esp+arg_0]
		push	esi
		push	edi
		mov	edi, [esp+8+arg_4]
		mov	esi, ecx
		imul	esi, edi
		test	esi, esi
		jz	loc_10002DFE
		mov	eax, ecx
		or	eax, edi
		test	eax, 0FFFF0000h
		jnz	loc_10002DC6

loc_10002B86:				; CODE XREF: calloc+26Ej
		cmp	esi, 0FF000h
		ja	loc_10002DEE

loc_10002B92:				; CODE XREF: calloc+2A3j
		push	dwTlsIndex	; dwTlsIndex
		call	ds:TlsGetValue
		mov	edi, eax
		test	edi, edi
		jz	loc_10002DDB

loc_10002BA8:				; CODE XREF: calloc+282j
		cmp	esi, 800h
		ja	loc_10002D9E
		push	ebx
		push	ebp
		cmp	esi, 9
		jb	loc_10002C88
		cmp	esi, 200h
		ja	loc_10002D0D
		add	esi, 0Fh
		and	esi, 0FFFFFFF0h
		mov	eax, esi
		mov	[esp+10h+arg_0], esi
		shr	eax, 4
		lea	ebp, ds:29h[eax*8]
		add	ebp, eax

loc_10002BE3:				; CODE XREF: calloc+1E8j
		lea	ebp, [edi+ebp*8]

loc_10002BE6:				; CODE XREF: calloc+174j calloc+182j
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	ebx, [ebp+0]
		test	ebx, ebx
		jz	loc_10002CE7
		cmp	dword ptr [ebx+8], 0
		jbe	loc_10002CE7
		mov	esi, [ebx+4]
		lea	eax, [esi+3]
		mov	edx, [ebx+eax*4]
		lea	eax, [ebx+eax*4]
		mov	[esp+10h+arg_4], eax
		test	edx, edx
		jz	loc_10002D4D
		bsf	eax, edx
		jz	loc_10002E0F
		lea	ecx, [eax+1]

loc_10002C26:				; CODE XREF: calloc+2B1j
		shl	esi, 5
		dec	ecx
		add	esi, ecx
		mov	eax, 1
		imul	esi, [ebp+14h]
		shl	eax, cl
		mov	ecx, [esp+10h+arg_4]
		add	esi, [ebp+24h]
		add	esi, ebx
		xor	eax, edx
		mov	[ecx], eax

loc_10002C44:				; CODE XREF: calloc+1A8j calloc+239j ...
		dec	dword ptr [ebx+8]
		test	esi, esi
		jz	loc_1000C3DC
		add	dword ptr [ebp+28h], 1
		mov	ebx, [esp+10h+arg_0]
		adc	dword ptr [ebp+2Ch], 0
		add	dword ptr [edi+58h], 1
		push	edi		; lpCriticalSection
		adc	dword ptr [edi+5Ch], 0
		add	[edi+54h], ebx
		call	ds:LeaveCriticalSection
		push	ebx		; size_t
		push	0		; int
		push	esi		; void *
		call	memset
		add	esp, 0Ch

loc_10002C79:				; CODE XREF: calloc+9885j
		pop	ebp
		pop	ebx

loc_10002C7B:				; CODE XREF: calloc+24Ej
		test	esi, esi
		jz	loc_1000C3EA

loc_10002C83:				; CODE XREF: calloc+9896j
		pop	edi
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_10002C88:				; CODE XREF: calloc+59j
		dec	esi
		mov	eax, esi
		shr	eax, 1
		or	esi, eax
		mov	eax, esi
		shr	eax, 2
		or	esi, eax
		mov	eax, esi
		shr	eax, 4
		or	esi, eax
		mov	eax, esi
		shr	eax, 8
		or	esi, eax
		mov	eax, esi
		shr	eax, 10h
		or	eax, esi
		mov	esi, eax
		mov	[esp+10h+arg_0], eax
		inc	esi
		mov	eax, esi
		mov	[esp+10h+arg_0], esi
		shr	eax, 2
		bsf	eax, eax
		jz	loc_10002DE7
		inc	eax

loc_10002CC5:				; CODE XREF: calloc+289j
		lea	ebp, ds:17h[eax*8]
		add	ebp, eax
		lea	ebp, [edi+ebp*8]
		cmp	esi, 2
		jnb	loc_10002BE6
		mov	[esp+10h+arg_0], 2
		jmp	loc_10002BE6
; ---------------------------------------------------------------------------

loc_10002CE7:				; CODE XREF: calloc+92j calloc+9Cj
		mov	edx, ebp
		mov	ecx, edi
		call	sub_10002E20
		mov	ebx, eax
		mov	[ebp+0], ebx
		test	ebx, ebx
		jz	loc_1000C3DC
		mov	edx, ebp
		mov	ecx, ebx
		call	sub_100035A0
		mov	esi, eax
		jmp	loc_10002C44
; ---------------------------------------------------------------------------

loc_10002D0D:				; CODE XREF: calloc+65j
		dec	esi
		mov	eax, esi
		shr	eax, 1
		or	esi, eax
		mov	eax, esi
		shr	eax, 2
		or	esi, eax
		mov	eax, esi
		shr	eax, 4
		or	esi, eax
		mov	eax, esi
		shr	eax, 8
		or	esi, eax
		mov	eax, esi
		shr	eax, 10h
		or	eax, esi
		inc	eax
		mov	[esp+10h+arg_0], eax
		shr	eax, 9
		bsf	eax, eax
		jz	loc_10002E08
		inc	eax

loc_10002D42:				; CODE XREF: calloc+2AAj
		lea	ebp, [eax+28h]
		lea	ebp, [eax+ebp*8]
		jmp	loc_10002BE3
; ---------------------------------------------------------------------------

loc_10002D4D:				; CODE XREF: calloc+B4j
		mov	edx, [ebp+20h]
		inc	esi
		cmp	esi, edx
		jnb	short loc_10002DBF
		lea	ecx, [esi+3]
		lea	ecx, [ebx+ecx*4]
		mov	[esp+10h+arg_4], ecx
		nop

loc_10002D60:				; CODE XREF: calloc+25Dj
		mov	eax, [ecx]
		test	eax, eax
		jz	short loc_10002DB3
		bsf	eax, eax
		jz	loc_10002E16
		lea	ecx, [eax+1]

loc_10002D72:				; CODE XREF: calloc+2B8j
		dec	ecx
		mov	edx, esi
		shl	edx, 5
		mov	eax, 1
		add	edx, ecx
		shl	eax, cl
		imul	edx, [ebp+14h]
		mov	ecx, [esp+10h+arg_4]
		add	edx, [ebp+24h]
		add	edx, ebx
		xor	eax, [ecx]
		mov	[ebx+esi*4+0Ch], eax
		mov	[ebx+4], esi
		mov	esi, edx
		jmp	loc_10002C44
; ---------------------------------------------------------------------------

loc_10002D9E:				; CODE XREF: calloc+4Ej
		push	1		; int
		mov	edx, esi
		mov	ecx, edi	; lpCriticalSection
		call	sub_10003C40

loc_10002DA9:				; CODE XREF: calloc+29Cj
		mov	esi, eax
		add	esp, 4
		jmp	loc_10002C7B
; ---------------------------------------------------------------------------

loc_10002DB3:				; CODE XREF: calloc+204j
		inc	esi
		add	ecx, 4
		mov	[esp+10h+arg_4], ecx
		cmp	esi, edx
		jb	short loc_10002D60

loc_10002DBF:				; CODE XREF: calloc+1F3j
		xor	esi, esi
		jmp	loc_10002C44
; ---------------------------------------------------------------------------

loc_10002DC6:				; CODE XREF: calloc+20j
		xor	edx, edx
		mov	eax, esi
		div	edi
		cmp	eax, ecx
		jz	loc_10002B86
		xor	esi, esi
		jmp	loc_1000C3EA
; ---------------------------------------------------------------------------

loc_10002DDB:				; CODE XREF: calloc+42j
		call	sub_100016CF
		mov	edi, eax
		jmp	loc_10002BA8
; ---------------------------------------------------------------------------

loc_10002DE7:				; CODE XREF: calloc+15Ej
		xor	eax, eax
		jmp	loc_10002CC5
; ---------------------------------------------------------------------------

loc_10002DEE:				; CODE XREF: calloc+2Cj
		push	1
		mov	edx, 100000h
		mov	ecx, esi
		call	sub_10005C6D
		jmp	short loc_10002DA9
; ---------------------------------------------------------------------------

loc_10002DFE:				; CODE XREF: calloc+11j
		mov	esi, 1
		jmp	loc_10002B92
; ---------------------------------------------------------------------------

loc_10002E08:				; CODE XREF: calloc+1DBj
		xor	eax, eax
		jmp	loc_10002D42
; ---------------------------------------------------------------------------

loc_10002E0F:				; CODE XREF: calloc+BDj
		xor	ecx, ecx
		jmp	loc_10002C26
; ---------------------------------------------------------------------------

loc_10002E16:				; CODE XREF: calloc+209j
		xor	ecx, ecx
		jmp	loc_10002D72
calloc		endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


sub_10002E20	proc near		; CODE XREF: sub_100018E8+4p
					; moz_xrealloc+20Cp ...
		push	ebx
		mov	ebx, edx
		mov	edx, ecx
		lea	ecx, [ebx+4]
		push	esi
		mov	esi, [ecx]
		push	edi
		lea	edi, [ecx+4]
		mov	eax, [esi]
		cmp	eax, edi
		jz	short loc_10002E3D

loc_10002E35:				; CODE XREF: sub_10002E20+1Bj
		mov	esi, eax
		mov	eax, [esi]
		cmp	eax, edi
		jnz	short loc_10002E35

loc_10002E3D:				; CODE XREF: sub_10002E20+13j
		cmp	esi, edi
		jz	short loc_10002E60
		test	esi, esi
		jz	short loc_10002E60
		mov	edx, esi
		call	sub_10003640
		mov	eax, [esi+8]
		and	eax, 0FFFFF000h
		add	dword ptr [ebx+38h], 1
		adc	dword ptr [ebx+3Ch], 0

loc_10002E5C:				; CODE XREF: sub_10002E20+59j
					; sub_10002E20+BFj ...
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_10002E60:				; CODE XREF: sub_10002E20+1Fj
					; sub_10002E20+23j
		push	0
		push	0
		push	dword ptr [ebx+18h]
		mov	ecx, edx
		call	sub_100029D0
		add	esp, 0Ch
		mov	esi, eax
		test	esi, esi
		jz	short loc_10002EE4
		cmp	esi, [ebx]
		jz	short loc_10002E5C
		mov	[esi], ebx
		xor	edx, edx
		mov	eax, [ebx+20h]
		dec	eax
		jz	short loc_10002EA2
		lea	ecx, [esi+0Ch]
		jmp	short loc_10002E90
; ---------------------------------------------------------------------------
		align 10h

loc_10002E90:				; CODE XREF: sub_10002E20+68j
					; sub_10002E20+80j
		mov	dword ptr [ecx], 0FFFFFFFFh
		lea	ecx, [ecx+4]
		mov	eax, [ebx+20h]
		inc	edx
		dec	eax
		cmp	edx, eax
		jb	short loc_10002E90

loc_10002EA2:				; CODE XREF: sub_10002E20+63j
		mov	eax, [ebx+1Ch]
		and	eax, 1Fh
		jz	short loc_10002EEB
		mov	ecx, 20h
		sub	ecx, eax
		or	eax, 0FFFFFFFFh
		shr	eax, cl
		mov	[esi+edx*4+0Ch], eax

loc_10002EBA:				; CODE XREF: sub_10002E20+D3j
		mov	dword ptr [esi+4], 0
		mov	eax, [ebx+1Ch]
		mov	[esi+8], eax
		add	dword ptr [ebx+30h], 1
		adc	dword ptr [ebx+34h], 0
		inc	dword ptr [ebx+44h]
		mov	eax, [ebx+44h]
		cmp	eax, [ebx+40h]
		jbe	short loc_10002EDD
		mov	[ebx+40h], eax

loc_10002EDD:				; CODE XREF: sub_10002E20+B8j
		mov	eax, esi
		jmp	loc_10002E5C
; ---------------------------------------------------------------------------

loc_10002EE4:				; CODE XREF: sub_10002E20+55j
		xor	eax, eax
		jmp	loc_10002E5C
; ---------------------------------------------------------------------------

loc_10002EEB:				; CODE XREF: sub_10002E20+88j
		mov	dword ptr [esi+edx*4+0Ch], 0FFFFFFFFh
		jmp	short loc_10002EBA
sub_10002E20	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 120. moz_xmalloc

; =============== S U B	R O U T	I N E =======================================


		public moz_xmalloc
moz_xmalloc	proc near		; CODE XREF: DllBlocklist_Initialize(void)+4Dp
					; DllBlocklist_Initialize(void)+AC55p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000C3FB SIZE 0000004D BYTES

		mov	eax, [esp+arg_0]
		sub	esp, 8
		push	ebp
		push	edi
		mov	edi, eax
		test	eax, eax
		jz	loc_10003210
		cmp	eax, 0FF000h
		ja	loc_1000C40F

loc_10002F1E:				; CODE XREF: moz_xmalloc+315j
		push	esi
		push	dwTlsIndex	; dwTlsIndex
		call	ds:TlsGetValue
		mov	esi, eax
		test	esi, esi
		jz	loc_1000321A

loc_10002F35:				; CODE XREF: moz_xmalloc+321j
		cmp	edi, 800h
		ja	loc_100030BC
		cmp	edi, 9
		jb	loc_10003061
		cmp	edi, 200h
		ja	loc_100030D1
		lea	ebp, [edi+0Fh]
		and	ebp, 0FFFFFFF0h
		mov	eax, ebp
		mov	[esp+14h+var_8], ebp
		shr	eax, 4
		lea	edi, ds:29h[eax*8]
		add	edi, eax

loc_10002F6E:				; CODE XREF: moz_xmalloc+210j
		lea	edi, [esi+edi*8]

loc_10002F71:				; CODE XREF: moz_xmalloc+1A9j
					; moz_xmalloc+1B7j
		push	ebx
		push	esi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	ebx, [edi]
		test	ebx, ebx
		jz	short loc_10002FCB
		cmp	dword ptr [ebx+8], 0
		jbe	short loc_10002FCB
		mov	edx, edi
		mov	ecx, ebx
		call	sub_100035A0
		mov	ebp, eax

loc_10002F90:				; CODE XREF: moz_xmalloc+15Cj
					; moz_xmalloc+266j ...
		dec	dword ptr [ebx+8]
		test	ebp, ebp
		jz	loc_1000C401
		add	dword ptr [edi+28h], 1
		mov	eax, [esp+18h+var_8]
		adc	dword ptr [edi+2Ch], 0
		add	dword ptr [esi+58h], 1
		push	esi		; lpCriticalSection
		adc	dword ptr [esi+5Ch], 0
		add	[esi+54h], eax
		call	ds:LeaveCriticalSection

loc_10002FB9:				; CODE XREF: moz_xmalloc+950Aj
		pop	ebx

loc_10002FBA:				; CODE XREF: moz_xmalloc+1CCj
		pop	esi

loc_10002FBB:				; CODE XREF: moz_xmalloc+9522j
		test	ebp, ebp
		jz	loc_1000C427

loc_10002FC3:				; CODE XREF: moz_xmalloc+9538j
		pop	edi
		mov	eax, ebp
		pop	ebp
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_10002FCB:				; CODE XREF: moz_xmalloc+7Dj
					; moz_xmalloc+83j
		mov	ebx, [edi+4]
		lea	ecx, [edi+4]
		lea	edx, [ecx+4]
		mov	eax, [ebx]
		cmp	eax, edx
		jz	short loc_10002FE8
		lea	ebx, [ebx+0]

loc_10002FE0:				; CODE XREF: moz_xmalloc+E6j
		mov	ebx, eax
		mov	eax, [ebx]
		cmp	eax, edx
		jnz	short loc_10002FE0

loc_10002FE8:				; CODE XREF: moz_xmalloc+D8j
		cmp	ebx, edx
		jz	loc_1000316B
		test	ebx, ebx
		jz	loc_1000316B
		mov	edx, ebx
		call	sub_10003640
		mov	ebx, [ebx+8]
		and	ebx, 0FFFFF000h
		add	dword ptr [edi+38h], 1
		adc	dword ptr [edi+3Ch], 0

loc_10003010:				; CODE XREF: moz_xmalloc+288j
					; moz_xmalloc+2E8j ...
		mov	[edi], ebx
		test	ebx, ebx
		jz	loc_1000C401
		mov	ebp, [ebx+4]
		lea	eax, [ebp+3]
		mov	edx, [ebx+eax*4]
		lea	eax, [ebx+eax*4]
		mov	[esp+18h+var_4], eax
		test	edx, edx
		jz	loc_10003115
		bsf	eax, edx
		jz	loc_10003237
		lea	ecx, [eax+1]

loc_1000303E:				; CODE XREF: moz_xmalloc+339j
		shl	ebp, 5
		dec	ecx
		add	ebp, ecx
		mov	eax, 1
		imul	ebp, [edi+14h]
		shl	eax, cl
		mov	ecx, [esp+18h+var_4]
		add	ebp, [edi+24h]
		add	ebp, ebx
		xor	eax, edx
		mov	[ecx], eax
		jmp	loc_10002F90
; ---------------------------------------------------------------------------

loc_10003061:				; CODE XREF: moz_xmalloc+44j
		lea	ecx, [edi-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	ebp, ecx
		shr	ebp, 10h
		or	ebp, ecx
		inc	ebp
		mov	eax, ebp
		mov	[esp+14h+var_8], ebp
		shr	eax, 2
		bsf	eax, eax
		jz	loc_10003209
		inc	eax

loc_1000309A:				; CODE XREF: moz_xmalloc+30Bj
		lea	edi, ds:17h[eax*8]
		add	edi, eax
		lea	edi, [esi+edi*8]
		cmp	ebp, 2
		jnb	loc_10002F71
		mov	[esp+14h+var_8], 2
		jmp	loc_10002F71
; ---------------------------------------------------------------------------

loc_100030BC:				; CODE XREF: moz_xmalloc+3Bj
		push	0		; int
		mov	edx, edi
		mov	ecx, esi	; lpCriticalSection
		call	sub_10003C40
		add	esp, 4
		mov	ebp, eax
		jmp	loc_10002FBA
; ---------------------------------------------------------------------------

loc_100030D1:				; CODE XREF: moz_xmalloc+50j
		lea	ecx, [edi-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	ebp, ecx
		shr	ebp, 10h
		or	ebp, ecx
		inc	ebp
		mov	eax, ebp
		mov	[esp+14h+var_8], ebp
		shr	eax, 9
		bsf	eax, eax
		jz	loc_10003230
		inc	eax

loc_1000310A:				; CODE XREF: moz_xmalloc+332j
		lea	edi, [eax+28h]
		lea	edi, [eax+edi*8]
		jmp	loc_10002F6E
; ---------------------------------------------------------------------------

loc_10003115:				; CODE XREF: moz_xmalloc+12Cj
		mov	edx, [edi+20h]
		inc	ebp
		cmp	ebp, edx
		jnb	loc_10003202
		lea	eax, [ebp+3]
		lea	eax, [ebx+eax*4]

loc_10003127:				; CODE XREF: moz_xmalloc+2FCj
		mov	ecx, [eax]
		mov	[esp+18h+var_4], ecx
		test	ecx, ecx
		jz	loc_100031F6
		bsf	eax, ecx
		jz	loc_1000323E
		lea	ecx, [eax+1]

loc_10003141:				; CODE XREF: moz_xmalloc+340j
		mov	edx, ebp
		dec	ecx
		shl	edx, 5
		mov	eax, 1
		add	edx, ecx
		shl	eax, cl
		imul	edx, [edi+14h]
		add	edx, [edi+24h]
		add	edx, ebx
		xor	eax, [esp+18h+var_4]
		mov	[ebx+ebp*4+0Ch], eax
		mov	[ebx+4], ebp
		mov	ebp, edx
		jmp	loc_10002F90
; ---------------------------------------------------------------------------

loc_1000316B:				; CODE XREF: moz_xmalloc+EAj
					; moz_xmalloc+F2j
		push	0
		push	0
		push	dword ptr [edi+18h]
		mov	ecx, esi
		call	sub_100029D0
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jz	loc_1000C3FB
		cmp	ebx, [edi]
		jz	loc_10003010
		mov	[ebx], edi
		xor	edx, edx
		mov	eax, [edi+20h]
		dec	eax
		jz	short loc_100031B2
		lea	ecx, [ebx+0Ch]
		jmp	short loc_100031A0
; ---------------------------------------------------------------------------
		align 10h

loc_100031A0:				; CODE XREF: moz_xmalloc+29Bj
					; moz_xmalloc+2B0j
		mov	dword ptr [ecx], 0FFFFFFFFh
		lea	ecx, [ecx+4]
		mov	eax, [edi+20h]
		inc	edx
		dec	eax
		cmp	edx, eax
		jb	short loc_100031A0

loc_100031B2:				; CODE XREF: moz_xmalloc+296j
		mov	eax, [edi+1Ch]
		and	eax, 1Fh
		jz	short loc_10003226
		mov	ecx, 20h
		sub	ecx, eax
		or	eax, 0FFFFFFFFh
		shr	eax, cl
		mov	[ebx+edx*4+0Ch], eax

loc_100031CA:				; CODE XREF: moz_xmalloc+32Ej
		mov	dword ptr [ebx+4], 0
		mov	eax, [edi+1Ch]
		mov	[ebx+8], eax
		add	dword ptr [edi+30h], 1
		adc	dword ptr [edi+34h], 0
		inc	dword ptr [edi+44h]
		mov	eax, [edi+44h]
		cmp	eax, [edi+40h]
		jbe	loc_10003010
		mov	[edi+40h], eax
		jmp	loc_10003010
; ---------------------------------------------------------------------------

loc_100031F6:				; CODE XREF: moz_xmalloc+22Fj
		inc	ebp
		add	eax, 4
		cmp	ebp, edx
		jb	loc_10003127

loc_10003202:				; CODE XREF: moz_xmalloc+21Bj
		xor	ebp, ebp
		jmp	loc_10002F90
; ---------------------------------------------------------------------------

loc_10003209:				; CODE XREF: moz_xmalloc+193j
		xor	eax, eax
		jmp	loc_1000309A
; ---------------------------------------------------------------------------

loc_10003210:				; CODE XREF: moz_xmalloc+Dj
		mov	edi, 1
		jmp	loc_10002F1E
; ---------------------------------------------------------------------------

loc_1000321A:				; CODE XREF: moz_xmalloc+2Fj
		call	sub_100016CF
		mov	esi, eax
		jmp	loc_10002F35
; ---------------------------------------------------------------------------

loc_10003226:				; CODE XREF: moz_xmalloc+2B8j
		mov	dword ptr [ebx+edx*4+0Ch], 0FFFFFFFFh
		jmp	short loc_100031CA
; ---------------------------------------------------------------------------

loc_10003230:				; CODE XREF: moz_xmalloc+203j
		xor	eax, eax
		jmp	loc_1000310A
; ---------------------------------------------------------------------------

loc_10003237:				; CODE XREF: moz_xmalloc+135j
		xor	ecx, ecx
		jmp	loc_1000303E
; ---------------------------------------------------------------------------

loc_1000323E:				; CODE XREF: moz_xmalloc+238j
		xor	ecx, ecx
		jmp	loc_10003141
moz_xmalloc	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 113. malloc

; =============== S U B	R O U T	I N E =======================================


		public malloc
malloc		proc near		; CODE XREF: wcsdup+20p strndup+Ap
					; DATA XREF: ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000C448 SIZE 00000032 BYTES

		push	ecx
		push	ebp
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		test	edi, edi
		jz	loc_10003545
		cmp	edi, 0FF000h
		ja	loc_1000356E

loc_1000326B:				; CODE XREF: malloc+2FAj
		push	esi
		push	dwTlsIndex	; dwTlsIndex
		call	ds:TlsGetValue
		mov	esi, eax
		test	esi, esi
		jz	loc_10003562

loc_10003282:				; CODE XREF: malloc+319j
		cmp	edi, 800h
		ja	loc_1000344C
		cmp	edi, 9
		jb	loc_100033F1
		cmp	edi, 200h
		ja	short loc_1000331A
		lea	ebp, [edi+0Fh]
		and	ebp, 0FFFFFFF0h
		mov	eax, ebp
		mov	[esp+10h+arg_0], ebp
		shr	eax, 4
		lea	edi, ds:29h[eax*8]
		add	edi, eax

loc_100032B7:				; CODE XREF: malloc+109j
		lea	edi, [esi+edi*8]

loc_100032BA:				; CODE XREF: malloc+1E9j malloc+1F7j
		push	ebx
		push	esi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	ebx, [edi]
		test	ebx, ebx
		jz	loc_1000335E
		cmp	dword ptr [ebx+8], 0
		jbe	loc_1000335E
		mov	edx, edi
		mov	ecx, ebx
		call	sub_100035A0
		mov	ebp, eax

loc_100032E1:				; CODE XREF: malloc+19Cj malloc+2E9j ...
		dec	dword ptr [ebx+8]
		test	ebp, ebp
		jz	loc_1000C44E
		add	dword ptr [edi+28h], 1
		mov	eax, [esp+14h+arg_0]
		adc	dword ptr [edi+2Ch], 0
		add	dword ptr [esi+58h], 1
		push	esi		; lpCriticalSection
		adc	dword ptr [esi+5Ch], 0
		add	[esi+54h], eax
		call	ds:LeaveCriticalSection

loc_1000330A:				; CODE XREF: malloc+9207j
		pop	ebx

loc_1000330B:				; CODE XREF: malloc+20Cj
		pop	esi

loc_1000330C:				; CODE XREF: malloc+331j
		test	ebp, ebp
		jz	loc_1000C469

loc_10003314:				; CODE XREF: malloc+9225j
		pop	edi
		mov	eax, ebp
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1000331A:				; CODE XREF: malloc+4Dj
		lea	ecx, [edi-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	ebp, ecx
		shr	ebp, 10h
		or	ebp, ecx
		inc	ebp
		mov	eax, ebp
		mov	[esp+10h+arg_0], ebp
		shr	eax, 9
		bsf	eax, eax
		jz	loc_10003586
		inc	eax

loc_10003353:				; CODE XREF: malloc+338j
		lea	edi, [eax+28h]
		lea	edi, [eax+edi*8]
		jmp	loc_100032B7
; ---------------------------------------------------------------------------

loc_1000335E:				; CODE XREF: malloc+76j malloc+80j
		mov	ebx, [edi+4]
		lea	ecx, [edi+4]
		lea	edx, [ecx+4]
		mov	eax, [ebx]
		cmp	eax, edx
		jz	short loc_10003378
		lea	ecx, [ecx+0]

loc_10003370:				; CODE XREF: malloc+126j
		mov	ebx, eax
		mov	eax, [ebx]
		cmp	eax, edx
		jnz	short loc_10003370

loc_10003378:				; CODE XREF: malloc+11Bj
		cmp	ebx, edx
		jz	loc_10003461
		test	ebx, ebx
		jz	loc_10003461
		mov	edx, ebx
		call	sub_10003640
		mov	ebx, [ebx+8]
		and	ebx, 0FFFFF000h
		add	dword ptr [edi+38h], 1
		adc	dword ptr [edi+3Ch], 0

loc_100033A0:				; CODE XREF: malloc+22Ej malloc+28Dj ...
		mov	[edi], ebx
		test	ebx, ebx
		jz	loc_1000C44E
		mov	ebp, [ebx+4]
		lea	eax, [ebp+3]
		mov	edx, [ebx+eax*4]
		lea	eax, [ebx+eax*4]
		mov	[esp+14h+var_4], eax
		test	edx, edx
		jz	loc_100034EB
		bsf	eax, edx
		jz	loc_1000358D
		lea	ecx, [eax+1]

loc_100033CE:				; CODE XREF: malloc+33Fj
		shl	ebp, 5
		dec	ecx
		add	ebp, ecx
		mov	eax, 1
		imul	ebp, [edi+14h]
		shl	eax, cl
		mov	ecx, [esp+14h+var_4]
		add	ebp, [edi+24h]
		add	ebp, ebx
		xor	eax, edx
		mov	[ecx], eax
		jmp	loc_100032E1
; ---------------------------------------------------------------------------

loc_100033F1:				; CODE XREF: malloc+41j
		lea	ecx, [edi-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	ebp, ecx
		shr	ebp, 10h
		or	ebp, ecx
		inc	ebp
		mov	eax, ebp
		mov	[esp+10h+arg_0], ebp
		shr	eax, 2
		bsf	eax, eax
		jz	loc_1000353E
		inc	eax

loc_1000342A:				; CODE XREF: malloc+2F0j
		lea	edi, ds:17h[eax*8]
		add	edi, eax
		lea	edi, [esi+edi*8]
		cmp	ebp, 2
		jnb	loc_100032BA
		mov	[esp+10h+arg_0], 2
		jmp	loc_100032BA
; ---------------------------------------------------------------------------

loc_1000344C:				; CODE XREF: malloc+38j
		push	0		; int
		mov	edx, edi
		mov	ecx, esi	; lpCriticalSection
		call	sub_10003C40
		add	esp, 4
		mov	ebp, eax
		jmp	loc_1000330B
; ---------------------------------------------------------------------------

loc_10003461:				; CODE XREF: malloc+12Aj malloc+132j
		push	0
		push	0
		push	dword ptr [edi+18h]
		mov	ecx, esi
		call	sub_100029D0
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jz	loc_1000C448
		cmp	ebx, [edi]
		jz	loc_100033A0
		mov	[ebx], edi
		xor	edx, edx
		mov	eax, [edi+20h]
		dec	eax
		jz	short loc_100034A3
		lea	ecx, [ebx+0Ch]

loc_10003491:				; CODE XREF: malloc+251j
		mov	dword ptr [ecx], 0FFFFFFFFh
		lea	ecx, [ecx+4]
		mov	eax, [edi+20h]
		inc	edx
		dec	eax
		cmp	edx, eax
		jb	short loc_10003491

loc_100034A3:				; CODE XREF: malloc+23Cj
		mov	eax, [edi+1Ch]
		and	eax, 1Fh
		jz	loc_1000C45C
		mov	ecx, 20h
		sub	ecx, eax
		or	eax, 0FFFFFFFFh
		shr	eax, cl
		mov	[ebx+edx*4+0Ch], eax

loc_100034BF:				; CODE XREF: malloc+9214j
		mov	dword ptr [ebx+4], 0
		mov	eax, [edi+1Ch]
		mov	[ebx+8], eax
		add	dword ptr [edi+30h], 1
		adc	dword ptr [edi+34h], 0
		inc	dword ptr [edi+44h]
		mov	eax, [edi+44h]
		cmp	eax, [edi+40h]
		jbe	loc_100033A0
		mov	[edi+40h], eax
		jmp	loc_100033A0
; ---------------------------------------------------------------------------

loc_100034EB:				; CODE XREF: malloc+16Cj
		mov	edx, [edi+20h]
		inc	ebp
		cmp	ebp, edx
		jnb	short loc_1000355B
		lea	ecx, [ebp+3]
		lea	ecx, [ebx+ecx*4]
		mov	[esp+14h+var_4], ecx
		lea	ecx, [ecx+0]

loc_10003500:				; CODE XREF: malloc+309j
		mov	eax, [ecx]
		test	eax, eax
		jz	short loc_1000354F
		bsf	eax, eax
		jz	loc_10003594
		lea	ecx, [eax+1]

loc_10003512:				; CODE XREF: malloc+346j
		dec	ecx
		mov	edx, ebp
		shl	edx, 5
		mov	eax, 1
		add	edx, ecx
		shl	eax, cl
		imul	edx, [edi+14h]
		mov	ecx, [esp+14h+var_4]
		add	edx, [edi+24h]
		add	edx, ebx
		xor	eax, [ecx]
		mov	[ebx+ebp*4+0Ch], eax
		mov	[ebx+4], ebp
		mov	ebp, edx
		jmp	loc_100032E1
; ---------------------------------------------------------------------------

loc_1000353E:				; CODE XREF: malloc+1D3j
		xor	eax, eax
		jmp	loc_1000342A
; ---------------------------------------------------------------------------

loc_10003545:				; CODE XREF: malloc+9j
		mov	edi, 1
		jmp	loc_1000326B
; ---------------------------------------------------------------------------

loc_1000354F:				; CODE XREF: malloc+2B4j
		inc	ebp
		add	ecx, 4
		mov	[esp+14h+var_4], ecx
		cmp	ebp, edx
		jb	short loc_10003500

loc_1000355B:				; CODE XREF: malloc+2A1j
		xor	ebp, ebp
		jmp	loc_100032E1
; ---------------------------------------------------------------------------

loc_10003562:				; CODE XREF: malloc+2Cj
		call	sub_100016CF
		mov	esi, eax
		jmp	loc_10003282
; ---------------------------------------------------------------------------

loc_1000356E:				; CODE XREF: malloc+15j
		push	0
		mov	edx, 100000h
		mov	ecx, edi
		call	sub_10005C6D
		add	esp, 4
		mov	ebp, eax
		jmp	loc_1000330C
; ---------------------------------------------------------------------------

loc_10003586:				; CODE XREF: malloc+FCj
		xor	eax, eax
		jmp	loc_10003353
; ---------------------------------------------------------------------------

loc_1000358D:				; CODE XREF: malloc+175j
		xor	ecx, ecx
		jmp	loc_100033CE
; ---------------------------------------------------------------------------

loc_10003594:				; CODE XREF: malloc+2B9j
		xor	ecx, ecx
		jmp	loc_10003512
malloc		endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


sub_100035A0	proc near		; CODE XREF: sub_100018E8+15p
					; moz_xrealloc+227p ...
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, ecx
		mov	ebp, edx
		mov	eax, [edi+4]
		mov	esi, [edi+eax*4+0Ch]
		lea	ebx, [edi+eax*4]
		test	esi, esi
		jz	short loc_100035DE
		bsf	edx, esi
		jz	short loc_10003630
		lea	ecx, [edx+1]

loc_100035BE:				; CODE XREF: sub_100035A0+92j
		shl	eax, 5
		dec	ecx
		add	eax, ecx
		mov	edx, 1
		imul	eax, [ebp+14h]
		shl	edx, cl
		add	eax, [ebp+24h]
		add	eax, edi
		xor	edx, esi
		mov	[ebx+0Ch], edx

loc_100035D9:				; CODE XREF: sub_100035A0+8Ej
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_100035DE:				; CODE XREF: sub_100035A0+14j
		mov	edx, [ebp+20h]
		inc	eax
		cmp	eax, edx
		jnb	short loc_1000362C
		lea	ecx, [edi+0Ch]
		lea	ecx, [ecx+eax*4]
		lea	esp, [esp+0]

loc_100035F0:				; CODE XREF: sub_100035A0+8Aj
		mov	ebx, [ecx]
		test	ebx, ebx
		jz	short loc_10003624
		bsf	ecx, ebx
		jz	short loc_10003634
		inc	ecx

loc_100035FC:				; CODE XREF: sub_100035A0+96j
		mov	esi, eax
		dec	ecx
		shl	esi, 5
		mov	edx, 1
		add	esi, ecx
		shl	edx, cl
		imul	esi, [ebp+14h]
		xor	edx, ebx
		add	esi, [ebp+24h]
		mov	[edi+eax*4+0Ch], edx
		add	esi, edi
		mov	[edi+4], eax
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_10003624:				; CODE XREF: sub_100035A0+54j
		inc	eax
		add	ecx, 4
		cmp	eax, edx
		jb	short loc_100035F0

loc_1000362C:				; CODE XREF: sub_100035A0+44j
		xor	eax, eax
		jmp	short loc_100035D9
; ---------------------------------------------------------------------------

loc_10003630:				; CODE XREF: sub_100035A0+19j
		xor	ecx, ecx
		jmp	short loc_100035BE
; ---------------------------------------------------------------------------

loc_10003634:				; CODE XREF: sub_100035A0+59j
		xor	ecx, ecx
		jmp	short loc_100035FC
sub_100035A0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame fpd=0Ch

sub_10003640	proc near		; CODE XREF: realloc+632p
					; sub_10002410+1A6p ...

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8

; FUNCTION CHUNK AT 1000C47A SIZE 00000035 BYTES

		sub	esp, 1Ch
		push	ebx
		mov	eax, ecx
		push	ebp
		push	esi
		push	edi
		mov	ebx, [eax]
		lea	edi, [eax+4]
		mov	[esp+2Ch+var_1C], eax
		lea	ebp, [esp+20h]
		mov	eax, edi
		mov	[esp+2Ch+var_C], ebx
		and	eax, 0FFFFFFFEh
		mov	[esp+2Ch+var_18], edi
		mov	[esp+2Ch+var_8], eax
		mov	esi, edx
		mov	eax, ebx
		cmp	esi, eax
		ja	loc_100039C0
		xor	ecx, ecx

loc_10003675:				; CODE XREF: sub_10003640+385j
		cmp	esi, eax
		jnb	loc_100037A6
		mov	edx, 1

loc_10003682:				; CODE XREF: sub_10003640+168j
		sub	ecx, edx
		mov	[esp+2Ch+var_14], ecx
		jns	loc_100037AD
		mov	edx, [eax]
		test	byte ptr [edx+4], 1
		jz	loc_10003755

loc_1000369A:				; CODE XREF: sub_10003640+121j
		mov	ebp, eax
		mov	eax, edx

loc_1000369E:				; CODE XREF: sub_10003640+161j
					; sub_10003640+2E5j ...
		test	ecx, ecx
		jz	loc_10003C32

loc_100036A6:				; CODE XREF: sub_10003640+8Ej
					; sub_10003640+D3j ...
		cmp	esi, eax
		ja	loc_100038CB
		xor	edx, edx

loc_100036B0:				; CODE XREF: sub_10003640+290j
		cmp	esi, eax
		sbb	ecx, ecx
		neg	ecx
		sub	edx, ecx
		jns	short loc_10003715
		mov	edx, [eax]
		cmp	edx, edi
		jz	loc_10003AA9
		test	byte ptr [edx+4], 1
		jz	short loc_100036D0

loc_100036CA:				; CODE XREF: sub_10003640+96j
					; sub_10003640+215j ...
		mov	ebp, eax
		mov	eax, edx
		jmp	short loc_100036A6
; ---------------------------------------------------------------------------

loc_100036D0:				; CODE XREF: sub_10003640+88j
		mov	ecx, [edx]
		test	byte ptr [ecx+4], 1
		jnz	short loc_100036CA
		or	dword ptr [edx+4], 1
		mov	ecx, [eax+4]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		mov	ebx, [edx]
		test	byte ptr [ebx+4], 1
		jnz	loc_100037DD
		or	ecx, 1
		mov	[eax+4], ecx

loc_100036F6:				; CODE XREF: sub_10003640+3E7j
		mov	ebx, ecx
		and	ecx, 1
		and	ebx, 0FFFFFFFEh
		or	ecx, [ebx]
		mov	[eax+4], ecx
		mov	[ebx], eax

loc_10003705:				; CODE XREF: sub_10003640+1DBj
					; sub_10003640+1FEj ...
		cmp	[ebp+0Ch+var_C], eax
		jnz	loc_10003A2C
		mov	[ebp+0Ch+var_C], ebx

loc_10003711:				; CODE XREF: sub_10003640+3F7j
		mov	eax, ebx
		jmp	short loc_100036A6
; ---------------------------------------------------------------------------

loc_10003715:				; CODE XREF: sub_10003640+78j
		test	edx, edx
		jnz	loc_10003847
		mov	ecx, [eax+4]
		and	ecx, 0FFFFFFFEh
		cmp	ecx, edi
		jnz	loc_10003843
		mov	esi, [eax]
		cmp	esi, edi
		jnz	loc_1000392A
		mov	esi, edi

loc_10003737:				; CODE XREF: sub_10003640+319j
		mov	ecx, [esp+2Ch+var_1C]
		cmp	[ebp+0Ch+var_C], eax
		jnz	loc_100039FB
		mov	[ebp+0Ch+var_C], esi
		mov	eax, [esp+2Ch+var_C]
		mov	[ecx], eax

loc_1000374D:				; CODE XREF: sub_10003640+5F8j
					; sub_10003640+8E6Aj
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_10003755:				; CODE XREF: sub_10003640+54j
		mov	ecx, [edx]
		test	byte ptr [ecx+4], 1
		jz	short loc_10003766
		mov	ecx, [esp+2Ch+var_14]
		jmp	loc_1000369A
; ---------------------------------------------------------------------------

loc_10003766:				; CODE XREF: sub_10003640+11Bj
		or	dword ptr [edx+4], 1
		mov	ecx, [eax+4]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		mov	ebx, [edx]
		test	byte ptr [ebx+4], 1
		jnz	loc_100038D5
		or	ecx, 1
		mov	ebx, ecx
		mov	[eax+4], ecx
		and	ebx, 0FFFFFFFEh
		and	ecx, 1
		mov	[esp+2Ch+var_C], ebx
		or	ecx, [ebx]
		mov	[eax+4], ecx
		mov	ecx, [esp+2Ch+var_14]
		mov	[ebx], eax
		mov	eax, ebx
		and	dword ptr [ebx+4], 0FFFFFFFEh
		jmp	loc_1000369E
; ---------------------------------------------------------------------------

loc_100037A6:				; CODE XREF: sub_10003640+37j
		xor	edx, edx
		jmp	loc_10003682
; ---------------------------------------------------------------------------

loc_100037AD:				; CODE XREF: sub_10003640+48j
		test	ecx, ecx
		jnz	loc_1000395E
		mov	ecx, [eax+4]
		and	ecx, 0FFFFFFFEh
		cmp	ecx, edi
		jnz	loc_10003BE5
		mov	esi, [eax]
		cmp	esi, edi
		jnz	loc_10003B65
		mov	ecx, [esp+2Ch+var_1C]
		mov	esi, edi
		pop	edi
		mov	[ecx], esi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_100037DD:				; CODE XREF: sub_10003640+AAj
		mov	ecx, [ebx+4]
		and	ecx, 0FFFFFFFEh
		mov	[edx], ecx
		mov	ecx, [ebx+4]
		and	ecx, 1
		or	ecx, edx
		mov	[ebx+4], ecx
		mov	ecx, [eax+4]
		and	ecx, 1
		or	ecx, ebx
		mov	ebx, ecx
		mov	[eax+4], ecx
		and	ebx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [ebx]
		mov	[eax+4], ecx
		mov	[ebx], eax
		mov	ecx, [eax+4]
		and	ecx, 0FFFFFFFEh
		mov	edx, [ecx+4]
		test	dl, 1
		jnz	short loc_10003820
		mov	[eax+4], ecx
		jmp	loc_10003705
; ---------------------------------------------------------------------------

loc_10003820:				; CODE XREF: sub_10003640+1D6j
		and	edx, 0FFFFFFFEh
		mov	[ecx+4], edx
		or	dword ptr [eax+4], 1
		mov	ecx, [eax+4]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx]
		mov	[eax+4], ecx
		mov	[edx], eax
		mov	[ebx], edx
		jmp	loc_10003705
; ---------------------------------------------------------------------------

loc_10003843:				; CODE XREF: sub_10003640+E5j
		mov	[esp+2Ch+var_18], ebp

loc_10003847:				; CODE XREF: sub_10003640+D7j
		mov	ebx, [eax+4]
		mov	edx, ebx
		and	edx, 0FFFFFFFEh
		mov	ecx, [edx]
		test	byte ptr [ecx+4], 1
		jnz	loc_100036CA
		mov	ecx, [eax]
		mov	[esp+2Ch+var_14], ecx
		mov	edx, [ecx+4]
		test	dl, 1
		jz	loc_10003A14
		and	edx, 0FFFFFFFEh
		mov	ecx, [edx]
		mov	[esp+2Ch+var_10], ecx
		test	byte ptr [ecx+4], 1
		mov	ecx, [esp+2Ch+var_14]
		jnz	loc_10003A3C
		and	ebx, 1
		or	ebx, edx
		mov	[ecx+4], ebx
		or	dword ptr [edx+4], 1
		mov	ebx, [eax]

loc_10003892:				; CODE XREF: sub_10003640+427j
		mov	ecx, [ebx+4]
		and	ecx, 0FFFFFFFEh
		mov	[eax], ecx
		mov	ecx, [ebx+4]
		and	ecx, 1
		or	ecx, eax
		mov	[ebx+4], ecx
		mov	ecx, [eax+4]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx]
		mov	[eax+4], ecx
		mov	[edx], eax
		mov	ecx, [ebx+4]
		and	ecx, 1
		or	ecx, edx
		mov	[ebx+4], ecx
		or	dword ptr [eax+4], 1
		jmp	loc_10003705
; ---------------------------------------------------------------------------

loc_100038CB:				; CODE XREF: sub_10003640+68j
		mov	edx, 1
		jmp	loc_100036B0
; ---------------------------------------------------------------------------

loc_100038D5:				; CODE XREF: sub_10003640+138j
		mov	ecx, [ebx+4]
		and	ecx, 0FFFFFFFEh
		mov	[edx], ecx
		mov	ecx, [ebx+4]
		and	ecx, 1
		or	ecx, edx
		mov	[ebx+4], ecx
		mov	ecx, [eax+4]
		and	ecx, 1
		or	ecx, ebx
		mov	ebx, ecx
		mov	[eax+4], ecx
		and	ebx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [ebx]
		mov	[eax+4], ecx
		mov	[ebx], eax
		mov	ecx, [eax+4]
		and	ecx, 0FFFFFFFEh
		mov	edx, [ecx+4]
		test	dl, 1
		jnz	loc_100039CA
		mov	[eax+4], ecx
		mov	eax, ebx
		and	dword ptr [ebx+4], 0FFFFFFFEh
		mov	ecx, [esp+2Ch+var_14]
		mov	[esp+2Ch+var_C], ebx
		jmp	loc_1000369E
; ---------------------------------------------------------------------------

loc_1000392A:				; CODE XREF: sub_10003640+EFj
		mov	ecx, [esi+4]
		and	ecx, 0FFFFFFFEh
		mov	[eax], ecx
		mov	edx, [esi+4]
		and	edx, 1
		or	edx, eax
		mov	[esi+4], edx
		mov	ecx, [eax+4]
		xor	ecx, edx
		and	ecx, 1
		xor	ecx, edx
		mov	[esi+4], ecx
		or	dword ptr [eax+4], 1
		mov	ecx, [esi+4]
		and	ecx, 1
		or	ecx, edi
		mov	[esi+4], ecx
		jmp	loc_10003737
; ---------------------------------------------------------------------------

loc_1000395E:				; CODE XREF: sub_10003640+16Fj
		cmp	ecx, 1
		jnz	loc_1000369E

loc_10003967:				; CODE XREF: sub_10003640+5ADj
		mov	ebx, [eax+4]
		mov	edx, ebx
		and	edx, 0FFFFFFFEh
		mov	ecx, [edx]
		test	byte ptr [ecx+4], 1
		jnz	loc_100036CA
		mov	ecx, [eax]
		mov	[esp+2Ch+var_14], ecx
		test	byte ptr [ecx+4], 1
		jnz	loc_10003AF5
		or	ebx, 1
		mov	[eax+4], ebx
		mov	ebx, [ecx]
		mov	edx, [ebx+4]
		test	dl, 1
		jnz	loc_10003BA2
		or	dword ptr [ecx+4], 1

loc_100039A3:				; CODE XREF: sub_10003640+8E48j
		mov	ecx, [eax+4]
		mov	ebx, ecx
		and	ebx, 0FFFFFFFEh
		and	ecx, 1
		mov	[esp+2Ch+var_C], ebx
		or	ecx, [ebx]
		mov	[eax+4], ecx
		mov	[ebx], eax
		mov	eax, ebx
		jmp	loc_100036A6
; ---------------------------------------------------------------------------

loc_100039C0:				; CODE XREF: sub_10003640+2Dj
		mov	ecx, 1
		jmp	loc_10003675
; ---------------------------------------------------------------------------

loc_100039CA:				; CODE XREF: sub_10003640+2CEj
		and	edx, 0FFFFFFFEh
		mov	[esp+2Ch+var_C], ebx
		mov	[ecx+4], edx
		or	dword ptr [eax+4], 1
		mov	ecx, [eax+4]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx]
		mov	[eax+4], ecx
		mov	ecx, [esp+2Ch+var_14]
		mov	[edx], eax
		mov	eax, ebx
		mov	[ebx], edx
		and	dword ptr [ebx+4], 0FFFFFFFEh
		jmp	loc_1000369E
; ---------------------------------------------------------------------------

loc_100039FB:				; CODE XREF: sub_10003640+FEj
		mov	eax, [ebp+0Ch+var_8]
		and	eax, 1
		pop	edi
		or	eax, esi
		mov	[ebp+0Ch+var_8], eax
		mov	eax, [esp+28h+var_C]
		pop	esi
		pop	ebp
		mov	[ecx], eax
		pop	ebx
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_10003A14:				; CODE XREF: sub_10003640+227j
		or	edx, 1
		mov	[ecx+4], edx
		mov	edx, [ecx]
		mov	ecx, [edx+4]
		test	cl, 1
		jnz	short loc_10003A6C
		mov	ecx, [eax+4]
		jmp	loc_100036F6
; ---------------------------------------------------------------------------

loc_10003A2C:				; CODE XREF: sub_10003640+C8j
		mov	eax, [ebp+0Ch+var_8]
		and	eax, 1
		or	eax, ebx
		mov	[ebp+0Ch+var_8], eax
		jmp	loc_10003711
; ---------------------------------------------------------------------------

loc_10003A3C:				; CODE XREF: sub_10003640+23Ej
		mov	ecx, [edx+4]
		xor	ecx, ebx
		and	ecx, 1
		xor	[edx+4], ecx
		mov	ecx, [esp+2Ch+var_10]
		mov	edx, [esp+2Ch+var_14]
		and	dword ptr [ecx+4], 0FFFFFFFEh
		mov	ecx, [edx+4]
		mov	ebx, ecx
		and	ebx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [ebx]
		mov	[edx+4], ecx
		mov	[ebx], edx
		mov	[eax], ebx
		jmp	loc_10003892
; ---------------------------------------------------------------------------

loc_10003A6C:				; CODE XREF: sub_10003640+3E2j
		and	ecx, 0FFFFFFFEh
		mov	[edx+4], ecx
		mov	ebx, [eax]
		mov	ecx, [ebx+4]
		and	ecx, 0FFFFFFFEh
		mov	[eax], ecx
		mov	ecx, [ebx+4]
		and	ecx, 1
		or	ecx, eax
		mov	[ebx+4], ecx
		mov	ecx, [eax+4]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx]
		mov	[eax+4], ecx
		mov	[edx], eax
		mov	ecx, [ebx+4]
		and	ecx, 1
		or	ecx, edx
		mov	[ebx+4], ecx
		jmp	loc_10003705
; ---------------------------------------------------------------------------

loc_10003AA9:				; CODE XREF: sub_10003640+7Ej
		mov	edx, [esp+2Ch+var_18]
		cmp	[edx], esi
		jnz	loc_10003BF2
		mov	[edx], eax

loc_10003AB7:				; CODE XREF: sub_10003640+5BDj
		mov	ecx, [esi]
		mov	[eax], ecx
		mov	edx, [esi+4]
		xor	edx, [eax+4]
		and	edx, 1
		xor	edx, [esi+4]
		mov	[eax+4], edx
		mov	ecx, [esi+4]
		xor	ecx, edx
		and	ecx, 1
		xor	ecx, edx
		mov	[eax+4], ecx
		mov	ecx, [esp+2Ch+var_1C]
		cmp	[ebp+0Ch+var_C], eax
		jnz	loc_1000C499
		mov	[ebp+0Ch+var_C], edi
		mov	eax, [esp+2Ch+var_C]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], eax
		pop	ebx
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_10003AF5:				; CODE XREF: sub_10003640+345j
		mov	edx, [ecx+4]
		test	dl, 1
		jz	loc_1000C47A
		and	edx, 0FFFFFFFEh
		mov	ecx, [edx]
		mov	[esp+2Ch+var_10], ecx
		test	byte ptr [ecx+4], 1
		mov	ecx, [esp+2Ch+var_14]
		jnz	loc_10003C02
		and	ebx, 1
		or	ebx, edx
		mov	[ecx+4], ebx
		or	dword ptr [edx+4], 1
		mov	ebx, [eax]

loc_10003B26:				; CODE XREF: sub_10003640+5EDj
		mov	ecx, [ebx+4]
		and	ecx, 0FFFFFFFEh
		mov	[esp+2Ch+var_C], ebx
		mov	[eax], ecx
		mov	ecx, [ebx+4]
		and	ecx, 1
		or	ecx, eax
		mov	[ebx+4], ecx
		mov	ecx, [eax+4]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx]
		mov	[eax+4], ecx
		mov	[edx], eax
		mov	ecx, [ebx+4]
		and	ecx, 1
		or	ecx, edx
		mov	[ebx+4], ecx
		or	dword ptr [eax+4], 1
		mov	eax, ebx
		jmp	loc_100036A6
; ---------------------------------------------------------------------------

loc_10003B65:				; CODE XREF: sub_10003640+187j
		mov	ecx, [esi+4]
		and	ecx, 0FFFFFFFEh
		mov	[eax], ecx
		mov	edx, [esi+4]
		and	edx, 1
		or	edx, eax
		mov	[esi+4], edx
		mov	ecx, [eax+4]
		xor	ecx, edx
		and	ecx, 1
		xor	ecx, edx
		mov	[esi+4], ecx
		or	dword ptr [eax+4], 1
		mov	eax, [esi+4]
		mov	ecx, [esp+2Ch+var_1C]
		and	eax, 1
		or	eax, edi
		pop	edi
		mov	[esi+4], eax
		mov	[ecx], esi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_10003BA2:				; CODE XREF: sub_10003640+359j
		and	edx, 0FFFFFFFEh
		mov	[ebx+4], edx

loc_10003BA8:				; CODE XREF: sub_10003640+8E54j
		mov	ebx, [eax]
		mov	[esp+2Ch+var_C], ebx
		mov	ecx, [ebx+4]
		and	ecx, 0FFFFFFFEh
		mov	[eax], ecx
		mov	ecx, [ebx+4]
		and	ecx, 1
		or	ecx, eax
		mov	[ebx+4], ecx
		mov	ecx, [eax+4]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx]
		mov	[eax+4], ecx
		mov	[edx], eax
		mov	eax, [ebx+4]
		and	eax, 1
		or	eax, edx
		mov	[ebx+4], eax
		mov	eax, ebx
		jmp	loc_100036A6
; ---------------------------------------------------------------------------

loc_10003BE5:				; CODE XREF: sub_10003640+17Dj
		lea	ecx, [esp+2Ch+var_C]
		mov	[esp+2Ch+var_18], ecx
		jmp	loc_10003967
; ---------------------------------------------------------------------------

loc_10003BF2:				; CODE XREF: sub_10003640+46Fj
		mov	ecx, [edx+4]
		and	ecx, 1
		or	ecx, eax
		mov	[edx+4], ecx
		jmp	loc_10003AB7
; ---------------------------------------------------------------------------

loc_10003C02:				; CODE XREF: sub_10003640+4D2j
		mov	ecx, [edx+4]
		xor	ecx, ebx
		and	ecx, 1
		xor	[edx+4], ecx
		mov	ecx, [esp+2Ch+var_10]
		mov	edx, [esp+2Ch+var_14]
		and	dword ptr [ecx+4], 0FFFFFFFEh
		mov	ecx, [edx+4]
		mov	ebx, ecx
		and	ebx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [ebx]
		mov	[edx+4], ecx
		mov	[ebx], edx
		mov	[eax], ebx
		jmp	loc_10003B26
; ---------------------------------------------------------------------------

loc_10003C32:				; CODE XREF: sub_10003640+60j
		mov	ecx, [esp+2Ch+var_1C]
		mov	[ecx], ebx
		jmp	loc_1000374D
sub_10003640	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


; int __usercall sub_10003C40@<eax>(LPCRITICAL_SECTION lpCriticalSection@<ecx>,	int)
sub_10003C40	proc near		; CODE XREF: sub_100017A1+Cj
					; moz_xrealloc+3A8p ...

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= byte ptr -0Ch
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000C4AF SIZE 00000018 BYTES

		sub	esp, 14h
		push	ebx
		push	ebp
		push	esi
		push	edi
		lea	edi, [edx+0FFFh]
		mov	ebx, ecx
		and	edi, 0FFFFF000h
		push	ebx		; lpCriticalSection
		mov	[esp+28h+var_14], edi
		call	ds:EnterCriticalSection
		mov	edx, [ebx+0A8h]
		lea	ecx, [ebx+0A8h]
		mov	eax, edi
		lea	esi, [ecx+4]
		or	eax, 10h
		xor	ebp, ebp
		mov	[esp+24h+var_10], eax
		cmp	edx, esi
		jz	loc_10003D4C
		mov	edi, eax
		and	edi, 0FFFFF000h
		lea	ebx, [ebx+0]

loc_10003C90:				; CODE XREF: sub_10003C40+77j
		mov	ecx, [edx+8]
		and	ecx, 0FFFFF000h
		cmp	ecx, edi
		sbb	eax, eax
		neg	eax
		cmp	edi, ecx
		sbb	ecx, ecx
		neg	ecx
		sub	eax, ecx
		jz	short loc_10003D1A

loc_10003CA9:				; CODE XREF: sub_10003C40+F4j
		test	eax, eax
		jns	loc_10003D39
		mov	ebp, edx
		mov	edx, [edx]

loc_10003CB5:				; CODE XREF: sub_10003C40+101j
		cmp	edx, esi
		jnz	short loc_10003C90

loc_10003CB9:				; CODE XREF: sub_10003C40+166j
		mov	edi, [esp+24h+var_14]
		test	ebp, ebp
		jz	loc_10003D46
		mov	ecx, ebp
		mov	eax, 0AAAAAAABh
		and	ecx, 0FFF00000h
		sub	ebp, ecx
		sub	ebp, 10h
		mul	ebp
		mov	esi, edx
		shr	esi, 3
		shl	esi, 0Ch
		add	esi, ecx

loc_10003CE3:				; CODE XREF: sub_10003C40+12Ej
					; sub_10003C40+15Bj
		push	[esp+24h+arg_0]
		mov	edx, esi
		mov	ecx, ebx
		push	1
		push	edi
		call	sub_10003DC0
		add	esp, 0Ch
		test	esi, esi
		jz	loc_10003DAB
		add	dword ptr [ebx+70h], 1
		push	ebx		; lpCriticalSection
		adc	dword ptr [ebx+74h], 0
		add	[ebx+68h], edi
		call	ds:LeaveCriticalSection
		mov	eax, esi

loc_10003D12:				; CODE XREF: sub_10003C40+174j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_10003D1A:				; CODE XREF: sub_10003C40+67j
		test	byte ptr [esp+24h+var_10], 10h
		jz	loc_1000C4AF
		xor	ecx, ecx

loc_10003D27:				; CODE XREF: sub_10003C40+8877j
		xor	eax, eax

loc_10003D29:				; CODE XREF: sub_10003C40+8882j
		cmp	ecx, edx
		jnb	short loc_10003DA0
		mov	ecx, 1

loc_10003D32:				; CODE XREF: sub_10003C40+162j
		sub	eax, ecx
		jmp	loc_10003CA9
; ---------------------------------------------------------------------------

loc_10003D39:				; CODE XREF: sub_10003C40+6Bj
		jle	short loc_10003DA4
		mov	edx, [edx+4]
		and	edx, 0FFFFFFFEh
		jmp	loc_10003CB5
; ---------------------------------------------------------------------------

loc_10003D46:				; CODE XREF: sub_10003C40+7Fj
		lea	ecx, [ebx+0A8h]

loc_10003D4C:				; CODE XREF: sub_10003C40+3Cj
		mov	edx, [ebx+0A0h]
		test	edx, edx
		jz	short loc_10003D73
		lea	esi, [edx+1000h]
		mov	dword ptr [ebx+0A0h], 0
		add	edx, 1Ch
		call	sub_10004C50
		jmp	loc_10003CE3
; ---------------------------------------------------------------------------

loc_10003D73:				; CODE XREF: sub_10003C40+114j
		mov	edx, 100000h
		push	1		; char
		push	0		; int
		mov	ecx, edx	; dwSize
		call	sub_100059AC
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jz	short loc_10003DAB
		mov	edx, esi
		mov	ecx, ebx
		call	sub_10005917
		add	esi, 1000h
		jmp	loc_10003CE3
; ---------------------------------------------------------------------------

loc_10003DA0:				; CODE XREF: sub_10003C40+EBj
		xor	ecx, ecx
		jmp	short loc_10003D32
; ---------------------------------------------------------------------------

loc_10003DA4:				; CODE XREF: sub_10003C40:loc_10003D39j
		mov	ebp, edx
		jmp	loc_10003CB9
; ---------------------------------------------------------------------------

loc_10003DAB:				; CODE XREF: sub_10003C40+B8j
					; sub_10003C40+14Aj
		push	ebx		; lpCriticalSection
		call	ds:LeaveCriticalSection
		xor	eax, eax
		jmp	loc_10003D12
sub_10003C40	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


sub_10003DC0	proc near		; CODE XREF: sub_10001850+6Ap
					; sub_100029D0+9Ap ...

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		sub	esp, 20h
		mov	eax, edx
		mov	[esp+20h+var_18], ecx
		push	ebx
		push	ebp
		mov	ebp, eax
		mov	[esp+28h+var_8], eax
		push	esi
		mov	esi, [esp+2Ch+arg_0]
		and	ebp, 0FFF00000h
		push	edi
		mov	edi, eax
		shr	esi, 0Ch
		sub	edi, ebp
		mov	[esp+30h+var_C], ebp
		mov	edx, [ebp+0Ch]
		add	ecx, 0A8h
		shr	edi, 0Ch
		mov	[esp+30h+var_4], edx
		lea	edx, [ebp+10h]
		mov	[esp+30h+var_1C], esi
		mov	[esp+30h+var_20], ecx
		lea	eax, [edi+edi*2]
		lea	eax, ds:18h[eax*4]
		add	eax, ebp
		mov	[esp+30h+var_10], eax
		mov	eax, [eax]
		shr	eax, 0Ch
		mov	[esp+30h+var_14], eax
		mov	ebx, eax
		lea	eax, [edi+edi*2]
		lea	edx, [edx+eax*4]
		call	sub_10003FB0
		sub	ebx, esi
		jnz	loc_10003ED1

loc_10003E31:				; CODE XREF: sub_10003DC0+15Dj
		mov	ecx, [esp+30h+var_1C]
		xor	ebx, ebx
		mov	edx, [esp+30h+arg_4]
		mov	[esp+30h+var_14], ebx
		test	ecx, ecx
		jz	short loc_10003E93
		mov	esi, [esp+30h+var_10]
		shl	edi, 0Ch
		add	edi, ebp
		lea	esp, [esp+0]

loc_10003E50:				; CODE XREF: sub_10003DC0+D1j
		mov	eax, [esi]
		test	al, 60h
		jnz	loc_10003F50
		cmp	[esp+30h+arg_8], 0
		jnz	short loc_10003EB3

loc_10003E61:				; CODE XREF: sub_10003DC0+F5j
					; sub_10003DC0+10Fj ...
		test	byte ptr [esi],	8
		jz	short loc_10003E73
		mov	eax, [esp+30h+var_18]
		dec	dword ptr [ebp+0Ch]
		dec	dword ptr [eax+0A4h]

loc_10003E73:				; CODE XREF: sub_10003DC0+A4j
		test	edx, edx
		jz	loc_10003F22
		mov	dword ptr [esi], 3

loc_10003E81:				; CODE XREF: sub_10003DC0+16Bj
		inc	ebx
		add	edi, 1000h
		add	esi, 0Ch
		mov	[esp+30h+var_14], ebx
		cmp	ebx, ecx
		jb	short loc_10003E50

loc_10003E93:				; CODE XREF: sub_10003DC0+81j
		test	edx, edx
		jz	short loc_10003EA1
		mov	eax, [esp+30h+var_10]
		mov	ecx, [esp+30h+arg_0]
		or	[eax], ecx

loc_10003EA1:				; CODE XREF: sub_10003DC0+D5j
		cmp	dword ptr [ebp+0Ch], 0
		jz	loc_10003F30

loc_10003EAB:				; CODE XREF: sub_10003DC0+175j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_10003EB3:				; CODE XREF: sub_10003DC0+9Fj
		test	al, 4
		jnz	short loc_10003E61
		push	1000h		; size_t
		push	0		; int
		push	edi		; void *
		call	memset
		mov	edx, [esp+3Ch+arg_4]
		add	esp, 0Ch
		mov	ecx, [esp+30h+var_1C]
		jmp	short loc_10003E61
; ---------------------------------------------------------------------------

loc_10003ED1:				; CODE XREF: sub_10003DC0+6Bj
		add	esi, edi
		shl	ebx, 0Ch
		lea	eax, [esi+esi*2]
		lea	ecx, ds:18h[eax*4]
		mov	eax, [ecx+ebp]
		and	eax, 0FFFh
		or	eax, ebx
		mov	[ecx+ebp], eax
		mov	eax, [esp+30h+var_14]
		mov	ecx, [esp+30h+var_20]
		inc	eax
		add	eax, edi
		lea	eax, [eax+eax*2]
		lea	edx, ds:0[eax*4]
		mov	eax, [edx+ebp]
		and	eax, 0FFFh
		or	eax, ebx
		mov	[edx+ebp], eax
		lea	eax, [esi+esi*2]
		lea	edx, [ebp+10h]
		lea	edx, [edx+eax*4]
		call	sub_10004C50
		jmp	loc_10003E31
; ---------------------------------------------------------------------------

loc_10003F22:				; CODE XREF: sub_10003DC0+B5j
		mov	eax, [esp+30h+var_8]
		or	eax, 1
		mov	[esi], eax
		jmp	loc_10003E81
; ---------------------------------------------------------------------------

loc_10003F30:				; CODE XREF: sub_10003DC0+E5j
		cmp	[esp+30h+var_4], 0
		jbe	loc_10003EAB
		mov	ecx, [esp+30h+var_18]
		mov	edx, ebp
		pop	edi
		pop	esi
		pop	ebp
		sub	ecx, 0FFFFFF80h
		pop	ebx
		add	esp, 20h
		jmp	sub_10004FE0
; ---------------------------------------------------------------------------

loc_10003F50:				; CODE XREF: sub_10003DC0+94j
		xor	eax, eax
		mov	[esp+30h+var_20], eax
		cmp	ebx, ecx
		jnb	short loc_10003F84
		mov	ebp, ebx
		mov	edx, esi
		mov	ebx, eax

loc_10003F60:				; CODE XREF: sub_10003DC0+1B2j
		mov	eax, [edx]
		test	al, 60h
		jz	short loc_10003F74
		and	eax, 0FFFFFF9Fh
		inc	ebp
		mov	[edx], eax
		inc	ebx
		add	edx, 0Ch
		cmp	ebp, ecx
		jb	short loc_10003F60

loc_10003F74:				; CODE XREF: sub_10003DC0+1A4j
		mov	ebp, [esp+30h+var_C]
		mov	[esp+30h+var_20], ebx
		mov	ebx, [esp+30h+var_14]
		mov	eax, [esp+30h+var_20]

loc_10003F84:				; CODE XREF: sub_10003DC0+198j
		mov	edx, eax
		mov	ecx, edi	; lpAddress
		shl	edx, 0Ch
		call	sub_100056A2
		mov	eax, [esp+30h+var_18]
		mov	ecx, [esp+30h+var_20]
		mov	edx, [esp+30h+arg_4]
		add	dword ptr [eax+40h], 1
		adc	dword ptr [eax+44h], 0
		add	[eax+50h], ecx
		mov	ecx, [esp+30h+var_1C]
		jmp	loc_10003E61
sub_10003DC0	endp


; =============== S U B	R O U T	I N E =======================================


sub_10003FB0	proc near		; CODE XREF: sub_10003DC0+64p
					; sub_10004A40+117p ...

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8

; FUNCTION CHUNK AT 1000C4C7 SIZE 00000042 BYTES

		sub	esp, 20h
		push	ebx
		mov	eax, ecx
		lea	ebx, [esp+24h+var_C]
		push	ebp
		mov	[esp+28h+var_1C], eax
		push	esi
		mov	ecx, [eax]
		lea	ebp, [eax+4]
		push	edi
		mov	edi, edx
		mov	[esp+30h+var_14], ecx
		mov	esi, ecx
		mov	[esp+30h+var_C], ecx
		mov	eax, ebp
		mov	[esp+30h+var_20], ebx
		and	eax, 0FFFFFFFEh
		mov	[esp+30h+var_18], ebp
		mov	ebx, [edi+8]
		mov	ecx, ebx
		mov	[esp+30h+var_8], eax
		and	ecx, 0FFFFF000h
		mov	eax, [esi+8]
		and	eax, 0FFFFF000h
		cmp	eax, ecx
		sbb	edx, edx
		neg	edx
		cmp	ecx, eax
		sbb	eax, eax
		neg	eax
		sub	edx, eax
		jz	loc_10004255

loc_1000400A:				; CODE XREF: sub_10003FB0+2C2j
					; sub_10003FB0+620j
		test	edx, edx
		jns	loc_100041AB
		mov	ecx, [esi]
		test	byte ptr [ecx+4], 1
		jz	loc_1000420D

loc_1000401E:				; CODE XREF: sub_10003FB0+263j
		mov	[esp+30h+var_20], esi
		mov	esi, ecx

loc_10004024:				; CODE XREF: sub_10003FB0+204j
		mov	ebx, [esp+30h+var_14]

loc_10004028:				; CODE XREF: sub_10003FB0+2A0j
					; sub_10003FB0+5CEj ...
		test	edx, edx
		jz	loc_1000463C

loc_10004030:				; CODE XREF: sub_10003FB0+DBj
					; sub_10003FB0+162j ...
		mov	ebx, [edi+8]
		mov	edx, ebx
		mov	ecx, [esi+8]
		and	edx, 0FFFFF000h
		and	ecx, 0FFFFF000h
		cmp	ecx, edx
		sbb	eax, eax
		neg	eax
		cmp	edx, ecx
		sbb	ecx, ecx
		neg	ecx
		sub	eax, ecx
		jnz	short loc_10004071
		test	bl, 10h
		jnz	loc_10004635
		mov	ecx, edi
		cmp	edi, esi
		ja	loc_10004353

loc_10004067:				; CODE XREF: sub_10003FB0+687j
		xor	eax, eax

loc_10004069:				; CODE XREF: sub_10003FB0+3A8j
		cmp	ecx, esi
		sbb	ecx, ecx
		neg	ecx
		sub	eax, ecx

loc_10004071:				; CODE XREF: sub_10003FB0+A2j
		test	eax, eax
		jns	short loc_1000408D
		mov	ecx, [esi]
		cmp	ecx, ebp
		jz	loc_10004381
		test	byte ptr [ecx+4], 1
		jz	short loc_100040CD

loc_10004085:				; CODE XREF: sub_10003FB0+123j
					; sub_10003FB0+179j
		mov	[esp+30h+var_20], esi
		mov	esi, ecx
		jmp	short loc_10004030
; ---------------------------------------------------------------------------

loc_1000408D:				; CODE XREF: sub_10003FB0+C3j
		jnz	loc_10004117
		mov	eax, [esi+4]
		and	eax, 0FFFFFFFEh
		cmp	eax, ebp
		jnz	loc_1000435D
		mov	edx, [esi]
		cmp	edx, ebp
		jnz	loc_100041D9
		mov	edx, ebp

loc_100040AD:				; CODE XREF: sub_10003FB0+258j
		mov	ecx, [esp+30h+var_20]
		cmp	[ecx], esi
		jnz	loc_10004277
		mov	[ecx], edx
		mov	ecx, [esp+30h+var_1C]
		mov	eax, [esp+30h+var_C]
		mov	[ecx], eax

loc_100040C5:				; CODE XREF: sub_10003FB0+692j
					; sub_10003FB0+8554j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_100040CD:				; CODE XREF: sub_10003FB0+D3j
		mov	eax, [ecx]
		test	byte ptr [eax+4], 1
		jnz	short loc_10004085
		or	dword ptr [ecx+4], 1
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		mov	edx, [ecx]
		test	byte ptr [edx+4], 1
		jnz	loc_100043CF
		or	eax, 1
		mov	edx, eax
		mov	[esi+4], eax
		and	edx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [edx]
		mov	[esi+4], eax
		mov	[edx], esi

loc_10004102:				; CODE XREF: sub_10003FB0+461j
					; sub_10003FB0+60Ej
		mov	ecx, [esp+30h+var_20]
		cmp	[ecx], esi
		jnz	loc_1000C4DF
		mov	[ecx], edx

loc_10004110:				; CODE XREF: sub_10003FB0+853Aj
		mov	esi, edx
		jmp	loc_10004030
; ---------------------------------------------------------------------------

loc_10004117:				; CODE XREF: sub_10003FB0:loc_1000408Dj
		mov	edx, [esp+30h+var_20]

loc_1000411B:				; CODE XREF: sub_10003FB0+3B5j
		mov	ebx, [esi+4]
		mov	ecx, ebx
		and	ecx, 0FFFFFFFEh
		mov	eax, [ecx]
		test	byte ptr [eax+4], 1
		jnz	loc_10004085
		mov	eax, [esi]
		mov	[esp+30h+var_10], eax
		mov	ecx, [eax+4]
		test	cl, 1
		jz	loc_10004329
		and	ecx, 0FFFFFFFEh
		mov	edx, [ecx]
		mov	[esp+30h+var_14], edx
		test	byte ptr [edx+4], 1
		mov	edx, [esp+30h+var_20]
		jnz	loc_10004453
		and	ebx, 1
		or	ebx, ecx
		mov	[eax+4], ebx
		or	dword ptr [ecx+4], 1
		mov	ebx, [esi]

loc_10004166:				; CODE XREF: sub_10003FB0+4CEj
		mov	eax, [ebx+4]
		and	eax, 0FFFFFFFEh
		mov	[esi], eax
		mov	eax, [ebx+4]
		and	eax, 1
		or	eax, esi
		mov	[ebx+4], eax
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	eax, [ebx+4]
		and	eax, 1
		or	eax, ecx
		mov	[ebx+4], eax
		or	dword ptr [esi+4], 1

loc_1000419A:				; CODE XREF: sub_10003FB0+39Ej
					; sub_10003FB0+49Ej
		cmp	[edx], esi
		jnz	loc_1000436A
		mov	[edx], ebx

loc_100041A4:				; CODE XREF: sub_10003FB0+3C5j
		mov	esi, ebx
		jmp	loc_10004030
; ---------------------------------------------------------------------------

loc_100041AB:				; CODE XREF: sub_10003FB0+5Cj
		jz	loc_10004294
		cmp	edx, 1
		jnz	loc_10004024

loc_100041BA:				; CODE XREF: sub_10003FB0+5DBj
		mov	ecx, [esi+4]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		mov	eax, [edx]
		test	byte ptr [eax+4], 1
		jz	loc_100042E9
		mov	[esp+30h+var_20], esi
		mov	esi, edx
		jmp	loc_10004030
; ---------------------------------------------------------------------------

loc_100041D9:				; CODE XREF: sub_10003FB0+F5j
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[esi], eax
		mov	ecx, [edx+4]
		and	ecx, 1
		or	ecx, esi
		mov	[edx+4], ecx
		mov	eax, [esi+4]
		xor	eax, ecx
		and	eax, 1
		xor	eax, ecx
		mov	[edx+4], eax
		or	dword ptr [esi+4], 1
		mov	eax, [edx+4]
		and	eax, 1
		or	eax, ebp
		mov	[edx+4], eax
		jmp	loc_100040AD
; ---------------------------------------------------------------------------

loc_1000420D:				; CODE XREF: sub_10003FB0+68j
		mov	eax, [ecx]
		test	byte ptr [eax+4], 1
		jnz	loc_1000401E
		or	dword ptr [ecx+4], 1
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		mov	ebx, [ecx]
		test	byte ptr [ebx+4], 1
		jnz	loc_10004532
		or	eax, 1
		mov	ebx, eax
		mov	[esi+4], eax
		and	ebx, 0FFFFFFFEh
		and	eax, 1
		mov	[esp+30h+var_C], ebx
		or	eax, [ebx]
		mov	[esi+4], eax
		mov	[ebx], esi
		mov	esi, ebx
		and	dword ptr [ebx+4], 0FFFFFFFEh
		jmp	loc_10004028
; ---------------------------------------------------------------------------

loc_10004255:				; CODE XREF: sub_10003FB0+54j
		test	bl, 10h
		jnz	loc_1000462E
		mov	eax, edi
		cmp	edi, esi
		ja	loc_100045C3

loc_10004268:				; CODE XREF: sub_10003FB0+680j
		xor	edx, edx
		cmp	eax, esi
		sbb	eax, eax
		neg	eax
		sub	edx, eax
		jmp	loc_1000400A
; ---------------------------------------------------------------------------

loc_10004277:				; CODE XREF: sub_10003FB0+103j
		mov	eax, [ecx+4]
		and	eax, 1
		or	eax, edx
		mov	[ecx+4], eax
		mov	ecx, [esp+30h+var_1C]
		mov	eax, [esp+30h+var_C]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], eax
		pop	ebx
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_10004294:				; CODE XREF: sub_10003FB0:loc_100041ABj
		mov	eax, [esi+4]
		and	eax, 0FFFFFFFEh
		cmp	eax, ebp
		jnz	loc_10004583
		mov	edx, [esi]
		cmp	edx, ebp
		jz	loc_1000437A
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[esi], eax
		mov	ecx, [edx+4]
		and	ecx, 1
		or	ecx, esi
		mov	[edx+4], ecx
		mov	eax, [esi+4]
		xor	eax, ecx
		and	eax, 1
		xor	eax, ecx
		mov	[edx+4], eax
		or	dword ptr [esi+4], 1
		mov	eax, [edx+4]
		and	eax, 1
		or	eax, ebp
		mov	[edx+4], eax

loc_100042DB:				; CODE XREF: sub_10003FB0+3CCj
		mov	ecx, [esp+30h+var_1C]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], edx
		pop	ebx
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_100042E9:				; CODE XREF: sub_10003FB0+218j
		mov	ebx, [esi]
		test	byte ptr [ebx+4], 1
		jnz	loc_100044C6
		or	ecx, 1
		mov	[esi+4], ecx
		mov	ecx, [ebx]
		mov	eax, [ecx+4]
		test	al, 1
		jnz	loc_10004483
		or	dword ptr [ebx+4], 1

loc_1000430C:				; CODE XREF: sub_10003FB0+8524j
		mov	eax, [esi+4]
		mov	edx, eax
		and	edx, 0FFFFFFFEh
		and	eax, 1
		mov	[esp+30h+var_C], edx
		or	eax, [edx]
		mov	[esi+4], eax
		mov	[edx], esi
		mov	esi, edx
		jmp	loc_10004030
; ---------------------------------------------------------------------------

loc_10004329:				; CODE XREF: sub_10003FB0+18Bj
		or	ecx, 1
		mov	[eax+4], ecx
		mov	ecx, [eax]
		mov	eax, [ecx+4]
		test	al, 1
		jnz	loc_10004416
		mov	eax, [esi+4]
		mov	ebx, eax
		and	ebx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [ebx]
		mov	[esi+4], eax
		mov	[ebx], esi
		jmp	loc_1000419A
; ---------------------------------------------------------------------------

loc_10004353:				; CODE XREF: sub_10003FB0+B1j
		mov	eax, 1
		jmp	loc_10004069
; ---------------------------------------------------------------------------

loc_1000435D:				; CODE XREF: sub_10003FB0+EBj
		mov	edx, [esp+30h+var_20]
		mov	[esp+30h+var_18], edx
		jmp	loc_1000411B
; ---------------------------------------------------------------------------

loc_1000436A:				; CODE XREF: sub_10003FB0+1ECj
		mov	eax, [edx+4]
		and	eax, 1
		or	eax, ebx
		mov	[edx+4], eax
		jmp	loc_100041A4
; ---------------------------------------------------------------------------

loc_1000437A:				; CODE XREF: sub_10003FB0+2F6j
		mov	edx, ebp
		jmp	loc_100042DB
; ---------------------------------------------------------------------------

loc_10004381:				; CODE XREF: sub_10003FB0+C9j
		mov	ecx, [esp+30h+var_18]
		cmp	[ecx], edi
		jnz	loc_10004590
		mov	[ecx], esi

loc_1000438F:				; CODE XREF: sub_10003FB0+5EBj
		mov	eax, [edi]
		mov	[esi], eax
		mov	ecx, [edi+4]
		xor	ecx, [esi+4]
		and	ecx, 1
		xor	ecx, [edi+4]
		mov	[esi+4], ecx
		mov	eax, [edi+4]
		xor	eax, ecx
		and	eax, 1
		xor	eax, ecx
		mov	ecx, [esp+30h+var_20]
		mov	[esi+4], eax
		cmp	[ecx], esi
		jnz	loc_1000C4EF
		mov	[ecx], ebp
		mov	ecx, [esp+30h+var_1C]
		mov	eax, [esp+30h+var_C]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], eax
		pop	ebx
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_100043CF:				; CODE XREF: sub_10003FB0+137j
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[ecx], eax
		mov	eax, [edx+4]
		and	eax, 1
		or	eax, ecx
		mov	[edx+4], eax
		mov	eax, [esi+4]
		and	eax, 1
		or	eax, edx
		mov	edx, eax
		mov	[esi+4], eax
		and	edx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [edx]
		mov	[esi+4], eax
		mov	[edx], esi
		mov	eax, [esi+4]
		and	eax, 0FFFFFFFEh
		mov	ecx, [eax+4]
		test	cl, 1
		jnz	loc_100045A0
		mov	[esi+4], eax
		jmp	loc_10004102
; ---------------------------------------------------------------------------

loc_10004416:				; CODE XREF: sub_10003FB0+386j
		and	eax, 0FFFFFFFEh
		mov	[ecx+4], eax
		mov	ebx, [esi]
		mov	eax, [ebx+4]
		and	eax, 0FFFFFFFEh
		mov	[esi], eax
		mov	eax, [ebx+4]
		and	eax, 1
		or	eax, esi
		mov	[ebx+4], eax
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	eax, [ebx+4]
		and	eax, 1
		or	eax, ecx
		mov	[ebx+4], eax
		jmp	loc_1000419A
; ---------------------------------------------------------------------------

loc_10004453:				; CODE XREF: sub_10003FB0+1A2j
		mov	eax, [ecx+4]
		xor	eax, ebx
		and	eax, 1
		xor	[ecx+4], eax
		mov	eax, [esp+30h+var_14]
		mov	ecx, [esp+30h+var_10]
		and	dword ptr [eax+4], 0FFFFFFFEh
		mov	eax, [ecx+4]
		mov	ebx, eax
		and	ebx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [ebx]
		mov	[ecx+4], eax
		mov	[ebx], ecx
		mov	[esi], ebx
		jmp	loc_10004166
; ---------------------------------------------------------------------------

loc_10004483:				; CODE XREF: sub_10003FB0+352j
					; sub_10003FB0+852Aj
		and	eax, 0FFFFFFFEh
		mov	[ecx+4], eax
		mov	edx, [esi]
		mov	[esp+30h+var_C], edx
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[esi], eax
		mov	eax, [edx+4]
		and	eax, 1
		or	eax, esi
		mov	[edx+4], eax
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	esi, edx
		mov	eax, [edx+4]
		and	eax, 1
		or	eax, ecx
		mov	[edx+4], eax
		jmp	loc_10004030
; ---------------------------------------------------------------------------

loc_100044C6:				; CODE XREF: sub_10003FB0+33Fj
		mov	edx, [ebx+4]
		test	dl, 1
		jz	loc_1000C4C7
		and	edx, 0FFFFFFFEh
		mov	eax, [edx]
		mov	[esp+30h+var_14], eax
		test	byte ptr [eax+4], 1
		jnz	loc_100045D5
		and	ecx, 1
		or	ecx, edx
		mov	[ebx+4], ecx
		or	dword ptr [edx+4], 1
		mov	edx, [esi]

loc_100044F3:				; CODE XREF: sub_10003FB0+64Cj
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[esp+30h+var_C], edx
		mov	[esi], eax
		mov	eax, [edx+4]
		and	eax, 1
		or	eax, esi
		mov	[edx+4], eax
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	eax, [edx+4]
		and	eax, 1
		or	eax, ecx
		mov	[edx+4], eax
		or	dword ptr [esi+4], 1
		mov	esi, edx
		jmp	loc_10004030
; ---------------------------------------------------------------------------

loc_10004532:				; CODE XREF: sub_10003FB0+27Bj
		mov	eax, [ebx+4]
		and	eax, 0FFFFFFFEh
		mov	[ecx], eax
		mov	eax, [ebx+4]
		and	eax, 1
		or	eax, ecx
		mov	[ebx+4], eax
		mov	eax, [esi+4]
		and	eax, 1
		or	eax, ebx
		mov	ebx, eax
		mov	[esi+4], eax
		and	ebx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [ebx]
		mov	[esi+4], eax
		mov	[ebx], esi
		mov	eax, [esi+4]
		and	eax, 0FFFFFFFEh
		mov	ecx, [eax+4]
		test	cl, 1
		jnz	loc_10004601
		mov	[esi+4], eax
		mov	esi, ebx
		and	dword ptr [ebx+4], 0FFFFFFFEh
		mov	[esp+30h+var_C], ebx
		jmp	loc_10004028
; ---------------------------------------------------------------------------

loc_10004583:				; CODE XREF: sub_10003FB0+2ECj
		lea	ecx, [esp+30h+var_C]
		mov	[esp+30h+var_18], ecx
		jmp	loc_100041BA
; ---------------------------------------------------------------------------

loc_10004590:				; CODE XREF: sub_10003FB0+3D7j
		mov	eax, [ecx+4]
		and	eax, 1
		or	eax, esi
		mov	[ecx+4], eax
		jmp	loc_1000438F
; ---------------------------------------------------------------------------

loc_100045A0:				; CODE XREF: sub_10003FB0+458j
		and	ecx, 0FFFFFFFEh
		mov	[eax+4], ecx
		or	dword ptr [esi+4], 1
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	[edx], ecx
		jmp	loc_10004102
; ---------------------------------------------------------------------------

loc_100045C3:				; CODE XREF: sub_10003FB0+2B2j
		cmp	eax, esi
		mov	edx, 1
		sbb	eax, eax
		neg	eax
		sub	edx, eax
		jmp	loc_1000400A
; ---------------------------------------------------------------------------

loc_100045D5:				; CODE XREF: sub_10003FB0+52Fj
		mov	eax, [edx+4]
		xor	eax, ecx
		and	eax, 1
		xor	[edx+4], eax
		mov	eax, [esp+30h+var_14]
		and	dword ptr [eax+4], 0FFFFFFFEh
		mov	eax, [ebx+4]
		mov	edx, eax
		and	edx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [edx]
		mov	[ebx+4], eax
		mov	[edx], ebx
		mov	[esi], edx
		jmp	loc_100044F3
; ---------------------------------------------------------------------------

loc_10004601:				; CODE XREF: sub_10003FB0+5BBj
		and	ecx, 0FFFFFFFEh
		mov	[esp+30h+var_C], ebx
		mov	[eax+4], ecx
		or	dword ptr [esi+4], 1
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	esi, ebx
		mov	[ebx], ecx
		and	dword ptr [ebx+4], 0FFFFFFFEh
		jmp	loc_10004028
; ---------------------------------------------------------------------------

loc_1000462E:				; CODE XREF: sub_10003FB0+2A8j
		xor	eax, eax
		jmp	loc_10004268
; ---------------------------------------------------------------------------

loc_10004635:				; CODE XREF: sub_10003FB0+A7j
		xor	ecx, ecx
		jmp	loc_10004067
; ---------------------------------------------------------------------------

loc_1000463C:				; CODE XREF: sub_10003FB0+7Aj
		mov	ecx, [esp+30h+var_1C]
		mov	[ecx], ebx
		jmp	loc_100040C5
sub_10003FB0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  95. _aligned_free
; Exported entry 105. free

; =============== S U B	R O U T	I N E =======================================


; int __cdecl free(void	*)
		public free
free		proc near		; CODE XREF: sub_1000E3FC+15p
					; sub_1000E62A:loc_1000E6B7p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		push	ecx		; _aligned_free
		push	esi
		mov	esi, [esp+8+arg_0]
		mov	eax, esi
		and	eax, 0FFFFFh
		jz	loc_1000474A
		mov	ecx, esi
		sub	ecx, eax
		shr	eax, 0Ch
		push	ebp
		push	edi
		mov	[esp+10h+var_4], ecx
		mov	edi, [ecx]
		lea	eax, [eax+eax*2]
		test	byte ptr [ecx+eax*4+18h], 2
		lea	ebp, [ecx+eax*4]
		jnz	loc_100047D7
		push	ebx
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	ebp, [ebp+18h]
		and	ebp, 0FFFFF000h
		mov	eax, [ebp+0]
		mov	[esp+14h+arg_0], eax
		mov	ebx, [eax+14h]
		push	ebx		; size_t
		push	0E5h		; int
		push	esi		; void *
		call	memset
		mov	eax, [esp+20h+arg_0]
		add	esp, 0Ch
		sub	esi, [eax+24h]
		lea	eax, [ebx-1]
		sub	esi, ebp
		test	ebx, eax
		jnz	short loc_1000472A
		cmp	ebx, 80h
		ja	loc_1000478F
		mov	cl, ds:byte_1001680F[ebx]
		shr	esi, cl

loc_100046D1:				; CODE XREF: free+F8j free+158j ...
		mov	eax, esi
		shr	eax, 5
		cmp	eax, [ebp+4]
		jb	loc_100047AD

loc_100046DF:				; CODE XREF: free+160j
		lea	edx, ds:0[eax*4]
		shl	eax, 5
		sub	esi, eax
		mov	eax, 1
		mov	ecx, esi
		mov	esi, [esp+14h+arg_0]
		shl	eax, cl
		or	[edx+ebp+0Ch], eax
		inc	dword ptr [ebp+8]
		mov	eax, [ebp+8]
		mov	ecx, [esi+1Ch]
		cmp	eax, ecx
		jz	loc_100047F6
		cmp	eax, 1
		jz	short loc_10004759

loc_10004712:				; CODE XREF: free+10Dj	free+13Dj ...
		sub	[edi+54h], ebx
		add	dword ptr [edi+60h], 1
		push	edi		; lpCriticalSection
		adc	dword ptr [edi+64h], 0
		call	ds:LeaveCriticalSection
		pop	ebx
		pop	edi
		pop	ebp

loc_10004727:				; CODE XREF: free+FCj
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1000472A:				; CODE XREF: free+6Bj
		cmp	ebx, 1D2h
		ja	loc_100047E9
		mov	eax, ebx
		shr	eax, 4
		mov	eax, ds:dword_10016884[eax*4]
		imul	esi, eax
		shr	esi, 15h
		jmp	short loc_100046D1
; ---------------------------------------------------------------------------

loc_1000474A:				; CODE XREF: free+Dj
		test	esi, esi
		jz	short loc_10004727
		mov	ecx, esi
		pop	esi
		add	esp, 4
		jmp	sub_10006073
; ---------------------------------------------------------------------------

loc_10004759:				; CODE XREF: free+C0j
		mov	eax, [esi]
		cmp	ebp, eax
		jz	short loc_10004712
		test	eax, eax
		jz	short loc_1000478B
		cmp	ebp, eax
		jnb	short loc_100047B5
		cmp	dword ptr [eax+8], 0
		jbe	short loc_1000478B
		mov	ecx, eax
		and	ecx, 0FFF00000h
		sub	eax, ecx
		shr	eax, 0Ch
		lea	edx, [eax+2]
		lea	edx, [eax+edx*2]
		lea	edx, [ecx+edx*4]
		lea	ecx, [esi+4]
		call	sub_10004840

loc_1000478B:				; CODE XREF: free+111j	free+11Bj
		mov	[esi], ebp
		jmp	short loc_10004712
; ---------------------------------------------------------------------------

loc_1000478F:				; CODE XREF: free+73j
		cmp	ebx, 8000h
		ja	short loc_100047E9
		mov	eax, ebx
		shr	eax, 8
		movzx	ecx, ds:byte_1001680F[eax]
		add	ecx, 8
		shr	esi, cl
		jmp	loc_100046D1
; ---------------------------------------------------------------------------

loc_100047AD:				; CODE XREF: free+89j
		mov	[ebp+4], eax
		jmp	loc_100046DF
; ---------------------------------------------------------------------------

loc_100047B5:				; CODE XREF: free+115j
		mov	ecx, [esp+14h+var_4]
		sub	ebp, ecx
		shr	ebp, 0Ch
		lea	edx, ds:4[ebp*2]
		add	edx, ebp
		lea	edx, [ecx+edx*4]
		lea	ecx, [esi+4]
		call	sub_10004840
		jmp	loc_10004712
; ---------------------------------------------------------------------------

loc_100047D7:				; CODE XREF: free+2Dj
		mov	edx, ecx
		mov	ecx, edi	; lpCriticalSection
		push	esi		; void *
		call	sub_100049E0
		add	esp, 4
		pop	edi
		pop	ebp
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_100047E9:				; CODE XREF: free+E0j free+145j
		mov	eax, esi
		xor	edx, edx
		div	ebx
		mov	esi, eax
		jmp	loc_100046D1
; ---------------------------------------------------------------------------

loc_100047F6:				; CODE XREF: free+B7j
		cmp	ebp, [esi]
		jnz	short loc_10004816
		mov	dword ptr [esi], 0

loc_10004800:				; CODE XREF: free+1C9j	free+1E7j
		push	1
		mov	edx, ebp
		mov	ecx, edi
		call	sub_10004A40
		add	esp, 4
		dec	dword ptr [esi+44h]
		jmp	loc_10004712
; ---------------------------------------------------------------------------

loc_10004816:				; CODE XREF: free+1A8j
		cmp	ecx, 1
		jz	short loc_10004800
		mov	ecx, [esp+14h+var_4]
		mov	eax, ebp
		sub	eax, ecx
		shr	eax, 0Ch
		lea	edx, [eax+2]
		lea	edx, [eax+edx*2]
		lea	edx, [ecx+edx*4]
		lea	ecx, [esi+4]
		call	sub_10003640
		jmp	short loc_10004800
free		endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame fpd=0Ch

sub_10004840	proc near		; CODE XREF: realloc+39Dp realloc+5B6p ...

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8

		sub	esp, 14h
		push	ebx
		push	ebp
		mov	eax, ecx
		lea	ebp, [esp+10h]
		push	esi
		mov	[esp+20h+var_10], eax
		mov	ebx, edx
		push	edi
		lea	edi, [eax+4]
		xor	esi, esi
		mov	eax, [eax]
		mov	edx, edi
		mov	[esp+24h+var_C], eax
		mov	eax, edi
		and	eax, 0FFFFFFFEh
		mov	[esp+24h+var_14], edx
		mov	[esp+24h+var_8], eax
		mov	eax, ecx
		mov	eax, [eax]
		cmp	eax, edi
		jz	short loc_1000489B

loc_10004875:				; CODE XREF: sub_10004840+59j
		mov	edx, [eax]
		test	byte ptr [edx+4], 1
		jnz	short loc_100048C0

loc_1000487D:				; CODE XREF: sub_10004840+86j
					; sub_10004840+AFj
		cmp	eax, ebx
		mov	edx, ebp
		mov	[esp+24h+var_14], edx
		mov	ebp, eax
		sbb	esi, esi
		neg	esi
		cmp	ebx, eax
		sbb	ecx, ecx
		neg	ecx
		sub	esi, ecx
		jns	short loc_100048F1
		mov	eax, [eax]

loc_10004897:				; CODE XREF: sub_10004840+B7j
					; sub_10004840+17Aj ...
		cmp	eax, edi
		jnz	short loc_10004875

loc_1000489B:				; CODE XREF: sub_10004840+33j
		mov	[ebx], edi
		or	edi, 1
		mov	[ebx+4], edi
		test	esi, esi
		jg	short loc_100048F9
		mov	[ebp+0Ch+var_C], ebx

loc_100048AA:				; CODE XREF: sub_10004840+10Aj
		mov	eax, [esp+24h+var_C]
		mov	ecx, [esp+24h+var_10]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], eax
		and	dword ptr [eax+4], 0FFFFFFFEh
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_100048C0:				; CODE XREF: sub_10004840+3Bj
		mov	ecx, [edx]
		test	byte ptr [ecx+4], 1
		jz	short loc_1000487D
		mov	ecx, [edx+4]
		and	ecx, 0FFFFFFFEh
		mov	[eax], ecx
		mov	ecx, [edx+4]
		and	ecx, 1
		or	ecx, eax
		mov	[edx+4], ecx
		mov	ecx, [edx]
		and	dword ptr [ecx+4], 0FFFFFFFEh
		cmp	[ebp+0Ch+var_C], eax
		jnz	loc_1000496E
		mov	[ebp+0Ch+var_C], edx
		mov	eax, edx
		jmp	short loc_1000487D
; ---------------------------------------------------------------------------

loc_100048F1:				; CODE XREF: sub_10004840+53j
		mov	eax, [eax+4]
		and	eax, 0FFFFFFFEh
		jmp	short loc_10004897
; ---------------------------------------------------------------------------

loc_100048F9:				; CODE XREF: sub_10004840+65j
		mov	ecx, [ebp+0Ch+var_8]
		and	ecx, 1
		or	ecx, ebx
		mov	[ebp+0Ch+var_8], ecx
		and	ecx, 0FFFFFFFEh
		mov	eax, [ebp+0Ch+var_8]
		and	eax, 1
		or	eax, [ecx]
		mov	[ebp+0Ch+var_8], eax
		mov	eax, [ecx+4]
		mov	[ecx], ebp
		xor	eax, [ebp+0Ch+var_8]
		and	eax, 1
		xor	[ecx+4], eax
		or	[ebp+0Ch+var_8], 1
		cmp	[edx], ebp
		jnz	short loc_10004940
		mov	[edx], ecx
		mov	eax, [esp+24h+var_C]
		mov	ecx, [esp+24h+var_10]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], eax
		and	dword ptr [eax+4], 0FFFFFFFEh
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_10004940:				; CODE XREF: sub_10004840+E6j
		mov	esi, [edx+4]
		mov	eax, esi
		and	eax, 0FFFFFFFEh
		cmp	eax, ebp
		jnz	loc_100048AA
		and	esi, 1
		or	esi, ecx
		mov	ecx, [esp+24h+var_10]
		mov	[edx+4], esi
		mov	eax, [esp+24h+var_C]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], eax
		and	dword ptr [eax+4], 0FFFFFFFEh
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_1000496E:				; CODE XREF: sub_10004840+A4j
		mov	eax, [ebp+0Ch+var_8]
		and	eax, 1
		or	eax, edx
		mov	edx, [esp+24h+var_14]
		mov	[ebp+0Ch+var_8], eax
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, 1
		or	eax, [ecx]
		mov	[ebp+0Ch+var_8], eax
		mov	eax, [ecx+4]
		mov	[ecx], ebp
		xor	eax, [ebp+0Ch+var_8]
		and	eax, 1
		xor	[ecx+4], eax
		or	[ebp+0Ch+var_8], 1
		cmp	[edx], ebp
		jnz	short loc_100049C6
		mov	[edx], ecx

loc_100049A2:				; CODE XREF: sub_10004840+191j
		cmp	ecx, ebx
		mov	ebp, ecx
		sbb	esi, esi
		neg	esi
		cmp	ebx, ecx
		sbb	eax, eax
		neg	eax
		sub	esi, eax
		js	short loc_100049BF
		mov	eax, [ecx+4]
		and	eax, 0FFFFFFFEh
		jmp	loc_10004897
; ---------------------------------------------------------------------------

loc_100049BF:				; CODE XREF: sub_10004840+172j
		mov	eax, [ecx]
		jmp	loc_10004897
; ---------------------------------------------------------------------------

loc_100049C6:				; CODE XREF: sub_10004840+15Ej
		mov	eax, [edx+4]
		and	eax, 1
		or	eax, ecx
		mov	[edx+4], eax
		jmp	short loc_100049A2
sub_10004840	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


; int __usercall sub_100049E0@<eax>(LPCRITICAL_SECTION lpCriticalSection@<ecx>,	void *)
sub_100049E0	proc near		; CODE XREF: moz_xrealloc+3D7p
					; realloc+594p	...

arg_0		= dword	ptr  4

		push	ebx
		push	esi
		push	edi
		mov	ebx, ecx
		mov	esi, edx
		push	ebx		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	edi, [esp+0Ch+arg_0]
		mov	eax, edi
		sub	eax, esi
		shr	eax, 0Ch
		add	eax, 2
		lea	eax, [eax+eax*2]
		mov	esi, [esi+eax*4]
		and	esi, 0FFFFF000h
		push	esi		; size_t
		push	0E5h		; int
		push	edi		; void *
		call	memset
		sub	[ebx+68h], esi
		mov	edx, edi
		add	dword ptr [ebx+78h], 1
		mov	ecx, ebx
		push	1
		adc	dword ptr [ebx+7Ch], 0
		call	sub_10004A40
		add	esp, 10h
		push	ebx		; lpCriticalSection
		call	ds:LeaveCriticalSection
		pop	edi
		pop	esi
		pop	ebx
		retn
sub_100049E0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


sub_10004A40	proc near		; CODE XREF: realloc+5E7p
					; sub_10002410+16Ep ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000C509 SIZE 00000061 BYTES

		sub	esp, 8
		push	ebx
		push	ebp
		mov	ebp, edx
		mov	[esp+10h+var_8], ecx
		push	esi
		push	edi
		mov	esi, ebp
		mov	edi, ebp
		and	esi, 0FFF00000h
		sub	edi, esi
		shr	edi, 0Ch
		lea	eax, [edi+2]
		lea	eax, [eax+eax*2]
		mov	ebx, [esi+eax*4]
		lea	edx, [esi+eax*4]
		mov	[esp+18h+var_4], edx
		test	bl, 2
		jz	loc_10004BAA
		and	ebx, 0FFFFF000h

loc_10004A7B:				; CODE XREF: sub_10004A40+170j
		mov	ebp, ebx
		shr	ebp, 0Ch
		cmp	[esp+18h+arg_0], 0
		jz	loc_1000C509
		test	ebp, ebp
		jz	short loc_10004AA3
		mov	eax, edx
		mov	ecx, ebp

loc_10004A93:				; CODE XREF: sub_10004A40+5Dj
		mov	dword ptr [eax], 8
		lea	eax, [eax+0Ch]
		dec	ecx
		jnz	short loc_10004A93
		mov	ecx, [esp+18h+var_8]

loc_10004AA3:				; CODE XREF: sub_10004A40+4Dj
		cmp	dword ptr [esi+0Ch], 0
		jz	loc_10004B93

loc_10004AAD:				; CODE XREF: sub_10004A40+165j
		add	[esi+0Ch], ebp
		add	[ecx+0A4h], ebp

loc_10004AB6:				; CODE XREF: sub_10004A40+7ACBj
					; sub_10004A40+7AE3j
		mov	eax, [edx]
		and	eax, 0FFFh
		or	eax, ebx
		mov	[edx], eax
		lea	edx, [edi+ebp]
		lea	eax, [edx+edx*2]
		lea	ebp, [esi+eax*4]
		mov	eax, [ebp+0Ch]
		and	eax, 0FFFh
		or	eax, ebx
		mov	[ebp+0Ch], eax
		cmp	edx, 100h
		jnb	short loc_10004AEA
		lea	eax, [edx+edx*2]
		mov	eax, [esi+eax*4+18h]
		test	al, 1
		jz	short loc_10004B45

loc_10004AEA:				; CODE XREF: sub_10004A40+9Dj
					; sub_10004A40+14Ej
		cmp	edi, 1
		jbe	short loc_10004AFE
		lea	eax, [edi+edi*2]
		mov	eax, [esi+eax*4+0Ch]
		test	al, 1
		jz	loc_10004BB5

loc_10004AFE:				; CODE XREF: sub_10004A40+ADj
					; sub_10004A40+1CEj
		lea	eax, [edi+2]
		lea	ebx, [ecx+0A8h]
		lea	eax, [edi+eax*2]
		mov	ecx, ebx
		lea	edx, [esi+eax*4]
		call	sub_10004C50
		mov	eax, [esi+24h]
		mov	edi, [esp+18h+var_8]
		and	eax, 0FFFFF001h
		cmp	eax, 0FF000h
		jz	loc_10004C13

loc_10004B2B:				; CODE XREF: sub_10004A40+1F1j
		mov	eax, [edi+0A4h]
		cmp	eax, dword_1001A49C
		ja	loc_10004C36
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_10004B45:				; CODE XREF: sub_10004A40+A8j
		and	eax, 0FFFFF000h
		lea	edx, [ebp+10h]
		add	ecx, 0A8h
		mov	[esp+18h+arg_0], eax
		call	sub_10003FB0
		mov	edx, [esp+18h+var_4]
		add	ebx, [esp+18h+arg_0]
		mov	ecx, ebx
		shr	ecx, 0Ch
		mov	eax, [edx]
		and	eax, 0FFFh
		or	eax, ebx
		mov	[edx], eax
		lea	eax, [edi+1]
		add	eax, ecx
		lea	eax, [eax+eax*2]
		lea	ecx, [esi+eax*4]
		mov	eax, [ecx]
		and	eax, 0FFFh
		or	eax, ebx
		mov	[ecx], eax
		mov	ecx, [esp+18h+var_8]
		jmp	loc_10004AEA
; ---------------------------------------------------------------------------

loc_10004B93:				; CODE XREF: sub_10004A40+67j
		sub	ecx, 0FFFFFF80h
		mov	edx, esi
		call	sub_10004E40
		mov	ecx, [esp+18h+var_8]
		mov	edx, [esp+18h+var_4]
		jmp	loc_10004AAD
; ---------------------------------------------------------------------------

loc_10004BAA:				; CODE XREF: sub_10004A40+2Fj
		mov	eax, [ebp+0]
		mov	ebx, [eax+18h]
		jmp	loc_10004A7B
; ---------------------------------------------------------------------------

loc_10004BB5:				; CODE XREF: sub_10004A40+B8j
		and	eax, 0FFFFF000h
		add	ecx, 0A8h
		mov	[esp+18h+arg_0], eax
		shr	eax, 0Ch
		sub	edi, eax
		lea	eax, [edi+2]
		lea	eax, [edi+eax*2]
		lea	edx, [esi+eax*4]
		call	sub_10003FB0
		add	ebx, [esp+18h+arg_0]
		lea	eax, [edi+2]
		lea	eax, [eax+eax*2]
		mov	edx, ebx
		lea	ecx, [esi+eax*4]
		shr	edx, 0Ch
		mov	eax, [ecx]
		and	eax, 0FFFh
		or	eax, ebx
		mov	[ecx], eax
		lea	eax, [edi+1]
		add	eax, edx
		lea	eax, [eax+eax*2]
		lea	ecx, [esi+eax*4]
		mov	eax, [ecx]
		and	eax, 0FFFh
		or	eax, ebx
		mov	[ecx], eax
		mov	ecx, [esp+18h+var_8]
		jmp	loc_10004AFE
; ---------------------------------------------------------------------------

loc_10004C13:				; CODE XREF: sub_10004A40+E5j
		mov	ebp, [edi+0A0h]
		test	ebp, ebp
		jnz	loc_1000C528

loc_10004C21:				; CODE XREF: sub_10004A40+7B25j
		lea	edx, [esi+1Ch]
		mov	ecx, ebx
		call	sub_10003FB0
		mov	[edi+0A0h], esi
		jmp	loc_10004B2B
; ---------------------------------------------------------------------------

loc_10004C36:				; CODE XREF: sub_10004A40+F7j
		mov	ecx, edi
		xor	edx, edx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 8
		jmp	sub_10005710
sub_10004A40	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame fpd=0Ch

sub_10004C50	proc near		; CODE XREF: sub_100029D0+FDp
					; sub_10003C40+129p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8

		sub	esp, 18h
		push	ebx
		push	ebp
		mov	ebx, edx
		lea	ebp, [esp+14h]
		mov	edx, ecx
		push	esi
		push	edi
		xor	esi, esi
		mov	[esp+28h+var_10], edx
		mov	eax, [edx]
		lea	edi, [edx+4]
		mov	[esp+28h+var_C], eax
		mov	eax, edi
		and	eax, 0FFFFFFFEh
		mov	[esp+28h+var_18], edi
		mov	[esp+28h+var_8], eax
		mov	eax, [edx]
		cmp	eax, edi
		jz	short loc_10004CC7

loc_10004C81:				; CODE XREF: sub_10004C50+71j
		mov	edx, [eax]
		test	byte ptr [edx+4], 1
		jnz	short loc_10004CEC

loc_10004C89:				; CODE XREF: sub_10004C50+A2j
					; sub_10004C50+C7j
		mov	edx, [ebx+8]
		mov	ecx, [eax+8]
		and	edx, 0FFFFF000h
		and	ecx, 0FFFFF000h
		mov	[esp+28h+var_18], ebp
		cmp	ecx, edx
		mov	ebp, eax
		sbb	esi, esi
		neg	esi
		cmp	edx, ecx
		sbb	ecx, ecx
		neg	ecx
		sub	esi, ecx
		jz	loc_10004D7D

loc_10004CB5:				; CODE XREF: sub_10004C50+147j
					; sub_10004C50+1A0j
		test	esi, esi
		jns	loc_10004D72

loc_10004CBD:				; CODE XREF: sub_10004C50+11Cj
		mov	eax, [eax]

loc_10004CBF:				; CODE XREF: sub_10004C50+128j
		cmp	eax, edi
		jnz	short loc_10004C81
		mov	edx, [esp+28h+var_10]

loc_10004CC7:				; CODE XREF: sub_10004C50+2Fj
		mov	[ebx], edi
		or	edi, 1
		mov	[ebx+4], edi
		test	esi, esi
		jg	loc_10004D9C
		mov	[ebp+0Ch+var_C], ebx

loc_10004CDA:				; CODE XREF: sub_10004C50+1AFj
		mov	eax, [esp+28h+var_C]
		pop	edi
		pop	esi
		pop	ebp
		mov	[edx], eax
		and	dword ptr [eax+4], 0FFFFFFFEh
		pop	ebx
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_10004CEC:				; CODE XREF: sub_10004C50+37j
		mov	ecx, [edx]
		test	byte ptr [ecx+4], 1
		jz	short loc_10004C89
		mov	ecx, [edx+4]
		and	ecx, 0FFFFFFFEh
		mov	[eax], ecx
		mov	ecx, [edx+4]
		and	ecx, 1
		or	ecx, eax
		mov	[edx+4], ecx
		mov	ecx, [edx]
		and	dword ptr [ecx+4], 0FFFFFFFEh
		cmp	[ebp+0Ch+var_C], eax
		jnz	short loc_10004D1C
		mov	[ebp+0Ch+var_C], edx
		mov	eax, edx
		jmp	loc_10004C89
; ---------------------------------------------------------------------------

loc_10004D1C:				; CODE XREF: sub_10004C50+C0j
		mov	eax, [ebp+0Ch+var_8]
		mov	ecx, [esp+28h+var_18]
		and	eax, 1
		or	eax, edx
		mov	[ebp+0Ch+var_8], eax
		mov	edx, eax
		and	edx, 0FFFFFFFEh
		and	eax, 1
		mov	[esp+28h+var_14], edx
		or	eax, [edx]
		mov	[ebp+0Ch+var_8], eax
		mov	eax, [edx+4]
		mov	[edx], ebp
		xor	eax, [ebp+0Ch+var_8]
		and	eax, 1
		xor	[edx+4], eax
		or	[ebp+0Ch+var_8], 1
		cmp	[ecx], ebp
		jnz	loc_10004E1F
		mov	[ecx], edx

loc_10004D58:				; CODE XREF: sub_10004C50+1DAj
		push	edx
		push	ebx
		mov	ebp, edx
		call	sub_10005652
		mov	esi, eax
		add	esp, 8
		mov	eax, [esp+28h+var_14]
		test	esi, esi
		js	loc_10004CBD

loc_10004D72:				; CODE XREF: sub_10004C50+67j
		mov	eax, [eax+4]
		and	eax, 0FFFFFFFEh
		jmp	loc_10004CBF
; ---------------------------------------------------------------------------

loc_10004D7D:				; CODE XREF: sub_10004C50+5Fj
		test	byte ptr [ebx+8], 10h
		jnz	loc_10004E2F
		mov	ecx, ebx
		cmp	ebx, eax
		ja	short loc_10004DE3

loc_10004D8D:				; CODE XREF: sub_10004C50+1E1j
		xor	esi, esi
		cmp	ecx, eax
		sbb	ecx, ecx
		neg	ecx
		sub	esi, ecx
		jmp	loc_10004CB5
; ---------------------------------------------------------------------------

loc_10004D9C:				; CODE XREF: sub_10004C50+81j
		mov	ecx, [ebp+0Ch+var_8]
		and	ecx, 1
		or	ecx, ebx
		mov	ebx, [esp+28h+var_18]
		mov	[ebp+0Ch+var_8], ecx
		and	ecx, 0FFFFFFFEh
		mov	eax, [ebp+0Ch+var_8]
		and	eax, 1
		or	eax, [ecx]
		mov	[ebp+0Ch+var_8], eax
		mov	eax, [ecx+4]
		mov	[ecx], ebp
		xor	eax, [ebp+0Ch+var_8]
		and	eax, 1
		xor	[ecx+4], eax
		or	[ebp+0Ch+var_8], 1
		cmp	[ebx], ebp
		jnz	short loc_10004DF5
		mov	[ebx], ecx
		mov	eax, [esp+28h+var_C]
		pop	edi
		pop	esi
		pop	ebp
		mov	[edx], eax
		and	dword ptr [eax+4], 0FFFFFFFEh
		pop	ebx
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_10004DE3:				; CODE XREF: sub_10004C50+13Bj
		cmp	ecx, eax
		mov	esi, 1
		sbb	ecx, ecx
		neg	ecx
		sub	esi, ecx
		jmp	loc_10004CB5
; ---------------------------------------------------------------------------

loc_10004DF5:				; CODE XREF: sub_10004C50+17Dj
		mov	esi, [ebx+4]
		mov	eax, esi
		and	eax, 0FFFFFFFEh
		cmp	eax, ebp
		jnz	loc_10004CDA
		and	esi, 1
		or	esi, ecx
		mov	[ebx+4], esi
		mov	eax, [esp+28h+var_C]
		pop	edi
		pop	esi
		pop	ebp
		mov	[edx], eax
		and	dword ptr [eax+4], 0FFFFFFFEh
		pop	ebx
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_10004E1F:				; CODE XREF: sub_10004C50+100j
		mov	eax, [ecx+4]
		and	eax, 1
		or	eax, edx
		mov	[ecx+4], eax
		jmp	loc_10004D58
; ---------------------------------------------------------------------------

loc_10004E2F:				; CODE XREF: sub_10004C50+131j
		xor	ecx, ecx
		jmp	loc_10004D8D
sub_10004C50	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame fpd=20h

sub_10004E40	proc near		; CODE XREF: sub_10004A40+158p

var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_4		= dword	ptr -4

		sub	esp, 2Ch
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+2Ch+var_4], eax
		push	ebx
		mov	eax, ecx
		mov	ebx, edx
		push	ebp
		push	esi
		mov	[esp+38h+var_24], eax
		lea	ebp, [esp+18h]
		push	edi
		lea	edi, [eax+4]
		xor	esi, esi
		mov	eax, [eax]
		mov	ecx, edi
		mov	[esp+3Ch+var_1C], eax
		mov	eax, edi
		and	eax, 0FFFFFFFEh
		mov	[esp+3Ch+var_2C], ecx
		mov	[esp+3Ch+var_18], eax
		mov	eax, [esp+3Ch+var_24]
		mov	eax, [eax]
		cmp	eax, edi
		jz	short loc_10004EB0

loc_10004E82:				; CODE XREF: sub_10004E40+6Aj
		mov	edx, [eax+4]
		test	byte ptr [edx+8], 1
		jnz	short loc_10004EE5

loc_10004E8B:				; CODE XREF: sub_10004E40+ACj
					; sub_10004E40+D3j
		cmp	eax, ebx
		mov	[esp+3Ch+var_2C], ebp
		mov	ebp, eax
		sbb	esi, esi
		neg	esi
		cmp	ebx, eax
		sbb	ecx, ecx
		neg	ecx
		sub	esi, ecx
		jns	loc_10004F6E

loc_10004EA5:				; CODE XREF: sub_10004E40+128j
		mov	eax, [eax+4]

loc_10004EA8:				; CODE XREF: sub_10004E40+134j
		cmp	eax, edi
		jnz	short loc_10004E82
		mov	ecx, [esp+3Ch+var_2C]

loc_10004EB0:				; CODE XREF: sub_10004E40+40j
		mov	[ebx+4], edi
		or	edi, 1
		mov	[ebx+8], edi
		test	esi, esi
		jg	loc_10004F79
		mov	[ebp+20h+var_1C], ebx

loc_10004EC4:				; CODE XREF: sub_10004E40+16Ej
					; sub_10004E40+17Dj ...
		mov	ecx, [esp+3Ch+var_24]
		mov	eax, [esp+3Ch+var_1C]
		pop	edi
		pop	esi
		mov	[ecx], eax
		mov	ecx, [esp+34h+var_4]
		and	dword ptr [eax+8], 0FFFFFFFEh
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 2Ch
		retn
; ---------------------------------------------------------------------------

loc_10004EE5:				; CODE XREF: sub_10004E40+49j
		mov	ecx, [edx+4]
		test	byte ptr [ecx+8], 1
		jz	short loc_10004E8B
		mov	ecx, [edx+8]
		and	ecx, 0FFFFFFFEh
		mov	[eax+4], ecx
		mov	ecx, [edx+8]
		and	ecx, 1
		or	ecx, eax
		mov	[edx+8], ecx
		mov	ecx, [edx+4]
		and	dword ptr [ecx+8], 0FFFFFFFEh
		cmp	[ebp+20h+var_1C], eax
		jnz	short loc_10004F18
		mov	[ebp+20h+var_1C], edx
		mov	eax, edx
		jmp	loc_10004E8B
; ---------------------------------------------------------------------------

loc_10004F18:				; CODE XREF: sub_10004E40+CCj
		mov	eax, [ebp+20h+var_18]
		mov	ecx, [esp+3Ch+var_2C]
		and	eax, 1
		or	eax, edx
		mov	[ebp+20h+var_18], eax
		mov	edx, eax
		and	edx, 0FFFFFFFEh
		and	eax, 1
		mov	[esp+3Ch+var_28], edx
		or	eax, [edx+4]
		mov	[ebp+20h+var_18], eax
		mov	eax, [edx+8]
		mov	[edx+4], ebp
		xor	eax, [ebp+20h+var_18]
		and	eax, 1
		xor	[edx+8], eax
		or	[ebp+20h+var_18], 1
		cmp	[ecx+4], ebp
		jnz	short loc_10004FD0
		mov	[ecx+4], edx

loc_10004F54:				; CODE XREF: sub_10004E40+19Bj
		push	edx
		push	ebx
		mov	ebp, edx
		call	sub_100056F2
		mov	esi, eax
		add	esp, 8
		mov	eax, [esp+3Ch+var_28]
		test	esi, esi
		js	loc_10004EA5

loc_10004F6E:				; CODE XREF: sub_10004E40+5Fj
		mov	eax, [eax+8]
		and	eax, 0FFFFFFFEh
		jmp	loc_10004EA8
; ---------------------------------------------------------------------------

loc_10004F79:				; CODE XREF: sub_10004E40+7Bj
		mov	edx, [ebp+20h+var_18]
		and	edx, 1
		or	edx, ebx
		mov	[ebp+20h+var_18], edx
		and	edx, 0FFFFFFFEh
		mov	eax, [ebp+20h+var_18]
		and	eax, 1
		or	eax, [edx+4]
		mov	[ebp+20h+var_18], eax
		mov	eax, [edx+8]
		mov	[edx+4], ebp
		xor	eax, [ebp+20h+var_18]
		and	eax, 1
		xor	[edx+8], eax
		or	[ebp+20h+var_18], 1
		cmp	[ecx+4], ebp
		jnz	short loc_10004FB3
		mov	[ecx+4], edx
		jmp	loc_10004EC4
; ---------------------------------------------------------------------------

loc_10004FB3:				; CODE XREF: sub_10004E40+169j
		mov	esi, [ecx+8]
		mov	eax, esi
		and	eax, 0FFFFFFFEh
		cmp	eax, ebp
		jnz	loc_10004EC4
		and	esi, 1
		or	esi, edx
		mov	[ecx+8], esi
		jmp	loc_10004EC4
; ---------------------------------------------------------------------------

loc_10004FD0:				; CODE XREF: sub_10004E40+10Fj
		mov	eax, [ecx+8]
		and	eax, 1
		or	eax, edx
		mov	[ecx+8], eax
		jmp	loc_10004F54
sub_10004E40	endp


; =============== S U B	R O U T	I N E =======================================


sub_10004FE0	proc near		; CODE XREF: sub_10003DC0+18Bj
					; sub_10005710+8Dp ...

var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= byte ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_4		= dword	ptr -4

; FUNCTION CHUNK AT 1000C56A SIZE 0000006C BYTES

		sub	esp, 30h
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+30h+var_4], eax
		push	ebx
		push	ebp
		push	esi
		mov	esi, edx
		mov	edx, ecx
		push	edi
		mov	[esp+40h+var_2C], edx
		mov	ebx, [edx]
		lea	edi, [edx+4]
		mov	eax, edi
		mov	[esp+40h+var_1C], ebx
		and	eax, 0FFFFFFFEh
		mov	[esp+40h+var_28], edi
		mov	[esp+40h+var_18], eax
		lea	eax, [esp+40h+var_20]
		mov	[esp+40h+var_30], eax
		mov	eax, ebx
		cmp	esi, eax
		ja	loc_1000528A
		xor	ebp, ebp

loc_10005024:				; CODE XREF: sub_10004FE0+2AFj
		cmp	esi, eax
		sbb	ecx, ecx
		neg	ecx
		sub	ebp, ecx
		jns	loc_100051F7
		mov	edx, [eax+4]
		test	byte ptr [edx+8], 1
		jnz	short loc_10005048
		mov	ecx, [edx+4]
		test	byte ptr [ecx+8], 1
		jz	loc_100051B8

loc_10005048:				; CODE XREF: sub_10004FE0+59j
		mov	[esp+40h+var_30], ebx
		mov	eax, edx

loc_1000504E:				; CODE XREF: sub_10004FE0+212j
					; sub_10004FE0+511j ...
		mov	edx, [esp+40h+var_2C]

loc_10005052:				; CODE XREF: sub_10004FE0+222j
		test	ebp, ebp
		jz	loc_1000564B
		mov	ebx, [esp+40h+var_30]
		mov	edi, edi

loc_10005060:				; CODE XREF: sub_10004FE0+A9j
					; sub_10004FE0+14Ej ...
		cmp	eax, esi
		sbb	edx, edx
		neg	edx
		cmp	esi, eax
		sbb	ecx, ecx
		neg	ecx
		sub	edx, ecx
		jns	short loc_1000508B
		mov	edx, [eax+4]
		cmp	edx, edi
		jz	loc_1000536C
		test	byte ptr [edx+8], 1
		jz	loc_10005133

loc_10005085:				; CODE XREF: sub_10004FE0+102j
					; sub_10004FE0+15Aj ...
		mov	ebx, eax
		mov	eax, edx
		jmp	short loc_10005060
; ---------------------------------------------------------------------------

loc_1000508B:				; CODE XREF: sub_10004FE0+8Ej
		test	edx, edx
		jnz	short loc_100050D3
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFFEh
		cmp	ecx, edi
		jnz	short loc_100050CF
		mov	esi, [eax+4]
		cmp	esi, edi
		jnz	loc_10005183
		mov	esi, edi

loc_100050A6:				; CODE XREF: sub_10004FE0+1D3j
		mov	ecx, [esp+40h+var_2C]
		cmp	[ebx+4], eax
		jnz	loc_10005266
		mov	[ebx+4], esi
		mov	eax, [esp+40h+var_1C]
		mov	[ecx], eax

loc_100050BC:				; CODE XREF: sub_10004FE0+66Dj
					; sub_10004FE0+75F1j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_100050CF:				; CODE XREF: sub_10004FE0+B7j
		mov	[esp+40h+var_28], ebx

loc_100050D3:				; CODE XREF: sub_10004FE0+ADj
		mov	ebp, [eax+8]
		mov	edx, ebp
		and	edx, 0FFFFFFFEh
		mov	ecx, [edx+4]
		test	byte ptr [ecx+8], 1
		jnz	short loc_10005085
		mov	ecx, [eax+4]
		mov	[esp+40h+var_30], ecx
		mov	edx, [ecx+8]
		test	dl, 1
		jnz	loc_100052C0
		or	edx, 1
		mov	[ecx+8], edx
		mov	edx, [ecx+4]
		mov	ecx, [edx+8]
		test	cl, 1
		jnz	loc_100053C7
		mov	ecx, [eax+8]
		mov	ebp, ecx
		and	ebp, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [ebp+4]
		mov	[eax+8], ecx
		mov	[ebp+4], eax

loc_10005120:				; CODE XREF: sub_10004FE0+33Ej
					; sub_10004FE0+423j
		cmp	[ebx+4], eax
		jnz	loc_10005408
		mov	[ebx+4], ebp
		mov	eax, ebp
		jmp	loc_10005060
; ---------------------------------------------------------------------------

loc_10005133:				; CODE XREF: sub_10004FE0+9Fj
		mov	ecx, [edx+4]
		test	byte ptr [ecx+8], 1
		jnz	loc_10005085
		or	dword ptr [edx+8], 1
		mov	ecx, [eax+8]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		mov	ebp, [edx+4]
		test	byte ptr [ebp+8], 1
		jnz	loc_10005418
		or	ecx, 1
		mov	ebp, ecx
		mov	[eax+8], ecx
		and	ebp, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [ebp+4]
		mov	[eax+8], ecx
		mov	[ebp+4], eax

loc_10005170:				; CODE XREF: sub_10004FE0+47Dj
					; sub_10004FE0+5F7j
		cmp	[ebx+4], eax
		jnz	loc_10005408
		mov	[ebx+4], ebp

loc_1000517C:				; CODE XREF: sub_10004FE0+433j
		mov	eax, ebp
		jmp	loc_10005060
; ---------------------------------------------------------------------------

loc_10005183:				; CODE XREF: sub_10004FE0+BEj
		mov	ecx, [esi+8]
		and	ecx, 0FFFFFFFEh
		mov	[eax+4], ecx
		mov	edx, [esi+8]
		and	edx, 1
		or	edx, eax
		mov	[esi+8], edx
		mov	ecx, [eax+8]
		xor	ecx, edx
		and	ecx, 1
		xor	ecx, edx
		mov	[esi+8], ecx
		or	dword ptr [eax+8], 1
		mov	ecx, [esi+8]
		and	ecx, 1
		or	ecx, edi
		mov	[esi+8], ecx
		jmp	loc_100050A6
; ---------------------------------------------------------------------------

loc_100051B8:				; CODE XREF: sub_10004FE0+62j
		or	dword ptr [edx+8], 1
		mov	ecx, [eax+8]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		mov	ebx, [edx+4]
		test	byte ptr [ebx+8], 1
		jnz	loc_100054A2
		or	ecx, 1
		mov	ebx, ecx
		mov	[eax+8], ecx
		and	ebx, 0FFFFFFFEh
		and	ecx, 1
		mov	[esp+40h+var_1C], ebx
		or	ecx, [ebx+4]
		mov	[eax+8], ecx
		mov	[ebx+4], eax
		mov	eax, ebx
		and	dword ptr [ebx+8], 0FFFFFFFEh
		jmp	loc_1000504E
; ---------------------------------------------------------------------------

loc_100051F7:				; CODE XREF: sub_10004FE0+4Cj
		test	ebp, ebp
		jz	loc_10005294
		cmp	ebp, 1
		jnz	loc_10005052

loc_10005208:				; CODE XREF: sub_10004FE0+4BDj
		mov	ebx, [eax+8]
		mov	edx, ebx
		and	edx, 0FFFFFFFEh
		mov	ecx, [edx+4]
		test	byte ptr [ecx+8], 1
		jnz	loc_10005085
		mov	edx, [eax+4]
		test	byte ptr [edx+8], 1
		jnz	loc_10005541
		or	ebx, 1
		mov	[eax+8], ebx
		mov	ebx, [edx+4]
		mov	ecx, [ebx+8]
		test	cl, 1
		jnz	loc_100054F6
		or	dword ptr [edx+8], 1

loc_10005243:				; CODE XREF: sub_10004FE0+7599j
		mov	ecx, [eax+8]
		mov	ebx, ecx
		and	ebx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [ebx+4]
		mov	[eax+8], ecx
		mov	[ebx+4], eax

loc_10005257:				; CODE XREF: sub_10004FE0+75DBj
		mov	[esp+40h+var_1C], ebx
		mov	eax, ebx
		lea	ebx, [esp+40h+var_20]
		jmp	loc_10005060
; ---------------------------------------------------------------------------

loc_10005266:				; CODE XREF: sub_10004FE0+CDj
		mov	eax, [ebx+8]
		and	eax, 1
		pop	edi
		or	eax, esi
		pop	esi
		mov	[ebx+8], eax
		mov	eax, [esp+38h+var_1C]
		pop	ebp
		mov	[ecx], eax
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_1000528A:				; CODE XREF: sub_10004FE0+3Cj
		mov	ebp, 1
		jmp	loc_10005024
; ---------------------------------------------------------------------------

loc_10005294:				; CODE XREF: sub_10004FE0+219j
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFFEh
		cmp	ecx, edi
		jnz	loc_10005495
		mov	esi, [eax+4]
		cmp	esi, edi
		jnz	short loc_10005323
		mov	esi, edi
		pop	edi
		mov	[edx], esi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_100052C0:				; CODE XREF: sub_10004FE0+111j
		and	edx, 0FFFFFFFEh
		mov	ecx, [edx+4]
		mov	[esp+40h+var_24], ecx
		test	byte ptr [ecx+8], 1
		mov	ecx, [esp+40h+var_30]
		jnz	loc_10005462
		and	ebp, 1
		or	ebp, edx
		mov	[ecx+8], ebp
		or	dword ptr [edx+8], 1
		mov	ebp, [eax+4]

loc_100052E7:				; CODE XREF: sub_10004FE0+4B0j
		mov	ecx, [ebp+8]
		and	ecx, 0FFFFFFFEh
		mov	[eax+4], ecx
		mov	ecx, [ebp+8]
		and	ecx, 1
		or	ecx, eax
		mov	[ebp+8], ecx
		mov	ecx, [eax+8]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx+4]
		mov	[eax+8], ecx
		mov	[edx+4], eax
		mov	ecx, [ebp+8]
		and	ecx, 1
		or	ecx, edx
		mov	[ebp+8], ecx
		or	dword ptr [eax+8], 1
		jmp	loc_10005120
; ---------------------------------------------------------------------------

loc_10005323:				; CODE XREF: sub_10004FE0+2C7j
		mov	ecx, [esi+8]
		and	ecx, 0FFFFFFFEh
		mov	[eax+4], ecx
		mov	edx, [esi+8]
		and	edx, 1
		or	edx, eax
		mov	[esi+8], edx
		mov	ecx, [eax+8]
		xor	ecx, edx
		and	ecx, 1
		xor	ecx, edx
		mov	edx, [esp+40h+var_2C]
		mov	[esi+8], ecx
		or	dword ptr [eax+8], 1
		mov	eax, [esi+8]
		and	eax, 1
		or	eax, edi
		pop	edi
		mov	[esi+8], eax
		mov	[edx], esi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_1000536C:				; CODE XREF: sub_10004FE0+95j
		mov	edx, [esp+40h+var_28]
		cmp	[edx+4], esi
		jnz	loc_100055DC
		mov	[edx+4], eax

loc_1000537C:				; CODE XREF: sub_10004FE0+607j
		mov	ecx, [esi+4]
		mov	[eax+4], ecx
		mov	edx, [esi+8]
		xor	edx, [eax+8]
		and	edx, 1
		xor	edx, [esi+8]
		mov	[eax+8], edx
		mov	ecx, [esi+8]
		xor	ecx, edx
		and	ecx, 1
		xor	ecx, edx
		mov	[eax+8], ecx
		mov	ecx, [esp+40h+var_2C]
		cmp	[ebx+4], eax
		jnz	loc_1000C5C0
		mov	[ebx+4], edi
		mov	eax, [esp+40h+var_1C]
		pop	edi
		pop	esi
		mov	[ecx], eax
		mov	ecx, [esp+38h+var_4]
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_100053C7:				; CODE XREF: sub_10004FE0+126j
		and	ecx, 0FFFFFFFEh
		mov	[edx+8], ecx
		mov	ebp, [eax+4]
		mov	ecx, [ebp+8]
		and	ecx, 0FFFFFFFEh
		mov	[eax+4], ecx
		mov	ecx, [ebp+8]
		and	ecx, 1
		or	ecx, eax
		mov	[ebp+8], ecx
		mov	ecx, [eax+8]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx+4]
		mov	[eax+8], ecx
		mov	[edx+4], eax
		mov	ecx, [ebp+8]
		and	ecx, 1
		or	ecx, edx
		mov	[ebp+8], ecx
		jmp	loc_10005120
; ---------------------------------------------------------------------------

loc_10005408:				; CODE XREF: sub_10004FE0+143j
					; sub_10004FE0+193j
		mov	eax, [ebx+8]
		and	eax, 1
		or	eax, ebp
		mov	[ebx+8], eax
		jmp	loc_1000517C
; ---------------------------------------------------------------------------

loc_10005418:				; CODE XREF: sub_10004FE0+173j
		mov	ecx, [ebp+8]
		and	ecx, 0FFFFFFFEh
		mov	[edx+4], ecx
		mov	ecx, [ebp+8]
		and	ecx, 1
		or	ecx, edx
		mov	[ebp+8], ecx
		mov	ecx, [eax+8]
		and	ecx, 1
		or	ecx, ebp
		mov	ebp, ecx
		mov	[eax+8], ecx
		and	ebp, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [ebp+4]
		mov	[eax+8], ecx
		mov	[ebp+4], eax
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFFEh
		mov	edx, [ecx+8]
		test	dl, 1
		jnz	loc_100055B6
		mov	[eax+8], ecx
		jmp	loc_10005170
; ---------------------------------------------------------------------------

loc_10005462:				; CODE XREF: sub_10004FE0+2F2j
		mov	ecx, [edx+8]
		xor	ecx, ebp
		and	ecx, 1
		xor	[edx+8], ecx
		mov	ecx, [esp+40h+var_24]
		mov	edx, [esp+40h+var_30]
		and	dword ptr [ecx+8], 0FFFFFFFEh
		mov	ecx, [edx+8]
		mov	ebp, ecx
		and	ebp, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [ebp+4]
		mov	[edx+8], ecx
		mov	[ebp+4], edx
		mov	[eax+4], ebp
		jmp	loc_100052E7
; ---------------------------------------------------------------------------

loc_10005495:				; CODE XREF: sub_10004FE0+2BCj
		lea	edx, [esp+40h+var_20]
		mov	[esp+40h+var_28], edx
		jmp	loc_10005208
; ---------------------------------------------------------------------------

loc_100054A2:				; CODE XREF: sub_10004FE0+1EBj
		mov	ecx, [ebx+8]
		and	ecx, 0FFFFFFFEh
		mov	[edx+4], ecx
		mov	ecx, [ebx+8]
		and	ecx, 1
		or	ecx, edx
		mov	[ebx+8], ecx
		mov	ecx, [eax+8]
		and	ecx, 1
		or	ecx, ebx
		mov	ebx, ecx
		mov	[eax+8], ecx
		and	ebx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [ebx+4]
		mov	[eax+8], ecx
		mov	[ebx+4], eax
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFFEh
		mov	edx, [ecx+8]
		test	dl, 1
		jnz	loc_1000561B
		mov	[eax+8], ecx
		mov	eax, ebx
		and	dword ptr [ebx+8], 0FFFFFFFEh
		mov	[esp+40h+var_1C], ebx
		jmp	loc_1000504E
; ---------------------------------------------------------------------------

loc_100054F6:				; CODE XREF: sub_10004FE0+259j
		and	ecx, 0FFFFFFFEh
		mov	[ebx+8], ecx
		mov	ebx, [eax+4]
		mov	[esp+40h+var_1C], ebx
		mov	ecx, [ebx+8]
		and	ecx, 0FFFFFFFEh
		mov	[eax+4], ecx
		mov	ecx, [ebx+8]
		and	ecx, 1
		or	ecx, eax
		mov	[ebx+8], ecx
		mov	ecx, [eax+8]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx+4]
		mov	[eax+8], ecx
		mov	[edx+4], eax
		mov	eax, [ebx+8]
		and	eax, 1
		or	eax, edx
		mov	[ebx+8], eax
		mov	eax, ebx
		lea	ebx, [esp+40h+var_20]
		jmp	loc_10005060
; ---------------------------------------------------------------------------

loc_10005541:				; CODE XREF: sub_10004FE0+244j
		mov	ecx, [edx+8]
		test	cl, 1
		jz	loc_1000C56A
		and	ecx, 0FFFFFFFEh
		mov	[esp+40h+var_30], ecx
		mov	ebp, [ecx+4]
		test	byte ptr [ebp+8], 1
		jnz	loc_100055EC
		and	ebx, 1
		or	ebx, ecx
		mov	[edx+8], ebx
		or	dword ptr [ecx+8], 1
		mov	ebx, [eax+4]

loc_10005570:				; CODE XREF: sub_10004FE0+636j
		mov	ecx, [ebx+8]
		and	ecx, 0FFFFFFFEh
		mov	[esp+40h+var_1C], ebx
		mov	[eax+4], ecx
		mov	ecx, [ebx+8]
		and	ecx, 1
		or	ecx, eax
		mov	[ebx+8], ecx
		mov	ecx, [eax+8]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx+4]
		mov	[eax+8], ecx
		mov	[edx+4], eax
		mov	ecx, [ebx+8]
		and	ecx, 1
		or	ecx, edx
		mov	[ebx+8], ecx
		or	dword ptr [eax+8], 1
		mov	eax, ebx
		lea	ebx, [esp+40h+var_20]
		jmp	loc_10005060
; ---------------------------------------------------------------------------

loc_100055B6:				; CODE XREF: sub_10004FE0+474j
		and	edx, 0FFFFFFFEh
		mov	[ecx+8], edx
		or	dword ptr [eax+8], 1
		mov	ecx, [eax+8]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx+4]
		mov	[eax+8], ecx
		mov	[edx+4], eax
		mov	[ebp+4], edx
		jmp	loc_10005170
; ---------------------------------------------------------------------------

loc_100055DC:				; CODE XREF: sub_10004FE0+393j
		mov	ecx, [edx+8]
		and	ecx, 1
		or	ecx, eax
		mov	[edx+8], ecx
		jmp	loc_1000537C
; ---------------------------------------------------------------------------

loc_100055EC:				; CODE XREF: sub_10004FE0+57Bj
		mov	ecx, [ecx+8]
		xor	ecx, ebx
		mov	ebx, [esp+40h+var_30]
		and	ecx, 1
		xor	[ebx+8], ecx
		and	dword ptr [ebp+8], 0FFFFFFFEh
		mov	ecx, [edx+8]
		mov	ebx, ecx
		and	ebx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [ebx+4]
		mov	[edx+8], ecx
		mov	[ebx+4], edx
		mov	[eax+4], ebx
		jmp	loc_10005570
; ---------------------------------------------------------------------------

loc_1000561B:				; CODE XREF: sub_10004FE0+4FEj
		and	edx, 0FFFFFFFEh
		mov	[esp+40h+var_1C], ebx
		mov	[ecx+8], edx
		or	dword ptr [eax+8], 1
		mov	ecx, [eax+8]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx+4]
		mov	[eax+8], ecx
		mov	[edx+4], eax
		mov	eax, ebx
		mov	[ebx+4], edx
		and	dword ptr [ebx+8], 0FFFFFFFEh
		jmp	loc_1000504E
; ---------------------------------------------------------------------------

loc_1000564B:				; CODE XREF: sub_10004FE0+74j
		mov	[edx], ebx
		jmp	loc_100050BC
sub_10004FE0	endp


; =============== S U B	R O U T	I N E =======================================


sub_10005652	proc near		; CODE XREF: sub_10004C50+10Cp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_4]
		mov	edx, 0FFFFF000h
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		mov	eax, [esi+8]
		and	eax, edx
		mov	ebx, [edi+8]
		mov	ecx, ebx
		and	ecx, edx
		cmp	eax, ecx
		sbb	edx, edx
		neg	edx
		cmp	ecx, eax
		sbb	eax, eax
		neg	eax
		sub	edx, eax
		jz	short loc_10005684

loc_1000567E:				; CODE XREF: sub_10005652+4Ej
		pop	edi
		pop	esi
		mov	eax, edx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_10005684:				; CODE XREF: sub_10005652+2Aj
		and	bl, 10h
		movzx	ecx, bl
		neg	ecx
		sbb	ecx, ecx
		not	ecx
		and	ecx, edi
		cmp	esi, ecx
		sbb	edx, edx
		neg	edx
		cmp	ecx, esi
		sbb	ecx, ecx
		neg	ecx
		sub	edx, ecx
		jmp	short loc_1000567E
sub_10005652	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_100056A2(LPVOID lpAddress)
sub_100056A2	proc near		; CODE XREF: sub_10003DC0+1CBp
					; sub_10005AAE+E2p ...
		push	ebx
		push	ebp
		mov	ebx, ecx
		mov	ebp, 100000h
		push	esi
		mov	eax, ebx
		mov	esi, ebp
		and	eax, 0FFFFFh
		push	edi
		mov	edi, edx
		sub	esi, eax
		cmp	edi, esi
		jnb	short loc_100056DF
		mov	esi, edi
		jmp	short loc_100056DF
; ---------------------------------------------------------------------------

loc_100056C2:				; CODE XREF: sub_100056A2+3Fj
		push	4		; flProtect
		push	1000h		; flAllocationType
		push	esi		; dwSize
		push	ebx		; lpAddress
		call	ds:VirtualAlloc
		test	eax, eax
		jz	short loc_100056EC
		sub	edi, esi
		add	ebx, esi
		mov	esi, edi
		cmp	edi, ebp
		jnb	short loc_100056E8

loc_100056DF:				; CODE XREF: sub_100056A2+1Aj
					; sub_100056A2+1Ej ...
		test	edi, edi
		jnz	short loc_100056C2
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_100056E8:				; CODE XREF: sub_100056A2+3Bj
		mov	esi, ebp
		jmp	short loc_100056DF
; ---------------------------------------------------------------------------

loc_100056EC:				; CODE XREF: sub_100056A2+31j
		call	sub_1000EDDD
sub_100056A2	endp

; ---------------------------------------------------------------------------
		align 2

; =============== S U B	R O U T	I N E =======================================


sub_100056F2	proc near		; CODE XREF: sub_10004E40+118p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_4]
		cmp	ecx, [esp+arg_0]
		sbb	eax, eax
		neg	eax
		cmp	[esp+arg_0], ecx
		sbb	ecx, ecx
		neg	ecx
		sub	eax, ecx
		retn
sub_100056F2	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


sub_10005710	proc near		; CODE XREF: sub_10004A40+201j
					; jemalloc_free_dirty_pages+26p

var_4		= dword	ptr -4

		push	ecx
		push	ebp
		mov	ebp, ecx
		test	edx, edx
		jnz	loc_10005826
		mov	eax, dword_1001A49C

loc_10005721:				; CODE XREF: sub_10005710+11Bj
		add	dword ptr [ebp+20h], 1
		adc	dword ptr [ebp+24h], 0
		shr	eax, 1
		mov	[esp+8+var_4], eax
		cmp	[ebp+0A4h], eax
		jbe	short loc_100057B1
		push	ebx
		push	esi
		push	edi
		lea	ebx, [ebp+80h]

loc_10005740:				; CODE XREF: sub_10005710+9Cj
		mov	edi, [ebx]
		lea	edx, [ebx+4]
		mov	ecx, [edi+8]
		mov	eax, ecx
		and	eax, 0FFFFFFFEh
		cmp	eax, edx
		jz	short loc_10005762

loc_10005751:				; CODE XREF: sub_10005710+50j
		mov	edi, ecx
		and	edi, 0FFFFFFFEh
		mov	ecx, [edi+8]
		mov	eax, ecx
		and	eax, 0FFFFFFFEh
		cmp	eax, edx
		jnz	short loc_10005751

loc_10005762:				; CODE XREF: sub_10005710+3Fj
		cmp	edi, edx
		jz	loc_10005830

loc_1000576A:				; CODE XREF: sub_10005710+122j
		cmp	dword ptr [edi+0Ch], 0
		mov	esi, 0FFh
		jbe	short loc_10005797

loc_10005775:				; CODE XREF: sub_10005710+7Bj
		lea	eax, [esi+2]
		lea	eax, [eax+eax*2]
		mov	ecx, [edi+eax*4]
		lea	eax, [edi+eax*4]
		test	cl, 8
		jnz	short loc_100057B4

loc_10005786:				; CODE XREF: sub_10005710+10Bj
		dec	esi
		cmp	dword ptr [edi+0Ch], 0
		ja	short loc_10005775

loc_1000578D:				; CODE XREF: sub_10005710+111j
		cmp	dword ptr [edi+0Ch], 0
		lea	ebx, [ebp+80h]

loc_10005797:				; CODE XREF: sub_10005710+63j
		jnz	short loc_100057A2
		mov	edx, edi
		mov	ecx, ebx
		call	sub_10004FE0

loc_100057A2:				; CODE XREF: sub_10005710:loc_10005797j
		mov	eax, [esp+14h+var_4]
		cmp	[ebp+0A4h], eax
		ja	short loc_10005740
		pop	edi
		pop	esi
		pop	ebx

loc_100057B1:				; CODE XREF: sub_10005710+25j
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_100057B4:				; CODE XREF: sub_10005710+74j
		xor	ecx, 28h
		mov	ebx, 1
		mov	[eax], ecx
		mov	edi, edi

loc_100057C0:				; CODE XREF: sub_10005710+C4j
		cmp	esi, 1
		jbe	short loc_100057D6
		test	byte ptr [eax-0Ch], 8
		jz	short loc_100057D6
		xor	dword ptr [eax-0Ch], 28h
		sub	eax, 0Ch
		dec	esi
		inc	ebx
		jmp	short loc_100057C0
; ---------------------------------------------------------------------------

loc_100057D6:				; CODE XREF: sub_10005710+B3j
					; sub_10005710+B9j
		sub	[edi+0Ch], ebx
		mov	ecx, esi
		sub	[ebp+0A4h], ebx
		mov	edx, ebx
		shl	ecx, 0Ch
		shl	edx, 0Ch
		add	ecx, edi	; lpAddress
		call	sub_10005837
		add	dword ptr [ebp+38h], 1
		mov	eax, [esp+14h+var_4]
		adc	dword ptr [ebp+3Ch], 0
		add	[ebp+48h], ebx
		adc	dword ptr [ebp+4Ch], 0
		sub	[ebp+50h], ebx
		add	dword ptr [ebp+28h], 1
		adc	dword ptr [ebp+2Ch], 0
		add	[ebp+30h], ebx
		adc	dword ptr [ebp+34h], 0
		cmp	[ebp+0A4h], eax
		ja	loc_10005786
		jmp	loc_1000578D
; ---------------------------------------------------------------------------

loc_10005826:				; CODE XREF: sub_10005710+6j
		mov	eax, 1
		jmp	loc_10005721
; ---------------------------------------------------------------------------

loc_10005830:				; CODE XREF: sub_10005710+54j
		xor	edi, edi
		jmp	loc_1000576A
sub_10005710	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_10005837(LPVOID lpAddress)
sub_10005837	proc near		; CODE XREF: sub_10005710+DBp
					; sub_10005917+62p ...
		push	ebx
		push	ebp
		mov	ebx, ecx
		mov	ebp, 100000h
		push	esi
		mov	eax, ebx
		mov	esi, ebp
		and	eax, 0FFFFFh
		push	edi
		mov	edi, edx
		sub	esi, eax
		cmp	edi, esi
		jnb	short loc_10005872
		mov	esi, edi
		jmp	short loc_10005872
; ---------------------------------------------------------------------------

loc_10005857:				; CODE XREF: sub_10005837+3Dj
		push	4000h		; dwFreeType
		push	esi		; dwSize
		push	ebx		; lpAddress
		call	ds:VirtualFree
		test	eax, eax
		jz	short loc_1000587F
		sub	edi, esi
		add	ebx, esi
		mov	esi, edi
		cmp	edi, ebp
		jnb	short loc_1000587B

loc_10005872:				; CODE XREF: sub_10005837+1Aj
					; sub_10005837+1Ej ...
		test	edi, edi
		jnz	short loc_10005857
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1000587B:				; CODE XREF: sub_10005837+39j
		mov	esi, ebp
		jmp	short loc_10005872
; ---------------------------------------------------------------------------

loc_1000587F:				; CODE XREF: sub_10005837+2Fj
		call	sub_1000EDDD
sub_10005837	endp

; ---------------------------------------------------------------------------
		db 0CCh

; =============== S U B	R O U T	I N E =======================================


sub_10005885	proc near		; CODE XREF: sub_100058DC+21p
					; sub_1000EF13+81p

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ecx
		push	ebx
		push	ebp
		push	esi
		mov	ebp, edx
		mov	[esp+10h+var_4], ecx
		mov	edx, [esp+10h+arg_8]
		mov	esi, edx
		push	edi
		mov	edi, [esp+14h+arg_0]
		or	esi, 3
		mov	ecx, [esp+14h+arg_4]
		sub	edi, ebp
		shr	edi, 0Ch
		sub	ecx, edx
		push	[esp+14h+arg_C]
		or	ecx, 3
		lea	eax, [edi+2]
		imul	eax, 0Ch
		mov	[eax+ebp], esi
		mov	eax, edx
		add	edx, [esp+18h+arg_0]
		shr	eax, 0Ch
		add	eax, 2
		add	eax, edi
		imul	eax, 0Ch
		mov	[eax+ebp], ecx
		mov	ecx, [esp+18h+var_4]
		call	sub_10004A40
		pop	ecx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
sub_10005885	endp


; =============== S U B	R O U T	I N E =======================================


; int __usercall sub_100058DC@<eax>(LPCRITICAL_SECTION lpCriticalSection@<ecx>,	int, int, int)
sub_100058DC	proc near		; CODE XREF: sub_100017CC+5Cp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	esi
		push	edi
		mov	ebx, ecx
		mov	esi, edx
		push	ebx		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	edi, [esp+0Ch+arg_4]
		mov	edx, esi
		push	1
		push	edi
		push	[esp+14h+arg_8]
		mov	ecx, ebx
		push	[esp+18h+arg_0]
		call	sub_10005885
		sub	edi, [esp+1Ch+arg_8]
		add	esp, 10h
		add	[ebx+68h], edi
		push	ebx		; lpCriticalSection
		call	ds:LeaveCriticalSection
		pop	edi
		pop	esi
		pop	ebx
		retn
sub_100058DC	endp


; =============== S U B	R O U T	I N E =======================================


sub_10005917	proc near		; CODE XREF: sub_100029D0+142p
					; sub_10003C40+150p
		push	ebx
		push	ebp
		push	esi
		mov	esi, ecx
		push	edi
		mov	edi, edx
		add	dword ptr [esi+18h], 100000h
		xor	ebp, ebp
		mov	ecx, ebp
		mov	[edi], esi
		lea	eax, [edi+18h]
		mov	[edi+0Ch], ebp

loc_10005932:				; CODE XREF: sub_10005917+93j
		cmp	ecx, 1
		jb	short loc_100059A4
		lea	eax, [ecx+2]
		mov	edx, 0FFh
		imul	eax, 0Ch
		inc	ecx
		mov	dword ptr [eax+edi], 0FF024h
		cmp	ecx, edx
		jnb	short loc_10005964
		lea	eax, [ecx+2]
		imul	eax, 0Ch
		add	eax, edi
		sub	edx, ecx

loc_10005958:				; CODE XREF: sub_10005917+4Bj
		mov	dword ptr [eax], 24h
		lea	eax, [eax+0Ch]
		dec	edx
		jnz	short loc_10005958

loc_10005964:				; CODE XREF: sub_10005917+35j
		mov	edx, 0FF000h
		mov	dword ptr [edi+0C0Ch], 0FF024h
		lea	ecx, [edi+1000h] ; lpAddress
		call	sub_10005837
		add	dword ptr [esi+38h], 1
		lea	edx, [edi+1Ch]
		pop	edi
		adc	[esi+3Ch], ebp
		lea	ecx, [esi+0A8h]
		add	dword ptr [esi+48h], 0FFh
		adc	[esi+4Ch], ebp
		inc	dword ptr [esi+50h]
		pop	esi
		pop	ebp
		pop	ebx
		jmp	sub_10004C50
; ---------------------------------------------------------------------------

loc_100059A4:				; CODE XREF: sub_10005917+1Ej
		mov	[eax], ebp
		inc	ecx
		add	eax, 0Ch
		jmp	short loc_10005932
sub_10005917	endp


; =============== S U B	R O U T	I N E =======================================


; int __usercall sub_100059AC@<eax>(DWORD dwSize@<ecx>,	int, char)
sub_100059AC	proc near		; CODE XREF: sub_100029D0+130p
					; sub_10003C40+13Ep ...

arg_0		= dword	ptr  4
arg_4		= byte ptr  8

		push	ebx
		push	esi
		push	edi
		mov	edi, ecx
		mov	ebx, edx
		mov	ecx, 100000h
		cmp	edi, ecx
		jnz	short loc_100059D5
		lea	eax, [esp+0Ch+arg_4]
		push	eax		; int
		push	[esp+10h+arg_0]	; int
		push	ebx		; int
		push	ecx		; size_t
		call	sub_10005AAE
		mov	esi, eax
		add	esp, 10h
		test	esi, esi
		jnz	short loc_100059E4

loc_100059D5:				; CODE XREF: sub_100059AC+Ej
		mov	edx, ebx
		mov	ecx, edi	; dwSize
		call	sub_10005A6D
		mov	esi, eax
		test	esi, esi
		jz	short loc_100059FE

loc_100059E4:				; CODE XREF: sub_100059AC+27j
		cmp	[esp+0Ch+arg_0], 0
		jnz	short loc_100059F8
		push	esi
		mov	edx, esi
		call	sub_10005A0F
		pop	ecx
		test	eax, eax
		jnz	short loc_10005A02

loc_100059F8:				; CODE XREF: sub_100059AC+3Dj
					; sub_100059AC+54j
		mov	eax, esi

loc_100059FA:				; CODE XREF: sub_100059AC+61j
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_100059FE:				; CODE XREF: sub_100059AC+36j
		xor	esi, esi
		jmp	short loc_100059F8
; ---------------------------------------------------------------------------

loc_10005A02:				; CODE XREF: sub_100059AC+4Aj
		mov	edx, edi
		mov	ecx, esi
		call	sub_1000600C
		xor	eax, eax
		jmp	short loc_100059FA
sub_100059AC	endp


; =============== S U B	R O U T	I N E =======================================


sub_10005A0F	proc near		; CODE XREF: sub_100059AC+42p
					; sub_1000600C+Ap

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000C5D6 SIZE 0000006B BYTES

		sub	esp, 14h
		push	ebx
		push	ebp
		push	esi
		mov	esi, lpCriticalSection
		mov	ebx, edx
		push	edi
		push	esi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	eax, [esi+1Ch]
		xor	edi, edi
		mov	edx, [esi+18h]
		dec	eax
		mov	ecx, edi
		mov	[esp+24h+var_4], eax
		push	20h
		mov	[esp+28h+var_C], ecx
		mov	ebp, edi
		pop	eax
		jnz	short loc_10005A61

loc_10005A3F:				; CODE XREF: sub_10005A0F+6C25j
		sub	eax, [esi+ebp*4+20h]
		shl	ebx, cl
		mov	ecx, eax
		shr	ebx, cl
		mov	ecx, [esp+24h+arg_0]
		mov	[edx+ebx*4], ecx

loc_10005A50:				; CODE XREF: sub_10005A0F+6C2Dj
		push	esi		; lpCriticalSection
		call	ds:LeaveCriticalSection
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_10005A61:				; CODE XREF: sub_10005A0F+2Ej
		lea	eax, [esi+24h]
		mov	[esp+24h+var_14], eax
		jmp	loc_1000C5D6
sub_10005A0F	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_10005A6D(DWORD dwSize)
sub_10005A6D	proc near		; CODE XREF: sub_100059AC+2Dp
		push	ebx
		push	esi
		push	edi
		push	4		; flProtect
		push	3000h		; flAllocationType
		mov	ebx, ecx
		mov	edi, edx
		push	ebx		; dwSize
		push	0		; lpAddress
		call	ds:VirtualAlloc
		mov	esi, eax
		test	esi, esi
		jz	short loc_10005AAA
		lea	eax, [edi-1]
		test	esi, eax
		jnz	short loc_10005A97
		mov	eax, esi

loc_10005A93:				; CODE XREF: sub_10005A6D+3Fj
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_10005A97:				; CODE XREF: sub_10005A6D+22j
		mov	ecx, esi	; lpAddress
		call	sub_10005C56
		mov	edx, edi
		mov	ecx, ebx	; dwSize
		pop	edi
		pop	esi
		pop	ebx
		jmp	sub_10005BF2
; ---------------------------------------------------------------------------

loc_10005AAA:				; CODE XREF: sub_10005A6D+1Bj
		xor	eax, eax
		jmp	short loc_10005A93
sub_10005A6D	endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_10005AAE(size_t, int,	int, int)
sub_10005AAE	proc near		; CODE XREF: sub_100059AC+1Bp

var_20		= dword	ptr -20h
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

; FUNCTION CHUNK AT 1000C641 SIZE 0000009E BYTES

		sub	esp, 20h
		cmp	[esp+20h+arg_8], 0
		jnz	loc_10005BAB
		push	ebx
		mov	ebx, [esp+24h+arg_4]
		push	edi
		mov	edi, [esp+28h+arg_0]
		lea	eax, [ebx-100000h]
		add	eax, edi
		cmp	eax, edi
		jb	loc_10005BB2
		and	[esp+28h+var_C], 0
		push	ebp
		push	esi
		mov	ebp, offset stru_1001AB78
		mov	[esp+30h+var_8], eax
		push	ebp		; lpCriticalSection
		call	ds:EnterCriticalSection
		lea	edx, [esp+30h+var_1C]
		mov	ecx, offset dword_1001AB04
		call	sub_10005BB9
		mov	esi, eax
		test	esi, esi
		jnz	short loc_10005B12
		push	ebp		; lpCriticalSection
		call	ds:LeaveCriticalSection

loc_10005B08:				; CODE XREF: sub_10005AAE+6BD4j
		xor	eax, eax

loc_10005B0A:				; CODE XREF: sub_10005AAE+F8j
		pop	esi
		pop	ebp

loc_10005B0C:				; CODE XREF: sub_10005AAE+106j
		pop	edi
		pop	ebx

loc_10005B0E:				; CODE XREF: sub_10005AAE+FFj
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_10005B12:				; CODE XREF: sub_10005AAE+51j
		mov	eax, [esi+10h]
		lea	ebp, [ebx-1]
		mov	ecx, [esi+14h]
		add	ebp, eax
		neg	ebx
		and	ebp, ebx
		sub	ebp, eax
		sub	ecx, ebp
		sub	ecx, edi
		mov	[esp+30h+arg_8], ecx
		lea	ebx, [eax+ebp]
		mov	eax, [esi+18h]
		mov	[esp+30h+var_20], eax
		test	eax, eax
		jz	short loc_10005B43
		mov	eax, [esp+30h+arg_C]
		mov	dword ptr [eax], 1

loc_10005B43:				; CODE XREF: sub_10005AAE+89j
		mov	edx, esi
		mov	ecx, offset dword_1001AB04
		call	sub_10006209
		mov	edx, esi
		mov	ecx, offset dword_1001AB58
		call	sub_10005E64
		test	ebp, ebp
		jnz	loc_1000C641

loc_10005B63:				; CODE XREF: sub_10005AAE+6BB0j
		cmp	[esp+30h+arg_8], 0
		mov	ebp, ds:LeaveCriticalSection
		jnz	loc_1000C663

loc_10005B74:				; CODE XREF: sub_10005AAE+6C12j
		sub	dword_1001AB94,	edi
		push	offset stru_1001AB78 ; lpCriticalSection
		call	ebp ; LeaveCriticalSection
		test	esi, esi
		jz	short loc_10005B8C
		mov	ecx, esi
		call	sub_100060F5

loc_10005B8C:				; CODE XREF: sub_10005AAE+D5j
		mov	edx, edi
		mov	ecx, ebx	; lpAddress
		call	sub_100056A2
		cmp	[esp+30h+var_20], 0
		mov	eax, [esp+30h+arg_C]
		jz	loc_1000C6C5

loc_10005BA4:				; CODE XREF: sub_10005AAE+6C1Aj
					; sub_10005AAE+6C2Cj
		mov	eax, ebx
		jmp	loc_10005B0A
; ---------------------------------------------------------------------------

loc_10005BAB:				; CODE XREF: sub_10005AAE+8j
		xor	eax, eax
		jmp	loc_10005B0E
; ---------------------------------------------------------------------------

loc_10005BB2:				; CODE XREF: sub_10005AAE+22j
		xor	eax, eax
		jmp	loc_10005B0C
sub_10005AAE	endp


; =============== S U B	R O U T	I N E =======================================


sub_10005BB9	proc near		; CODE XREF: sub_10005AAE+48p

; FUNCTION CHUNK AT 1000C6DF SIZE 00000007 BYTES

		push	ebx
		push	ebp
		push	esi
		mov	esi, [ecx]
		lea	ebx, [ecx+4]
		push	edi
		mov	ebp, edx
		xor	edi, edi

loc_10005BC6:				; CODE XREF: sub_10005BB9+29j
					; sub_10005BB9+37j
		cmp	esi, ebx
		jnz	short loc_10005BD1

loc_10005BCA:				; CODE XREF: sub_10005BB9+6B28j
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_10005BD1:				; CODE XREF: sub_10005BB9+Fj
		push	esi
		push	ebp
		call	sub_10006282
		pop	ecx
		pop	ecx
		test	eax, eax
		jns	short loc_10005BE4
		mov	edi, esi
		mov	esi, [esi]
		jmp	short loc_10005BC6
; ---------------------------------------------------------------------------

loc_10005BE4:				; CODE XREF: sub_10005BB9+23j
		jle	loc_1000C6DF
		mov	esi, [esi+4]
		and	esi, 0FFFFFFFEh
		jmp	short loc_10005BC6
sub_10005BB9	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_10005BF2(DWORD dwSize)
sub_10005BF2	proc near		; CODE XREF: sub_10005A6D+38j

; FUNCTION CHUNK AT 1000C6E6 SIZE 00000012 BYTES

		push	ebx
		push	ebp
		mov	ebp, edx
		push	edi
		mov	edi, ecx
		lea	ebx, [ebp-1000h]
		add	ebx, edi
		cmp	ebx, edi
		jb	short loc_10005C4E
		push	esi

loc_10005C06:				; CODE XREF: sub_10005BF2+53j
		push	4		; flProtect
		push	3000h		; flAllocationType
		push	ebx		; dwSize
		push	0		; lpAddress
		call	ds:VirtualAlloc
		test	eax, eax
		jz	short loc_10005C52
		lea	esi, [ebp-1]
		mov	ecx, ebp
		neg	ecx
		add	esi, eax
		and	esi, ecx
		mov	ecx, eax	; lpAddress
		call	sub_10005C56
		push	4		; flProtect
		push	3000h		; flAllocationType
		push	edi		; dwSize
		push	esi		; lpAddress
		call	ds:VirtualAlloc
		cmp	eax, esi
		jnz	loc_1000C6E6

loc_10005C43:				; CODE XREF: sub_10005BF2+6B01j
		test	esi, esi
		jz	short loc_10005C06
		mov	eax, esi

loc_10005C49:				; CODE XREF: sub_10005BF2+62j
		pop	esi

loc_10005C4A:				; CODE XREF: sub_10005BF2+5Ej
		pop	edi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_10005C4E:				; CODE XREF: sub_10005BF2+11j
		xor	eax, eax
		jmp	short loc_10005C4A
; ---------------------------------------------------------------------------

loc_10005C52:				; CODE XREF: sub_10005BF2+26j
		xor	eax, eax
		jmp	short loc_10005C49
sub_10005BF2	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_10005C56(LPVOID lpAddress)
sub_10005C56	proc near		; CODE XREF: sub_10005A6D+2Cp
					; sub_10005BF2+35p ...

; FUNCTION CHUNK AT 1000C6F8 SIZE 00000028 BYTES

		push	8000h		; dwFreeType
		push	0		; dwSize
		push	ecx		; lpAddress
		call	ds:VirtualFree
		test	eax, eax
		jz	loc_1000C6F8
		retn
sub_10005C56	endp


; =============== S U B	R O U T	I N E =======================================


sub_10005C6D	proc near		; CODE XREF: calloc+297p malloc+327p ...

arg_0		= byte ptr  4

		push	ebx
		push	ebp
		mov	ebp, ecx
		mov	ebx, edx
		push	esi
		lea	esi, [ebp+0FFFFFh]
		and	esi, 0FFF00000h
		jz	loc_10005D12
		push	edi
		call	sub_10005DE5
		mov	edi, eax
		test	edi, edi
		jz	loc_10005D1D
		push	dword ptr [esp+10h+arg_0] ; char
		mov	edx, ebx
		mov	ecx, esi	; dwSize
		push	0		; int
		call	sub_100059AC
		mov	ebx, eax
		pop	ecx
		pop	ecx
		test	ebx, ebx
		jz	short loc_10005D16
		add	ebp, 0FFFh
		mov	[edi+10h], ebx
		and	ebp, 0FFFFF000h
		push	offset stru_1001AAB0 ; lpCriticalSection
		mov	[edi+14h], ebp
		call	ds:EnterCriticalSection
		mov	edx, edi
		mov	ecx, offset dword_1001AACC
		call	sub_10005D21
		add	dword_1001AB50,	1
		push	offset stru_1001AAB0 ; lpCriticalSection
		adc	dword_1001AB54,	0
		add	dword_1001AAAC,	ebp
		add	dword_1001AB48,	esi
		call	ds:LeaveCriticalSection
		sub	esi, ebp
		jnz	short loc_10005D06

loc_10005CFF:				; CODE XREF: sub_10005C6D+A3j
		mov	eax, ebx

loc_10005D01:				; CODE XREF: sub_10005C6D+B2j
		pop	edi

loc_10005D02:				; CODE XREF: sub_10005C6D+A7j
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_10005D06:				; CODE XREF: sub_10005C6D+90j
		lea	ecx, [ebx+ebp]	; lpAddress
		mov	edx, esi
		call	sub_10005837
		jmp	short loc_10005CFF
; ---------------------------------------------------------------------------

loc_10005D12:				; CODE XREF: sub_10005C6D+13j
		xor	eax, eax
		jmp	short loc_10005D02
; ---------------------------------------------------------------------------

loc_10005D16:				; CODE XREF: sub_10005C6D+3Ej
		mov	ecx, edi
		call	sub_100060F5

loc_10005D1D:				; CODE XREF: sub_10005C6D+23j
		xor	eax, eax
		jmp	short loc_10005D01
sub_10005C6D	endp


; =============== S U B	R O U T	I N E =======================================


sub_10005D21	proc near		; CODE XREF: sub_10005C6D+64p
					; sub_100062B7+6Fp ...

var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= byte ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

; FUNCTION CHUNK AT 1000C720 SIZE 0000009B BYTES

		sub	esp, 24h
		push	ebx
		push	ebp
		push	esi
		mov	esi, ecx
		mov	[esp+30h+var_24], edx
		xor	ecx, ecx
		mov	[esp+30h+var_20], esi
		push	edi
		lea	edi, [esp+34h+var_1C]
		mov	eax, [esi]
		lea	ebp, [esi+4]
		mov	esi, [esi]
		mov	ebx, ebp
		mov	[esp+34h+var_14], eax
		mov	eax, ebp
		and	eax, 0FFFFFFFEh
		mov	[esp+34h+var_10], eax

loc_10005D4E:				; CODE XREF: sub_10005D21+B5j
		cmp	esi, ebp
		jnz	short loc_10005DAC
		xor	esi, esi
		mov	[edx+8], ebp
		inc	esi
		or	ebp, esi
		mov	[edx+0Ch], ebp
		test	ecx, ecx
		jle	short loc_10005DDB
		mov	ecx, [edi+0Ch]
		and	ecx, esi
		or	ecx, edx
		mov	[edi+0Ch], ecx
		and	ecx, 0FFFFFFFEh
		mov	eax, [edi+0Ch]
		and	eax, esi
		or	eax, [ecx+8]
		mov	[edi+0Ch], eax
		mov	eax, [ecx+0Ch]
		mov	[ecx+8], edi
		xor	eax, [edi+0Ch]
		and	eax, esi
		xor	[ecx+0Ch], eax
		or	[edi+0Ch], esi
		cmp	[ebx+8], edi
		jnz	loc_1000C79F
		mov	[ebx+8], ecx

loc_10005D96:				; CODE XREF: sub_10005D21+BDj
					; sub_10005D21+6A88j ...
		mov	eax, [esp+34h+var_14]
		mov	ecx, [esp+34h+var_20]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], eax
		and	dword ptr [eax+0Ch], 0FFFFFFFEh
		pop	ebx
		add	esp, 24h
		retn
; ---------------------------------------------------------------------------

loc_10005DAC:				; CODE XREF: sub_10005D21+2Fj
		mov	ecx, [esi+8]
		test	byte ptr [ecx+0Ch], 1
		jnz	loc_1000C720

loc_10005DB9:				; CODE XREF: sub_10005D21+6A06j
					; sub_10005D21+6A31j
		mov	ebx, edi

loc_10005DBB:				; CODE XREF: sub_10005D21+6A6Aj
					; sub_10005D21+6A79j
		push	esi
		push	edx
		mov	edi, esi
		call	sub_10005F71
		pop	ecx
		pop	ecx
		mov	ecx, eax
		test	ecx, ecx
		js	short loc_10005DE0
		mov	esi, [esi+0Ch]
		and	esi, 0FFFFFFFEh

loc_10005DD2:				; CODE XREF: sub_10005D21+C2j
		mov	edx, [esp+34h+var_24]
		jmp	loc_10005D4E
; ---------------------------------------------------------------------------

loc_10005DDB:				; CODE XREF: sub_10005D21+3Ej
		mov	[edi+8], edx
		jmp	short loc_10005D96
; ---------------------------------------------------------------------------

loc_10005DE0:				; CODE XREF: sub_10005D21+A9j
		mov	esi, [esi+8]
		jmp	short loc_10005DD2
sub_10005D21	endp


; =============== S U B	R O U T	I N E =======================================


sub_10005DE5	proc near		; CODE XREF: sub_10005C6D+1Ap
					; sub_100062B7+14p ...
		push	esi
		push	edi
		mov	edi, offset stru_1001AB98
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	esi, dword_1001ABB8
		push	edi		; lpCriticalSection
		test	esi, esi
		jz	short loc_10005E10
		mov	eax, [esi]
		mov	dword_1001ABB8,	eax
		call	ds:LeaveCriticalSection

loc_10005E0B:				; CODE XREF: sub_10005DE5+3Bj
		pop	edi
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_10005E10:				; CODE XREF: sub_10005DE5+17j
		call	ds:LeaveCriticalSection
		push	1Ch
		pop	ecx
		call	sub_10005F8F
		mov	esi, eax
		jmp	short loc_10005E0B
sub_10005DE5	endp


; =============== S U B	R O U T	I N E =======================================


sub_10005E22	proc near		; CODE XREF: sub_10006073+1Dp
					; sub_100023C0+9F71p ...
		push	ebx
		push	esi
		mov	esi, dword_1001AACC
		mov	ebx, offset dword_1001AAD0
		push	edi
		mov	edi, edx
		cmp	esi, ebx
		jz	short loc_10005E60

loc_10005E36:				; CODE XREF: sub_10005E22+32j
		push	esi
		push	edi
		call	sub_10005F71
		pop	ecx
		pop	ecx
		test	eax, eax
		jnz	short loc_10005E4D

loc_10005E43:				; CODE XREF: sub_10005E22+34j
		cmp	esi, ebx
		jz	short loc_10005E60

loc_10005E47:				; CODE XREF: sub_10005E22+40j
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_10005E4D:				; CODE XREF: sub_10005E22+1Fj
		jns	short loc_10005E58
		mov	esi, [esi+8]

loc_10005E52:				; CODE XREF: sub_10005E22+3Cj
		cmp	esi, ebx
		jnz	short loc_10005E36
		jmp	short loc_10005E43
; ---------------------------------------------------------------------------

loc_10005E58:				; CODE XREF: sub_10005E22:loc_10005E4Dj
		mov	esi, [esi+0Ch]
		and	esi, 0FFFFFFFEh
		jmp	short loc_10005E52
; ---------------------------------------------------------------------------

loc_10005E60:				; CODE XREF: sub_10005E22+12j
					; sub_10005E22+23j
		xor	esi, esi
		jmp	short loc_10005E47
sub_10005E22	endp


; =============== S U B	R O U T	I N E =======================================


sub_10005E64	proc near		; CODE XREF: sub_10005AAE+A8p
					; sub_10006073+2Bp ...

var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= byte ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

; FUNCTION CHUNK AT 1000C7BB SIZE 0000044E BYTES

		sub	esp, 34h
		push	ebx
		mov	eax, ecx
		mov	[esp+38h+var_28], edx
		push	ebp
		push	esi
		push	edi
		mov	esi, [eax]
		lea	ebp, [eax+4]
		mov	[esp+44h+var_20], eax
		lea	edi, [esp+44h+var_1C]
		mov	eax, ebp
		mov	[esp+44h+var_14], esi
		and	eax, 0FFFFFFFEh
		mov	[esp+44h+var_34], ebp
		push	esi
		push	edx
		mov	[esp+4Ch+var_10], eax
		call	sub_10005F71
		xor	ebx, ebx
		mov	[esp+4Ch+var_2C], eax
		pop	ecx
		inc	ebx
		pop	ecx
		test	eax, eax
		js	short loc_10005ED6
		jnz	loc_1000C86A
		mov	eax, [esi+0Ch]
		and	eax, 0FFFFFFFEh
		cmp	eax, ebp
		jnz	loc_1000C85C
		mov	edx, [esi+8]
		cmp	edx, ebp
		jnz	short loc_10005F28
		mov	edx, ebp

loc_10005EC0:				; CODE XREF: sub_10005E64+F3j
		mov	[esp+44h+var_14], edx

loc_10005EC4:				; CODE XREF: sub_10005E64+87j
					; sub_10005E64+C2j ...
		mov	ecx, [esp+44h+var_20]
		mov	eax, [esp+44h+var_14]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], eax
		pop	ebx
		add	esp, 34h
		retn
; ---------------------------------------------------------------------------

loc_10005ED6:				; CODE XREF: sub_10005E64+3Dj
		mov	ecx, [esi+8]
		test	[ecx+0Ch], bl
		jz	loc_1000C7BB

loc_10005EE2:				; CODE XREF: sub_10005E64+695Dj
		mov	edi, esi
		mov	esi, ecx

loc_10005EE6:				; CODE XREF: sub_10005E64+6A08j
					; sub_10005E64+6B44j
		cmp	[esp+44h+var_2C], 0
		jz	short loc_10005EC4

loc_10005EED:				; CODE XREF: sub_10005E64+6D0Ej
					; sub_10005E64+6D17j
		push	esi
		push	[esp+48h+var_28]
		call	sub_10005F71
		pop	ecx
		pop	ecx
		test	eax, eax
		js	loc_1000C9AD
		jnz	loc_1000CA50
		mov	eax, [esi+0Ch]
		and	eax, 0FFFFFFFEh
		cmp	eax, ebp
		jnz	short loc_10005F5C
		mov	edx, [esi+8]
		cmp	edx, ebp
		jnz	loc_1000CBD8
		mov	edx, ebp

loc_10005F1E:				; CODE XREF: sub_10005E64+6DA0j
		cmp	[edi+8], esi
		jnz	short loc_10005F65
		mov	[edi+8], edx
		jmp	short loc_10005EC4
; ---------------------------------------------------------------------------

loc_10005F28:				; CODE XREF: sub_10005E64+58j
		mov	eax, [edx+0Ch]
		xor	ebx, ebx
		and	eax, 0FFFFFFFEh
		inc	ebx
		mov	[esi+8], eax
		mov	ecx, [edx+0Ch]
		and	ecx, ebx
		or	ecx, esi
		mov	[edx+0Ch], ecx
		mov	eax, [esi+0Ch]
		xor	eax, ecx
		and	eax, ebx
		xor	eax, ecx
		mov	[edx+0Ch], eax
		or	[esi+0Ch], ebx
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, ebp
		mov	[edx+0Ch], eax
		jmp	loc_10005EC0
; ---------------------------------------------------------------------------

loc_10005F5C:				; CODE XREF: sub_10005E64+ABj
		mov	[esp+44h+var_34], edi
		jmp	loc_1000CA50
; ---------------------------------------------------------------------------

loc_10005F65:				; CODE XREF: sub_10005E64+BDj
		mov	eax, [edi+0Ch]
		and	eax, ebx
		or	eax, edx
		jmp	loc_1000CBD0
sub_10005E64	endp


; =============== S U B	R O U T	I N E =======================================


sub_10005F71	proc near		; CODE XREF: sub_10005D21+9Ep
					; sub_10005E22+16p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+10h]
		mov	eax, [esp+arg_4]
		cmp	[eax+10h], ecx
		sbb	edx, edx
		neg	edx
		cmp	ecx, [eax+10h]
		sbb	ecx, ecx
		neg	ecx
		sub	edx, ecx
		mov	eax, edx
		retn
sub_10005F71	endp


; =============== S U B	R O U T	I N E =======================================


sub_10005F8F	proc near		; CODE XREF: sub_10005DE5+34p
					; sub_1000611C+6p ...
		push	ebx
		push	ebp
		push	esi
		push	edi
		lea	edi, [ecx+3Fh]
		mov	ebp, offset stru_1001AB98
		push	ebp		; lpCriticalSection
		and	edi, 0FFFFFFC0h
		call	ds:EnterCriticalSection
		mov	esi, dword_1001AAEC
		lea	eax, [esi+edi]
		cmp	eax, dword_1001AB28
		ja	short loc_10005FD8

loc_10005FB6:				; CODE XREF: sub_10005F8F+5Aj
		mov	ecx, lpAddress	; lpAddress
		mov	ebx, esi
		add	esi, edi
		mov	dword_1001AAEC,	esi
		cmp	esi, ecx
		ja	short loc_10005FEB

loc_10005FCA:				; CODE XREF: sub_10005F8F+77j
					; sub_10005F8F+7Bj
		push	ebp		; lpCriticalSection
		call	ds:LeaveCriticalSection
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_10005FD8:				; CODE XREF: sub_10005F8F+25j
		mov	ecx, edi
		call	sub_100063E5
		test	eax, eax
		jnz	short loc_10006008
		mov	esi, dword_1001AAEC
		jmp	short loc_10005FB6
; ---------------------------------------------------------------------------

loc_10005FEB:				; CODE XREF: sub_10005F8F+39j
		add	esi, 0FFFh
		and	esi, 0FFFFF000h
		mov	edx, esi
		sub	edx, ecx
		call	sub_100056A2
		mov	lpAddress, esi
		jmp	short loc_10005FCA
; ---------------------------------------------------------------------------

loc_10006008:				; CODE XREF: sub_10005F8F+52j
		xor	ebx, ebx
		jmp	short loc_10005FCA
sub_10005F8F	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000600C	proc near		; CODE XREF: sub_100059AC+5Ap
					; sub_10006073+6Fp ...
		push	esi
		push	edi
		mov	esi, ecx
		mov	edi, edx
		push	0
		mov	edx, esi
		call	sub_10005A0F
		pop	ecx
		mov	edx, edi
		mov	ecx, esi
		call	sub_10006035
		test	eax, eax
		jz	short loc_10006032
		push	edi		; int
		push	esi		; lpAddress
		call	sub_100062B7
		pop	ecx
		pop	ecx

loc_10006032:				; CODE XREF: sub_1000600C+1Bj
		pop	edi
		pop	esi
		retn
sub_1000600C	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10006035	proc near		; CODE XREF: sub_1000600C+14p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ecx
		cmp	edx, 100000h
		jnz	short loc_1000606A
		mov	eax, dword_1001AB94
		mov	[ebp+var_8], eax
		xor	eax, eax
		inc	eax
		mov	[ebp+var_4], 0
		push	esi
		mov	edx, eax
		lea	esi, [ebp+var_4]
		xchg	edx, [esi]
		cmp	[ebp+var_8], 8000000h
		pop	esi
		jnb	short loc_1000606A

loc_10006066:				; CODE XREF: sub_10006035+3Cj
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000606A:				; CODE XREF: sub_10006035+Bj
					; sub_10006035+2Fj
		call	sub_10005C56
		xor	eax, eax
		jmp	short loc_10006066
sub_10006035	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10006073	proc near		; CODE XREF: realloc:loc_100023B5p
					; free+104j ...

var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 1Ch
		push	ebx
		push	esi
		push	edi
		mov	ebx, offset stru_1001AAB0
		mov	esi, ecx
		push	ebx		; lpCriticalSection
		call	ds:EnterCriticalSection
		lea	edx, [ebp+var_1C]
		mov	[ebp+var_C], esi
		call	sub_10005E22
		mov	esi, eax
		mov	ecx, offset dword_1001AACC
		mov	edx, esi
		call	sub_10005E64
		add	dword_1001AAF8,	1
		mov	edi, 0FFF00000h
		mov	ecx, [esi+14h]
		adc	dword_1001AAFC,	0
		sub	dword_1001AAAC,	ecx
		add	ecx, 0FFFFFh
		and	ecx, edi
		sub	dword_1001AB48,	ecx
		push	ebx		; lpCriticalSection
		call	ds:LeaveCriticalSection
		mov	edx, [esi+14h]
		mov	ecx, [esi+10h]
		add	edx, 0FFFFFh
		and	edx, edi
		call	sub_1000600C
		mov	ecx, esi
		call	sub_100060F5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
sub_10006073	endp


; =============== S U B	R O U T	I N E =======================================


sub_100060F5	proc near		; CODE XREF: sub_10005AAE+D9p
					; sub_10005C6D+ABp ...
		push	esi
		push	edi
		mov	edi, offset stru_1001AB98
		mov	esi, ecx
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	eax, dword_1001ABB8
		push	edi		; lpCriticalSection
		mov	[esi], eax
		mov	dword_1001ABB8,	esi
		call	ds:LeaveCriticalSection
		pop	edi
		pop	esi
		retn
sub_100060F5	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000611C	proc near		; CODE XREF: sub_1000613A+2Cp
					; sub_1000613A+5Bp ...
		push	esi
		mov	esi, edx
		push	edi
		mov	ecx, esi
		call	sub_10005F8F
		push	esi		; size_t
		mov	edi, eax
		push	0		; int
		push	edi		; void *
		call	memset
		add	esp, 0Ch
		mov	eax, edi
		pop	edi
		pop	esi
		retn
sub_1000611C	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000613A	proc near		; CODE XREF: sub_100066AB+1A0p
		push	ebx
		push	ebp
		mov	eax, 1000h
		bsf	eax, eax
		push	esi
		push	edi
		jz	short loc_100061A8
		lea	ebp, [eax+1]

loc_1000614B:				; CODE XREF: sub_1000613A+70j
		dec	ebp
		xor	edx, edx
		push	0Ch
		pop	eax
		div	ebp
		mov	ebx, eax
		mov	edi, edx
		imul	eax, ebp
		cmp	eax, 0Ch
		jnz	short loc_100061AC

loc_1000615F:				; CODE XREF: sub_1000613A+73j
		lea	edx, ds:20h[ebx*4]
		call	sub_1000611C
		mov	esi, eax
		test	esi, esi
		jz	short loc_100061AF
		mov	ecx, esi	; lpCriticalSection
		call	sub_100068A1
		mov	eax, ebx
		mov	[esi+1Ch], ebx
		imul	eax, ebp
		cmp	eax, 0Ch
		ja	short loc_100061B3
		mov	[esi+20h], ebp

loc_10006188:				; CODE XREF: sub_1000613A+7Cj
		cmp	ebx, 1
		ja	short loc_100061B8

loc_1000618D:				; CODE XREF: sub_1000613A+88j
		mov	ecx, [esi+20h]
		push	4
		pop	edx
		shl	edx, cl
		call	sub_1000611C
		mov	[esi+18h], eax
		neg	eax
		sbb	eax, eax
		and	eax, esi

loc_100061A3:				; CODE XREF: sub_1000613A+77j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_100061A8:				; CODE XREF: sub_1000613A+Cj
		xor	ebp, ebp
		jmp	short loc_1000614B
; ---------------------------------------------------------------------------

loc_100061AC:				; CODE XREF: sub_1000613A+23j
		inc	ebx
		jmp	short loc_1000615F
; ---------------------------------------------------------------------------

loc_100061AF:				; CODE XREF: sub_1000613A+35j
		xor	eax, eax
		jmp	short loc_100061A3
; ---------------------------------------------------------------------------

loc_100061B3:				; CODE XREF: sub_1000613A+49j
		mov	[esi+20h], edi
		jmp	short loc_10006188
; ---------------------------------------------------------------------------

loc_100061B8:				; CODE XREF: sub_1000613A+51j
		lea	edi, [esi+24h]
		mov	eax, ebp
		lea	ecx, [ebx-1]
		rep stosd
		jmp	short loc_1000618D
sub_1000613A	endp


; =============== S U B	R O U T	I N E =======================================


sub_100061C4	proc near		; CODE XREF: sub_100062B7+87p

; FUNCTION CHUNK AT 1000CC09 SIZE 00000016 BYTES

		push	ebx
		push	ebp
		mov	ebp, edx
		lea	ebx, [ecx+4]
		push	esi
		mov	esi, [ebp+8]
		cmp	esi, ebx
		jnz	loc_1000CC0E
		push	edi
		mov	edi, [ecx]
		mov	esi, ebx

loc_100061DC:				; CODE XREF: sub_100061C4+39j
					; sub_100061C4+43j
		push	edi
		push	ebp
		call	sub_10005F71
		pop	ecx
		pop	ecx
		test	eax, eax
		js	short loc_100061FA
		jg	short loc_100061FF
		pop	edi

loc_100061EC:				; CODE XREF: sub_100061C4+6A56j
		mov	eax, esi
		sub	eax, ebx
		neg	eax
		sbb	eax, eax
		and	eax, esi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_100061FA:				; CODE XREF: sub_100061C4+23j
		mov	edi, [edi+8]
		jmp	short loc_100061DC
; ---------------------------------------------------------------------------

loc_100061FF:				; CODE XREF: sub_100061C4+25j
		mov	esi, edi
		mov	edi, [edi+0Ch]
		and	edi, 0FFFFFFFEh
		jmp	short loc_100061DC
sub_100061C4	endp


; =============== S U B	R O U T	I N E =======================================


sub_10006209	proc near		; CODE XREF: sub_10005AAE+9Cp
					; sub_100062B7+6E4Dp ...

var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h

; FUNCTION CHUNK AT 1000CC1F SIZE 00000496 BYTES

		sub	esp, 34h
		push	ebx
		mov	eax, ecx
		mov	[esp+38h+var_28], edx
		push	ebp
		push	esi
		push	edi
		mov	esi, [eax]
		lea	ebp, [eax+4]
		mov	[esp+44h+var_20], eax
		lea	edi, [esp+44h+var_1C]
		mov	eax, ebp
		mov	[esp+44h+var_1C], esi
		and	eax, 0FFFFFFFEh
		mov	[esp+44h+var_34], ebp
		push	esi
		push	edx
		mov	[esp+4Ch+var_18], eax
		call	sub_10006282
		xor	ebx, ebx
		mov	[esp+4Ch+var_2C], eax
		pop	ecx
		inc	ebx
		pop	ecx
		test	eax, eax
		js	loc_1000CC1F
		jnz	loc_1000CD0B
		mov	eax, [esi+4]
		and	eax, 0FFFFFFFEh
		cmp	eax, ebp
		jnz	loc_1000CCFD
		mov	edx, [esi]
		cmp	edx, ebp
		jnz	loc_1000CCCA
		mov	edx, ebp

loc_1000626C:				; CODE XREF: sub_10006209+6AEFj
		mov	[esp+44h+var_1C], edx

loc_10006270:				; CODE XREF: sub_10006209+6C2Cj
					; sub_10006209+6E4Fj ...
		mov	ecx, [esp+44h+var_20]
		mov	eax, [esp+44h+var_1C]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], eax
		pop	ebx
		add	esp, 34h
		retn
sub_10006209	endp


; =============== S U B	R O U T	I N E =======================================


sub_10006282	proc near		; CODE XREF: sub_10005BB9+1Ap
					; sub_10006209+2Dp ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		push	esi
		mov	esi, [esp+4+arg_4]
		mov	eax, [ecx+14h]
		cmp	[esi+14h], eax
		sbb	edx, edx
		neg	edx
		cmp	eax, [esi+14h]
		sbb	eax, eax
		neg	eax
		sub	edx, eax
		jnz	short loc_100062B3
		mov	ecx, [ecx+10h]
		cmp	[esi+10h], ecx
		sbb	edx, edx
		neg	edx
		cmp	ecx, [esi+10h]
		sbb	ecx, ecx
		neg	ecx
		sub	edx, ecx

loc_100062B3:				; CODE XREF: sub_10006282+1Cj
		mov	eax, edx
		pop	esi
		retn
sub_10006282	endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_100062B7(LPVOID lpAddress, int)
sub_100062B7	proc near		; CODE XREF: sub_1000600C+1Fp

var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
lpAddress	= dword	ptr  4
arg_4		= dword	ptr  8

; FUNCTION CHUNK AT 1000D0B5 SIZE 000000D7 BYTES

		sub	esp, 1Ch
		mov	edx, [esp+1Ch+arg_4]
		mov	ecx, [esp+1Ch+lpAddress] ; lpAddress
		push	ebx
		push	ebp
		push	esi
		push	edi
		call	sub_10005837
		call	sub_10005DE5
		push	offset stru_1001AB78 ; lpCriticalSection
		mov	ebp, eax
		xor	ebx, ebx
		call	ds:EnterCriticalSection
		mov	eax, [esp+2Ch+arg_4]
		mov	esi, ebx
		mov	ecx, [esp+2Ch+lpAddress]
		mov	edi, dword_1001AB58
		lea	edx, [ecx+eax]
		mov	[esp+2Ch+var_C], edx
		cmp	edi, offset dword_1001AB5C
		jnz	loc_1000D0B5

loc_10006302:				; CODE XREF: sub_100062B7+6E36j
		test	esi, esi
		jnz	loc_1000D0F2

loc_1000630A:				; CODE XREF: sub_100062B7+6E3Ej
		test	ebp, ebp
		jz	short loc_10006357
		mov	esi, ebp
		mov	ebp, ebx
		mov	edx, esi
		mov	[esi+10h], ecx
		mov	ecx, offset dword_1001AB58
		mov	[esi+14h], eax
		mov	dword ptr [esi+18h], 1
		call	sub_10005D21
		mov	ecx, offset dword_1001AB04

loc_10006330:				; CODE XREF: sub_100062B7+6E6Dj
		mov	edx, esi
		call	sub_10006386
		mov	edx, esi
		mov	ecx, offset dword_1001AB58
		call	sub_100061C4
		mov	edi, eax
		test	edi, edi
		jnz	loc_1000D129

loc_1000634D:				; CODE XREF: sub_100062B7+6E7Cj
					; sub_100062B7+6ED0j
		mov	eax, [esp+2Ch+arg_4]
		add	dword_1001AB94,	eax

loc_10006357:				; CODE XREF: sub_100062B7+55j
		push	offset stru_1001AB78 ; lpCriticalSection
		call	ds:LeaveCriticalSection
		test	ebp, ebp
		jnz	short loc_10006372

loc_10006366:				; CODE XREF: sub_100062B7+C2j
		pop	edi
		pop	esi
		pop	ebp
		test	ebx, ebx
		jnz	short loc_1000637B
		pop	ebx
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_10006372:				; CODE XREF: sub_100062B7+ADj
		mov	ecx, ebp
		call	sub_100060F5
		jmp	short loc_10006366
; ---------------------------------------------------------------------------

loc_1000637B:				; CODE XREF: sub_100062B7+B4j
		mov	ecx, ebx
		pop	ebx
		add	esp, 1Ch
		jmp	sub_100060F5
sub_100062B7	endp


; =============== S U B	R O U T	I N E =======================================


sub_10006386	proc near		; CODE XREF: sub_100062B7+7Bp
					; sub_10005AAE+6B9Dp ...

var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h

; FUNCTION CHUNK AT 1000D18C SIZE 000000E3 BYTES

		sub	esp, 24h
		push	ebx
		push	ebp
		push	esi
		mov	esi, ecx
		mov	[esp+30h+var_24], edx
		xor	ecx, ecx
		mov	[esp+30h+var_20], esi
		push	edi
		lea	edi, [esp+34h+var_1C]
		mov	eax, [esi]
		lea	ebp, [esi+4]
		mov	esi, [esi]
		mov	ebx, ebp
		mov	[esp+34h+var_1C], eax
		mov	eax, ebp
		and	eax, 0FFFFFFFEh
		mov	[esp+34h+var_18], eax

loc_100063B3:				; CODE XREF: sub_10006386+6E96j
		cmp	esi, ebp
		jnz	loc_1000D18C
		xor	esi, esi
		mov	[edx], ebp
		inc	esi
		or	ebp, esi
		mov	[edx+4], ebp
		test	ecx, ecx
		jg	loc_1000D221
		mov	[edi], edx

loc_100063CF:				; CODE XREF: sub_10006386+6EC8j
					; sub_10006386+6ED7j ...
		mov	eax, [esp+34h+var_1C]
		mov	ecx, [esp+34h+var_20]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], eax
		and	dword ptr [eax+4], 0FFFFFFFEh
		pop	ebx
		add	esp, 24h
		retn
sub_10006386	endp


; =============== S U B	R O U T	I N E =======================================


sub_100063E5	proc near		; CODE XREF: sub_10005F8F+4Bp
		push	esi
		push	edi
		mov	edi, ecx
		mov	edx, 100000h
		push	0		; char
		push	1		; int
		lea	esi, [edi+0FFFFFh]
		and	esi, 0FFF00000h
		mov	ecx, esi	; dwSize
		call	sub_100059AC
		pop	ecx
		pop	ecx
		mov	ecx, eax
		mov	dword_1001AB90,	ecx
		test	ecx, ecx
		jz	short loc_10006453
		add	edi, 0FFFh
		mov	dword_1001AAEC,	ecx
		and	edi, 0FFFFF000h
		lea	eax, [ecx+esi]
		add	ecx, edi	; lpAddress
		mov	dword_1001AB28,	eax
		mov	lpAddress, ecx
		cmp	edi, esi
		jnb	short loc_10006442
		mov	edx, esi
		sub	edx, edi
		call	sub_10005837

loc_10006442:				; CODE XREF: sub_100063E5+52j
		add	dword_1001ABB0,	esi
		add	dword_1001AAF0,	edi
		xor	eax, eax

loc_10006450:				; CODE XREF: sub_100063E5+71j
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_10006453:				; CODE XREF: sub_100063E5+2Cj
		xor	eax, eax
		inc	eax
		jmp	short loc_10006450
sub_100063E5	endp


; =============== S U B	R O U T	I N E =======================================


sub_10006458	proc near		; CODE XREF: sub_100068B3+1Ap

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		sub	esp, 10h
		push	ebp
		mov	ebp, ecx
		mov	[esp+14h+var_10], ebp
		call	sub_100068A1
		test	eax, eax
		jnz	loc_100065CC
		push	ebx
		push	esi
		push	edi
		push	68h		; size_t
		push	eax		; int
		lea	eax, [ebp+18h]
		push	eax		; void *
		call	memset
		lea	eax, [ebp+84h]
		add	esp, 0Ch
		mov	[ebp+80h], eax
		mov	edx, 1000h
		mov	[ebp+88h], eax
		and	eax, 0FFFFFFFEh
		mov	[ebp+8Ch], eax
		lea	eax, [ebp+0ACh]
		and	dword ptr [ebp+0A0h], 0
		and	dword ptr [ebp+0A4h], 0
		mov	[ebp+0A8h], eax
		mov	[eax], eax
		and	eax, 0FFFFFFFEh
		mov	[ebp+0B0h], eax
		xor	ebx, ebx
		lea	eax, [ebp+0C0h]
		mov	ebp, eax

loc_100064D0:				; CODE XREF: sub_10006458+AFj
		and	dword ptr [ebp-8], 0
		mov	eax, ebp
		and	eax, 0FFFFFFFEh
		mov	[ebp-4], ebp
		mov	[ebp+4], eax
		inc	ebx
		xor	eax, eax
		mov	[ebp+0], ebp
		inc	eax
		mov	ecx, ebx
		shl	eax, cl
		lea	ecx, [ebp-8]
		mov	[ebp+0Ch], eax
		call	sub_100065D1
		push	8
		lea	edi, [ebp+20h]
		mov	edx, eax
		xor	eax, eax
		add	ebp, 48h
		pop	ecx
		rep stosd
		cmp	ebx, 3
		jb	short loc_100064D0
		mov	ebp, [esp+20h+var_10]
		push	23h
		pop	esi
		cmp	ebx, esi
		jnb	short loc_10006576
		mov	eax, ebx
		add	ebp, 0C0h
		shl	eax, 4
		sub	esi, ebx
		sub	eax, 20h
		mov	[esp+20h+var_8], eax
		imul	eax, ebx, 48h
		add	eax, ebp
		add	ebx, esi
		mov	[esp+20h+var_4], ebx
		mov	ebp, eax
		mov	ebx, [esp+20h+var_8]
		mov	[esp+20h+var_C], eax

loc_1000653D:				; CODE XREF: sub_10006458+114j
		lea	ecx, [ebp-8]
		mov	eax, ebp
		and	dword ptr [ecx], 0
		and	eax, 0FFFFFFFEh
		mov	[ebp-4], ebp
		mov	[ebp+0], ebp
		mov	[ebp+4], eax
		mov	[ebp+0Ch], ebx
		call	sub_100065D1
		push	8
		lea	edi, [ebp+20h]
		mov	edx, eax
		xor	eax, eax
		add	ebx, 10h
		pop	ecx
		add	ebp, 48h
		rep stosd
		dec	esi
		jnz	short loc_1000653D
		mov	ebx, [esp+20h+var_4]
		mov	ebp, [esp+20h+var_10]

loc_10006576:				; CODE XREF: sub_10006458+BAj
		cmp	ebx, 25h
		jnb	short loc_100065C2
		imul	eax, ebx, 48h
		add	ebp, 0C0h
		add	ebp, eax

loc_10006586:				; CODE XREF: sub_10006458+168j
		and	dword ptr [ebp-8], 0
		lea	ecx, [ebx-22h]
		mov	eax, ebp
		mov	[ebp-4], ebp
		and	eax, 0FFFFFFFEh
		mov	[ebp+0], ebp
		mov	[ebp+4], eax
		mov	eax, 200h
		shl	eax, cl
		lea	ecx, [ebp-8]
		mov	[ebp+0Ch], eax
		call	sub_100065D1
		mov	edx, eax
		lea	edi, [ebp+20h]
		xor	eax, eax
		add	ebp, 48h
		push	8
		inc	ebx
		pop	ecx
		rep stosd
		cmp	ebx, 25h
		jb	short loc_10006586

loc_100065C2:				; CODE XREF: sub_10006458+121j
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx

loc_100065C7:				; CODE XREF: sub_10006458+177j
		pop	ebp
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_100065CC:				; CODE XREF: sub_10006458+11j
		xor	eax, eax
		inc	eax
		jmp	short loc_100065C7
sub_10006458	endp


; =============== S U B	R O U T	I N E =======================================


sub_100065D1	proc near		; CODE XREF: sub_10006458+98p
					; sub_10006458+FCp ...

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		sub	esp, 14h
		push	ebx
		push	ebp
		mov	ebp, edx
		xor	edx, edx
		push	esi
		push	edi
		mov	edi, ecx
		lea	eax, [ebp-10h]
		mov	ecx, [edi+14h]
		div	ecx
		lea	edx, [eax+1]
		imul	ecx, edx

loc_100065EC:				; CODE XREF: sub_100065D1+3Cj
		sub	ecx, [edi+14h]
		dec	edx
		test	dl, 1Fh
		mov	esi, edx
		push	0
		pop	eax
		setnz	al
		mov	ebx, ebp
		shr	esi, 5
		sub	ebx, ecx
		add	esi, eax
		lea	eax, ds:0Ch[esi*4]
		cmp	eax, ebx
		ja	short loc_100065EC
		imul	eax, ebp, 3Dh

loc_10006612:				; CODE XREF: sub_100065D1+B4j
		mov	ecx, [edi+14h]
		add	eax, 3D000h
		mov	[esp+24h+var_10], ebp
		add	ebp, 1000h
		mov	[esp+24h+var_C], edx
		xor	edx, edx
		mov	[esp+24h+var_14], eax
		mov	[esp+24h+var_8], esi
		lea	eax, [ebp-10h]
		mov	[esp+24h+var_4], ebx
		div	ecx
		lea	edx, [eax+1]

loc_1000663E:				; CODE XREF: sub_100065D1+90j
		dec	edx
		mov	ebx, ebp
		test	dl, 1Fh
		mov	esi, edx
		push	0
		pop	eax
		setnz	al
		shr	esi, 5
		add	esi, eax
		mov	eax, ecx
		imul	eax, edx
		sub	ebx, eax
		lea	eax, ds:0Ch[esi*4]
		cmp	eax, ebx
		ja	short loc_1000663E
		cmp	[esp+24h+var_14], 3CC3000h
		ja	short loc_10006687
		imul	eax, ecx, 1E8h
		cmp	eax, 1800h
		jbe	short loc_10006687
		mov	eax, [esp+24h+var_14]
		mov	ecx, ebx
		shl	ecx, 0Ch
		cmp	ecx, eax
		ja	short loc_10006612

loc_10006687:				; CODE XREF: sub_100065D1+9Aj
					; sub_100065D1+A7j
		mov	ecx, [esp+24h+var_C]
		mov	eax, [esp+24h+var_10]
		mov	[edi+1Ch], ecx
		mov	ecx, [esp+24h+var_8]
		mov	[edi+20h], ecx
		mov	ecx, [esp+24h+var_4]
		mov	[edi+18h], eax
		mov	[edi+24h], ecx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
sub_100065D1	endp


; =============== S U B	R O U T	I N E =======================================


sub_100066AB	proc near		; CODE XREF: DllMain(x,x,x)+10p

var_134		= byte ptr -134h
var_133		= byte ptr -133h
SystemInfo	= _SYSTEM_INFO ptr -130h
var_10C		= byte ptr -10Ch
var_4		= dword	ptr -4

; FUNCTION CHUNK AT 1000D26F SIZE 0000017A BYTES

		sub	esp, 134h
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+134h+var_4], eax
		cmp	dword_1001A808,	0
		jnz	loc_10006892
		call	ds:TlsAlloc
		mov	dwTlsIndex, eax
		lea	eax, [esp+134h+SystemInfo]
		push	eax		; lpSystemInfo
		call	ds:GetSystemInfo
		xor	edx, edx
		mov	eax, 1000h
		div	[esp+134h+SystemInfo.dwPageSize]
		test	edx, edx
		jnz	loc_1000D26F
		push	ebx
		push	ebp
		xor	ebx, ebx
		push	esi
		mov	ebp, ebx
		push	edi

loc_100066FD:				; CODE XREF: sub_100066AB+82j
		mov	eax, ebp
		sub	eax, ebx
		jz	short loc_10006716
		dec	eax
		jnz	loc_10006878
		call	sub_100068E8
		mov	esi, eax
		jmp	loc_10006885
; ---------------------------------------------------------------------------

loc_10006716:				; CODE XREF: sub_100066AB+56j
					; sub_100066AB+1CEj ...
		lea	esi, [esp+144h+var_10C]
		mov	[esp+144h+var_10C], bl

loc_1000671E:				; CODE XREF: sub_100066AB+1DCj
		cmp	byte ptr [esi],	0
		mov	edi, ebx
		jnz	loc_10006896

loc_10006729:				; CODE XREF: sub_100066AB+6CE7j
		inc	ebp
		cmp	ebp, 3
		jb	short loc_100066FD
		mov	ecx, offset stru_1001AB78 ; lpCriticalSection
		mov	dword_1001AB94,	ebx
		call	sub_100068A1
		mov	eax, offset dword_1001AB08
		mov	ecx, offset stru_1001AAB0 ; lpCriticalSection
		mov	dword_1001AB04,	eax
		mov	dword_1001AB08,	eax
		and	eax, 0FFFFFFFEh
		mov	dword_1001AB0C,	eax
		mov	eax, offset dword_1001AB5C
		mov	dword_1001AB58,	eax
		mov	dword_1001AB64,	eax
		and	eax, 0FFFFFFFEh
		mov	dword_1001AB68,	eax
		call	sub_100068A1
		mov	eax, offset dword_1001AAD0
		mov	dword_1001AB50,	ebx
		mov	dword_1001AACC,	eax
		mov	ecx, offset stru_1001AB98 ; lpCriticalSection
		mov	dword_1001AAD8,	eax
		and	eax, 0FFFFFFFEh
		mov	dword_1001AADC,	eax
		mov	dword_1001AB54,	ebx
		mov	dword_1001AAF8,	ebx
		mov	dword_1001AAFC,	ebx
		mov	dword_1001AAAC,	ebx
		mov	dword_1001AB48,	ebx
		mov	dword_1001ABB0,	ebx
		mov	dword_1001AAF0,	ebx
		mov	dword_1001ABB8,	ebx
		call	sub_100068A1
		mov	ecx, dword_1001AC88
		xor	ebp, ebp
		inc	ebp
		mov	edx, ebp
		mov	dword_1001AB2C,	edx
		pop	edi
		pop	esi
		test	ecx, ecx
		jg	loc_1000D397
		js	loc_1000D3BE

loc_100067EF:				; CODE XREF: sub_100066AB+6D06j
					; sub_100066AB+6D1Bj ...
		mov	ecx, edx
		mov	dword_1001AB24,	ebx
		shl	ecx, 2
		call	sub_10005F8F
		mov	ecx, eax
		mov	dword_1001AB00,	ecx
		test	ecx, ecx
		jz	loc_1000689D
		mov	eax, dword_1001AB2C
		shl	eax, 2
		push	eax		; size_t
		push	ebx		; int
		push	ecx		; void *
		call	memset
		add	esp, 0Ch
		xor	ecx, ecx
		call	sub_100068B3
		mov	eax, dword_1001AB00
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_1000689D
		push	eax		; lpTlsValue
		push	dwTlsIndex	; dwTlsIndex
		call	ds:TlsSetValue
		mov	ecx, offset stru_1001AB30 ; lpCriticalSection
		call	sub_100068A1
		call	sub_1000613A
		mov	lpCriticalSection, eax
		test	eax, eax
		jz	short loc_1000689D
		mov	dword_1001A808,	ebp
		xor	eax, eax

loc_10006861:				; CODE XREF: sub_100066AB+1F4j
		pop	ebp
		pop	ebx

loc_10006863:				; CODE XREF: sub_100066AB+1E9j
		mov	ecx, [esp+134h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 134h
		retn
; ---------------------------------------------------------------------------

loc_10006878:				; CODE XREF: sub_100066AB+59j
		dec	eax
		jnz	loc_10006716
		mov	esi, _malloc_options

loc_10006885:				; CODE XREF: sub_100066AB+66j
		test	esi, esi
		jnz	loc_1000671E
		jmp	loc_10006716
; ---------------------------------------------------------------------------

loc_10006892:				; CODE XREF: sub_100066AB+1Bj
		xor	eax, eax
		jmp	short loc_10006863
; ---------------------------------------------------------------------------

loc_10006896:				; CODE XREF: sub_100066AB+78j
					; sub_100066AB+6CE1j
		xor	ecx, ecx
		jmp	loc_1000D28E
; ---------------------------------------------------------------------------

loc_1000689D:				; CODE XREF: sub_100066AB+15Ej
					; sub_100066AB+187j ...
		mov	eax, ebp
		jmp	short loc_10006861
sub_100066AB	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_100068A1(LPCRITICAL_SECTION lpCriticalSection)
sub_100068A1	proc near		; CODE XREF: sub_1000613A+39p
					; sub_10006458+Ap ...
		push	1388h		; dwSpinCount
		push	ecx		; lpCriticalSection
		call	ds:InitializeCriticalSectionAndSpinCount
		neg	eax
		sbb	eax, eax
		inc	eax
		retn
sub_100068A1	endp


; =============== S U B	R O U T	I N E =======================================


sub_100068B3	proc near		; CODE XREF: sub_100066AB+179p
					; sub_100016CF+AA1Cp

; FUNCTION CHUNK AT 1000D3E9 SIZE 00000034 BYTES

		push	esi
		push	edi
		mov	edi, ecx
		mov	ecx, 0B20h
		call	sub_10005F8F
		mov	esi, eax
		test	esi, esi
		jz	loc_1000D3E9
		mov	ecx, esi
		call	sub_10006458
		test	eax, eax
		jnz	loc_1000D3E9
		mov	ecx, dword_1001AB00
		mov	eax, esi
		mov	[ecx+edi*4], esi

loc_100068E5:				; CODE XREF: sub_100068B3+6B65j
		pop	edi
		pop	esi
		retn
sub_100068B3	endp


; =============== S U B	R O U T	I N E =======================================


sub_100068E8	proc near		; CODE XREF: sub_100066AB+5Fp
		push	esi
		push	40h		; nSize
		mov	esi, offset Buffer
		push	esi		; lpBuffer
		push	offset Name	; "MALLOC_OPTIONS"
		call	ds:GetEnvironmentVariableA
		xor	ecx, ecx
		cmp	ecx, eax
		sbb	eax, eax
		and	eax, esi
		pop	esi
		retn
sub_100068E8	endp


; =============== S U B	R O U T	I N E =======================================


; int __usercall sub_10006906@<eax>(void *@<ecx>, size_t@<edx>,	int)
sub_10006906	proc near		; CODE XREF: realloc+642p
					; sub_1000C2B6+5p

var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000D41D SIZE 000000C9 BYTES

		sub	esp, 1Ch
		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+28h+arg_0]
		mov	ebp, ecx
		push	edi
		mov	edi, edx
		cmp	esi, 0FF000h
		ja	loc_1000D41D

loc_10006921:				; CODE XREF: sub_10006906+6B2Bj
		push	0
		mov	edx, 100000h
		mov	ecx, edi
		call	sub_10005C6D
		mov	ebx, eax
		pop	ecx
		test	ebx, ebx
		jz	short loc_10006958
		cmp	edi, esi
		jb	short loc_1000693C
		mov	edi, esi

loc_1000693C:				; CODE XREF: sub_10006906+32j
		push	edi		; size_t
		push	ebp		; void *
		push	ebx		; void *
		call	memcpy
		add	esp, 0Ch
		mov	ecx, ebp	; void *
		call	sub_1000695C
		mov	eax, ebx

loc_10006950:				; CODE XREF: sub_10006906+54j
					; sub_10006906+6BDBj
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_10006958:				; CODE XREF: sub_10006906+2Ej
		xor	eax, eax
		jmp	short loc_10006950
sub_10006906	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_1000695C(void *)
sub_1000695C	proc near		; CODE XREF: sub_10006906+43p

; FUNCTION CHUNK AT 1000D4E6 SIZE 00000020 BYTES

		mov	edx, ecx
		and	edx, 0FFFFFh
		jnz	loc_1000696F
		jmp	sub_10006073
; ---------------------------------------------------------------------------

loc_1000696F:				; CODE XREF: sub_1000695C+8j
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	ebx, ecx
		mov	edi, ebx
		sub	edi, edx
		shr	edx, 0Ch
		imul	ebp, edx, 0Ch
		mov	esi, [edi]
		add	ebp, 10h
		add	ebp, edi
		test	byte ptr [ebp+8], 2
		jz	loc_1000D4E6
		push	ebx		; void *
		mov	edx, edi
		mov	ecx, esi	; lpCriticalSection
		call	sub_100049E0
		pop	ecx

loc_1000699B:				; CODE XREF: sub_1000695C+6BA5j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
sub_1000695C	endp

; Exported entry  37. ?HashBytes@mozilla@@YAIPBXI@Z

; =============== S U B	R O U T	I N E =======================================


; unsigned int __cdecl mozilla::HashBytes(mozilla *this, const void *, unsigned	int)
		public ?HashBytes@mozilla@@YAIPBXI@Z
?HashBytes@mozilla@@YAIPBXI@Z proc near	; DATA XREF: .rdata:off_100175A8o

this		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		xor	eax, eax
		push	esi
		mov	ecx, ebx
		mov	esi, ebx
		and	ecx, 3
		xor	edx, edx
		push	edi
		mov	edi, [esp+0Ch+this]
		sub	esi, ecx
		jz	short loc_100069DF
		lea	ebx, [ebx+0]

loc_100069C0:				; CODE XREF: mozilla::HashBytes(void const *,uint)+3Dj
		rol	eax, 5
		xor	eax, [edx+edi]
		add	edx, 4
		imul	eax, 9E3779B9h
		rol	eax, 5
		xor	eax, 4
		imul	eax, 9E3779B9h
		cmp	edx, esi
		jb	short loc_100069C0

loc_100069DF:				; CODE XREF: mozilla::HashBytes(void const *,uint)+18j
		cmp	edx, ebx
		jb	short loc_100069E7

loc_100069E3:				; CODE XREF: mozilla::HashBytes(void const *,uint)+5Bj
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_100069E7:				; CODE XREF: mozilla::HashBytes(void const *,uint)+41j
					; mozilla::HashBytes(void const	*,uint)+59j
		movsx	ecx, byte ptr [edx+edi]
		inc	edx
		rol	eax, 5
		xor	eax, ecx
		imul	eax, 9E3779B9h
		cmp	edx, ebx
		jb	short loc_100069E7
		jmp	short loc_100069E3
?HashBytes@mozilla@@YAIPBXI@Z endp

; Exported entry  40. ?ProcessCreation@TimeStamp@mozilla@@SA?AV12@AA_N@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static class mozilla::TimeStamp __cdecl mozilla::TimeStamp::ProcessCreation(bool &)
		public ?ProcessCreation@TimeStamp@mozilla@@SA?AV12@AA_N@Z
?ProcessCreation@TimeStamp@mozilla@@SA?AV12@AA_N@Z proc	near
					; DATA XREF: .rdata:off_100175A8o

var_70		= qword	ptr -70h
var_5C		= dword	ptr -5Ch
var_58		= qword	ptr -58h
var_50		= byte ptr -50h
var_48		= byte ptr -48h
var_30		= byte ptr -30h
var_18		= byte ptr -18h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

; FUNCTION CHUNK AT 1000D506 SIZE 0000002B BYTES

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		mov	eax, [ebp+arg_4]
		sub	esp, 5Ch
		mov	ecx, offset dword_1001AA68
		push	ebx
		push	esi
		push	edi
		mov	byte ptr [eax],	0
		call	sub_10006B4F
		test	al, al
		jnz	short loc_10006A33

loc_10006A1D:				; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+F5j
		mov	eax, [ebp+arg_0]
		mov	esi, offset dword_1001AA68
		push	6
		pop	ecx
		mov	edi, eax
		rep movsd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10006A33:				; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+1Ej
		push	offset aMoz_app_restar ; "MOZ_APP_RESTART"
		call	ds:getenv
		pop	ecx
		test	eax, eax
		jnz	loc_1000D506

loc_10006A47:				; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+6B1Bj
		lea	ecx, [esp+68h+var_30]
		call	sub_10006E33
		call	?ComputeProcessUptime@TimeStamp@mozilla@@CA_KXZ	; mozilla::TimeStamp::ComputeProcessUptime(void)
		mov	ebx, eax
		mov	eax, edx
		mov	ecx, eax
		mov	dword ptr [esp+68h+var_58], ebx
		mov	esi, ecx
		mov	[esp+68h+var_5C], eax
		and	ecx, 7FFFFFFFh
		and	esi, 80000000h
		mov	dword ptr [esp+68h+var_58+4], ecx
		fild	[esp+68h+var_58]
		and	dword ptr [esp+68h+var_58], 0
		mov	dword ptr [esp+68h+var_58+4], esi
		push	ecx
		fild	[esp+6Ch+var_58]
		push	ecx
		lea	ecx, [esp+70h+var_50]
		fchs
		faddp	st(1), st
		fstp	[esp+70h+var_58]
		fld	[esp+70h+var_58]
		fdiv	ds:dbl_100164C0
		fstp	[esp+70h+var_70] ; double
		call	sub_10006C83
		pop	ecx
		pop	ecx
		lea	eax, [esp+68h+var_50]
		push	eax
		lea	eax, [esp+6Ch+var_18]
		push	eax
		lea	ecx, [esp+70h+var_30]
		call	sub_10006B02
		push	6
		pop	ecx
		mov	esi, eax
		lea	edi, [esp+68h+var_48]
		rep movsd
		push	offset dword_1001AA50
		lea	ecx, [esp+6Ch+var_48]
		call	??GTimeStampValue@mozilla@@QBE_KABV01@@Z ; mozilla::TimeStampValue::operator-(mozilla::TimeStampValue const &)
		test	edx, edx
		jg	short loc_10006AF7
		jl	short loc_10006ADE
		test	eax, eax
		jnz	short loc_10006AF7

loc_10006ADE:				; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+DBj
		or	ebx, [esp+68h+var_5C]
		jz	short loc_10006AF7

loc_10006AE4:				; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+6B2Fj
		push	6
		pop	ecx
		lea	esi, [esp+68h+var_48]
		mov	edi, offset dword_1001AA68
		rep movsd
		jmp	loc_10006A1D
; ---------------------------------------------------------------------------

loc_10006AF7:				; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+D9j
					; mozilla::TimeStamp::ProcessCreation(bool &)+DFj ...
		mov	eax, [ebp+arg_4]
		mov	byte ptr [eax],	1
		jmp	loc_1000D51E
?ProcessCreation@TimeStamp@mozilla@@SA?AV12@AA_N@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10006B02	proc near		; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+B9p

var_18		= byte ptr -18h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		sub	esp, 1Ch
		push	ebx
		mov	ebx, ecx
		push	esi
		mov	esi, [eax]
		push	edi
		mov	edi, [eax+4]
		movzx	eax, byte ptr [ebx+10h]
		mov	edx, [ebx+8]
		mov	ecx, [ebx]
		sub	edx, esi
		push	eax		; bool
		mov	eax, [ebx+0Ch]
		sbb	eax, edi
		sub	ecx, esi
		push	eax
		mov	eax, [ebx+4]
		push	edx		; unsigned __int64
		sbb	eax, edi
		push	eax
		push	ecx		; unsigned __int64
		lea	ecx, [ebp+var_18] ; this
		call	??0TimeStampValue@mozilla@@AAE@_K0_N@Z ; mozilla::TimeStampValue::TimeStampValue(unsigned __int64,unsigned __int64,bool)
		mov	eax, [ebp+arg_0]
		lea	esi, [ebp+var_18]
		push	6
		pop	ecx
		mov	edi, eax
		rep movsd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
sub_10006B02	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10006B4F	proc near		; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+17p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= byte ptr -8
var_7		= byte ptr -7

		push	ebp
		mov	ebp, esp
		sub	esp, 1Ch
		xor	eax, eax
		push	ebx
		mov	[ebp+var_18], eax
		xor	ebx, ebx
		mov	[ebp+var_14], eax
		inc	ebx
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], al
		lea	eax, [ebp+var_18]
		push	eax
		mov	[ebp+var_7], bl
		call	??GTimeStampValue@mozilla@@QBE_KABV01@@Z ; mozilla::TimeStampValue::operator-(mozilla::TimeStampValue const &)
		or	eax, edx
		jz	short loc_10006B7C
		xor	ebx, ebx

loc_10006B7C:				; CODE XREF: sub_10006B4F+29j
		mov	al, bl
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
sub_10006B4F	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  27. ?CheckQPC@TimeStampValue@mozilla@@ABE_KABV12@@Z

; =============== S U B	R O U T	I N E =======================================


; unsigned __int64 __thiscall mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue	*this, const struct mozilla::TimeStampValue *)
		public ?CheckQPC@TimeStampValue@mozilla@@ABE_KABV12@@Z
?CheckQPC@TimeStampValue@mozilla@@ABE_KABV12@@Z	proc near
					; CODE XREF: mozilla::TimeStampValue::operator-(mozilla::TimeStampValue	const &)+Ej
					; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000D531 SIZE 0000015D BYTES

		mov	eax, [esp+arg_0]
		push	esi
		mov	esi, [ecx]
		push	edi
		sub	esi, [eax]
		mov	edi, [ecx+4]
		sbb	edi, [eax+4]
		cmp	byte ptr [ecx+10h], 0
		jz	short loc_10006BD2
		cmp	byte ptr [eax+10h], 0
		jz	short loc_10006BD2
		push	ebx
		mov	ebx, [ecx+8]
		sub	ebx, [eax+8]
		push	ebp
		mov	ebp, [ecx+0Ch]
		sbb	ebp, [eax+0Ch]
		cmp	byte_1001A80C, 0
		jz	loc_1000D531

loc_10006BC7:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+69C1j
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+69C9j ...
		mov	eax, ebx
		mov	edx, ebp

loc_10006BCB:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6AF9j
		pop	ebp
		pop	ebx
		pop	edi
		pop	esi
		retn	4
; ---------------------------------------------------------------------------

loc_10006BD2:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+14j
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+1Aj
		mov	edx, edi
		mov	eax, esi
		pop	edi
		pop	esi
		retn	4
?CheckQPC@TimeStampValue@mozilla@@ABE_KABV12@@Z	endp

; Exported entry  24. ??ZTimeStampValue@mozilla@@QAEAAV01@_J@Z

; =============== S U B	R O U T	I N E =======================================


; public: class	mozilla::TimeStampValue	& __thiscall mozilla::TimeStampValue::operator-=(__int64)
		public ??ZTimeStampValue@mozilla@@QAEAAV01@_J@Z
??ZTimeStampValue@mozilla@@QAEAAV01@_J@Z proc near ; DATA XREF:	.rdata:off_100175A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		sub	[ecx], edx
		mov	eax, [esp+arg_4]
		sbb	[ecx+4], eax
		sub	[ecx+8], edx
		sbb	[ecx+0Ch], eax
		mov	eax, ecx
		retn	8
??ZTimeStampValue@mozilla@@QAEAAV01@_J@Z endp

; Exported entry  22. ??YTimeStampValue@mozilla@@QAEAAV01@_J@Z

; =============== S U B	R O U T	I N E =======================================


; public: class	mozilla::TimeStampValue	& __thiscall mozilla::TimeStampValue::operator+=(__int64)
		public ??YTimeStampValue@mozilla@@QAEAAV01@_J@Z
??YTimeStampValue@mozilla@@QAEAAV01@_J@Z proc near ; DATA XREF:	.rdata:off_100175A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		add	[ecx], edx
		mov	eax, [esp+arg_4]
		adc	[ecx+4], eax
		add	[ecx+8], edx
		adc	[ecx+0Ch], eax
		mov	eax, ecx
		retn	8
??YTimeStampValue@mozilla@@QAEAAV01@_J@Z endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  13. ??GTimeStampValue@mozilla@@QBE_KABV01@@Z

; =============== S U B	R O U T	I N E =======================================


; public: unsigned __int64 __thiscall mozilla::TimeStampValue::operator-(class mozilla::TimeStampValue const &)const
		public ??GTimeStampValue@mozilla@@QBE_KABV01@@Z
??GTimeStampValue@mozilla@@QBE_KABV01@@Z proc near
					; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+D2p
					; sub_10006B4F+22p
					; DATA XREF: ...

arg_0		= dword	ptr  4

		cmp	byte ptr [ecx+11h], 0
		mov	eax, [esp+arg_0]
		jnz	short loc_10006C23

loc_10006C1A:				; CODE XREF: mozilla::TimeStampValue::operator-(mozilla::TimeStampValue	const &)+17j
		mov	[esp+arg_0], eax ; struct mozilla::TimeStampValue *
		jmp	?CheckQPC@TimeStampValue@mozilla@@ABE_KABV12@@Z	; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)
; ---------------------------------------------------------------------------

loc_10006C23:				; CODE XREF: mozilla::TimeStampValue::operator-(mozilla::TimeStampValue	const &)+8j
		cmp	byte ptr [eax+11h], 0
		jz	short loc_10006C1A
		xor	eax, eax
		xor	edx, edx
		retn	4
??GTimeStampValue@mozilla@@QBE_KABV01@@Z endp

; Exported entry   6. ??0TimeStampValue@mozilla@@AAE@_K0_N@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::TimeStampValue::TimeStampValue(mozilla::TimeStampValue *this, unsigned __int64, unsigned __int64, bool)
		public ??0TimeStampValue@mozilla@@AAE@_K0_N@Z
??0TimeStampValue@mozilla@@AAE@_K0_N@Z proc near ; CODE	XREF: sub_10006B02+32p
					; DATA XREF: .rdata:off_100175A8o

arg_0		= qword	ptr  8
arg_8		= qword	ptr  10h
arg_10		= byte ptr  18h

		push	ebp
		mov	ebp, esp
		mov	eax, dword ptr [ebp+arg_0]
		mov	[ecx], eax
		mov	eax, dword ptr [ebp+arg_0+4]
		mov	[ecx+4], eax
		mov	eax, dword ptr [ebp+arg_8]
		mov	[ecx+8], eax
		mov	eax, dword ptr [ebp+arg_8+4]
		mov	[ecx+0Ch], eax
		mov	al, [ebp+arg_10]
		mov	[ecx+10h], al
		mov	eax, ecx
		mov	byte ptr [ecx+11h], 0
		pop	ebp
		retn	14h
??0TimeStampValue@mozilla@@AAE@_K0_N@Z endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  49. ?ToSeconds@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@Z

; =============== S U B	R O U T	I N E =======================================


; double __cdecl mozilla::BaseTimeDurationPlatformUtils::ToSeconds(__int64)
		public ?ToSeconds@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@Z
?ToSeconds@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@Z proc near
					; DATA XREF: .rdata:off_100175A8o

arg_0		= qword	ptr  4

		fild	[esp+arg_0]
		fstp	[esp+arg_0]
		fld	[esp+arg_0]
		fild	qword_1001A810
		fstp	[esp+arg_0]
		fld	[esp+arg_0]
		fmul	ds:dbl_100164C0
		fdivp	st(1), st
		retn
?ToSeconds@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_10006C83(double)
sub_10006C83	proc near		; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+A4p

var_14		= qword	ptr -14h
var_8		= qword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ecx
		fld	[ebp+arg_0]
		push	esi
		mov	esi, ecx
		mov	dword ptr [ebp+var_8+4], 7FF00000h
		xor	ecx, ecx
		mov	dword ptr [ebp+var_8], ecx
		fld	[ebp+var_8]
		fucomp	st(1)
		fnstsw	ax
		test	ah, 44h
		jnp	short loc_10006CD4
		mov	dword ptr [ebp+arg_0], ecx
		mov	dword ptr [ebp+arg_0+4], 0FFF00000h
		fld	[ebp+arg_0]
		fucomp	st(1)
		fnstsw	ax
		test	ah, 44h
		jnp	short loc_10006CE2
		push	ecx
		push	ecx
		fstp	[esp+14h+var_14] ; double
		call	?TicksFromMilliseconds@BaseTimeDurationPlatformUtils@mozilla@@SA_JN@Z ;	mozilla::BaseTimeDurationPlatformUtils::TicksFromMilliseconds(double)
		pop	ecx
		pop	ecx
		mov	[esi], eax
		mov	[esi+4], edx

loc_10006CCD:				; CODE XREF: sub_10006C83+5Dj
					; sub_10006C83+6Aj
		mov	eax, esi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10006CD4:				; CODE XREF: sub_10006C83+21j
		or	dword ptr [esi], 0FFFFFFFFh
		fstp	st
		mov	dword ptr [esi+4], 7FFFFFFFh
		jmp	short loc_10006CCD
; ---------------------------------------------------------------------------

loc_10006CE2:				; CODE XREF: sub_10006C83+37j
		fstp	st
		mov	[esi], ecx
		mov	dword ptr [esi+4], 80000000h
		jmp	short loc_10006CCD
sub_10006C83	endp

; Exported entry  45. ?TicksFromMilliseconds@BaseTimeDurationPlatformUtils@mozilla@@SA_JN@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __cdecl mozilla::BaseTimeDurationPlatformUtils::TicksFromMilliseconds(double)
		public ?TicksFromMilliseconds@BaseTimeDurationPlatformUtils@mozilla@@SA_JN@Z
?TicksFromMilliseconds@BaseTimeDurationPlatformUtils@mozilla@@SA_JN@Z proc near
					; CODE XREF: sub_10006C83+3Ep
					; DATA XREF: .rdata:off_100175A8o

var_8		= qword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ecx
		fild	qword_1001A810
		fstp	[ebp+var_8]
		fld	[ebp+var_8]
		fmul	[ebp+arg_0]
		fld	ds:dbl_100164D0
		fcomp	st(1)
		fnstsw	ax
		test	ah, 5
		jnp	short loc_10006D2A
		fld	ds:dbl_100164C8
		fcomp	st(1)
		fnstsw	ax
		test	ah, 41h
		jz	short loc_10006D36
		call	__ftol2

loc_10006D26:				; CODE XREF: mozilla::BaseTimeDurationPlatformUtils::TicksFromMilliseconds(double)+45j
					; mozilla::BaseTimeDurationPlatformUtils::TicksFromMilliseconds(double)+50j
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10006D2A:				; CODE XREF: mozilla::BaseTimeDurationPlatformUtils::TicksFromMilliseconds(double)+21j
		fstp	st
		or	eax, 0FFFFFFFFh
		mov	edx, 7FFFFFFFh
		jmp	short loc_10006D26
; ---------------------------------------------------------------------------

loc_10006D36:				; CODE XREF: mozilla::BaseTimeDurationPlatformUtils::TicksFromMilliseconds(double)+30j
		fstp	st
		xor	eax, eax
		mov	edx, 80000000h
		jmp	short loc_10006D26
?TicksFromMilliseconds@BaseTimeDurationPlatformUtils@mozilla@@SA_JN@Z endp

; Exported entry  28. ?ComputeProcessUptime@TimeStamp@mozilla@@CA_KXZ

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static unsigned __int64 __cdecl mozilla::TimeStamp::ComputeProcessUptime(void)
		public ?ComputeProcessUptime@TimeStamp@mozilla@@CA_KXZ
?ComputeProcessUptime@TimeStamp@mozilla@@CA_KXZ	proc near
					; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+53p
					; DATA XREF: .rdata:off_100175A8o

KernelTime	= _FILETIME ptr	-3Ch
ExitTime	= _FILETIME ptr	-34h
UserTime	= _FILETIME ptr	-2Ch
FileTime	= _FILETIME ptr	-24h
CreationTime	= _FILETIME ptr	-1Ch
SystemTime	= _SYSTEMTIME ptr -14h
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 40h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		lea	eax, [ebp+SystemTime]
		push	eax		; lpSystemTime
		call	ds:GetSystemTime
		lea	eax, [ebp+FileTime]
		push	eax		; lpFileTime
		lea	eax, [ebp+SystemTime]
		push	eax		; lpSystemTime
		call	ds:SystemTimeToFileTime
		test	eax, eax
		jz	short loc_10006DB3
		lea	eax, [ebp+UserTime]
		push	eax		; lpUserTime
		lea	eax, [ebp+KernelTime]
		push	eax		; lpKernelTime
		lea	eax, [ebp+ExitTime]
		push	eax		; lpExitTime
		lea	eax, [ebp+CreationTime]
		push	eax		; lpCreationTime
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:GetProcessTimes
		test	eax, eax
		jz	short loc_10006DB3
		mov	ecx, [ebp+FileTime.dwLowDateTime]
		sub	ecx, [ebp+CreationTime.dwLowDateTime]
		mov	eax, [ebp+FileTime.dwHighDateTime]
		sbb	eax, [ebp+CreationTime.dwHighDateTime]
		push	0
		push	0Ah
		push	eax
		push	ecx
		call	__aulldiv

loc_10006DA5:				; CODE XREF: mozilla::TimeStamp::ComputeProcessUptime(void)+76j
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10006DB3:				; CODE XREF: mozilla::TimeStamp::ComputeProcessUptime(void)+2Aj
					; mozilla::TimeStamp::ComputeProcessUptime(void)+4Bj
		xor	eax, eax
		xor	edx, edx
		jmp	short loc_10006DA5
?ComputeProcessUptime@TimeStamp@mozilla@@CA_KXZ	endp

; Exported entry  43. ?Shutdown@TimeStamp@mozilla@@SAXXZ

; =============== S U B	R O U T	I N E =======================================


; public: static void __cdecl mozilla::TimeStamp::Shutdown(void)
		public ?Shutdown@TimeStamp@mozilla@@SAXXZ
?Shutdown@TimeStamp@mozilla@@SAXXZ proc	near
					; CODE XREF: mozilla::TimeStamp::Shutdown(void)j
					; DATA XREF: .rdata:off_100175A8o
		push	offset stru_1001AC68 ; lpCriticalSection
		call	ds:DeleteCriticalSection
		retn
?Shutdown@TimeStamp@mozilla@@SAXXZ endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10006DC5	proc near		; CODE XREF: sub_1000131Bp

var_18		= byte ptr -18h

		push	ebp
		mov	ebp, esp
		xor	eax, eax
		mov	word_1001AA60, 100h
		sub	esp, 18h
		mov	dword_1001AA50,	eax
		mov	dword_1001AA54,	eax
		mov	dword_1001AA58,	eax
		mov	dword_1001AA5C,	eax
		push	esi
		push	edi
		mov	dword_1001AA68,	eax
		mov	dword_1001AA6C,	eax
		mov	dword_1001AA70,	eax
		mov	dword_1001AA74,	eax
		mov	word_1001AA78, 100h
		call	?Startup@TimeStamp@mozilla@@SAXXZ ; mozilla::TimeStamp::Startup(void)
		lea	eax, [ebp+var_18]
		push	1
		push	eax
		call	?Now@TimeStamp@mozilla@@CA?AV12@_N@Z ; mozilla::TimeStamp::Now(bool)
		pop	ecx
		pop	ecx
		push	6
		pop	ecx
		lea	esi, [ebp+var_18]
		mov	edi, offset dword_1001AA50
		rep movsd
		pop	edi
		mov	eax, offset dword_1001AA50
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
sub_10006DC5	endp


; =============== S U B	R O U T	I N E =======================================


sub_10006E33	proc near		; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+4Ep
		push	esi
		mov	esi, ecx
		push	1
		push	esi
		call	?Now@TimeStamp@mozilla@@CA?AV12@_N@Z ; mozilla::TimeStamp::Now(bool)
		pop	ecx
		pop	ecx
		mov	eax, esi
		pop	esi
		retn
sub_10006E33	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  39. ?Now@TimeStamp@mozilla@@CA?AV12@_N@Z

; =============== S U B	R O U T	I N E =======================================


; private: static class	mozilla::TimeStamp __cdecl mozilla::TimeStamp::Now(bool)
		public ?Now@TimeStamp@mozilla@@CA?AV12@_N@Z
?Now@TimeStamp@mozilla@@CA?AV12@_N@Z proc near ; CODE XREF: sub_10006DC5+4Fp
					; sub_10006E33+6p
					; DATA XREF: ...

PerformanceCount= LARGE_INTEGER	ptr -20h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= byte ptr  8

		sub	esp, 20h
		cmp	[esp+20h+arg_4], 0
		push	ebx
		push	ebp
		push	esi
		push	edi
		jz	short loc_10006ED5
		cmp	byte_1001A028, 0
		jz	short loc_10006ED5
		lea	eax, [esp+30h+PerformanceCount]
		mov	bl, 1
		push	eax		; lpPerformanceCount
		call	ds:QueryPerformanceCounter
		push	0
		push	3E8h
		push	dword ptr [esp+38h+PerformanceCount+4]
		push	dword ptr [esp+3Ch+PerformanceCount]
		call	__allmul
		mov	edi, eax
		mov	ebp, edx

loc_10006E8C:				; CODE XREF: mozilla::TimeStamp::Now(bool)+8Bj
		call	dword_1001A818
		push	dword ptr qword_1001A810+4
		push	dword ptr qword_1001A810
		push	edx
		push	eax
		call	__allmul
		mov	esi, [esp+30h+arg_0]
		mov	byte ptr [esp+30h+var_8], bl
		mov	byte ptr [esp+30h+var_8+1], 0
		mov	ecx, [esp+30h+var_8]
		mov	[esi], eax
		mov	eax, esi
		mov	[esi+4], edx
		mov	[esi+8], edi
		mov	[esi+0Ch], ebp
		mov	[esi+10h], ecx
		mov	ecx, [esp+30h+var_4]
		pop	edi
		mov	[esi+14h], ecx
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_10006ED5:				; CODE XREF: mozilla::TimeStamp::Now(bool)+Cj
					; mozilla::TimeStamp::Now(bool)+15j
		xor	bl, bl
		xor	edi, edi
		xor	ebp, ebp
		jmp	short loc_10006E8C
?Now@TimeStamp@mozilla@@CA?AV12@_N@Z endp

; Exported entry  44. ?Startup@TimeStamp@mozilla@@SAXXZ

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl mozilla::TimeStamp::Startup(void)
		public ?Startup@TimeStamp@mozilla@@SAXXZ
?Startup@TimeStamp@mozilla@@SAXXZ proc near ; CODE XREF: sub_10006DC5+44p
					; DATA XREF: .rdata:off_100175A8o

Frequency	= LARGE_INTEGER	ptr -8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ecx
		push	offset aKernel32_dll_0 ; "kernel32.dll"
		call	ds:GetModuleHandleW
		push	offset aGettickcount64 ; "GetTickCount64"
		push	eax		; hModule
		call	ds:GetProcAddress
		mov	dword_1001A818,	eax
		test	eax, eax
		jz	short loc_10006F56

loc_10006F02:				; CODE XREF: mozilla::TimeStamp::Startup(void)+83j
		push	1000h		; dwSpinCount
		push	offset stru_1001AC68 ; lpCriticalSection
		call	ds:InitializeCriticalSectionAndSpinCount
		call	sub_100070FE
		mov	byte_1001A80C, al
		lea	eax, [ebp+Frequency]
		push	eax		; lpFrequency
		call	ds:QueryPerformanceFrequency
		test	eax, eax
		setnz	byte_1001A028
		cmp	byte_1001A028, 0
		jz	short loc_10006F4D
		mov	eax, dword ptr [ebp+Frequency]
		mov	dword ptr qword_1001A810, eax
		mov	eax, dword ptr [ebp+Frequency+4]
		mov	dword ptr qword_1001A810+4, eax
		call	sub_10007034

loc_10006F4D:				; CODE XREF: mozilla::TimeStamp::Startup(void)+59j
		call	sub_10006F65
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10006F56:				; CODE XREF: mozilla::TimeStamp::Startup(void)+23j
		mov	dword_1001A818,	offset sub_1000F36F
		jmp	short loc_10006F02
?Startup@TimeStamp@mozilla@@SAXXZ endp

; ---------------------------------------------------------------------------
		db 3 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================


sub_10006F65	proc near		; CODE XREF: mozilla::TimeStamp::Startup(void):loc_10006F4Dp

var_4		= dword	ptr -4

; FUNCTION CHUNK AT 1000D68E SIZE 00000026 BYTES

		push	ecx
		push	ebx
		push	ebp
		push	esi
		or	ebx, 0FFFFFFFFh
		mov	[esp+10h+var_4], 0Ah
		push	edi
		mov	ebp, ebx

loc_10006F77:				; CODE XREF: sub_10006F65+3Cj
		call	sub_1000700F
		mov	esi, eax
		mov	edi, edx
		call	sub_1000700F
		sub	eax, esi
		sbb	edx, edi
		cmp	edx, ebp
		ja	short loc_10006F97
		jb	short loc_10006F93
		cmp	eax, ebx
		jnb	short loc_10006F97

loc_10006F93:				; CODE XREF: sub_10006F65+28j
		mov	ebx, eax
		mov	ebp, edx

loc_10006F97:				; CODE XREF: sub_10006F65+26j
					; sub_10006F65+2Cj
		dec	[esp+14h+var_4]
		jz	short loc_10006FA3
		mov	eax, ebx
		or	eax, ebp
		jnz	short loc_10006F77

loc_10006FA3:				; CODE XREF: sub_10006F65+36j
		xor	esi, esi
		inc	esi
		test	ebx, ebx
		jnz	short loc_10006FB0
		test	ebp, ebp
		jnz	short loc_10006FB0
		mov	ebx, esi

loc_10006FB0:				; CODE XREF: sub_10006F65+43j
					; sub_10006F65+47j
		push	0
		push	0F4240h
		push	ebp
		push	ebx
		call	__allmul
		push	dword ptr qword_1001A810+4
		push	dword ptr qword_1001A810
		push	edx
		push	eax
		call	__aulldiv
		mov	ebp, eax
		mov	edi, edx
		test	ebp, ebp
		jnz	short loc_10006FDF
		test	edi, edi
		jnz	short loc_10006FDF
		mov	ebp, esi

loc_10006FDF:				; CODE XREF: sub_10006F65+72j
					; sub_10006F65+76j
		mov	dword_1001ABC8,	ebp
		xor	ebx, ebx
		mov	dword_1001ABCC,	edi

loc_10006FED:				; CODE XREF: sub_10006F65+674Aj
		cmp	esi, ebp
		jnz	loc_1000D68E
		cmp	ebx, edi
		jnz	loc_1000D68E

loc_10006FFD:				; CODE XREF: sub_10006F65+6736j
					; sub_10006F65+6740j
		pop	edi
		mov	dword_1001ABC0,	esi
		pop	esi
		pop	ebp
		mov	dword_1001ABC4,	ebx
		pop	ebx
		pop	ecx
		retn
sub_10006F65	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000700F	proc near		; CODE XREF: sub_10006F65:loc_10006F77p
					; sub_10006F65+1Bp

PerformanceCount= LARGE_INTEGER	ptr -8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ecx
		lea	eax, [ebp+PerformanceCount]
		push	eax		; lpPerformanceCount
		call	ds:QueryPerformanceCounter
		push	0
		push	3E8h
		push	dword ptr [ebp+PerformanceCount+4]
		push	dword ptr [ebp+PerformanceCount]
		call	__allmul
		mov	esp, ebp
		pop	ebp
		retn
sub_1000700F	endp


; =============== S U B	R O U T	I N E =======================================


sub_10007034	proc near		; CODE XREF: mozilla::TimeStamp::Startup(void)+6Bp

TimeIncrement	= dword	ptr -0Ch
TimeAdjustment	= dword	ptr -8
TimeAdjustmentDisabled=	dword ptr -4

		sub	esp, 0Ch
		push	ebx
		push	ebp
		push	esi
		push	edi
		lea	eax, [esp+1Ch+TimeAdjustmentDisabled]
		xor	ebp, ebp
		push	eax		; lpTimeAdjustmentDisabled
		lea	eax, [esp+20h+TimeIncrement]
		mov	[esp+20h+TimeAdjustment], ebp
		push	eax		; lpTimeIncrement
		lea	eax, [esp+24h+TimeAdjustment]
		mov	[esp+24h+TimeIncrement], ebp
		push	eax		; lpTimeAdjustment
		call	ds:GetSystemTimeAdjustment
		mov	eax, [esp+1Ch+TimeIncrement]
		test	eax, eax
		jz	loc_100070F4

loc_10007066:				; CODE XREF: sub_10007034+C5j
		dec	eax
		mov	edi, dword ptr qword_1001A810+4
		xor	edx, edx
		mov	esi, dword ptr qword_1001A810
		mov	ebx, 2710h
		div	ebx
		push	edi
		inc	eax
		imul	eax, 2710h
		push	esi
		push	ebp
		push	eax
		call	__allmul
		push	ebp
		push	ebx
		push	edx
		push	eax
		call	__alldiv
		push	ebp
		shld	edx, eax, 2
		push	7D0h
		push	edi
		shl	eax, 2
		push	esi
		mov	dword_1001ABD0,	eax
		mov	dword_1001ABD4,	edx
		call	__allmul
		push	ebp
		push	1388h
		push	edi
		push	esi
		mov	dword_1001ABE8,	eax
		mov	dword_1001ABEC,	edx
		call	__allmul
		push	ebp
		push	32h
		push	edi
		push	esi
		mov	dword_1001ABE0,	eax
		mov	dword_1001ABE4,	edx
		call	__allmul
		pop	edi
		pop	esi
		pop	ebp
		mov	dword_1001ABD8,	eax
		mov	dword_1001ABDC,	edx
		pop	ebx
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_100070F4:				; CODE XREF: sub_10007034+2Cj
		mov	eax, 26161h
		jmp	loc_10007066
sub_10007034	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100070FE	proc near		; CODE XREF: mozilla::TimeStamp::Startup(void)+35p

var_14		= dword	ptr -14h
var_10		= byte ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		push	ebx
		push	esi
		xor	eax, eax
		lea	esi, [ebp+var_14]
		xor	ecx, ecx
		cpuid
		mov	[esi], eax
		lea	eax, [ebp+var_10]
		push	0Ch		; size_t
		mov	[esi+4], ebx
		push	offset aGenuntelinei ; "GenuntelineI"
		mov	[esi+8], ecx
		push	eax		; char *
		mov	[esi+0Ch], edx
		call	ds:_strnicmp
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_10007184
		lea	esi, [ebp+var_14]
		xor	ecx, ecx
		mov	eax, 80000000h
		cpuid
		mov	[esi], eax
		mov	eax, 80000007h
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		cmp	[ebp+var_14], eax
		jb	short loc_10007184
		xor	ecx, ecx
		cpuid
		mov	[esi], eax
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[esi+0Ch], edx
		mov	eax, [ebp+var_8]
		shr	eax, 8
		and	al, 1

loc_10007174:				; CODE XREF: sub_100070FE+88j
		mov	ecx, [ebp+var_4]
		pop	esi
		xor	ecx, ebp
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10007184:				; CODE XREF: sub_100070FE+3Cj
					; sub_100070FE+5Dj
		xor	al, al
		jmp	short loc_10007174
sub_100070FE	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 118. moz_malloc_usable_size

; =============== S U B	R O U T	I N E =======================================


		public moz_malloc_usable_size
moz_malloc_usable_size proc near	; DATA XREF: .rdata:off_100175A8o

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000D6B4 SIZE 0000007C BYTES

		mov	eax, [esp+arg_0]
		sub	esp, 28h
		test	eax, eax
		jz	loc_10007223
		push	ebx
		push	edi
		mov	edi, eax
		and	edi, 0FFF00000h
		jz	short loc_10007227
		push	ebp
		push	esi
		mov	esi, lpCriticalSection
		xor	ecx, ecx
		xor	ebp, ebp
		mov	[esp+38h+var_20], ecx
		mov	ebx, [esi+1Ch]
		mov	edx, [esi+18h]
		mov	[esp+38h+arg_0], edx
		dec	ebx
		jnz	short loc_1000722B

loc_100071C8:				; CODE XREF: moz_malloc_usable_size+6568j
		mov	edx, 20h
		sub	edx, [esi+ebp*4+20h]
		mov	esi, edi
		shl	esi, cl
		mov	ecx, edx
		shr	esi, cl
		mov	ecx, [esp+38h+arg_0]
		cmp	dword ptr [ecx+esi*4], 0
		jz	short loc_10007237
		cmp	edi, eax
		jz	loc_1000D6FD
		sub	eax, edi
		shr	eax, 0Ch
		add	eax, 2
		lea	eax, [eax+eax*2]
		mov	ebx, [edi+eax*4]
		test	bl, 2
		jnz	short loc_10007213
		and	ebx, 0FFFFF000h
		mov	eax, [ebx]
		mov	ebx, [eax+14h]

loc_10007209:				; CODE XREF: moz_malloc_usable_size+A9j
					; moz_malloc_usable_size+659Bj
		pop	esi
		pop	ebp

loc_1000720B:				; CODE XREF: moz_malloc_usable_size+99j
		pop	edi
		mov	eax, ebx
		pop	ebx

loc_1000720F:				; CODE XREF: moz_malloc_usable_size+95j
		add	esp, 28h
		retn
; ---------------------------------------------------------------------------

loc_10007213:				; CODE XREF: moz_malloc_usable_size+6Cj
		pop	esi
		pop	ebp
		and	ebx, 0FFFFF000h
		pop	edi
		mov	eax, ebx
		pop	ebx
		add	esp, 28h
		retn
; ---------------------------------------------------------------------------

loc_10007223:				; CODE XREF: moz_malloc_usable_size+9j
		xor	eax, eax
		jmp	short loc_1000720F
; ---------------------------------------------------------------------------

loc_10007227:				; CODE XREF: moz_malloc_usable_size+19j
		xor	ebx, ebx
		jmp	short loc_1000720B
; ---------------------------------------------------------------------------

loc_1000722B:				; CODE XREF: moz_malloc_usable_size+36j
		lea	edx, [esi+20h]
		mov	[esp+38h+var_28], edx
		jmp	loc_1000D6B4
; ---------------------------------------------------------------------------

loc_10007237:				; CODE XREF: moz_malloc_usable_size+51j
					; moz_malloc_usable_size+6546j
		xor	ebx, ebx
		jmp	short loc_10007209
moz_malloc_usable_size endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 114. malloc_good_size

; =============== S U B	R O U T	I N E =======================================


		public malloc_good_size
malloc_good_size proc near		; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		cmp	eax, 9
		jb	short loc_10007285
		cmp	eax, 200h
		jbe	short loc_1000727E
		cmp	eax, 800h
		ja	short loc_100072B6
		lea	ecx, [eax-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 10h
		or	eax, ecx
		inc	eax

locret_1000727D:			; CODE XREF: malloc_good_size+6Ej
		retn
; ---------------------------------------------------------------------------

loc_1000727E:				; CODE XREF: malloc_good_size+Ej
		add	eax, 0Fh
		and	eax, 0FFFFFFF0h
		retn
; ---------------------------------------------------------------------------

loc_10007285:				; CODE XREF: malloc_good_size+7j
		lea	ecx, [eax-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 10h
		or	eax, ecx
		inc	eax
		cmp	eax, 2
		jnb	short locret_1000727D
		mov	eax, 2
		retn
; ---------------------------------------------------------------------------

loc_100072B6:				; CODE XREF: malloc_good_size+15j
		add	eax, 0FFFh
		and	eax, 0FFFFF000h
		retn
malloc_good_size endp

; Exported entry  93. ?update@SHA1Sum@mozilla@@QAEXPBXI@Z

; =============== S U B	R O U T	I N E =======================================


; void __thiscall mozilla::SHA1Sum::update(mozilla::SHA1Sum *this, const void *, size_t)
		public ?update@SHA1Sum@mozilla@@QAEXPBXI@Z
?update@SHA1Sum@mozilla@@QAEXPBXI@Z proc near
					; CODE XREF: mozilla::SHA1Sum::finish(uchar (&)[20])+1Ap
					; DATA XREF: .rdata:off_100175A8o

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ecx
		push	ebp
		mov	ebp, [esp+8+arg_0]
		push	esi
		mov	esi, [esp+0Ch+arg_4]
		push	edi
		mov	edi, ecx
		mov	[esp+10h+var_4], edi
		test	esi, esi
		jz	short loc_10007302
		mov	eax, [edi+40h]
		and	eax, 3Fh
		add	[edi+40h], esi
		push	ebx
		adc	dword ptr [edi+44h], 0
		mov	[esp+14h+arg_0], eax
		test	eax, eax
		jnz	short loc_10007309

loc_100072ED:				; CODE XREF: mozilla::SHA1Sum::update(void const *,uint)+6Cj
					; mozilla::SHA1Sum::update(void	const *,uint)+78j
		cmp	esi, 40h
		jnb	short loc_1000733B

loc_100072F2:				; CODE XREF: mozilla::SHA1Sum::update(void const *,uint)+9Aj
		pop	ebx
		test	esi, esi
		jz	short loc_10007302
		push	esi		; size_t
		push	ebp		; void *
		push	edi		; void *
		call	memcpy
		add	esp, 0Ch

loc_10007302:				; CODE XREF: mozilla::SHA1Sum::update(void const *,uint)+14j
					; mozilla::SHA1Sum::update(void	const *,uint)+34j
		pop	edi
		pop	esi
		pop	ebp
		pop	ecx
		retn	8
; ---------------------------------------------------------------------------

loc_10007309:				; CODE XREF: mozilla::SHA1Sum::update(void const *,uint)+2Aj
		push	40h
		pop	ebx
		sub	ebx, eax
		cmp	esi, ebx
		jnb	short loc_10007314
		mov	ebx, esi

loc_10007314:				; CODE XREF: mozilla::SHA1Sum::update(void const *,uint)+4Fj
		push	ebx		; size_t
		add	eax, edi
		push	ebp		; void *
		push	eax		; void *
		call	memcpy
		mov	eax, [esp+20h+arg_0]
		add	esp, 0Ch
		add	eax, ebx
		sub	esi, ebx
		add	ebp, ebx
		test	al, 3Fh
		jnz	short loc_100072ED
		lea	ecx, [edi+74h]
		mov	edx, edi
		call	sub_10007410
		jmp	short loc_100072ED
; ---------------------------------------------------------------------------

loc_1000733B:				; CODE XREF: mozilla::SHA1Sum::update(void const *,uint)+2Fj
		lea	eax, [edi+74h]
		mov	ebx, esi
		shr	ebx, 6
		mov	edi, eax

loc_10007345:				; CODE XREF: mozilla::SHA1Sum::update(void const *,uint)+94j
		mov	edx, ebp
		mov	ecx, edi
		sub	esi, 40h
		call	sub_10007410
		add	ebp, 40h
		dec	ebx
		jnz	short loc_10007345
		mov	edi, [esp+14h+var_4]
		jmp	short loc_100072F2
?update@SHA1Sum@mozilla@@QAEXPBXI@Z endp

; Exported entry  60. ?finish@SHA1Sum@mozilla@@QAEXAAY0BE@E@Z

; =============== S U B	R O U T	I N E =======================================


; void __thiscall mozilla::SHA1Sum::finish(mozilla::SHA1Sum *this, unsigned __int8 (*)[20])
		public ?finish@SHA1Sum@mozilla@@QAEXAAY0BE@E@Z
?finish@SHA1Sum@mozilla@@QAEXAAY0BE@E@Z	proc near ; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

		push	ebx
		push	esi
		push	edi
		mov	ebx, ecx
		push	0FFFFFFF7h
		pop	eax
		mov	edi, [ebx+40h]
		sub	eax, edi
		mov	esi, [ebx+44h]
		and	eax, 3Fh
		inc	eax
		push	eax		; size_t
		push	offset aA	; ""
		call	?update@SHA1Sum@mozilla@@QAEXPBXI@Z ; mozilla::SHA1Sum::update(void const *,uint)
		shld	esi, edi, 3
		lea	ecx, [ebx+74h]
		mov	edx, ebx
		shl	edi, 3
		bswap	esi
		bswap	edi
		mov	[ebx+38h], esi
		mov	[ebx+3Ch], edi
		call	sub_10007410
		mov	eax, [ebx+48h]
		mov	esi, ebx
		mov	edi, [esp+0Ch+arg_0]
		bswap	eax
		mov	[ebx], eax
		mov	eax, [ebx+4Ch]
		bswap	eax
		mov	[ebx+4], eax
		mov	eax, [ebx+50h]
		bswap	eax
		mov	[ebx+8], eax
		mov	eax, [ebx+54h]
		bswap	eax
		mov	[ebx+0Ch], eax
		mov	eax, [ebx+58h]
		push	5
		pop	ecx
		bswap	eax
		mov	[ebx+10h], eax
		rep movsd
		pop	edi
		pop	esi
		mov	byte ptr [ebx+0A0h], 1
		pop	ebx
		retn	4
?finish@SHA1Sum@mozilla@@QAEXAAY0BE@E@Z	endp

; Exported entry   5. ??0SHA1Sum@mozilla@@QAE@XZ

; =============== S U B	R O U T	I N E =======================================


; _DWORD __thiscall mozilla::SHA1Sum::SHA1Sum(mozilla::SHA1Sum *__hidden this)
		public ??0SHA1Sum@mozilla@@QAE@XZ
??0SHA1Sum@mozilla@@QAE@XZ proc	near	; DATA XREF: .rdata:off_100175A8o
		xor	eax, eax
		mov	[ecx+40h], eax
		mov	[ecx+44h], eax
		mov	[ecx+0A0h], al
		mov	eax, ecx
		mov	dword ptr [ecx+48h], 67452301h
		mov	dword ptr [ecx+4Ch], 0EFCDAB89h
		mov	dword ptr [ecx+50h], 98BADCFEh
		mov	dword ptr [ecx+54h], 10325476h
		mov	dword ptr [ecx+58h], 0C3D2E1F0h
		retn
??0SHA1Sum@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


sub_10007410	proc near		; CODE XREF: mozilla::SHA1Sum::update(void const *,uint)+73p
					; mozilla::SHA1Sum::update(void	const *,uint)+8Bp ...

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		sub	esp, 14h
		mov	eax, edx
		mov	edx, ecx
		push	ebx
		mov	[esp+18h+var_10], eax
		push	ebp
		mov	ecx, [edx-2Ch]
		mov	ebp, [edx-28h]
		mov	ebx, [edx-24h]
		mov	[esp+1Ch+var_C], ecx
		push	esi
		mov	[esp+20h+var_14], edx
		push	edi
		mov	edi, [edx-20h]
		mov	esi, [edx-1Ch]
		mov	eax, [eax]
		bswap	eax
		mov	[edx-18h], eax
		mov	edx, ecx
		rol	edx, 5
		mov	ecx, edi
		xor	ecx, ebx
		add	edx, esi
		mov	esi, [esp+24h+var_14]
		and	ecx, ebp
		xor	ecx, edi
		ror	ebp, 2
		add	ecx, edx
		mov	eax, [esi-18h]
		add	eax, 5A827999h
		add	ecx, eax
		mov	eax, [esp+24h+var_10]
		mov	[esp+24h+var_8], ecx
		mov	edx, ecx
		rol	edx, 5
		mov	ecx, ebx
		xor	ecx, ebp
		add	edx, edi
		and	ecx, [esp+24h+var_C]
		mov	eax, [eax+4]
		xor	ecx, ebx
		mov	edi, [esp+24h+var_C]
		add	ecx, edx
		bswap	eax
		mov	[esi-14h], eax
		mov	esi, [esi-14h]
		mov	eax, [esp+24h+var_10]
		add	esi, 5A827999h
		add	esi, ecx
		ror	edi, 2
		mov	ecx, [esp+24h+var_14]
		mov	edx, esi
		rol	edx, 5
		mov	eax, [eax+8]
		add	edx, ebx
		mov	ebx, [esp+24h+var_14]
		bswap	eax
		mov	[ecx-10h], eax
		mov	ecx, ebp
		mov	eax, [esp+24h+var_10]
		xor	ecx, edi
		and	ecx, [esp+24h+var_8]
		xor	ecx, ebp
		mov	[esp+24h+var_C], edi
		mov	edi, [ebx-10h]
		add	ecx, edx
		mov	eax, [eax+0Ch]
		add	edi, 5A827999h
		add	edi, ecx
		mov	ecx, [esp+24h+var_8]
		ror	ecx, 2
		mov	edx, edi
		mov	[esp+24h+var_8], ecx
		xor	ecx, [esp+24h+var_C]
		rol	edx, 5
		and	ecx, esi
		xor	ecx, [esp+24h+var_C]
		add	edx, ebp
		bswap	eax
		mov	[ebx-0Ch], eax
		add	ecx, edx
		mov	ebx, [ebx-0Ch]
		mov	eax, [esp+24h+var_10]
		add	ebx, 5A827999h
		mov	ebp, [esp+24h+var_14]
		add	ebx, ecx
		mov	ecx, [esp+24h+var_8]
		mov	edx, ebx
		rol	edx, 5
		mov	eax, [eax+10h]
		add	edx, [esp+24h+var_C]
		bswap	eax
		mov	[ebp-8], eax
		mov	ebp, [ebp-8]
		mov	eax, [esp+24h+var_10]
		add	ebp, 5A827999h
		ror	esi, 2
		xor	ecx, esi
		and	ecx, edi
		ror	edi, 2
		xor	ecx, [esp+24h+var_8]
		mov	eax, [eax+14h]
		add	ecx, edx
		add	ebp, ecx
		mov	ecx, [esp+24h+var_14]
		bswap	eax
		mov	edx, ebp
		rol	edx, 5
		add	edx, [esp+24h+var_8]
		mov	[ecx-4], eax
		mov	ecx, esi
		mov	eax, [esp+24h+var_14]
		xor	ecx, edi
		and	ecx, ebx
		ror	ebx, 2
		xor	ecx, esi
		add	ecx, edx
		mov	eax, [eax-4]
		lea	edx, [eax+5A827999h]
		mov	eax, [esp+24h+var_10]
		add	edx, ecx
		mov	ecx, [esp+24h+var_14]
		mov	[esp+24h+var_4], edx
		rol	edx, 5
		mov	eax, [eax+18h]
		add	edx, esi
		mov	esi, [esp+24h+var_14]
		bswap	eax
		mov	[ecx], eax
		mov	ecx, edi
		xor	ecx, ebx
		mov	eax, [esi]
		and	ecx, ebp
		xor	ecx, edi
		ror	ebp, 2
		add	ecx, edx
		lea	edx, [eax+5A827999h]
		mov	eax, [esp+24h+var_10]
		add	edx, ecx
		mov	ecx, ebx
		mov	[esp+24h+var_8], edx
		xor	ecx, ebp
		rol	edx, 5
		mov	eax, [eax+1Ch]
		add	edx, edi
		mov	edi, [esp+24h+var_14]
		bswap	eax
		mov	[esi+4], eax
		mov	esi, [esp+24h+var_4]
		and	ecx, esi
		mov	eax, [edi+4]
		xor	ecx, ebx
		add	ecx, edx
		ror	esi, 2
		lea	edx, [eax+5A827999h]
		mov	eax, [esp+24h+var_10]
		add	edx, ecx
		mov	ecx, esi
		mov	[esp+24h+var_4], edx
		rol	edx, 5
		mov	eax, [eax+20h]
		bswap	eax
		mov	[edi+8], eax
		mov	edi, [esp+24h+var_8]
		add	edx, ebx
		mov	ebx, [esp+24h+var_14]
		xor	ecx, ebp
		and	ecx, edi
		ror	edi, 2
		xor	ecx, ebp
		add	ecx, edx
		mov	eax, [ebx+8]
		lea	edx, [eax+5A827999h]
		mov	eax, [esp+24h+var_10]
		add	edx, ecx
		mov	ecx, esi
		mov	[esp+24h+var_8], edx
		xor	ecx, edi
		rol	edx, 5
		mov	eax, [eax+24h]
		add	edx, ebp
		mov	ebp, [esp+24h+var_14]
		bswap	eax
		mov	[ebx+0Ch], eax
		mov	ebx, [esp+24h+var_4]
		and	ecx, ebx
		mov	eax, [ebp+0Ch]
		xor	ecx, esi
		add	ecx, edx
		ror	ebx, 2
		lea	edx, [eax+5A827999h]
		mov	eax, [esp+24h+var_10]
		add	edx, ecx
		mov	ecx, edi
		mov	[esp+24h+var_4], edx
		xor	ecx, ebx
		rol	edx, 5
		mov	eax, [eax+28h]
		add	edx, esi
		mov	esi, [esp+24h+var_14]
		bswap	eax
		mov	[ebp+10h], eax
		mov	ebp, [esp+24h+var_8]
		and	ecx, ebp
		mov	eax, [esi+10h]
		xor	ecx, edi
		add	ecx, edx
		ror	ebp, 2
		lea	edx, [eax+5A827999h]
		mov	eax, [esp+24h+var_10]
		add	edx, ecx
		mov	ecx, ebx
		mov	[esp+24h+var_8], edx
		xor	ecx, ebp
		rol	edx, 5
		mov	eax, [eax+2Ch]
		add	edx, edi
		mov	edi, [esp+24h+var_14]
		bswap	eax
		mov	[esi+14h], eax
		mov	esi, [esp+24h+var_4]
		and	ecx, esi
		mov	eax, [edi+14h]
		xor	ecx, ebx
		add	ecx, edx
		ror	esi, 2
		lea	edx, [eax+5A827999h]
		mov	eax, [esp+24h+var_10]
		add	edx, ecx
		mov	ecx, ebp
		mov	[esp+24h+var_4], edx
		xor	ecx, esi
		rol	edx, 5
		mov	eax, [eax+30h]
		add	edx, ebx
		mov	ebx, [esp+24h+var_14]
		bswap	eax
		mov	[edi+18h], eax
		mov	edi, [esp+24h+var_8]
		and	ecx, edi
		mov	eax, [ebx+18h]
		xor	ecx, ebp
		add	ecx, edx
		lea	edx, [eax+5A827999h]
		add	edx, ecx
		mov	eax, [esp+24h+var_10]
		mov	[esp+24h+var_8], edx
		rol	edx, 5
		add	edx, ebp
		ror	edi, 2
		mov	eax, [eax+34h]
		mov	ecx, edi
		mov	ebp, [esp+24h+var_14]
		xor	ecx, esi
		bswap	eax
		mov	[ebx+1Ch], eax
		mov	ebx, [esp+24h+var_4]
		and	ecx, ebx
		mov	eax, [ebp+1Ch]
		xor	ecx, esi
		add	ecx, edx
		ror	ebx, 2
		lea	edx, [eax+5A827999h]
		mov	eax, [esp+24h+var_10]
		add	edx, ecx
		mov	ecx, edi
		xor	ecx, ebx
		mov	[esp+24h+var_4], edx
		rol	edx, 5
		mov	eax, [eax+38h]
		add	edx, esi
		mov	esi, [esp+24h+var_14]
		bswap	eax
		mov	[ebp+20h], eax
		mov	ebp, [esp+24h+var_8]
		and	ecx, ebp
		mov	eax, [esi+20h]
		xor	ecx, edi
		add	ecx, edx
		ror	ebp, 2
		lea	edx, [eax+5A827999h]
		mov	eax, [esp+24h+var_10]
		add	edx, ecx
		mov	ecx, ebx
		mov	[esp+24h+var_C], edx
		xor	ecx, ebp
		rol	edx, 5
		mov	eax, [eax+3Ch]
		add	edx, edi
		mov	edi, [esp+24h+var_14]
		bswap	eax
		mov	[esi+24h], eax
		mov	esi, [esp+24h+var_4]
		and	ecx, esi
		mov	eax, [edi+24h]
		xor	ecx, ebx
		add	ecx, edx
		ror	esi, 2
		lea	edx, [eax+5A827999h]
		add	edx, ecx
		mov	ecx, [edi-18h]
		mov	eax, [edi+1Ch]
		xor	ecx, eax
		mov	eax, [edi-10h]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [edi+8]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, ebx
		mov	ebx, [esp+24h+var_14]
		mov	[edi-18h], ecx
		mov	ecx, ebp
		mov	edi, [esp+24h+var_C]
		xor	ecx, esi
		and	ecx, edi
		mov	eax, [ebx-18h]
		xor	ecx, ebp
		add	ecx, edx
		lea	edx, [eax+5A827999h]
		add	edx, ecx
		mov	ecx, [ebx+20h]
		mov	[esp+24h+var_C], edx
		ror	edi, 2
		mov	eax, [ebx-14h]
		xor	ecx, eax
		mov	eax, [ebx-0Ch]
		xor	eax, ecx
		rol	edx, 5
		mov	ecx, [ebx+0Ch]
		add	edx, ebp
		xor	ecx, eax
		mov	ebp, [esp+24h+var_8]
		rol	ecx, 1
		mov	[ebx-14h], ecx
		mov	ecx, esi
		mov	ebx, [ebx-14h]
		xor	ecx, edi
		and	ecx, [esp+24h+var_8]
		add	ebx, 5A827999h
		xor	ecx, esi
		ror	ebp, 2
		add	ecx, edx
		mov	[esp+24h+var_8], ebp
		mov	edx, [esp+24h+var_14]
		add	ebx, ecx
		mov	ecx, [edx-10h]
		mov	eax, [edx+24h]
		xor	ecx, eax
		mov	eax, [edx+10h]
		xor	eax, ecx
		mov	ecx, [edx-8]
		xor	ecx, eax
		mov	eax, [esp+24h+var_14]
		rol	ecx, 1
		mov	[edx-10h], ecx
		mov	ecx, ebp
		xor	ecx, edi
		mov	edx, ebx
		and	ecx, [esp+24h+var_C]
		mov	ebp, [eax-10h]
		xor	ecx, edi
		rol	edx, 5
		add	ebp, 5A827999h
		add	edx, esi
		mov	esi, [esp+24h+var_C]
		add	ecx, edx
		ror	esi, 2
		add	ebp, ecx
		mov	[esp+24h+var_C], esi
		mov	edx, eax
		mov	ecx, [edx+14h]
		mov	eax, [edx-18h]
		xor	ecx, eax
		mov	eax, [edx-0Ch]
		xor	eax, ecx
		mov	ecx, [edx-4]
		xor	ecx, eax
		rol	ecx, 1
		mov	[edx-0Ch], ecx
		mov	edx, ebp
		mov	ecx, [esp+24h+var_8]
		xor	ecx, esi
		rol	edx, 5
		and	ecx, ebx
		add	edx, edi
		mov	edi, [esp+24h+var_14]
		xor	ecx, [esp+24h+var_8]
		add	ecx, edx
		ror	ebx, 2
		mov	[esp+24h+var_4], ebx
		mov	esi, [edi-0Ch]
		add	esi, 5A827999h
		add	esi, ecx
		mov	ecx, [edi+18h]
		mov	eax, [edi-14h]
		mov	edx, esi
		xor	ecx, eax
		mov	eax, [edi-8]
		xor	eax, ecx
		mov	ecx, [edi]
		xor	ecx, eax
		rol	ecx, 1
		mov	[edi-8], ecx
		rol	edx, 5
		mov	edi, [edi-8]
		add	edx, [esp+24h+var_8]
		add	edi, 6ED9EBA1h
		mov	ecx, [esp+24h+var_C]
		xor	ecx, ebx
		xor	ecx, ebp
		ror	ebp, 2
		add	ecx, edx
		mov	[esp+24h+var_8], ebp
		mov	edx, [esp+24h+var_14]
		add	edi, ecx
		mov	ecx, [edx-10h]
		mov	eax, [edx+1Ch]
		xor	ecx, eax
		mov	eax, [edx-4]
		xor	eax, ecx
		mov	ecx, [edx+4]
		xor	ecx, eax
		mov	eax, [esp+24h+var_14]
		rol	ecx, 1
		mov	[edx-4], ecx
		mov	ecx, ebx
		xor	ecx, ebp
		mov	edx, edi
		mov	ebx, [eax-4]
		xor	ecx, esi
		rol	edx, 5
		add	ebx, 6ED9EBA1h
		add	edx, [esp+24h+var_C]
		add	ecx, edx
		ror	esi, 2
		add	ebx, ecx
		mov	edx, eax
		mov	ecx, [edx-0Ch]
		mov	eax, [edx+20h]
		xor	ecx, eax
		mov	eax, [edx+8]
		xor	eax, ecx
		mov	ecx, [edx]
		xor	ecx, eax
		mov	eax, [esp+24h+var_14]
		rol	ecx, 1
		mov	[edx], ecx
		mov	edx, ebx
		rol	edx, 5
		mov	ecx, edi
		add	edx, [esp+24h+var_4]
		xor	ecx, ebp
		mov	ebp, [eax]
		xor	ecx, esi
		add	ecx, edx
		ror	edi, 2
		mov	edx, eax
		add	ebp, 6ED9EBA1h
		add	ebp, ecx
		mov	ecx, [edx+24h]
		mov	eax, [edx+0Ch]
		xor	ecx, eax
		mov	eax, [edx-8]
		xor	eax, ecx
		mov	ecx, [edx+4]
		xor	ecx, eax
		mov	eax, [esp+24h+var_14]
		rol	ecx, 1
		mov	[edx+4], ecx
		mov	edx, ebp
		rol	edx, 5
		mov	ecx, edi
		mov	eax, [eax+4]
		xor	ecx, ebx
		add	edx, [esp+24h+var_8]
		xor	ecx, esi
		add	ecx, edx
		ror	ebx, 2
		lea	edx, [eax+6ED9EBA1h]
		mov	eax, [esp+24h+var_14]
		add	edx, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [eax-18h]
		mov	eax, [eax+10h]
		xor	ecx, eax
		mov	eax, [esp+24h+var_14]
		rol	edx, 5
		add	edx, esi
		mov	eax, [eax+8]
		xor	eax, ecx
		mov	ecx, [esp+24h+var_14]
		mov	ecx, [ecx-4]
		xor	ecx, eax
		mov	eax, [esp+24h+var_14]
		rol	ecx, 1
		mov	esi, eax
		mov	[eax+8], ecx
		mov	ecx, edi
		mov	eax, [esi+8]
		xor	ecx, ebx
		xor	ecx, ebp
		ror	ebp, 2
		add	ecx, edx
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [esi+14h]
		mov	eax, [esi-14h]
		xor	ecx, eax
		mov	eax, [esi+0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [esi]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, edi
		mov	edi, [esp+24h+var_14]
		mov	[esi+0Ch], ecx
		mov	ecx, ebx
		mov	esi, [esp+24h+var_4]
		xor	ecx, ebp
		xor	ecx, esi
		ror	esi, 2
		mov	eax, [edi+0Ch]
		add	ecx, edx
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [edi+18h]
		mov	eax, [edi-10h]
		xor	ecx, eax
		mov	eax, [edi+10h]
		xor	eax, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [edi+4]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, ebx
		mov	ebx, [esp+24h+var_14]
		mov	[edi+10h], ecx
		mov	ecx, ebp
		mov	edi, [esp+24h+var_8]
		xor	ecx, esi
		xor	ecx, edi
		ror	edi, 2
		mov	eax, [ebx+10h]
		add	ecx, edx
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [ebx+14h]
		mov	eax, [ebx+1Ch]
		xor	ecx, eax
		mov	eax, [ebx-0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [ebx+8]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		mov	[ebx+14h], ecx
		mov	ebx, [esp+24h+var_4]
		mov	ecx, ebx
		xor	ecx, esi
		xor	ecx, edi
		add	edx, ebp
		mov	ebp, [esp+24h+var_14]
		mov	eax, [ebp+14h]
		add	ecx, edx
		ror	ebx, 2
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [ebp+18h]
		mov	eax, [ebp+20h]
		xor	ecx, eax
		mov	eax, [ebp+0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [ebp-8]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, esi
		mov	[ebp+18h], ecx
		mov	ecx, ebx
		mov	esi, [esp+24h+var_14]
		mov	ebp, [esp+24h+var_8]
		xor	ecx, ebp
		xor	ecx, edi
		ror	ebp, 2
		add	ecx, edx
		mov	eax, [esi+18h]
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [esi+24h]
		mov	eax, [esi+1Ch]
		xor	ecx, eax
		mov	eax, [esi+10h]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [esi-4]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, edi
		mov	edi, [esp+24h+var_14]
		mov	[esi+1Ch], ecx
		mov	ecx, ebx
		mov	esi, [esp+24h+var_4]
		xor	ecx, ebp
		xor	ecx, esi
		ror	esi, 2
		mov	eax, [edi+1Ch]
		add	ecx, edx
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [edi+20h]
		mov	eax, [edi-18h]
		xor	ecx, eax
		mov	eax, [edi+14h]
		xor	eax, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [edi]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, ebx
		mov	ebx, [esp+24h+var_14]
		mov	[edi+20h], ecx
		mov	ecx, ebp
		mov	edi, [esp+24h+var_8]
		xor	ecx, esi
		xor	ecx, edi
		ror	edi, 2
		mov	eax, [ebx+20h]
		add	ecx, edx
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [ebx+18h]
		mov	eax, [ebx+24h]
		xor	ecx, eax
		mov	eax, [ebx-14h]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [ebx+4]
		xor	ecx, eax
		rol	ecx, 1
		mov	[ebx+24h], ecx
		mov	ebx, [esp+24h+var_4]
		mov	ecx, esi
		xor	ecx, edi
		rol	edx, 5
		xor	ecx, ebx
		add	edx, ebp
		mov	ebp, [esp+24h+var_14]
		add	ecx, edx
		ror	ebx, 2
		mov	eax, [ebp+24h]
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [ebp-18h]
		mov	eax, [ebp+1Ch]
		xor	ecx, eax
		mov	eax, [ebp-10h]
		xor	eax, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [ebp+8]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, esi
		mov	esi, [esp+24h+var_14]
		mov	[ebp-18h], ecx
		mov	ebp, [esp+24h+var_8]
		mov	ecx, ebp
		xor	ecx, edi
		ror	ebp, 2
		mov	eax, [esi-18h]
		xor	ecx, ebx
		add	ecx, edx
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [esi+20h]
		mov	eax, [esi-14h]
		xor	ecx, eax
		mov	eax, [esi-0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [esi+0Ch]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, edi
		mov	edi, [esp+24h+var_14]
		mov	[esi-14h], ecx
		mov	ecx, ebp
		mov	esi, [esp+24h+var_4]
		xor	ecx, esi
		xor	ecx, ebx
		ror	esi, 2
		mov	eax, [edi-14h]
		add	ecx, edx
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [edi-10h]
		mov	eax, [edi+24h]
		xor	ecx, eax
		mov	eax, [edi+10h]
		xor	eax, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [edi-8]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, ebx
		mov	ebx, [esp+24h+var_14]
		mov	[edi-10h], ecx
		mov	ecx, ebp
		mov	edi, [esp+24h+var_8]
		xor	ecx, esi
		xor	ecx, edi
		mov	eax, [ebx-10h]
		add	ecx, edx
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [ebx+14h]
		mov	eax, [ebx-18h]
		mov	[esp+24h+var_C], edx
		ror	edi, 2
		xor	ecx, eax
		rol	edx, 5
		mov	eax, [ebx-0Ch]
		add	edx, ebp
		xor	eax, ecx
		mov	ecx, [ebx-4]
		xor	ecx, eax
		mov	eax, [esp+24h+var_14]
		rol	ecx, 1
		mov	[ebx-0Ch], ecx
		mov	ecx, esi
		mov	ebx, [esp+24h+var_4]
		xor	ecx, edi
		mov	ebp, [eax-0Ch]
		xor	ecx, ebx
		add	ecx, edx
		ror	ebx, 2
		mov	edx, eax
		add	ebp, 6ED9EBA1h
		add	ebp, ecx
		mov	[esp+24h+var_8], ebp
		mov	ecx, [edx+18h]
		mov	eax, [edx-14h]
		xor	ecx, eax
		mov	eax, [edx-8]
		xor	eax, ecx
		mov	ecx, [edx]
		xor	ecx, eax
		rol	ecx, 1
		mov	[edx-8], ecx
		mov	edx, ebp
		mov	ebp, [esp+24h+var_C]
		mov	ecx, edi
		xor	ecx, ebx
		rol	edx, 5
		add	edx, esi
		xor	ecx, ebp
		mov	esi, [esp+24h+var_14]
		add	ecx, edx
		ror	ebp, 2
		mov	eax, [esi-8]
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [esi-10h]
		mov	eax, [esi+1Ch]
		xor	ecx, eax
		mov	eax, [esi-4]
		xor	eax, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [esi+4]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, edi
		mov	edi, [esp+24h+var_14]
		mov	[esi-4], ecx
		mov	esi, [esp+24h+var_8]
		mov	ecx, esi
		xor	ecx, ebx
		ror	esi, 2
		mov	eax, [edi-4]
		xor	ecx, ebp
		add	ecx, edx
		mov	[esp+24h+var_8], esi
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [edi-0Ch]
		mov	eax, [edi+20h]
		xor	ecx, eax
		mov	eax, [edi+8]
		xor	eax, ecx
		mov	[esp+24h+var_10], edx
		mov	ecx, [edi]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		mov	[edi], ecx
		mov	ecx, esi
		mov	edi, [esp+24h+var_4]
		xor	ecx, edi
		xor	ecx, ebp
		add	edx, ebx
		ror	edi, 2
		mov	ebx, [esp+24h+var_14]
		add	ecx, edx
		mov	eax, [ebx]
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [ebx+24h]
		mov	eax, [ebx+0Ch]
		xor	ecx, eax
		mov	eax, [ebx-8]
		xor	eax, ecx
		mov	[esp+24h+var_C], edx
		mov	ecx, [ebx+4]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, ebp
		mov	[ebx+4], ecx
		mov	ecx, esi
		mov	esi, [esp+24h+var_14]
		xor	ecx, edi
		mov	ebx, [esp+24h+var_10]
		xor	ecx, ebx
		add	ecx, edx
		mov	ebp, [esp+24h+var_C]
		ror	ebx, 2
		mov	eax, [esi+4]
		ror	ebp, 2
		lea	edx, [eax+6ED9EBA1h]
		add	edx, ecx
		mov	ecx, [esi-18h]
		mov	eax, [esi+10h]
		xor	ecx, eax
		mov	eax, [esi+8]
		xor	eax, ecx
		mov	[esp+24h+var_10], edx
		mov	ecx, [esi-4]
		xor	ecx, eax
		mov	eax, ebx
		and	eax, [esp+24h+var_C]
		rol	ecx, 1
		mov	[esi+8], ecx
		mov	esi, edx
		mov	edx, ebx
		rol	esi, 5
		or	edx, [esp+24h+var_C]
		add	esi, [esp+24h+var_8]
		and	edx, edi
		or	edx, eax
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	esi, eax
		mov	ecx, [eax+8]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	ecx, [esi+14h]
		mov	eax, [esi-14h]
		xor	ecx, eax
		mov	eax, [esi+0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [esi]
		xor	ecx, eax
		mov	eax, ebp
		and	eax, [esp+24h+var_10]
		rol	ecx, 1
		mov	[esi+0Ch], ecx
		mov	esi, edx
		mov	edx, ebp
		rol	esi, 5
		or	edx, [esp+24h+var_10]
		add	esi, edi
		and	edx, ebx
		or	edx, eax
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	ecx, [eax+0Ch]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	[esp+24h+var_C], edx
		mov	esi, eax
		mov	edi, [esp+24h+var_10]
		ror	edi, 2
		mov	ecx, [esi+18h]
		mov	eax, [esi-10h]
		xor	ecx, eax
		mov	eax, [esi+10h]
		xor	eax, ecx
		mov	ecx, [esi+4]
		xor	ecx, eax
		mov	eax, [esp+24h+var_8]
		rol	ecx, 1
		mov	[esi+10h], ecx
		mov	esi, edx
		mov	edx, eax
		rol	esi, 5
		or	edx, edi
		and	eax, edi
		and	edx, ebp
		add	esi, ebx
		or	edx, eax
		mov	ebx, [esp+24h+var_8]
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	esi, eax
		ror	ebx, 2
		mov	ecx, [eax+10h]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	ecx, [esi+14h]
		mov	eax, [esi+1Ch]
		xor	ecx, eax
		mov	eax, [esi-0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_10], edx
		mov	ecx, [esi+8]
		xor	ecx, eax
		mov	eax, ebx
		and	eax, [esp+24h+var_C]
		rol	ecx, 1
		mov	[esi+14h], ecx
		mov	esi, edx
		mov	edx, ebx
		rol	esi, 5
		or	edx, [esp+24h+var_C]
		add	esi, ebp
		mov	ebp, [esp+24h+var_C]
		and	edx, edi
		or	edx, eax
		ror	ebp, 2
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	esi, eax
		mov	ecx, [eax+14h]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	ecx, [esi+18h]
		mov	eax, [esi+20h]
		xor	ecx, eax
		mov	eax, [esi+0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [esi-8]
		xor	ecx, eax
		mov	eax, ebp
		and	eax, [esp+24h+var_10]
		rol	ecx, 1
		mov	[esi+18h], ecx
		mov	esi, edx
		mov	edx, ebp
		rol	esi, 5
		or	edx, [esp+24h+var_10]
		add	esi, edi
		and	edx, ebx
		or	edx, eax
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	ecx, [eax+18h]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	[esp+24h+var_C], edx
		mov	esi, eax
		mov	edi, [esp+24h+var_10]
		ror	edi, 2
		mov	ecx, [esi+24h]
		mov	eax, [esi+1Ch]
		xor	ecx, eax
		mov	eax, [esi+10h]
		xor	eax, ecx
		mov	ecx, [esi-4]
		xor	ecx, eax
		mov	eax, edi
		and	eax, [esp+24h+var_8]
		rol	ecx, 1
		mov	[esi+1Ch], ecx
		mov	esi, edx
		rol	esi, 5
		mov	edx, edi
		or	edx, [esp+24h+var_8]
		add	esi, ebx
		and	edx, ebp
		mov	ebx, [esp+24h+var_8]
		or	edx, eax
		ror	ebx, 2
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	esi, eax
		mov	ecx, [eax+1Ch]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	ecx, [esi+20h]
		mov	eax, [esi-18h]
		xor	ecx, eax
		mov	eax, [esi+14h]
		xor	eax, ecx
		mov	[esp+24h+var_10], edx
		mov	ecx, [esi]
		xor	ecx, eax
		mov	eax, ebx
		and	eax, [esp+24h+var_C]
		rol	ecx, 1
		mov	[esi+20h], ecx
		mov	esi, edx
		mov	edx, ebx
		rol	esi, 5
		or	edx, [esp+24h+var_C]
		add	esi, ebp
		and	edx, edi
		mov	ebp, [esp+24h+var_C]
		or	edx, eax
		ror	ebp, 2
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	esi, eax
		mov	ecx, [eax+20h]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	ecx, [esi+18h]
		mov	eax, [esi+24h]
		xor	ecx, eax
		mov	eax, [esi-14h]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [esi+4]
		xor	ecx, eax
		mov	eax, [esp+24h+var_10]
		rol	ecx, 1
		mov	[esi+24h], ecx
		mov	esi, edx
		mov	edx, eax
		rol	esi, 5
		or	edx, ebp
		and	eax, ebp
		and	edx, ebx
		add	esi, edi
		or	edx, eax
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	ecx, [eax+24h]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	[esp+24h+var_C], edx
		mov	esi, eax
		mov	edi, [esp+24h+var_10]
		ror	edi, 2
		mov	ecx, [esi-18h]
		mov	eax, [esi+1Ch]
		xor	ecx, eax
		mov	eax, [esi-10h]
		xor	eax, ecx
		mov	ecx, [esi+8]
		xor	ecx, eax
		mov	eax, edi
		and	eax, [esp+24h+var_8]
		rol	ecx, 1
		mov	[esi-18h], ecx
		mov	esi, edx
		rol	esi, 5
		mov	edx, edi
		or	edx, [esp+24h+var_8]
		add	esi, ebx
		and	edx, ebp
		mov	ebx, [esp+24h+var_8]
		or	edx, eax
		ror	ebx, 2
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	esi, eax
		mov	ecx, [eax-18h]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	ecx, [esi+20h]
		mov	eax, [esi-14h]
		xor	ecx, eax
		mov	eax, [esi-0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_10], edx
		mov	ecx, [esi+0Ch]
		xor	ecx, eax
		mov	eax, ebx
		and	eax, [esp+24h+var_C]
		rol	ecx, 1
		mov	[esi-14h], ecx
		mov	esi, edx
		mov	edx, ebx
		rol	esi, 5
		or	edx, [esp+24h+var_C]
		add	esi, ebp
		mov	ebp, [esp+24h+var_C]
		and	edx, edi
		or	edx, eax
		ror	ebp, 2
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	esi, eax
		mov	ecx, [eax-14h]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	ecx, [esi-10h]
		mov	eax, [esi+24h]
		xor	ecx, eax
		mov	eax, [esi+10h]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [esi-8]
		xor	ecx, eax
		mov	eax, ebp
		and	eax, [esp+24h+var_10]
		rol	ecx, 1
		mov	[esi-10h], ecx
		mov	esi, edx
		mov	edx, ebp
		rol	esi, 5
		or	edx, [esp+24h+var_10]
		add	esi, edi
		and	edx, ebx
		or	edx, eax
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	ecx, [eax-10h]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	[esp+24h+var_C], edx
		mov	esi, eax
		mov	edi, [esp+24h+var_10]
		ror	edi, 2
		mov	ecx, [esi+14h]
		mov	eax, [esi-18h]
		xor	ecx, eax
		mov	eax, [esi-0Ch]
		xor	eax, ecx
		mov	ecx, [esi-4]
		xor	ecx, eax
		mov	eax, edi
		and	eax, [esp+24h+var_8]
		rol	ecx, 1
		mov	[esi-0Ch], ecx
		mov	esi, edx
		rol	esi, 5
		mov	edx, edi
		or	edx, [esp+24h+var_8]
		add	esi, ebx
		and	edx, ebp
		mov	ebx, [esp+24h+var_8]
		or	edx, eax
		ror	ebx, 2
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	esi, eax
		mov	ecx, [eax-0Ch]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	ecx, [esi+18h]
		mov	eax, [esi-14h]
		xor	ecx, eax
		mov	eax, [esi-8]
		xor	eax, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [esi]
		xor	ecx, eax
		mov	eax, [esp+24h+var_C]
		rol	ecx, 1
		mov	[esi-8], ecx
		mov	esi, edx
		mov	edx, eax
		rol	esi, 5
		or	edx, ebx
		and	eax, ebx
		and	edx, edi
		add	esi, ebp
		or	edx, eax
		mov	ebp, [esp+24h+var_C]
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	esi, eax
		ror	ebp, 2
		mov	ecx, [eax-8]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	ecx, [esi-10h]
		mov	eax, [esi+1Ch]
		xor	ecx, eax
		mov	eax, [esi-4]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [esi+4]
		xor	ecx, eax
		mov	eax, ebp
		and	eax, [esp+24h+var_4]
		rol	ecx, 1
		mov	[esi-4], ecx
		mov	esi, edx
		mov	edx, ebp
		rol	esi, 5
		or	edx, [esp+24h+var_4]
		add	esi, edi
		and	edx, ebx
		or	edx, eax
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	ecx, [eax-4]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	[esp+24h+var_10], edx
		mov	esi, eax
		mov	edi, [esp+24h+var_4]
		ror	edi, 2
		mov	ecx, [esi-0Ch]
		mov	eax, [esi+20h]
		xor	ecx, eax
		mov	eax, [esi+8]
		xor	eax, ecx
		mov	ecx, [esi]
		xor	ecx, eax
		mov	eax, edi
		and	eax, [esp+24h+var_8]
		rol	ecx, 1
		mov	[esi], ecx
		mov	esi, edx
		mov	edx, edi
		rol	esi, 5
		or	edx, [esp+24h+var_8]
		add	esi, ebx
		and	edx, ebp
		mov	ebx, [esp+24h+var_8]
		or	edx, eax
		ror	ebx, 2
		mov	eax, [esp+24h+var_14]
		add	edx, esi
		mov	esi, eax
		mov	ecx, [eax]
		add	ecx, 8F1BBCDCh
		add	edx, ecx
		mov	ecx, [esi+24h]
		mov	eax, [esi+0Ch]
		xor	ecx, eax
		mov	eax, [esi-8]
		xor	eax, ecx
		mov	[esp+24h+var_C], edx
		mov	ecx, [esi+4]
		xor	ecx, eax
		mov	eax, ebx
		and	eax, [esp+24h+var_10]
		rol	ecx, 1
		mov	[esi+4], ecx
		mov	esi, edx
		mov	edx, ebx
		rol	esi, 5
		or	edx, [esp+24h+var_10]
		add	ebp, esi
		and	edx, edi
		or	edx, eax
		mov	eax, [esp+24h+var_14]
		mov	esi, eax
		add	ebp, edx
		mov	edx, [esp+24h+var_10]
		ror	edx, 2
		mov	ecx, [eax+4]
		add	ecx, 8F1BBCDCh
		mov	[esp+24h+var_10], edx
		or	edx, [esp+24h+var_C]
		add	ebp, ecx
		mov	ecx, [esi-18h]
		and	edx, ebx
		mov	eax, [esi+10h]
		xor	ecx, eax
		mov	eax, [esi+8]
		xor	eax, ecx
		mov	ecx, [esi-4]
		xor	ecx, eax
		mov	eax, [esp+24h+var_10]
		and	eax, [esp+24h+var_C]
		rol	ecx, 1
		or	edx, eax
		mov	eax, [esp+24h+var_14]
		mov	[esi+8], ecx
		mov	esi, ebp
		rol	esi, 5
		add	edi, esi
		mov	ecx, [eax+8]
		add	edi, edx
		add	ecx, 8F1BBCDCh
		mov	edx, eax
		add	edi, ecx
		ror	[esp+24h+var_C], 2
		mov	ecx, [edx+14h]
		mov	esi, edi
		mov	eax, [edx-14h]
		xor	ecx, eax
		mov	eax, [edx+0Ch]
		xor	eax, ecx
		rol	esi, 5
		mov	ecx, [edx]
		add	ebx, esi
		xor	ecx, eax
		mov	eax, ebp
		and	eax, [esp+24h+var_C]
		rol	ecx, 1
		mov	[edx+0Ch], ecx
		mov	edx, ebp
		or	edx, [esp+24h+var_C]
		and	edx, [esp+24h+var_10]
		or	edx, eax
		ror	ebp, 2
		mov	eax, [esp+24h+var_14]
		add	ebx, edx
		mov	edx, eax
		mov	[esp+24h+var_4], ebp
		mov	ecx, [eax+0Ch]
		add	ecx, 8F1BBCDCh
		add	ebx, ecx
		mov	ecx, [edx+18h]
		mov	eax, [edx-10h]
		mov	esi, ebx
		xor	ecx, eax
		rol	esi, 5
		mov	eax, [edx+10h]
		add	esi, [esp+24h+var_10]
		xor	eax, ecx
		mov	ecx, [edx+4]
		xor	ecx, eax
		mov	eax, [esp+24h+var_14]
		rol	ecx, 1
		mov	[edx+10h], ecx
		mov	edx, ebp
		or	edx, edi
		and	ebp, edi
		mov	ecx, [eax+10h]
		and	edx, [esp+24h+var_C]
		add	ecx, 8F1BBCDCh
		or	ebp, edx
		ror	edi, 2
		mov	edx, eax
		mov	[esp+24h+var_8], edi
		add	ebp, esi
		add	ebp, ecx
		mov	esi, ebp
		mov	ecx, [edx+14h]
		mov	eax, [edx+1Ch]
		xor	ecx, eax
		mov	eax, [edx-0Ch]
		xor	eax, ecx
		rol	esi, 5
		mov	ecx, [edx+8]
		add	esi, [esp+24h+var_C]
		xor	ecx, eax
		rol	ecx, 1
		mov	eax, edi
		mov	[edx+14h], ecx
		and	eax, ebx
		mov	edx, edi
		or	edx, ebx
		ror	ebx, 2
		and	edx, [esp+24h+var_4]
		or	edx, eax
		mov	[esp+24h+var_C], ebx
		mov	eax, [esp+24h+var_14]
		add	esi, edx
		mov	edx, eax
		mov	ecx, [eax+14h]
		add	ecx, 8F1BBCDCh
		add	esi, ecx
		mov	ecx, [edx+18h]
		mov	eax, [edx+20h]
		xor	ecx, eax
		mov	eax, [edx+0Ch]
		xor	eax, ecx
		xor	edi, ebx
		mov	ecx, [edx-8]
		xor	edi, ebp
		xor	ecx, eax
		ror	ebp, 2
		rol	ecx, 1
		xor	ebx, ebp
		mov	[edx+18h], ecx
		xor	ebx, esi
		mov	ecx, [esp+24h+var_14]
		mov	edx, esi
		rol	edx, 5
		add	edx, [esp+24h+var_4]
		add	edi, edx
		mov	[esp+24h+var_4], ebp
		mov	ecx, [ecx+18h]
		mov	edx, [esp+24h+var_14]
		add	ecx, 0CA62C1D6h
		add	edi, ecx
		ror	esi, 2
		xor	ebp, edi
		xor	ebp, esi
		mov	ecx, [edx+24h]
		mov	eax, [edx+1Ch]
		xor	ecx, eax
		mov	eax, [edx+10h]
		xor	eax, ecx
		mov	ecx, [edx-4]
		xor	ecx, eax
		rol	ecx, 1
		mov	[edx+1Ch], ecx
		mov	edx, edi
		mov	ecx, [esp+24h+var_14]
		rol	edx, 5
		add	edx, [esp+24h+var_8]
		add	ebx, edx
		ror	edi, 2
		mov	ecx, [ecx+1Ch]
		mov	edx, [esp+24h+var_14]
		add	ecx, 0CA62C1D6h
		add	ebx, ecx
		mov	ecx, [edx+20h]
		mov	eax, [edx-18h]
		xor	ecx, eax
		mov	eax, [edx+14h]
		xor	eax, ecx
		mov	ecx, [edx]
		xor	ecx, eax
		rol	ecx, 1
		mov	[edx+20h], ecx
		mov	edx, ebx
		mov	ecx, [esp+24h+var_14]
		rol	edx, 5
		add	edx, [esp+24h+var_C]
		add	ebp, edx
		mov	edx, [esp+24h+var_14]
		mov	ecx, [ecx+20h]
		add	ecx, 0CA62C1D6h
		add	ebp, ecx
		mov	ecx, [edx+18h]
		mov	eax, [edx+24h]
		xor	ecx, eax
		mov	eax, [edx-14h]
		xor	eax, ecx
		mov	ecx, [edx+4]
		xor	ecx, eax
		mov	eax, edi
		rol	ecx, 1
		xor	eax, ebx
		mov	[edx+24h], ecx
		xor	eax, esi
		mov	ecx, [esp+24h+var_14]
		mov	edx, ebp
		rol	edx, 5
		add	edx, [esp+24h+var_4]
		add	edx, eax
		mov	ecx, [ecx+24h]
		add	ecx, 0CA62C1D6h
		add	edx, ecx
		mov	[esp+24h+var_4], edx
		mov	eax, [esp+24h+var_14]
		rol	edx, 5
		add	edx, esi
		ror	ebx, 2
		mov	esi, [esp+24h+var_14]
		mov	ecx, [eax-18h]
		mov	eax, [eax+1Ch]
		xor	ecx, eax
		mov	eax, [esp+24h+var_14]
		mov	eax, [eax-10h]
		xor	eax, ecx
		mov	ecx, [esp+24h+var_14]
		mov	ecx, [ecx+8]
		xor	ecx, eax
		mov	eax, [esp+24h+var_14]
		rol	ecx, 1
		mov	[eax-18h], ecx
		mov	eax, edi
		mov	ecx, [esi-18h]
		xor	eax, ebx
		add	ecx, 0CA62C1D6h
		xor	eax, ebp
		add	edx, eax
		ror	ebp, 2
		add	edx, ecx
		mov	ecx, [esi+20h]
		mov	eax, [esi-14h]
		xor	ecx, eax
		mov	eax, [esi-0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [esi+0Ch]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, edi
		mov	edi, [esp+24h+var_14]
		mov	eax, ebx
		mov	[esi-14h], ecx
		xor	eax, ebp
		mov	esi, [esp+24h+var_4]
		xor	eax, esi
		add	edx, eax
		ror	esi, 2
		mov	ecx, [edi-14h]
		add	ecx, 0CA62C1D6h
		add	edx, ecx
		mov	ecx, [edi-10h]
		mov	eax, [edi+24h]
		xor	ecx, eax
		mov	eax, [edi+10h]
		xor	eax, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [edi-8]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, ebx
		mov	ebx, [esp+24h+var_14]
		mov	eax, ebp
		mov	[edi-10h], ecx
		xor	eax, esi
		mov	edi, [esp+24h+var_8]
		xor	eax, edi
		add	edx, eax
		ror	edi, 2
		mov	ecx, [ebx-10h]
		add	ecx, 0CA62C1D6h
		add	edx, ecx
		mov	ecx, [ebx+14h]
		mov	eax, [ebx-18h]
		xor	ecx, eax
		mov	eax, [ebx-0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [ebx-4]
		xor	ecx, eax
		rol	ecx, 1
		mov	[ebx-0Ch], ecx
		mov	ebx, [esp+24h+var_4]
		rol	edx, 5
		add	edx, ebp
		mov	eax, ebx
		mov	ebp, [esp+24h+var_14]
		xor	eax, esi
		xor	eax, edi
		ror	ebx, 2
		add	edx, eax
		mov	ecx, [ebp-0Ch]
		add	ecx, 0CA62C1D6h
		add	edx, ecx
		mov	ecx, [ebp+18h]
		mov	eax, [ebp-14h]
		xor	ecx, eax
		mov	eax, [ebp-8]
		xor	eax, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [ebp+0]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, esi
		mov	esi, [esp+24h+var_14]
		mov	eax, ebx
		mov	[ebp-8], ecx
		mov	ebp, [esp+24h+var_8]
		xor	eax, ebp
		xor	eax, edi
		ror	ebp, 2
		mov	ecx, [esi-8]
		add	edx, eax
		add	ecx, 0CA62C1D6h
		add	edx, ecx
		mov	ecx, [esi-10h]
		mov	eax, [esi+1Ch]
		xor	ecx, eax
		mov	eax, [esi-4]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [esi+4]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, edi
		mov	edi, [esp+24h+var_14]
		mov	eax, ebx
		mov	[esi-4], ecx
		xor	eax, ebp
		mov	esi, [esp+24h+var_4]
		xor	eax, esi
		add	edx, eax
		ror	esi, 2
		mov	ecx, [edi-4]
		add	ecx, 0CA62C1D6h
		add	edx, ecx
		mov	ecx, [edi-0Ch]
		mov	eax, [edi+20h]
		xor	ecx, eax
		mov	eax, [edi+8]
		xor	eax, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [edi]
		xor	ecx, eax
		rol	edx, 5
		add	edx, ebx
		rol	ecx, 1
		mov	ebx, [esp+24h+var_14]
		mov	eax, ebp
		mov	[edi], ecx
		xor	eax, esi
		mov	edi, [esp+24h+var_8]
		xor	eax, edi
		add	edx, eax
		ror	edi, 2
		mov	ecx, [ebx]
		add	ecx, 0CA62C1D6h
		add	edx, ecx
		mov	ecx, [ebx+24h]
		mov	eax, [ebx+0Ch]
		xor	ecx, eax
		mov	eax, [ebx-8]
		mov	[esp+24h+var_8], edx
		xor	eax, ecx
		rol	edx, 5
		mov	ecx, [ebx+4]
		add	edx, ebp
		xor	ecx, eax
		mov	ebp, [esp+24h+var_14]
		rol	ecx, 1
		mov	eax, esi
		mov	[ebx+4], ecx
		xor	eax, edi
		mov	ebx, [esp+24h+var_4]
		xor	eax, ebx
		mov	ecx, [ebp+4]
		add	edx, eax
		add	ecx, 0CA62C1D6h
		ror	ebx, 2
		add	edx, ecx
		mov	ecx, [ebp-18h]
		mov	eax, [ebp+10h]
		xor	ecx, eax
		mov	eax, [ebp+8]
		xor	eax, ecx
		mov	[esp+24h+var_4], edx
		mov	ecx, [ebp-4]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, esi
		mov	esi, [esp+24h+var_14]
		mov	[ebp+8], ecx
		mov	ebp, [esp+24h+var_8]
		mov	eax, ebp
		xor	eax, edi
		ror	ebp, 2
		mov	ecx, [esi+8]
		xor	eax, ebx
		add	edx, eax
		add	ecx, 0CA62C1D6h
		add	edx, ecx
		mov	ecx, [esi+14h]
		mov	eax, [esi-14h]
		xor	ecx, eax
		mov	eax, [esi+0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_C], edx
		mov	ecx, [esi]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	edx, edi
		mov	edi, [esp+24h+var_14]
		mov	eax, ebp
		mov	[esi+0Ch], ecx
		mov	esi, [esp+24h+var_4]
		xor	eax, esi
		xor	eax, ebx
		ror	esi, 2
		mov	ecx, [edi+0Ch]
		add	edx, eax
		add	ecx, 0CA62C1D6h
		add	edx, ecx
		mov	ecx, [edi+18h]
		mov	eax, [edi-10h]
		xor	ecx, eax
		mov	eax, [edi+10h]
		xor	eax, ecx
		mov	[esp+24h+var_8], edx
		mov	ecx, [edi+4]
		xor	ecx, eax
		rol	edx, 5
		add	edx, ebx
		rol	ecx, 1
		mov	ebx, [esp+24h+var_14]
		mov	eax, ebp
		mov	[edi+10h], ecx
		xor	eax, esi
		mov	edi, [esp+24h+var_C]
		xor	eax, edi
		add	edx, eax
		mov	ecx, [ebx+10h]
		add	ecx, 0CA62C1D6h
		add	edx, ecx
		ror	edi, 2
		mov	ecx, [ebx+14h]
		mov	eax, [ebx+1Ch]
		xor	ecx, eax
		mov	eax, [ebx-0Ch]
		xor	eax, ecx
		mov	[esp+24h+var_C], edx
		mov	ecx, [ebx+8]
		xor	ecx, eax
		rol	edx, 5
		rol	ecx, 1
		add	ebp, edx
		mov	[ebx+14h], ecx
		mov	eax, esi
		mov	ecx, [esp+24h+var_14]
		xor	eax, edi
		mov	edx, [esp+24h+var_14]
		mov	ebx, [esp+24h+var_8]
		xor	eax, ebx
		add	ebp, eax
		ror	ebx, 2
		mov	ecx, [ecx+14h]
		add	ecx, 0CA62C1D6h
		mov	[esp+24h+var_8], ebx
		add	ebp, ecx
		xor	ebx, edi
		mov	ecx, [edx+18h]
		mov	eax, [edx+20h]
		xor	ecx, eax
		mov	eax, [edx+0Ch]
		xor	eax, ecx
		xor	ebx, [esp+24h+var_C]
		mov	ecx, [edx-8]
		xor	ecx, eax
		ror	[esp+24h+var_C], 2
		rol	ecx, 1
		mov	[edx+18h], ecx
		mov	edx, ebp
		rol	edx, 5
		add	edx, esi
		mov	esi, [esp+24h+var_14]
		add	ebx, edx
		mov	ecx, [esi+18h]
		add	ecx, 0CA62C1D6h
		add	ebx, ecx
		mov	ecx, [esi+24h]
		mov	eax, [esi+1Ch]
		mov	edx, ebx
		xor	ecx, eax
		rol	edx, 5
		mov	eax, [esi+10h]
		add	edi, edx
		mov	edx, [esp+24h+var_14]
		xor	eax, ecx
		mov	ecx, [esi-4]
		xor	ecx, eax
		mov	eax, ebp
		rol	ecx, 1
		mov	[esi+1Ch], ecx
		mov	ecx, [esp+24h+var_14]
		mov	esi, [esp+24h+var_8]
		xor	eax, esi
		xor	eax, [esp+24h+var_C]
		add	edi, eax
		ror	ebp, 2
		mov	ecx, [ecx+1Ch]
		add	ecx, 0CA62C1D6h
		add	edi, ecx
		mov	ecx, [edx+20h]
		mov	eax, [edx-18h]
		xor	ecx, eax
		mov	eax, [edx+14h]
		xor	eax, ecx
		mov	ecx, [edx]
		xor	ecx, eax
		mov	eax, ebp
		rol	ecx, 1
		mov	[edx+20h], ecx
		mov	edx, edi
		rol	edx, 5
		mov	ecx, [esp+24h+var_14]
		xor	eax, ebx
		xor	eax, [esp+24h+var_C]
		add	esi, edx
		mov	edx, [esp+24h+var_14]
		add	esi, eax
		ror	ebx, 2
		mov	ecx, [ecx+20h]
		add	ecx, 0CA62C1D6h
		add	esi, ecx
		mov	ecx, [edx+18h]
		mov	eax, [edx+24h]
		xor	ecx, eax
		mov	eax, [edx-14h]
		xor	eax, ecx
		mov	ecx, [edx+4]
		xor	ecx, eax
		mov	eax, ebp
		rol	ecx, 1
		xor	eax, ebx
		mov	[edx+24h], ecx
		xor	eax, edi
		mov	ecx, [esp+24h+var_14]
		mov	edx, esi
		rol	edx, 5
		add	edx, [esp+24h+var_C]
		add	eax, edx
		ror	edi, 2
		mov	ecx, [ecx+24h]
		add	ecx, 0CA62C1D6h
		add	eax, ecx
		mov	ecx, [esp+24h+var_14]
		add	[ecx-2Ch], eax
		add	[ecx-28h], esi
		add	[ecx-24h], edi
		add	[ecx-20h], ebx
		add	[ecx-1Ch], ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
sub_10007410	endp

; Exported entry  35. ?EcmaScriptConverter@DoubleToStringConverter@double_conversion@@SAABV12@XZ

; =============== S U B	R O U T	I N E =======================================


; const	struct double_conversion::DoubleToStringConverter *__cdecl double_conversion::DoubleToStringConverter::EcmaScriptConverter()
		public ?EcmaScriptConverter@DoubleToStringConverter@double_conversion@@SAABV12@XZ
?EcmaScriptConverter@DoubleToStringConverter@double_conversion@@SAABV12@XZ proc	near
					; CODE XREF: sub_10011370+13p
					; DATA XREF: .rdata:off_100175A8o
		mov	eax, dword_1001AC18
		test	al, 1
		jz	short loc_10008841

loc_1000883B:				; CODE XREF: double_conversion::DoubleToStringConverter::EcmaScriptConverter(void)+1Fj
		mov	eax, offset dword_1001ABF8
		retn
; ---------------------------------------------------------------------------

loc_10008841:				; CODE XREF: double_conversion::DoubleToStringConverter::EcmaScriptConverter(void)+7j
		sub	esp, 20h
		or	eax, 1
		mov	dword_1001AC18,	eax
		call	sub_100094D9
		jmp	short loc_1000883B
?EcmaScriptConverter@DoubleToStringConverter@double_conversion@@SAABV12@XZ endp


; =============== S U B	R O U T	I N E =======================================


sub_10008853	proc near		; CODE XREF: sub_10008958+1FFp

var_1		= byte ptr -1
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch
arg_1C		= dword	ptr  20h

; FUNCTION CHUNK AT 1000D730 SIZE 0000002B BYTES

		push	ecx
		mov	[esp+4+var_1], dl
		mov	edx, [esp+4+arg_8]
		push	ebx
		mov	ebx, [esp+8+arg_C]
		push	ebp
		mov	ebp, [esp+0Ch+arg_10]
		push	esi
		mov	esi, [esp+10h+arg_1C]
		push	edi
		mov	edi, [esp+14h+arg_14]
		push	esi
		push	[esp+18h+arg_18]
		push	edi
		push	ebp
		push	ebx
		push	[esp+28h+arg_4]
		push	[esp+2Ch+arg_0]
		test	ecx, ecx
		jns	short loc_1000889E
		test	edx, edx
		js	short loc_100088A5
		call	sub_100088AC

loc_1000888D:				; CODE XREF: sub_10008853+50j
					; sub_10008853+57j
		add	esp, 1Ch
		test	bl, bl
		jnz	loc_1000D730

loc_10008898:				; CODE XREF: sub_10008853+4EE2j
					; sub_10008853+4F03j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1000889E:				; CODE XREF: sub_10008853+2Fj
		call	sub_10013A5E
		jmp	short loc_1000888D
; ---------------------------------------------------------------------------

loc_100088A5:				; CODE XREF: sub_10008853+33j
		call	sub_100139F5
		jmp	short loc_1000888D
sub_10008853	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100088AC	proc near		; CODE XREF: sub_10008853+35p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

; FUNCTION CHUNK AT 1000D75B SIZE 00000028 BYTES

		push	ebp
		mov	ebp, esp
		push	esi
		push	edi
		push	[ebp+arg_4]
		mov	edi, ecx
		mov	esi, edx
		push	[ebp+arg_0]
		mov	ecx, [ebp+arg_C]
		call	sub_1000919E
		push	esi
		push	ecx
		mov	ecx, [ebp+arg_10]
		call	sub_10008FB5
		mov	ecx, [ebp+arg_10]
		neg	edi
		push	edi
		call	sub_1000911A
		cmp	[ebp+arg_8], 0
		pop	edi
		pop	esi
		jnz	loc_1000D75B
		pop	ebp
		retn
sub_100088AC	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100088E6	proc near		; CODE XREF: sub_10008958+22Fp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

; FUNCTION CHUNK AT 1000D783 SIZE 00000012 BYTES

		push	ebp
		mov	ebp, esp
		push	ebx
		push	esi
		mov	esi, [ebp+arg_10]
		mov	ebx, ecx
		push	edi
		mov	edi, [ebp+arg_4]
		test	dl, dl
		push	[ebp+arg_8]
		mov	ecx, edi
		mov	edx, esi
		jz	short loc_1000894C
		call	sub_10008C25
		pop	ecx
		test	eax, eax
		jns	short loc_10008942

loc_10008909:				; CODE XREF: sub_100088E6+6Ej
		mov	eax, [ebp+arg_0]
		mov	ecx, edi
		push	0Ah
		mov	[eax], ebx
		pop	ebx
		push	ebx
		call	sub_10009096
		mov	edi, [ebp+arg_C]
		mov	edx, esi
		mov	ecx, edi
		call	sub_1000A406
		mov	ecx, edi
		push	ebx
		test	eax, eax
		jnz	loc_1000D783
		call	sub_10009096
		push	edi
		mov	ecx, esi
		call	sub_10009150

loc_1000893D:				; CODE XREF: sub_100088E6+64j
					; sub_100088E6+4EAAj
		pop	edi
		pop	esi
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10008942:				; CODE XREF: sub_100088E6+21j
					; sub_100088E6+70j
		mov	eax, [ebp+arg_0]
		lea	ecx, [ebx+1]
		mov	[eax], ecx
		jmp	short loc_1000893D
; ---------------------------------------------------------------------------

loc_1000894C:				; CODE XREF: sub_100088E6+17j
		call	sub_10008C25
		pop	ecx
		test	eax, eax
		jle	short loc_10008909
		jmp	short loc_10008942
sub_100088E6	endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_10008958(int,	int, double, int, int)
sub_10008958	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+F2p

var_8FC		= qword	ptr -8FCh
var_8E5		= byte ptr -8E5h
var_8E4		= dword	ptr -8E4h
var_8E0		= dword	ptr -8E0h
var_8DC		= dword	ptr -8DCh
var_8D8		= dword	ptr -8D8h
var_8D4		= dword	ptr -8D4h
var_8D0		= dword	ptr -8D0h
var_8CC		= dword	ptr -8CCh
var_8C8		= dword	ptr -8C8h
var_8C4		= qword	ptr -8C4h
var_8BC		= qword	ptr -8BCh
var_8B4		= dword	ptr -8B4h
var_8B0		= dword	ptr -8B0h
var_8AC		= dword	ptr -8ACh
var_8A8		= dword	ptr -8A8h
var_8A4		= dword	ptr -8A4h
var_8A0		= dword	ptr -8A0h
var_89C		= dword	ptr -89Ch
var_898		= dword	ptr -898h
var_894		= dword	ptr -894h
var_890		= dword	ptr -890h
var_88C		= dword	ptr -88Ch
var_888		= dword	ptr -888h
var_884		= dword	ptr -884h
var_880		= dword	ptr -880h
var_87C		= dword	ptr -87Ch
var_878		= dword	ptr -878h
var_874		= dword	ptr -874h
var_870		= dword	ptr -870h
var_86C		= dword	ptr -86Ch
var_868		= dword	ptr -868h
var_864		= qword	ptr -864h
var_85C		= qword	ptr -85Ch
var_854		= qword	ptr -854h
var_84C		= byte ptr -84Ch
var_63C		= byte ptr -63Ch
var_42C		= byte ptr -42Ch
var_21C		= byte ptr -21Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= qword	ptr  0Ch
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

; FUNCTION CHUNK AT 1000D795 SIZE 00000176 BYTES

		sub	esp, 8E8h
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+8E8h+var_8], eax
		mov	eax, [esp+8E8h+arg_0]
		fld	[esp+8E8h+arg_8]
		push	ebp
		push	esi
		mov	esi, ds:memmove
		mov	ebp, ecx
		mov	[esp+8F0h+var_8DC], eax
		mov	eax, [esp+8F0h+arg_4]
		mov	[esp+8F0h+var_8E0], eax
		push	edi
		mov	edi, edx
		mov	dword ptr [esp+8F4h+var_8C4], edi
		fst	[esp+8F4h+var_8BC]
		cmp	ebp, 1
		jz	loc_1000D795
		push	8		; size_t
		lea	eax, [esp+8F8h+var_864]
		push	eax		; void *
		lea	eax, [esp+8FCh+var_874]
		push	eax		; void *
		fstp	[esp+900h+var_864]
		call	esi ; memmove
		mov	eax, [esp+900h+var_874]
		lea	ecx, [esp+900h+var_884]
		add	esp, 0Ch
		mov	[esp+8F4h+var_884], eax
		mov	eax, [esp+8F4h+var_870]
		mov	[esp+8F4h+var_880], eax
		call	sub_10009CA5
		fld	[esp+8F4h+var_8BC]
		mov	[esp+8F4h+var_8D8], eax
		lea	eax, [esp+8F4h+var_85C]
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+8FCh+var_894]
		mov	[esp+8FCh+var_8D0], edx
		push	eax		; void *
		fstp	[esp+900h+var_85C]
		call	esi ; memmove
		mov	eax, [esp+900h+var_894]
		lea	ecx, [esp+900h+var_88C]
		add	esp, 0Ch
		mov	[esp+8F4h+var_88C], eax
		mov	eax, [esp+8F4h+var_890]
		mov	[esp+8F4h+var_888], eax
		call	sub_10009E0D
		fld	[esp+8F4h+var_8BC]
		mov	[esp+8F4h+var_8CC], eax
		lea	eax, [esp+8F4h+var_854]
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+8FCh+var_87C]
		push	eax		; void *
		fstp	[esp+900h+var_854]
		call	esi ; memmove
		mov	eax, [esp+900h+var_87C]
		lea	ecx, [esp+900h+var_86C]
		add	esp, 0Ch
		mov	[esp+8F4h+var_86C], eax
		mov	eax, [esp+8F4h+var_878]
		mov	[esp+8F4h+var_868], eax
		call	sub_10009CCB
		mov	[esp+8F4h+var_8E5], al
		mov	byte ptr [esp+8F4h+var_8C8], 0
		test	ebp, ebp
		jz	loc_10008C08

loc_10008A80:				; CODE XREF: sub_10008958+2B5j
		mov	ecx, [esp+8F4h+var_8D8]
		mov	eax, ecx
		and	eax, 1
		mov	byte ptr [esp+8F4h+var_8D4], 1
		or	eax, 0
		jnz	loc_10008C12

loc_10008A97:				; CODE XREF: sub_10008958+2BFj
		mov	eax, [esp+8F4h+var_8CC]
		mov	edx, ecx
		mov	esi, [esp+8F4h+var_8D0]
		mov	ecx, esi
		mov	[esp+8F4h+var_8E4], eax
		and	ecx, 100000h
		xor	eax, eax
		or	eax, ecx
		jz	loc_10008C1C

loc_10008AB7:				; CODE XREF: sub_10008958+4EF3j
		mov	eax, [esp+8F4h+var_8E4]
		add	eax, 34h
		mov	dword ptr [esp+8F4h+var_8C4], eax
		fild	dword ptr [esp+8F4h+var_8C4]
		push	ecx
		push	ecx
		fstp	[esp+8FCh+var_8C4]
		fld	[esp+8FCh+var_8C4]
		fmul	ds:dbl_100164D8
		fsub	ds:dbl_100164E0
		fstp	[esp+8FCh+var_8FC] ; double
		call	ceil
		pop	ecx
		pop	ecx
		call	__ftol2_sse
		mov	esi, eax
		cmp	ebp, 2
		jz	loc_1000D850

loc_10008AF6:				; CODE XREF: sub_10008958+4EFFj
		lea	ecx, [esp+8F4h+var_63C]
		call	sub_10009208
		lea	ecx, [esp+8F4h+var_84C]
		call	sub_10009208
		lea	ecx, [esp+8F4h+var_21C]
		call	sub_10009208
		lea	ecx, [esp+8F4h+var_42C]
		call	sub_10009208
		mov	edx, [esp+8F4h+var_8D0]
		mov	eax, ecx
		mov	ecx, [esp+8F4h+var_8CC]
		push	eax
		lea	eax, [esp+8F8h+var_21C]
		push	eax
		lea	eax, [esp+8FCh+var_84C]
		push	eax
		lea	eax, [esp+900h+var_63C]
		push	eax
		push	[esp+904h+var_8C8]
		push	esi
		push	edx
		push	[esp+910h+var_8D8]
		mov	dl, [esp+914h+var_8E5]
		call	sub_10008853
		mov	dl, byte ptr [esp+914h+var_8D4]
		lea	eax, [esp+914h+var_42C]
		push	eax
		lea	eax, [esp+918h+var_21C]
		mov	ecx, esi
		push	eax
		lea	eax, [esp+91Ch+var_84C]
		push	eax
		lea	eax, [esp+920h+var_63C]
		push	eax
		mov	eax, [esp+924h+var_8E0]
		push	eax
		call	sub_100088E6
		add	esp, 34h
		test	ebp, ebp
		js	loc_1000D8F0
		cmp	ebp, 1
		jle	loc_1000D8AE
		cmp	ebp, 2
		jz	loc_1000D87B
		cmp	ebp, 3
		jnz	loc_1000D8F0
		push	[esp+8F4h+arg_14]
		mov	esi, [esp+8F8h+var_8DC]
		lea	eax, [esp+8F8h+var_84C]
		push	[esp+8F8h+arg_10]
		mov	edx, [esp+8FCh+var_8E0]
		mov	ecx, edi
		push	esi
		push	eax
		lea	eax, [esp+904h+var_63C]
		push	eax
		call	sub_10008D3A

loc_10008BE0:				; CODE XREF: sub_10008958+4F51j
		add	esp, 14h

loc_10008BE3:				; CODE XREF: sub_10008958+4F93j
		mov	ecx, [esi]
		mov	eax, [esp+8F4h+arg_10]
		mov	byte ptr [eax+ecx], 0

loc_10008BF0:				; CODE XREF: sub_10008958+4F1Ej
		mov	ecx, [esp+8F4h+var_8]
		pop	edi
		pop	esi
		pop	ebp
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 8E8h
		retn
; ---------------------------------------------------------------------------

loc_10008C08:				; CODE XREF: sub_10008958+122j
					; sub_10008958+4ED1j
		mov	byte ptr [esp+8F4h+var_8C8], 1
		jmp	loc_10008A80
; ---------------------------------------------------------------------------

loc_10008C12:				; CODE XREF: sub_10008958+139j
		mov	byte ptr [esp+8F4h+var_8D4], 0
		jmp	loc_10008A97
; ---------------------------------------------------------------------------

loc_10008C1C:				; CODE XREF: sub_10008958+159j
		mov	edi, [esp+8F4h+var_8E4]
		jmp	loc_1000D82E
sub_10008958	endp


; =============== S U B	R O U T	I N E =======================================


sub_10008C25	proc near		; CODE XREF: sub_100088E6+19p
					; sub_100088E6:loc_1000894Cp ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000D90B SIZE 00000018 BYTES

		sub	esp, 0Ch
		push	ebx
		push	esi
		push	edi
		mov	edi, edx
		mov	ebx, ecx

loc_10008C2F:				; CODE XREF: sub_10008C25+4CECj
		mov	esi, [ebx+20Ch]
		mov	eax, [edi+20Ch]
		add	esi, [ebx+208h]
		add	eax, [edi+208h]
		cmp	esi, eax
		jl	loc_1000D90B
		mov	eax, [esp+18h+arg_0]
		mov	edx, [ebx+208h]
		mov	esi, [ebx+20Ch]
		add	edx, esi
		mov	ecx, [eax+20Ch]
		mov	eax, [eax+208h]
		add	ecx, eax
		lea	eax, [edx+1]
		cmp	eax, ecx
		jge	short loc_10008C80

loc_10008C76:				; CODE XREF: sub_10008C25+4CF9j
		or	eax, 0FFFFFFFFh

loc_10008C79:				; CODE XREF: sub_10008C25+FAj
					; sub_10008C25+107j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_10008C80:				; CODE XREF: sub_10008C25+4Fj
		cmp	edx, ecx
		jg	loc_10008D29
		mov	eax, [edi+208h]
		add	eax, [edi+20Ch]
		cmp	edx, ecx
		jl	loc_1000D916

loc_10008C9C:				; CODE XREF: sub_10008C25+4CF3j
		mov	eax, [edi+20Ch]
		push	ebp
		xor	ebp, ebp
		cmp	esi, eax
		jl	short loc_10008CAB
		mov	esi, eax

loc_10008CAB:				; CODE XREF: sub_10008C25+82j
		mov	edx, [esp+1Ch+arg_0]
		mov	eax, [edx+20Ch]
		cmp	esi, eax
		jge	short loc_10008D31

loc_10008CB9:				; CODE XREF: sub_10008C25+10Ej
		lea	eax, [ecx-1]
		mov	[esp+1Ch+var_C], eax
		cmp	eax, esi
		jl	short loc_10008D1C

loc_10008CC4:				; CODE XREF: sub_10008C25+F1j
		push	eax
		mov	ecx, edx
		call	sub_10008EB9
		push	[esp+1Ch+var_C]
		mov	ecx, ebx
		mov	[esp+20h+var_4], eax
		call	sub_10008EB9
		push	[esp+1Ch+var_C]
		mov	ecx, edi
		mov	[esp+20h+var_8], eax
		call	sub_10008EB9
		mov	ecx, [esp+1Ch+var_4]
		mov	edx, [esp+1Ch+var_8]
		add	edx, eax
		lea	eax, [ecx+ebp]
		cmp	edx, eax
		ja	short loc_10008D35
		sub	ecx, edx
		add	ebp, ecx
		cmp	ebp, 1
		ja	short loc_10008D24
		mov	eax, [esp+1Ch+var_C]
		mov	edx, [esp+1Ch+arg_0]
		shl	ebp, 1Ch
		dec	eax
		mov	[esp+1Ch+var_C], eax
		cmp	eax, esi
		jge	short loc_10008CC4
		test	ebp, ebp
		jnz	short loc_10008D24

loc_10008D1C:				; CODE XREF: sub_10008C25+9Dj
		xor	eax, eax

loc_10008D1E:				; CODE XREF: sub_10008C25+102j
					; sub_10008C25+113j
		pop	ebp
		jmp	loc_10008C79
; ---------------------------------------------------------------------------

loc_10008D24:				; CODE XREF: sub_10008C25+DDj
					; sub_10008C25+F5j
		or	eax, 0FFFFFFFFh
		jmp	short loc_10008D1E
; ---------------------------------------------------------------------------

loc_10008D29:				; CODE XREF: sub_10008C25+5Dj
		xor	eax, eax
		inc	eax
		jmp	loc_10008C79
; ---------------------------------------------------------------------------

loc_10008D31:				; CODE XREF: sub_10008C25+92j
		mov	esi, eax
		jmp	short loc_10008CB9
; ---------------------------------------------------------------------------

loc_10008D35:				; CODE XREF: sub_10008C25+D4j
		xor	eax, eax
		inc	eax
		jmp	short loc_10008D1E
sub_10008C25	endp


; =============== S U B	R O U T	I N E =======================================


sub_10008D3A	proc near		; CODE XREF: sub_10008958+283p
					; sub_100129A9+60p

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ecx
		push	ebx
		push	ebp
		mov	ebp, [esp+0Ch+arg_0]
		xor	ebx, ebx
		push	esi
		push	edi
		mov	edi, ecx
		mov	[esp+14h+var_4], edx
		lea	esi, [edi-1]
		test	esi, esi
		jle	short loc_10008D78

loc_10008D52:				; CODE XREF: sub_10008D3A+3Cj
		push	[esp+14h+arg_4]
		mov	ecx, ebp
		call	sub_10008EE7
		movzx	ecx, ax
		mov	eax, [esp+14h+arg_C]
		add	cl, 30h
		push	0Ah
		mov	[eax+ebx], cl
		mov	ecx, ebp
		call	sub_10009096
		inc	ebx
		cmp	ebx, esi
		jl	short loc_10008D52

loc_10008D78:				; CODE XREF: sub_10008D3A+16j
		push	[esp+14h+arg_4]
		mov	ecx, ebp
		call	sub_10008EE7
		push	[esp+14h+arg_4]
		mov	edx, ebp
		movzx	ebx, ax
		mov	ecx, ebp
		call	sub_10008C25
		pop	ecx
		test	eax, eax
		jns	short loc_10008DC2

loc_10008D98:				; CODE XREF: sub_10008D3A+89j
		mov	eax, [esp+14h+arg_C]
		add	bl, 30h
		mov	[eax+edi-1], bl

loc_10008DA3:				; CODE XREF: sub_10008D3A+98j
		mov	eax, [esp+14h+arg_C]
		test	esi, esi
		jle	short loc_10008DB1
		cmp	byte ptr [eax+esi], 3Ah
		jz	short loc_10008DC5

loc_10008DB1:				; CODE XREF: sub_10008D3A+6Fj
		cmp	byte ptr [eax],	3Ah
		jz	short loc_10008DD4

loc_10008DB6:				; CODE XREF: sub_10008D3A+A3j
		mov	eax, [esp+14h+arg_8]
		mov	[eax], edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_10008DC2:				; CODE XREF: sub_10008D3A+5Cj
		inc	ebx
		jmp	short loc_10008D98
; ---------------------------------------------------------------------------

loc_10008DC5:				; CODE XREF: sub_10008D3A+75j
		mov	byte ptr [eax+esi], 30h
		mov	eax, [esp+14h+arg_C]
		inc	byte ptr [eax+esi-1]
		dec	esi
		jmp	short loc_10008DA3
; ---------------------------------------------------------------------------

loc_10008DD4:				; CODE XREF: sub_10008D3A+7Aj
		mov	byte ptr [eax],	31h
		mov	eax, [esp+14h+var_4]
		inc	dword ptr [eax]
		jmp	short loc_10008DB6
sub_10008D3A	endp


; =============== S U B	R O U T	I N E =======================================


sub_10008DDF	proc near		; CODE XREF: sub_1000911A+2Cp

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000D923 SIZE 0000001A BYTES

		push	ecx
		push	ebx
		push	esi
		mov	esi, ecx
		xor	ebx, ebx
		mov	ecx, ebx
		mov	[esp+0Ch+var_4], ebx
		cmp	[esi+208h], ebx
		jle	short loc_10008E39
		push	ebp
		push	edi
		push	1Ch
		pop	ebp
		sub	ebp, [esp+14h+arg_0]

loc_10008DFD:				; CODE XREF: sub_10008DDF+4Ej
		mov	edx, [esi+200h]
		mov	eax, [edx+ecx*4]
		mov	edi, eax
		mov	ecx, ebp
		shr	edi, cl
		mov	ecx, [esp+14h+arg_0]
		shl	eax, cl
		mov	ecx, [esp+14h+var_4]
		add	eax, ebx
		and	eax, 0FFFFFFFh
		mov	ebx, edi
		mov	[edx+ecx*4], eax
		inc	ecx
		mov	[esp+14h+var_4], ecx
		cmp	ecx, [esi+208h]
		jl	short loc_10008DFD
		test	edi, edi
		jnz	loc_1000D923

loc_10008E37:				; CODE XREF: sub_10008DDF+4B59j
		pop	edi
		pop	ebp

loc_10008E39:				; CODE XREF: sub_10008DDF+13j
		pop	esi
		pop	ebx
		pop	ecx
		retn	4
sub_10008DDF	endp


; =============== S U B	R O U T	I N E =======================================


sub_10008E3F	proc near		; CODE XREF: sub_10008EE7+34p
					; sub_1001271C+Bp ...

arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000D93D SIZE 00000059 BYTES

		mov	eax, [esp+arg_0]
		push	esi
		mov	esi, ecx
		push	edi
		mov	eax, [eax+20Ch]
		mov	edi, [esi+20Ch]
		cmp	edi, eax
		jg	loc_1000D93D

loc_10008E5B:				; CODE XREF: sub_10008E3F+4B52j
		pop	edi
		pop	esi
		retn	4
sub_10008E3F	endp


; =============== S U B	R O U T	I N E =======================================


sub_10008E60	proc near		; CODE XREF: sub_10008FB5+21p
					; sub_10009096:loc_10009113p ...

; FUNCTION CHUNK AT 1000D996 SIZE 00000017 BYTES

		push	esi
		xor	esi, esi
		mov	edx, esi
		cmp	[ecx+208h], esi
		jg	loc_1000D996

loc_10008E71:				; CODE XREF: sub_10008E60+4B48j
		mov	[ecx+208h], esi
		mov	[ecx+20Ch], esi
		pop	esi
		retn
sub_10008E60	endp


; =============== S U B	R O U T	I N E =======================================


sub_10008E7F	proc near		; CODE XREF: sub_10008EE7+B5p
					; sub_1000919E+46p ...
		push	esi
		xor	esi, esi
		cmp	[ecx+208h], esi
		jle	short loc_10008EAD
		mov	edx, [ecx+200h]

loc_10008E90:				; CODE XREF: sub_10008E7F+26j
		mov	eax, [ecx+208h]
		cmp	[edx+eax*4-4], esi
		jnz	short loc_10008EA7
		dec	eax
		mov	[ecx+208h], eax
		test	eax, eax
		jg	short loc_10008E90

loc_10008EA7:				; CODE XREF: sub_10008E7F+1Bj
		cmp	[ecx+208h], esi

loc_10008EAD:				; CODE XREF: sub_10008E7F+9j
		jz	short loc_10008EB1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_10008EB1:				; CODE XREF: sub_10008E7F:loc_10008EADj
		mov	[ecx+20Ch], esi
		pop	esi
		retn
sub_10008E7F	endp


; =============== S U B	R O U T	I N E =======================================


sub_10008EB9	proc near		; CODE XREF: sub_10008C25+A2p
					; sub_10008C25+B1p ...

arg_0		= dword	ptr  4

		mov	eax, [ecx+208h]
		mov	edx, [esp+arg_0]
		push	esi
		mov	esi, [ecx+20Ch]
		add	eax, esi
		cmp	edx, eax
		jge	short loc_10008EE3
		cmp	edx, esi
		jl	short loc_10008EE3
		mov	eax, [ecx+200h]
		sub	edx, esi
		mov	eax, [eax+edx*4]

loc_10008EDF:				; CODE XREF: sub_10008EB9+2Cj
		pop	esi
		retn	4
; ---------------------------------------------------------------------------

loc_10008EE3:				; CODE XREF: sub_10008EB9+15j
					; sub_10008EB9+19j
		xor	eax, eax
		jmp	short loc_10008EDF
sub_10008EB9	endp


; =============== S U B	R O U T	I N E =======================================


sub_10008EE7	proc near		; CODE XREF: sub_10008D3A+1Ep
					; sub_10008D3A+44p ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000D9AD SIZE 0000008D BYTES

		sub	esp, 0Ch
		push	ebx
		mov	ebx, [esp+10h+arg_0]
		push	edi
		mov	edi, ecx
		mov	eax, [ebx+208h]
		add	eax, [ebx+20Ch]
		mov	edx, [edi+20Ch]
		add	edx, [edi+208h]
		cmp	edx, eax
		jge	short loc_10008F18
		xor	eax, eax

loc_10008F10:				; CODE XREF: sub_10008EE7+BFj
		pop	edi
		pop	ebx
		add	esp, 0Ch
		retn	4
; ---------------------------------------------------------------------------

loc_10008F18:				; CODE XREF: sub_10008EE7+25j
		push	ebp
		push	esi
		push	ebx
		call	sub_10008E3F
		mov	ecx, [edi+20Ch]
		xor	ebp, ebp
		mov	eax, [ebx+208h]
		mov	edx, [edi+208h]
		add	ecx, edx
		add	eax, [ebx+20Ch]
		mov	[esp+1Ch+arg_0], ebp
		cmp	ecx, eax
		jg	short loc_10008FAB

loc_10008F44:				; CODE XREF: sub_10008EE7+4B04j
		mov	eax, [edi+208h]
		mov	ecx, [edi+200h]
		mov	edx, [ecx+eax*4-4]
		mov	ecx, [ebx+208h]
		mov	eax, [ebx+200h]
		mov	[esp+1Ch+var_8], edx
		mov	esi, [eax+ecx*4-4]
		mov	eax, edx
		xor	edx, edx
		mov	[esp+1Ch+var_C], esi
		cmp	ecx, 1
		jnz	loc_1000D9F0
		div	esi
		mov	edx, [esp+1Ch+var_8]
		mov	esi, eax
		mov	eax, [edi+208h]
		mov	ecx, esi
		imul	ecx, [esp+1Ch+var_C]
		sub	edx, ecx
		mov	ecx, [edi+200h]
		mov	[ecx+eax*4-4], edx
		mov	ecx, edi
		call	sub_10008E7F
		lea	eax, [esi+ebp]

loc_10008FA4:				; CODE XREF: sub_10008EE7+4B4Ej
		pop	esi
		pop	ebp
		jmp	loc_10008F10
; ---------------------------------------------------------------------------

loc_10008FAB:				; CODE XREF: sub_10008EE7+5Bj
		mov	si, word ptr [esp+1Ch+arg_0]
		jmp	loc_1000D9AD
sub_10008EE7	endp


; =============== S U B	R O U T	I N E =======================================


sub_10008FB5	proc near		; CODE XREF: sub_100088AC+1Cp
					; sub_100139F5+11p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_4		= dword	ptr  8

; FUNCTION CHUNK AT 1000DA3A SIZE 000000A8 BYTES

		sub	esp, 18h
		push	ebx
		mov	ebx, [esp+1Ch+arg_4]
		mov	[esp+1Ch+var_18], 0Ah
		push	edi
		mov	edi, ecx
		mov	[esp+20h+var_4], edi
		test	ebx, ebx
		jz	loc_10009078
		push	ebp
		push	esi
		call	sub_10008E60
		mov	ax, word ptr [esp+28h+var_18]
		xor	ebp, ebp

loc_10008FE2:				; CODE XREF: sub_10008FB5+38j
		shr	ax, 1
		inc	ebp
		mov	word ptr [esp+28h+var_18], ax
		test	al, 1
		jz	short loc_10008FE2
		movzx	eax, ax
		xor	ecx, ecx
		mov	[esp+28h+var_10], ebp
		mov	[esp+28h+var_18], ecx
		mov	[esp+28h+var_14], eax
		test	eax, eax
		jz	short loc_1000900D

loc_10009004:				; CODE XREF: sub_10008FB5+52j
		inc	ecx
		sar	eax, 1
		jnz	short loc_10009004
		mov	[esp+28h+var_18], ecx

loc_1000900D:				; CODE XREF: sub_10008FB5+4Dj
		mov	eax, ecx
		imul	eax, ebx
		push	1Ch
		pop	ecx
		cdq
		idiv	ecx
		add	eax, 2
		push	eax
		call	sub_10009240
		xor	esi, esi
		inc	esi
		cmp	ebx, esi
		jl	short loc_1000902E

loc_10009028:				; CODE XREF: sub_10008FB5+77j
		add	esi, esi
		cmp	ebx, esi
		jge	short loc_10009028

loc_1000902E:				; CODE XREF: sub_10008FB5+71j
		mov	eax, [esp+28h+var_14]
		cdq
		sar	esi, 2
		mov	ecx, eax
		mov	[esp+28h+var_C], eax
		mov	eax, edx
		mov	[esp+28h+var_8], edx
		mov	byte ptr [esp+28h+arg_4], 0
		test	esi, esi
		jnz	loc_1000DA3A

loc_1000904F:				; CODE XREF: sub_10008FB5+4B08j
		push	eax
		push	ecx
		mov	ecx, edi
		call	sub_1000919E
		cmp	byte ptr [esp+28h+arg_4], 0
		jnz	short loc_10009080

loc_1000905F:				; CODE XREF: sub_10008FB5+D6j
		test	esi, esi
		jnz	short loc_1000908D

loc_10009063:				; CODE XREF: sub_10008FB5+4B28j
		imul	ebp, ebx
		mov	ecx, edi
		push	ebp
		call	sub_1000911A
		pop	esi
		pop	ebp

loc_10009070:				; CODE XREF: sub_10008FB5+C9j
		pop	edi
		pop	ebx
		add	esp, 18h
		retn	8
; ---------------------------------------------------------------------------

loc_10009078:				; CODE XREF: sub_10008FB5+19j
		push	ecx
		call	sub_100091EF
		jmp	short loc_10009070
; ---------------------------------------------------------------------------

loc_10009080:				; CODE XREF: sub_10008FB5+A8j
		push	[esp+28h+var_14]
		mov	ecx, edi
		call	sub_10009096
		jmp	short loc_1000905F
; ---------------------------------------------------------------------------

loc_1000908D:				; CODE XREF: sub_10008FB5+ACj
		mov	ebp, [esp+28h+var_14]
		jmp	loc_1000DAC2
sub_10008FB5	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009096	proc near		; CODE XREF: sub_100088E6+2Ep
					; sub_100088E6+4Ap ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000DAE2 SIZE 00000036 BYTES

		push	ecx
		cmp	[esp+4+arg_0], 1
		push	ebx
		mov	ebx, ecx
		jz	short loc_100090B2
		cmp	[esp+8+arg_0], 0
		jz	short loc_10009113
		mov	eax, [ebx+208h]
		test	eax, eax
		jnz	short loc_100090B7

loc_100090B2:				; CODE XREF: sub_10009096+9j
					; sub_10009096+7Bj ...
		pop	ebx
		pop	ecx
		retn	4
; ---------------------------------------------------------------------------

loc_100090B7:				; CODE XREF: sub_10009096+1Aj
		push	ebp
		push	edi
		xor	ecx, ecx
		xor	ebp, ebp
		xor	edi, edi
		mov	[esp+10h+var_4], ecx
		test	eax, eax
		jle	short loc_1000910F
		push	esi

loc_100090C8:				; CODE XREF: sub_10009096+6Cj
		mov	esi, [ebx+200h]
		push	0
		push	[esp+18h+arg_0]
		push	0
		push	dword ptr [esi+ecx*4]
		call	__allmul
		mov	ecx, [esp+14h+var_4]
		add	ebp, eax
		mov	eax, ebp
		adc	edi, edx
		and	eax, 0FFFFFFFh
		shrd	ebp, edi, 1Ch
		mov	[esi+ecx*4], eax
		shr	edi, 1Ch
		inc	ecx
		mov	[esp+14h+var_4], ecx
		cmp	ecx, [ebx+208h]
		jl	short loc_100090C8
		pop	esi

loc_10009105:				; CODE XREF: sub_10009096+4A7Dj
		mov	eax, ebp
		or	eax, edi
		jnz	loc_1000DAE2

loc_1000910F:				; CODE XREF: sub_10009096+2Fj
		pop	edi
		pop	ebp
		jmp	short loc_100090B2
; ---------------------------------------------------------------------------

loc_10009113:				; CODE XREF: sub_10009096+10j
		call	sub_10008E60
		jmp	short loc_100090B2
sub_10009096	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000911A	proc near		; CODE XREF: sub_100088AC+27p
					; sub_10008FB5+B4p ...

arg_0		= dword	ptr  4

		push	edi
		mov	edi, ecx
		mov	ecx, [edi+208h]
		test	ecx, ecx
		jz	short loc_1000914C
		mov	eax, [esp+4+arg_0]
		push	esi
		push	1Ch
		pop	esi
		cdq
		idiv	esi
		add	[edi+20Ch], eax
		mov	esi, edx
		lea	eax, [ecx+1]
		push	eax
		call	sub_10009240
		push	esi
		mov	ecx, edi
		call	sub_10008DDF
		pop	esi

loc_1000914C:				; CODE XREF: sub_1000911A+Bj
		pop	edi
		retn	4
sub_1000911A	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009150	proc near		; CODE XREF: sub_100088E6+52p
					; sub_100139F5+21p ...

arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000DB18 SIZE 00000020 BYTES

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	edx, ecx
		push	edi
		xor	edi, edi
		mov	eax, [esi+20Ch]
		mov	[edx+20Ch], eax
		cmp	[esi+208h], edi
		jg	loc_1000DB18

loc_10009172:				; CODE XREF: sub_10009150+49E3j
		mov	ecx, [esi+208h]

loc_10009178:				; CODE XREF: sub_10009150+4Cj
		cmp	ecx, [edx+208h]
		jl	short loc_10009191
		mov	eax, [esi+208h]
		pop	edi
		mov	[edx+208h], eax
		pop	esi
		retn	4
; ---------------------------------------------------------------------------

loc_10009191:				; CODE XREF: sub_10009150+2Ej
		mov	eax, [edx+200h]
		and	dword ptr [eax+ecx*4], 0
		inc	ecx
		jmp	short loc_10009178
sub_10009150	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000919E	proc near		; CODE XREF: sub_100088AC+12p
					; sub_10008FB5+9Ep ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		mov	esi, ecx
		call	sub_10008E60
		mov	edi, [esp+8+arg_0]
		mov	eax, edi
		mov	edx, [esp+8+arg_4]
		or	eax, edx
		jz	short loc_100091EA
		push	ebx
		xor	ebx, ebx

loc_100091B8:				; CODE XREF: sub_1000919E+38j
		mov	eax, [esi+200h]
		mov	ecx, edi
		and	ecx, 0FFFFFFFh
		shrd	edi, edx, 1Ch
		mov	[ebx+eax], ecx
		add	ebx, 4
		shr	edx, 1Ch
		cmp	ebx, 0Ch
		jl	short loc_100091B8
		mov	ecx, esi
		mov	dword ptr [esi+208h], 3
		call	sub_10008E7F
		pop	ebx

loc_100091EA:				; CODE XREF: sub_1000919E+15j
		pop	edi
		pop	esi
		retn	8
sub_1000919E	endp


; =============== S U B	R O U T	I N E =======================================


sub_100091EF	proc near		; CODE XREF: sub_10008FB5+C4p
					; sub_100088AC+4EC7p ...
		call	sub_10008E60
		mov	eax, [ecx+200h]
		xor	edx, edx
		inc	edx
		mov	[eax], edx
		mov	[ecx+208h], edx
		retn	4
sub_100091EF	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009208	proc near		; CODE XREF: sub_10008958+1A5p
					; sub_10008958+1B1p ...
		mov	[ecx+200h], ecx
		mov	dword ptr [ecx+204h], 80h
		and	dword ptr [ecx+208h], 0
		and	dword ptr [ecx+20Ch], 0
		xor	edx, edx

loc_10009228:				; CODE XREF: sub_10009208+33j
		mov	eax, [ecx+200h]
		and	dword ptr [edx+eax], 0
		add	edx, 4
		cmp	edx, 200h
		jl	short loc_10009228
		mov	eax, ecx
		retn
sub_10009208	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009240	proc near		; CODE XREF: sub_10008FB5+67p
					; sub_1000911A+24p ...

arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000DB38 SIZE 0000001B BYTES

		cmp	[esp+arg_0], 80h
		jg	loc_1000DB38
		retn	4
sub_10009240	endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_10009251(int,	double,	int, int)
sub_10009251	proc near		; CODE XREF: sub_10009EA5+79p

var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= qword	ptr -38h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  4
arg_4		= qword	ptr  8
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		sub	esp, 40h
		fld	[esp+40h+arg_4]
		lea	eax, [esp+40h+var_38]
		push	ebx
		push	ebp
		push	esi
		push	edi
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+58h+arg_4]
		mov	[esp+58h+var_40], edx
		push	eax		; void *
		fstp	[esp+5Ch+var_38]
		mov	[esp+5Ch+var_3C], ecx
		call	ds:memmove
		mov	eax, dword ptr [esp+5Ch+arg_4]
		lea	ecx, [esp+5Ch+var_38]
		mov	dword ptr [esp+5Ch+var_38], eax
		add	esp, 0Ch
		mov	eax, dword ptr [esp+50h+arg_4+4]
		mov	dword ptr [esp+50h+var_38+4], eax
		lea	eax, [esp+50h+var_20]
		push	eax
		call	sub_10009E38
		lea	eax, [esp+50h+var_38]
		xor	ebp, ebp
		push	eax
		lea	eax, [esp+54h+var_30]
		mov	[esp+54h+var_30], ebp
		push	eax
		push	0FFFFFF84h
		pop	ecx
		sub	ecx, [esp+58h+var_18]
		mov	[esp+58h+var_2C], ebp
		mov	[esp+58h+var_28], ebp
		call	sub_1000A2C3
		pop	ecx
		lea	esi, [esp+54h+var_20]
		lea	edi, [esp+54h+var_10]
		movsd
		pop	ecx
		push	ebp
		push	[esp+54h+var_20]
		movsd
		push	ebp
		push	[esp+5Ch+var_2C]
		movsd
		movsd
		call	__allmul
		push	ebp
		push	[esp+54h+var_1C]
		mov	edi, eax
		mov	dword ptr [esp+58h+arg_4], edx
		push	ebp
		push	[esp+5Ch+var_30]
		call	__allmul
		mov	ecx, [esp+50h+var_28]
		mov	esi, eax
		push	0
		push	[esp+54h+var_20]
		add	ecx, 40h
		mov	ebp, edx
		add	ecx, [esp+58h+var_18]
		push	0
		push	[esp+5Ch+var_30]
		mov	[esp+60h+var_8], ecx
		call	__allmul
		xor	ebx, ebx
		add	edx, esi
		push	0
		adc	ebx, ebx
		add	edx, edi
		pop	edi
		push	edi
		push	[esp+54h+var_1C]
		adc	ebx, edi
		add	edx, 80000000h
		push	edi
		push	[esp+5Ch+var_2C]
		adc	ebx, edi
		xor	esi, esi
		call	__allmul
		push	[esp+50h+arg_10]
		add	ebx, eax
		mov	ecx, [esp+54h+var_3C]
		push	[esp+54h+arg_C]
		adc	esi, edx
		lea	eax, [esp+58h+arg_4]
		mov	edx, [esp+58h+var_40]
		add	ebx, ebp
		adc	esi, edi
		add	ebx, dword ptr [esp+58h+arg_4]
		mov	[esp+58h+var_10], ebx
		adc	esi, edi
		sub	esp, 10h
		mov	[esp+68h+var_C], esi
		mov	edi, esp
		lea	esi, [esp+68h+var_10]
		push	eax
		movsd
		movsd
		movsd
		movsd
		call	sub_10009391
		mov	ecx, [esp+6Ch+arg_0]
		add	esp, 1Ch
		mov	edx, dword ptr [esp+50h+arg_4]
		sub	edx, dword ptr [esp+50h+var_38]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], edx
		pop	ebx
		add	esp, 40h
		retn
sub_10009251	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009391	proc near		; CODE XREF: sub_10009251+122p

var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

; FUNCTION CHUNK AT 1000DB53 SIZE 00000085 BYTES

		sub	esp, 2Ch
		and	[esp+2Ch+var_2C], 0
		xor	eax, eax
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, ecx
		mov	ebx, edx
		mov	ecx, [esp+3Ch+arg_C]
		inc	eax
		mov	esi, ecx
		mov	[esp+3Ch+var_20], ecx
		neg	esi
		mov	[esp+3Ch+var_28], eax
		xor	edx, edx
		mov	ecx, esi
		call	__allshl
		mov	ebp, eax
		mov	[esp+3Ch+var_14], edx
		mov	eax, [esp+3Ch+arg_4]
		mov	ecx, esi
		mov	edx, [esp+3Ch+arg_8]
		mov	[esp+3Ch+var_4], ebp
		call	__aullshr
		mov	edx, [esp+3Ch+var_14]
		add	ebp, 0FFFFFFFFh
		mov	ecx, eax
		mov	[esp+3Ch+var_C], ebp
		adc	edx, 0FFFFFFFFh
		mov	[esp+3Ch+var_24], ecx
		and	ebp, [esp+3Ch+arg_4]
		lea	eax, [esp+3Ch+var_10]
		mov	[esp+3Ch+var_8], edx
		and	edx, [esp+3Ch+arg_8]
		mov	[esp+3Ch+var_1C], edx
		mov	edx, [esp+3Ch+var_20]
		push	eax
		lea	eax, [esp+40h+var_18]
		add	edx, 40h
		push	eax
		call	sub_1000A296
		mov	eax, [esp+44h+var_10]
		and	dword ptr [ebx], 0
		mov	esi, [esp+44h+var_18]
		pop	ecx
		pop	ecx
		mov	ecx, [esp+3Ch+arg_0]
		push	0Ah
		pop	edx
		mov	[ecx], eax
		test	eax, eax
		jle	short loc_1000945F

loc_10009429:				; CODE XREF: sub_10009391+C9j
		mov	eax, [esp+3Ch+var_24]
		xor	edx, edx
		div	esi
		mov	ecx, [ebx]
		mov	[esp+3Ch+var_24], edx
		lea	edx, [eax+30h]
		mov	eax, [esp+3Ch+arg_14]
		mov	[eax+ecx], dl
		mov	ecx, [esp+3Ch+arg_0]
		inc	dword ptr [ebx]
		dec	dword ptr [ecx]
		dec	edi
		jz	short loc_1000948D
		mov	eax, esi
		xor	edx, edx
		push	0Ah
		pop	esi
		div	esi
		cmp	dword ptr [ecx], 0
		mov	esi, eax
		jg	short loc_10009429
		push	0Ah
		pop	edx

loc_1000945F:				; CODE XREF: sub_10009391+96j
		test	edi, edi
		jz	short loc_1000948D
		mov	esi, [esp+3Ch+var_1C]
		jle	short loc_10009481

loc_10009469:				; CODE XREF: sub_10009391+481Bj
		cmp	esi, [esp+3Ch+var_2C]
		jb	short loc_10009481
		ja	loc_1000DB53
		mov	eax, [esp+3Ch+var_28]
		cmp	ebp, eax
		ja	loc_1000DB53

loc_10009481:				; CODE XREF: sub_10009391+D6j
					; sub_10009391+DCj ...
		test	edi, edi
		jz	loc_1000DBB7
		xor	al, al
		jmp	short loc_100094D1
; ---------------------------------------------------------------------------

loc_1000948D:				; CODE XREF: sub_10009391+B9j
					; sub_10009391+D0j
		push	[esp+3Ch+arg_18]
		mov	edi, [esp+40h+var_20]
		xor	eax, eax
		push	[esp+40h+arg_14]
		inc	eax
		neg	edi
		push	0
		push	eax
		mov	eax, esi
		xor	edx, edx
		mov	ecx, edi
		call	__allshl
		push	edx
		push	eax
		mov	eax, [esp+54h+var_24]
		xor	edx, edx
		mov	ecx, edi
		call	__allshl
		add	eax, ebp
		adc	edx, [esp+54h+var_1C]
		push	edx
		mov	edx, [esp+58h+arg_0]
		push	eax

loc_100094C7:				; CODE XREF: sub_10009391+4842j
		mov	ecx, [ebx]
		call	sub_1000A341
		add	esp, 20h

loc_100094D1:				; CODE XREF: sub_10009391+FAj
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 2Ch
		retn
sub_10009391	endp


; =============== S U B	R O U T	I N E =======================================


sub_100094D9	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::EcmaScriptConverter(void)+1Ap
		and	dword_1001AC14,	0
		mov	eax, offset dword_1001ABF8
		mov	dword_1001ABF8,	9
		mov	dword_1001ABFC,	offset aInfinity ; "Infinity"
		mov	dword_1001AC00,	offset aNan ; "NaN"
		mov	byte_1001AC04, 65h
		mov	dword_1001AC08,	0FFFFFFFAh
		mov	dword_1001AC0C,	15h
		mov	dword_1001AC10,	6
		retn	20h
sub_100094D9	endp

; Exported entry  48. ?ToPrecision@DoubleToStringConverter@double_conversion@@QBE_NNHPA_NPAVStringBuilder@2@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall double_conversion::DoubleToStringConverter::ToPrecision(double_conversion::DoubleToStringConverter *this, double, int, bool *, struct	double_conversion::StringBuilder *)
		public ?ToPrecision@DoubleToStringConverter@double_conversion@@QBE_NNHPA_NPAVStringBuilder@2@@Z
?ToPrecision@DoubleToStringConverter@double_conversion@@QBE_NNHPA_NPAVStringBuilder@2@@Z proc near
					; DATA XREF: .rdata:off_100175A8o

var_DC		= qword	ptr -0DCh
var_C4		= qword	ptr -0C4h
var_A9		= byte ptr -0A9h
var_A8		= dword	ptr -0A8h
var_A0		= dword	ptr -0A0h
var_9C		= dword	ptr -9Ch
var_98		= qword	ptr -98h
var_8C		= dword	ptr -8Ch
var_88		= byte ptr -88h
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

; FUNCTION CHUNK AT 1000DBD8 SIZE 00000052 BYTES

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 0ACh
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+0ACh+var_4], eax
		mov	eax, [ebp+arg_C]
		fld	[ebp+arg_0]
		push	ebx
		mov	ebx, [ebp+arg_10]
		push	esi
		push	edi
		mov	[esp+0B8h+var_8C], eax
		mov	edi, ecx
		mov	byte ptr [eax],	0
		lea	eax, [esp+0B8h+var_A8]
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+0C0h+var_A0]
		fst	[esp+0C0h+var_98]
		push	eax		; void *
		fstp	qword ptr [esp+0C4h+var_A8]
		call	ds:memmove
		mov	eax, [esp+0C4h+var_A0]
		lea	ecx, [esp+0C4h+var_A8]
		add	esp, 0Ch
		mov	[esp+0B8h+var_A8], eax
		mov	eax, [esp+0B8h+var_9C]
		mov	[esp+0B8h+var_A8+4], eax
		call	sub_10009DDB
		test	al, al
		jnz	loc_1000DBD8
		mov	esi, [ebp+arg_8]
		lea	eax, [esi-1]
		cmp	eax, 77h
		ja	loc_10009672
		fld	[esp+0B8h+var_98]
		lea	eax, [esp+0B8h+var_A0]
		push	eax
		lea	eax, [esp+0BCh+var_A8]
		push	eax
		lea	eax, [esp+0C0h+var_A9]
		push	eax
		push	79h
		lea	eax, [esp+0C8h+var_88]
		push	eax
		push	esi
		push	3
		push	ecx
		push	ecx
		fstp	[esp+0DCh+var_DC]
		call	?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z ; double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool	*,int *,int *)
		mov	cl, [edi]
		add	esp, 24h
		shr	cl, 3
		and	cl, 1
		cmp	[esp+0B8h+var_A9], 0
		jnz	short loc_10009641

loc_100095E0:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+134j
					; double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder *)+13Bj
		mov	edx, [esp+0B8h+var_A0]
		movsx	ecx, byte ptr [edi]
		and	ecx, 4
		shr	ecx, 2
		lea	eax, [edx-1]
		mov	[esp+0B8h+var_A0], eax
		xor	eax, eax
		inc	eax
		sub	eax, edx
		cmp	eax, [edi+18h]
		jg	loc_1000DBEE
		sub	ecx, esi
		add	ecx, edx
		cmp	ecx, [edi+1Ch]
		jg	loc_1000DBEE
		sub	esi, edx
		test	esi, esi
		jle	short loc_1000966E

loc_10009615:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+145j
		push	ebx		; struct double_conversion::StringBuilder *
		push	esi		; int
		push	edx		; size_t
		push	[esp+0C4h+var_A8] ; size_t
		lea	eax, [esp+0C8h+var_88]
		mov	ecx, edi	; this
		push	eax		; char *
		call	?CreateDecimalRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHHPAVStringBuilder@2@@Z	; double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const *,int,int,int,double_conversion::StringBuilder *)

loc_10009628:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+46FAj
		mov	al, 1

loc_1000962A:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+149j
					; double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder *)+46BEj
		mov	ecx, [esp+0B8h+var_4]
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn	14h
; ---------------------------------------------------------------------------

loc_10009641:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+B3j
		fldz
		fld	[esp+0B8h+var_98]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jnp	short loc_10009664

loc_10009650:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+141j
		mov	ecx, [ebx+8]
		lea	eax, [ecx+1]
		mov	[ebx+8], eax
		mov	eax, [ebx]
		mov	byte ptr [ecx+eax], 2Dh
		jmp	loc_100095E0
; ---------------------------------------------------------------------------

loc_10009664:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+123j
		test	cl, cl
		jnz	loc_100095E0
		jmp	short loc_10009650
; ---------------------------------------------------------------------------

loc_1000966E:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+E8j
		xor	esi, esi
		jmp	short loc_10009615
; ---------------------------------------------------------------------------

loc_10009672:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+76j
		xor	al, al
		jmp	short loc_1000962A
?ToPrecision@DoubleToStringConverter@double_conversion@@QBE_NNHPA_NPAVStringBuilder@2@@Z endp

; Exported entry  29. ?CreateDecimalRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHHPAVStringBuilder@2@@Z

; =============== S U B	R O U T	I N E =======================================


; void __thiscall double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(double_conversion::DoubleToStringConverter *this, const char *, size_t, size_t, int, struct double_conversion::StringBuilder *)
		public ?CreateDecimalRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHHPAVStringBuilder@2@@Z
?CreateDecimalRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHHPAVStringBuilder@2@@Z	proc near
					; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+F8p
					; double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+C6p	...

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

; FUNCTION CHUNK AT 1000DC2A SIZE 00000082 BYTES

		push	ecx
		push	ebx
		mov	ebx, [esp+8+arg_8]
		mov	edx, ecx
		mov	[esp+8+var_4], edx
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_10]
		test	ebx, ebx
		jle	loc_1000DC2A
		push	ebp
		mov	ebp, [esp+14h+arg_4]
		mov	ecx, edi
		cmp	ebx, ebp
		jl	short loc_100096DA
		push	ebp		; size_t
		push	[esp+18h+arg_0]	; void *
		call	sub_1000981D
		sub	ebx, ebp
		push	ebx
		push	ecx
		mov	ecx, edi
		call	sub_10009841
		mov	esi, [esp+14h+arg_C]
		test	esi, esi
		jg	short loc_10009717

loc_100096B8:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+9Fj
		pop	ebp

loc_100096B9:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+4609j
		mov	edx, [esp+10h+var_4]
		test	esi, esi

loc_100096BF:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+45C9j
		jnz	short loc_100096D3
		test	byte ptr [edx],	2
		jnz	loc_1000DC84

loc_100096CA:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+461Dj
		test	byte ptr [edx],	4
		jnz	loc_1000DC98

loc_100096D3:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *):loc_100096BFj
					; double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const *,int,int,int,double_conversion::StringBuilder *)+4631j
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn	14h
; ---------------------------------------------------------------------------

loc_100096DA:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+23j
		mov	esi, [esp+14h+arg_0]
		push	ebx		; size_t
		push	esi		; void *
		call	sub_1000981D
		mov	ecx, [edi+8]
		lea	eax, [ecx+1]
		mov	[edi+8], eax
		mov	eax, [edi]
		mov	byte ptr [ecx+eax], 2Eh
		mov	eax, ebp
		sub	eax, ebx
		mov	ecx, edi
		push	eax		; size_t
		lea	eax, [esi+ebx]
		push	eax		; void *
		call	sub_1000981D
		mov	esi, [esp+14h+arg_C]
		sub	ebx, ebp
		add	ebx, esi
		push	ebx

loc_1000970D:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+B1j
		push	ecx
		mov	ecx, edi
		call	sub_10009841
		jmp	short loc_100096B8
; ---------------------------------------------------------------------------

loc_10009717:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+40j
		mov	ecx, [edi+8]
		push	esi
		lea	eax, [ecx+1]
		mov	[edi+8], eax
		mov	eax, [edi]
		mov	byte ptr [ecx+eax], 2Eh
		jmp	short loc_1000970D
?CreateDecimalRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHHPAVStringBuilder@2@@Z	endp

; Exported entry  51. ?ToShortestIeeeNumber@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@W4DtoaMode@12@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: bool	__thiscall double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double, class double_conversion::StringBuilder *, enum  double_conversion::DoubleToStringConverter::DtoaMode)const
		public ?ToShortestIeeeNumber@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@W4DtoaMode@12@@Z
?ToShortestIeeeNumber@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@W4DtoaMode@12@@Z proc	near
					; CODE XREF: sub_10011370+39p
					; DATA XREF: .rdata:off_100175A8o

var_64		= qword	ptr -64h
var_4C		= qword	ptr -4Ch
var_31		= byte ptr -31h
var_30		= dword	ptr -30h
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= qword	ptr -20h
var_18		= byte ptr -18h
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

; FUNCTION CHUNK AT 1000DCAC SIZE 0000003D BYTES

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 38h
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+38h+var_4], eax
		fld	[ebp+arg_0]
		lea	eax, [esp+38h+var_30]
		push	esi
		push	edi
		mov	edi, [ebp+arg_8]
		mov	esi, ecx
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+48h+var_28]
		fst	[esp+48h+var_20]
		push	eax		; void *
		fstp	qword ptr [esp+4Ch+var_30]
		call	ds:memmove
		mov	eax, [esp+4Ch+var_28]
		lea	ecx, [esp+4Ch+var_30]
		add	esp, 0Ch
		mov	[esp+40h+var_30], eax
		mov	eax, [esp+40h+var_24]
		mov	[esp+40h+var_30+4], eax
		call	sub_10009DDB
		fld	[esp+40h+var_20]
		test	al, al
		jnz	loc_1000DCAC
		lea	eax, [esp+40h+var_28]
		push	eax
		lea	eax, [esp+44h+var_30]
		push	eax
		lea	eax, [esp+48h+var_31]
		push	eax
		push	12h
		lea	eax, [esp+50h+var_18]
		push	eax
		push	0
		push	[ebp+arg_C]
		push	ecx
		push	ecx
		fstp	[esp+64h+var_64]
		call	?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z ; double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool	*,int *,int *)
		mov	cl, [esi]
		add	esp, 24h
		shr	cl, 3
		and	cl, 1
		cmp	[esp+40h+var_31], 0
		jnz	loc_1000DCBE

loc_100097C4:				; CODE XREF: double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+45A6j
					; double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+45BBj
		mov	ecx, [esp+40h+var_28]
		lea	eax, [ecx-1]
		cmp	[esi+10h], eax
		jg	short loc_10009809
		cmp	eax, [esi+14h]
		jge	short loc_10009809
		mov	eax, [esp+40h+var_30]
		sub	eax, ecx
		test	eax, eax
		jg	short loc_100097E1
		xor	eax, eax

loc_100097E1:				; CODE XREF: double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+B4j
		push	edi		; struct double_conversion::StringBuilder *
		push	eax		; int
		push	ecx		; size_t
		push	[esp+4Ch+var_30] ; size_t
		lea	eax, [esp+50h+var_18]
		mov	ecx, esi	; this
		push	eax		; char *
		call	?CreateDecimalRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHHPAVStringBuilder@2@@Z	; double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const *,int,int,int,double_conversion::StringBuilder *)

loc_100097F4:				; CODE XREF: double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+F2j
		mov	al, 1

loc_100097F6:				; CODE XREF: double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+4590j
		mov	ecx, [esp+40h+var_4]
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn	10h
; ---------------------------------------------------------------------------

loc_10009809:				; CODE XREF: double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+A5j
					; double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+AAj
		push	edi		; struct double_conversion::StringBuilder *
		push	eax		; int
		push	[esp+48h+var_30] ; int
		lea	eax, [esp+4Ch+var_18]
		mov	ecx, esi	; this
		push	eax		; char *
		call	?CreateExponentialRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHPAVStringBuilder@2@@Z ; double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)
		jmp	short loc_100097F4
?ToShortestIeeeNumber@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@W4DtoaMode@12@@Z endp


; =============== S U B	R O U T	I N E =======================================


; int __stdcall	sub_1000981D(void *, size_t)
sub_1000981D	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+2Ap
					; double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const *,int,int,int,double_conversion::StringBuilder *)+6Ap ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_4]
		push	edi
		mov	edi, ecx
		push	esi		; size_t
		push	[esp+0Ch+arg_0]	; void *
		mov	eax, [edi]
		add	eax, [edi+8]
		push	eax		; void *
		call	ds:memmove
		add	[edi+8], esi
		add	esp, 0Ch
		pop	edi
		pop	esi
		retn	8
sub_1000981D	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009841	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+35p
					; double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const *,int,int,int,double_conversion::StringBuilder *)+9Ap ...

arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_4]
		push	edi
		mov	edi, ecx
		test	esi, esi
		jg	short loc_10009852

loc_1000984D:				; CODE XREF: sub_10009841+1Dj
		pop	edi
		pop	esi
		retn	8
; ---------------------------------------------------------------------------

loc_10009852:				; CODE XREF: sub_10009841+Aj
					; sub_10009841+1Bj
		push	30h
		mov	ecx, edi
		call	sub_10009860
		dec	esi
		jnz	short loc_10009852
		jmp	short loc_1000984D
sub_10009841	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009860	proc near		; CODE XREF: sub_10009841+15p
					; double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)+21p ...

arg_0		= byte ptr  4

		mov	edx, [ecx+8]
		lea	eax, [edx+1]
		mov	[ecx+8], eax
		mov	ecx, [ecx]
		mov	al, [esp+arg_0]
		mov	[edx+ecx], al
		retn	4
sub_10009860	endp

; Exported entry  34. ?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl double_conversion::DoubleToStringConverter::DoubleToAscii(double,	enum  double_conversion::DoubleToStringConverter::DtoaMode, int, char *, int, bool *, int *, int *)
		public ?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z
?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z proc near
					; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+9Ep
					; double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+80p	...

var_40		= qword	ptr -40h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= qword	ptr -10h
var_8		= qword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h
arg_20		= dword	ptr  28h

; FUNCTION CHUNK AT 1000DCE9 SIZE 00000055 BYTES

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 24h
		fld	[ebp+arg_0]
		lea	eax, [esp+24h+var_8]
		push	ebx
		mov	ebx, [ebp+arg_14]
		push	esi
		mov	esi, [ebp+arg_10]
		push	edi
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+38h+var_20]
		fst	[esp+38h+var_10]
		push	eax		; void *
		fstp	[esp+3Ch+var_8]
		call	ds:memmove
		mov	eax, [esp+3Ch+var_20]
		lea	ecx, [esp+3Ch+var_18]
		add	esp, 0Ch
		mov	[esp+30h+var_18], eax
		mov	eax, [esp+30h+var_1C]
		mov	[esp+30h+var_14], eax
		call	sub_10009DC6
		fld	[ebp+arg_0]
		xor	edx, edx
		test	eax, eax
		mov	eax, [ebp+arg_18]
		js	loc_10009977
		mov	[eax], dl

loc_100098D2:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+10Bj
		cmp	[ebp+arg_8], 3
		mov	ecx, [ebp+arg_C]
		jz	short loc_10009917

loc_100098DB:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+A4j
		fldz
		fucomp	st(1)
		fnstsw	ax
		test	ah, 44h
		jnp	loc_10009985
		mov	eax, [ebp+arg_8]
		sub	eax, edx
		jnz	short loc_10009920
		push	ebx		; int
		push	esi		; int
		push	ecx
		push	ecx
		xor	edx, edx
		xor	ecx, ecx

loc_100098F9:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+44C4j
		mov	ebx, [ebp+arg_20]
		mov	edi, [ebp+arg_1C]
		fstp	[esp+40h+var_40] ; double
		push	ebx		; int
		push	edi		; int

loc_10009904:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+D4j
		call	sub_10009EA5
		add	esp, 18h

loc_1000990C:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+44B6j
		test	al, al
		jz	short loc_1000994B

loc_10009910:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+100j
					; double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int	*)+124j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10009917:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+64j
		test	ecx, ecx
		jnz	short loc_100098DB
		jmp	loc_1000DCE9
; ---------------------------------------------------------------------------

loc_10009920:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+7Aj
		dec	eax
		jz	loc_1000DD30
		dec	eax
		jz	loc_1000DD13
		dec	eax
		jnz	loc_1000DCF7
		mov	edi, [ebp+arg_1C]
		mov	edx, ecx
		push	ebx
		mov	ebx, [ebp+arg_20]
		push	esi
		push	ecx
		push	ecx
		fstp	[esp+40h+var_40]
		push	ebx
		push	edi
		push	2
		pop	ecx
		jmp	short loc_10009904
; ---------------------------------------------------------------------------

loc_1000994B:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+99j
		mov	ecx, [ebp+arg_8]
		call	sub_1000A3E5
		push	[ebp+arg_14]	; int
		fld	[esp+34h+var_10]
		mov	edx, [ebp+arg_C]
		push	esi		; int
		push	ecx
		push	ecx
		fstp	[esp+40h+var_40] ; double
		push	ebx		; int
		push	edi		; int
		mov	ecx, eax
		call	sub_10008958
		mov	eax, [edi]
		add	esp, 18h
		mov	byte ptr [esi+eax], 0
		jmp	short loc_10009910
; ---------------------------------------------------------------------------

loc_10009977:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+55j
		fchs
		mov	byte ptr [eax],	1
		fst	[esp+30h+var_10]
		jmp	loc_100098D2
; ---------------------------------------------------------------------------

loc_10009985:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+6Fj
		mov	eax, [ebp+arg_1C]
		xor	ecx, ecx
		inc	ecx
		mov	word ptr [esi],	30h
		fstp	st
		mov	[eax], ecx
		mov	eax, [ebp+arg_20]
		mov	[eax], ecx
		jmp	loc_10009910
?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_1000999E(int,	double,	int, int)
sub_1000999E	proc near		; CODE XREF: sub_10009EA5+2Fp

var_70		= dword	ptr -70h
var_6C		= dword	ptr -6Ch
var_64		= dword	ptr -64h
var_60		= qword	ptr -60h
var_58		= dword	ptr -58h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  4
arg_4		= qword	ptr  8
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

; FUNCTION CHUNK AT 1000DD3E SIZE 00000041 BYTES

		sub	esp, 70h
		fld	[esp+70h+arg_4]
		lea	eax, [esp+70h+var_60]
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, ds:memmove
		mov	esi, ecx
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+88h+var_70]
		mov	[esp+88h+var_64], edx
		push	eax		; void *
		fstp	[esp+8Ch+var_60]
		call	edi ; memmove
		mov	eax, [esp+8Ch+var_70]
		lea	ecx, [esp+8Ch+var_60]
		mov	dword ptr [esp+8Ch+var_60], eax
		add	esp, 0Ch
		mov	eax, [esp+80h+var_6C]
		mov	dword ptr [esp+80h+var_60+4], eax
		lea	eax, [esp+80h+var_30]
		push	eax
		call	sub_10009E38
		fld	[esp+80h+arg_4]
		xor	ebp, ebp
		mov	[esp+80h+var_50], ebp
		mov	[esp+80h+var_4C], ebp
		mov	[esp+80h+var_48], ebp
		mov	[esp+80h+var_40], ebp
		mov	[esp+80h+var_3C], ebp
		mov	[esp+80h+var_38], ebp
		test	esi, esi
		jnz	loc_1000DD3E
		push	8		; size_t
		lea	eax, [esp+84h+var_60]
		push	eax		; void *
		lea	eax, [esp+88h+arg_4]
		push	eax		; void *
		fstp	[esp+8Ch+var_60]
		call	edi ; memmove
		mov	eax, dword ptr [esp+8Ch+arg_4]
		lea	ecx, [esp+8Ch+var_60]
		mov	dword ptr [esp+8Ch+var_60], eax
		add	esp, 0Ch
		mov	eax, dword ptr [esp+80h+arg_4+4]
		mov	dword ptr [esp+80h+var_60+4], eax
		lea	eax, [esp+80h+var_40]
		push	eax
		lea	eax, [esp+84h+var_50]
		push	eax
		call	sub_10009CEC

loc_10009A52:				; CODE XREF: sub_1000999E+43DCj
		lea	eax, [esp+80h+var_70]
		mov	dword ptr [esp+80h+var_60], ebp
		push	eax
		lea	eax, [esp+84h+var_60]
		mov	dword ptr [esp+84h+var_60+4], ebp
		push	eax
		push	0FFFFFF84h
		pop	ecx
		sub	ecx, [esp+88h+var_28]
		mov	[esp+88h+var_58], ebp
		call	sub_1000A2C3
		pop	ecx
		lea	esi, [esp+84h+var_30]
		lea	edi, [esp+84h+var_20]
		movsd
		pop	ecx
		push	ebp
		push	[esp+84h+var_30]
		movsd
		push	ebp
		push	dword ptr [esp+8Ch+var_60+4]
		movsd
		movsd
		call	__allmul
		push	ebp
		push	[esp+84h+var_2C]
		mov	edi, eax
		mov	dword ptr [esp+88h+arg_4], edx
		push	ebp
		push	dword ptr [esp+8Ch+var_60]
		call	__allmul
		mov	ecx, [esp+80h+var_58]
		mov	esi, eax
		push	0
		push	[esp+84h+var_30]
		add	ecx, 40h
		mov	ebp, edx
		add	ecx, [esp+88h+var_28]
		push	0
		push	dword ptr [esp+8Ch+var_60]
		mov	[esp+90h+var_18], ecx
		call	__allmul
		xor	ebx, ebx
		add	edx, esi
		push	0
		adc	ebx, ebx
		add	edx, edi
		pop	edi
		push	edi
		push	[esp+84h+var_2C]
		adc	ebx, edi
		add	edx, 80000000h
		push	edi
		push	dword ptr [esp+8Ch+var_60+4]
		adc	ebx, edi
		xor	esi, esi
		call	__allmul
		add	ebx, eax
		adc	esi, edx
		add	ebx, ebp
		adc	esi, edi
		add	ebx, dword ptr [esp+80h+arg_4]
		mov	[esp+80h+var_20], ebx
		adc	esi, edi
		lea	edi, [esp+80h+var_10]
		mov	[esp+80h+var_1C], esi
		xor	ebx, ebx
		lea	esi, [esp+80h+var_50]
		movsd
		push	ebx
		push	[esp+84h+var_50]
		movsd
		push	ebx
		push	dword ptr [esp+8Ch+var_60+4]
		movsd
		movsd
		call	__allmul
		push	ebx
		push	[esp+84h+var_4C]
		mov	edi, eax
		mov	dword ptr [esp+88h+arg_4], edx
		push	ebx
		push	dword ptr [esp+8Ch+var_60]
		call	__allmul
		mov	ecx, [esp+80h+var_48]
		mov	esi, eax
		mov	eax, [esp+80h+var_58]
		mov	ebp, edx
		push	ebx
		push	[esp+84h+var_50]
		add	eax, 40h
		push	ebx
		push	dword ptr [esp+8Ch+var_60]
		add	ecx, eax
		mov	[esp+90h+var_8], ecx
		call	__allmul
		add	edx, esi
		push	0
		adc	ebx, ebx
		add	edx, edi
		pop	edi
		push	edi
		push	[esp+84h+var_4C]
		adc	ebx, edi
		add	edx, 80000000h
		push	edi
		push	dword ptr [esp+8Ch+var_60+4]
		adc	ebx, edi
		xor	esi, esi
		call	__allmul
		add	ebx, eax
		adc	esi, edx
		add	ebx, ebp
		adc	esi, edi
		add	ebx, dword ptr [esp+80h+arg_4]
		mov	[esp+80h+var_10], ebx
		adc	esi, edi
		lea	edi, [esp+80h+var_30]
		mov	[esp+80h+var_C], esi
		xor	ebx, ebx
		lea	esi, [esp+80h+var_40]
		movsd
		push	ebx
		push	[esp+84h+var_40]
		movsd
		push	ebx
		push	dword ptr [esp+8Ch+var_60+4]
		movsd
		movsd
		call	__allmul
		push	ebx
		push	[esp+84h+var_3C]
		mov	edi, eax
		mov	dword ptr [esp+88h+arg_4], edx
		push	ebx
		push	dword ptr [esp+8Ch+var_60]
		call	__allmul
		mov	ecx, [esp+80h+var_38]
		mov	esi, eax
		mov	eax, [esp+80h+var_58]
		mov	ebp, edx
		push	ebx
		push	[esp+84h+var_40]
		add	eax, 40h
		push	ebx
		push	dword ptr [esp+8Ch+var_60]
		add	ecx, eax
		mov	[esp+90h+var_28], ecx
		call	__allmul
		add	edx, esi
		push	0
		adc	ebx, ebx
		add	edx, edi
		pop	edi
		push	edi
		push	[esp+84h+var_3C]
		adc	ebx, edi
		add	edx, 80000000h
		push	edi
		push	dword ptr [esp+8Ch+var_60+4]
		adc	ebx, edi
		xor	esi, esi
		call	__allmul
		push	[esp+80h+arg_10]
		add	ebx, eax
		mov	ecx, [esp+84h+var_64]
		push	[esp+84h+arg_C]
		adc	esi, edx
		add	ebx, ebp
		lea	edx, [esp+88h+arg_4]
		adc	esi, edi
		add	ebx, dword ptr [esp+88h+arg_4]
		mov	[esp+88h+var_30], ebx
		adc	esi, edi
		sub	esp, 10h
		mov	[esp+98h+var_2C], esi
		mov	edi, esp
		lea	esi, [esp+98h+var_30]
		sub	esp, 10h
		movsd
		movsd
		movsd
		movsd
		mov	edi, esp
		lea	esi, [esp+0A8h+var_20]
		sub	esp, 10h
		movsd
		movsd
		movsd
		movsd
		mov	edi, esp
		lea	esi, [esp+0B8h+var_10]
		movsd
		movsd
		movsd
		movsd
		call	sub_10009F7E
		mov	ecx, [esp+0B8h+arg_0]
		add	esp, 38h
		mov	edx, dword ptr [esp+80h+arg_4]
		sub	edx, [esp+80h+var_70]
		pop	edi
		pop	esi
		pop	ebp
		mov	[ecx], edx
		pop	ebx
		add	esp, 70h
		retn
sub_1000999E	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009CA5	proc near		; CODE XREF: sub_10008958+87p
					; sub_10009E38+6p ...
		push	esi
		mov	esi, [ecx+4]
		push	edi
		mov	edi, [ecx]
		and	esi, 0FFFFFh
		call	sub_10009DF4
		test	al, al
		jnz	short loc_10009CC4
		add	edi, 0
		adc	esi, 100000h

loc_10009CC4:				; CODE XREF: sub_10009CA5+14j
		mov	eax, edi
		mov	edx, esi
		pop	edi
		pop	esi
		retn
sub_10009CA5	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009CCB	proc near		; CODE XREF: sub_10008958+112p
					; sub_10009CEC+5Dp
		mov	eax, [ecx+4]
		mov	edx, [ecx]
		and	eax, 0FFFFFh
		or	edx, eax
		jz	short loc_10009CDC

loc_10009CD9:				; CODE XREF: sub_10009CCB+1Bj
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10009CDC:				; CODE XREF: sub_10009CCB+Cj
		call	sub_10009E0D
		cmp	eax, 0FFFFFBCEh
		jz	short loc_10009CD9
		xor	eax, eax
		inc	eax
		retn
sub_10009CCB	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009CEC	proc near		; CODE XREF: sub_1000999E+AFp

var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_14		= byte ptr -14h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

; FUNCTION CHUNK AT 1000DD7F SIZE 00000025 BYTES

		sub	esp, 3Ch
		push	ebx
		push	ebp
		push	esi
		push	edi
		lea	eax, [esp+4Ch+var_34]
		mov	ebx, ecx
		push	eax
		call	sub_10009E80
		mov	ebp, [esp+4Ch+var_34]
		lea	esi, [esp+4Ch+var_24]
		mov	edx, [esp+4Ch+var_30]
		lea	edi, [esp+4Ch+var_14]
		mov	eax, ebp
		shld	edx, eax, 1
		add	eax, eax
		mov	[esp+4Ch+var_38], edx
		mov	ecx, eax
		mov	[esp+4Ch+var_3C], eax
		add	ecx, 1
		mov	eax, edx
		mov	[esp+4Ch+var_24], ecx
		lea	ecx, [esp+4Ch+var_14]
		adc	eax, 0
		mov	[esp+4Ch+var_20], eax
		mov	eax, [esp+4Ch+var_2C]
		dec	eax
		mov	[esp+4Ch+var_1C], eax
		movsd
		movsd
		movsd
		movsd
		call	sub_10009F25
		mov	ecx, ebx
		call	sub_10009CCB
		lea	esi, [esp+4Ch+var_24]
		lea	edi, [esp+4Ch+var_34]
		test	al, al
		jnz	loc_1000DD7F
		mov	eax, [esp+4Ch+var_3C]
		mov	ecx, [esp+4Ch+var_38]
		add	eax, 0FFFFFFFFh
		mov	[esp+4Ch+var_24], eax
		mov	eax, [esp+4Ch+var_2C]
		adc	ecx, 0FFFFFFFFh
		mov	[esp+4Ch+var_20], ecx
		dec	eax

loc_10009D79:				; CODE XREF: sub_10009CEC+40B3j
		mov	[esp+4Ch+var_1C], eax
		movsd
		movsd
		movsd
		movsd
		mov	ecx, [esp+4Ch+var_2C]
		mov	esi, [esp+4Ch+var_C]
		sub	ecx, esi
		mov	eax, [esp+4Ch+var_34]
		mov	edx, [esp+4Ch+var_30]
		call	__allshl
		mov	edi, [esp+4Ch+arg_4]
		mov	[esp+4Ch+var_2C], esi
		lea	esi, [esp+4Ch+var_14]
		mov	[esp+4Ch+var_34], eax
		mov	[esp+4Ch+var_30], edx
		movsd
		movsd
		movsd
		movsd
		mov	edi, [esp+4Ch+arg_0]
		lea	esi, [esp+4Ch+var_34]
		movsd
		movsd
		movsd
		movsd
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 3Ch
		retn	8
sub_10009CEC	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009DC6	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+46p
					; sub_10013DA5:loc_10013DCAp ...
		mov	ecx, [ecx+4]
		xor	eax, eax
		and	ecx, 80000000h
		or	eax, ecx
		jnz	short loc_10009DD7
		inc	eax
		retn
; ---------------------------------------------------------------------------

loc_10009DD7:				; CODE XREF: sub_10009DC6+Dj
		or	eax, 0FFFFFFFFh
		retn
sub_10009DC6	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009DDB	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+60p
					; double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+4Fp	...
		mov	ecx, [ecx+4]
		mov	edx, 7FF00000h
		xor	eax, eax
		and	ecx, edx
		cmp	eax, eax
		jnz	short locret_10009DEF
		cmp	ecx, edx
		jz	short loc_10009DF0

locret_10009DEF:			; CODE XREF: sub_10009DDB+Ej
		retn
; ---------------------------------------------------------------------------

loc_10009DF0:				; CODE XREF: sub_10009DDB+12j
		xor	eax, eax
		inc	eax
		retn
sub_10009DDB	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009DF4	proc near		; CODE XREF: sub_10009CA5+Dp
					; sub_10009E0D+3p
		mov	ecx, [ecx+4]
		xor	edx, edx
		and	ecx, 7FF00000h
		mov	eax, edx
		or	eax, ecx
		jz	short loc_10009E08

loc_10009E05:				; CODE XREF: sub_10009DF4+17j
		mov	al, dl
		retn
; ---------------------------------------------------------------------------

loc_10009E08:				; CODE XREF: sub_10009DF4+Fj
		xor	edx, edx
		inc	edx
		jmp	short loc_10009E05
sub_10009DF4	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009E0D	proc near		; CODE XREF: sub_10008958+C7p
					; sub_10009CCB:loc_10009CDCp ...
		push	esi
		mov	esi, ecx
		call	sub_10009DF4
		test	al, al
		jnz	short loc_10009E31
		mov	eax, [esi]
		mov	cl, 34h
		mov	edx, [esi+4]
		call	__aullshr
		and	eax, 7FFh
		sub	eax, 433h
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_10009E31:				; CODE XREF: sub_10009E0D+Aj
		mov	eax, 0FFFFFBCEh
		pop	esi
		retn
sub_10009E0D	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009E38	proc near		; CODE XREF: sub_10009251+45p
					; sub_1000999E+45p

arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000DDA4 SIZE 00000016 BYTES

		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	esi, ecx
		call	sub_10009CA5
		mov	ecx, esi
		mov	edi, eax
		mov	ebx, edx
		call	sub_10009E0D
		mov	esi, ebx
		mov	ebp, 100000h
		and	esi, ebp
		xor	ecx, ecx
		or	ecx, esi
		mov	edx, eax
		jz	loc_1000DDA4

loc_10009E63:				; CODE XREF: sub_10009E38+3F7Dj
		mov	eax, [esp+10h+arg_0]
		lea	ecx, [edx-0Bh]
		shld	ebx, edi, 0Bh
		shl	edi, 0Bh
		mov	[eax], edi
		pop	edi
		pop	esi
		pop	ebp
		mov	[eax+4], ebx
		mov	[eax+8], ecx
		pop	ebx
		retn	4
sub_10009E38	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009E80	proc near		; CODE XREF: sub_10009CEC+Ep

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	esi, ecx
		call	sub_10009E0D
		mov	ecx, esi
		mov	edi, eax
		call	sub_10009CA5
		mov	ecx, [esp+8+arg_0]
		mov	[ecx+8], edi
		pop	edi
		mov	[ecx], eax
		mov	eax, ecx
		mov	[ecx+4], edx
		pop	esi
		retn	4
sub_10009E80	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_10009EA5(int,	int, double, int, int)
sub_10009EA5	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *):loc_10009904p

var_18		= qword	ptr -18h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= qword	ptr  10h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

; FUNCTION CHUNK AT 1000DDBA SIZE 0000001B BYTES

		push	ebp
		mov	ebp, esp
		push	ecx
		and	[ebp+var_4], 0
		mov	eax, edx
		push	esi
		test	ecx, ecx
		js	loc_1000DDBA
		cmp	ecx, 1
		jg	short loc_10009EFC
		push	[ebp+arg_14]	; int
		fld	[ebp+arg_8]
		lea	eax, [ebp+var_4]
		push	[ebp+arg_10]	; int
		mov	esi, [ebp+arg_0]
		mov	edx, esi
		push	ecx
		push	ecx
		fstp	[esp+18h+var_18] ; double
		push	eax		; int
		call	sub_1000999E

loc_10009ED9:				; CODE XREF: sub_10009EA5+7Ej
		mov	dl, al
		add	esp, 14h
		test	dl, dl
		jz	short loc_10009EF5
		mov	ecx, [esi]
		mov	eax, [ebp+arg_4]
		add	ecx, [ebp+var_4]
		mov	[eax], ecx
		mov	ecx, [esi]
		mov	eax, [ebp+arg_10]
		mov	byte ptr [eax+ecx], 0

loc_10009EF5:				; CODE XREF: sub_10009EA5+3Bj
		mov	al, dl
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10009EFC:				; CODE XREF: sub_10009EA5+16j
		cmp	ecx, 2
		jnz	loc_1000DDBA
		push	[ebp+arg_14]	; int
		fld	[ebp+arg_8]
		push	[ebp+arg_10]	; int
		mov	esi, [ebp+arg_0]
		mov	edx, esi
		push	ecx
		push	ecx
		lea	ecx, [ebp+var_4]
		fstp	[esp+18h+var_18] ; double
		push	ecx		; int
		mov	ecx, eax
		call	sub_10009251
		jmp	short loc_10009ED9
sub_10009EA5	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009F25	proc near		; CODE XREF: sub_10009CEC+56p
					; sub_10012D4D+4Ap ...
		push	ebx
		mov	ebx, ecx
		xor	eax, eax
		push	ebp
		push	esi
		push	edi
		mov	esi, [ebx+4]
		mov	edx, esi
		mov	edi, [ebx]
		and	edx, 0FFC00000h
		or	eax, edx
		mov	ebp, [ebx+8]
		jnz	short loc_10009F59

loc_10009F41:				; CODE XREF: sub_10009F25+32j
		shld	esi, edi, 0Ah
		xor	eax, eax
		sub	ebp, 0Ah
		mov	ecx, esi
		shl	edi, 0Ah
		and	ecx, 0FFC00000h
		or	eax, ecx
		jz	short loc_10009F41

loc_10009F59:				; CODE XREF: sub_10009F25+1Aj
		mov	edx, 80000000h

loc_10009F5E:				; CODE XREF: sub_10009F25+57j
		mov	ecx, esi
		xor	eax, eax
		and	ecx, edx
		or	eax, ecx
		jz	short loc_10009F75
		mov	[ebx], edi
		pop	edi
		mov	[ebx+4], esi
		pop	esi
		mov	[ebx+8], ebp
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_10009F75:				; CODE XREF: sub_10009F25+41j
		shld	esi, edi, 1
		add	edi, edi
		dec	ebp
		jmp	short loc_10009F5E
sub_10009F25	endp


; =============== S U B	R O U T	I N E =======================================


sub_10009F7E	proc near		; CODE XREF: sub_1000999E+2E3p

var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch
arg_20		= dword	ptr  24h
arg_24		= dword	ptr  28h
arg_30		= dword	ptr  34h
arg_34		= dword	ptr  38h

; FUNCTION CHUNK AT 1000DDD5 SIZE 00000043 BYTES

		sub	esp, 4Ch
		push	ebx
		mov	ebx, [esp+50h+arg_24]
		xor	eax, eax
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+5Ch+arg_20]
		inc	eax
		mov	[esp+5Ch+var_34], edx
		xor	edx, edx
		add	edi, eax
		mov	[esp+5Ch+var_40], ecx
		mov	ebp, edi
		mov	[esp+5Ch+var_30], edx
		adc	ebx, edx
		mov	[esp+5Ch+var_8], edi
		sub	ebp, [esp+5Ch+arg_0]
		mov	ecx, ebx
		mov	[esp+5Ch+var_4], ebx
		sbb	ecx, [esp+5Ch+arg_4]
		add	ebp, eax
		adc	ecx, edx
		mov	[esp+5Ch+var_48], ecx
		mov	ecx, [esp+5Ch+arg_18]
		mov	esi, ecx
		neg	esi
		mov	[esp+5Ch+var_44], ecx
		mov	ecx, esi
		mov	[esp+5Ch+var_2C], esi
		call	__allshl
		mov	[esp+5Ch+var_24], eax
		mov	ecx, esi
		mov	[esp+5Ch+var_28], edx
		mov	eax, edi
		mov	edx, ebx
		call	__aullshr
		mov	edx, [esp+5Ch+var_28]
		mov	ecx, eax
		mov	eax, [esp+5Ch+var_24]
		add	eax, 0FFFFFFFFh
		mov	[esp+5Ch+var_3C], ecx
		mov	esi, eax
		mov	[esp+5Ch+var_10], eax
		adc	edx, 0FFFFFFFFh
		lea	eax, [esp+5Ch+var_38]
		mov	[esp+5Ch+var_C], edx
		and	esi, edi
		and	edx, ebx
		mov	[esp+5Ch+var_4C], edx
		mov	edx, [esp+5Ch+var_44]
		push	eax
		lea	eax, [esp+60h+var_20]
		push	eax
		lea	edx, [edx+40h]
		call	sub_1000A296
		mov	eax, [esp+64h+var_38]
		pop	ecx
		pop	ecx
		mov	ecx, [esp+5Ch+var_34]
		push	0Ah
		pop	edx
		mov	[ecx], eax
		mov	ecx, [esp+5Ch+var_40]
		and	dword ptr [ecx], 0
		test	eax, eax
		jle	loc_1000A0D6
		mov	ecx, [esp+5Ch+var_20]
		mov	[esp+5Ch+var_38], ecx

loc_1000A04D:				; CODE XREF: sub_10009F7E+14Fj
		mov	eax, [esp+5Ch+var_3C]
		xor	edx, edx
		div	ecx
		mov	[esp+5Ch+var_3C], edx
		lea	edx, [eax+30h]
		mov	eax, [esp+5Ch+var_40]
		mov	ecx, [eax]
		mov	eax, [esp+5Ch+arg_30]
		mov	[eax+ecx], dl
		xor	edx, edx
		mov	eax, [esp+5Ch+var_40]
		mov	ecx, [esp+5Ch+var_2C]
		inc	dword ptr [eax]
		mov	eax, [eax]
		mov	[esp+5Ch+var_14], eax
		mov	eax, [esp+5Ch+var_34]
		dec	dword ptr [eax]
		mov	eax, [eax]
		mov	[esp+5Ch+var_20], eax
		mov	eax, [esp+5Ch+var_3C]
		call	__allshl
		add	eax, esi
		mov	ecx, edx
		mov	[esp+5Ch+var_18], eax
		adc	ecx, [esp+5Ch+var_4C]
		mov	[esp+5Ch+var_1C], ecx
		cmp	ecx, [esp+5Ch+var_48]
		jb	loc_1000DDD5
		ja	short loc_1000A0B7
		cmp	eax, ebp
		jb	loc_1000DDD5

loc_1000A0B7:				; CODE XREF: sub_10009F7E+12Fj
		mov	eax, [esp+5Ch+var_38]
		xor	edx, edx
		push	0Ah
		pop	ecx
		div	ecx
		cmp	[esp+5Ch+var_20], 0
		mov	ecx, eax
		mov	[esp+5Ch+var_38], ecx
		jg	loc_1000A04D
		push	0Ah
		pop	edx

loc_1000A0D6:				; CODE XREF: sub_10009F7E+C1j
		neg	[esp+5Ch+var_44]
		xor	ebx, ebx
		mov	edi, [esp+5Ch+var_48]
		inc	ebx
		mov	ecx, [esp+5Ch+var_4C]

loc_1000A0E5:				; CODE XREF: sub_10009F7E+1E7j
					; sub_10009F7E+1F1j
		push	0
		push	edx
		push	ecx
		push	esi
		call	__allmul
		push	0
		push	0Ah
		mov	esi, eax
		mov	[esp+64h+var_4C], edx
		mov	edx, [esp+64h+var_30]
		pop	eax
		push	eax
		push	edx
		push	ebx
		mov	[esp+6Ch+var_14], esi
		call	__allmul
		push	0
		push	0Ah
		mov	ebx, eax
		mov	[esp+64h+var_30], edx
		pop	eax
		push	eax
		push	edi
		push	ebp
		call	__allmul
		mov	ecx, [esp+5Ch+var_44]
		mov	ebp, eax
		mov	edi, edx
		mov	eax, esi
		mov	edx, [esp+5Ch+var_4C]
		call	__aullshr
		mov	edx, [esp+5Ch+var_40]
		add	al, 30h
		mov	ecx, [esp+5Ch+arg_30]
		push	0Ah
		mov	esi, [edx]
		mov	[ecx+esi], al
		inc	dword ptr [edx]
		mov	eax, [edx]
		mov	esi, [esp+60h+var_14]
		mov	ecx, [esp+60h+var_4C]
		and	esi, [esp+60h+var_10]
		and	ecx, [esp+60h+var_C]
		mov	[esp+60h+var_18], eax
		mov	eax, [esp+60h+var_34]
		pop	edx
		dec	dword ptr [eax]
		cmp	ecx, edi
		ja	loc_1000A0E5
		jb	short loc_1000A175
		cmp	esi, ebp
		jnb	loc_1000A0E5

loc_1000A175:				; CODE XREF: sub_10009F7E+1EDj
		push	[esp+5Ch+arg_34]
		mov	edx, [esp+60h+var_30]
		push	[esp+60h+arg_30]
		mov	[esp+64h+var_C], ebx
		mov	eax, [esp+64h+var_C]
		mov	ebx, [esp+64h+var_4]
		push	edx
		push	eax
		push	[esp+6Ch+var_28]
		mov	[esp+70h+var_48], edi
		push	[esp+70h+var_24]
		mov	edi, [esp+74h+var_8]
		sub	edi, [esp+74h+arg_10]
		push	ecx
		sbb	ebx, [esp+78h+arg_14]
		push	esi
		push	[esp+7Ch+var_48]
		push	ebp
		push	edx
		push	eax
		push	ebx
		push	edi
		call	__allmul
		mov	ecx, [esp+84h+var_18]
		push	edx
		push	eax

loc_1000A1C9:				; CODE XREF: sub_10009F7E+3E95j
		call	sub_1000A1D9
		add	esp, 30h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 4Ch
		retn
sub_10009F7E	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000A1D9	proc near		; CODE XREF: sub_10009F7E:loc_1000A1C9p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch
arg_1C		= dword	ptr  20h
arg_20		= dword	ptr  24h
arg_24		= dword	ptr  28h
arg_28		= dword	ptr  2Ch

; FUNCTION CHUNK AT 1000DE18 SIZE 00000108 BYTES

		sub	esp, 14h
		mov	edx, [esp+14h+arg_10]
		push	ebx
		mov	ebx, [esp+18h+arg_20]
		push	ebp
		mov	ebp, [esp+1Ch+arg_4]
		mov	eax, ebp
		push	esi
		mov	esi, [esp+20h+arg_14]
		push	edi
		mov	edi, [esp+24h+arg_0]
		mov	[esp+24h+var_8], ecx
		mov	ecx, edi
		sub	ecx, ebx
		mov	[esp+24h+var_14], ecx
		sbb	eax, [esp+24h+arg_24]
		add	edi, ebx
		mov	[esp+24h+arg_0], eax
		adc	ebp, [esp+24h+arg_24]
		cmp	esi, eax
		mov	eax, [esp+24h+arg_8]
		ja	short loc_1000A226
		jb	loc_1000DE18
		cmp	edx, ecx
		jb	loc_1000DE18

loc_1000A226:				; CODE XREF: sub_1000A1D9+3Dj
					; sub_1000A1D9+3CEFj ...
		cmp	esi, ebp
		ja	short loc_1000A252
		jb	short loc_1000A230
		cmp	edx, edi
		jnb	short loc_1000A252

loc_1000A230:				; CODE XREF: sub_1000A1D9+51j
		mov	ecx, eax
		mov	eax, [esp+24h+arg_C]
		sub	ecx, edx
		sbb	eax, esi
		cmp	eax, [esp+24h+arg_1C]
		jb	short loc_1000A252
		mov	eax, [esp+24h+arg_18]
		ja	loc_1000DEDF
		cmp	ecx, eax
		jnb	loc_1000DEDF

loc_1000A252:				; CODE XREF: sub_1000A1D9+4Fj
					; sub_1000A1D9+55j ...
		mov	edi, [esp+24h+arg_24]
		mov	ecx, ebx
		mov	eax, edi
		shld	eax, ecx, 1
		add	ecx, ecx
		cmp	eax, esi
		ja	short loc_1000A292
		jb	short loc_1000A26A
		cmp	ecx, edx
		ja	short loc_1000A292

loc_1000A26A:				; CODE XREF: sub_1000A1D9+8Bj
		mov	eax, [esp+24h+arg_8]
		mov	ecx, [esp+24h+arg_C]
		shld	edi, ebx, 2
		shl	ebx, 2
		sub	eax, ebx
		sbb	ecx, edi
		cmp	esi, ecx
		ja	short loc_1000A292
		jb	short loc_1000A287
		cmp	edx, eax
		ja	short loc_1000A292

loc_1000A287:				; CODE XREF: sub_1000A1D9+A8j
		xor	eax, eax
		inc	eax

loc_1000A28A:				; CODE XREF: sub_1000A1D9+BBj
					; sub_1000A1D9+3D42j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_1000A292:				; CODE XREF: sub_1000A1D9+89j
					; sub_1000A1D9+8Fj ...
		xor	eax, eax
		jmp	short loc_1000A28A
sub_1000A1D9	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000A296	proc near		; CODE XREF: sub_10009391+79p
					; sub_10009F7E+A4p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		lea	eax, [edx+1]
		imul	edx, eax, 4D1h
		sar	edx, 0Ch
		inc	edx
		jmp	short loc_1000A2A6
; ---------------------------------------------------------------------------

loc_1000A2A5:				; CODE XREF: sub_1000A296+17j
		dec	edx

loc_1000A2A6:				; CODE XREF: sub_1000A296+Dj
		cmp	ecx, ds:dword_10016910[edx*4]
		jb	short loc_1000A2A5
		mov	eax, [esp+arg_0]
		mov	ecx, ds:dword_10016910[edx*4]
		mov	[eax], ecx
		mov	eax, [esp+arg_4]
		mov	[eax], edx
		retn
sub_1000A296	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000A2C3	proc near		; CODE XREF: sub_10009251+69p
					; sub_1000999E+D1p

var_30		= qword	ptr -30h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 20h
		lea	eax, [ecx+3Fh]
		mov	[ebp+var_4], eax
		fild	[ebp+var_4]
		push	esi
		push	edi
		push	ecx
		push	ecx
		fstp	qword ptr [ebp-8]
		fld	qword ptr [ebp-8]
		fmul	ds:dbl_100164D8
		fstp	[esp+30h+var_30] ; double
		call	ceil
		pop	ecx
		pop	ecx
		call	__ftol2_sse
		add	eax, 15Bh
		lea	edi, [ebp+var_10]
		cdq
		push	8
		pop	ecx
		idiv	ecx
		lea	esi, [eax+1]
		shl	esi, 4
		add	esi, offset dword_10016940
		movsd
		movsd
		movsd
		movsd
		mov	edx, [ebp+var_8]
		lea	esi, [ebp+var_20]
		mov	edi, [ebp+arg_0]
		mov	eax, edx
		shr	eax, 10h
		movsx	ecx, ax
		mov	eax, [ebp+arg_4]
		mov	[eax], ecx
		mov	eax, [ebp+var_10]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_C]
		mov	[ebp+var_1C], eax
		movsx	eax, dx
		mov	[ebp+var_18], eax
		movsd
		movsd
		movsd
		movsd
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
sub_1000A2C3	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000A341	proc near		; CODE XREF: sub_10009391+138p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

; FUNCTION CHUNK AT 1000DF20 SIZE 0000005B BYTES

		push	ecx
		push	ecx
		push	ebp
		mov	ebp, [esp+0Ch+arg_8]
		push	esi
		mov	esi, [esp+10h+arg_10]
		push	edi
		mov	edi, [esp+14h+arg_14]
		mov	[esp+14h+var_8], ecx
		mov	ecx, [esp+14h+arg_C]
		mov	[esp+14h+var_4], edx
		cmp	edi, ecx
		jb	short loc_1000A368
		ja	short loc_1000A3D4
		cmp	esi, ebp
		jnb	short loc_1000A3D4

loc_1000A368:				; CODE XREF: sub_1000A341+1Fj
		mov	edx, ebp
		mov	eax, ecx
		sub	edx, esi
		sbb	eax, edi
		cmp	eax, edi
		ja	short loc_1000A37A
		jb	short loc_1000A3D4
		cmp	edx, esi
		jbe	short loc_1000A3D4

loc_1000A37A:				; CODE XREF: sub_1000A341+31j
		mov	edx, [esp+14h+arg_0]
		mov	eax, ecx
		mov	ecx, [esp+14h+arg_4]
		push	ebx
		mov	ebx, ebp
		sub	ebx, edx
		sbb	eax, ecx
		mov	[esp+18h+arg_10], eax
		cmp	eax, ecx
		jb	loc_1000DF20
		ja	short loc_1000A3A1
		cmp	ebx, edx
		jbe	loc_1000DF20

loc_1000A3A1:				; CODE XREF: sub_1000A341+56j
		mov	eax, edx
		shld	ecx, eax, 1
		add	eax, eax
		sub	ebp, eax
		mov	eax, [esp+18h+arg_C]
		sbb	eax, ecx
		mov	ecx, esi
		mov	[esp+18h+arg_8], eax
		mov	eax, edi
		shld	eax, ecx, 1
		add	ecx, ecx
		cmp	[esp+18h+arg_8], eax
		jb	short loc_1000A3D8
		ja	short loc_1000A3CB
		cmp	ebp, ecx
		jb	short loc_1000A3D8

loc_1000A3CB:				; CODE XREF: sub_1000A341+84j
					; sub_1000A341+3C1Fj ...
		mov	al, 1

loc_1000A3CD:				; CODE XREF: sub_1000A341+3C35j
		pop	ebx

loc_1000A3CE:				; CODE XREF: sub_1000A341+95j
		pop	edi
		pop	esi
		pop	ebp
		pop	ecx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1000A3D4:				; CODE XREF: sub_1000A341+21j
					; sub_1000A341+25j ...
		xor	al, al
		jmp	short loc_1000A3CE
; ---------------------------------------------------------------------------

loc_1000A3D8:				; CODE XREF: sub_1000A341+82j
					; sub_1000A341+88j
		mov	eax, [esp+18h+arg_10]
		mov	ecx, [esp+18h+arg_4]
		jmp	loc_1000DF20
sub_1000A341	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000A3E5	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+D9p

; FUNCTION CHUNK AT 1000DF7B SIZE 0000001B BYTES

		sub	ecx, 0
		jz	short loc_1000A403
		dec	ecx
		jz	short loc_1000A3FF
		dec	ecx
		jz	short loc_1000A3FB
		dec	ecx
		jnz	loc_1000DF7B
		push	3
		pop	eax
		retn
; ---------------------------------------------------------------------------

loc_1000A3FB:				; CODE XREF: sub_1000A3E5+9j
		push	2
		pop	eax
		retn
; ---------------------------------------------------------------------------

loc_1000A3FF:				; CODE XREF: sub_1000A3E5+6j
		xor	eax, eax
		inc	eax
		retn
; ---------------------------------------------------------------------------

loc_1000A403:				; CODE XREF: sub_1000A3E5+3j
		xor	eax, eax
		retn
sub_1000A3E5	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000A406	proc near		; CODE XREF: sub_100088E6+3Ap
					; sub_10008EE7+4B31p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4

; FUNCTION CHUNK AT 1000DF96 SIZE 00000031 BYTES

		push	ecx
		push	ecx
		push	ebx
		mov	ebx, [ecx+20Ch]
		mov	eax, edx
		push	esi
		mov	esi, [ecx+208h]
		push	edi
		mov	edi, [eax+20Ch]
		add	esi, ebx
		mov	[esp+14h+var_8], eax
		mov	eax, [eax+208h]
		add	eax, edi
		mov	[esp+14h+var_4], ecx
		cmp	esi, eax
		jl	short loc_1000A452
		jg	short loc_1000A457
		push	ebp

loc_1000A438:				; CODE XREF: sub_1000A406+3BACj
		dec	esi
		mov	eax, ebx
		cmp	ebx, edi
		jl	short loc_1000A441
		mov	eax, edi

loc_1000A441:				; CODE XREF: sub_1000A406+37j
		cmp	esi, eax
		jge	loc_1000DF96
		xor	eax, eax

loc_1000A44B:				; CODE XREF: sub_1000A406+3BB4j
					; sub_1000A406+3BBCj
		pop	ebp

loc_1000A44C:				; CODE XREF: sub_1000A406+4Fj
					; sub_1000A406+54j
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1000A452:				; CODE XREF: sub_1000A406+2Dj
		or	eax, 0FFFFFFFFh
		jmp	short loc_1000A44C
; ---------------------------------------------------------------------------

loc_1000A457:				; CODE XREF: sub_1000A406+2Fj
		xor	eax, eax
		inc	eax
		jmp	short loc_1000A44C
sub_1000A406	endp

; Exported entry  56. ?compress@LZ4@Compression@mozilla@@SAIPBDIPAD@Z

; =============== S U B	R O U T	I N E =======================================


; unsigned int __cdecl mozilla::Compression::LZ4::compress(const char *, unsigned int, char *)
		public ?compress@LZ4@Compression@mozilla@@SAIPBDIPAD@Z
?compress@LZ4@Compression@mozilla@@SAIPBDIPAD@Z	proc near ; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	[esp+arg_4]
		mov	edx, [esp+4+arg_8]
		mov	ecx, [esp+4+arg_0]
		call	sub_1000A46F
		pop	ecx
		retn
?compress@LZ4@Compression@mozilla@@SAIPBDIPAD@Z	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000A46F	proc near		; CODE XREF: mozilla::Compression::LZ4::compress(char const *,uint,char	*)+Cp

var_4024	= dword	ptr -4024h
var_4020	= byte ptr -4020h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, 4024h
		call	__alloca_probe
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		push	ebx
		push	esi
		push	edi
		xor	ebx, ebx
		lea	eax, [ebp+var_4020]
		push	401Ch		; size_t
		push	ebx		; int
		push	eax		; void *
		mov	edi, edx
		mov	[ebp+var_4024],	ebx
		mov	esi, ecx
		call	memset
		add	esp, 0Ch
		mov	edx, esi
		cmp	[ebp+arg_0], 1000Bh
		push	ecx
		push	ecx
		lea	ecx, [ebp+var_4024]
		jge	short loc_1000A4DE
		push	2

loc_1000A4BF:				; CODE XREF: sub_1000A46F+70j
		push	ebx
		push	ebx
		push	[ebp+arg_0]
		push	edi
		call	sub_1000A50E
		mov	ecx, [ebp+var_4]
		add	esp, 1Ch
		xor	ecx, ebp
		pop	edi
		pop	esi
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000A4DE:				; CODE XREF: sub_1000A46F+4Cj
		push	ebx
		jmp	short loc_1000A4BF
sub_1000A46F	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000A4E1	proc near		; CODE XREF: sub_1000A50E+6Ep
					; sub_1000A50E+1C5p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [ecx]
		push	esi
		mov	esi, edx
		imul	edx, eax, 9E3779B1h
		cmp	[esp+4+arg_0], 2
		jnz	short loc_1000A509
		shr	edx, 13h

loc_1000A4F6:				; CODE XREF: sub_1000A4E1+2Bj
		push	[esp+4+arg_4]
		push	[esp+8+arg_0]
		push	esi
		call	sub_1000A82A
		add	esp, 0Ch
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1000A509:				; CODE XREF: sub_1000A4E1+10j
		shr	edx, 14h
		jmp	short loc_1000A4F6
sub_1000A4E1	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000A50E	proc near		; CODE XREF: sub_1000A46F+56p
					; sub_1000F49A+5Cp

var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

; FUNCTION CHUNK AT 1000DFC7 SIZE 000000FE BYTES

		sub	esp, 30h
		mov	eax, [esp+30h+arg_4]
		push	ebx
		push	ebp
		mov	ebp, edx
		mov	[esp+38h+var_28], ecx
		push	esi
		push	edi
		mov	esi, ebp
		mov	[esp+40h+var_2C], ebp
		lea	edi, [eax+ebp]
		mov	[esp+40h+var_30], esi
		lea	edx, [edi-0Ch]
		mov	[esp+40h+var_10], edi
		mov	[esp+40h+var_14], edx
		lea	edx, [edi-5]
		mov	[esp+40h+var_4], edx
		mov	edx, [esp+40h+arg_0]
		mov	edi, edx
		add	edx, [esp+40h+arg_8]
		mov	[esp+40h+var_18], edx
		cmp	eax, 7E000000h
		ja	loc_1000A7FF
		cmp	eax, 1000Bh
		jge	loc_1000DFC7

loc_1000A562:				; CODE XREF: sub_1000A50E+3ABEj
		mov	[esp+40h+var_8], 0FFh
		cmp	eax, 0Dh
		jl	loc_1000A7B1
		push	ebp
		push	[esp+44h+arg_10]
		mov	edx, ecx
		mov	ecx, ebp
		call	sub_1000A4E1
		pop	ecx
		pop	ecx
		lea	ebx, [ebp+1]
		jmp	loc_1000A720
; ---------------------------------------------------------------------------

loc_1000A58B:				; CODE XREF: sub_1000A50E+21Fj
		shr	esi, 13h

loc_1000A58E:				; CODE XREF: sub_1000A50E+228j
		xor	ecx, ecx
		mov	eax, ebx
		push	40h
		inc	ecx
		pop	edx

loc_1000A596:				; CODE XREF: sub_1000A50E+10Fj
					; sub_1000A50E+3ADDj
		mov	ebx, eax
		mov	[esp+40h+var_C], esi
		add	eax, ecx
		mov	ecx, edx
		shr	ecx, 6
		inc	edx
		mov	[esp+40h+var_24], eax
		mov	[esp+40h+var_20], ecx
		mov	[esp+40h+var_1C], edx
		cmp	eax, [esp+40h+var_14]
		ja	loc_1000A7AD
		cmp	[esp+40h+arg_10], 0
		mov	edx, [esp+40h+var_28]
		mov	ecx, [esp+40h+var_2C]
		jz	loc_1000A803
		movzx	ebp, word ptr [edx+esi*2]
		add	ebp, ecx

loc_1000A5D3:				; CODE XREF: sub_1000A50E+2F8j
		mov	eax, [eax]
		imul	esi, eax, 9E3779B1h
		cmp	[esp+40h+arg_10], 2
		mov	[esp+40h+arg_4], ebp
		jnz	loc_1000A80B
		shr	esi, 13h

loc_1000A5ED:				; CODE XREF: sub_1000A50E+300j
		push	ecx
		push	[esp+44h+arg_10]
		mov	ecx, ebx
		push	edx
		mov	edx, [esp+4Ch+var_C]
		call	sub_1000A82A
		add	esp, 0Ch
		cmp	[esp+40h+arg_10], 2
		jnz	loc_1000DFD7

loc_1000A60C:				; CODE XREF: sub_1000A50E+3AE3j
		mov	eax, [ebp+0]
		cmp	eax, [ebx]
		mov	eax, [esp+40h+var_24]
		mov	ecx, [esp+40h+var_20]
		mov	edx, [esp+40h+var_1C]
		jnz	loc_1000A596
		mov	esi, [esp+40h+var_30]
		cmp	ebx, esi
		jbe	short loc_1000A640
		mov	edx, [esp+40h+var_2C]

loc_1000A62F:				; CODE XREF: sub_1000A50E+294j
		cmp	ebp, edx
		jbe	short loc_1000A640
		mov	al, [ebx-1]
		dec	ebp
		cmp	al, [ebp+0]
		jz	loc_1000A79B

loc_1000A640:				; CODE XREF: sub_1000A50E+11Bj
					; sub_1000A50E+123j ...
		mov	ecx, ebx
		mov	ebp, edi
		sub	ecx, esi
		inc	edi
		cmp	[esp+40h+arg_C], 0
		mov	[esp+40h+var_1C], ecx
		jnz	loc_1000DFF6

loc_1000A656:				; CODE XREF: sub_1000A50E+3B01j
		cmp	ecx, 0Fh
		jnb	loc_1000A747
		mov	al, cl
		shl	al, 4
		mov	[ebp+0], al

loc_1000A667:				; CODE XREF: sub_1000A50E+254j
		push	4
		add	ecx, edi
		pop	edx

loc_1000A66C:				; CODE XREF: sub_1000A50E+170j
		mov	eax, [esi]
		add	esi, edx
		mov	[edi], eax
		add	edi, edx
		mov	eax, [esi]
		add	esi, edx
		mov	[edi], eax
		add	edi, edx
		cmp	edi, ecx
		jb	short loc_1000A66C
		mov	esi, [esp+40h+arg_4]
		mov	edi, ecx

loc_1000A686:				; CODE XREF: sub_1000A50E+234j
		push	[esp+40h+var_4]
		mov	eax, ebx
		lea	edx, [esi+4]
		sub	eax, esi
		lea	ecx, [ebx+4]
		mov	[edi], ax
		add	edi, 2
		call	sub_1000A872
		pop	ecx
		mov	ecx, eax
		add	ebx, 4
		add	ebx, ecx
		cmp	ecx, 0Fh
		jnb	loc_1000A767
		add	[ebp+0], cl

loc_1000A6B3:				; CODE XREF: sub_1000A50E+288j
		mov	esi, ebx
		mov	[esp+40h+var_30], esi
		cmp	ebx, [esp+40h+var_14]
		ja	loc_1000A7B1
		mov	ebp, [esp+40h+var_2C]
		lea	ecx, [ebx-2]
		mov	edx, [esp+40h+var_28]
		push	ebp
		push	[esp+44h+arg_10]
		call	sub_1000A4E1
		mov	eax, [ebx]
		pop	ecx
		pop	ecx
		imul	ecx, eax, 9E3779B1h
		cmp	[esp+40h+arg_10], 2
		jnz	loc_1000A81D
		shr	ecx, 13h

loc_1000A6F0:				; CODE XREF: sub_1000A50E+312j
		mov	edx, [esp+40h+var_28]
		push	ebp
		push	[esp+44h+arg_10]
		call	sub_1000A852
		push	ebp
		push	[esp+4Ch+arg_10]
		mov	ecx, ebx
		mov	esi, eax
		call	sub_1000A4E1
		lea	eax, [esi+0FFFFh]
		add	esp, 10h
		cmp	eax, ebx
		jb	short loc_1000A71F
		mov	eax, [esi]
		cmp	eax, [ebx]
		jz	short loc_1000A73B

loc_1000A71F:				; CODE XREF: sub_1000A50E+209j
		inc	ebx

loc_1000A720:				; CODE XREF: sub_1000A50E+78j
		mov	eax, [ebx]
		imul	esi, eax, 9E3779B1h
		cmp	[esp+40h+arg_10], 2
		jz	loc_1000A58B
		shr	esi, 14h
		jmp	loc_1000A58E
; ---------------------------------------------------------------------------

loc_1000A73B:				; CODE XREF: sub_1000A50E+20Fj
		mov	ebp, edi
		inc	edi
		mov	byte ptr [ebp+0], 0
		jmp	loc_1000A686
; ---------------------------------------------------------------------------

loc_1000A747:				; CODE XREF: sub_1000A50E+14Bj
		lea	edx, [ecx-0Fh]
		mov	byte ptr [ebp+0], 0F0h
		mov	eax, 0FFh
		mov	[esp+40h+var_C], edx
		cmp	edx, eax
		jge	loc_1000E014

loc_1000A75F:				; CODE XREF: sub_1000A50E+3B34j
		mov	[edi], dl
		inc	edi
		jmp	loc_1000A667
; ---------------------------------------------------------------------------

loc_1000A767:				; CODE XREF: sub_1000A50E+19Cj
		cmp	[esp+40h+arg_C], 0
		jnz	loc_1000E047

loc_1000A772:				; CODE XREF: sub_1000A50E+3B4Dj
		add	byte ptr [ebp+0], 0Fh
		sub	ecx, 0Fh
		mov	ebp, 1FEh
		cmp	ecx, ebp
		jnb	loc_1000E060
		mov	edx, 0FFh

loc_1000A78B:				; CODE XREF: sub_1000A50E+3B6Aj
		cmp	ecx, edx
		jnb	loc_1000A813

loc_1000A793:				; CODE XREF: sub_1000A50E+30Aj
		mov	[edi], cl
		inc	edi
		jmp	loc_1000A6B3
; ---------------------------------------------------------------------------

loc_1000A79B:				; CODE XREF: sub_1000A50E+12Cj
		dec	ebx
		mov	[esp+40h+arg_4], ebp
		cmp	ebx, esi
		ja	loc_1000A62F
		jmp	loc_1000A640
; ---------------------------------------------------------------------------

loc_1000A7AD:				; CODE XREF: sub_1000A50E+A6j
		mov	esi, [esp+40h+var_30]

loc_1000A7B1:				; CODE XREF: sub_1000A50E+5Fj
					; sub_1000A50E+1AFj
		mov	ebp, [esp+40h+var_10]
		mov	ecx, 0FFh
		sub	ebp, esi
		cmp	[esp+40h+arg_C], 0
		mov	ebx, ebp
		jnz	loc_1000E07D

loc_1000A7C9:				; CODE XREF: sub_1000A50E+3B8Cj
		cmp	ebx, 0Fh
		jl	short loc_1000A825
		mov	byte ptr [edi],	0F0h
		sub	ebx, 0Fh
		inc	edi
		cmp	ebx, ecx
		jge	loc_1000E09F

loc_1000A7DD:				; CODE XREF: sub_1000A50E+31Aj
					; sub_1000A50E+3BB2j
		push	ebp		; size_t
		mov	[edi], bl
		inc	edi
		push	esi		; void *
		push	edi		; void *
		call	memcpy
		sub	edi, esi
		add	esp, 0Ch
		sub	edi, [esp+40h+arg_0]
		add	edi, [esp+40h+var_10]
		mov	eax, edi

loc_1000A7F7:				; CODE XREF: sub_1000A50E+2F3j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_1000A7FF:				; CODE XREF: sub_1000A50E+43j
					; sub_1000A50E+3AC4j ...
		xor	eax, eax
		jmp	short loc_1000A7F7
; ---------------------------------------------------------------------------

loc_1000A803:				; CODE XREF: sub_1000A50E+B9j
		mov	ebp, [edx+esi*4]
		jmp	loc_1000A5D3
; ---------------------------------------------------------------------------

loc_1000A80B:				; CODE XREF: sub_1000A50E+D6j
		shr	esi, 14h
		jmp	loc_1000A5ED
; ---------------------------------------------------------------------------

loc_1000A813:				; CODE XREF: sub_1000A50E+27Fj
		sub	ecx, edx
		mov	[edi], dl
		inc	edi
		jmp	loc_1000A793
; ---------------------------------------------------------------------------

loc_1000A81D:				; CODE XREF: sub_1000A50E+1D9j
		shr	ecx, 14h
		jmp	loc_1000A6F0
; ---------------------------------------------------------------------------

loc_1000A825:				; CODE XREF: sub_1000A50E+2BEj
		shl	bl, 4
		jmp	short loc_1000A7DD
sub_1000A50E	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000A82A	proc near		; CODE XREF: sub_1000A4E1+1Ep
					; sub_1000A50E+EBp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		sub	eax, 0
		jz	short loc_1000A84A
		dec	eax
		jz	short loc_1000A847
		dec	eax
		jnz	short loc_1000A845
		mov	eax, [ebp+arg_0]
		sub	ecx, [ebp+arg_8]
		mov	[eax+edx*2], cx

loc_1000A845:				; CODE XREF: sub_1000A82A+Fj
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000A847:				; CODE XREF: sub_1000A82A+Cj
		sub	ecx, [ebp+arg_8]

loc_1000A84A:				; CODE XREF: sub_1000A82A+9j
		mov	eax, [ebp+arg_0]
		mov	[eax+edx*4], ecx
		pop	ebp
		retn
sub_1000A82A	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000A852	proc near		; CODE XREF: sub_1000A50E+1EBp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		cmp	[esp+arg_0], 0
		jz	short loc_1000A869
		cmp	[esp+arg_0], 1
		jz	short loc_1000A86D
		movzx	eax, word ptr [edx+ecx*2]

loc_1000A864:				; CODE XREF: sub_1000A852+1Ej
		add	eax, [esp+arg_4]
		retn
; ---------------------------------------------------------------------------

loc_1000A869:				; CODE XREF: sub_1000A852+5j
		mov	eax, [edx+ecx*4]
		retn
; ---------------------------------------------------------------------------

loc_1000A86D:				; CODE XREF: sub_1000A852+Cj
		mov	eax, [edx+ecx*4]
		jmp	short loc_1000A864
sub_1000A852	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000A872	proc near		; CODE XREF: sub_1000A50E+18Cp

arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 1000E0C5 SIZE 00000029 BYTES

		push	ebp
		mov	ebp, esp
		push	ebx
		push	esi
		mov	esi, [ebp+arg_0]
		push	edi
		mov	edi, ecx
		lea	ebx, [esi-3]

loc_1000A880:				; CODE XREF: sub_1000A872+22j
		cmp	ecx, ebx
		jnb	loc_1000E0C5
		mov	eax, [ecx]
		xor	eax, [edx]
		jnz	short loc_1000A896
		add	ecx, 4
		add	edx, 4
		jmp	short loc_1000A880
; ---------------------------------------------------------------------------

loc_1000A896:				; CODE XREF: sub_1000A872+1Aj
		bsf	eax, eax
		mov	[ebp+arg_0], eax
		shr	eax, 3
		sub	eax, edi
		add	eax, ecx

loc_1000A8A3:				; CODE XREF: sub_1000A872+3877j
		pop	edi
		pop	esi
		pop	ebx
		pop	ebp
		retn
sub_1000A872	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000A8A8	proc near		; DATA XREF: sub_10001482+B0o

puLen		= dword	ptr -0C0h
dwHandle	= dword	ptr -0BCh
dwLen		= dword	ptr -0B8h
var_B4		= dword	ptr -0B4h
var_B0		= dword	ptr -0B0h
var_AC		= dword	ptr -0ACh
lpBuffer	= dword	ptr -0A8h
var_A4		= byte ptr -0A4h
var_A0		= byte ptr -0A0h
var_9C		= dword	ptr -9Ch
lpPath		= dword	ptr -98h
EndPtr		= dword	ptr -94h
lpFileName	= dword	ptr -90h
var_89		= byte ptr -89h
var_88		= byte ptr -88h
var_14		= dword	ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

; FUNCTION CHUNK AT 1000E0EE SIZE 000001FD BYTES

		sub	esp, 0C0h
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+0C0h+var_4], eax
		mov	ecx, [esp+0C0h+arg_8]
		xor	edx, edx
		mov	eax, [esp+0C0h+arg_0]
		mov	[esp+0C0h+lpPath], eax
		mov	eax, [esp+0C0h+arg_4]
		push	ebx
		mov	ebx, [ecx+4]
		mov	[esp+0C4h+var_AC], eax
		mov	eax, [esp+0C4h+arg_C]
		push	esi
		mov	[esp+0C8h+var_B4], eax
		mov	esi, edx
		movzx	eax, word ptr [ecx]
		push	edi
		mov	edi, eax
		mov	[esp+0CCh+var_B0], ecx
		movzx	ecx, word ptr [ecx+2]
		add	eax, 2
		shr	edi, 1
		mov	[esp+0CCh+lpFileName], ebx
		cmp	ecx, eax
		jl	loc_1000A9FB
		cmp	[ebx+edi*2], dx
		jnz	loc_1000A9FB
		mov	edx, edi
		mov	ecx, ebx
		call	sub_1000AADD
		mov	ecx, eax
		test	ecx, ecx
		jnz	loc_1000AA58
		mov	ecx, ebx

loc_1000A92B:				; CODE XREF: sub_1000A8A8+1BBj
		cmp	edi, 80h
		jg	loc_1000A9FB
		xor	ebx, ebx
		test	edi, edi
		jle	short loc_1000A960

loc_1000A93D:				; CODE XREF: sub_1000A8A8+B6j
		movzx	edx, word ptr [ecx+ebx*2]
		cmp	edx, 7Fh
		ja	loc_1000A9F7
		lea	eax, [edx-41h]
		cmp	ax, 19h
		jbe	loc_1000AA49

loc_1000A957:				; CODE XREF: sub_1000A8A8+1A4j
		mov	[esp+ebx+0CCh+var_88], dl
		inc	ebx
		cmp	ebx, edi
		jl	short loc_1000A93D

loc_1000A960:				; CODE XREF: sub_1000A8A8+93j
		cmp	edi, 81h
		jnb	loc_1000AAD8
		mov	ebx, ds:strchr
		lea	eax, [esp+0CCh+var_88]
		push	2Eh		; int
		push	eax		; char *
		mov	[esp+edi+0D4h+var_88], 0
		call	ebx ; strchr
		mov	edi, eax
		pop	ecx
		pop	ecx
		test	edi, edi
		jz	short loc_1000A9AE
		lea	eax, [edi+1]
		push	2Eh		; int
		push	eax		; char *
		call	ebx ; strchr
		lea	ebx, [edi+0Dh]
		pop	ecx
		pop	ecx
		cmp	eax, ebx
		jz	loc_1000E0EE

loc_1000A99D:				; CODE XREF: sub_1000A8A8+3862j
		mov	eax, edi
		lea	ecx, [esp+0CCh+var_88]
		sub	eax, ecx
		cmp	eax, 10h
		jge	loc_1000AA68

loc_1000A9AE:				; CODE XREF: sub_1000A8A8+DEj
					; sub_1000A8A8+1E0j
		mov	eax, off_1001A030
		mov	ebx, offset off_1001A030
		test	eax, eax
		jz	short loc_1000A9F7

loc_1000A9BC:				; CODE XREF: sub_1000A8A8+145j
		lea	ecx, [esp+0CCh+var_88]

loc_1000A9C0:				; CODE XREF: sub_1000A8A8+136j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	loc_1000AA51
		test	dl, dl
		jz	short loc_1000A9E0
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_1000AA51
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_1000A9C0

loc_1000A9E0:				; CODE XREF: sub_1000A8A8+124j
		xor	eax, eax

loc_1000A9E2:				; CODE XREF: sub_1000A8A8+1AEj
		test	eax, eax
		jz	short loc_1000A9EF
		add	ebx, 18h
		mov	eax, [ebx]
		test	eax, eax
		jnz	short loc_1000A9BC

loc_1000A9EF:				; CODE XREF: sub_1000A8A8+13Cj
		cmp	[ebx], esi
		jnz	loc_1000E13E

loc_1000A9F7:				; CODE XREF: sub_1000A8A8+9Cj
					; sub_1000A8A8+112j ...
		mov	ebx, [esp+0CCh+lpFileName]

loc_1000A9FB:				; CODE XREF: sub_1000A8A8+5Ej
					; sub_1000A8A8+68j ...
		call	ds:GetCurrentThreadId
		cmp	eax, dword_1001AAA4
		jz	loc_1000AA93

loc_1000AA0D:				; CODE XREF: sub_1000A8A8+216j
					; sub_1000A8A8+225j
		push	[esp+0CCh+var_B4]
		push	[esp+0D0h+var_B0]
		push	[esp+0D4h+var_AC]
		push	[esp+0D8h+lpPath]
		call	dword_1001A800
		push	esi
		mov	edi, eax
		call	ds:??_V@YAXPAX@Z ; operator delete[](void *)
		mov	eax, edi

loc_1000AA2E:				; CODE XREF: sub_1000A8A8+3891j
		pop	ecx

loc_1000AA2F:				; CODE XREF: sub_1000A8A8+3A2Cj
		mov	ecx, [esp+0DCh+var_14]
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0C0h
		retn	10h
; ---------------------------------------------------------------------------

loc_1000AA49:				; CODE XREF: sub_1000A8A8+A9j
		add	edx, 20h
		jmp	loc_1000A957
; ---------------------------------------------------------------------------

loc_1000AA51:				; CODE XREF: sub_1000A8A8+11Cj
					; sub_1000A8A8+12Cj
		sbb	eax, eax
		or	eax, 1
		jmp	short loc_1000A9E2
; ---------------------------------------------------------------------------

loc_1000AA58:				; CODE XREF: sub_1000A8A8+7Bj
		add	ecx, 2
		mov	eax, ecx
		sub	eax, ebx
		sar	eax, 1
		sub	edi, eax
		jmp	loc_1000A92B
; ---------------------------------------------------------------------------

loc_1000AA68:				; CODE XREF: sub_1000A8A8+100j
		lea	ebx, [esp+0CCh+var_88]
		mov	eax, ebx
		cmp	eax, edi
		jnb	short loc_1000AA86

loc_1000AA72:				; CODE XREF: sub_1000A8A8+1DCj
		movsx	eax, byte ptr [ebx]
		push	eax		; int
		call	ds:isxdigit
		pop	ecx
		test	eax, eax
		jz	short loc_1000AA86
		inc	ebx
		cmp	ebx, edi
		jb	short loc_1000AA72

loc_1000AA86:				; CODE XREF: sub_1000A8A8+1C8j
					; sub_1000A8A8+1D7j
		cmp	ebx, edi
		jnz	loc_1000A9AE
		jmp	loc_1000E12C
; ---------------------------------------------------------------------------

loc_1000AA93:				; CODE XREF: sub_1000A8A8+15Fj
		mov	ecx, [esp+0CCh+lpPath] ; lpPath
		mov	edx, ebx	; lpFileName
		mov	edi, esi
		call	sub_1000AD10
		push	edi
		mov	esi, eax
		call	ds:??_V@YAXPAX@Z ; operator delete[](void *)
		pop	ecx
		test	esi, esi
		jz	loc_1000E2B5
		mov	ecx, 6000000h
		call	sub_1000AAFC
		test	al, al
		jz	loc_1000AA0D
		mov	ecx, esi	; lpFileName
		call	sub_1000ABC8
		test	al, al
		jnz	loc_1000AA0D
		jmp	loc_1000E2D9
; ---------------------------------------------------------------------------

loc_1000AAD8:				; CODE XREF: sub_1000A8A8+BEj
		call	___report_rangecheckfailure
sub_1000A8A8	endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================


sub_1000AADD	proc near		; CODE XREF: sub_1000A8A8+72p
		lea	eax, [edx-1]
		lea	eax, [ecx+eax*2]

loc_1000AAE3:				; CODE XREF: sub_1000AADD+1Aj
		cmp	eax, ecx
		jb	short loc_1000AAF9
		movzx	edx, word ptr [eax]
		cmp	edx, 5Ch
		jz	short locret_1000AAFB
		cmp	edx, 2Fh
		jz	short locret_1000AAFB
		sub	eax, 2
		jmp	short loc_1000AAE3
; ---------------------------------------------------------------------------

loc_1000AAF9:				; CODE XREF: sub_1000AADD+8j
		xor	eax, eax

locret_1000AAFB:			; CODE XREF: sub_1000AADD+10j
					; sub_1000AADD+15j
		retn
sub_1000AADD	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame fpd=78h

sub_1000AAFC	proc near		; CODE XREF: sub_1000A8A8+20Fp
					; sub_1000A8A8+38A6p ...

VersionInformation= _OSVERSIONINFOEXA ptr -0A0h
var_4		= dword	ptr -4

		push	ebp
		lea	ebp, [esp-78h]
		sub	esp, 0A0h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+78h+var_4], eax
		push	ebx
		mov	ebx, ecx
		cmp	dword_1001A7F0,	ebx
		jnb	loc_1000ABAC
		cmp	ebx, dword_1001A498
		jnb	loc_1000ABC4
		push	esi
		mov	esi, 9Ch
		lea	eax, [ebp+78h+VersionInformation]
		push	esi		; size_t
		push	0		; int
		push	eax		; void *
		call	memset
		mov	eax, ebx
		mov	[ebp+78h+VersionInformation.dwOSVersionInfoSize], esi
		shr	eax, 18h
		lea	ecx, [esi+63h]
		mov	esi, ds:VerSetConditionMask
		add	esp, 0Ch
		mov	[ebp+78h+VersionInformation.dwMajorVersion], eax
		mov	eax, ebx
		shr	eax, 10h
		and	eax, ecx
		mov	[ebp+78h+VersionInformation.dwMinorVersion], eax
		mov	eax, ebx
		push	3		; Condition
		shr	eax, 8
		and	eax, ecx
		push	2		; TypeMask
		mov	[ebp+78h+VersionInformation.wServicePackMajor],	ax
		push	0
		movzx	eax, bl
		push	0		; ConditionMask
		mov	[ebp+78h+VersionInformation.wServicePackMinor],	ax
		call	esi ; VerSetConditionMask
		push	3		; Condition
		push	1		; TypeMask
		push	edx
		push	eax		; ConditionMask
		call	esi ; VerSetConditionMask
		push	3		; Condition
		push	20h		; TypeMask
		push	edx
		push	eax		; ConditionMask
		call	esi ; VerSetConditionMask
		push	3		; Condition
		push	10h		; TypeMask
		push	edx
		push	eax		; ConditionMask
		call	esi ; VerSetConditionMask
		push	edx
		push	eax		; dwlConditionMask
		push	33h		; dwTypeMask
		lea	ecx, [ebp+78h+VersionInformation]
		push	ecx		; lpVersionInformation
		call	ds:VerifyVersionInfoA
		pop	esi
		test	eax, eax
		jz	short loc_1000ABBE
		mov	dword_1001A7F0,	ebx

loc_1000ABAC:				; CODE XREF: sub_1000AAFC+1Ej
		mov	al, 1

loc_1000ABAE:				; CODE XREF: sub_1000AAFC+CAj
		mov	ecx, [ebp+78h+var_4]
		xor	ecx, ebp
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		lea	esp, [ebp+78h]
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000ABBE:				; CODE XREF: sub_1000AAFC+A8j
		mov	dword_1001A498,	ebx

loc_1000ABC4:				; CODE XREF: sub_1000AAFC+2Aj
		xor	al, al
		jmp	short loc_1000ABAE
sub_1000AAFC	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall sub_1000ABC8(LPCWSTR lpFileName)
sub_1000ABC8	proc near		; CODE XREF: sub_1000A8A8+21Ep

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
lpBaseAddress	= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	ebx
		push	edi
		xor	ebx, ebx
		push	ebx		; hTemplateFile
		push	80h		; dwFlagsAndAttributes
		push	3		; dwCreationDisposition
		push	ebx		; lpSecurityAttributes
		push	1		; dwShareMode
		push	80000000h	; dwDesiredAccess
		push	ecx		; lpFileName
		call	ds:CreateFileW
		mov	edi, eax
		cmp	edi, 0FFFFFFFFh
		jz	short loc_1000AC62
		push	esi
		push	ebx		; lpName
		push	ebx		; dwMaximumSizeLow
		push	ebx		; dwMaximumSizeHigh
		push	2		; flProtect
		push	ebx		; lpFileMappingAttributes
		push	edi		; hFile
		call	ds:CreateFileMappingW
		mov	esi, eax
		test	esi, esi
		jz	short loc_1000AC5A
		push	ecx		; int
		push	esi		; hFileMappingObject
		lea	ecx, [ebp+var_10]
		call	sub_1000ACC2
		mov	eax, [ebp+var_10]
		test	eax, eax
		jz	short loc_1000AC44
		push	dword ptr [eax+3Ch] ; int
		lea	ecx, [ebp+var_8]
		push	esi		; hFileMappingObject
		call	sub_1000AC6A
		mov	eax, [ebp+var_8]
		test	eax, eax
		jz	short loc_1000AC35
		cmp	[eax+1Ch], ebx
		jz	short loc_1000AC33
		test	byte ptr [eax+5Eh], 40h
		jz	short loc_1000AC35

loc_1000AC33:				; CODE XREF: sub_1000ABC8+63j
		mov	bl, 1

loc_1000AC35:				; CODE XREF: sub_1000ABC8+5Ej
					; sub_1000ABC8+69j
		cmp	[ebp+lpBaseAddress], 0
		jz	short loc_1000AC44
		push	[ebp+lpBaseAddress] ; lpBaseAddress
		call	ds:UnmapViewOfFile

loc_1000AC44:				; CODE XREF: sub_1000ABC8+4Bj
					; sub_1000ABC8+71j
		push	esi		; hObject
		call	ds:CloseHandle
		cmp	[ebp+var_C], 0
		jz	short loc_1000AC5A
		push	[ebp+var_C]	; lpBaseAddress
		call	ds:UnmapViewOfFile

loc_1000AC5A:				; CODE XREF: sub_1000ABC8+3Aj
					; sub_1000ABC8+87j
		push	edi		; hObject
		call	ds:CloseHandle
		pop	esi

loc_1000AC62:				; CODE XREF: sub_1000ABC8+26j
		pop	edi
		mov	al, bl
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
sub_1000ABC8	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	sub_1000AC6A(HANDLE hFileMappingObject,	int)
sub_1000AC6A	proc near		; CODE XREF: sub_1000ABC8+54p
					; sub_1000E98B+54p

SystemInfo	= _SYSTEM_INFO ptr -24h
hFileMappingObject= dword ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 24h
		push	esi
		push	edi
		lea	eax, [ebp+SystemInfo]
		mov	esi, ecx
		push	eax		; lpSystemInfo
		call	ds:GetSystemInfo
		mov	eax, [ebp+arg_4]
		xor	edx, edx
		div	[ebp+SystemInfo.dwAllocationGranularity]
		mov	ecx, [ebp+arg_4]
		mov	edi, eax
		imul	edi, [ebp+SystemInfo.dwAllocationGranularity]
		sub	ecx, edi
		add	ecx, 0F8h
		push	ecx		; dwNumberOfBytesToMap
		push	edi		; dwFileOffsetLow
		push	0		; dwFileOffsetHigh
		push	4		; dwDesiredAccess
		push	[ebp+hFileMappingObject] ; hFileMappingObject
		call	ds:MapViewOfFile
		mov	[esi+4], eax
		test	eax, eax
		jz	short loc_1000ACBE
		sub	eax, edi
		add	eax, [ebp+arg_4]

loc_1000ACB2:				; CODE XREF: sub_1000AC6A+56j
		mov	[esi], eax
		mov	eax, esi
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn	8
; ---------------------------------------------------------------------------

loc_1000ACBE:				; CODE XREF: sub_1000AC6A+41j
		xor	eax, eax
		jmp	short loc_1000ACB2
sub_1000AC6A	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	sub_1000ACC2(HANDLE hFileMappingObject,	int)
sub_1000ACC2	proc near		; CODE XREF: sub_1000ABC8+41p
					; sub_1000E98B+41p

SystemInfo	= _SYSTEM_INFO ptr -24h
hFileMappingObject= dword ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 24h
		push	esi
		push	edi
		lea	eax, [ebp+SystemInfo]
		mov	esi, ecx
		push	eax		; lpSystemInfo
		call	ds:GetSystemInfo
		xor	eax, eax
		xor	edx, edx
		div	[ebp+SystemInfo.dwAllocationGranularity]
		push	40h
		mov	edi, eax
		imul	edi, [ebp+SystemInfo.dwAllocationGranularity]
		pop	ecx
		sub	ecx, edi
		push	ecx		; dwNumberOfBytesToMap
		push	edi		; dwFileOffsetLow
		push	0		; dwFileOffsetHigh
		push	4		; dwDesiredAccess
		push	[ebp+hFileMappingObject] ; hFileMappingObject
		call	ds:MapViewOfFile
		mov	[esi+4], eax
		test	eax, eax
		jz	short loc_1000AD0C
		sub	eax, edi

loc_1000AD00:				; CODE XREF: sub_1000ACC2+4Cj
		mov	[esi], eax
		mov	eax, esi
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn	8
; ---------------------------------------------------------------------------

loc_1000AD0C:				; CODE XREF: sub_1000ACC2+3Aj
		xor	eax, eax
		jmp	short loc_1000AD00
sub_1000ACC2	endp


; =============== S U B	R O U T	I N E =======================================


; int __fastcall sub_1000AD10(LPCWSTR lpPath, LPCWSTR lpFileName)
sub_1000AD10	proc near		; CODE XREF: sub_1000A8A8+1F3p
					; sub_1000A8A8+390Fp

nBufferLength	= dword	ptr -4

		push	ecx
		push	esi
		mov	esi, ecx
		xor	eax, eax
		push	edi
		mov	edi, edx
		cmp	esi, 1000h
		jl	short loc_1000AD72

loc_1000AD21:				; CODE XREF: sub_1000AD10+64j
		push	eax		; lpFilePart
		push	eax		; lpBuffer
		push	eax		; nBufferLength
		push	offset Extension ; ".dll"
		push	edi		; lpFileName
		push	esi		; lpPath
		call	ds:SearchPathW
		test	eax, eax
		jz	short loc_1000AD76
		push	ebp
		inc	eax
		xor	ecx, ecx
		push	2
		pop	edx
		mov	[esp+10h+nBufferLength], eax
		mul	edx
		seto	cl
		neg	ecx
		or	ecx, eax
		push	ecx
		call	ds:??_U@YAPAXI@Z ; operator new[](uint)
		mov	ebp, eax
		pop	ecx
		test	ebp, ebp
		jz	short loc_1000AD7A
		push	0		; lpFilePart
		push	ebp		; lpBuffer
		push	[esp+18h+nBufferLength]	; nBufferLength
		push	offset Extension ; ".dll"
		push	edi		; lpFileName
		push	esi		; lpPath
		call	ds:SearchPathW
		mov	eax, ebp

loc_1000AD6D:				; CODE XREF: sub_1000AD10+6Cj
		pop	ebp

loc_1000AD6E:				; CODE XREF: sub_1000AD10+68j
		pop	edi
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1000AD72:				; CODE XREF: sub_1000AD10+Fj
		mov	esi, eax
		jmp	short loc_1000AD21
; ---------------------------------------------------------------------------

loc_1000AD76:				; CODE XREF: sub_1000AD10+23j
		xor	eax, eax
		jmp	short loc_1000AD6E
; ---------------------------------------------------------------------------

loc_1000AD7A:				; CODE XREF: sub_1000AD10+45j
		xor	eax, eax
		jmp	short loc_1000AD6D
sub_1000AD10	endp

; Exported entry 117. moz_malloc_size_of

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public moz_malloc_size_of
moz_malloc_size_of proc	near		; DATA XREF: .rdata:off_100175A8o

var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 1000E2EB SIZE 0000002E BYTES

		push	ebp
		mov	ebp, esp
		sub	esp, 1Ch
		push	esi
		push	edi
		mov	edi, [ebp+arg_0]
		test	edi, edi
		jz	short loc_1000ADBB
		mov	esi, edi
		and	esi, 0FFF00000h
		jz	short loc_1000ADBB
		mov	edx, esi
		call	sub_1000ADF0
		test	eax, eax
		jz	short loc_1000ADBB
		cmp	esi, edi
		jz	loc_1000E2EB
		mov	ecx, edi
		call	sub_1000ADBF
		mov	esi, eax

loc_1000ADB3:				; CODE XREF: moz_malloc_size_of+3Fj
					; moz_malloc_size_of+3596j
		pop	edi
		mov	eax, esi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000ADBB:				; CODE XREF: moz_malloc_size_of+Dj
					; moz_malloc_size_of+17j ...
		xor	esi, esi
		jmp	short loc_1000ADB3
moz_malloc_size_of endp


; =============== S U B	R O U T	I N E =======================================


sub_1000ADBF	proc near		; CODE XREF: moz_malloc_size_of+2Ep
					; malloc_usable_size+29p
		mov	edx, ecx
		and	edx, 0FFF00000h
		sub	ecx, edx
		shr	ecx, 0Ch
		add	ecx, 2
		imul	eax, ecx, 0Ch
		mov	ecx, [eax+edx]
		test	cl, 2
		jnz	short loc_1000ADE8
		and	ecx, 0FFFFF000h
		mov	eax, [ecx]
		mov	ecx, [eax+14h]

loc_1000ADE5:				; CODE XREF: sub_1000ADBF+2Fj
		mov	eax, ecx
		retn
; ---------------------------------------------------------------------------

loc_1000ADE8:				; CODE XREF: sub_1000ADBF+19j
		and	ecx, 0FFFFF000h
		jmp	short loc_1000ADE5
sub_1000ADBF	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000ADF0	proc near		; CODE XREF: moz_malloc_size_of+1Bp
					; malloc_usable_size+18p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

; FUNCTION CHUNK AT 1000E319 SIZE 00000045 BYTES

		sub	esp, 10h
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, lpCriticalSection
		xor	esi, esi
		push	20h
		mov	ebx, esi
		pop	ebp
		mov	eax, [edi+18h]
		mov	[esp+20h+var_10], eax
		mov	eax, [edi+1Ch]
		dec	eax
		mov	[esp+20h+var_4], eax
		jnz	short loc_1000AE30

loc_1000AE15:				; CODE XREF: sub_1000ADF0+3562j
		sub	ebp, [edi+ebx*4+20h]
		mov	ecx, esi
		mov	eax, [esp+20h+var_10]
		shl	edx, cl
		mov	ecx, ebp
		shr	edx, cl
		mov	eax, [eax+edx*4]

loc_1000AE28:				; CODE XREF: sub_1000ADF0+3569j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_1000AE30:				; CODE XREF: sub_1000ADF0+23j
		lea	eax, [edi+20h]
		mov	[esp+20h+var_C], eax
		jmp	loc_1000E319
sub_1000ADF0	endp

; Exported entry   3. ??0Decimal@WebCore@@QAE@H@Z

; =============== S U B	R O U T	I N E =======================================


; _DWORD __thiscall WebCore::Decimal::Decimal(WebCore::Decimal *this, int)
		public ??0Decimal@WebCore@@QAE@H@Z
??0Decimal@WebCore@@QAE@H@Z proc near	; CODE XREF: WebCore::Decimal::`default	constructor closure'(void)+2p
					; WebCore::Decimal::ceiling(void)+52p ...

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, esi
		cdq
		push	edi
		mov	edi, ecx
		test	esi, esi
		js	short loc_1000AE65

loc_1000AE4B:				; CODE XREF: WebCore::Decimal::Decimal(int)+30j
		xor	ecx, ecx
		test	esi, esi
		push	edx
		push	eax
		sets	cl
		push	0
		push	ecx
		mov	ecx, edi
		call	sub_1000AE6E
		mov	eax, edi
		pop	edi
		pop	esi
		retn	4
; ---------------------------------------------------------------------------

loc_1000AE65:				; CODE XREF: WebCore::Decimal::Decimal(int)+Dj
		neg	eax
		adc	edx, 0
		neg	edx
		jmp	short loc_1000AE4B
??0Decimal@WebCore@@QAE@H@Z endp


; =============== S U B	R O U T	I N E =======================================


sub_1000AE6E	proc near		; CODE XREF: WebCore::Decimal::Decimal(int)+1Dp
					; WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned	__int64)+1Fp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

; FUNCTION CHUNK AT 1000E35E SIZE 00000037 BYTES

		mov	edx, [esp+arg_C]
		push	ebx
		push	esi
		mov	esi, ecx
		mov	ecx, [esp+8+arg_8]
		mov	eax, ecx
		or	eax, edx
		push	edi
		jnz	short loc_1000AEE3
		push	3
		pop	eax

loc_1000AE84:				; CODE XREF: sub_1000AE6E+78j
		mov	edi, [esp+0Ch+arg_4]
		xor	ebx, ebx
		mov	[esi+0Ch], eax
		mov	eax, [esp+0Ch+arg_0]
		mov	[esi+10h], eax
		cmp	edi, 0FFFFFC01h
		jl	short loc_1000AEBE
		cmp	edi, 3FFh
		jg	short loc_1000AEE8
		cmp	edx, 1634578h
		jb	short loc_1000AEBE
		ja	loc_1000E35E

loc_1000AEB2:				; CODE XREF: sub_1000AE6E+350Bj
		cmp	ecx, 5D89FFFFh
		ja	loc_1000E35E

loc_1000AEBE:				; CODE XREF: sub_1000AE6E+2Cj
					; sub_1000AE6E+3Cj ...
		cmp	edi, 3FFh
		jg	short loc_1000AEE8
		cmp	edi, 0FFFFFC01h
		jl	loc_1000E37E
		mov	[esi], ecx
		mov	[esi+4], edx
		mov	[esi+8], di

loc_1000AEDB:				; CODE XREF: sub_1000AE6E+88j
					; sub_1000AE6E+3522j
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn	10h
; ---------------------------------------------------------------------------

loc_1000AEE3:				; CODE XREF: sub_1000AE6E+11j
		xor	eax, eax
		inc	eax
		jmp	short loc_1000AE84
; ---------------------------------------------------------------------------

loc_1000AEE8:				; CODE XREF: sub_1000AE6E+34j
					; sub_1000AE6E+56j
		xor	eax, eax
		mov	[esi], ebx
		mov	[esi+4], ebx
		mov	[esi+8], ax
		mov	[esi+0Ch], ebx
		jmp	short loc_1000AEDB
sub_1000AE6E	endp

; Exported entry  38. ?IsFloat32Representable@mozilla@@YA_NN@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl mozilla::IsFloat32Representable(mozilla *this, double)
		public ?IsFloat32Representable@mozilla@@YA_NN@Z
?IsFloat32Representable@mozilla@@YA_NN@Z proc near ; DATA XREF:	.rdata:off_100175A8o

this		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		fld	qword ptr [ebp+this]
		fst	dword ptr [ebp+0Ch]
		fld	dword ptr [ebp+0Ch]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_1000AF12
		xor	eax, eax
		inc	eax
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000AF12:				; CODE XREF: mozilla::IsFloat32Representable(double)+13j
		xor	eax, eax
		pop	ebp
		retn
?IsFloat32Representable@mozilla@@YA_NN@Z endp

; Exported entry 116. mozPoisonValueInit

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mozPoisonValueInit
mozPoisonValueInit proc	near		; DATA XREF: .rdata:off_100175A8o

SystemInfo	= _SYSTEM_INFO ptr -24h

; FUNCTION CHUNK AT 1000E395 SIZE 00000067 BYTES

		push	ebp
		mov	ebp, esp
		sub	esp, 24h
		push	ebx
		push	esi
		push	edi
		lea	eax, [ebp+SystemInfo]
		push	eax		; lpSystemInfo
		call	ds:GetSystemInfo
		mov	ebx, [ebp+SystemInfo.dwAllocationGranularity]
		push	1		; flProtect
		push	2000h		; flAllocationType
		push	ebx		; dwSize
		lea	esi, [ebx-1]
		mov	gMozillaPoisonSize, ebx
		not	esi
		and	esi, 0F0DEAFFFh
		push	esi		; lpAddress
		call	ds:VirtualAlloc
		mov	edi, eax
		cmp	edi, esi
		jnz	loc_1000E395

loc_1000AF56:				; CODE XREF: mozPoisonValueInit+348Ej
					; mozPoisonValueInit+34A1j ...
		mov	eax, gMozillaPoisonSize
		mov	gMozillaPoisonBase, esi
		test	eax, eax
		jz	short loc_1000AF6F
		shr	eax, 1
		dec	eax
		add	eax, esi
		mov	gMozillaPoisonValue, eax

loc_1000AF6F:				; CODE XREF: mozPoisonValueInit+4Dj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
mozPoisonValueInit endp


; =============== S U B	R O U T	I N E =======================================


sub_1000AF76	proc near		; CODE XREF: sub_10001338p
		mov	dword_1001ABF4,	offset off_10016394
		mov	eax, offset dword_1001ABF4
		retn
sub_1000AF76	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000AF86	proc near		; CODE XREF: sub_10001349p
		mov	dword_1001ABF0,	offset off_10016364
		mov	eax, offset dword_1001ABF0
		retn
sub_1000AF86	endp

; Exported entry  32. ?DllBlocklist_SetInXPCOMLoadOnMainThread@@YAX_N@Z

; =============== S U B	R O U T	I N E =======================================


; void __cdecl DllBlocklist_SetInXPCOMLoadOnMainThread(bool)
		public ?DllBlocklist_SetInXPCOMLoadOnMainThread@@YAX_N@Z
?DllBlocklist_SetInXPCOMLoadOnMainThread@@YAX_N@Z proc near
					; DATA XREF: .rdata:off_100175A8o

arg_0		= byte ptr  4

		cmp	[esp+arg_0], 0
		jz	short loc_1000AFA9
		call	ds:GetCurrentThreadId
		mov	dword_1001AAA4,	eax
		retn
; ---------------------------------------------------------------------------

loc_1000AFA9:				; CODE XREF: DllBlocklist_SetInXPCOMLoadOnMainThread(bool)+5j
		and	dword_1001AAA4,	0
		retn
?DllBlocklist_SetInXPCOMLoadOnMainThread@@YAX_N@Z endp

; Exported entry  77. ?mozalloc_set_oom_abort_handler@@YAXP6AXI@Z@Z

; =============== S U B	R O U T	I N E =======================================


; void __cdecl mozalloc_set_oom_abort_handler(void (__cdecl *)(unsigned	int))
		public ?mozalloc_set_oom_abort_handler@@YAXP6AXI@Z@Z
?mozalloc_set_oom_abort_handler@@YAXP6AXI@Z@Z proc near	; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	dword_1001AAA8,	eax
		retn
?mozalloc_set_oom_abort_handler@@YAXP6AXI@Z@Z endp

; Exported entry 106. frex
; Exported entry 111. jemalloc_purge_freed_pages

; =============== S U B	R O U T	I N E =======================================


		public jemalloc_purge_freed_pages
jemalloc_purge_freed_pages proc	near	; DATA XREF: .rdata:off_100175A8o
		retn			; frex
jemalloc_purge_freed_pages endp

; ---------------------------------------------------------------------------
		align 10h
; [0000000F BYTES: COLLAPSED FUNCTION __security_check_cookie(x)]
; [0000003C BYTES: COLLAPSED FUNCTION ___atonexitinit]

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_1000B00B(_onexit_t)
sub_1000B00B	proc near		; CODE XREF: sub_1000B0B4+6p

var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
Ptr		= dword	ptr -1Ch
ms_exc		= CPPEH_RECORD ptr -18h
arg_0		= dword	ptr  8

		push	14h
		push	offset stru_100174F8
		call	__SEH_prolog4
		and	[ebp+var_24], 0
		push	Ptr		; Ptr
		mov	esi, ds:DecodePointer
		call	esi ; DecodePointer
		mov	[ebp+Ptr], eax
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_1000B03D
		push	[ebp+arg_0]	; _onexit_t
		call	ds:_onexit
		pop	ecx
		jmp	short loc_1000B0A2
; ---------------------------------------------------------------------------

loc_1000B03D:				; CODE XREF: sub_1000B00B+24j
		push	8
		call	_lock
		pop	ecx
		and	[ebp+ms_exc.registration.TryLevel], 0
		push	Ptr		; Ptr
		call	esi ; DecodePointer
		mov	[ebp+Ptr], eax
		push	dword_1001A7E8	; Ptr
		call	esi ; DecodePointer
		mov	[ebp+var_20], eax
		lea	eax, [ebp+var_20]
		push	eax
		lea	eax, [ebp+Ptr]
		push	eax
		push	[ebp+arg_0]	; Ptr
		mov	esi, ds:EncodePointer
		call	esi ; EncodePointer
		push	eax
		call	__dllonexit
		add	esp, 0Ch
		mov	edi, eax
		mov	[ebp+var_24], edi
		push	[ebp+Ptr]	; Ptr
		call	esi ; EncodePointer
		mov	Ptr, eax
		push	[ebp+var_20]	; Ptr
		call	esi ; EncodePointer
		mov	dword_1001A7E8,	eax
		mov	[ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh
		call	loc_1000B0AB
; ---------------------------------------------------------------------------

loc_1000B0A0:				; CODE XREF: sub_1000B00B+A8j
		mov	eax, edi

loc_1000B0A2:				; CODE XREF: sub_1000B00B+30j
		call	__SEH_epilog4
		retn
; ---------------------------------------------------------------------------

loc_1000B0A8:				; DATA XREF: .rdata:stru_100174F8o
		mov	edi, [ebp+var_24] ; Finally handler 0 for function 1000B00B

loc_1000B0AB:				; CODE XREF: sub_1000B00B+90j
		push	8
		call	_unlock
		pop	ecx
		retn
sub_1000B00B	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_1000B0B4(_onexit_t)
sub_1000B0B4	proc near		; CODE XREF: sub_1000130A+Ap
					; sub_1000131B+Ap ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	[ebp+arg_0]	; _onexit_t
		call	sub_1000B00B
		neg	eax
		pop	ecx
		sbb	eax, eax
		neg	eax
		dec	eax
		pop	ebp
		retn
sub_1000B0B4	endp

; [0000003D BYTES: COLLAPSED FUNCTION ___raise_securityfailure]
; [000000FB BYTES: COLLAPSED FUNCTION ___report_gsfailure]
; [0000000C BYTES: COLLAPSED FUNCTION ___report_rangecheckfailure]
; [000000D0 BYTES: COLLAPSED FUNCTION ___report_securityfailure]
		align 2
; [00000006 BYTES: COLLAPSED FUNCTION _purecall]
; [0000004C BYTES: COLLAPSED FUNCTION _pre_c_init]

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000B330	proc near		; CODE XREF: ___DllMainCRTStartup+64p
					; ___DllMainCRTStartup+A3p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ecx
		cmp	[ebp+arg_4], 0
		push	ebx
		push	esi
		push	edi
		jnz	loc_1000B46B
		mov	eax, dword_1001A7C8
		test	eax, eax
		jle	loc_1000B464
		dec	eax
		mov	ebx, offset dword_1001A7DC
		mov	dword_1001A7C8,	eax
		xor	edi, edi
		mov	eax, large fs:18h
		mov	[ebp+var_4], edi
		mov	edx, [eax+4]
		jmp	short loc_1000B36E
; ---------------------------------------------------------------------------

loc_1000B36A:				; CODE XREF: sub_1000B330+48j
		cmp	eax, edx
		jz	short loc_1000B37C

loc_1000B36E:				; CODE XREF: sub_1000B330+38j
		xor	eax, eax
		mov	ecx, edx
		lock cmpxchg [ebx], ecx
		test	eax, eax
		jnz	short loc_1000B36A
		jmp	short loc_1000B383
; ---------------------------------------------------------------------------

loc_1000B37C:				; CODE XREF: sub_1000B330+3Cj
		mov	[ebp+var_4], 1

loc_1000B383:				; CODE XREF: sub_1000B330+4Aj
		cmp	dword_1001A7E0,	2
		jz	short loc_1000B399
		push	1Fh
		call	_amsg_exit
		pop	ecx
		jmp	loc_1000B51B
; ---------------------------------------------------------------------------

loc_1000B399:				; CODE XREF: sub_1000B330+5Aj
		push	Ptr		; Ptr
		call	ds:DecodePointer
		mov	esi, eax
		mov	[ebp+arg_8], esi
		test	esi, esi
		jz	loc_1000B44C
		push	dword_1001A7E8	; Ptr
		call	ds:DecodePointer
		mov	ebx, eax
		mov	[ebp+arg_4], esi
		mov	[ebp+arg_0], ebx

loc_1000B3C6:				; CODE XREF: sub_1000B330+9Fj
					; sub_1000B330+AAj ...
		sub	ebx, 4
		cmp	ebx, esi
		jb	short loc_1000B429
		cmp	[ebx], edi
		jz	short loc_1000B3C6
		push	edi		; Ptr
		call	ds:EncodePointer
		cmp	[ebx], eax
		jz	short loc_1000B3C6
		push	dword ptr [ebx]	; Ptr
		call	ds:DecodePointer
		push	edi		; Ptr
		mov	esi, eax
		call	ds:EncodePointer
		mov	[ebx], eax
		call	esi
		push	Ptr		; Ptr
		mov	esi, ds:DecodePointer
		call	esi ; DecodePointer
		push	dword_1001A7E8	; Ptr
		mov	[ebp+var_8], eax
		call	esi ; DecodePointer
		mov	ecx, [ebp+var_8]
		cmp	[ebp+arg_4], ecx
		jnz	short loc_1000B41A
		mov	esi, [ebp+arg_8]
		cmp	[ebp+arg_0], eax
		jz	short loc_1000B3C6

loc_1000B41A:				; CODE XREF: sub_1000B330+E0j
		mov	esi, ecx
		mov	[ebp+arg_4], ecx
		mov	[ebp+arg_8], esi
		mov	ebx, eax
		mov	[ebp+arg_0], eax
		jmp	short loc_1000B3C6
; ---------------------------------------------------------------------------

loc_1000B429:				; CODE XREF: sub_1000B330+9Bj
		cmp	esi, 0FFFFFFFFh
		jz	short loc_1000B436
		push	esi		; void *
		call	ds:free_0
		pop	ecx

loc_1000B436:				; CODE XREF: sub_1000B330+FCj
		push	edi		; Ptr
		call	ds:EncodePointer
		mov	dword_1001A7E8,	eax
		mov	ebx, offset dword_1001A7DC
		mov	Ptr, eax

loc_1000B44C:				; CODE XREF: sub_1000B330+7Cj
		mov	dword_1001A7E0,	edi
		cmp	[ebp+var_4], edi
		jnz	loc_1000B51B
		xor	eax, eax
		xchg	eax, [ebx]
		jmp	loc_1000B51B
; ---------------------------------------------------------------------------

loc_1000B464:				; CODE XREF: sub_1000B330+19j
					; sub_1000B330+19Fj
		xor	eax, eax
		jmp	loc_1000B51E
; ---------------------------------------------------------------------------

loc_1000B46B:				; CODE XREF: sub_1000B330+Cj
		cmp	[ebp+arg_4], 1
		jnz	loc_1000B51B
		mov	eax, large fs:18h
		xor	edi, edi
		mov	esi, edi
		mov	ebx, offset dword_1001A7DC
		mov	edx, [eax+4]
		jmp	short loc_1000B48D
; ---------------------------------------------------------------------------

loc_1000B489:				; CODE XREF: sub_1000B330+167j
		cmp	eax, edx
		jz	short loc_1000B49B

loc_1000B48D:				; CODE XREF: sub_1000B330+157j
		xor	eax, eax
		mov	ecx, edx
		lock cmpxchg [ebx], ecx
		test	eax, eax
		jnz	short loc_1000B489
		jmp	short loc_1000B49E
; ---------------------------------------------------------------------------

loc_1000B49B:				; CODE XREF: sub_1000B330+15Bj
		xor	esi, esi
		inc	esi

loc_1000B49E:				; CODE XREF: sub_1000B330+169j
		cmp	dword_1001A7E0,	edi
		push	2
		pop	edi
		jz	short loc_1000B4B2
		push	1Fh
		call	_amsg_exit
		jmp	short loc_1000B4E7
; ---------------------------------------------------------------------------

loc_1000B4B2:				; CODE XREF: sub_1000B330+177j
		push	offset dword_10016268
		push	offset dword_10016258
		mov	dword_1001A7E0,	1
		call	_initterm_e
		pop	ecx
		pop	ecx
		test	eax, eax
		jnz	short loc_1000B464
		push	offset dword_10016254
		push	offset dword_10016218
		call	_initterm
		pop	ecx
		mov	dword_1001A7E0,	edi

loc_1000B4E7:				; CODE XREF: sub_1000B330+180j
		pop	ecx
		test	esi, esi
		jnz	short loc_1000B4F0
		xor	eax, eax
		xchg	eax, [ebx]

loc_1000B4F0:				; CODE XREF: sub_1000B330+1BAj
		cmp	dword_1001A7E4,	0
		jz	short loc_1000B515
		push	offset dword_1001A7E4
		call	__IsNonwritableInCurrentImage
		pop	ecx
		test	eax, eax
		jz	short loc_1000B515
		push	[ebp+arg_8]
		push	edi
		push	[ebp+arg_0]
		call	dword_1001A7E4

loc_1000B515:				; CODE XREF: sub_1000B330+1C7j
					; sub_1000B330+1D6j
		inc	dword_1001A7C8

loc_1000B51B:				; CODE XREF: sub_1000B330+64j
					; sub_1000B330+125j ...
		xor	eax, eax
		inc	eax

loc_1000B51E:				; CODE XREF: sub_1000B330+136j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	0Ch
sub_1000B330	endp

; [00000023 BYTES: COLLAPSED FUNCTION DllEntryPoint]
; [00000133 BYTES: COLLAPSED FUNCTION ___DllMainCRTStartup]
		align 2
; [00000006 BYTES: COLLAPSED FUNCTION _lock]
; [00000006 BYTES: COLLAPSED FUNCTION _unlock]
; [00000006 BYTES: COLLAPSED FUNCTION __dllonexit]
; [00000045 BYTES: COLLAPSED FUNCTION __SEH_prolog4]
; [00000014 BYTES: COLLAPSED FUNCTION __SEH_epilog4]
; [00000023 BYTES: COLLAPSED FUNCTION __except_handler4]
; [00000006 BYTES: COLLAPSED FUNCTION _crt_debugger_hook]
; [00000006 BYTES: COLLAPSED FUNCTION __crtUnhandledException]
; [00000006 BYTES: COLLAPSED FUNCTION __crtTerminateProcess]
; [00000006 BYTES: COLLAPSED FUNCTION __CppXcptFilter]
; [00000006 BYTES: COLLAPSED FUNCTION _amsg_exit]
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000B730	proc near		; CODE XREF: __IsNonwritableInCurrentImage+59p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		xor	edx, edx
		push	ebx
		push	esi
		push	edi
		mov	ecx, [eax+3Ch]
		add	ecx, eax
		movzx	eax, word ptr [ecx+14h]
		movzx	ebx, word ptr [ecx+6]
		add	eax, 18h
		add	eax, ecx
		test	ebx, ebx
		jz	short loc_1000B76C
		mov	edi, [ebp+arg_4]

loc_1000B754:				; CODE XREF: sub_1000B730+3Aj
		mov	esi, [eax+0Ch]
		cmp	edi, esi
		jb	short loc_1000B764
		mov	ecx, [eax+8]
		add	ecx, esi
		cmp	edi, ecx
		jb	short loc_1000B76E

loc_1000B764:				; CODE XREF: sub_1000B730+29j
		inc	edx
		add	eax, 28h
		cmp	edx, ebx
		jb	short loc_1000B754

loc_1000B76C:				; CODE XREF: sub_1000B730+1Fj
		xor	eax, eax

loc_1000B76E:				; CODE XREF: sub_1000B730+32j
		pop	edi
		pop	esi
		pop	ebx
		pop	ebp
		retn
sub_1000B730	endp

; ---------------------------------------------------------------------------
		align 10h
; [000000BA BYTES: COLLAPSED FUNCTION __IsNonwritableInCurrentImage]
		align 10h
; [00000031 BYTES: COLLAPSED FUNCTION __ValidateImageBase]

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000B871	proc near		; CODE XREF: DllEntryPoint+9p

PerformanceCount= LARGE_INTEGER	ptr -14h
SystemTimeAsFileTime= _FILETIME	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		and	[ebp+SystemTimeAsFileTime.dwLowDateTime], 0
		and	[ebp+SystemTimeAsFileTime.dwHighDateTime], 0
		mov	eax, ___security_cookie
		push	esi
		push	edi
		mov	edi, 0BB40E64Eh
		mov	esi, 0FFFF0000h
		cmp	eax, edi
		jz	short loc_1000B8A1
		test	esi, eax
		jz	short loc_1000B8A1
		not	eax
		mov	dword_1001A004,	eax
		jmp	short loc_1000B907
; ---------------------------------------------------------------------------

loc_1000B8A1:				; CODE XREF: sub_1000B871+21j
					; sub_1000B871+25j
		lea	eax, [ebp+SystemTimeAsFileTime]
		push	eax		; lpSystemTimeAsFileTime
		call	ds:GetSystemTimeAsFileTime
		mov	eax, [ebp+SystemTimeAsFileTime.dwHighDateTime]
		xor	eax, [ebp+SystemTimeAsFileTime.dwLowDateTime]
		mov	[ebp+var_4], eax
		call	ds:GetCurrentThreadId
		xor	[ebp+var_4], eax
		call	ds:GetCurrentProcessId
		xor	[ebp+var_4], eax
		lea	eax, [ebp+PerformanceCount]
		push	eax		; lpPerformanceCount
		call	ds:QueryPerformanceCounter
		mov	ecx, dword ptr [ebp+PerformanceCount+4]
		lea	eax, [ebp+var_4]
		xor	ecx, dword ptr [ebp+PerformanceCount]
		xor	ecx, [ebp+var_4]
		xor	ecx, eax
		cmp	ecx, edi
		jnz	short loc_1000B8E9
		mov	ecx, 0BB40E64Fh
		jmp	short loc_1000B8F9
; ---------------------------------------------------------------------------

loc_1000B8E9:				; CODE XREF: sub_1000B871+6Fj
		test	esi, ecx
		jnz	short loc_1000B8F9
		mov	eax, ecx
		or	eax, 4711h
		shl	eax, 10h
		or	ecx, eax

loc_1000B8F9:				; CODE XREF: sub_1000B871+76j
					; sub_1000B871+7Aj
		mov	___security_cookie, ecx
		not	ecx
		mov	dword_1001A004,	ecx

loc_1000B907:				; CODE XREF: sub_1000B871+2Ej
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
sub_1000B871	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000B90D	proc near		; CODE XREF: _pre_c_init+2Cp
		push	esi
		push	edi
		mov	esi, offset dword_100174EC
		mov	edi, offset dword_100174EC
		jmp	short loc_1000B926
; ---------------------------------------------------------------------------

loc_1000B91B:				; CODE XREF: sub_1000B90D+1Bj
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_1000B923
		call	eax

loc_1000B923:				; CODE XREF: sub_1000B90D+12j
		add	esi, 4

loc_1000B926:				; CODE XREF: sub_1000B90D+Cj
		cmp	esi, edi
		jb	short loc_1000B91B
		pop	edi
		pop	esi
		retn
sub_1000B90D	endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_1000B92D()
sub_1000B92D	proc near		; DATA XREF: _pre_c_init+31o
		push	esi
		push	edi
		mov	esi, offset dword_100174F4
		mov	edi, offset dword_100174F4
		jmp	short loc_1000B946
; ---------------------------------------------------------------------------

loc_1000B93B:				; CODE XREF: sub_1000B92D+1Bj
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_1000B943
		call	eax

loc_1000B943:				; CODE XREF: sub_1000B92D+12j
		add	esi, 4

loc_1000B946:				; CODE XREF: sub_1000B92D+Cj
		cmp	esi, edi
		jb	short loc_1000B93B
		pop	edi
		pop	esi
		retn
sub_1000B92D	endp

; ---------------------------------------------------------------------------
		align 2
; [00000006 BYTES: COLLAPSED FUNCTION _initterm]
; [00000006 BYTES: COLLAPSED FUNCTION _initterm_e]

; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_1000B95A()
sub_1000B95A	proc near		; DATA XREF: _pre_c_init+3Bo
		push	offset dword_1001A7CC
		call	__clean_type_info_names_internal
		pop	ecx
		retn
sub_1000B95A	endp

; [00000006 BYTES: COLLAPSED FUNCTION _except_handler4_common]
; [00000006 BYTES: COLLAPSED FUNCTION __clean_type_info_names_internal]
; [00000006 BYTES: COLLAPSED FUNCTION std::basic_streambuf<char,std::char_traits<char>>::imbue(std::locale const &)]
; [00000006 BYTES: COLLAPSED FUNCTION std::basic_streambuf<char,std::char_traits<char>>::sync(void)]
; [00000006 BYTES: COLLAPSED FUNCTION std::basic_streambuf<char,std::char_traits<char>>::setbuf(char *,__int64)]
; [00000006 BYTES: COLLAPSED FUNCTION std::basic_streambuf<char,std::char_traits<char>>::xsputn(char const *,__int64)]
; [00000006 BYTES: COLLAPSED FUNCTION std::basic_streambuf<char,std::char_traits<char>>::xsgetn(char *,__int64)]
; [00000006 BYTES: COLLAPSED FUNCTION std::basic_streambuf<char,std::char_traits<char>>::uflow(void)]
; [00000006 BYTES: COLLAPSED FUNCTION std::basic_streambuf<char,std::char_traits<char>>::showmanyc(void)]
; [00000006 BYTES: COLLAPSED FUNCTION std::basic_streambuf<char,std::char_traits<char>>::_Unlock(void)]
; [00000006 BYTES: COLLAPSED FUNCTION std::basic_streambuf<char,std::char_traits<char>>::_Lock(void)]
; [00000006 BYTES: COLLAPSED FUNCTION IsProcessorFeaturePresent]
		align 10h
; [00000048 BYTES: COLLAPSED FUNCTION __SEH_prolog4_GS]
; [0000000F BYTES: COLLAPSED FUNCTION __SEH_epilog4_GS]
		align 10h
; [000000AA BYTES: COLLAPSED FUNCTION __alldiv]
		align 10h
; [00000034 BYTES: COLLAPSED FUNCTION __allmul]
		align 10h
; [0000001F BYTES: COLLAPSED FUNCTION __allshl]
		align 10h
; [00000021 BYTES: COLLAPSED FUNCTION __allshr]
		align 10h
; [00000068 BYTES: COLLAPSED FUNCTION __aulldiv]
		align 10h
; [00000095 BYTES: COLLAPSED FUNCTION __aulldvrm]
		align 10h
; [00000075 BYTES: COLLAPSED FUNCTION __aullrem]
		align 10h
; [0000001F BYTES: COLLAPSED FUNCTION __aullshr]
		align 10h
; [0000002B BYTES: COLLAPSED FUNCTION __alloca_probe]
		align 10h
; [0000001C BYTES: COLLAPSED FUNCTION __ftol2_sse]
; ---------------------------------------------------------------------------

__ftol2_sse_excpt:
		cmp	dword_1001A7D4,	0
		jz	short __ftol2
		sub	esp, 4
		fnstcw	word ptr [esp]
		pop	eax
		and	ax, 7Fh
		cmp	ax, 7Fh
		jz	short __ftol2_pentium4
; [00000075 BYTES: COLLAPSED FUNCTION __ftol2]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION ceil]
; [00000006 BYTES: COLLAPSED FUNCTION memcpy]
; [00000006 BYTES: COLLAPSED FUNCTION memset]
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000BDF0	proc near		; DATA XREF: .rdata:10016264o

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		and	dword_1001A7D4,	0
		sub	esp, 1Ch
		push	ebx
		xor	ebx, ebx
		inc	ebx
		or	dword_1001A020,	ebx
		push	0Ah		; ProcessorFeature
		call	IsProcessorFeaturePresent
		test	eax, eax
		jz	loc_1000BF62
		xor	ecx, ecx
		mov	dword_1001A7D4,	ebx
		xor	eax, eax
		cpuid
		push	esi
		mov	esi, dword_1001A020
		push	edi
		lea	edi, [ebp+var_1C]
		or	esi, 2
		mov	[edi], eax
		mov	[edi+4], ebx
		mov	[edi+8], ecx
		mov	[edi+0Ch], edx
		mov	eax, [ebp+var_1C]
		mov	ecx, [ebp+var_10]
		mov	[ebp+var_C], eax
		xor	ecx, 49656E69h
		mov	eax, [ebp+var_14]
		xor	eax, 6C65746Eh
		mov	dword_1001A020,	esi
		or	ecx, eax
		mov	eax, [ebp+var_18]
		xor	eax, 756E6547h
		or	ecx, eax
		neg	ecx
		push	1
		sbb	cl, cl
		pop	eax
		inc	cl
		push	0
		pop	ecx
		cpuid
		mov	[edi], eax
		mov	[edi+4], ebx
		mov	[edi+8], ecx
		mov	[edi+0Ch], edx
		mov	ecx, [ebp+var_14]
		mov	[ebp+var_8], ecx
		jz	short loc_1000BEC8
		mov	eax, [ebp+var_1C]
		and	eax, 0FFF3FF0h
		cmp	eax, 106C0h
		jz	short loc_1000BEB7
		cmp	eax, 20660h
		jz	short loc_1000BEB7
		cmp	eax, 20670h
		jz	short loc_1000BEB7
		cmp	eax, 30650h
		jz	short loc_1000BEB7
		cmp	eax, 30660h
		jz	short loc_1000BEB7
		cmp	eax, 30670h
		jnz	short loc_1000BEC8

loc_1000BEB7:				; CODE XREF: sub_1000BDF0+A2j
					; sub_1000BDF0+A9j ...
		mov	edi, dword_1001A7D8
		or	edi, 1
		mov	dword_1001A7D8,	edi
		jmp	short loc_1000BECE
; ---------------------------------------------------------------------------

loc_1000BEC8:				; CODE XREF: sub_1000BDF0+93j
					; sub_1000BDF0+C5j
		mov	edi, dword_1001A7D8

loc_1000BECE:				; CODE XREF: sub_1000BDF0+D6j
		cmp	[ebp+var_C], 7
		jl	short loc_1000BF09
		push	7
		xor	ecx, ecx
		lea	esi, [ebp+var_1C]
		pop	eax
		cpuid
		mov	[esi], eax
		mov	eax, esi
		mov	esi, dword_1001A020
		mov	[eax+4], ebx
		mov	[eax+8], ecx
		mov	ecx, [ebp+var_8]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_18]
		test	eax, 200h
		jz	short loc_1000BF0B
		or	edi, 2
		mov	dword_1001A7D8,	edi
		jmp	short loc_1000BF0B
; ---------------------------------------------------------------------------

loc_1000BF09:				; CODE XREF: sub_1000BDF0+E2j
		xor	eax, eax

loc_1000BF0B:				; CODE XREF: sub_1000BDF0+10Cj
					; sub_1000BDF0+117j
		test	ecx, 100000h
		jz	short loc_1000BF60
		or	esi, 4
		mov	dword_1001A7D4,	2
		mov	dword_1001A020,	esi
		test	ecx, 8000000h
		jz	short loc_1000BF60
		test	ecx, 10000000h
		jz	short loc_1000BF60
		or	esi, 8
		mov	dword_1001A7D4,	3
		mov	dword_1001A020,	esi
		test	al, 20h
		jz	short loc_1000BF60
		or	esi, 20h
		mov	dword_1001A7D4,	5
		mov	dword_1001A020,	esi

loc_1000BF60:				; CODE XREF: sub_1000BDF0+121j
					; sub_1000BDF0+13Cj ...
		pop	edi
		pop	esi

loc_1000BF62:				; CODE XREF: sub_1000BDF0+20j
		xor	eax, eax
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
sub_1000BDF0	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000BF69	proc near		; DATA XREF: .rdata:off_100174BCo

arg_0		= byte ptr  4

; FUNCTION CHUNK AT 10010421 SIZE 0000001F BYTES

		sub	ecx, [ecx-4]
		jmp	loc_10010421
sub_1000BF69	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000BF71	proc near		; DATA XREF: .rdata:10016358o
					; .rdata:10016388o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	edx, [esp+arg_4]
		mov	[eax], edx
		mov	[eax+4], ecx
		retn	8
sub_1000BF71	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000BF81	proc near		; DATA XREF: .rdata:10016380o
		mov	eax, offset aGeneric ; "generic"
		retn
sub_1000BF81	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000BF87	proc near		; DATA XREF: .rdata:10016398o
		mov	eax, offset aIostream ;	"iostream"
		retn
sub_1000BF87	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000BF8D	proc near		; DATA XREF: .rdata:10016368o
		mov	eax, offset aSystem ; "system"
		retn
sub_1000BF8D	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: thunk

; int __cdecl sub_1000BF93()
sub_1000BF93	proc near		; DATA XREF: sub_1000130A+5o
		jmp	sub_100013FD
sub_1000BF93	endp

; [00000005 BYTES: COLLAPSED FUNCTION mozilla::TimeStamp::Shutdown(void)]

; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_1000BF9D()
sub_1000BF9D	proc near		; DATA XREF: sub_1000132Co
		mov	off_1001A02C, offset off_1001634C
		retn
sub_1000BF9D	endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_1000BFA8()
sub_1000BFA8	proc near		; DATA XREF: sub_10001338+5o
		mov	dword_1001ABF4,	offset off_1001634C
		retn
sub_1000BFA8	endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_1000BFB3()
sub_1000BFB3	proc near		; DATA XREF: sub_10001349+5o
		mov	dword_1001ABF0,	offset off_1001634C
		retn
sub_1000BFB3	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?DllBlocklist_Initialize@@YAXXZ

loc_1000BFBE:				; CODE XREF: DllBlocklist_Initialize(void)+57j
		push	18h
		mov	[esi], edi
		mov	[esi+4], edi
		call	moz_xmalloc
		pop	ecx
		test	eax, eax
		jnz	short loc_1000BFD5
		call	ds:?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)

loc_1000BFD5:				; CODE XREF: DllBlocklist_Initialize(void)+AC5Dj
		lea	ecx, [eax+4]
		mov	[eax], eax
		test	ecx, ecx
		jz	short loc_1000BFE0
		mov	[ecx], eax

loc_1000BFE0:				; CODE XREF: DllBlocklist_Initialize(void)+AC6Cj
		lea	ecx, [eax+8]
		test	ecx, ecx
		jz	loc_100013D7
		jmp	loc_100013D5
; END OF FUNCTION CHUNK	FOR ?DllBlocklist_Initialize@@YAXXZ
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100013FD

loc_1000BFF0:				; CODE XREF: sub_100013FD+14j
		push	ebx
		mov	ebx, ds:GetCurrentProcess
		push	ebp
		push	edi
		mov	edi, offset dword_1001A834

loc_1000BFFE:				; CODE XREF: sub_100013FD+AC4Fj
		mov	ebp, [edi]
		lea	eax, [esp+14h+flOldProtect]
		push	eax		; lpflOldProtect
		push	40h		; flNewProtect
		push	2		; dwSize
		push	ebp		; lpAddress
		call	ebx ; GetCurrentProcess
		push	eax		; hProcess
		call	ds:VirtualProtectEx
		test	eax, eax
		jz	short loc_1000C042
		mov	eax, 0FF8Bh
		mov	[ebp+0], ax
		lea	eax, [esp+14h+flOldProtect]
		push	eax		; lpflOldProtect
		push	[esp+18h+flOldProtect] ; flNewProtect
		push	2		; dwSize
		push	ebp		; lpAddress
		call	ebx ; GetCurrentProcess
		push	eax		; hProcess
		call	ds:VirtualProtectEx
		push	0		; dwSize
		push	0		; lpBaseAddress
		call	ebx ; GetCurrentProcess
		push	eax		; hProcess
		call	ds:FlushInstructionCache

loc_1000C042:				; CODE XREF: sub_100013FD+AC18j
		inc	esi
		add	edi, 4
		cmp	esi, dword_1001AA34
		jl	short loc_1000BFFE
		pop	edi
		pop	ebp
		pop	ebx
		jmp	loc_10001417
; END OF FUNCTION CHUNK	FOR sub_100013FD
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10001482

loc_1000C056:				; CODE XREF: sub_10001482+52j
		test	al, al
		jnz	short loc_1000C06D
		mov	dl, cl
		and	dl, 7
		cmp	dl, 4
		jz	short loc_1000C06D
		cmp	dl, 5
		jnz	loc_100014DA

loc_1000C06D:				; CODE XREF: sub_10001482+ABD6j
					; sub_10001482+ABE0j
		cmp	al, 40h
		jnz	loc_10001552
		and	cl, 7
		cmp	cl, 4
		jnz	short loc_1000C093
		add	esi, 4
		jmp	loc_100014DD
; ---------------------------------------------------------------------------

loc_1000C085:				; CODE XREF: sub_10001482+DFj
		mov	al, [esi+ebx+1]
		and	al, 0C0h
		cmp	al, 0C0h
		jnz	loc_10001552

loc_1000C093:				; CODE XREF: sub_10001482+ABF9j
		add	esi, 3
		jmp	loc_100014DD
; ---------------------------------------------------------------------------

loc_1000C09B:				; CODE XREF: sub_10001482+F0j
		cmp	cl, 6Ah
		jz	loc_100014DA
		cmp	cl, 0E9h
		jnz	short loc_1000C0B0
		mov	ebp, esi
		jmp	loc_1000157E
; ---------------------------------------------------------------------------

loc_1000C0B0:				; CODE XREF: sub_10001482+AC25j
		cmp	cl, 0FFh
		jnz	loc_10001552
		cmp	byte ptr [esi+ebx+1], 25h
		jnz	loc_10001552
		add	esi, 6
		jmp	loc_100014DD
; END OF FUNCTION CHUNK	FOR sub_10001482
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100016CF

loc_1000C0CC:				; CODE XREF: sub_100016CF+8j
		push	edi
		mov	edi, offset stru_1001AB30
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	ecx, dword_1001AB24
		mov	eax, dword_1001AB00
		mov	esi, [eax+ecx*4]
		test	esi, esi
		jnz	short loc_1000C0F8
		call	sub_100068B3
		mov	ecx, dword_1001AB24
		mov	esi, eax

loc_1000C0F8:				; CODE XREF: sub_100016CF+AA1Aj
		lea	eax, [ecx+1]
		xor	edx, edx
		div	dword_1001AB2C
		push	edi		; lpCriticalSection
		mov	dword_1001AB24,	edx
		call	ds:LeaveCriticalSection
		pop	edi
		jmp	loc_100016E4
; END OF FUNCTION CHUNK	FOR sub_100016CF
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR posix_memalign

loc_1000C116:				; CODE XREF: posix_memalign+2Aj
					; posix_memalign+31j
		pop	eax
		retn
; END OF FUNCTION CHUNK	FOR posix_memalign
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000172B

loc_1000C118:				; CODE XREF: sub_1000172B+5Cj
					; sub_1000172B+66j
		mov	eax, 0FFFFF000h
		lea	esi, [edx+0FFFh]
		lea	edi, [ecx+0FFFh]
		and	esi, eax
		and	edi, eax
		cmp	esi, edx
		jb	short loc_1000C18A
		lea	ebx, [esi+edi]
		cmp	ebx, esi
		jb	short loc_1000C18A
		cmp	esi, edi
		jb	short loc_1000C140
		add	ebx, eax
		jmp	short loc_1000C147
; ---------------------------------------------------------------------------

loc_1000C140:				; CODE XREF: sub_1000172B+AA0Fj
		lea	ebx, ds:0FFFFF000h[edi*2]

loc_1000C147:				; CODE XREF: sub_1000172B+AA13j
		cmp	ebx, ebp
		ja	short loc_1000C171
		push	dwTlsIndex	; dwTlsIndex
		call	ds:TlsGetValue
		test	eax, eax
		jnz	short loc_1000C160
		call	sub_100016CF

loc_1000C160:				; CODE XREF: sub_1000172B+AA2Ej
		push	ebx		; int
		push	esi		; int
		mov	edx, edi
		mov	ecx, eax	; lpCriticalSection
		call	sub_1000EF13
		pop	ecx
		jmp	loc_1000177A
; ---------------------------------------------------------------------------

loc_1000C171:				; CODE XREF: sub_1000172B+AA1Ej
		mov	edx, 100000h
		mov	ecx, esi
		push	0
		cmp	edi, edx
		jbe	short loc_1000C180
		mov	edx, edi

loc_1000C180:				; CODE XREF: sub_1000172B+AA51j
		call	sub_10005C6D
		jmp	loc_1000177A
; ---------------------------------------------------------------------------

loc_1000C18A:				; CODE XREF: sub_1000172B+AA04j
					; sub_1000172B+AA0Bj
		xor	eax, eax
		jmp	loc_1000177B
; END OF FUNCTION CHUNK	FOR sub_1000172B
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR moz_xcalloc

loc_1000C191:				; CODE XREF: moz_xcalloc+12j
		cmp	[ebp+arg_0], 0
		jz	loc_100017CA
		cmp	[ebp+arg_4], 0
		jz	loc_100017CA
		push	[ebp+arg_4]	; unsigned int
		call	?mozalloc_handle_oom@@YAXI@Z ; mozalloc_handle_oom(uint)
; ---------------------------------------------------------------------------
		align 2
; END OF FUNCTION CHUNK	FOR moz_xcalloc
; START	OF FUNCTION CHUNK FOR moz_xrealloc

loc_1000C1AE:				; CODE XREF: moz_xrealloc+39j
		cmp	ebp, 9
		jnb	loc_10001979
		lea	ecx, [esi-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 10h
		or	eax, ecx
		inc	eax
		shr	eax, 2
		bsf	eax, eax
		jz	short loc_1000C1EA
		lea	edx, [eax+1]
		jmp	short loc_1000C1EC
; ---------------------------------------------------------------------------

loc_1000C1EA:				; CODE XREF: moz_xrealloc+A8D3j
		xor	edx, edx

loc_1000C1EC:				; CODE XREF: moz_xrealloc+A8D8j
		lea	ecx, [ebp-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 10h
		or	eax, ecx
		inc	eax
		shr	eax, 2
		bsf	eax, eax
		jz	short loc_1000C21D
		inc	eax
		jmp	short loc_1000C21F
; ---------------------------------------------------------------------------

loc_1000C21D:				; CODE XREF: moz_xrealloc+A908j
		xor	eax, eax

loc_1000C21F:				; CODE XREF: moz_xrealloc+A90Bj
		cmp	edx, eax
		jz	loc_10001AFC
		jmp	loc_10001979
; ---------------------------------------------------------------------------

loc_1000C22C:				; CODE XREF: moz_xrealloc+7Dj
		call	sub_100016CF
		mov	edx, eax
		mov	[esp+28h+lpCriticalSection], eax
		jmp	loc_10001993
; ---------------------------------------------------------------------------

loc_1000C23C:				; CODE XREF: moz_xrealloc+92j
		lea	ecx, [esi-1]
		mov	eax, ecx
		shr	eax, 1
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 2
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 4
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 8
		or	ecx, eax
		mov	eax, ecx
		shr	eax, 10h
		or	eax, ecx
		inc	eax
		mov	[esp+28h+var_C], eax
		shr	eax, 2
		bsf	eax, eax
		jz	short loc_1000C271
		inc	eax
		jmp	short loc_1000C273
; ---------------------------------------------------------------------------

loc_1000C271:				; CODE XREF: moz_xrealloc+A95Cj
		xor	eax, eax

loc_1000C273:				; CODE XREF: moz_xrealloc+A95Fj
		cmp	[esp+28h+var_C], 2
		lea	eax, [eax+eax*8]
		lea	eax, [eax+17h]
		lea	eax, [edx+eax*8]
		mov	[esp+28h+var_14], eax
		jnb	loc_100019CE
		mov	[esp+28h+var_C], 2
		jmp	loc_100019CE
; ---------------------------------------------------------------------------

loc_1000C298:				; CODE XREF: moz_xrealloc+13Fj
					; moz_xrealloc+21Fj
		push	[esp+28h+lpCriticalSection] ; lpCriticalSection
		mov	eax, ds:LeaveCriticalSection
		call	eax ; LeaveCriticalSection
		xor	eax, eax
		jmp	loc_10001CC0
; ---------------------------------------------------------------------------

loc_1000C2AA:				; CODE XREF: moz_xrealloc+190j
		mov	ecx, ebx
		call	sub_10006073
		jmp	loc_10001AE6
; END OF FUNCTION CHUNK	FOR moz_xrealloc

; =============== S U B	R O U T	I N E =======================================


sub_1000C2B6	proc near		; CODE XREF: moz_xrealloc+30j
		push	ebp		; int
		mov	edx, esi	; size_t
		mov	ecx, ebx	; void *
		call	sub_10006906
		add	esp, 4
		mov	ebx, eax
		jmp	loc_10001AEA
sub_1000C2B6	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR moz_xrealloc

loc_1000C2CA:				; CODE XREF: moz_xrealloc+1DDj
					; moz_xrealloc+3F5j
		call	ds:_errno
		mov	dword ptr [eax], 0Ch
		test	edi, edi
		jz	loc_10001AF3
		push	edi		; unsigned int
		call	?mozalloc_handle_oom@@YAXI@Z ; mozalloc_handle_oom(uint)
; ---------------------------------------------------------------------------
		db 0CCh
; END OF FUNCTION CHUNK	FOR moz_xrealloc
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR realloc

loc_1000C2E5:				; CODE XREF: realloc+7Bj
		call	sub_100016CF
		mov	edi, eax
		jmp	loc_10001DB1
; ---------------------------------------------------------------------------

loc_1000C2F1:				; CODE XREF: realloc+4CFj
		mov	[esp+20h+arg_0], 2
		jmp	loc_10001DEF
; ---------------------------------------------------------------------------

loc_1000C2FE:				; CODE XREF: realloc+127j realloc+3E2j
		mov	eax, ds:LeaveCriticalSection
		push	edi		; lpCriticalSection
		call	eax ; LeaveCriticalSection
		xor	ebp, ebp
		jmp	loc_10001E80
; ---------------------------------------------------------------------------

loc_1000C30D:				; CODE XREF: realloc+247j realloc+262j
		call	ds:_errno
		mov	dword ptr [eax], 0Ch
		jmp	loc_10001F7D
; END OF FUNCTION CHUNK	FOR realloc
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100023C0

loc_1000C31E:				; CODE XREF: sub_100023C0+Fj
		push	offset stru_1001AAB0 ; lpCriticalSection
		call	ds:EnterCriticalSection
		lea	edx, [esp+20h+var_1C]
		mov	[esp+20h+var_C], esi
		call	sub_10005E22
		push	offset stru_1001AAB0 ; lpCriticalSection
		mov	esi, [eax+14h]
		call	ds:LeaveCriticalSection
		mov	eax, esi
		jmp	loc_100023FB
; END OF FUNCTION CHUNK	FOR sub_100023C0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10002410

loc_1000C34B:				; CODE XREF: sub_10002410+F8j
					; sub_10002410+122j
		mov	eax, edi
		xor	edx, edx
		div	ebp
		mov	edi, eax
		jmp	loc_1000246C
; END OF FUNCTION CHUNK	FOR sub_10002410
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100025C0

loc_1000C358:				; CODE XREF: sub_100025C0+23j
		call	sub_100016CF
		mov	esi, eax
		jmp	loc_100025E9
; ---------------------------------------------------------------------------

loc_1000C364:				; CODE XREF: sub_100025C0+BEj
					; sub_100025C0+FBj
		push	esi		; lpCriticalSection
		call	ds:LeaveCriticalSection
		xor	ecx, ecx
		jmp	loc_100026A2
; ---------------------------------------------------------------------------

loc_1000C372:				; CODE XREF: sub_100025C0+Cj
		push	0
		mov	edx, 100000h
		call	sub_10005C6D
		add	esp, 4
		jmp	loc_100026A7
; END OF FUNCTION CHUNK	FOR sub_100025C0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR strdup

loc_1000C386:				; CODE XREF: strdup+26j
		push	0
		mov	edx, 100000h
		mov	ecx, edi
		call	sub_10005C6D
		jmp	loc_1000284F
; END OF FUNCTION CHUNK	FOR strdup
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100028A0

loc_1000C399:				; CODE XREF: sub_100028A0+57j
		mov	[esp+10h+var_4], 2
		jmp	loc_100028FD
; ---------------------------------------------------------------------------

loc_1000C3A6:				; CODE XREF: sub_100028A0+83j
		call	ds:LeaveCriticalSection
		xor	eax, eax
		jmp	loc_10002953
; ---------------------------------------------------------------------------

loc_1000C3B3:				; CODE XREF: sub_100028A0+ABj
		push	edi		; size_t
		push	0		; int
		push	ebp		; void *
		call	memset
		add	esp, 0Ch
		jmp	loc_10002951
; END OF FUNCTION CHUNK	FOR sub_100028A0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100029D0

loc_1000C3C4:				; CODE XREF: sub_100029D0+B1j
		lea	ecx, [esp+24h+var_C]
		mov	edx, ecx
		cmp	edx, eax
		jbe	loc_10002A89
		mov	edx, 1
		jmp	loc_10002A8B
; END OF FUNCTION CHUNK	FOR sub_100029D0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR calloc

loc_1000C3DC:				; CODE XREF: calloc+E9j calloc+197j
		push	edi		; lpCriticalSection
		call	ds:LeaveCriticalSection
		xor	esi, esi
		jmp	loc_10002C79
; ---------------------------------------------------------------------------

loc_1000C3EA:				; CODE XREF: calloc+11Dj calloc+276j
		call	ds:_errno
		mov	dword ptr [eax], 0Ch
		jmp	loc_10002C83
; END OF FUNCTION CHUNK	FOR calloc
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR moz_xmalloc

loc_1000C3FB:				; CODE XREF: moz_xmalloc+280j
		mov	dword ptr [edi], 0

loc_1000C401:				; CODE XREF: moz_xmalloc+95j
					; moz_xmalloc+114j
		push	esi		; lpCriticalSection
		call	ds:LeaveCriticalSection
		xor	ebp, ebp
		jmp	loc_10002FB9
; ---------------------------------------------------------------------------

loc_1000C40F:				; CODE XREF: moz_xmalloc+18j
		push	0
		mov	edx, 100000h
		mov	ecx, eax
		call	sub_10005C6D
		add	esp, 4
		mov	ebp, eax
		jmp	loc_10002FBB
; ---------------------------------------------------------------------------

loc_1000C427:				; CODE XREF: moz_xmalloc+BDj
		call	ds:_errno
		cmp	[esp+10h+arg_0], 0
		mov	dword ptr [eax], 0Ch
		jz	loc_10002FC3
		push	[esp+10h+arg_0]	; unsigned int
		call	?mozalloc_handle_oom@@YAXI@Z ; mozalloc_handle_oom(uint)
; ---------------------------------------------------------------------------
		align 4
; END OF FUNCTION CHUNK	FOR moz_xmalloc
; START	OF FUNCTION CHUNK FOR malloc

loc_1000C448:				; CODE XREF: malloc+226j
		mov	dword ptr [edi], 0

loc_1000C44E:				; CODE XREF: malloc+96j malloc+154j
		push	esi		; lpCriticalSection
		call	ds:LeaveCriticalSection
		xor	ebp, ebp
		jmp	loc_1000330A
; ---------------------------------------------------------------------------

loc_1000C45C:				; CODE XREF: malloc+259j
		mov	dword ptr [ebx+edx*4+0Ch], 0FFFFFFFFh
		jmp	loc_100034BF
; ---------------------------------------------------------------------------

loc_1000C469:				; CODE XREF: malloc+BEj
		call	ds:_errno
		mov	dword ptr [eax], 0Ch
		jmp	loc_10003314
; END OF FUNCTION CHUNK	FOR malloc
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10003640

loc_1000C47A:				; CODE XREF: sub_10003640+4BBj
		or	edx, 1
		mov	[ecx+4], edx
		mov	edx, [ecx]
		mov	ecx, [edx+4]
		test	cl, 1
		jz	loc_100039A3
		and	ecx, 0FFFFFFFEh
		mov	[edx+4], ecx
		jmp	loc_10003BA8
; ---------------------------------------------------------------------------

loc_1000C499:				; CODE XREF: sub_10003640+49Ej
		mov	eax, [ebp+0Ch+var_8]
		and	eax, 1
		or	eax, edi
		mov	[ebp+0Ch+var_8], eax
		mov	eax, [esp+2Ch+var_C]
		mov	[ecx], eax
		jmp	loc_1000374D
; END OF FUNCTION CHUNK	FOR sub_10003640
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10003C40

loc_1000C4AF:				; CODE XREF: sub_10003C40+DFj
		lea	ecx, [esp+24h+var_C]
		mov	eax, ecx
		cmp	eax, edx
		jbe	loc_10003D27
		mov	eax, 1
		jmp	loc_10003D29
; END OF FUNCTION CHUNK	FOR sub_10003C40
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10003FB0

loc_1000C4C7:				; CODE XREF: sub_10003FB0+51Cj
		mov	ecx, [ebx]
		or	edx, 1
		mov	[ebx+4], edx
		mov	eax, [ecx+4]
		test	al, 1
		jz	loc_1000430C
		jmp	loc_10004483
; ---------------------------------------------------------------------------

loc_1000C4DF:				; CODE XREF: sub_10003FB0+158j
		mov	eax, [ecx+4]
		and	eax, 1
		or	eax, edx
		mov	[ecx+4], eax
		jmp	loc_10004110
; ---------------------------------------------------------------------------

loc_1000C4EF:				; CODE XREF: sub_10003FB0+405j
		mov	eax, [ecx+4]
		and	eax, 1
		or	eax, ebp
		mov	[ecx+4], eax
		mov	ecx, [esp+30h+var_1C]
		mov	eax, [esp+30h+var_C]
		mov	[ecx], eax
		jmp	loc_100040C5
; END OF FUNCTION CHUNK	FOR sub_10003FB0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10004A40

loc_1000C509:				; CODE XREF: sub_10004A40+45j
		test	ebp, ebp
		jz	loc_10004AB6
		mov	eax, edx
		mov	[esp+18h+arg_0], ebp

loc_1000C517:				; CODE XREF: sub_10004A40+7AE1j
		and	dword ptr [eax], 0FFFFFFFCh
		lea	eax, [eax+0Ch]
		dec	[esp+18h+arg_0]
		jnz	short loc_1000C517
		jmp	loc_10004AB6
; ---------------------------------------------------------------------------

loc_1000C528:				; CODE XREF: sub_10004A40+1DBj
		cmp	dword ptr [ebp+0Ch], 0
		jbe	short loc_1000C54F
		mov	ecx, [esi]
		mov	edx, ebp
		sub	ecx, 0FFFFFF80h
		call	sub_10004FE0
		mov	ebp, [edi+0A0h]
		mov	eax, [ebp+0Ch]
		sub	[edi+0A4h], eax
		mov	eax, [ebp+0Ch]
		sub	[edi+50h], eax

loc_1000C54F:				; CODE XREF: sub_10004A40+7AECj
		mov	edx, 100000h
		mov	ecx, ebp
		call	sub_1000600C
		add	dword ptr [edi+18h], 0FFF00000h
		dec	dword ptr [edi+50h]
		jmp	loc_10004C21
; END OF FUNCTION CHUNK	FOR sub_10004A40
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10004FE0

loc_1000C56A:				; CODE XREF: sub_10004FE0+567j
		or	ecx, 1
		mov	[edx+8], ecx
		mov	edx, [edx+4]
		mov	ecx, [edx+8]
		test	cl, 1
		jz	loc_10005243
		and	ecx, 0FFFFFFFEh
		mov	[edx+8], ecx
		mov	ebx, [eax+4]
		mov	ecx, [ebx+8]
		and	ecx, 0FFFFFFFEh
		mov	[eax+4], ecx
		mov	ecx, [ebx+8]
		and	ecx, 1
		or	ecx, eax
		mov	[ebx+8], ecx
		mov	ecx, [eax+8]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		and	ecx, 1
		or	ecx, [edx+4]
		mov	[eax+8], ecx
		mov	[edx+4], eax
		mov	eax, [ebx+8]
		and	eax, 1
		or	eax, edx
		mov	[ebx+8], eax
		jmp	loc_10005257
; ---------------------------------------------------------------------------

loc_1000C5C0:				; CODE XREF: sub_10004FE0+3C5j
		mov	eax, [ebx+8]
		and	eax, 1
		or	eax, edi
		mov	[ebx+8], eax
		mov	eax, [esp+40h+var_1C]
		mov	[ecx], eax
		jmp	loc_100050BC
; END OF FUNCTION CHUNK	FOR sub_10004FE0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10005A0F

loc_1000C5D6:				; CODE XREF: sub_10005A0F+59j
					; sub_10005A0F+6C20j
		mov	eax, [eax-4]
		mov	[esp+24h+var_10], eax
		mov	eax, ebx
		shl	eax, cl
		push	20h
		pop	ecx
		sub	ecx, [esp+24h+var_10]
		shr	eax, cl
		lea	eax, [edx+eax*4]
		mov	edx, [eax]
		mov	[esp+24h+var_8], eax
		test	edx, edx
		jnz	short loc_1000C613
		mov	ecx, [esp+24h+var_14]
		push	4
		pop	edx
		mov	ecx, [ecx]
		shl	edx, cl
		call	sub_1000611C
		mov	edx, eax
		test	edx, edx
		jz	short loc_1000C639
		mov	eax, [esp+24h+var_8]
		mov	[eax], edx

loc_1000C613:				; CODE XREF: sub_10005A0F+6BE6j
		mov	eax, [esp+24h+var_14]
		inc	ebp
		mov	ecx, [esp+24h+var_C]
		add	eax, 4
		add	ecx, [esp+24h+var_10]
		mov	[esp+24h+var_14], eax
		mov	[esp+24h+var_C], ecx
		cmp	ebp, [esp+24h+var_4]
		jb	short loc_1000C5D6
		push	20h
		pop	eax
		jmp	loc_10005A3F
; ---------------------------------------------------------------------------

loc_1000C639:				; CODE XREF: sub_10005A0F+6BFCj
		xor	edi, edi
		inc	edi
		jmp	loc_10005A50
; END OF FUNCTION CHUNK	FOR sub_10005A0F
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10005AAE

loc_1000C641:				; CODE XREF: sub_10005AAE+AFj
		mov	edx, esi
		mov	[esi+14h], ebp
		mov	ecx, offset dword_1001AB04
		call	sub_10006386
		mov	edx, esi
		mov	ecx, offset dword_1001AB58
		call	sub_10005D21
		xor	esi, esi
		jmp	loc_10005B63
; ---------------------------------------------------------------------------

loc_1000C663:				; CODE XREF: sub_10005AAE+C0j
		test	esi, esi
		jnz	short loc_1000C692
		push	offset stru_1001AB78 ; lpCriticalSection
		call	ebp ; LeaveCriticalSection
		call	sub_10005DE5
		mov	esi, eax
		test	esi, esi
		jnz	short loc_1000C687
		mov	edx, edi
		mov	ecx, ebx
		call	sub_1000600C
		jmp	loc_10005B08
; ---------------------------------------------------------------------------

loc_1000C687:				; CODE XREF: sub_10005AAE+6BC9j
		push	offset stru_1001AB78 ; lpCriticalSection
		call	ds:EnterCriticalSection

loc_1000C692:				; CODE XREF: sub_10005AAE+6BB7j
		lea	eax, [ebx+edi]
		mov	edx, esi
		mov	[esi+10h], eax
		mov	ecx, offset dword_1001AB04
		mov	eax, [esp+30h+arg_8]
		mov	[esi+14h], eax
		mov	eax, [esp+30h+var_20]
		mov	[esi+18h], eax
		call	sub_10006386
		mov	edx, esi
		mov	ecx, offset dword_1001AB58
		call	sub_10005D21
		xor	esi, esi
		jmp	loc_10005B74
; ---------------------------------------------------------------------------

loc_1000C6C5:				; CODE XREF: sub_10005AAE+F0j
		cmp	dword ptr [eax], 0
		jz	loc_10005BA4
		push	edi		; size_t
		push	0		; int
		push	ebx		; void *
		call	memset
		add	esp, 0Ch
		jmp	loc_10005BA4
; END OF FUNCTION CHUNK	FOR sub_10005AAE
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10005BB9

loc_1000C6DF:				; CODE XREF: sub_10005BB9:loc_10005BE4j
		mov	edi, esi
		jmp	loc_10005BCA
; END OF FUNCTION CHUNK	FOR sub_10005BB9
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10005BF2

loc_1000C6E6:				; CODE XREF: sub_10005BF2+4Bj
		test	eax, eax
		jz	short loc_1000C6F1
		mov	ecx, eax	; lpAddress
		call	sub_10005C56

loc_1000C6F1:				; CODE XREF: sub_10005BF2+6AF6j
		xor	esi, esi
		jmp	loc_10005C43
; END OF FUNCTION CHUNK	FOR sub_10005BF2
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10005C56

loc_1000C6F8:				; CODE XREF: sub_10005C56+10j
		mov	eax, offset byte_1001680D
		push	eax		; void *
		push	eax		; void *
		push	offset aMallocErrorInV ; ": (malloc) Error in VirtualFree()\n"
		push	offset aJemalloc ; "<jemalloc>"
		call	_malloc_message
		add	esp, 10h
		cmp	dword_1001AC98,	0
		jnz	sub_1000EDDD
		retn
; END OF FUNCTION CHUNK	FOR sub_10005C56
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10005D21

loc_1000C720:				; CODE XREF: sub_10005D21+92j
		mov	eax, [ecx+8]
		test	byte ptr [eax+0Ch], 1
		jz	loc_10005DB9
		mov	eax, [ecx+0Ch]
		and	eax, 0FFFFFFFEh
		mov	[esi+8], eax
		mov	eax, [ecx+0Ch]
		and	eax, 1
		or	eax, esi
		mov	[ecx+0Ch], eax
		mov	eax, [ecx+8]
		and	dword ptr [eax+0Ch], 0FFFFFFFEh
		cmp	[edi+8], esi
		jnz	short loc_1000C757
		mov	[edi+8], ecx
		mov	esi, ecx
		jmp	loc_10005DB9
; ---------------------------------------------------------------------------

loc_1000C757:				; CODE XREF: sub_10005D21+6A2Aj
		mov	eax, [edi+0Ch]
		and	eax, 1
		or	eax, ecx
		xor	ecx, ecx
		mov	[edi+0Ch], eax
		mov	esi, eax
		and	esi, 0FFFFFFFEh
		inc	ecx
		and	eax, ecx
		or	eax, [esi+8]
		mov	[edi+0Ch], eax
		mov	eax, [esi+0Ch]
		mov	[esi+8], edi
		xor	eax, [edi+0Ch]
		and	eax, ecx
		xor	[esi+0Ch], eax
		or	[edi+0Ch], ecx
		cmp	[ebx+8], edi
		jnz	short loc_1000C790
		mov	[ebx+8], esi
		jmp	loc_10005DBB
; ---------------------------------------------------------------------------

loc_1000C790:				; CODE XREF: sub_10005D21+6A65j
		mov	eax, [ebx+0Ch]
		and	eax, ecx
		or	eax, esi
		mov	[ebx+0Ch], eax
		jmp	loc_10005DBB
; ---------------------------------------------------------------------------

loc_1000C79F:				; CODE XREF: sub_10005D21+6Cj
		mov	edx, [ebx+0Ch]
		mov	eax, edx
		and	eax, 0FFFFFFFEh
		cmp	eax, edi
		jnz	loc_10005D96
		and	edx, esi
		or	edx, ecx
		mov	[ebx+0Ch], edx
		jmp	loc_10005D96
; END OF FUNCTION CHUNK	FOR sub_10005D21
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10005E64

loc_1000C7BB:				; CODE XREF: sub_10005E64+78j
		mov	eax, [ecx+8]
		test	[eax+0Ch], bl
		jnz	loc_10005EE2
		or	[ecx+0Ch], ebx
		mov	eax, [esi+0Ch]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		mov	edx, [ecx+8]
		test	[edx+0Ch], bl
		jz	short loc_1000C83A
		mov	eax, [edx+0Ch]
		and	eax, 0FFFFFFFEh
		mov	[ecx+8], eax
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+0Ch], eax
		mov	eax, [esi+0Ch]
		and	eax, ebx
		or	eax, edx
		mov	edx, eax
		mov	[esi+0Ch], eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx+8]
		mov	[esi+0Ch], eax
		mov	[edx+8], esi
		mov	eax, [esi+0Ch]
		and	eax, 0FFFFFFFEh
		mov	ecx, [eax+0Ch]
		test	bl, cl
		jz	short loc_1000C835
		and	ecx, 0FFFFFFFEh
		mov	[eax+0Ch], ecx
		or	[esi+0Ch], ebx
		mov	eax, [esi+0Ch]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx+8]
		mov	[esi+0Ch], eax
		mov	[ecx+8], esi
		mov	[edx+8], ecx
		jmp	short loc_1000C84F
; ---------------------------------------------------------------------------

loc_1000C835:				; CODE XREF: sub_10005E64+69AEj
		mov	[esi+0Ch], eax
		jmp	short loc_1000C84F
; ---------------------------------------------------------------------------

loc_1000C83A:				; CODE XREF: sub_10005E64+6974j
		or	eax, ebx
		mov	edx, eax
		mov	[esi+0Ch], eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx+8]
		mov	[esi+0Ch], eax
		mov	[edx+8], esi

loc_1000C84F:				; CODE XREF: sub_10005E64+69CFj
					; sub_10005E64+69D4j
		and	dword ptr [edx+0Ch], 0FFFFFFFEh
		mov	[esp+44h+var_14], edx
		jmp	loc_1000C9A6
; ---------------------------------------------------------------------------

loc_1000C85C:				; CODE XREF: sub_10005E64+4Dj
		lea	eax, [esp+44h+var_1C]
		mov	[esp+44h+var_2C], ebx
		mov	[esp+44h+var_34], eax
		mov	eax, ebx

loc_1000C86A:				; CODE XREF: sub_10005E64+3Fj
		cmp	eax, ebx
		jnz	loc_10005EE6
		mov	ecx, [esi+0Ch]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		mov	[esp+44h+var_30], ecx
		mov	eax, [edx+8]
		test	[eax+0Ch], bl
		jnz	loc_1000C9A4
		mov	edx, [esi+8]
		mov	[esp+44h+var_24], edx
		test	[edx+0Ch], bl
		jz	loc_1000C955
		mov	ecx, [edx+0Ch]
		test	bl, cl
		jz	loc_1000C92A
		and	ecx, 0FFFFFFFEh
		mov	eax, [ecx+8]
		mov	[esp+44h+var_2C], eax
		test	[eax+0Ch], bl
		jz	short loc_1000C8E4
		mov	eax, [ecx+0Ch]
		xor	eax, [esp+44h+var_30]
		and	eax, ebx
		xor	[ecx+0Ch], eax
		mov	eax, [esp+44h+var_2C]
		mov	ecx, [esp+44h+var_24]
		and	dword ptr [eax+0Ch], 0FFFFFFFEh
		mov	eax, [edx+0Ch]
		mov	edx, eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx+8]
		mov	[ecx+0Ch], eax
		mov	[edx+8], ecx
		mov	[esi+8], edx
		jmp	short loc_1000C8F5
; ---------------------------------------------------------------------------

loc_1000C8E4:				; CODE XREF: sub_10005E64+6A4Ej
		mov	eax, [esp+44h+var_30]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+0Ch], eax
		or	[ecx+0Ch], ebx
		mov	edx, [esi+8]

loc_1000C8F5:				; CODE XREF: sub_10005E64+6A7Ej
		mov	eax, [edx+0Ch]
		and	eax, 0FFFFFFFEh
		mov	[esi+8], eax
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, esi
		mov	[edx+0Ch], eax
		mov	eax, [esi+0Ch]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx+8]
		mov	[esi+0Ch], eax
		mov	[ecx+8], esi
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+0Ch], eax
		or	[esi+0Ch], ebx
		jmp	short loc_1000C94C
; ---------------------------------------------------------------------------

loc_1000C92A:				; CODE XREF: sub_10005E64+6A3Bj
		or	ecx, ebx
		mov	[edx+0Ch], ecx
		mov	ecx, [edx+8]
		mov	eax, [ecx+0Ch]
		test	bl, al
		jnz	short loc_1000C969

loc_1000C939:				; CODE XREF: sub_10005E64+6B03j
		mov	eax, [esi+0Ch]
		mov	edx, eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx+8]
		mov	[esi+0Ch], eax
		mov	[edx+8], esi

loc_1000C94C:				; CODE XREF: sub_10005E64+6AC4j
					; sub_10005E64+6B3Ej
		mov	[esp+44h+var_14], edx
		jmp	loc_1000CB70
; ---------------------------------------------------------------------------

loc_1000C955:				; CODE XREF: sub_10005E64+6A30j
		or	ecx, ebx
		mov	[esi+0Ch], ecx
		mov	ecx, [edx+8]
		mov	eax, [ecx+0Ch]
		test	bl, al
		jnz	short loc_1000C969
		or	[edx+0Ch], ebx
		jmp	short loc_1000C939
; ---------------------------------------------------------------------------

loc_1000C969:				; CODE XREF: sub_10005E64+6AD3j
					; sub_10005E64+6AFEj
		and	eax, 0FFFFFFFEh
		mov	[ecx+0Ch], eax
		mov	edx, [esi+8]
		mov	eax, [edx+0Ch]
		and	eax, 0FFFFFFFEh
		mov	[esi+8], eax
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, esi
		mov	[edx+0Ch], eax
		mov	eax, [esi+0Ch]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx+8]
		mov	[esi+0Ch], eax
		mov	[ecx+8], esi
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+0Ch], eax
		jmp	short loc_1000C94C
; ---------------------------------------------------------------------------

loc_1000C9A4:				; CODE XREF: sub_10005E64+6A20j
		mov	edi, esi

loc_1000C9A6:				; CODE XREF: sub_10005E64+69F3j
		mov	esi, edx
		jmp	loc_10005EE6
; ---------------------------------------------------------------------------

loc_1000C9AD:				; CODE XREF: sub_10005E64+97j
		mov	ecx, [esi+8]
		cmp	ecx, ebp
		jz	loc_1000CB80
		test	[ecx+0Ch], bl
		jnz	loc_1000CB77
		mov	eax, [ecx+8]
		test	[eax+0Ch], bl
		jnz	loc_1000CB77
		or	[ecx+0Ch], ebx
		mov	eax, [esi+0Ch]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		mov	edx, [ecx+8]
		test	[edx+0Ch], bl
		jz	short loc_1000CA46
		mov	eax, [edx+0Ch]
		and	eax, 0FFFFFFFEh
		mov	[ecx+8], eax
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+0Ch], eax
		mov	eax, [esi+0Ch]
		and	eax, ebx
		or	eax, edx
		mov	edx, eax
		mov	[esi+0Ch], eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx+8]
		mov	[esi+0Ch], eax
		mov	[edx+8], esi
		mov	eax, [esi+0Ch]
		and	eax, 0FFFFFFFEh
		mov	ecx, [eax+0Ch]
		test	bl, cl
		jz	short loc_1000CA3E
		and	ecx, 0FFFFFFFEh
		mov	[eax+0Ch], ecx
		or	[esi+0Ch], ebx
		mov	eax, [esi+0Ch]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx+8]
		mov	[esi+0Ch], eax
		mov	[ecx+8], esi
		mov	[edx+8], ecx
		jmp	loc_1000CB5C
; ---------------------------------------------------------------------------

loc_1000CA3E:				; CODE XREF: sub_10005E64+6BB4j
		mov	[esi+0Ch], eax
		jmp	loc_1000CB5C
; ---------------------------------------------------------------------------

loc_1000CA46:				; CODE XREF: sub_10005E64+6B7Aj
		or	eax, ebx
		mov	[esi+0Ch], eax
		jmp	loc_1000CB4C
; ---------------------------------------------------------------------------

loc_1000CA50:				; CODE XREF: sub_10005E64+9Dj
					; sub_10005E64+FCj
		mov	eax, [esi+0Ch]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		mov	[esp+44h+var_2C], eax
		mov	eax, [ecx+8]
		test	[eax+0Ch], bl
		jnz	loc_1000CB77
		mov	edx, [esi+8]
		mov	[esp+44h+var_30], edx
		mov	ecx, [edx+0Ch]
		test	bl, cl
		jz	loc_1000CAFF
		and	ecx, 0FFFFFFFEh
		mov	eax, [ecx+8]
		mov	[esp+44h+var_24], eax
		test	[eax+0Ch], bl
		jz	short loc_1000CAB9
		mov	eax, [ecx+0Ch]
		xor	eax, [esp+44h+var_2C]
		and	eax, ebx
		xor	[ecx+0Ch], eax
		mov	eax, [esp+44h+var_24]
		mov	ecx, [esp+44h+var_30]
		and	dword ptr [eax+0Ch], 0FFFFFFFEh
		mov	eax, [edx+0Ch]
		mov	edx, eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx+8]
		mov	[ecx+0Ch], eax
		mov	[edx+8], ecx
		mov	[esi+8], edx
		jmp	short loc_1000CACA
; ---------------------------------------------------------------------------

loc_1000CAB9:				; CODE XREF: sub_10005E64+6C23j
		mov	eax, [esp+44h+var_2C]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+0Ch], eax
		or	[ecx+0Ch], ebx
		mov	edx, [esi+8]

loc_1000CACA:				; CODE XREF: sub_10005E64+6C53j
		mov	eax, [edx+0Ch]
		and	eax, 0FFFFFFFEh
		mov	[esi+8], eax
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, esi
		mov	[edx+0Ch], eax
		mov	eax, [esi+0Ch]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx+8]
		mov	[esi+0Ch], eax
		mov	[ecx+8], esi
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+0Ch], eax
		or	[esi+0Ch], ebx
		jmp	short loc_1000CB5C
; ---------------------------------------------------------------------------

loc_1000CAFF:				; CODE XREF: sub_10005E64+6C10j
		or	ecx, ebx
		mov	[edx+0Ch], ecx
		mov	ecx, [edx+8]
		mov	eax, [ecx+0Ch]
		test	bl, al
		jz	short loc_1000CB49
		and	eax, 0FFFFFFFEh
		mov	[ecx+0Ch], eax
		mov	edx, [esi+8]
		mov	eax, [edx+0Ch]
		and	eax, 0FFFFFFFEh
		mov	[esi+8], eax
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, esi
		mov	[edx+0Ch], eax
		mov	eax, [esi+0Ch]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx+8]
		mov	[esi+0Ch], eax
		mov	[ecx+8], esi
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+0Ch], eax
		jmp	short loc_1000CB5C
; ---------------------------------------------------------------------------

loc_1000CB49:				; CODE XREF: sub_10005E64+6CA8j
		mov	eax, [esi+0Ch]

loc_1000CB4C:				; CODE XREF: sub_10005E64+6BE7j
		mov	edx, eax
		and	eax, ebx
		and	edx, 0FFFFFFFEh
		or	eax, [edx+8]
		mov	[esi+0Ch], eax
		mov	[edx+8], esi

loc_1000CB5C:				; CODE XREF: sub_10005E64+6BD5j
					; sub_10005E64+6BDDj ...
		cmp	[edi+8], esi
		jnz	short loc_1000CB66
		mov	[edi+8], edx
		jmp	short loc_1000CB70
; ---------------------------------------------------------------------------

loc_1000CB66:				; CODE XREF: sub_10005E64+6CFBj
		mov	eax, [edi+0Ch]
		and	eax, ebx
		or	eax, edx
		mov	[edi+0Ch], eax

loc_1000CB70:				; CODE XREF: sub_10005E64+6AECj
					; sub_10005E64+6D00j
		mov	esi, edx
		jmp	loc_10005EED
; ---------------------------------------------------------------------------

loc_1000CB77:				; CODE XREF: sub_10005E64+6B57j
					; sub_10005E64+6B63j ...
		mov	edi, esi
		mov	esi, ecx
		jmp	loc_10005EED
; ---------------------------------------------------------------------------

loc_1000CB80:				; CODE XREF: sub_10005E64+6B4Ej
		mov	ecx, [esp+44h+var_34]
		mov	edx, [esp+44h+var_28]
		cmp	[ecx+8], edx
		jnz	short loc_1000CB92
		mov	[ecx+8], esi
		jmp	short loc_1000CB9C
; ---------------------------------------------------------------------------

loc_1000CB92:				; CODE XREF: sub_10005E64+6D27j
		mov	eax, [ecx+0Ch]
		and	eax, ebx
		or	eax, esi
		mov	[ecx+0Ch], eax

loc_1000CB9C:				; CODE XREF: sub_10005E64+6D2Cj
		mov	eax, [edx+8]
		mov	[esi+8], eax
		mov	ecx, [edx+0Ch]
		xor	ecx, [esi+0Ch]
		and	ecx, ebx
		xor	ecx, [edx+0Ch]
		mov	[esi+0Ch], ecx
		mov	eax, [edx+0Ch]
		xor	eax, ecx
		and	eax, ebx
		xor	eax, ecx
		mov	[esi+0Ch], eax
		cmp	[edi+8], esi
		jnz	short loc_1000CBC9
		mov	[edi+8], ebp
		jmp	loc_10005EC4
; ---------------------------------------------------------------------------

loc_1000CBC9:				; CODE XREF: sub_10005E64+6D5Bj
		mov	eax, [edi+0Ch]
		and	eax, ebx
		or	eax, ebp

loc_1000CBD0:				; CODE XREF: sub_10005E64+108j
		mov	[edi+0Ch], eax
		jmp	loc_10005EC4
; ---------------------------------------------------------------------------

loc_1000CBD8:				; CODE XREF: sub_10005E64+B2j
		mov	eax, [edx+0Ch]
		and	eax, 0FFFFFFFEh
		mov	[esi+8], eax
		mov	ecx, [edx+0Ch]
		and	ecx, ebx
		or	ecx, esi
		mov	[edx+0Ch], ecx
		mov	eax, [esi+0Ch]
		xor	eax, ecx
		and	eax, ebx
		xor	eax, ecx
		mov	[edx+0Ch], eax
		or	[esi+0Ch], ebx
		mov	eax, [edx+0Ch]
		and	eax, ebx
		or	eax, ebp
		mov	[edx+0Ch], eax
		jmp	loc_10005F1E
; END OF FUNCTION CHUNK	FOR sub_10005E64
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100061C4

loc_1000CC09:				; CODE XREF: sub_100061C4+6A54j
		mov	esi, ecx
		and	esi, 0FFFFFFFEh

loc_1000CC0E:				; CODE XREF: sub_100061C4+Dj
		mov	ecx, [esi+0Ch]
		mov	eax, ecx
		and	eax, 0FFFFFFFEh
		cmp	eax, ebx
		jnz	short loc_1000CC09
		jmp	loc_100061EC
; END OF FUNCTION CHUNK	FOR sub_100061C4
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10006209

loc_1000CC1F:				; CODE XREF: sub_10006209+3Dj
		mov	ecx, [esi]
		test	[ecx+4], bl
		jnz	loc_1000CCC1
		mov	eax, [ecx]
		test	[eax+4], bl
		jnz	loc_1000CCC1
		or	[ecx+4], ebx
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		mov	edx, [ecx]
		test	[edx+4], bl
		jz	short loc_1000CCA1
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[ecx], eax
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+4], eax
		mov	eax, [esi+4]
		and	eax, ebx
		or	eax, edx
		mov	edx, eax
		mov	[esi+4], eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx]
		mov	[esi+4], eax
		mov	[edx], esi
		mov	eax, [esi+4]
		and	eax, 0FFFFFFFEh
		mov	ecx, [eax+4]
		test	bl, cl
		jz	short loc_1000CC9C
		and	ecx, 0FFFFFFFEh
		mov	[eax+4], ecx
		or	[esi+4], ebx
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	[edx], ecx
		jmp	short loc_1000CCB4
; ---------------------------------------------------------------------------

loc_1000CC9C:				; CODE XREF: sub_10006209+6A73j
		mov	[esi+4], eax
		jmp	short loc_1000CCB4
; ---------------------------------------------------------------------------

loc_1000CCA1:				; CODE XREF: sub_10006209+6A3Cj
		or	eax, ebx
		mov	edx, eax
		mov	[esi+4], eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx]
		mov	[esi+4], eax
		mov	[edx], esi

loc_1000CCB4:				; CODE XREF: sub_10006209+6A91j
					; sub_10006209+6A96j
		and	dword ptr [edx+4], 0FFFFFFFEh
		mov	[esp+44h+var_1C], edx
		jmp	loc_1000CE2E
; ---------------------------------------------------------------------------

loc_1000CCC1:				; CODE XREF: sub_10006209+6A1Bj
					; sub_10006209+6A26j
		mov	edi, esi
		mov	esi, ecx
		jmp	loc_1000CE30
; ---------------------------------------------------------------------------

loc_1000CCCA:				; CODE XREF: sub_10006209+5Bj
		mov	eax, [edx+4]
		xor	ebx, ebx
		and	eax, 0FFFFFFFEh
		inc	ebx
		mov	[esi], eax
		mov	ecx, [edx+4]
		and	ecx, ebx
		or	ecx, esi
		mov	[edx+4], ecx
		mov	eax, [esi+4]
		xor	eax, ecx
		and	eax, ebx
		xor	eax, ecx
		mov	[edx+4], eax
		or	[esi+4], ebx
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, ebp
		mov	[edx+4], eax
		jmp	loc_1000626C
; ---------------------------------------------------------------------------

loc_1000CCFD:				; CODE XREF: sub_10006209+51j
		lea	eax, [esp+44h+var_1C]
		mov	[esp+44h+var_2C], ebx
		mov	[esp+44h+var_34], eax
		mov	eax, ebx

loc_1000CD0B:				; CODE XREF: sub_10006209+43j
		cmp	eax, ebx
		jnz	loc_1000CE30
		mov	ecx, [esi+4]
		mov	edx, ecx
		and	edx, 0FFFFFFFEh
		mov	[esp+44h+var_30], ecx
		mov	eax, [edx]
		test	[eax+4], bl
		jnz	loc_1000CE2C
		mov	edx, [esi]
		mov	[esp+44h+var_24], edx
		test	[edx+4], bl
		jz	loc_1000CDE2
		mov	ecx, [edx+4]
		test	bl, cl
		jz	short loc_1000CDBD
		and	ecx, 0FFFFFFFEh
		mov	eax, [ecx]
		mov	[esp+44h+var_2C], eax
		test	[eax+4], bl
		jz	short loc_1000CD7B
		mov	eax, [ecx+4]
		xor	eax, [esp+44h+var_30]
		and	eax, ebx
		xor	[ecx+4], eax
		mov	eax, [esp+44h+var_2C]
		mov	ecx, [esp+44h+var_24]
		and	dword ptr [eax+4], 0FFFFFFFEh
		mov	eax, [edx+4]
		mov	edx, eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx]
		mov	[ecx+4], eax
		mov	[edx], ecx
		mov	[esi], edx
		jmp	short loc_1000CD8B
; ---------------------------------------------------------------------------

loc_1000CD7B:				; CODE XREF: sub_10006209+6B43j
		mov	eax, [esp+44h+var_30]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+4], eax
		or	[ecx+4], ebx
		mov	edx, [esi]

loc_1000CD8B:				; CODE XREF: sub_10006209+6B70j
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[esi], eax
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, esi
		mov	[edx+4], eax
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+4], eax
		or	[esi+4], ebx
		jmp	short loc_1000CDDC
; ---------------------------------------------------------------------------

loc_1000CDBD:				; CODE XREF: sub_10006209+6B35j
		or	ecx, ebx
		mov	[edx+4], ecx
		mov	ecx, [edx]
		mov	eax, [ecx+4]
		test	bl, al
		jnz	short loc_1000CDF5

loc_1000CDCB:				; CODE XREF: sub_10006209+6BEAj
		mov	eax, [esi+4]
		mov	edx, eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx]
		mov	[esi+4], eax
		mov	[edx], esi

loc_1000CDDC:				; CODE XREF: sub_10006209+6BB2j
					; sub_10006209+6C21j
		mov	[esp+44h+var_1C], edx
		jmp	short loc_1000CE47
; ---------------------------------------------------------------------------

loc_1000CDE2:				; CODE XREF: sub_10006209+6B2Aj
		or	ecx, ebx
		mov	[esi+4], ecx
		mov	ecx, [edx]
		mov	eax, [ecx+4]
		test	bl, al
		jnz	short loc_1000CDF5
		or	[edx+4], ebx
		jmp	short loc_1000CDCB
; ---------------------------------------------------------------------------

loc_1000CDF5:				; CODE XREF: sub_10006209+6BC0j
					; sub_10006209+6BE5j
		and	eax, 0FFFFFFFEh
		mov	[ecx+4], eax
		mov	edx, [esi]
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[esi], eax
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, esi
		mov	[edx+4], eax
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+4], eax
		jmp	short loc_1000CDDC
; ---------------------------------------------------------------------------

loc_1000CE2C:				; CODE XREF: sub_10006209+6B1Bj
		mov	edi, esi

loc_1000CE2E:				; CODE XREF: sub_10006209+6AB3j
		mov	esi, edx

loc_1000CE30:				; CODE XREF: sub_10006209+6ABCj
					; sub_10006209+6B04j
		cmp	[esp+44h+var_2C], 0
		jz	loc_10006270
		jmp	short loc_1000CE49
; ---------------------------------------------------------------------------

loc_1000CE3D:				; CODE XREF: sub_10006209+6DFBj
		mov	eax, [edi+4]
		and	eax, ebx
		or	eax, edx
		mov	[edi+4], eax

loc_1000CE47:				; CODE XREF: sub_10006209+6BD7j
					; sub_10006209+6E03j
		mov	esi, edx

loc_1000CE49:				; CODE XREF: sub_10006209+6C32j
					; sub_10006209+6E0Cj
		push	esi
		push	[esp+48h+var_28]
		call	sub_10006282
		pop	ecx
		pop	ecx
		test	eax, eax
		jns	loc_1000CEF7
		mov	ecx, [esi]
		cmp	ecx, ebp
		jz	loc_1000D01A
		test	[ecx+4], bl
		jnz	loc_1000D011
		mov	eax, [ecx]
		test	[eax+4], bl
		jnz	loc_1000D011
		or	[ecx+4], ebx
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		mov	edx, [ecx]
		test	[edx+4], bl
		jz	short loc_1000CEED
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[ecx], eax
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+4], eax
		mov	eax, [esi+4]
		and	eax, ebx
		or	eax, edx
		mov	edx, eax
		mov	[esi+4], eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx]
		mov	[esi+4], eax
		mov	[edx], esi
		mov	eax, [esi+4]
		and	eax, 0FFFFFFFEh
		mov	ecx, [eax+4]
		test	bl, cl
		jz	short loc_1000CEE5
		and	ecx, 0FFFFFFFEh
		mov	[eax+4], ecx
		or	[esi+4], ebx
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	[edx], ecx
		jmp	loc_1000D002
; ---------------------------------------------------------------------------

loc_1000CEE5:				; CODE XREF: sub_10006209+6CB9j
		mov	[esi+4], eax
		jmp	loc_1000D002
; ---------------------------------------------------------------------------

loc_1000CEED:				; CODE XREF: sub_10006209+6C82j
		or	eax, ebx
		mov	[esi+4], eax
		jmp	loc_1000CFF4
; ---------------------------------------------------------------------------

loc_1000CEF7:				; CODE XREF: sub_10006209+6C4Ej
		jnz	short loc_1000CF0B
		mov	eax, [esi+4]
		and	eax, 0FFFFFFFEh
		cmp	eax, ebp
		jz	loc_1000D066
		mov	[esp+44h+var_34], edi

loc_1000CF0B:				; CODE XREF: sub_10006209:loc_1000CEF7j
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		mov	[esp+44h+var_2C], eax
		mov	eax, [ecx]
		test	[eax+4], bl
		jnz	loc_1000D011
		mov	edx, [esi]
		mov	[esp+44h+var_30], edx
		mov	ecx, [edx+4]
		test	bl, cl
		jz	short loc_1000CFAC
		and	ecx, 0FFFFFFFEh
		mov	eax, [ecx]
		mov	[esp+44h+var_24], eax
		test	[eax+4], bl
		jz	short loc_1000CF6A
		mov	eax, [ecx+4]
		xor	eax, [esp+44h+var_2C]
		and	eax, ebx
		xor	[ecx+4], eax
		mov	eax, [esp+44h+var_24]
		mov	ecx, [esp+44h+var_30]
		and	dword ptr [eax+4], 0FFFFFFFEh
		mov	eax, [edx+4]
		mov	edx, eax
		and	edx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [edx]
		mov	[ecx+4], eax
		mov	[edx], ecx
		mov	[esi], edx
		jmp	short loc_1000CF7A
; ---------------------------------------------------------------------------

loc_1000CF6A:				; CODE XREF: sub_10006209+6D32j
		mov	eax, [esp+44h+var_2C]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+4], eax
		or	[ecx+4], ebx
		mov	edx, [esi]

loc_1000CF7A:				; CODE XREF: sub_10006209+6D5Fj
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[esi], eax
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, esi
		mov	[edx+4], eax
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+4], eax
		or	[esi+4], ebx
		jmp	short loc_1000D002
; ---------------------------------------------------------------------------

loc_1000CFAC:				; CODE XREF: sub_10006209+6D24j
		or	ecx, ebx
		mov	[edx+4], ecx
		mov	ecx, [edx]
		mov	eax, [ecx+4]
		test	bl, al
		jz	short loc_1000CFF1
		and	eax, 0FFFFFFFEh
		mov	[ecx+4], eax
		mov	edx, [esi]
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[esi], eax
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, esi
		mov	[edx+4], eax
		mov	eax, [esi+4]
		mov	ecx, eax
		and	ecx, 0FFFFFFFEh
		and	eax, ebx
		or	eax, [ecx]
		mov	[esi+4], eax
		mov	[ecx], esi
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, ecx
		mov	[edx+4], eax
		jmp	short loc_1000D002
; ---------------------------------------------------------------------------

loc_1000CFF1:				; CODE XREF: sub_10006209+6DAFj
		mov	eax, [esi+4]

loc_1000CFF4:				; CODE XREF: sub_10006209+6CE9j
		mov	edx, eax
		and	eax, ebx
		and	edx, 0FFFFFFFEh
		or	eax, [edx]
		mov	[esi+4], eax
		mov	[edx], esi

loc_1000D002:				; CODE XREF: sub_10006209+6CD7j
					; sub_10006209+6CDFj ...
		cmp	[edi], esi
		jnz	loc_1000CE3D
		mov	[edi], edx
		jmp	loc_1000CE47
; ---------------------------------------------------------------------------

loc_1000D011:				; CODE XREF: sub_10006209+6C61j
					; sub_10006209+6C6Cj ...
		mov	edi, esi
		mov	esi, ecx
		jmp	loc_1000CE49
; ---------------------------------------------------------------------------

loc_1000D01A:				; CODE XREF: sub_10006209+6C58j
		mov	ecx, [esp+44h+var_34]
		mov	edx, [esp+44h+var_28]
		cmp	[ecx], edx
		jnz	short loc_1000D02A
		mov	[ecx], esi
		jmp	short loc_1000D034
; ---------------------------------------------------------------------------

loc_1000D02A:				; CODE XREF: sub_10006209+6E1Bj
		mov	eax, [ecx+4]
		and	eax, ebx
		or	eax, esi
		mov	[ecx+4], eax

loc_1000D034:				; CODE XREF: sub_10006209+6E1Fj
		mov	eax, [edx]
		mov	ecx, [esi+4]
		mov	[esi], eax
		xor	ecx, [edx+4]
		and	ecx, ebx
		xor	ecx, [edx+4]
		mov	[esi+4], ecx
		mov	eax, [edx+4]
		xor	eax, ecx
		and	eax, ebx
		xor	eax, ecx
		mov	[esi+4], eax
		cmp	[edi], esi
		jnz	short loc_1000D05D
		mov	[edi], ebp
		jmp	loc_10006270
; ---------------------------------------------------------------------------

loc_1000D05D:				; CODE XREF: sub_10006209+6E4Bj
		mov	eax, [edi+4]
		and	eax, ebx
		or	eax, ebp
		jmp	short loc_1000D0AD
; ---------------------------------------------------------------------------

loc_1000D066:				; CODE XREF: sub_10006209+6CF8j
		mov	edx, [esi]
		cmp	edx, ebp
		jz	short loc_1000D099
		mov	eax, [edx+4]
		and	eax, 0FFFFFFFEh
		mov	[esi], eax
		mov	ecx, [edx+4]
		and	ecx, ebx
		or	ecx, esi
		mov	[edx+4], ecx
		mov	eax, [esi+4]
		xor	eax, ecx
		and	eax, ebx
		xor	eax, ecx
		mov	[edx+4], eax
		or	[esi+4], ebx
		mov	eax, [edx+4]
		and	eax, ebx
		or	eax, ebp
		mov	[edx+4], eax
		jmp	short loc_1000D09B
; ---------------------------------------------------------------------------

loc_1000D099:				; CODE XREF: sub_10006209+6E61j
		mov	edx, ebp

loc_1000D09B:				; CODE XREF: sub_10006209+6E8Ej
		cmp	[edi], esi
		jnz	short loc_1000D0A6
		mov	[edi], edx
		jmp	loc_10006270
; ---------------------------------------------------------------------------

loc_1000D0A6:				; CODE XREF: sub_10006209+6E94j
		mov	eax, [edi+4]
		and	eax, ebx
		or	eax, edx

loc_1000D0AD:				; CODE XREF: sub_10006209+6E5Bj
		mov	[edi+4], eax
		jmp	loc_10006270
; END OF FUNCTION CHUNK	FOR sub_10006209
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100062B7

loc_1000D0B5:				; CODE XREF: sub_100062B7+45j
					; sub_100062B7+6E24j
		lea	eax, [esp+2Ch+var_1C]
		push	edi
		push	eax
		call	sub_10005F71
		pop	ecx
		pop	ecx
		test	eax, eax
		jns	short loc_1000D0CD
		mov	esi, edi
		mov	edi, [edi+8]
		jmp	short loc_1000D0D5
; ---------------------------------------------------------------------------

loc_1000D0CD:				; CODE XREF: sub_100062B7+6E0Dj
		jle	short loc_1000D0DF
		mov	edi, [edi+0Ch]
		and	edi, 0FFFFFFFEh

loc_1000D0D5:				; CODE XREF: sub_100062B7+6E14j
		cmp	edi, offset dword_1001AB5C
		jnz	short loc_1000D0B5
		jmp	short loc_1000D0E1
; ---------------------------------------------------------------------------

loc_1000D0DF:				; CODE XREF: sub_100062B7:loc_1000D0CDj
		mov	esi, edi

loc_1000D0E1:				; CODE XREF: sub_100062B7+6E26j
		mov	edx, [esp+2Ch+var_C]
		mov	ecx, [esp+2Ch+lpAddress]
		mov	eax, [esp+2Ch+arg_4]
		jmp	loc_10006302
; ---------------------------------------------------------------------------

loc_1000D0F2:				; CODE XREF: sub_100062B7+4Dj
		cmp	[esi+10h], edx
		jnz	loc_1000630A
		mov	edi, offset dword_1001AB04
		mov	edx, esi
		mov	ecx, edi
		call	sub_10006209
		mov	eax, [esp+2Ch+lpAddress]
		mov	ecx, edi
		mov	[esi+10h], eax
		mov	eax, [esp+2Ch+arg_4]
		add	[esi+14h], eax
		xor	eax, eax
		cmp	[esi+18h], ebx
		setnz	al
		mov	[esi+18h], eax
		jmp	loc_10006330
; ---------------------------------------------------------------------------

loc_1000D129:				; CODE XREF: sub_100062B7+90j
		mov	ecx, [edi+14h]
		add	ecx, [edi+10h]
		cmp	ecx, [esp+2Ch+lpAddress]
		jnz	loc_1000634D
		mov	edx, edi
		mov	ecx, offset dword_1001AB04
		call	sub_10006209
		mov	edx, edi
		mov	ecx, offset dword_1001AB58
		call	sub_10005E64
		mov	edx, esi
		mov	ecx, offset dword_1001AB04
		call	sub_10006209
		mov	eax, [edi+10h]
		mov	[esi+10h], eax
		mov	eax, [edi+14h]
		add	[esi+14h], eax
		cmp	[esi+18h], ebx
		jz	short loc_1000D176
		cmp	[edi+18h], ebx
		jz	short loc_1000D176
		xor	ebx, ebx
		inc	ebx

loc_1000D176:				; CODE XREF: sub_100062B7+6EB5j
					; sub_100062B7+6EBAj
		mov	edx, esi
		mov	[esi+18h], ebx
		mov	ecx, offset dword_1001AB04
		call	sub_10006386
		mov	ebx, edi
		jmp	loc_1000634D
; END OF FUNCTION CHUNK	FOR sub_100062B7
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10006386

loc_1000D18C:				; CODE XREF: sub_10006386+2Fj
		mov	ecx, [esi]
		test	byte ptr [ecx+4], 1
		jz	short loc_1000D1BD
		mov	eax, [ecx]
		test	byte ptr [eax+4], 1
		jz	short loc_1000D1BD
		mov	eax, [ecx+4]
		and	eax, 0FFFFFFFEh
		mov	[esi], eax
		mov	eax, [ecx+4]
		and	eax, 1
		or	eax, esi
		mov	[ecx+4], eax
		mov	eax, [ecx]
		and	dword ptr [eax+4], 0FFFFFFFEh
		cmp	[edi], esi
		jnz	short loc_1000D1D4
		mov	[edi], ecx
		mov	esi, ecx

loc_1000D1BD:				; CODE XREF: sub_10006386+6E0Cj
					; sub_10006386+6E14j
		mov	ebx, edi

loc_1000D1BF:				; CODE XREF: sub_10006386+6E7Ej
					; sub_10006386+6E8Aj
		push	esi
		push	edx
		mov	edi, esi
		call	sub_10006282
		pop	ecx
		pop	ecx
		mov	ecx, eax
		test	ecx, ecx
		jns	short loc_1000D212
		mov	esi, [esi]
		jmp	short loc_1000D218
; ---------------------------------------------------------------------------

loc_1000D1D4:				; CODE XREF: sub_10006386+6E31j
		mov	eax, [edi+4]
		and	eax, 1
		or	eax, ecx
		xor	ecx, ecx
		mov	[edi+4], eax
		mov	esi, eax
		and	esi, 0FFFFFFFEh
		inc	ecx
		and	eax, ecx
		or	eax, [esi]
		mov	[edi+4], eax
		mov	eax, [esi+4]
		mov	[esi], edi
		xor	eax, [edi+4]
		and	eax, ecx
		xor	[esi+4], eax
		or	[edi+4], ecx
		cmp	[ebx], edi
		jnz	short loc_1000D206
		mov	[ebx], esi
		jmp	short loc_1000D1BF
; ---------------------------------------------------------------------------

loc_1000D206:				; CODE XREF: sub_10006386+6E7Aj
		mov	eax, [ebx+4]
		and	eax, ecx
		or	eax, esi
		mov	[ebx+4], eax
		jmp	short loc_1000D1BF
; ---------------------------------------------------------------------------

loc_1000D212:				; CODE XREF: sub_10006386+6E48j
		mov	esi, [esi+4]
		and	esi, 0FFFFFFFEh

loc_1000D218:				; CODE XREF: sub_10006386+6E4Cj
		mov	edx, [esp+34h+var_24]
		jmp	loc_100063B3
; ---------------------------------------------------------------------------

loc_1000D221:				; CODE XREF: sub_10006386+41j
		mov	ecx, [edi+4]
		and	ecx, esi
		or	ecx, edx
		mov	[edi+4], ecx
		and	ecx, 0FFFFFFFEh
		mov	eax, [edi+4]
		and	eax, esi
		or	eax, [ecx]
		mov	[edi+4], eax
		mov	eax, [ecx+4]
		mov	[ecx], edi
		xor	eax, [edi+4]
		and	eax, esi
		xor	[ecx+4], eax
		or	[edi+4], esi
		cmp	[ebx], edi
		jnz	short loc_1000D253
		mov	[ebx], ecx
		jmp	loc_100063CF
; ---------------------------------------------------------------------------

loc_1000D253:				; CODE XREF: sub_10006386+6EC4j
		mov	edx, [ebx+4]
		mov	eax, edx
		and	eax, 0FFFFFFFEh
		cmp	eax, edi
		jnz	loc_100063CF
		and	edx, esi
		or	edx, ecx
		mov	[ebx+4], edx
		jmp	loc_100063CF
; END OF FUNCTION CHUNK	FOR sub_10006386
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100066AB

loc_1000D26F:				; CODE XREF: sub_100066AB+44j
		mov	eax, offset byte_1001680D
		push	eax		; void *
		push	eax		; void *
		push	offset aCompileTimePag ; "Compile-time page size does not divide "...
		push	offset aJemalloc ; "<jemalloc>"
		call	_malloc_message
		add	esp, 10h
		call	sub_1000EDDD
; ---------------------------------------------------------------------------

loc_1000D28E:				; CODE XREF: sub_100066AB+1EDj
					; sub_100066AB+6BFCj
		mov	dl, [edi+esi]
		lea	eax, [edx-30h]
		cmp	al, 9
		ja	short loc_1000D2A9
		imul	ecx, ebx, 0Ah
		movsx	ebx, dl
		add	ebx, 0FFFFFFD0h
		add	ebx, ecx
		xor	ecx, ecx
		inc	edi
		inc	ecx
		jmp	short loc_1000D28E
; ---------------------------------------------------------------------------

loc_1000D2A9:				; CODE XREF: sub_100066AB+6BEBj
		xor	edx, edx
		inc	edx
		test	ecx, ecx
		jnz	short loc_1000D2B2
		mov	ebx, edx

loc_1000D2B2:				; CODE XREF: sub_100066AB+6C03j
		test	ebx, ebx
		jz	loc_1000D384

loc_1000D2BA:				; CODE XREF: sub_100066AB+6CD3j
		mov	cl, [edi+esi]
		movsx	eax, cl
		cmp	eax, 61h
		jg	short loc_1000D329
		jz	short loc_1000D320
		sub	eax, 41h
		jz	short loc_1000D318
		dec	eax
		jz	loc_1000D37A
		sub	eax, 4
		jz	short loc_1000D2F7
		sub	eax, 8
		jz	short loc_1000D2EC
		dec	eax
		dec	eax
		jnz	short loc_1000D344
		mov	dword_1001AC94,	edx
		jmp	loc_1000D37A
; ---------------------------------------------------------------------------

loc_1000D2EC:				; CODE XREF: sub_100066AB+6C30j
		inc	dword_1001AC88
		jmp	loc_1000D37A
; ---------------------------------------------------------------------------

loc_1000D2F7:				; CODE XREF: sub_100066AB+6C2Bj
		cmp	dword_1001A49C,	0
		jnz	short loc_1000D308
		mov	dword_1001A49C,	edx
		jmp	short loc_1000D37A
; ---------------------------------------------------------------------------

loc_1000D308:				; CODE XREF: sub_100066AB+6C53j
		mov	eax, dword_1001A49C
		add	eax, eax
		jz	short loc_1000D37A
		mov	dword_1001A49C,	eax
		jmp	short loc_1000D37A
; ---------------------------------------------------------------------------

loc_1000D318:				; CODE XREF: sub_100066AB+6C1Fj
		mov	dword_1001AC98,	edx
		jmp	short loc_1000D37A
; ---------------------------------------------------------------------------

loc_1000D320:				; CODE XREF: sub_100066AB+6C1Aj
		and	dword_1001AC98,	0
		jmp	short loc_1000D37A
; ---------------------------------------------------------------------------

loc_1000D329:				; CODE XREF: sub_100066AB+6C18j
		sub	eax, 62h
		jz	short loc_1000D37A
		sub	eax, 4
		jz	short loc_1000D374
		sub	eax, 8
		jz	short loc_1000D36C
		dec	eax
		dec	eax
		jnz	short loc_1000D344
		and	dword_1001AC94,	eax
		jmp	short loc_1000D37A
; ---------------------------------------------------------------------------

loc_1000D344:				; CODE XREF: sub_100066AB+6C34j
					; sub_100066AB+6C8Fj
		push	offset asc_1001741C ; "'\n"
		lea	eax, [esp+148h+var_134]
		mov	[esp+148h+var_134], cl
		push	eax		; void *
		push	offset aMallocUnsuppor ; ": (malloc) Unsupported character in mal"...
		push	offset aJemalloc ; "<jemalloc>"
		mov	[esp+154h+var_133], 0
		call	_malloc_message
		add	esp, 10h
		jmp	short loc_1000D37A
; ---------------------------------------------------------------------------

loc_1000D36C:				; CODE XREF: sub_100066AB+6C8Bj
		dec	dword_1001AC88
		jmp	short loc_1000D37A
; ---------------------------------------------------------------------------

loc_1000D374:				; CODE XREF: sub_100066AB+6C86j
		shr	dword_1001A49C,	1

loc_1000D37A:				; CODE XREF: sub_100066AB+6C22j
					; sub_100066AB+6C3Cj ...
		push	1
		pop	edx
		dec	ebx
		jnz	loc_1000D2BA

loc_1000D384:				; CODE XREF: sub_100066AB+6C09j
		inc	edi
		push	0
		pop	ebx
		cmp	byte ptr [edi+esi], 0
		jnz	loc_10006896
		jmp	loc_10006729
; ---------------------------------------------------------------------------

loc_1000D397:				; CODE XREF: sub_100066AB+138j
		mov	eax, ebp
		shl	eax, cl
		cmp	eax, ebp
		jbe	short loc_1000D3A7
		mov	edx, eax
		mov	dword_1001AB2C,	edx

loc_1000D3A7:				; CODE XREF: sub_100066AB+6CF2j
		mov	eax, edx
		shl	eax, 2
		cmp	eax, 100000h
		jbe	loc_100067EF
		mov	edx, 40000h
		jmp	short loc_1000D3DE
; ---------------------------------------------------------------------------

loc_1000D3BE:				; CODE XREF: sub_100066AB+13Ej
		neg	ecx
		mov	eax, ebp
		shr	eax, cl
		cmp	eax, ebp
		jnb	loc_100067EF
		mov	edx, eax
		mov	dword_1001AB2C,	edx
		test	edx, edx
		jnz	loc_100067EF
		mov	edx, ebp

loc_1000D3DE:				; CODE XREF: sub_100066AB+6D11j
		mov	dword_1001AB2C,	edx
		jmp	loc_100067EF
; END OF FUNCTION CHUNK	FOR sub_100066AB
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100068B3

loc_1000D3E9:				; CODE XREF: sub_100068B3+12j
					; sub_100068B3+21j
		mov	eax, offset byte_1001680D
		push	eax		; void *
		push	eax		; void *
		push	offset aMallocErrorIni ; ": (malloc) Error initializing	arena\n"
		push	offset aJemalloc ; "<jemalloc>"
		call	_malloc_message
		add	esp, 10h
		cmp	dword_1001AC98,	0
		jz	short loc_1000D411
		call	sub_1000EDDD
; ---------------------------------------------------------------------------

loc_1000D411:				; CODE XREF: sub_100068B3+6B57j
		mov	eax, dword_1001AB00
		mov	eax, [eax]
		jmp	loc_100068E5
; END OF FUNCTION CHUNK	FOR sub_100068B3
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10006906

loc_1000D41D:				; CODE XREF: sub_10006906+15j
		lea	edx, [edi+0FFFFFh]
		lea	eax, [esi+0FFFFFh]
		xor	edx, eax
		test	edx, 0FFF00000h
		jnz	loc_10006921
		lea	ebx, [edi+0FFFh]
		and	ebx, 0FFFFF000h
		cmp	edi, esi
		jnb	short loc_1000D45D
		mov	eax, esi
		sub	eax, edi
		push	eax		; size_t
		lea	eax, [edi+ebp]
		push	0E5h		; int
		push	eax		; void *
		call	memset
		add	esp, 0Ch

loc_1000D45D:				; CODE XREF: sub_10006906+6B3Fj
		mov	edi, ds:EnterCriticalSection
		cmp	ebx, esi
		jnb	short loc_1000D4A1
		mov	edx, esi
		lea	ecx, [ebx+ebp]	; lpAddress
		sub	edx, ebx
		call	sub_10005837
		push	offset stru_1001AAB0 ; lpCriticalSection
		call	edi ; EnterCriticalSection
		mov	eax, ebx
		mov	[esp+2Ch+var_C], ebp
		sub	eax, esi
		lea	edx, [esp+2Ch+var_1C]
		add	dword_1001AAAC,	eax
		call	sub_10005E22
		push	offset stru_1001AAB0 ; lpCriticalSection
		mov	[eax+14h], ebx
		call	ds:LeaveCriticalSection
		jmp	short loc_1000D4AF
; ---------------------------------------------------------------------------

loc_1000D4A1:				; CODE XREF: sub_10006906+6B5Fj
		jbe	short loc_1000D4DF
		mov	edx, ebx
		lea	ecx, [esi+ebp]	; lpAddress
		sub	edx, esi
		call	sub_100056A2

loc_1000D4AF:				; CODE XREF: sub_10006906+6B99j
		cmp	ebx, esi
		jbe	short loc_1000D4DF
		push	offset stru_1001AAB0 ; lpCriticalSection
		call	edi ; EnterCriticalSection
		mov	eax, ebx
		mov	[esp+2Ch+var_C], ebp
		sub	eax, esi
		lea	edx, [esp+2Ch+var_1C]
		add	dword_1001AAAC,	eax
		call	sub_10005E22
		push	offset stru_1001AAB0 ; lpCriticalSection
		mov	[eax+14h], ebx
		call	ds:LeaveCriticalSection

loc_1000D4DF:				; CODE XREF: sub_10006906:loc_1000D4A1j
					; sub_10006906+6BABj
		mov	eax, ebp
		jmp	loc_10006950
; END OF FUNCTION CHUNK	FOR sub_10006906
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000695C

loc_1000D4E6:				; CODE XREF: sub_1000695C+2Ej
		push	esi		; lpCriticalSection
		call	ds:EnterCriticalSection
		push	ebp		; int
		push	ebx		; void *
		mov	edx, edi
		mov	ecx, esi
		call	sub_10002410
		pop	ecx
		pop	ecx
		push	esi		; lpCriticalSection
		call	ds:LeaveCriticalSection
		jmp	loc_1000699B
; END OF FUNCTION CHUNK	FOR sub_1000695C
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?ProcessCreation@TimeStamp@mozilla@@SA?AV12@AA_N@Z

loc_1000D506:				; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+44j
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_1000D511
		xor	eax, eax
		jmp	short loc_1000D516
; ---------------------------------------------------------------------------

loc_1000D511:				; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+6B0Ej
		sbb	eax, eax
		or	eax, 1

loc_1000D516:				; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+6B12j
		test	eax, eax
		jz	loc_10006A47

loc_1000D51E:				; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+100j
		push	6
		pop	ecx
		lea	edi, [esp+68h+var_48]
		mov	esi, offset dword_1001AA50
		rep movsd
		jmp	loc_10006AE4
; END OF FUNCTION CHUNK	FOR ?ProcessCreation@TimeStamp@mozilla@@SA?AV12@AA_N@Z
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?CheckQPC@TimeStampValue@mozilla@@ABE_KABV12@@Z

loc_1000D531:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+31j
		mov	ecx, ebx
		mov	eax, ebp
		sub	ecx, esi
		sbb	eax, edi
		push	eax
		push	ecx
		call	sub_1000F355
		add	esp, 8
		cmp	edx, dword_1001ABD4
		mov	ecx, dword_1001ABD0
		jg	short loc_1000D55F
		jl	loc_10006BC7
		cmp	eax, ecx
		jbe	loc_10006BC7

loc_1000D55F:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+69BFj
		sub	eax, ecx
		sbb	edx, dword_1001ABD4
		cmp	edx, dword_1001ABDC
		jg	short loc_1000D581
		jl	loc_10006BC7
		cmp	eax, dword_1001ABD8
		jbe	loc_10006BC7

loc_1000D581:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+69DDj
		cmp	byte_1001A028, 0
		jz	loc_1000D685
		push	edi
		push	esi
		call	sub_1000F355
		add	esp, 8
		cmp	edx, dword_1001ABEC
		jg	loc_1000D685
		jl	short loc_1000D5B2
		cmp	eax, dword_1001ABE8
		jnb	loc_1000D685

loc_1000D5B2:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A14j
		call	dword_1001A818
		push	dword ptr qword_1001A810+4
		push	dword ptr qword_1001A810
		push	edx
		push	eax
		call	__allmul
		push	offset stru_1001AC68 ; lpCriticalSection
		mov	ebx, eax
		mov	ebp, edx
		call	ds:EnterCriticalSection
		mov	edx, dword_1001ACA8
		mov	ecx, edx
		mov	eax, dword_1001ACAC
		or	ecx, eax
		jz	short loc_1000D660
		cmp	eax, ebp
		jb	short loc_1000D660
		ja	short loc_1000D5F5
		cmp	edx, ebx
		jbe	short loc_1000D660

loc_1000D5F5:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A5Fj
		mov	ecx, dword_1001ABE0
		mov	eax, dword_1001ABE4
		sub	ecx, ebx
		push	dword_1001ABE4
		sbb	eax, ebp
		add	ecx, edx
		push	dword_1001ABE0
		adc	eax, dword_1001ACAC
		add	ecx, 0FFFFFFFFh
		adc	eax, 0FFFFFFFFh
		push	eax
		push	ecx
		call	__aulldiv
		test	edx, edx
		jnz	short loc_1000D657
		cmp	eax, 4
		ja	short loc_1000D657
		push	dword_1001ABE4
		add	eax, 1
		push	dword_1001ABE0
		adc	edx, edx
		push	edx
		push	eax
		call	__allmul
		add	eax, ebx
		mov	dword_1001ACA8,	eax
		adc	edx, ebp
		mov	dword_1001ACAC,	edx
		jmp	short loc_1000D67A
; ---------------------------------------------------------------------------

loc_1000D657:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A97j
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A9Cj
		mov	byte_1001A028, 0
		jmp	short loc_1000D67A
; ---------------------------------------------------------------------------

loc_1000D660:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A59j
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A5Dj ...
		mov	ecx, dword_1001ABE0
		mov	eax, dword_1001ABE4
		add	ecx, ebx
		mov	dword_1001ACA8,	ecx
		adc	eax, ebp
		mov	dword_1001ACAC,	eax

loc_1000D67A:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6AC5j
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6ACEj
		push	offset stru_1001AC68 ; lpCriticalSection
		call	ds:LeaveCriticalSection

loc_1000D685:				; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+69F8j
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A0Ej ...
		mov	eax, esi
		mov	edx, edi
		jmp	loc_10006BCB
; END OF FUNCTION CHUNK	FOR ?CheckQPC@TimeStampValue@mozilla@@ABE_KABV12@@Z
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10006F65

loc_1000D68E:				; CODE XREF: sub_10006F65+8Aj
					; sub_10006F65+92j
		push	0
		push	0Ah
		push	ebx
		push	esi
		call	__allmul
		cmp	edx, edi
		ja	loc_10006FFD
		jb	short loc_1000D6AB
		cmp	eax, ebp
		ja	loc_10006FFD

loc_1000D6AB:				; CODE XREF: sub_10006F65+673Cj
		mov	esi, eax
		mov	ebx, edx
		jmp	loc_10006FED
; END OF FUNCTION CHUNK	FOR sub_10006F65
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR moz_malloc_usable_size

loc_1000D6B4:				; CODE XREF: moz_malloc_usable_size+A2j
					; moz_malloc_usable_size+6566j
		mov	edx, [edx]
		mov	[esp+38h+var_24], edx
		mov	edx, edi
		shl	edx, cl
		mov	ecx, 20h
		sub	ecx, [esp+38h+var_24]
		shr	edx, cl
		mov	ecx, [esp+38h+arg_0]
		mov	ecx, [ecx+edx*4]
		mov	[esp+38h+arg_0], ecx
		test	ecx, ecx
		jz	loc_10007237
		mov	edx, [esp+38h+var_28]
		inc	ebp
		mov	ecx, [esp+38h+var_20]
		add	edx, 4
		add	ecx, [esp+38h+var_24]
		mov	[esp+38h+var_28], edx
		mov	[esp+38h+var_20], ecx
		cmp	ebp, ebx
		jb	short loc_1000D6B4
		jmp	loc_100071C8
; ---------------------------------------------------------------------------

loc_1000D6FD:				; CODE XREF: moz_malloc_usable_size+55j
		push	offset stru_1001AAB0 ; lpCriticalSection
		mov	[esp+3Ch+var_C], edi
		call	ds:EnterCriticalSection
		lea	edx, [esp+38h+var_1C]
		call	sub_10005E22
		test	eax, eax
		jz	short loc_1000D71E
		mov	ebx, [eax+14h]
		jmp	short loc_1000D720
; ---------------------------------------------------------------------------

loc_1000D71E:				; CODE XREF: moz_malloc_usable_size+6587j
		xor	ebx, ebx

loc_1000D720:				; CODE XREF: moz_malloc_usable_size+658Cj
		push	offset stru_1001AAB0 ; lpCriticalSection
		call	ds:LeaveCriticalSection
		jmp	loc_10007209
; END OF FUNCTION CHUNK	FOR moz_malloc_usable_size
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10008853

loc_1000D730:				; CODE XREF: sub_10008853+3Fj
		cmp	[esp+14h+var_1], 0
		jz	loc_10008898
		push	1
		mov	ecx, edi
		call	sub_1000911A
		push	1
		mov	ecx, ebp
		call	sub_1000911A
		push	1
		mov	ecx, esi
		call	sub_1000911A
		jmp	loc_10008898
; END OF FUNCTION CHUNK	FOR sub_10008853
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100088AC

loc_1000D75B:				; CODE XREF: sub_100088AC+32j
		mov	ecx, [ebp+arg_10]
		push	1
		call	sub_1000911A
		mov	ecx, [ebp+arg_C]
		push	1
		call	sub_1000911A
		push	ecx
		mov	ecx, [ebp+arg_18]
		call	sub_100091EF
		push	ecx
		mov	ecx, [ebp+arg_14]
		call	sub_100091EF
		pop	ebp
		retn
; END OF FUNCTION CHUNK	FOR sub_100088AC
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_100088E6

loc_1000D783:				; CODE XREF: sub_100088E6+44j
		call	sub_10009096
		push	ebx
		mov	ecx, esi
		call	sub_10009096
		jmp	loc_1000893D
; END OF FUNCTION CHUNK	FOR sub_100088E6
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10008958

loc_1000D795:				; CODE XREF: sub_10008958+49j
		push	4		; size_t
		lea	eax, [esp+8F8h+var_8B0]
		push	eax		; void *
		fstp	[esp+8FCh+var_8E4]
		fld	[esp+8FCh+var_8E4]
		lea	eax, [esp+8FCh+var_8A0]
		push	eax		; void *
		fstp	[esp+900h+var_8B0]
		call	esi ; memmove
		mov	eax, [esp+900h+var_8A0]
		lea	ecx, [esp+900h+var_898]
		add	esp, 0Ch
		mov	[esp+8F4h+var_898], eax
		call	sub_10014161
		fld	[esp+8F4h+var_8E4]
		xor	edx, edx
		mov	[esp+8F4h+var_8D8], eax
		lea	eax, [esp+8F4h+var_8AC]
		push	4		; size_t
		push	eax		; void *
		lea	eax, [esp+8FCh+var_89C]
		mov	[esp+8FCh+var_8D0], edx
		push	eax		; void *
		fstp	[esp+900h+var_8AC]
		call	esi ; memmove
		mov	eax, [esp+900h+var_89C]
		lea	ecx, [esp+900h+var_8A4]
		add	esp, 0Ch
		mov	[esp+8F4h+var_8A4], eax
		call	sub_10013264
		fld	[esp+8F4h+var_8E4]
		mov	[esp+8F4h+var_8CC], eax
		lea	eax, [esp+8F4h+var_8B4]
		push	4		; size_t
		push	eax		; void *
		lea	eax, [esp+8FCh+var_8A8]
		push	eax		; void *
		fstp	[esp+900h+var_8B4]
		call	esi ; memmove
		mov	eax, [esp+900h+var_8A8]
		lea	ecx, [esp+900h+var_8BC]
		add	esp, 0Ch
		mov	dword ptr [esp+8F4h+var_8BC], eax
		call	sub_10013B14
		mov	[esp+8F4h+var_8E5], al
		jmp	loc_10008C08
; ---------------------------------------------------------------------------

loc_1000D82E:				; CODE XREF: sub_10008958+2C8j
					; sub_10008958+4EE9j
		shld	esi, edx, 1
		xor	eax, eax
		mov	ecx, esi
		add	edx, edx
		and	ecx, 100000h
		dec	edi
		or	eax, ecx
		jz	short loc_1000D82E
		mov	[esp+8F4h+var_8E4], edi
		mov	edi, dword ptr [esp+8F4h+var_8C4]
		jmp	loc_10008AB7
; ---------------------------------------------------------------------------

loc_1000D850:				; CODE XREF: sub_10008958+198j
		or	ecx, 0FFFFFFFFh
		sub	ecx, esi
		cmp	ecx, edi
		jle	loc_10008AF6
		mov	eax, [esp+8F4h+arg_10]
		mov	esi, [esp+8F4h+var_8DC]
		mov	byte ptr [eax],	0
		mov	eax, [esp+8F4h+var_8E0]
		and	dword ptr [esi], 0
		neg	edi
		mov	[eax], edi
		jmp	loc_10008BF0
; ---------------------------------------------------------------------------

loc_1000D87B:				; CODE XREF: sub_10008958+24Bj
		push	[esp+8F4h+arg_14]
		mov	esi, [esp+8F8h+var_8DC]
		lea	eax, [esp+8F8h+var_84C]
		push	[esp+8F8h+arg_10]
		mov	edx, [esp+8FCh+var_8E0]
		mov	ecx, edi
		push	esi
		push	eax
		lea	eax, [esp+904h+var_63C]
		push	eax
		call	sub_100129A9
		jmp	loc_10008BE0
; ---------------------------------------------------------------------------

loc_1000D8AE:				; CODE XREF: sub_10008958+242j
		push	[esp+8F4h+arg_14]
		mov	esi, [esp+8F8h+var_8DC]
		lea	eax, [esp+8F8h+var_42C]
		push	[esp+8F8h+arg_10]
		lea	edx, [esp+8FCh+var_84C]
		push	esi
		push	[esp+900h+var_8D4]
		lea	ecx, [esp+904h+var_63C]
		push	eax
		lea	eax, [esp+908h+var_21C]
		push	eax
		call	sub_100137E9
		add	esp, 18h
		jmp	loc_10008BE3
; ---------------------------------------------------------------------------

loc_1000D8F0:				; CODE XREF: sub_10008958+239j
					; sub_10008958+254j
		int	3		; Trap to Debugger
		push	3		; uExitCode
		mov	large dword ptr	ds:0, 0A6h
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:TerminateProcess
		int	3		; Trap to Debugger
; END OF FUNCTION CHUNK	FOR sub_10008958
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10008C25

loc_1000D90B:				; CODE XREF: sub_10008C25+24j
		mov	eax, ebx
		mov	ebx, edi
		mov	edi, eax
		jmp	loc_10008C2F
; ---------------------------------------------------------------------------

loc_1000D916:				; CODE XREF: sub_10008C25+71j
		cmp	esi, eax
		jl	loc_10008C9C
		jmp	loc_10008C76
; END OF FUNCTION CHUNK	FOR sub_10008C25
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10008DDF

loc_1000D923:				; CODE XREF: sub_10008DDF+52j
		mov	ecx, [esi+208h]
		mov	eax, [esi+200h]
		mov	[eax+ecx*4], edi
		inc	dword ptr [esi+208h]
		jmp	loc_10008E37
; END OF FUNCTION CHUNK	FOR sub_10008DDF
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10008E3F

loc_1000D93D:				; CODE XREF: sub_10008E3F+16j
		sub	edi, eax
		mov	eax, [esi+208h]
		add	eax, edi
		push	eax
		call	sub_10009240
		mov	edx, [esi+208h]
		dec	edx
		js	short loc_1000D970
		push	ebx
		lea	ebx, [edx+edi]
		shl	ebx, 2

loc_1000D95D:				; CODE XREF: sub_10008E3F+4B2Ej
		mov	ecx, [esi+200h]
		mov	eax, [ecx+edx*4]
		dec	edx
		mov	[ebx+ecx], eax
		lea	ebx, [ebx-4]
		jns	short loc_1000D95D
		pop	ebx

loc_1000D970:				; CODE XREF: sub_10008E3F+4B15j
		xor	ecx, ecx
		test	edi, edi
		jle	short loc_1000D985

loc_1000D976:				; CODE XREF: sub_10008E3F+4B44j
		mov	eax, [esi+200h]
		and	dword ptr [eax+ecx*4], 0
		inc	ecx
		cmp	ecx, edi
		jl	short loc_1000D976

loc_1000D985:				; CODE XREF: sub_10008E3F+4B35j
		add	[esi+208h], edi
		sub	[esi+20Ch], edi
		jmp	loc_10008E5B
; END OF FUNCTION CHUNK	FOR sub_10008E3F
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10008E60

loc_1000D996:				; CODE XREF: sub_10008E60+Bj
					; sub_10008E60+4B46j
		mov	eax, [ecx+200h]
		mov	[eax+edx*4], esi
		inc	edx
		cmp	edx, [ecx+208h]
		jl	short loc_1000D996
		jmp	loc_10008E71
; END OF FUNCTION CHUNK	FOR sub_10008E60
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10008EE7

loc_1000D9AD:				; CODE XREF: sub_10008EE7+C9j
					; sub_10008EE7+4AF9j
		mov	eax, [edi+200h]
		mov	ecx, edi
		push	dword ptr [eax+edx*4-4]
		add	si, [eax+edx*4-4]
		push	ebx
		call	sub_10014B14
		mov	ecx, [edi+20Ch]
		mov	eax, [ebx+208h]
		mov	edx, [edi+208h]
		add	ecx, edx
		add	eax, [ebx+20Ch]
		cmp	ecx, eax
		jg	short loc_1000D9AD
		mov	word ptr [esp+1Ch+arg_0], si
		mov	ebp, [esp+1Ch+arg_0]
		jmp	loc_10008F44
; ---------------------------------------------------------------------------

loc_1000D9F0:				; CODE XREF: sub_10008EE7+8Cj
		lea	ecx, [esi+1]
		div	ecx
		mov	ecx, edi
		mov	esi, eax
		push	esi
		add	ebp, esi
		push	ebx
		mov	[esp+24h+arg_0], ebp
		call	sub_10014B14
		lea	eax, [esi+1]
		imul	eax, [esp+1Ch+var_C]
		cmp	eax, [esp+1Ch+var_8]
		ja	short loc_1000DA30

loc_1000DA14:				; CODE XREF: sub_10008EE7+4B43j
		mov	edx, edi
		mov	ecx, ebx
		call	sub_1000A406
		test	eax, eax
		jg	short loc_1000DA2C
		push	ebx
		mov	ecx, edi
		call	sub_10014A61
		inc	ebp
		jmp	short loc_1000DA14
; ---------------------------------------------------------------------------

loc_1000DA2C:				; CODE XREF: sub_10008EE7+4B38j
		mov	[esp+1Ch+arg_0], ebp

loc_1000DA30:				; CODE XREF: sub_10008EE7+4B2Bj
		mov	ax, word ptr [esp+1Ch+arg_0]
		jmp	loc_10008FA4
; END OF FUNCTION CHUNK	FOR sub_10008EE7
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10008FB5

loc_1000DA3A:				; CODE XREF: sub_10008FB5+94j
		mov	edi, [esp+28h+var_C]
		push	40h
		pop	edx
		sub	edx, [esp+28h+var_18]
		mov	[esp+28h+var_18], edx
		mov	ebp, edx

loc_1000DA4B:				; CODE XREF: sub_10008FB5+4AFEj
		test	eax, eax
		ja	short loc_1000DAB5
		jb	short loc_1000DA56
		cmp	ecx, 0FFFFFFFFh
		ja	short loc_1000DAB5

loc_1000DA56:				; CODE XREF: sub_10008FB5+4A9Aj
		push	eax
		push	ecx
		push	eax
		push	ecx
		call	__allmul
		mov	ecx, eax
		mov	eax, edx
		mov	[esp+28h+var_C], ecx
		mov	[esp+28h+var_18], eax
		test	ebx, esi
		jz	short loc_1000DAB1
		xor	eax, eax
		xor	edx, edx
		inc	eax
		mov	ecx, ebp
		call	__allshl
		mov	ecx, [esp+28h+var_C]
		add	eax, 0FFFFFFFFh
		not	eax
		adc	edx, 0FFFFFFFFh
		and	eax, ecx
		not	edx
		and	edx, [esp+28h+var_18]
		or	eax, edx
		jnz	short loc_1000DAA8
		push	[esp+28h+var_18]
		push	ecx
		push	[esp+30h+var_8]
		push	edi
		call	__allmul
		mov	ecx, eax
		mov	eax, edx
		jmp	short loc_1000DAB1
; ---------------------------------------------------------------------------

loc_1000DAA8:				; CODE XREF: sub_10008FB5+4ADCj
		mov	eax, [esp+28h+var_18]
		mov	byte ptr [esp+28h+arg_4], 1

loc_1000DAB1:				; CODE XREF: sub_10008FB5+4AB8j
					; sub_10008FB5+4AF1j
		sar	esi, 1
		jnz	short loc_1000DA4B

loc_1000DAB5:				; CODE XREF: sub_10008FB5+4A98j
					; sub_10008FB5+4A9Fj
		mov	edi, [esp+28h+var_4]
		mov	ebp, [esp+28h+var_10]
		jmp	loc_1000904F
; ---------------------------------------------------------------------------

loc_1000DAC2:				; CODE XREF: sub_10008FB5+DCj
					; sub_10008FB5+4B22j
		mov	ecx, edi
		call	sub_10014194
		test	ebx, esi
		jz	short loc_1000DAD5
		push	ebp
		mov	ecx, edi
		call	sub_10009096

loc_1000DAD5:				; CODE XREF: sub_10008FB5+4B16j
		sar	esi, 1
		jnz	short loc_1000DAC2
		mov	ebp, [esp+28h+var_10]
		jmp	loc_10009063
; END OF FUNCTION CHUNK	FOR sub_10008FB5
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10009096

loc_1000DAE2:				; CODE XREF: sub_10009096+73j
		mov	eax, [ebx+208h]
		inc	eax
		push	eax
		call	sub_10009240
		mov	ecx, [ebx+208h]
		mov	edx, ebp
		mov	eax, [ebx+200h]
		and	edx, 0FFFFFFFh
		shrd	ebp, edi, 1Ch
		mov	[eax+ecx*4], edx
		inc	dword ptr [ebx+208h]
		shr	edi, 1Ch
		jmp	loc_10009105
; END OF FUNCTION CHUNK	FOR sub_10009096
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10009150

loc_1000DB18:				; CODE XREF: sub_10009150+1Cj
					; sub_10009150+49E1j
		mov	eax, [esi+200h]
		mov	ecx, [edx+200h]
		mov	eax, [eax+edi*4]
		mov	[ecx+edi*4], eax
		inc	edi
		cmp	edi, [esi+208h]
		jl	short loc_1000DB18
		jmp	loc_10009172
; END OF FUNCTION CHUNK	FOR sub_10009150
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10009240

loc_1000DB38:				; CODE XREF: sub_10009240+8j
		int	3		; Trap to Debugger
		push	3		; uExitCode
		mov	large dword ptr	ds:0, 74h
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:TerminateProcess
		int	3		; Trap to Debugger
; END OF FUNCTION CHUNK	FOR sub_10009240
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10009391

loc_1000DB53:				; CODE XREF: sub_10009391+DEj
					; sub_10009391+EAj
		push	0
		push	edx
		push	esi
		push	ebp
		call	__allmul
		push	0
		push	0Ah
		mov	ebp, eax
		mov	esi, edx
		pop	eax
		push	eax
		push	[esp+44h+var_2C]
		push	[esp+48h+var_28]
		call	__allmul
		mov	ecx, [esp+3Ch+var_20]
		mov	[esp+3Ch+var_28], eax
		neg	ecx
		mov	[esp+3Ch+var_2C], edx
		mov	eax, ebp
		mov	edx, esi
		call	__aullshr
		mov	edx, [ebx]
		add	al, 30h
		mov	ecx, [esp+3Ch+arg_14]
		and	ebp, [esp+3Ch+var_C]
		and	esi, [esp+3Ch+var_8]
		push	0Ah
		mov	[ecx+edx], al
		mov	ecx, [esp+40h+arg_0]
		inc	dword ptr [ebx]
		dec	edi
		pop	edx
		dec	dword ptr [ecx]
		test	edi, edi
		jg	loc_10009469
		jmp	loc_10009481
; ---------------------------------------------------------------------------

loc_1000DBB7:				; CODE XREF: sub_10009391+F2j
		push	[esp+3Ch+arg_18]
		mov	edx, ecx
		push	[esp+40h+arg_14]
		push	[esp+44h+var_2C]
		push	[esp+48h+var_28]
		push	[esp+4Ch+var_14]
		push	[esp+50h+var_4]
		push	esi
		push	ebp
		jmp	loc_100094C7
; END OF FUNCTION CHUNK	FOR sub_10009391
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?ToPrecision@DoubleToStringConverter@double_conversion@@QBE_NNHPA_NPAVStringBuilder@2@@Z

loc_1000DBD8:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+67j
		fld	[esp+0B8h+var_98]
		push	ebx		; struct double_conversion::StringBuilder *
		push	ecx
		push	ecx
		mov	ecx, edi	; this
		fstp	[esp+0C4h+var_C4] ; double
		call	?HandleSpecialValues@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@@Z ; double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)
		jmp	loc_1000962A
; ---------------------------------------------------------------------------

loc_1000DBEE:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+D1j
					; double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder *)+DEj
		mov	edx, [esp+0B8h+var_A8]
		cmp	edx, esi
		jge	short loc_1000DC0C
		mov	eax, esi
		lea	ecx, [esp+0B8h+var_88]
		sub	eax, edx
		add	ecx, edx
		push	eax		; size_t
		push	30h		; int
		push	ecx		; void *
		call	memset
		add	esp, 0Ch

loc_1000DC0C:				; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+46C9j
		mov	eax, [esp+0B8h+var_8C]
		lea	ecx, [esp+0B8h+var_88]
		push	ebx		; struct double_conversion::StringBuilder *
		push	[esp+0BCh+var_A0] ; int
		push	esi		; int
		push	ecx		; char *
		mov	ecx, edi	; this
		mov	byte ptr [eax],	1
		call	?CreateExponentialRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHPAVStringBuilder@2@@Z ; double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)
		jmp	loc_10009628
; END OF FUNCTION CHUNK	FOR ?ToPrecision@DoubleToStringConverter@double_conversion@@QBE_NNHPA_NPAVStringBuilder@2@@Z
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?CreateDecimalRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHHPAVStringBuilder@2@@Z

loc_1000DC2A:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+14j
		mov	ecx, [edi+8]
		mov	esi, [esp+10h+arg_C]
		lea	eax, [ecx+1]
		mov	[edi+8], eax
		mov	eax, [edi]
		mov	byte ptr [ecx+eax], 30h
		test	esi, esi
		jle	loc_100096BF
		mov	ecx, [edi+8]
		lea	eax, [ecx+1]
		mov	[edi+8], eax
		mov	eax, [edi]
		mov	byte ptr [ecx+eax], 2Eh
		mov	eax, ebx
		neg	eax
		push	eax
		push	ecx
		mov	ecx, edi
		call	sub_10009841
		push	[esp+10h+arg_4]	; size_t
		mov	ecx, edi
		push	[esp+14h+arg_0]	; void *
		call	sub_1000981D
		sub	ebx, [esp+10h+arg_4]
		add	ebx, esi
		push	ebx
		push	ecx
		mov	ecx, edi
		call	sub_10009841
		jmp	loc_100096B9
; ---------------------------------------------------------------------------

loc_1000DC84:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+4Ej
		mov	ecx, [edi+8]
		lea	eax, [ecx+1]
		mov	[edi+8], eax
		mov	eax, [edi]
		mov	byte ptr [ecx+eax], 2Eh
		jmp	loc_100096CA
; ---------------------------------------------------------------------------

loc_1000DC98:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const	*,int,int,int,double_conversion::StringBuilder *)+57j
		mov	ecx, [edi+8]
		lea	eax, [ecx+1]
		mov	[edi+8], eax
		mov	eax, [edi]
		mov	byte ptr [ecx+eax], 30h
		jmp	loc_100096D3
; END OF FUNCTION CHUNK	FOR ?CreateDecimalRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHHPAVStringBuilder@2@@Z
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?ToShortestIeeeNumber@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@W4DtoaMode@12@@Z

loc_1000DCAC:				; CODE XREF: double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+5Aj
		push	edi		; struct double_conversion::StringBuilder *
		push	ecx
		push	ecx
		mov	ecx, esi	; this
		fstp	[esp+4Ch+var_4C] ; double
		call	?HandleSpecialValues@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@@Z ; double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)
		jmp	loc_100097F6
; ---------------------------------------------------------------------------

loc_1000DCBE:				; CODE XREF: double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+95j
		fldz
		fld	[esp+40h+var_20]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_1000DCD5
		test	cl, cl
		jnz	loc_100097C4

loc_1000DCD5:				; CODE XREF: double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+45A2j
		mov	ecx, [edi+8]
		lea	eax, [ecx+1]
		mov	[edi+8], eax
		mov	eax, [edi]
		mov	byte ptr [ecx+eax], 2Dh
		jmp	loc_100097C4
; END OF FUNCTION CHUNK	FOR ?ToShortestIeeeNumber@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@W4DtoaMode@12@@Z
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z

loc_1000DCE9:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+A6j
		mov	eax, [ebp+arg_1C]
		fstp	st
		mov	[esi], dl
		mov	[eax], edx
		jmp	loc_10009910
; ---------------------------------------------------------------------------

loc_1000DCF7:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+BAj
		fstp	st
		int	3		; Trap to Debugger
		push	3		; uExitCode
		mov	large dword ptr	ds:0, 199h
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:TerminateProcess

loc_1000DD13:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+B3j
		mov	edi, [ebp+arg_1C]
		mov	edx, edi
		push	ebx		; int
		mov	ebx, [ebp+arg_20]
		push	esi		; int
		push	ecx
		push	ecx
		fstp	[esp+40h+var_40] ; double
		push	ebx		; int
		call	sub_10013281
		add	esp, 14h
		jmp	loc_1000990C
; ---------------------------------------------------------------------------

loc_1000DD30:				; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+ACj
		push	ebx
		push	esi
		push	ecx
		push	ecx
		xor	ecx, ecx
		xor	edx, edx
		inc	ecx
		jmp	loc_100098F9
; END OF FUNCTION CHUNK	FOR ?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000999E

loc_1000DD3E:				; CODE XREF: sub_1000999E+6Dj
		push	4		; size_t
		lea	eax, [esp+84h+arg_4]
		push	eax		; void *
		lea	eax, [esp+88h+var_70]
		push	eax		; void *
		fstp	dword ptr [esp+8Ch+arg_4]
		call	edi ; memmove
		mov	eax, [esp+8Ch+var_70]
		lea	ecx, [esp+8Ch+arg_4]
		add	esp, 0Ch
		mov	dword ptr [esp+80h+arg_4], eax
		lea	eax, [esp+80h+var_40]
		push	eax
		lea	eax, [esp+84h+var_50]
		push	eax
		call	sub_10013E1E
		jmp	loc_10009A52
; END OF FUNCTION CHUNK	FOR sub_1000999E
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10009CEC

loc_1000DD7F:				; CODE XREF: sub_10009CEC+6Cj
		mov	eax, [esp+4Ch+var_30]
		shld	eax, ebp, 2
		shl	ebp, 2
		add	ebp, 0FFFFFFFFh
		mov	[esp+4Ch+var_24], ebp
		adc	eax, 0FFFFFFFFh
		mov	[esp+4Ch+var_20], eax
		mov	eax, [esp+4Ch+var_2C]
		add	eax, 0FFFFFFFEh
		jmp	loc_10009D79
; END OF FUNCTION CHUNK	FOR sub_10009CEC
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10009E38

loc_1000DDA4:				; CODE XREF: sub_10009E38+25j
					; sub_10009E38+3F7Bj
		shld	ebx, edi, 1
		xor	eax, eax
		mov	ecx, ebx
		add	edi, edi
		and	ecx, ebp
		dec	edx
		or	eax, ecx
		jz	short loc_1000DDA4
		jmp	loc_10009E63
; END OF FUNCTION CHUNK	FOR sub_10009E38
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10009EA5

loc_1000DDBA:				; CODE XREF: sub_10009EA5+Dj
					; sub_10009EA5+5Aj
		int	3		; Trap to Debugger
		push	3		; uExitCode
		mov	large dword ptr	ds:0, 28Fh
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:TerminateProcess
		int	3		; Trap to Debugger
; END OF FUNCTION CHUNK	FOR sub_10009EA5
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_10009F7E

loc_1000DDD5:				; CODE XREF: sub_10009F7E+129j
					; sub_10009F7E+133j
		push	[esp+5Ch+arg_34]
		sub	edi, [esp+60h+arg_10]
		push	[esp+60h+arg_30]
		sbb	ebx, [esp+64h+arg_14]
		xor	edx, edx
		mov	eax, [esp+64h+var_38]
		mov	ecx, [esp+64h+var_2C]
		push	0
		push	1
		call	__allshl
		mov	ecx, [esp+6Ch+var_14]
		push	edx
		push	eax
		push	[esp+74h+var_1C]
		push	[esp+78h+var_18]
		push	[esp+7Ch+var_48]
		push	ebp
		push	ebx
		push	edi
		jmp	loc_1000A1C9
; END OF FUNCTION CHUNK	FOR sub_10009F7E
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000A1D9

loc_1000DE18:				; CODE XREF: sub_1000A1D9+3Fj
					; sub_1000A1D9+47j ...
		sub	eax, edx
		mov	[esp+24h+arg_10], eax
		mov	eax, [esp+24h+arg_C]
		sbb	eax, esi
		cmp	eax, [esp+24h+arg_1C]
		jb	loc_1000DED6
		ja	short loc_1000DE3E
		mov	eax, [esp+24h+arg_18]
		cmp	[esp+24h+arg_10], eax
		jb	loc_1000DED6

loc_1000DE3E:				; CODE XREF: sub_1000A1D9+3C55j
		mov	ecx, [esp+24h+arg_1C]
		mov	eax, edx
		add	eax, [esp+24h+arg_18]
		mov	[esp+24h+arg_10], esi
		adc	[esp+24h+arg_10], ecx
		mov	ecx, [esp+24h+arg_0]
		cmp	[esp+24h+arg_10], ecx
		mov	ecx, [esp+24h+var_14]
		mov	[esp+24h+var_4], eax
		jb	short loc_1000DEA6
		ja	short loc_1000DE68
		cmp	eax, ecx
		jb	short loc_1000DEA6

loc_1000DE68:				; CODE XREF: sub_1000A1D9+3C89j
		mov	eax, edx
		sub	eax, ecx
		mov	ecx, esi
		mov	[esp+24h+var_10], eax
		sbb	ecx, [esp+24h+arg_0]
		add	eax, [esp+24h+arg_18]
		mov	[esp+24h+var_10], eax
		adc	ecx, [esp+24h+arg_1C]
		mov	eax, [esp+24h+var_14]
		sub	eax, edx
		mov	[esp+24h+var_C], eax
		mov	eax, [esp+24h+arg_0]
		sbb	eax, esi
		cmp	eax, ecx
		jb	short loc_1000DED6
		ja	short loc_1000DEA2
		mov	eax, [esp+24h+var_C]
		cmp	eax, [esp+24h+var_10]
		jb	short loc_1000DED6

loc_1000DEA2:				; CODE XREF: sub_1000A1D9+3CBDj
		mov	ecx, [esp+24h+var_14]

loc_1000DEA6:				; CODE XREF: sub_1000A1D9+3C87j
					; sub_1000A1D9+3C8Dj
		mov	eax, [esp+24h+arg_28]
		mov	edx, [esp+24h+var_8]
		mov	esi, [esp+24h+arg_10]
		dec	byte ptr [eax+edx-1]
		mov	edx, [esp+24h+var_4]
		mov	eax, [esp+24h+arg_8]
		cmp	esi, [esp+24h+arg_0]
		jb	loc_1000DE18
		ja	loc_1000A226
		cmp	edx, ecx
		jb	loc_1000DE18

loc_1000DED6:				; CODE XREF: sub_1000A1D9+3C4Fj
					; sub_1000A1D9+3C5Fj ...
		mov	eax, [esp+24h+arg_8]
		jmp	loc_1000A226
; ---------------------------------------------------------------------------

loc_1000DEDF:				; CODE XREF: sub_1000A1D9+6Bj
					; sub_1000A1D9+73j
		mov	ecx, edx
		add	ecx, eax
		mov	eax, esi
		adc	eax, [esp+24h+arg_1C]
		cmp	eax, ebp
		jb	short loc_1000DF19
		ja	short loc_1000DEF3
		cmp	ecx, edi
		jb	short loc_1000DF19

loc_1000DEF3:				; CODE XREF: sub_1000A1D9+3D14j
		mov	ecx, edx
		mov	eax, esi
		sub	ecx, edi
		sbb	eax, ebp
		add	ecx, [esp+24h+arg_18]
		adc	eax, [esp+24h+arg_1C]
		sub	edi, edx
		sbb	ebp, esi
		cmp	ebp, eax
		jb	loc_1000A252
		ja	short loc_1000DF19
		cmp	edi, ecx
		jbe	loc_1000A252

loc_1000DF19:				; CODE XREF: sub_1000A1D9+3D12j
					; sub_1000A1D9+3D18j ...
		xor	al, al
		jmp	loc_1000A28A
; END OF FUNCTION CHUNK	FOR sub_1000A1D9
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000A341

loc_1000DF20:				; CODE XREF: sub_1000A341+50j
					; sub_1000A341+5Aj ...
		cmp	ecx, edi
		jb	short loc_1000DF74
		ja	short loc_1000DF2A
		cmp	edx, esi
		jbe	short loc_1000DF74

loc_1000DF2A:				; CODE XREF: sub_1000A341+3BE3j
		add	ebx, esi
		adc	eax, edi
		sub	edx, esi
		sbb	ecx, edi
		cmp	eax, ecx
		ja	short loc_1000DF74
		jb	short loc_1000DF3C
		cmp	ebx, edx
		ja	short loc_1000DF74

loc_1000DF3C:				; CODE XREF: sub_1000A341+3BF5j
		mov	ecx, [esp+18h+var_8]
		jmp	short loc_1000DF4C
; ---------------------------------------------------------------------------

loc_1000DF42:				; CODE XREF: sub_1000A341+3C1Aj
		cmp	byte ptr [eax+ecx], 3Ah
		jnz	short loc_1000DF5D
		mov	byte ptr [eax+ecx], 30h

loc_1000DF4C:				; CODE XREF: sub_1000A341+3BFFj
		mov	eax, [esp+18h+arg_18]
		inc	byte ptr [eax+ecx-1]
		dec	ecx
		mov	eax, [esp+18h+arg_18]
		test	ecx, ecx
		jg	short loc_1000DF42

loc_1000DF5D:				; CODE XREF: sub_1000A341+3C05j
		cmp	byte ptr [eax],	3Ah
		jnz	loc_1000A3CB
		mov	byte ptr [eax],	31h
		mov	eax, [esp+18h+var_4]
		inc	dword ptr [eax]
		jmp	loc_1000A3CB
; ---------------------------------------------------------------------------

loc_1000DF74:				; CODE XREF: sub_1000A341+3BE1j
					; sub_1000A341+3BE7j ...
		xor	al, al
		jmp	loc_1000A3CD
; END OF FUNCTION CHUNK	FOR sub_1000A341
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000A3E5

loc_1000DF7B:				; CODE XREF: sub_1000A3E5+Cj
		int	3		; Trap to Debugger
		push	3		; uExitCode
		mov	large dword ptr	ds:0, 161h
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:TerminateProcess
		int	3		; Trap to Debugger
; END OF FUNCTION CHUNK	FOR sub_1000A3E5
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000A406

loc_1000DF96:				; CODE XREF: sub_1000A406+3Dj
		push	esi
		call	sub_10008EB9
		mov	ecx, [esp+18h+var_8]
		mov	ebp, eax
		push	esi
		call	sub_10008EB9
		cmp	ebp, eax
		jb	short loc_1000DFBF
		ja	short loc_1000DFB7
		mov	ecx, [esp+18h+var_4]
		jmp	loc_1000A438
; ---------------------------------------------------------------------------

loc_1000DFB7:				; CODE XREF: sub_1000A406+3BA6j
		xor	eax, eax
		inc	eax
		jmp	loc_1000A44B
; ---------------------------------------------------------------------------

loc_1000DFBF:				; CODE XREF: sub_1000A406+3BA4j
		or	eax, 0FFFFFFFFh
		jmp	loc_1000A44B
; END OF FUNCTION CHUNK	FOR sub_1000A406
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000A50E

loc_1000DFC7:				; CODE XREF: sub_1000A50E+4Ej
		cmp	[esp+40h+arg_10], 2
		jnz	loc_1000A562
		jmp	loc_1000A7FF
; ---------------------------------------------------------------------------

loc_1000DFD7:				; CODE XREF: sub_1000A50E+F8j
		mov	ecx, [esp+40h+var_20]
		lea	eax, [ebp+0FFFFh]
		mov	edx, [esp+40h+var_1C]
		cmp	eax, ebx
		mov	eax, [esp+40h+var_24]
		jb	loc_1000A596
		jmp	loc_1000A60C
; ---------------------------------------------------------------------------

loc_1000DFF6:				; CODE XREF: sub_1000A50E+142j
		xor	edx, edx
		mov	eax, ecx
		div	[esp+40h+var_8]
		add	eax, 8
		add	eax, ecx
		add	eax, edi
		cmp	eax, [esp+40h+var_18]
		ja	loc_1000A7FF
		jmp	loc_1000A656
; ---------------------------------------------------------------------------

loc_1000E014:				; CODE XREF: sub_1000A50E+24Bj
		mov	eax, edx
		mov	ecx, 0FFh
		xor	edx, edx
		div	ecx
		mov	esi, eax
		push	esi		; size_t
		push	ecx		; int
		push	edi		; void *
		call	memset
		mov	edx, [esp+4Ch+var_C]
		add	edi, esi
		mov	ecx, [esp+4Ch+var_1C]
		add	esp, 0Ch
		imul	eax, esi, 0FFFFFF01h
		mov	esi, [esp+40h+var_30]
		add	edx, eax
		jmp	loc_1000A75F
; ---------------------------------------------------------------------------

loc_1000E047:				; CODE XREF: sub_1000A50E+25Ej
		mov	eax, ecx
		shr	eax, 8
		add	eax, 6
		add	eax, edi
		cmp	eax, [esp+40h+var_18]
		ja	loc_1000A7FF
		jmp	loc_1000A772
; ---------------------------------------------------------------------------

loc_1000E060:				; CODE XREF: sub_1000A50E+272j
		xor	edx, edx
		mov	eax, ecx
		div	ebp
		mov	edx, 0FFh

loc_1000E06B:				; CODE XREF: sub_1000A50E+3B68j
		mov	word ptr [edi],	0FFFFh
		sub	ecx, ebp
		add	edi, 2
		dec	eax
		jnz	short loc_1000E06B
		jmp	loc_1000A78B
; ---------------------------------------------------------------------------

loc_1000E07D:				; CODE XREF: sub_1000A50E+2B5j
		xor	edx, edx
		lea	eax, [ebx+0F0h]
		div	ecx
		sub	eax, [esp+40h+arg_0]
		inc	eax
		add	eax, ebx
		add	eax, edi
		cmp	eax, [esp+40h+arg_8]
		ja	loc_1000A7FF
		jmp	loc_1000A7C9
; ---------------------------------------------------------------------------

loc_1000E09F:				; CODE XREF: sub_1000A50E+2C9j
		xor	edx, edx
		mov	eax, ebx
		div	ecx
		mov	esi, eax
		push	esi		; size_t
		push	ecx		; int
		push	edi		; void *
		call	memset
		imul	eax, esi, 0FFFFFF01h
		add	edi, esi
		mov	esi, [esp+4Ch+var_30]
		add	esp, 0Ch
		add	ebx, eax
		jmp	loc_1000A7DD
; END OF FUNCTION CHUNK	FOR sub_1000A50E
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000A872

loc_1000E0C5:				; CODE XREF: sub_1000A872+10j
		lea	eax, [esi-1]
		cmp	ecx, eax
		jnb	short loc_1000E0DA
		mov	ax, [edx]
		cmp	ax, [ecx]
		jnz	short loc_1000E0DA
		add	ecx, 2
		add	edx, 2

loc_1000E0DA:				; CODE XREF: sub_1000A872+3858j
					; sub_1000A872+3860j
		cmp	ecx, esi
		jnb	short loc_1000E0E5
		mov	al, [edx]
		cmp	al, [ecx]
		jnz	short loc_1000E0E5
		inc	ecx

loc_1000E0E5:				; CODE XREF: sub_1000A872+386Aj
					; sub_1000A872+3870j
		sub	ecx, edi
		mov	eax, ecx
		jmp	loc_1000A8A3
; END OF FUNCTION CHUNK	FOR sub_1000A872
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000A8A8

loc_1000E0EE:				; CODE XREF: sub_1000A8A8+EFj
		and	[esp+0CCh+EndPtr], esi
		lea	eax, [esp+0CCh+EndPtr]
		push	10h		; Radix
		push	eax		; EndPtr
		lea	eax, [edi+1]
		push	eax		; String
		call	ds:_strtoui64
		add	esp, 0Ch
		cmp	[esp+0CCh+EndPtr], ebx
		jnz	loc_1000A99D
		jmp	short loc_1000E12C
; ---------------------------------------------------------------------------

loc_1000E112:				; CODE XREF: sub_1000A8A8+3921j
		lea	eax, [esp+0CCh+var_88]
		push	eax		; char
		push	offset aLdrloaddllBloc ; "LdrLoadDll: Blocking load of '%s' (Sear"...
		call	sub_1000EC1C
		pop	ecx
		pop	ecx
		lea	ecx, [esp+0CCh+var_A4]
		call	sub_1000E774

loc_1000E12C:				; CODE XREF: sub_1000A8A8+1E6j
					; sub_1000A8A8+3868j
		push	0
		call	ds:??_V@YAXPAX@Z ; operator delete[](void *)
		mov	eax, 0C0000135h
		jmp	loc_1000AA2E
; ---------------------------------------------------------------------------

loc_1000E13E:				; CODE XREF: sub_1000A8A8+149j
		cmp	dword ptr [ebx+10h], 1
		mov	[esp+0CCh+var_89], 0
		jnz	short loc_1000E15B
		mov	ecx, 6020000h
		call	sub_1000AAFC
		test	al, al
		jz	loc_1000A9F7

loc_1000E15B:				; CODE XREF: sub_1000A8A8+389Fj
		cmp	dword ptr [ebx+10h], 2
		jnz	short loc_1000E173
		mov	ecx, 5020000h
		call	sub_1000AAFC
		test	al, al
		jnz	loc_1000A9F7

loc_1000E173:				; CODE XREF: sub_1000A8A8+38B7j
		mov	eax, [ebx+8]
		or	edi, 0FFFFFFFFh
		and	eax, [ebx+0Ch]
		mov	[esp+0CCh+var_9C], edi
		mov	[esp+0CCh+EndPtr], edi
		cmp	eax, edi
		jz	loc_1000E28E
		lea	eax, [esp+0CCh+var_88]
		push	eax		; char *
		lea	ecx, [esp+0D0h+var_A4]
		call	sub_1000E70F
		cmp	[esp+0CCh+var_A0], 0
		jz	short loc_1000E1AF
		lea	ecx, [esp+0CCh+var_A4]
		call	sub_1000E774
		jmp	loc_1000A9F7
; ---------------------------------------------------------------------------

loc_1000E1AF:				; CODE XREF: sub_1000A8A8+38F7j
		mov	edx, [esp+0CCh+lpFileName] ; lpFileName
		mov	ecx, [esp+0CCh+lpPath] ; lpPath
		call	sub_1000AD10
		push	0
		mov	esi, eax
		call	ds:??_V@YAXPAX@Z ; operator delete[](void *)
		pop	ecx
		test	esi, esi
		jz	loc_1000E112
		test	byte ptr [ebx+10h], 4
		jz	short loc_1000E1FF
		mov	ecx, esi	; lpFileName
		call	sub_1000E98B
		mov	edi, eax
		xor	eax, eax
		mov	[esp+0CCh+EndPtr], eax
		cmp	eax, [ebx+0Ch]
		jb	loc_1000E27A
		ja	short loc_1000E1F8
		cmp	edi, [ebx+8]
		jbe	loc_1000E27A

loc_1000E1F8:				; CODE XREF: sub_1000A8A8+3945j
		mov	[esp+0CCh+var_89], 1
		jmp	short loc_1000E27A
; ---------------------------------------------------------------------------

loc_1000E1FF:				; CODE XREF: sub_1000A8A8+392Bj
		lea	eax, [esp+0CCh+dwHandle]
		push	eax		; lpdwHandle
		push	esi		; lptstrFilename
		call	ds:GetFileVersionInfoSizeW
		mov	[esp+0CCh+dwLen], eax
		test	eax, eax
		jz	short loc_1000E27A
		push	eax
		call	ds:??_U@YAPAXI@Z ; operator new[](uint)
		pop	ecx
		mov	edi, eax
		push	edi		; lpData
		push	[esp+0D0h+dwLen] ; dwLen
		push	0		; dwHandle
		push	esi		; lptstrFilename
		call	ds:GetFileVersionInfoW
		test	eax, eax
		jz	short loc_1000E26E
		lea	eax, [esp+0CCh+puLen]
		push	eax		; puLen
		lea	eax, [esp+0D0h+lpBuffer]
		push	eax		; lplpBuffer
		push	offset SubBlock	; "\\"
		push	edi		; pBlock
		call	ds:VerQueryValueW
		test	eax, eax
		jz	short loc_1000E26E
		mov	eax, [esp+0CCh+lpBuffer]
		xor	ecx, ecx
		mov	edx, [eax+8]
		or	ecx, [eax+0Ch]
		mov	[esp+0CCh+var_9C], ecx
		mov	[esp+0CCh+EndPtr], edx
		cmp	edx, [ebx+0Ch]
		jb	short loc_1000E26E
		ja	short loc_1000E269
		cmp	ecx, [ebx+8]
		jbe	short loc_1000E26E

loc_1000E269:				; CODE XREF: sub_1000A8A8+39BAj
		mov	[esp+0CCh+var_89], 1

loc_1000E26E:				; CODE XREF: sub_1000A8A8+3985j
					; sub_1000A8A8+399Fj ...
		push	edi
		call	ds:??_V@YAXPAX@Z ; operator delete[](void *)
		mov	edi, [esp+0D0h+var_9C]
		pop	ecx

loc_1000E27A:				; CODE XREF: sub_1000A8A8+393Fj
					; sub_1000A8A8+394Aj ...
		lea	ecx, [esp+0CCh+var_A4]
		call	sub_1000E774
		cmp	[esp+0CCh+var_89], 0
		jnz	loc_1000A9F7

loc_1000E28E:				; CODE XREF: sub_1000A8A8+38DEj
		lea	eax, [esp+0CCh+var_88]
		push	eax		; char
		push	offset aLdrloaddllBl_0 ; "LdrLoadDll: Blocking load of '%s' -- se"...
		call	sub_1000EC1C
		push	[esp+0D4h+EndPtr]
		mov	ecx, [ebx]
		push	edi
		call	sub_1000E885
		push	esi
		call	ds:??_V@YAXPAX@Z ; operator delete[](void *)
		add	esp, 14h
		jmp	short loc_1000E2CF
; ---------------------------------------------------------------------------

loc_1000E2B5:				; CODE XREF: sub_1000A8A8+204j
		lea	eax, [esp+0CCh+var_88]
		push	eax		; char
		push	offset aLdrloaddllBloc ; "LdrLoadDll: Blocking load of '%s' (Sear"...
		call	sub_1000EC1C
		push	0

loc_1000E2C6:				; CODE XREF: sub_1000A8A8+3A41j
		call	ds:??_V@YAXPAX@Z ; operator delete[](void *)
		add	esp, 0Ch

loc_1000E2CF:				; CODE XREF: sub_1000A8A8+3A0Bj
		mov	eax, 0C0000135h
		jmp	loc_1000AA2F
; ---------------------------------------------------------------------------

loc_1000E2D9:				; CODE XREF: sub_1000A8A8+22Bj
		lea	eax, [esp+0CCh+var_88]
		push	eax		; char
		push	offset aLdrloaddllBl_1 ; "LdrLoadDll: Blocking load of '%s'.  XPC"...
		call	sub_1000EC1C
		push	esi
		jmp	short loc_1000E2C6
; END OF FUNCTION CHUNK	FOR sub_1000A8A8
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR moz_malloc_size_of

loc_1000E2EB:				; CODE XREF: moz_malloc_size_of+26j
		mov	edi, offset stru_1001AAB0
		mov	[ebp+var_C], esi
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		lea	edx, [ebp+var_1C]
		call	sub_10005E22
		test	eax, eax
		jz	short loc_1000E30B
		mov	esi, [eax+14h]
		jmp	short loc_1000E30D
; ---------------------------------------------------------------------------

loc_1000E30B:				; CODE XREF: moz_malloc_size_of+3586j
		xor	esi, esi

loc_1000E30D:				; CODE XREF: moz_malloc_size_of+358Bj
		push	edi		; lpCriticalSection
		call	ds:LeaveCriticalSection
		jmp	loc_1000ADB3
; END OF FUNCTION CHUNK	FOR moz_malloc_size_of
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000ADF0

loc_1000E319:				; CODE XREF: sub_1000ADF0+47j
					; sub_1000ADF0+3560j
		mov	eax, [eax]
		mov	ecx, esi
		mov	[esp+20h+var_8], eax
		mov	eax, edx
		shl	eax, cl
		mov	ecx, ebp
		sub	ecx, [esp+20h+var_8]
		shr	eax, cl
		mov	ecx, [esp+20h+var_10]
		mov	ecx, [ecx+eax*4]
		mov	[esp+20h+var_10], ecx
		test	ecx, ecx
		jz	short loc_1000E357
		mov	eax, [esp+20h+var_C]
		inc	ebx
		add	esi, [esp+20h+var_8]
		add	eax, 4
		mov	[esp+20h+var_C], eax
		cmp	ebx, [esp+20h+var_4]
		jb	short loc_1000E319
		jmp	loc_1000AE15
; ---------------------------------------------------------------------------

loc_1000E357:				; CODE XREF: sub_1000ADF0+354Aj
		xor	eax, eax
		jmp	loc_1000AE28
; END OF FUNCTION CHUNK	FOR sub_1000ADF0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000AE6E

loc_1000E35E:				; CODE XREF: sub_1000AE6E+3Ej
					; sub_1000AE6E+4Aj ...
		push	ebx
		push	0Ah
		push	edx
		push	ecx
		call	__aulldiv
		inc	edi
		mov	ecx, eax
		cmp	edx, 1634578h
		ja	short loc_1000E35E
		jb	loc_1000AEBE
		jmp	loc_1000AEB2
; ---------------------------------------------------------------------------

loc_1000E37E:				; CODE XREF: sub_1000AE6E+5Ej
		xor	eax, eax
		mov	[esi], ebx
		mov	[esi+4], ebx
		mov	[esi+8], ax
		mov	dword ptr [esi+0Ch], 3
		jmp	loc_1000AEDB
; END OF FUNCTION CHUNK	FOR sub_1000AE6E
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR mozPoisonValueInit

loc_1000E395:				; CODE XREF: mozPoisonValueInit+3Aj
		mov	edx, ebx
		mov	ecx, esi
		call	sub_10013F13
		test	al, al
		jz	short loc_1000E3BC
		test	edi, edi
		jz	loc_1000AF56
		push	8000h		; dwFreeType
		push	ebx		; dwSize
		push	edi		; lpAddress
		call	ds:VirtualFree
		jmp	loc_1000AF56
; ---------------------------------------------------------------------------

loc_1000E3BC:				; CODE XREF: mozPoisonValueInit+348Aj
		test	edi, edi
		jz	short loc_1000E3C7
		mov	esi, edi
		jmp	loc_1000AF56
; ---------------------------------------------------------------------------

loc_1000E3C7:				; CODE XREF: mozPoisonValueInit+34A8j
		push	1		; flProtect
		push	2000h		; flAllocationType
		push	ebx		; dwSize
		push	0		; lpAddress
		call	ds:VirtualAlloc
		mov	esi, eax
		test	esi, esi
		jnz	loc_1000AF56
		int	3		; Trap to Debugger
		push	3		; uExitCode
		mov	large dword ptr	ds:0, 0C4h
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:TerminateProcess
		int	3		; Trap to Debugger
; END OF FUNCTION CHUNK	FOR mozPoisonValueInit

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	sub_1000E3FC(int, char,	int, int, void *)
sub_1000E3FC	proc near		; CODE XREF: sub_1000E51F+18p
					; sub_1000E51F+DDp ...

var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	ebx
		mov	ebx, ecx
		push	esi
		push	edi
		mov	eax, [ebx+4]
		cmp	eax, 0AAAAAA9h
		jb	short loc_1000E423
		push	[ebp+arg_10]	; void *
		call	free
		mov	[esp+10h+var_10], offset aMapSetTTooLong ; "map/set<T> too long"
		call	ds:?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)

loc_1000E423:				; CODE XREF: sub_1000E3FC+10j
		mov	edi, [ebp+arg_10]
		inc	eax
		mov	[ebx+4], eax
		mov	eax, [ebp+arg_8]
		mov	[edi+4], eax
		mov	ecx, [ebx]
		cmp	eax, ecx
		jnz	short loc_1000E444
		mov	[ecx+4], edi
		mov	eax, [ebx]
		mov	[eax], edi
		mov	eax, [ebx]
		mov	[eax+8], edi
		jmp	short loc_1000E463
; ---------------------------------------------------------------------------

loc_1000E444:				; CODE XREF: sub_1000E3FC+38j
		cmp	[ebp+arg_4], 0
		jz	short loc_1000E456
		mov	[eax], edi
		mov	ecx, [ebx]
		cmp	eax, [ecx]
		jnz	short loc_1000E463
		mov	[ecx], edi
		jmp	short loc_1000E463
; ---------------------------------------------------------------------------

loc_1000E456:				; CODE XREF: sub_1000E3FC+4Cj
		mov	[eax+8], edi
		mov	ecx, [ebx]
		cmp	eax, [ecx+8]
		jnz	short loc_1000E463
		mov	[ecx+8], edi

loc_1000E463:				; CODE XREF: sub_1000E3FC+46j
					; sub_1000E3FC+54j ...
		mov	eax, [edi+4]
		mov	esi, edi
		jmp	loc_1000E500
; ---------------------------------------------------------------------------

loc_1000E46D:				; CODE XREF: sub_1000E3FC+108j
		mov	eax, [esi+4]
		mov	edx, [eax+4]
		mov	ecx, [edx]
		cmp	eax, ecx
		jnz	short loc_1000E4B1
		mov	ecx, [edx+8]
		cmp	byte ptr [ecx+0Ch], 0
		jz	short loc_1000E4B7
		cmp	esi, [eax+8]
		jnz	short loc_1000E491
		mov	esi, eax
		mov	ecx, ebx
		push	esi
		call	sub_1000EB79

loc_1000E491:				; CODE XREF: sub_1000E3FC+89j
		mov	eax, [esi+4]
		mov	ecx, ebx
		mov	byte ptr [eax+0Ch], 1
		mov	eax, [esi+4]
		mov	eax, [eax+4]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [esi+4]
		push	dword ptr [eax+4]
		call	sub_1000EBD9
		jmp	short loc_1000E4FD
; ---------------------------------------------------------------------------

loc_1000E4B1:				; CODE XREF: sub_1000E3FC+7Bj
		cmp	byte ptr [ecx+0Ch], 0
		jnz	short loc_1000E4D1

loc_1000E4B7:				; CODE XREF: sub_1000E3FC+84j
		mov	byte ptr [eax+0Ch], 1
		mov	byte ptr [ecx+0Ch], 1
		mov	eax, [esi+4]
		mov	eax, [eax+4]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [esi+4]
		mov	esi, [eax+4]
		jmp	short loc_1000E4FD
; ---------------------------------------------------------------------------

loc_1000E4D1:				; CODE XREF: sub_1000E3FC+B9j
		cmp	esi, [eax]
		jnz	short loc_1000E4DF
		mov	esi, eax
		mov	ecx, ebx
		push	esi
		call	sub_1000EBD9

loc_1000E4DF:				; CODE XREF: sub_1000E3FC+D7j
		mov	eax, [esi+4]
		mov	ecx, ebx
		mov	byte ptr [eax+0Ch], 1
		mov	eax, [esi+4]
		mov	eax, [eax+4]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [esi+4]
		push	dword ptr [eax+4]
		call	sub_1000EB79

loc_1000E4FD:				; CODE XREF: sub_1000E3FC+B3j
					; sub_1000E3FC+D3j
		mov	eax, [esi+4]

loc_1000E500:				; CODE XREF: sub_1000E3FC+6Cj
		cmp	byte ptr [eax+0Ch], 0
		jz	loc_1000E46D
		mov	eax, [ebx]
		mov	eax, [eax+4]
		mov	byte ptr [eax+0Ch], 1
		mov	eax, [ebp+arg_0]
		mov	[eax], edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ebp
		retn	14h
sub_1000E3FC	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_1000E51F(int, int,	int, int, void *)
sub_1000E51F	proc near		; CODE XREF: sub_1000E6CF+32p

var_8		= dword	ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ecx
		push	ecx
		push	edi
		mov	edi, ecx
		cmp	dword ptr [edi+4], 0
		jnz	short loc_1000E545
		push	[esp+0Ch+arg_C]	; void *
		push	ecx		; int
		push	dword ptr [edi]	; int
		push	1		; char
		push	[esp+1Ch+arg_0]	; int
		call	sub_1000E3FC
		mov	eax, [esp+0Ch+arg_0]
		jmp	loc_1000E624
; ---------------------------------------------------------------------------

loc_1000E545:				; CODE XREF: sub_1000E51F+9j
		push	ebx
		mov	ebx, [esp+10h+arg_8]
		push	ebp
		mov	ebp, [edi]
		push	esi
		mov	esi, [esp+18h+arg_4]
		cmp	esi, [ebp+0]
		jnz	short loc_1000E56D
		mov	eax, [ebx]
		cmp	eax, [esi+10h]
		jnb	loc_1000E607
		push	[esp+18h+arg_C]
		push	ecx

loc_1000E567:				; CODE XREF: sub_1000E51F+99j
		push	esi
		jmp	loc_1000E5F6
; ---------------------------------------------------------------------------

loc_1000E56D:				; CODE XREF: sub_1000E51F+36j
		cmp	esi, ebp
		jnz	short loc_1000E58B
		mov	ecx, [ebp+8]
		mov	eax, [ecx+10h]
		cmp	eax, [ebx]
		jnb	loc_1000E607
		push	[esp+18h+arg_C]
		push	ecx
		push	ecx
		push	0
		mov	ecx, edi
		jmp	short loc_1000E5F8
; ---------------------------------------------------------------------------

loc_1000E58B:				; CODE XREF: sub_1000E51F+50j
		mov	eax, [ebx]
		cmp	[esi+10h], eax
		jbe	short loc_1000E5C2
		lea	ecx, [esp+18h+arg_8]
		mov	[esp+18h+arg_8], esi
		call	sub_1000E843
		mov	eax, [esp+18h+arg_8]
		mov	ecx, [ebx]
		cmp	[eax+10h], ecx
		jnb	short loc_1000E5BD
		mov	ecx, [eax+8]
		push	[esp+18h+arg_C]
		push	ecx
		cmp	byte ptr [ecx+0Dh], 0
		mov	ecx, edi
		jz	short loc_1000E567
		push	eax
		jmp	short loc_1000E5F1
; ---------------------------------------------------------------------------

loc_1000E5BD:				; CODE XREF: sub_1000E51F+89j
		mov	eax, ecx
		cmp	[esi+10h], eax

loc_1000E5C2:				; CODE XREF: sub_1000E51F+71j
		jnb	short loc_1000E607
		lea	ecx, [esp+18h+arg_8]
		mov	[esp+18h+arg_8], esi
		call	sub_1000E80C
		mov	eax, [esp+18h+arg_8]
		cmp	eax, ebp
		jz	short loc_1000E5E0
		mov	ecx, [ebx]
		cmp	ecx, [eax+10h]
		jnb	short loc_1000E607

loc_1000E5E0:				; CODE XREF: sub_1000E51F+B8j
		mov	ecx, [esi+8]
		push	[esp+18h+arg_C]	; void *
		push	ecx		; int
		cmp	byte ptr [ecx+0Dh], 0
		mov	ecx, edi
		jz	short loc_1000E5F5
		push	esi

loc_1000E5F1:				; CODE XREF: sub_1000E51F+9Cj
		push	0
		jmp	short loc_1000E5F8
; ---------------------------------------------------------------------------

loc_1000E5F5:				; CODE XREF: sub_1000E51F+CFj
		push	eax		; int

loc_1000E5F6:				; CODE XREF: sub_1000E51F+49j
		push	1		; char

loc_1000E5F8:				; CODE XREF: sub_1000E51F+6Aj
					; sub_1000E51F+D4j
		push	[esp+28h+arg_0]	; int
		call	sub_1000E3FC
		mov	eax, [esp+18h+arg_0]
		jmp	short loc_1000E621
; ---------------------------------------------------------------------------

loc_1000E607:				; CODE XREF: sub_1000E51F+3Dj
					; sub_1000E51F+5Aj ...
		push	[esp+18h+arg_C]	; void *
		lea	eax, [esp+1Ch+var_8]
		push	ebx		; int
		push	ecx		; int
		push	eax		; int
		mov	ecx, edi
		call	sub_1000E62A
		mov	ecx, [eax]
		mov	eax, [esp+18h+arg_0]
		mov	[eax], ecx

loc_1000E621:				; CODE XREF: sub_1000E51F+E6j
		pop	esi
		pop	ebp
		pop	ebx

loc_1000E624:				; CODE XREF: sub_1000E51F+21j
		pop	edi
		pop	ecx
		pop	ecx
		retn	10h
sub_1000E51F	endp


; =============== S U B	R O U T	I N E =======================================


; int __stdcall	sub_1000E62A(int, int, int, void *)
sub_1000E62A	proc near		; CODE XREF: sub_1000E51F+F5p

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ecx
		push	ebx
		mov	ebx, [esp+8+arg_8]
		mov	dl, 1
		push	ebp
		mov	ebp, ecx
		mov	byte ptr [esp+0Ch+var_4], dl
		push	esi
		push	edi
		mov	ecx, [ebp+0]
		mov	edi, ecx
		mov	eax, [ecx+4]
		cmp	byte ptr [eax+0Dh], 0
		jnz	short loc_1000E667
		mov	esi, [ebx]

loc_1000E64B:				; CODE XREF: sub_1000E62A+3Bj
		mov	edi, eax
		cmp	esi, [eax+10h]
		jnb	short loc_1000E658
		mov	eax, [eax]
		mov	dl, 1
		jmp	short loc_1000E65D
; ---------------------------------------------------------------------------

loc_1000E658:				; CODE XREF: sub_1000E62A+26j
		mov	eax, [eax+8]
		xor	dl, dl

loc_1000E65D:				; CODE XREF: sub_1000E62A+2Cj
		cmp	byte ptr [eax+0Dh], 0
		mov	byte ptr [esp+14h+var_4], dl
		jz	short loc_1000E64B

loc_1000E667:				; CODE XREF: sub_1000E62A+1Dj
		mov	esi, edi
		mov	[esp+14h+arg_8], esi
		test	dl, dl
		jz	short loc_1000E6A4
		cmp	edi, [ecx]
		jnz	short loc_1000E697
		push	[esp+14h+arg_C]	; void *
		push	ecx		; int
		push	edi		; int
		push	1		; char

loc_1000E67D:				; CODE XREF: sub_1000E62A+8Bj
		lea	eax, [esp+24h+arg_C]
		mov	ecx, ebp
		push	eax		; int
		call	sub_1000E3FC
		mov	ecx, [eax]
		mov	eax, [esp+14h+arg_0]
		mov	[eax], ecx
		mov	byte ptr [eax+4], 1
		jmp	short loc_1000E6C7
; ---------------------------------------------------------------------------

loc_1000E697:				; CODE XREF: sub_1000E62A+49j
		lea	ecx, [esp+14h+arg_8]
		call	sub_1000E843
		mov	esi, [esp+14h+arg_8]

loc_1000E6A4:				; CODE XREF: sub_1000E62A+45j
		mov	eax, [esi+10h]
		push	[esp+14h+arg_C]	; void *
		cmp	eax, [ebx]
		jnb	short loc_1000E6B7
		push	ecx
		push	edi
		push	[esp+20h+var_4]
		jmp	short loc_1000E67D
; ---------------------------------------------------------------------------

loc_1000E6B7:				; CODE XREF: sub_1000E62A+83j
		call	free
		mov	eax, [esp+18h+arg_0]
		pop	ecx
		mov	[eax], esi
		mov	byte ptr [eax+4], 0

loc_1000E6C7:				; CODE XREF: sub_1000E62A+6Bj
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn	10h
sub_1000E62A	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_1000E6CF(int, int,	int, int, int, int)
sub_1000E6CF	proc near		; CODE XREF: sub_1000E7AB+4Fp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_C		= dword	ptr  10h

		push	esi
		push	edi
		mov	edi, ecx
		call	sub_1000EB44
		mov	esi, eax
		lea	edx, [esi+10h]
		mov	word ptr [esi+0Ch], 0
		test	edx, edx
		jz	short loc_1000E6F5
		mov	ecx, [esp+8+arg_C]
		mov	ecx, [ecx]
		mov	eax, [ecx]
		and	dword ptr [edx+4], 0
		mov	[edx], eax

loc_1000E6F5:				; CODE XREF: sub_1000E6CF+16j
		push	esi		; void *
		push	edx		; int
		push	[esp+10h+arg_4]	; int
		mov	ecx, edi	; int
		push	[esp+14h+arg_0]	; int
		call	sub_1000E51F
		mov	eax, [esp+8+arg_0]
		pop	edi
		pop	esi
		retn	14h
sub_1000E6CF	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	sub_1000E70F(char *)
sub_1000E70F	proc near		; CODE XREF: sub_1000A8A8+38EDp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ebx
		push	esi
		push	edi
		mov	esi, ecx
		call	ds:GetCurrentThreadId
		mov	ebx, offset CriticalSection
		mov	[ebp+var_4], eax
		push	ebx		; lpCriticalSection
		call	ds:EnterCriticalSection
		lea	eax, [ebp+var_4]
		push	eax
		call	sub_1000E7AB
		mov	edi, [ebp+arg_0]
		mov	eax, [eax]
		mov	[esi], eax
		test	eax, eax
		jz	short loc_1000E752
		push	edi		; char *
		push	eax		; char *
		call	ds:_stricmp
		pop	ecx
		pop	ecx
		test	eax, eax
		jnz	short loc_1000E752
		inc	eax
		jmp	short loc_1000E754
; ---------------------------------------------------------------------------

loc_1000E752:				; CODE XREF: sub_1000E70F+30j
					; sub_1000E70F+3Ej
		xor	eax, eax

loc_1000E754:				; CODE XREF: sub_1000E70F+41j
		mov	[esi+4], al
		lea	eax, [ebp+var_4]
		push	eax
		call	sub_1000E7AB
		push	ebx		; lpCriticalSection
		mov	[eax], edi
		call	ds:LeaveCriticalSection
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
sub_1000E70F	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000E774	proc near		; CODE XREF: sub_1000A8A8+387Fp
					; sub_1000A8A8+38FDp ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		push	edi
		mov	esi, ecx
		call	ds:GetCurrentThreadId
		mov	edi, offset CriticalSection
		mov	[ebp+var_4], eax
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		lea	eax, [ebp+var_4]
		push	eax
		call	sub_1000E7AB
		mov	ecx, [esi]
		push	edi		; lpCriticalSection
		mov	[eax], ecx
		call	ds:LeaveCriticalSection
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
sub_1000E774	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000E7AB	proc near		; CODE XREF: sub_1000E70F+22p
					; sub_1000E70F+4Cp ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	esi, [ebp+arg_0]
		push	edi
		mov	edi, dword_1001A804
		mov	edx, [edi]
		mov	eax, edx
		mov	ecx, [edx+4]
		cmp	byte ptr [ecx+0Dh], 0
		jnz	short loc_1000E7DF
		push	ebx
		mov	ebx, [esi]

loc_1000E7CA:				; CODE XREF: sub_1000E7AB+31j
		cmp	[ecx+10h], ebx
		jnb	short loc_1000E7D4
		mov	ecx, [ecx+8]
		jmp	short loc_1000E7D8
; ---------------------------------------------------------------------------

loc_1000E7D4:				; CODE XREF: sub_1000E7AB+22j
		mov	eax, ecx
		mov	ecx, [ecx]

loc_1000E7D8:				; CODE XREF: sub_1000E7AB+27j
		cmp	byte ptr [ecx+0Dh], 0
		jz	short loc_1000E7CA
		pop	ebx

loc_1000E7DF:				; CODE XREF: sub_1000E7AB+1Aj
		cmp	eax, edx
		jz	short loc_1000E7EA
		mov	ecx, [esi]
		cmp	ecx, [eax+10h]
		jnb	short loc_1000E801

loc_1000E7EA:				; CODE XREF: sub_1000E7AB+36j
		push	ecx		; int
		lea	ecx, [ebp+arg_0]
		mov	[ebp+arg_0], esi
		push	ecx		; int
		push	ecx		; int
		push	eax		; int
		lea	eax, [ebp+var_4]
		mov	ecx, edi	; int
		push	eax		; int
		call	sub_1000E6CF
		mov	eax, [eax]

loc_1000E801:				; CODE XREF: sub_1000E7AB+3Dj
		pop	edi
		add	eax, 14h
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn	4
sub_1000E7AB	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000E80C	proc near		; CODE XREF: sub_1000E51F+ADp
		push	esi
		mov	esi, ecx
		mov	ecx, [esi]
		cmp	byte ptr [ecx+0Dh], 0
		jnz	short loc_1000E83F
		mov	eax, [ecx+8]
		cmp	byte ptr [eax+0Dh], 0
		jnz	short loc_1000E834
		mov	ecx, eax
		call	sub_1000EBCA
		mov	[esi], eax
		jmp	short loc_1000E83F
; ---------------------------------------------------------------------------

loc_1000E82B:				; CODE XREF: sub_1000E80C+2Fj
		mov	eax, [esi]
		cmp	eax, [ecx+8]
		jnz	short loc_1000E83D
		mov	[esi], ecx

loc_1000E834:				; CODE XREF: sub_1000E80C+12j
		mov	ecx, [ecx+4]
		cmp	byte ptr [ecx+0Dh], 0
		jz	short loc_1000E82B

loc_1000E83D:				; CODE XREF: sub_1000E80C+24j
		mov	[esi], ecx

loc_1000E83F:				; CODE XREF: sub_1000E80C+9j
					; sub_1000E80C+1Dj
		mov	eax, esi
		pop	esi
		retn
sub_1000E80C	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000E843	proc near		; CODE XREF: sub_1000E51F+7Bp
					; sub_1000E62A+71p
		push	esi
		mov	esi, ecx
		mov	ecx, [esi]
		cmp	byte ptr [ecx+0Dh], 0
		jz	short loc_1000E853
		mov	eax, [ecx+8]
		jmp	short loc_1000E862
; ---------------------------------------------------------------------------

loc_1000E853:				; CODE XREF: sub_1000E843+9j
		mov	eax, [ecx]
		cmp	byte ptr [eax+0Dh], 0
		jnz	short loc_1000E86E
		mov	ecx, eax
		call	sub_1000EBBA

loc_1000E862:				; CODE XREF: sub_1000E843+Ej
		mov	[esi], eax
		jmp	short loc_1000E881
; ---------------------------------------------------------------------------

loc_1000E866:				; CODE XREF: sub_1000E843+32j
		mov	eax, [esi]
		cmp	eax, [ecx]
		jnz	short loc_1000E877
		mov	[esi], ecx

loc_1000E86E:				; CODE XREF: sub_1000E843+16j
		mov	ecx, [ecx+4]
		cmp	byte ptr [ecx+0Dh], 0
		jz	short loc_1000E866

loc_1000E877:				; CODE XREF: sub_1000E843+27j
		mov	eax, [esi]
		cmp	byte ptr [eax+0Dh], 0
		jnz	short loc_1000E881
		mov	[esi], ecx

loc_1000E881:				; CODE XREF: sub_1000E843+21j
					; sub_1000E843+3Aj
		mov	eax, esi
		pop	esi
		retn
sub_1000E843	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000E885	proc near		; CODE XREF: sub_1000A8A8+39FCp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	ebp
		push	esi
		push	edi
		push	offset CriticalSection ; lpCriticalSection
		mov	ebp, ecx
		call	ds:EnterCriticalSection
		mov	eax, dword_1001AC90
		mov	esi, [esp+10h+arg_4]
		mov	edi, [esp+10h+arg_0]
		jmp	short loc_1000E8DF
; ---------------------------------------------------------------------------

loc_1000E8A5:				; CODE XREF: sub_1000E885+5Cj
		mov	ecx, [eax]
		mov	edx, ebp

loc_1000E8A9:				; CODE XREF: sub_1000E885+3Ej
		mov	bl, [ecx]
		cmp	bl, [edx]
		jnz	short loc_1000E8C9
		test	bl, bl
		jz	short loc_1000E8C5
		mov	bl, [ecx+1]
		cmp	bl, [edx+1]
		jnz	short loc_1000E8C9
		add	ecx, 2
		add	edx, 2
		test	bl, bl
		jnz	short loc_1000E8A9

loc_1000E8C5:				; CODE XREF: sub_1000E885+2Cj
		xor	ecx, ecx
		jmp	short loc_1000E8CE
; ---------------------------------------------------------------------------

loc_1000E8C9:				; CODE XREF: sub_1000E885+28j
					; sub_1000E885+34j
		sbb	ecx, ecx
		or	ecx, 1

loc_1000E8CE:				; CODE XREF: sub_1000E885+42j
		test	ecx, ecx
		jnz	short loc_1000E8DC
		cmp	[eax+8], edi
		jnz	short loc_1000E8DC
		cmp	[eax+0Ch], esi
		jz	short loc_1000E90F

loc_1000E8DC:				; CODE XREF: sub_1000E885+4Bj
					; sub_1000E885+50j
		mov	eax, [eax+10h]

loc_1000E8DF:				; CODE XREF: sub_1000E885+1Ej
		test	eax, eax
		jnz	short loc_1000E8A5
		push	18h
		call	moz_xmalloc
		pop	ecx
		mov	ecx, eax
		test	ecx, ecx
		jz	short loc_1000E8FF
		and	dword ptr [ecx+10h], 0
		mov	[ecx], ebp
		mov	[ecx+8], edi
		mov	[ecx+0Ch], esi
		jmp	short loc_1000E901
; ---------------------------------------------------------------------------

loc_1000E8FF:				; CODE XREF: sub_1000E885+6Aj
		xor	ecx, ecx

loc_1000E901:				; CODE XREF: sub_1000E885+78j
		mov	eax, dword_1001AC90
		mov	[ecx+10h], eax
		mov	dword_1001AC90,	ecx

loc_1000E90F:				; CODE XREF: sub_1000E885+55j
		push	offset CriticalSection ; lpCriticalSection
		call	ds:LeaveCriticalSection
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
sub_1000E885	endp

; Exported entry  33. ?DllBlocklist_WriteNotes@@YAXPAX@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl DllBlocklist_WriteNotes(HANDLE hFile)
		public ?DllBlocklist_WriteNotes@@YAXPAX@Z
?DllBlocklist_WriteNotes@@YAXPAX@Z proc	near ; DATA XREF: .rdata:off_100175A8o

NumberOfBytesWritten= dword ptr	-4
hFile		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ebx
		push	esi
		mov	esi, [ebp+hFile]
		lea	eax, [ebp+NumberOfBytesWritten]
		push	edi
		mov	edi, ds:WriteFile
		xor	ebx, ebx
		push	ebx		; lpOverlapped
		push	eax		; lpNumberOfBytesWritten
		push	0Fh		; nNumberOfBytesToWrite
		push	offset aBlockeddlllist ; "BlockedDllList="
		push	esi		; hFile
		call	edi ; WriteFile
		mov	ecx, esi
		call	sub_1000EA23
		push	ebx		; lpOverlapped
		lea	eax, [ebp+NumberOfBytesWritten]
		push	eax		; lpNumberOfBytesWritten
		push	1		; nNumberOfBytesToWrite
		push	offset asc_1001705C ; "\n"
		push	esi		; hFile
		call	edi ; WriteFile
		cmp	byte_1001AAA1, bl
		jz	short loc_1000E96D
		push	ebx		; lpOverlapped
		lea	eax, [ebp+NumberOfBytesWritten]
		push	eax		; lpNumberOfBytesWritten
		push	16h		; nNumberOfBytesToWrite
		push	offset aBlocklistinitf ; "BlocklistInitFailed=1\n"
		push	esi		; hFile
		call	edi ; WriteFile

loc_1000E96D:				; CODE XREF: DllBlocklist_WriteNotes(void *)+3Dj
		cmp	byte_1001AAA0, bl
		jz	short loc_1000E984
		push	ebx		; lpOverlapped
		lea	eax, [ebp+NumberOfBytesWritten]
		push	eax		; lpNumberOfBytesWritten
		push	18h		; nNumberOfBytesToWrite
		push	offset aUser32beforebl ; "User32BeforeBlocklist=1\n"
		push	esi		; hFile
		call	edi ; WriteFile

loc_1000E984:				; CODE XREF: DllBlocklist_WriteNotes(void *)+54j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?DllBlocklist_WriteNotes@@YAXPAX@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall sub_1000E98B(LPCWSTR lpFileName)
sub_1000E98B	proc near		; CODE XREF: sub_1000A8A8+392Fp

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
lpBaseAddress	= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	ebx
		push	esi
		xor	esi, esi
		push	esi		; hTemplateFile
		push	80h		; dwFlagsAndAttributes
		push	3		; dwCreationDisposition
		push	esi		; lpSecurityAttributes
		push	1		; dwShareMode
		push	80000000h	; dwDesiredAccess
		push	ecx		; lpFileName
		call	ds:CreateFileW
		mov	ebx, eax
		cmp	ebx, 0FFFFFFFFh
		jz	short loc_1000EA1B
		push	edi
		push	esi		; lpName
		push	esi		; dwMaximumSizeLow
		push	esi		; dwMaximumSizeHigh
		push	2		; flProtect
		push	esi		; lpFileMappingAttributes
		push	ebx		; hFile
		call	ds:CreateFileMappingW
		mov	edi, eax
		test	edi, edi
		jz	short loc_1000EA13
		push	ecx		; int
		push	edi		; hFileMappingObject
		lea	ecx, [ebp+var_10]
		call	sub_1000ACC2
		mov	eax, [ebp+var_10]
		test	eax, eax
		jz	short loc_1000E9FD
		push	dword ptr [eax+3Ch] ; int
		lea	ecx, [ebp+var_8]
		push	edi		; hFileMappingObject
		call	sub_1000AC6A
		mov	eax, [ebp+var_8]
		test	eax, eax
		jz	short loc_1000E9EE
		mov	esi, [eax+8]

loc_1000E9EE:				; CODE XREF: sub_1000E98B+5Ej
		cmp	[ebp+lpBaseAddress], 0
		jz	short loc_1000E9FD
		push	[ebp+lpBaseAddress] ; lpBaseAddress
		call	ds:UnmapViewOfFile

loc_1000E9FD:				; CODE XREF: sub_1000E98B+4Bj
					; sub_1000E98B+67j
		push	edi		; hObject
		call	ds:CloseHandle
		cmp	[ebp+var_C], 0
		jz	short loc_1000EA13
		push	[ebp+var_C]	; lpBaseAddress
		call	ds:UnmapViewOfFile

loc_1000EA13:				; CODE XREF: sub_1000E98B+3Aj
					; sub_1000E98B+7Dj
		push	ebx		; hObject
		call	ds:CloseHandle
		pop	edi

loc_1000EA1B:				; CODE XREF: sub_1000E98B+26j
		mov	eax, esi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
sub_1000E98B	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000EA23	proc near		; CODE XREF: DllBlocklist_WriteNotes(void *)+23p

lpCriticalSection= dword ptr -54h
var_50		= dword	ptr -50h
hFile		= dword	ptr -4Ch
NumberOfBytesWritten= dword ptr	-48h
Buffer		= byte ptr -44h
var_24		= word ptr -24h
var_22		= word ptr -22h
var_20		= word ptr -20h
var_1E		= word ptr -1Eh
ms_exc		= CPPEH_RECORD ptr -18h

		push	44h
		push	offset stru_10017560
		call	__SEH_prolog4_GS
		mov	edi, ecx
		mov	[ebp+hFile], edi
		mov	eax, offset CriticalSection
		mov	[ebp+lpCriticalSection], eax
		push	eax		; lpCriticalSection
		call	ds:EnterCriticalSection
		and	[ebp+ms_exc.registration.TryLevel], 0
		mov	esi, dword_1001AC90
		mov	ebx, ds:WriteFile

loc_1000EA53:				; CODE XREF: sub_1000EA23+FFj
		test	esi, esi
		jz	loc_1000EB2E
		mov	ecx, [esi]
		lea	edx, [ecx+1]

loc_1000EA60:				; CODE XREF: sub_1000EA23+42j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1000EA60
		sub	ecx, edx
		push	0		; lpOverlapped
		lea	eax, [ebp+NumberOfBytesWritten]
		push	eax		; lpNumberOfBytesWritten
		push	ecx		; nNumberOfBytesToWrite
		push	dword ptr [esi]	; lpBuffer
		push	edi		; hFile
		call	ebx ; WriteFile
		mov	eax, [esi+8]
		and	eax, [esi+0Ch]
		cmp	eax, 0FFFFFFFFh
		jz	loc_1000EB0F
		push	0		; lpOverlapped
		lea	eax, [ebp+NumberOfBytesWritten]
		push	eax		; lpNumberOfBytesWritten
		push	1		; nNumberOfBytesToWrite
		push	offset asc_10016F64 ; lpBuffer
		push	edi		; hFile
		call	ebx ; WriteFile
		mov	ax, [esi+0Eh]
		mov	[ebp+var_24], ax
		mov	ax, [esi+0Ch]
		mov	[ebp+var_22], ax
		mov	ax, [esi+0Ah]
		mov	[ebp+var_20], ax
		mov	ax, [esi+8]
		mov	[ebp+var_1E], ax
		xor	edi, edi

loc_1000EAB6:				; CODE XREF: sub_1000EA23+E7j
		mov	[ebp+var_50], edi
		cmp	edi, 4
		jge	short loc_1000EB0C
		push	0Ah		; int
		lea	eax, [ebp+Buffer]
		push	eax		; char *
		movzx	eax, [ebp+edi*2+var_24]
		push	eax		; __int32
		call	ds:_ltoa
		add	esp, 0Ch
		lea	ecx, [ebp+Buffer]
		lea	edx, [ecx+1]

loc_1000EAD9:				; CODE XREF: sub_1000EA23+BBj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1000EAD9
		sub	ecx, edx
		push	0		; lpOverlapped
		lea	eax, [ebp+NumberOfBytesWritten]
		push	eax		; lpNumberOfBytesWritten
		push	ecx		; nNumberOfBytesToWrite
		lea	eax, [ebp+Buffer]
		push	eax		; lpBuffer
		push	[ebp+hFile]	; hFile
		call	ebx ; WriteFile
		cmp	edi, 3
		jz	short loc_1000EB09
		push	0		; lpOverlapped
		lea	eax, [ebp+NumberOfBytesWritten]
		push	eax		; lpNumberOfBytesWritten
		push	1		; nNumberOfBytesToWrite
		push	offset a_	; lpBuffer
		push	[ebp+hFile]	; hFile
		call	ebx ; WriteFile

loc_1000EB09:				; CODE XREF: sub_1000EA23+D2j
		inc	edi
		jmp	short loc_1000EAB6
; ---------------------------------------------------------------------------

loc_1000EB0C:				; CODE XREF: sub_1000EA23+99j
		mov	edi, [ebp+hFile]

loc_1000EB0F:				; CODE XREF: sub_1000EA23+5Bj
		push	0		; lpOverlapped
		lea	eax, [ebp+NumberOfBytesWritten]
		push	eax		; lpNumberOfBytesWritten
		push	1		; nNumberOfBytesToWrite
		push	offset asc_10016F6C ; lpBuffer
		push	edi		; hFile
		call	ebx ; WriteFile
		mov	esi, [esi+10h]
		jmp	loc_1000EA53
; ---------------------------------------------------------------------------

loc_1000EB27:				; DATA XREF: .rdata:stru_10017560o
		xor	eax, eax	; Exception filter 0 for function 1000EA23
		inc	eax
		retn
; ---------------------------------------------------------------------------

loc_1000EB2B:				; DATA XREF: .rdata:stru_10017560o
		mov	esp, [ebp+ms_exc.old_esp] ; Exception handler 0	for function 1000EA23

loc_1000EB2E:				; CODE XREF: sub_1000EA23+32j
		mov	[ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh
		push	[ebp+lpCriticalSection]	; lpCriticalSection
		call	ds:LeaveCriticalSection
		call	__SEH_epilog4_GS
		retn
sub_1000EA23	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000EB44	proc near		; CODE XREF: sub_1000E6CF+4p
		push	esi
		push	18h
		mov	esi, ecx
		call	moz_xmalloc
		mov	edx, eax
		pop	ecx
		test	edx, edx
		jnz	short loc_1000EB5B
		call	ds:?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)

loc_1000EB5B:				; CODE XREF: sub_1000EB44+Fj
		mov	eax, [esi]
		lea	ecx, [edx+4]
		mov	[edx], eax
		test	ecx, ecx
		jz	short loc_1000EB6A
		mov	eax, [esi]
		mov	[ecx], eax

loc_1000EB6A:				; CODE XREF: sub_1000EB44+20j
		lea	ecx, [edx+8]
		test	ecx, ecx
		jz	short loc_1000EB75
		mov	eax, [esi]
		mov	[ecx], eax

loc_1000EB75:				; CODE XREF: sub_1000EB44+2Bj
		mov	eax, edx
		pop	esi
		retn
sub_1000EB44	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000EB79	proc near		; CODE XREF: sub_1000E3FC+90p
					; sub_1000E3FC+FCp

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		push	esi
		mov	esi, [edx+8]
		mov	eax, [esi]
		mov	[edx+8], eax
		mov	eax, [esi]
		cmp	byte ptr [eax+0Dh], 0
		jnz	short loc_1000EB91
		mov	[eax+4], edx

loc_1000EB91:				; CODE XREF: sub_1000EB79+13j
		mov	eax, [edx+4]
		mov	[esi+4], eax
		mov	eax, [ecx]
		cmp	edx, [eax+4]
		jnz	short loc_1000EBA3
		mov	[eax+4], esi
		jmp	short loc_1000EBB1
; ---------------------------------------------------------------------------

loc_1000EBA3:				; CODE XREF: sub_1000EB79+23j
		mov	eax, [edx+4]
		cmp	edx, [eax]
		jnz	short loc_1000EBAE
		mov	[eax], esi
		jmp	short loc_1000EBB1
; ---------------------------------------------------------------------------

loc_1000EBAE:				; CODE XREF: sub_1000EB79+2Fj
		mov	[eax+8], esi

loc_1000EBB1:				; CODE XREF: sub_1000EB79+28j
					; sub_1000EB79+33j
		mov	[esi], edx
		mov	[edx+4], esi
		pop	esi
		retn	4
sub_1000EB79	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000EBBA	proc near		; CODE XREF: sub_1000E843+1Ap
		jmp	short loc_1000EBBE
; ---------------------------------------------------------------------------

loc_1000EBBC:				; CODE XREF: sub_1000EBBA+Bj
		mov	ecx, eax

loc_1000EBBE:				; CODE XREF: sub_1000EBBAj
		mov	eax, [ecx+8]
		cmp	byte ptr [eax+0Dh], 0
		jz	short loc_1000EBBC
		mov	eax, ecx
		retn
sub_1000EBBA	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000EBCA	proc near		; CODE XREF: sub_1000E80C+16p
		jmp	short loc_1000EBCE
; ---------------------------------------------------------------------------

loc_1000EBCC:				; CODE XREF: sub_1000EBCA+Aj
		mov	ecx, eax

loc_1000EBCE:				; CODE XREF: sub_1000EBCAj
		mov	eax, [ecx]
		cmp	byte ptr [eax+0Dh], 0
		jz	short loc_1000EBCC
		mov	eax, ecx
		retn
sub_1000EBCA	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000EBD9	proc near		; CODE XREF: sub_1000E3FC+AEp
					; sub_1000E3FC+DEp

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		push	esi
		mov	esi, [edx]
		mov	eax, [esi+8]
		mov	[edx], eax
		mov	eax, [esi+8]
		cmp	byte ptr [eax+0Dh], 0
		jnz	short loc_1000EBF1
		mov	[eax+4], edx

loc_1000EBF1:				; CODE XREF: sub_1000EBD9+13j
		mov	eax, [edx+4]
		mov	[esi+4], eax
		mov	eax, [ecx]
		cmp	edx, [eax+4]
		jnz	short loc_1000EC03
		mov	[eax+4], esi
		jmp	short loc_1000EC12
; ---------------------------------------------------------------------------

loc_1000EC03:				; CODE XREF: sub_1000EBD9+23j
		mov	eax, [edx+4]
		cmp	edx, [eax+8]
		jnz	short loc_1000EC10
		mov	[eax+8], esi
		jmp	short loc_1000EC12
; ---------------------------------------------------------------------------

loc_1000EC10:				; CODE XREF: sub_1000EBD9+30j
		mov	[eax], esi

loc_1000EC12:				; CODE XREF: sub_1000EBD9+28j
					; sub_1000EBD9+35j
		mov	[esi+8], edx
		mov	[edx+4], esi
		pop	esi
		retn	4
sub_1000EBD9	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_1000EC1C(char	*, char)
sub_1000EC1C	proc near		; CODE XREF: sub_1000A8A8+3874p
					; sub_1000A8A8+39F0p ...

OutputString	= byte ptr -804h
var_5		= byte ptr -5
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 804h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		call	ds:IsDebuggerPresent
		test	eax, eax
		jz	short loc_1000EC66
		lea	eax, [ebp+arg_4]
		push	eax		; va_list
		push	[ebp+arg_0]	; char *
		lea	eax, [ebp+OutputString]
		push	800h		; size_t
		push	eax		; char *
		call	ds:_vsnprintf
		add	esp, 10h
		mov	[ebp+var_5], 0
		lea	eax, [ebp+OutputString]
		push	eax		; lpOutputString
		call	ds:OutputDebugStringA

loc_1000EC66:				; CODE XREF: sub_1000EC1C+1Bj
		push	esi
		push	offset aA_0	; "a"
		push	2		; int
		call	ds:_dup
		pop	ecx
		push	eax		; int
		call	ds:_fdopen
		mov	esi, eax
		pop	ecx
		pop	ecx
		test	esi, esi
		jz	short loc_1000EC9C
		lea	eax, [ebp+arg_4]
		push	eax		; va_list
		push	[ebp+arg_0]	; char *
		push	esi		; FILE *
		call	ds:vfprintf
		push	esi		; FILE *
		call	ds:fclose
		add	esp, 10h

loc_1000EC9C:				; CODE XREF: sub_1000EC1C+66j
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		pop	esi
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_1000EC1C	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?moz_Xinvalid_argument@std@@YAXPBD@Z

loc_1000ECAB:				; CODE XREF: std::moz_Xinvalid_argument(char const *)+9j
					; std::moz_Xlength_error(char const *)+9j ...
		push	esi
		push	ecx
		push	offset aFatalStlThrewS ; "fatal: STL threw %s: "
		mov	esi, edx
		call	ds:__iob_func
		add	eax, 40h
		push	eax		; FILE *
		call	ds:fprintf
		add	esp, 0Ch
		push	esi		; char *
		call	?mozalloc_abort@@YAXQBD@Z ; mozalloc_abort(char	const *	const)
; END OF FUNCTION CHUNK	FOR ?moz_Xinvalid_argument@std@@YAXPBD@Z
; ---------------------------------------------------------------------------
		db  5Eh	; ^
; Exported entry  70. ?moz_Xinvalid_argument@std@@YAXPBD@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

; void __cdecl std::moz_Xinvalid_argument(const	char *)
		public ?moz_Xinvalid_argument@std@@YAXPBD@Z
?moz_Xinvalid_argument@std@@YAXPBD@Z proc near ; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

; FUNCTION CHUNK AT 1000ECAB SIZE 00000022 BYTES

		mov	edx, [esp+arg_0]
		mov	ecx, offset aInvalid_argume ; "invalid_argument"
		jmp	loc_1000ECAB
?moz_Xinvalid_argument@std@@YAXPBD@Z endp

; Exported entry  71. ?moz_Xlength_error@std@@YAXPBD@Z

; =============== S U B	R O U T	I N E =======================================


; void __cdecl std::moz_Xlength_error(const char *)
		public ?moz_Xlength_error@std@@YAXPBD@Z
?moz_Xlength_error@std@@YAXPBD@Z proc near ; DATA XREF:	.rdata:off_100175A8o

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		mov	ecx, offset aLength_error ; "length_error"
		jmp	loc_1000ECAB
?moz_Xlength_error@std@@YAXPBD@Z endp

; Exported entry  72. ?moz_Xout_of_range@std@@YAXPBD@Z

; =============== S U B	R O U T	I N E =======================================


; void __cdecl std::moz_Xout_of_range(const char *)
		public ?moz_Xout_of_range@std@@YAXPBD@Z
?moz_Xout_of_range@std@@YAXPBD@Z proc near ; DATA XREF:	.rdata:off_100175A8o

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		mov	ecx, offset aOut_of_range ; "out_of_range"
		jmp	loc_1000ECAB
?moz_Xout_of_range@std@@YAXPBD@Z endp

; Exported entry  73. ?moz_Xoverflow_error@std@@YAXPBD@Z

; =============== S U B	R O U T	I N E =======================================


; void __cdecl std::moz_Xoverflow_error(const char *)
		public ?moz_Xoverflow_error@std@@YAXPBD@Z
?moz_Xoverflow_error@std@@YAXPBD@Z proc	near ; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		mov	ecx, offset aOverflow_error ; "overflow_error"
		jmp	loc_1000ECAB
?moz_Xoverflow_error@std@@YAXPBD@Z endp

; Exported entry  74. ?moz_Xruntime_error@std@@YAXPBD@Z

; =============== S U B	R O U T	I N E =======================================


; void __cdecl std::moz_Xruntime_error(const char *)
		public ?moz_Xruntime_error@std@@YAXPBD@Z
?moz_Xruntime_error@std@@YAXPBD@Z proc near ; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		mov	ecx, offset aRuntime_error ; "runtime_error"
		jmp	loc_1000ECAB
?moz_Xruntime_error@std@@YAXPBD@Z endp

; Exported entry  78. ?mozilla_Throw@std@@YAXABVexception@stdext@@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

; void __cdecl std::mozilla_Throw(const	struct stdext::exception *)
		public ?mozilla_Throw@std@@YAXABVexception@stdext@@@Z
?mozilla_Throw@std@@YAXABVexception@stdext@@@Z proc near ; DATA	XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		call	dword ptr [eax+4]
		push	eax		; char *
		call	?mozalloc_abort@@YAXQBD@Z ; mozalloc_abort(char	const *	const)
?mozilla_Throw@std@@YAXABVexception@stdext@@@Z endp

; ---------------------------------------------------------------------------
		align 4
; Exported entry  75. ?mozalloc_abort@@YAXQBD@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

; void __cdecl mozalloc_abort(const char *const	)
		public ?mozalloc_abort@@YAXQBD@Z
?mozalloc_abort@@YAXQBD@Z proc near	; CODE XREF: std::moz_Xinvalid_argument(char const *)-6p
					; std::mozilla_Throw(stdext::exception const &)+Ap ...

arg_0		= dword	ptr  4

		call	ds:__iob_func
		add	eax, 40h
		push	eax		; FILE *
		push	[esp+4+arg_0]	; char *
		call	ds:fputs
		call	ds:__iob_func
		add	eax, 40h
		push	eax		; FILE *
		push	offset asc_1001705C ; "\n"
		call	ds:fputs
		add	esp, 10h
		int	3		; Trap to Debugger
		push	3		; uExitCode
		mov	large dword ptr	ds:0, 21h
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:TerminateProcess
		int	3		; Trap to Debugger
?mozalloc_abort@@YAXQBD@Z endp

; Exported entry  76. ?mozalloc_handle_oom@@YAXI@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl mozalloc_handle_oom(unsigned int)
		public ?mozalloc_handle_oom@@YAXI@Z
?mozalloc_handle_oom@@YAXI@Z proc near	; CODE XREF: moz_xcalloc+A9F6p
					; moz_xrealloc+A9CFp ...

var_38		= byte ptr -38h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		push	ebx
		push	esi
		push	edi
		mov	eax, dword_1001AAA8
		lea	edi, [ebp+var_38]
		mov	ebx, [ebp+arg_0]
		mov	esi, offset aOutOfMemory0x0 ; "out of memory: 0x0000000000000000 bytes"...
		push	0Ch
		pop	ecx
		rep movsd
		movsw
		test	eax, eax
		jz	short loc_1000ED9D
		push	ebx
		call	eax ; dword_1001AAA8
		pop	ecx

loc_1000ED9D:				; CODE XREF: mozalloc_handle_oom(uint)+2Cj
		push	20h
		pop	ecx
		jmp	short loc_1000EDBA
; ---------------------------------------------------------------------------

loc_1000EDA2:				; CODE XREF: mozalloc_handle_oom(uint)+51j
		cmp	ecx, 11h
		jb	short loc_1000EDBE
		mov	eax, ebx
		shr	ebx, 4
		and	eax, 0Fh
		mov	al, ds:byte_10017340[eax]
		mov	[ebp+ecx+var_38], al
		dec	ecx

loc_1000EDBA:				; CODE XREF: mozalloc_handle_oom(uint)+35j
		test	ebx, ebx
		jnz	short loc_1000EDA2

loc_1000EDBE:				; CODE XREF: mozalloc_handle_oom(uint)+3Aj
		lea	eax, [ebp+var_38]
		push	eax		; char *
		call	?mozalloc_abort@@YAXQBD@Z ; mozalloc_abort(char	const *	const)
?mozalloc_handle_oom@@YAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
; Exported entry 122. moz_xstrdup

; =============== S U B	R O U T	I N E =======================================


; int __cdecl moz_xstrdup(char *)
		public moz_xstrdup
moz_xstrdup	proc near		; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

		push	[esp+arg_0]	; char *
		call	strdup
		pop	ecx
		test	eax, eax
		jnz	short locret_1000EDDC
		push	eax		; unsigned int
		call	?mozalloc_handle_oom@@YAXI@Z ; mozalloc_handle_oom(uint)
; ---------------------------------------------------------------------------

locret_1000EDDC:			; CODE XREF: moz_xstrdup+Cj
		retn
moz_xstrdup	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

sub_1000EDDD	proc near		; CODE XREF: sub_100056A2:loc_100056ECp
					; sub_10005837:loc_1000587Fp ...
		int	3		; Trap to Debugger
		push	3		; uExitCode
		mov	large dword ptr	ds:0, 32h
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:TerminateProcess
		int	3		; Trap to Debugger
sub_1000EDDD	endp

; Exported entry  96. _aligned_malloc

; =============== S U B	R O U T	I N E =======================================


		public _aligned_malloc
_aligned_malloc	proc near		; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		jmp	sub_1000172B
_aligned_malloc	endp

; Exported entry 126. strndup

; =============== S U B	R O U T	I N E =======================================


; int __cdecl strndup(char *, size_t)
		public strndup
strndup		proc near		; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		mov	edi, [esp+8+arg_4]
		lea	eax, [edi+1]
		push	eax
		call	malloc
		mov	esi, eax
		pop	ecx
		test	esi, esi
		jz	short loc_1000EE2E
		push	edi		; size_t
		push	[esp+0Ch+arg_0]	; char *
		push	esi		; char *
		call	ds:strncpy
		add	esp, 0Ch
		mov	byte ptr [esi+edi], 0

loc_1000EE2E:				; CODE XREF: strndup+14j
		pop	edi
		mov	eax, esi
		pop	esi
		retn
strndup		endp


; =============== S U B	R O U T	I N E =======================================


; BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
_DllMain@12	proc near		; CODE XREF: ___DllMainCRTStartup+7Dp
					; ___DllMainCRTStartup+97p

hinstDLL	= dword	ptr  4
fdwReason	= dword	ptr  8
lpvReserved	= dword	ptr  0Ch

		dec	[esp+fdwReason]
		jnz	short loc_1000EE48
		push	[esp+hinstDLL]	; hLibModule
		call	ds:DisableThreadLibraryCalls
		call	sub_100066AB

loc_1000EE48:				; CODE XREF: DllMain(x,x,x)+4j
		xor	eax, eax
		inc	eax
		retn	0Ch
_DllMain@12	endp

; Exported entry  97. _expand

; =============== S U B	R O U T	I N E =======================================


		public _expand
_expand		proc near		; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		call	sub_100023C0
		cmp	eax, [esp+arg_4]
		sbb	eax, eax
		not	eax
		and	eax, [esp+arg_0]
		retn
_expand		endp

; Exported entry 100. _msize
; Exported entry 115. malloc_usable_size

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public malloc_usable_size
malloc_usable_size proc	near		; DATA XREF: .rdata:off_100175A8o

var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp		; _msize
		mov	ebp, esp
		sub	esp, 1Ch
		push	esi
		mov	esi, [ebp+arg_0]
		and	esi, 0FFF00000h
		jnz	short loc_1000EE7A

loc_1000EE76:				; CODE XREF: malloc_usable_size+1Fj
		xor	esi, esi
		jmp	short loc_1000EEC1
; ---------------------------------------------------------------------------

loc_1000EE7A:				; CODE XREF: malloc_usable_size+10j
		mov	edx, esi
		call	sub_1000ADF0
		test	eax, eax
		jz	short loc_1000EE76
		cmp	esi, [ebp+arg_0]
		jz	short loc_1000EE96
		mov	ecx, [ebp+arg_0]
		call	sub_1000ADBF
		mov	esi, eax
		jmp	short loc_1000EEC1
; ---------------------------------------------------------------------------

loc_1000EE96:				; CODE XREF: malloc_usable_size+24j
		push	edi
		mov	edi, offset stru_1001AAB0
		mov	[ebp+var_C], esi
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		lea	edx, [ebp+var_1C]
		call	sub_10005E22
		test	eax, eax
		jz	short loc_1000EEB7
		mov	esi, [eax+14h]
		jmp	short loc_1000EEB9
; ---------------------------------------------------------------------------

loc_1000EEB7:				; CODE XREF: malloc_usable_size+4Cj
		xor	esi, esi

loc_1000EEB9:				; CODE XREF: malloc_usable_size+51j
		push	edi		; lpCriticalSection
		call	ds:LeaveCriticalSection
		pop	edi

loc_1000EEC1:				; CODE XREF: malloc_usable_size+14j
					; malloc_usable_size+30j
		mov	eax, esi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
malloc_usable_size endp

; Exported entry 101. _recalloc

; =============== S U B	R O U T	I N E =======================================


; int __cdecl recalloc(void *, int, int)
		public _recalloc
_recalloc	proc near		; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	esi
		push	edi
		test	ebx, ebx
		jz	short loc_1000EEDE
		mov	ecx, ebx
		call	sub_100023C0
		mov	edi, eax
		jmp	short loc_1000EEE0
; ---------------------------------------------------------------------------

loc_1000EEDE:				; CODE XREF: _recalloc+9j
		xor	edi, edi

loc_1000EEE0:				; CODE XREF: _recalloc+14j
		mov	esi, [esp+0Ch+arg_4]
		imul	esi, [esp+0Ch+arg_8]
		push	esi		; size_t
		push	ebx		; void *
		call	realloc
		mov	ebx, eax
		pop	ecx
		pop	ecx
		test	ebx, ebx
		jz	short loc_1000EF0D
		cmp	edi, esi
		jnb	short loc_1000EF0D
		sub	esi, edi
		lea	eax, [edi+ebx]
		push	esi		; size_t
		push	0		; int
		push	eax		; void *
		call	memset
		add	esp, 0Ch

loc_1000EF0D:				; CODE XREF: _recalloc+2Ej
					; _recalloc+32j
		pop	edi
		pop	esi
		mov	eax, ebx
		pop	ebx
		retn
_recalloc	endp


; =============== S U B	R O U T	I N E =======================================


; int __usercall sub_1000EF13@<eax>(LPCRITICAL_SECTION lpCriticalSection@<ecx>,	int, int)
sub_1000EF13	proc near		; CODE XREF: sub_1000172B+AA3Bp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ecx
		push	ecx
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	esi, ecx
		mov	[esp+18h+var_8], edx
		push	esi		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	ebx, [esp+18h+arg_4]
		xor	ebp, ebp
		push	ebp
		push	1
		push	ebx
		mov	ecx, esi
		call	sub_100029D0
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	short loc_1000EFAC
		mov	ecx, [esp+18h+var_8]
		mov	edx, edi
		and	edx, 0FFF00000h
		mov	[esp+18h+var_4], edx
		lea	eax, [ecx-1]
		and	eax, edi
		jnz	short loc_1000EF5F
		push	ebp
		push	[esp+1Ch+arg_0]
		push	ebx
		jmp	short loc_1000EF91
; ---------------------------------------------------------------------------

loc_1000EF5F:				; CODE XREF: sub_1000EF13+42j
		sub	ecx, eax
		mov	[esp+18h+var_8], ecx
		jz	short loc_1000EF82
		mov	eax, ebx
		sub	eax, ecx
		mov	ecx, esi
		push	eax
		push	ebx
		push	edi
		call	sub_1000EFBC
		mov	ecx, [esp+24h+var_8]
		add	esp, 0Ch
		mov	edx, [esp+18h+var_4]
		add	edi, ecx

loc_1000EF82:				; CODE XREF: sub_1000EF13+52j
		mov	eax, [esp+18h+arg_0]
		sub	ebx, ecx
		sub	ebx, eax
		jz	short loc_1000EFA0
		push	ebp
		push	eax
		add	eax, ebx
		push	eax

loc_1000EF91:				; CODE XREF: sub_1000EF13+4Aj
		push	edi
		mov	ecx, esi
		call	sub_10005885
		mov	eax, [esp+28h+arg_0]
		add	esp, 10h

loc_1000EFA0:				; CODE XREF: sub_1000EF13+77j
		add	dword ptr [esi+70h], 1
		adc	[esi+74h], ebp
		mov	ebp, edi
		add	[esi+68h], eax

loc_1000EFAC:				; CODE XREF: sub_1000EF13+2Bj
		push	esi		; lpCriticalSection
		call	ds:LeaveCriticalSection
		pop	edi
		pop	esi
		mov	eax, ebp
		pop	ebp
		pop	ebx
		pop	ecx
		pop	ecx
		retn
sub_1000EF13	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000EFBC	proc near		; CODE XREF: sub_1000EF13+5Dp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		mov	ebx, edx
		mov	edx, [esp+4+arg_0]
		sub	edx, ebx
		shr	edx, 0Ch
		push	ebp
		push	esi
		mov	esi, [esp+0Ch+arg_4]
		mov	ebp, ecx
		lea	eax, [edx+2]
		imul	eax, 0Ch
		push	edi
		mov	edi, [esp+10h+arg_8]
		sub	esi, edi
		mov	ecx, esi
		or	edi, 3
		or	ecx, 3
		shr	esi, 0Ch
		push	0
		mov	[eax+ebx], ecx
		lea	eax, [esi+2]
		add	eax, edx
		mov	ecx, ebp
		mov	edx, [esp+14h+arg_0]
		imul	eax, 0Ch
		mov	[eax+ebx], edi
		call	sub_10004A40
		pop	ecx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
sub_1000EFBC	endp

; Exported entry 110. jemalloc_free_dirty_pages

; =============== S U B	R O U T	I N E =======================================


		public jemalloc_free_dirty_pages
jemalloc_free_dirty_pages proc near	; DATA XREF: .rdata:off_100175A8o
		mov	ecx, dword_1001AB2C
		push	esi
		xor	esi, esi
		test	ecx, ecx
		jz	short loc_1000F047
		push	edi

loc_1000F017:				; CODE XREF: jemalloc_free_dirty_pages+3Bj
		mov	eax, dword_1001AB00
		mov	edi, [eax+esi*4]
		test	edi, edi
		jz	short loc_1000F041
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		xor	edx, edx
		mov	ecx, edi
		inc	edx
		call	sub_10005710
		push	edi		; lpCriticalSection
		call	ds:LeaveCriticalSection
		mov	ecx, dword_1001AB2C

loc_1000F041:				; CODE XREF: jemalloc_free_dirty_pages+18j
		inc	esi
		cmp	esi, ecx
		jb	short loc_1000F017
		pop	edi

loc_1000F047:				; CODE XREF: jemalloc_free_dirty_pages+Bj
		pop	esi
		retn
jemalloc_free_dirty_pages endp

; Exported entry 112. jemalloc_stats

; =============== S U B	R O U T	I N E =======================================


		public jemalloc_stats
jemalloc_stats	proc near		; DATA XREF: .rdata:off_100175A8o

var_188		= dword	ptr -188h
var_184		= dword	ptr -184h
var_180		= dword	ptr -180h
var_17C		= dword	ptr -17Ch
var_178		= dword	ptr -178h
var_174		= dword	ptr -174h
var_170		= dword	ptr -170h
var_16C		= dword	ptr -16Ch
var_168		= dword	ptr -168h
lpCriticalSection= dword ptr -164h
var_160		= dword	ptr -160h
var_15C		= byte ptr -15Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		sub	esp, 188h
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+188h+var_4], eax
		mov	al, byte ptr dword_1001AC98
		xor	ecx, ecx
		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+194h+arg_0]
		push	edi
		mov	edi, offset stru_1001AAB0
		mov	[esp+198h+var_174], esi
		push	edi		; lpCriticalSection
		or	dword ptr [esi+0Ch], 0FFFFFFFFh
		mov	[esi], al
		mov	eax, dword_1001AB2C
		mov	[esi+8], eax
		mov	eax, dword_1001A49C
		mov	dword ptr [esi+1], 100h
		mov	[esi+5], cx
		mov	dword ptr [esi+10h], 10h
		mov	dword ptr [esi+14h], 200h
		mov	dword ptr [esi+18h], 0FF000h
		mov	dword ptr [esi+1Ch], 100000h
		mov	[esi+20h], eax
		mov	[esi+24h], ecx
		mov	[esi+28h], ecx
		mov	[esi+2Ch], ecx
		mov	[esi+30h], ecx
		mov	[esi+34h], ecx
		mov	[esi+38h], ecx
		call	ds:EnterCriticalSection
		mov	eax, dword_1001AAAC
		mov	ebx, dword_1001AB48
		add	[esi+28h], eax
		mov	ebp, ds:LeaveCriticalSection
		push	edi		; lpCriticalSection
		call	ebp ; LeaveCriticalSection
		mov	edi, offset stru_1001AB98
		push	edi		; lpCriticalSection
		call	ds:EnterCriticalSection
		add	ebx, dword_1001ABB0
		mov	eax, dword_1001AAF0
		add	[esi+34h], eax
		push	edi		; lpCriticalSection
		mov	[esp+19Ch+var_168], ebx
		call	ebp ; LeaveCriticalSection
		mov	ecx, dword_1001AB2C
		xor	edx, edx
		mov	[esp+198h+var_180], edx
		test	ecx, ecx
		jz	loc_1000F280

loc_1000F11A:				; CODE XREF: jemalloc_stats+22Dj
		mov	eax, dword_1001AB00
		mov	ebp, [eax+edx*4]
		mov	[esp+198h+lpCriticalSection], ebp
		test	ebp, ebp
		jz	loc_1000F26F
		xor	esi, esi
		xor	ecx, ecx
		push	ebp		; lpCriticalSection
		mov	[esp+19Ch+var_184], esi
		call	ds:EnterCriticalSection
		mov	eax, [ebp+18h]
		lea	ebx, [ebp+0CCh]
		mov	edi, [ebp+50h]
		mov	[esp+198h+var_17C], eax
		mov	eax, [ebp+68h]
		add	eax, [ebp+54h]
		mov	[esp+198h+var_16C], eax
		mov	eax, [ebp+0A4h]
		mov	ebp, esi
		shl	edi, 0Ch
		shl	eax, 0Ch
		push	25h
		mov	[esp+19Ch+var_170], edi
		mov	[esp+19Ch+var_178], eax
		pop	edi

loc_1000F170:				; CODE XREF: jemalloc_stats+1D1j
		mov	eax, [ebx-10h]
		lea	ecx, [ebx-0Ch]
		xor	edx, edx
		mov	[esp+198h+var_188], edx
		cmp	eax, ecx
		jz	short loc_1000F1F8
		mov	[esp+198h+var_160], eax
		inc	edx
		mov	eax, [eax]
		cmp	eax, ecx
		jz	short loc_1000F1A6
		lea	esi, [esp+198h+var_15C]

loc_1000F18F:				; CODE XREF: jemalloc_stats+157j
		mov	[esi], eax
		inc	edx
		lea	esi, [esp+198h+var_160]
		lea	esi, [esi+edx*4]
		mov	eax, [esi-4]
		mov	eax, [eax]
		cmp	eax, ecx
		jnz	short loc_1000F18F
		test	edx, edx
		jz	short loc_1000F1F0

loc_1000F1A6:				; CODE XREF: jemalloc_stats+140j
		lea	esi, [ebx-0Ch]

loc_1000F1A9:				; CODE XREF: jemalloc_stats+1A5j
		mov	ecx, [esp+edx*4+198h+lpCriticalSection]
		mov	eax, [ecx+8]
		and	eax, 0FFFFF000h
		mov	eax, [eax+8]
		imul	eax, [ebx]
		add	[esp+198h+var_188], eax
		mov	eax, [ecx+4]
		and	eax, 0FFFFFFFEh
		cmp	eax, esi
		jz	short loc_1000F1DA

loc_1000F1C9:				; CODE XREF: jemalloc_stats+18Dj
		mov	[esp+edx*4+198h+var_160], eax
		inc	edx
		mov	eax, [esp+edx*4+198h+lpCriticalSection]
		mov	eax, [eax]
		cmp	eax, esi
		jnz	short loc_1000F1C9
		jmp	short loc_1000F1EC
; ---------------------------------------------------------------------------

loc_1000F1DA:				; CODE XREF: jemalloc_stats+17Ej
		dec	edx
		jz	short loc_1000F1F0

loc_1000F1DD:				; CODE XREF: jemalloc_stats+1A1j
		mov	eax, [esp+edx*4+198h+lpCriticalSection]
		mov	eax, [eax]
		cmp	eax, [esp+edx*4+198h+var_160]
		jz	short loc_1000F1EC
		dec	edx
		jnz	short loc_1000F1DD

loc_1000F1EC:				; CODE XREF: jemalloc_stats+18Fj
					; jemalloc_stats+19Ej
		test	edx, edx
		jnz	short loc_1000F1A9

loc_1000F1F0:				; CODE XREF: jemalloc_stats+15Bj
					; jemalloc_stats+192j
		mov	esi, [esp+198h+var_184]
		mov	edx, [esp+198h+var_188]

loc_1000F1F8:				; CODE XREF: jemalloc_stats+135j
		mov	eax, [ebx-14h]
		test	eax, eax
		jz	short loc_1000F207
		mov	eax, [eax+8]
		imul	eax, [ebx]
		add	edx, eax

loc_1000F207:				; CODE XREF: jemalloc_stats+1B4j
		mov	eax, [ebx+30h]
		add	ebp, edx
		imul	eax, [ebx+10h]
		add	ebx, 48h
		add	esi, eax
		mov	[esp+198h+var_184], esi
		dec	edi
		jnz	loc_1000F170
		mov	[esp+198h+var_188], ebp
		mov	ebp, [esp+198h+lpCriticalSection]
		push	ebp		; lpCriticalSection
		call	ds:LeaveCriticalSection
		mov	esi, [esp+198h+var_174]
		mov	ecx, [esp+198h+var_178]
		mov	eax, [esp+198h+var_17C]
		mov	edi, [esp+198h+var_170]
		add	[esi+24h], eax
		sub	edi, ecx
		mov	eax, [esp+198h+var_16C]
		sub	edi, eax
		add	[esi+30h], ecx
		mov	ecx, [esp+198h+var_188]
		sub	edi, ecx
		add	[esi+28h], eax
		mov	eax, [esp+198h+var_184]
		sub	edi, eax
		add	[esi+38h], ecx
		add	[esi+2Ch], edi
		add	[esi+34h], eax
		mov	ecx, dword_1001AB2C
		mov	edx, [esp+198h+var_180]

loc_1000F26F:				; CODE XREF: jemalloc_stats+DFj
		inc	edx
		mov	[esp+198h+var_180], edx
		cmp	edx, ecx
		jb	loc_1000F11A
		mov	ebx, [esp+198h+var_168]

loc_1000F280:				; CODE XREF: jemalloc_stats+CBj
		mov	ecx, [esi+24h]
		xor	edx, edx
		mov	eax, ecx
		add	ecx, ebx
		div	dword ptr [esi+1Ch]
		pop	edi
		shl	eax, 0Ch
		add	[esi+34h], eax
		sub	[esi+2Ch], eax
		mov	[esi+24h], ecx
		mov	ecx, [esp+194h+var_4]
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 188h
		retn
jemalloc_stats	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_1000F2B1(void	*, void	*, void	*, void	*)
sub_1000F2B1	proc near		; CODE XREF: sub_10005C56+6AB3p
					; sub_100066AB+6BD5p ...

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+1]

loc_1000F2BA:				; CODE XREF: sub_1000F2B1+Ej
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1000F2BA
		push	esi
		mov	esi, ds:_write
		sub	ecx, edx
		push	ecx		; unsigned int
		push	[ebp+arg_0]	; void *
		push	2		; int
		call	esi ; _write
		mov	ecx, [ebp+arg_4]
		add	esp, 0Ch
		lea	edx, [ecx+1]

loc_1000F2DB:				; CODE XREF: sub_1000F2B1+2Fj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1000F2DB
		sub	ecx, edx
		push	ecx		; unsigned int
		push	[ebp+arg_4]	; void *
		push	2		; int
		call	esi ; _write
		mov	ecx, [ebp+arg_8]
		add	esp, 0Ch
		lea	edx, [ecx+1]

loc_1000F2F5:				; CODE XREF: sub_1000F2B1+49j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1000F2F5
		sub	ecx, edx
		push	ecx		; unsigned int
		push	[ebp+arg_8]	; void *
		push	2		; int
		call	esi ; _write
		mov	ecx, [ebp+arg_C]
		add	esp, 0Ch
		lea	edx, [ecx+1]

loc_1000F30F:				; CODE XREF: sub_1000F2B1+63j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1000F30F
		sub	ecx, edx
		push	ecx		; unsigned int
		push	[ebp+arg_C]	; void *
		push	2		; int
		call	esi ; _write
		add	esp, 0Ch
		pop	esi
		pop	ebp
		retn
sub_1000F2B1	endp

; Exported entry  41. ?RecordProcessRestart@TimeStamp@mozilla@@SAXXZ

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl mozilla::TimeStamp::RecordProcessRestart(void)
		public ?RecordProcessRestart@TimeStamp@mozilla@@SAXXZ
?RecordProcessRestart@TimeStamp@mozilla@@SAXXZ proc near ; DATA	XREF: .rdata:off_100175A8o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= word ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	esi
		push	edi
		xor	eax, eax
		mov	[ebp+var_8], 100h
		push	6
		pop	ecx
		lea	esi, [ebp+var_18]
		mov	[ebp+var_18], eax
		mov	edi, offset dword_1001AA68
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		rep movsd
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
?RecordProcessRestart@TimeStamp@mozilla@@SAXXZ endp


; =============== S U B	R O U T	I N E =======================================


sub_1000F355	proc near		; CODE XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+69ABp
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A00p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		mov	eax, [esp+arg_0]
		test	edx, edx
		jl	short loc_1000F367
		jg	short locret_1000F36E
		test	eax, eax
		jnb	short locret_1000F36E

loc_1000F367:				; CODE XREF: sub_1000F355+Aj
		neg	eax
		adc	edx, 0
		neg	edx

locret_1000F36E:			; CODE XREF: sub_1000F355+Cj
					; sub_1000F355+10j
		retn
sub_1000F355	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000F36F	proc near		; DATA XREF: mozilla::TimeStamp::Startup(void):loc_10006F56o
		push	ebx
		push	ebp
		push	esi
		push	edi
		call	ds:GetTickCount
		mov	ebp, offset stru_1001AC68
		mov	ebx, eax
		push	ebp		; lpCriticalSection
		call	ds:EnterCriticalSection
		mov	ecx, dword_1001ACA0
		cmp	ecx, ebx
		jbe	short loc_1000F3AA
		sub	ecx, ebx
		cmp	ecx, 40000000h
		jbe	short loc_1000F3AA
		mov	edi, dword_1001AC9C
		inc	edi
		mov	dword_1001AC9C,	edi
		jmp	short loc_1000F3B0
; ---------------------------------------------------------------------------

loc_1000F3AA:				; CODE XREF: sub_1000F36F+20j
					; sub_1000F36F+2Aj
		mov	edi, dword_1001AC9C

loc_1000F3B0:				; CODE XREF: sub_1000F36F+39j
		xor	esi, esi
		mov	dword_1001ACA0,	ebx
		push	ebp		; lpCriticalSection
		or	esi, ebx
		call	ds:LeaveCriticalSection
		mov	edx, edi
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
sub_1000F36F	endp

; Exported entry  42. ?ResolutionInTicks@BaseTimeDurationPlatformUtils@mozilla@@SA_JXZ

; =============== S U B	R O U T	I N E =======================================


; __int64 __cdecl mozilla::BaseTimeDurationPlatformUtils::ResolutionInTicks()
		public ?ResolutionInTicks@BaseTimeDurationPlatformUtils@mozilla@@SA_JXZ
?ResolutionInTicks@BaseTimeDurationPlatformUtils@mozilla@@SA_JXZ proc near
					; DATA XREF: .rdata:off_100175A8o
		mov	eax, dword_1001ABC8
		mov	edx, dword_1001ABCC
		retn
?ResolutionInTicks@BaseTimeDurationPlatformUtils@mozilla@@SA_JXZ endp

; Exported entry  50. ?ToSecondsSigDigits@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@Z

; =============== S U B	R O U T	I N E =======================================


; double __cdecl mozilla::BaseTimeDurationPlatformUtils::ToSecondsSigDigits(__int64)
		public ?ToSecondsSigDigits@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@Z
?ToSecondsSigDigits@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@Z proc	near
					; DATA XREF: .rdata:off_100175A8o

arg_0		= qword	ptr  4

		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, dword_1001ABC8
		mov	esi, dword_1001ABCC
		mov	ebp, dword_1001ABC0
		mov	ebx, dword_1001ABC4
		push	esi
		push	edi
		push	dword ptr [esp+18h+arg_0+4]
		push	dword ptr [esp+1Ch+arg_0]
		call	__alldiv
		push	esi
		push	edi
		push	edx
		push	eax
		call	__allmul
		push	ebx
		push	ebp
		push	edx
		push	eax
		call	__alldiv
		push	ebx
		push	ebp
		push	edx
		push	eax
		call	__allmul
		mov	dword ptr [esp+10h+arg_0], eax
		mov	dword ptr [esp+10h+arg_0+4], edx
		fild	[esp+10h+arg_0]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		fstp	[esp+arg_0]
		fld	[esp+arg_0]
		fdiv	ds:dbl_100174D0
		retn
?ToSecondsSigDigits@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@Z endp

; Exported entry  57. ?compressLimitedOutput@LZ4@Compression@mozilla@@SAIPBDIPADI@Z

; =============== S U B	R O U T	I N E =======================================


; unsigned int __cdecl mozilla::Compression::LZ4::compressLimitedOutput(const char *, unsigned int, char *, unsigned int)
		public ?compressLimitedOutput@LZ4@Compression@mozilla@@SAIPBDIPADI@Z
?compressLimitedOutput@LZ4@Compression@mozilla@@SAIPBDIPADI@Z proc near
					; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	[esp+arg_C]
		mov	edx, [esp+4+arg_8]
		push	[esp+4+arg_4]
		mov	ecx, [esp+8+arg_0]
		call	sub_1000F49A
		pop	ecx
		pop	ecx
		retn
?compressLimitedOutput@LZ4@Compression@mozilla@@SAIPBDIPADI@Z endp

; Exported entry  58. ?decompress@LZ4@Compression@mozilla@@SA_NPBDIPADIPAI@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl mozilla::Compression::LZ4::decompress(const char	*, unsigned int, char *, unsigned int, unsigned	int *)
		public ?decompress@LZ4@Compression@mozilla@@SA_NPBDIPADIPAI@Z
?decompress@LZ4@Compression@mozilla@@SA_NPBDIPADIPAI@Z proc near
					; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	[ebp+arg_C]
		mov	edx, [ebp+arg_8]
		push	[ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		call	sub_1000F6C8
		pop	ecx
		pop	ecx
		test	eax, eax
		js	short loc_1000F476
		mov	ecx, [ebp+arg_10]
		mov	[ecx], eax
		mov	al, 1
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000F476:				; CODE XREF: mozilla::Compression::LZ4::decompress(char	const *,uint,char *,uint,uint *)+18j
		mov	eax, [ebp+arg_10]
		and	dword ptr [eax], 0
		xor	al, al
		pop	ebp
		retn
?decompress@LZ4@Compression@mozilla@@SA_NPBDIPADIPAI@Z endp

; Exported entry  59. ?decompress@LZ4@Compression@mozilla@@SA_NPBDPADI@Z

; =============== S U B	R O U T	I N E =======================================


; bool __cdecl mozilla::Compression::LZ4::decompress(const char	*, char	*, unsigned int)
		public ?decompress@LZ4@Compression@mozilla@@SA_NPBDPADI@Z
?decompress@LZ4@Compression@mozilla@@SA_NPBDPADI@Z proc	near
					; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	[esp+arg_8]
		mov	edx, [esp+4+arg_4]
		mov	ecx, [esp+4+arg_0]
		call	sub_1000F50E
		pop	ecx
		xor	ecx, ecx
		test	eax, eax
		setns	al
		retn
?decompress@LZ4@Compression@mozilla@@SA_NPBDPADI@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000F49A	proc near		; CODE XREF: mozilla::Compression::LZ4::compressLimitedOutput(char const *,uint,char *,uint)+10p

var_4024	= dword	ptr -4024h
var_4020	= byte ptr -4020h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, 4024h
		call	__alloca_probe
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		and	[ebp+var_4024],	0
		lea	eax, [ebp+var_4020]
		push	esi
		push	edi
		push	401Ch		; size_t
		push	0		; int
		push	eax		; void *
		mov	edi, edx
		mov	esi, ecx
		call	memset
		add	esp, 0Ch
		mov	edx, esi
		cmp	[ebp+arg_0], 1000Bh
		push	ecx
		push	ecx
		lea	ecx, [ebp+var_4024]
		jge	short loc_1000F4EB
		push	2
		jmp	short loc_1000F4ED
; ---------------------------------------------------------------------------

loc_1000F4EB:				; CODE XREF: sub_1000F49A+4Bj
		push	0

loc_1000F4ED:				; CODE XREF: sub_1000F49A+4Fj
		push	1
		push	[ebp+arg_4]
		push	[ebp+arg_0]
		push	edi
		call	sub_1000A50E
		mov	ecx, [ebp+var_4]
		add	esp, 1Ch
		xor	ecx, ebp
		pop	edi
		pop	esi
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_1000F49A	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000F50E	proc near		; CODE XREF: mozilla::Compression::LZ4::decompress(char	const *,char *,uint)+Cp

var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		sub	esp, 2Ch
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+2Ch+var_4], eax
		mov	eax, [esp+2Ch+arg_0]
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	ebp, ecx
		mov	[esp+3Ch+var_1C], 2
		mov	esi, edx
		mov	[esp+3Ch+var_28], ebp
		xor	ecx, ecx
		mov	edi, ebp
		push	4
		pop	ebx
		inc	ecx
		mov	[esp+3Ch+var_24], ebx
		mov	[esp+3Ch+var_20], ecx
		lea	edx, [esi+eax]
		mov	[esp+3Ch+var_2C], edx
		mov	[esp+3Ch+var_18], ecx
		mov	[esp+3Ch+var_14], ebx
		mov	[esp+3Ch+var_10], ebx
		mov	[esp+3Ch+var_C], ebx
		mov	[esp+3Ch+var_8], ebx
		test	eax, eax
		jnz	short loc_1000F577
		xor	ebx, ebx
		cmp	[ebp+0], bl
		setz	bl
		lea	ebx, ds:0FFFFFFFFh[ebx*2]
		jmp	loc_1000F6B3
; ---------------------------------------------------------------------------

loc_1000F577:				; CODE XREF: sub_1000F50E+53j
					; sub_1000F50E+182j
		movzx	ebp, byte ptr [edi]
		inc	edi
		mov	ebx, ebp
		shr	ebx, 4
		cmp	ebx, 0Fh
		jnz	short loc_1000F59D

loc_1000F585:				; CODE XREF: sub_1000F50E+82j
		movzx	eax, byte ptr [edi]
		inc	edi
		add	ebx, eax
		cmp	eax, 0FFh
		jz	short loc_1000F585
		lea	eax, [ebx+esi]
		cmp	eax, esi
		jb	loc_1000F6AC

loc_1000F59D:				; CODE XREF: sub_1000F50E+75j
		lea	ecx, [ebx+esi]
		lea	eax, [edx-8]
		cmp	ecx, eax
		ja	loc_1000F695
		push	4
		pop	ebx

loc_1000F5AE:				; CODE XREF: sub_1000F50E+B2j
		mov	eax, [edi]
		add	edi, ebx
		mov	[esi], eax
		add	esi, ebx
		mov	eax, [edi]
		add	edi, ebx
		mov	[esi], eax
		add	esi, ebx
		cmp	esi, ecx
		jb	short loc_1000F5AE
		mov	eax, ecx
		mov	edx, ecx
		sub	eax, esi
		and	ebp, 0Fh
		add	edi, eax
		movzx	eax, word ptr [edi]
		add	edi, 2
		sub	edx, eax
		cmp	ebp, 0Fh
		jnz	short loc_1000F5F2

loc_1000F5DA:				; CODE XREF: sub_1000F50E+D7j
		movzx	eax, byte ptr [edi]
		inc	edi
		add	ebp, eax
		cmp	eax, 0FFh
		jz	short loc_1000F5DA
		lea	eax, [ecx+ebp]
		cmp	eax, ecx
		jb	loc_1000F6AC

loc_1000F5F2:				; CODE XREF: sub_1000F50E+CAj
		mov	esi, ecx
		sub	esi, edx
		cmp	esi, ebx
		jge	short loc_1000F61D
		mov	al, [edx]
		mov	[ecx], al
		mov	al, [edx+1]
		mov	[ecx+1], al
		mov	al, [edx+2]
		mov	[ecx+2], al
		mov	al, [edx+3]
		add	edx, [esp+esi*4+3Ch+var_24]
		mov	[ecx+3], al
		add	ecx, 4
		mov	eax, [edx]
		mov	[ecx], eax
		jmp	short loc_1000F626
; ---------------------------------------------------------------------------

loc_1000F61D:				; CODE XREF: sub_1000F50E+EAj
		mov	eax, [edx]
		mov	[ecx], eax
		add	ecx, 4
		add	edx, ebx

loc_1000F626:				; CODE XREF: sub_1000F50E+10Dj
		mov	eax, [esp+3Ch+var_2C]
		lea	esi, [ecx+ebp]
		lea	ebx, [eax-8]
		cmp	esi, ebx
		jbe	short loc_1000F675
		add	eax, 0FFFFFFFBh
		cmp	esi, eax
		ja	short loc_1000F6AC
		cmp	ecx, ebx
		jnb	short loc_1000F656
		push	4
		pop	ebp

loc_1000F642:				; CODE XREF: sub_1000F50E+146j
		mov	eax, [edx]
		add	edx, ebp
		mov	[ecx], eax
		add	ecx, ebp
		mov	eax, [edx]
		add	edx, ebp
		mov	[ecx], eax
		add	ecx, ebp
		cmp	ecx, ebx
		jb	short loc_1000F642

loc_1000F656:				; CODE XREF: sub_1000F50E+12Fj
		mov	eax, esi
		xor	ebp, ebp
		sub	eax, ecx
		cmp	esi, ecx
		sbb	ebx, ebx
		not	ebx
		and	ebx, eax
		jbe	short loc_1000F68C
		sub	edx, ecx

loc_1000F668:				; CODE XREF: sub_1000F50E+163j
		mov	al, [edx+ecx]
		mov	[ecx], al
		inc	ecx
		inc	ebp
		cmp	ebp, ebx
		jb	short loc_1000F668
		jmp	short loc_1000F68C
; ---------------------------------------------------------------------------

loc_1000F675:				; CODE XREF: sub_1000F50E+124j
		push	4
		pop	ebp

loc_1000F678:				; CODE XREF: sub_1000F50E+17Cj
		mov	eax, [edx]
		add	edx, ebp
		mov	[ecx], eax
		add	ecx, ebp
		mov	eax, [edx]
		add	edx, ebp
		mov	[ecx], eax
		add	ecx, ebp
		cmp	ecx, esi
		jb	short loc_1000F678

loc_1000F68C:				; CODE XREF: sub_1000F50E+156j
					; sub_1000F50E+165j
		mov	edx, [esp+3Ch+var_2C]
		jmp	loc_1000F577
; ---------------------------------------------------------------------------

loc_1000F695:				; CODE XREF: sub_1000F50E+97j
		cmp	ecx, edx
		jnz	short loc_1000F6AC
		push	ebx		; size_t
		push	edi		; void *
		push	esi		; void *
		call	memcpy
		sub	ebx, [esp+48h+var_28]
		add	esp, 0Ch
		add	ebx, edi
		jmp	short loc_1000F6B3
; ---------------------------------------------------------------------------

loc_1000F6AC:				; CODE XREF: sub_1000F50E+89j
					; sub_1000F50E+DEj ...
		mov	ebx, [esp+3Ch+var_28]
		sub	ebx, edi
		dec	ebx

loc_1000F6B3:				; CODE XREF: sub_1000F50E+64j
					; sub_1000F50E+19Cj
		mov	ecx, [esp+3Ch+var_4]
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 2Ch
		retn
sub_1000F50E	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000F6C8	proc near		; CODE XREF: mozilla::Compression::LZ4::decompress(char	const *,uint,char *,uint,uint *)+Fp

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		sub	esp, 38h
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+38h+var_4], eax
		mov	eax, [esp+38h+arg_4]
		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+44h+arg_0]
		mov	ebp, edx
		push	edi
		mov	[esp+48h+var_30], ebp
		mov	ebx, ebp
		add	ebp, eax
		mov	[esp+48h+var_2C], ecx
		mov	[esp+48h+var_34], ebp
		lea	edx, [ecx+esi]
		mov	[esp+48h+var_38], edx
		mov	edi, ecx
		mov	[esp+48h+var_20], 1
		mov	[esp+48h+var_1C], 2
		mov	[esp+48h+var_18], 1
		push	4
		pop	ebp
		mov	[esp+48h+var_24], ebp
		mov	[esp+48h+var_14], ebp
		mov	[esp+48h+var_10], ebp
		mov	[esp+48h+var_C], ebp
		mov	[esp+48h+var_8], ebp
		test	eax, eax
		jnz	short loc_1000F748
		cmp	esi, 1
		jnz	short loc_1000F740
		cmp	[ecx], al
		jnz	short loc_1000F740
		xor	esi, esi
		jmp	loc_1000F8D3
; ---------------------------------------------------------------------------

loc_1000F740:				; CODE XREF: sub_1000F6C8+6Bj
					; sub_1000F6C8+6Fj
		or	esi, 0FFFFFFFFh
		jmp	loc_1000F8D3
; ---------------------------------------------------------------------------

loc_1000F748:				; CODE XREF: sub_1000F6C8+66j
					; sub_1000F6C8+1DDj
		movzx	esi, byte ptr [edi]
		inc	edi
		mov	[esp+48h+var_28], esi
		shr	esi, 4
		cmp	esi, 0Fh
		jnz	short loc_1000F782
		lea	ecx, [edx-0Fh]

loc_1000F75B:				; CODE XREF: sub_1000F6C8+A2j
		movzx	eax, byte ptr [edi]
		inc	edi
		add	esi, eax
		cmp	edi, ecx
		jnb	short loc_1000F76C
		cmp	eax, 0FFh
		jz	short loc_1000F75B

loc_1000F76C:				; CODE XREF: sub_1000F6C8+9Bj
		lea	eax, [esi+ebx]
		cmp	eax, ebx
		jb	loc_1000F8CC
		lea	eax, [esi+edi]
		cmp	eax, edi
		jb	loc_1000F8CC

loc_1000F782:				; CODE XREF: sub_1000F6C8+8Ej
		mov	ecx, [esp+48h+var_34]
		lea	ebp, [esi+ebx]
		lea	eax, [ecx-0Ch]
		cmp	ebp, eax
		ja	loc_1000F8AE
		lea	ecx, [esi+edi]
		lea	eax, [edx-8]
		cmp	ecx, eax
		ja	loc_1000F8AA
		push	4
		pop	esi

loc_1000F7A5:				; CODE XREF: sub_1000F6C8+EFj
		mov	eax, [edi]
		add	edi, esi
		mov	[ebx], eax
		add	ebx, esi
		mov	eax, [edi]
		add	edi, esi
		mov	[ebx], eax
		add	ebx, esi
		cmp	ebx, ebp
		jb	short loc_1000F7A5
		mov	eax, ebp
		mov	edx, ebp
		sub	eax, ebx
		add	edi, eax
		movzx	eax, word ptr [edi]
		add	edi, 2
		sub	edx, eax
		cmp	edx, [esp+48h+var_30]
		jb	loc_1000F8CC
		mov	ebx, [esp+48h+var_28]
		and	ebx, 0Fh
		cmp	ebx, 0Fh
		jnz	short loc_1000F806
		mov	ecx, [esp+48h+var_38]
		add	ecx, 0FFFFFFFBh

loc_1000F7E6:				; CODE XREF: sub_1000F6C8+131j
		cmp	edi, ecx
		ja	loc_1000F8CC
		movzx	eax, byte ptr [edi]
		inc	edi
		add	ebx, eax
		cmp	eax, 0FFh
		jz	short loc_1000F7E6
		lea	eax, [ebx+ebp]
		cmp	eax, ebp
		jb	loc_1000F8CC

loc_1000F806:				; CODE XREF: sub_1000F6C8+115j
		mov	ecx, ebp
		sub	ecx, edx
		cmp	ecx, esi
		jge	short loc_1000F832
		mov	al, [edx]
		mov	[ebp+0], al
		mov	al, [edx+1]
		mov	[ebp+1], al
		mov	al, [edx+2]
		mov	[ebp+2], al
		mov	al, [edx+3]
		add	edx, [esp+ecx*4+48h+var_24]
		lea	ecx, [ebp+4]
		mov	[ebp+3], al
		mov	eax, [edx]
		mov	[ecx], eax
		jmp	short loc_1000F83C
; ---------------------------------------------------------------------------

loc_1000F832:				; CODE XREF: sub_1000F6C8+144j
		mov	eax, [edx]
		lea	ecx, [ebp+4]
		mov	[ebp+0], eax
		add	edx, esi

loc_1000F83C:				; CODE XREF: sub_1000F6C8+168j
		mov	ebp, [esp+48h+var_34]
		add	ebx, ecx
		lea	esi, [ebp-8]
		cmp	ebx, esi
		jbe	short loc_1000F88A
		lea	eax, [ebp-5]
		cmp	ebx, eax
		ja	short loc_1000F8CC
		cmp	ecx, esi
		jnb	short loc_1000F86B
		push	4
		pop	ebp

loc_1000F857:				; CODE XREF: sub_1000F6C8+1A1j
		mov	eax, [edx]
		add	edx, ebp
		mov	[ecx], eax
		add	ecx, ebp
		mov	eax, [edx]
		add	edx, ebp
		mov	[ecx], eax
		add	ecx, ebp
		cmp	ecx, esi
		jb	short loc_1000F857

loc_1000F86B:				; CODE XREF: sub_1000F6C8+18Aj
		mov	eax, ebx
		xor	ebp, ebp
		sub	eax, ecx
		cmp	ebx, ecx
		sbb	esi, esi
		not	esi
		and	esi, eax
		jbe	short loc_1000F8A1
		sub	edx, ecx

loc_1000F87D:				; CODE XREF: sub_1000F6C8+1BEj
		mov	al, [edx+ecx]
		mov	[ecx], al
		inc	ecx
		inc	ebp
		cmp	ebp, esi
		jb	short loc_1000F87D
		jmp	short loc_1000F8A1
; ---------------------------------------------------------------------------

loc_1000F88A:				; CODE XREF: sub_1000F6C8+17Fj
		push	4
		pop	ebp

loc_1000F88D:				; CODE XREF: sub_1000F6C8+1D7j
		mov	eax, [edx]
		add	edx, ebp
		mov	[ecx], eax
		add	ecx, ebp
		mov	eax, [edx]
		add	edx, ebp
		mov	[ecx], eax
		add	ecx, ebp
		cmp	ecx, ebx
		jb	short loc_1000F88D

loc_1000F8A1:				; CODE XREF: sub_1000F6C8+1B1j
					; sub_1000F6C8+1C0j
		mov	edx, [esp+48h+var_38]
		jmp	loc_1000F748
; ---------------------------------------------------------------------------

loc_1000F8AA:				; CODE XREF: sub_1000F6C8+D4j
		mov	ecx, [esp+48h+var_34]

loc_1000F8AE:				; CODE XREF: sub_1000F6C8+C6j
		lea	eax, [esi+edi]
		cmp	eax, edx
		jnz	short loc_1000F8CC
		cmp	ebp, ecx
		ja	short loc_1000F8CC
		push	esi		; size_t
		push	edi		; void *
		push	ebx		; void *
		call	memcpy
		sub	esi, [esp+54h+var_30]
		add	esp, 0Ch
		add	esi, ebx
		jmp	short loc_1000F8D3
; ---------------------------------------------------------------------------

loc_1000F8CC:				; CODE XREF: sub_1000F6C8+A9j
					; sub_1000F6C8+B4j ...
		mov	esi, [esp+48h+var_2C]
		sub	esi, edi
		dec	esi

loc_1000F8D3:				; CODE XREF: sub_1000F6C8+73j
					; sub_1000F6C8+7Bj ...
		mov	ecx, [esp+48h+var_4]
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 38h
		retn
sub_1000F6C8	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000F8E8	proc near		; CODE XREF: sub_100113D1+38p
					; sub_10011434+38p
		push	esi
		mov	esi, ecx
		test	esi, esi
		jnz	short loc_1000F8F3
		xor	eax, eax
		jmp	short loc_1000F8FA
; ---------------------------------------------------------------------------

loc_1000F8F3:				; CODE XREF: sub_1000F8E8+5j
		mov	eax, [esi]
		mov	eax, [eax+4]
		add	eax, esi

loc_1000F8FA:				; CODE XREF: sub_1000F8E8+9j
		push	dword ptr [edx+0Ch]
		push	dword ptr [edx+8]
		push	eax
		call	dword ptr [edx]
		add	esp, 0Ch
		mov	eax, esi
		pop	esi
		retn
sub_1000F8E8	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_1000F90A(double)
sub_1000F90A	proc near		; CODE XREF: WebCore::Decimal::fromDouble(double)+24p

arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		fld	[ebp+arg_0]
		lea	eax, [ebp+arg_0]
		push	eax
		fstp	[ebp+arg_0]
		call	ds:_dtest
		pop	ecx
		xor	ecx, ecx
		test	ax, ax
		setle	al
		pop	ebp
		retn
sub_1000F90A	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_1000F928(double)
sub_1000F928	proc near		; CODE XREF: WebCore::Decimal::fromDouble(double):loc_10010E28p

arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		fld	[ebp+arg_0]
		lea	eax, [ebp+arg_0]
		push	eax
		fstp	[ebp+arg_0]
		call	ds:_dtest
		pop	ecx
		xor	ecx, ecx
		cmp	ax, 1
		setz	al
		pop	ebp
		retn
sub_1000F928	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000F947	proc near		; CODE XREF: sub_100113D1+14p
					; sub_10011434+14p

var_4		= dword	ptr -4

		push	ecx
		push	ebx
		push	esi
		push	edi
		mov	edi, ecx
		xor	ebx, ebx
		mov	[esp+10h+var_4], ebx
		lea	ecx, [edi+50h]
		mov	dword ptr [edi], offset	dword_100174C4
		call	ds:??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ;	std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(void)
		push	ebx
		push	ebx
		lea	esi, [edi+4]
		mov	ecx, edi
		push	esi
		call	ds:??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(std::basic_streambuf<char,std::char_traits<char>> *,bool)
		mov	eax, [edi]
		mov	eax, [eax+4]
		mov	dword ptr [edi+eax], offset off_100174BC
		mov	eax, [edi]
		mov	ecx, [eax+4]
		lea	eax, [ecx-50h]
		mov	[ecx+edi-4], eax
		mov	ecx, esi
		call	ds:??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(void)
		mov	eax, edi
		mov	[esi+38h], ebx
		pop	edi
		mov	dword ptr [esi], offset	off_10016430
		mov	dword ptr [esi+3Ch], 4
		pop	esi
		pop	ebx
		pop	ecx
		retn	8
sub_1000F947	endp


; =============== S U B	R O U T	I N E =======================================


; int __stdcall	sub_1000F9A9(void *)
sub_1000F9A9	proc near		; CODE XREF: sub_10011C58+A5p

arg_0		= dword	ptr  4

		push	esi
		push	[esp+4+arg_0]	; void *
		mov	esi, ecx
		and	dword ptr [esi+10h], 0
		mov	dword ptr [esi+14h], 0Fh
		mov	byte ptr [esi],	0
		call	sub_10010487
		mov	eax, esi
		pop	esi
		retn	4
sub_1000F9A9	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000F9C9	proc near		; CODE XREF: sub_10011268+19p
					; sub_1001128D+11p ...

arg_0		= dword	ptr  4

		push	esi
		mov	esi, ecx
		mov	ecx, [esp+4+arg_0]
		and	dword ptr [esi+10h], 0
		mov	dword ptr [esi+14h], 0Fh
		mov	byte ptr [esi],	0
		call	sub_10011250
		push	eax		; size_t
		push	[esp+8+arg_0]	; void *
		mov	ecx, esi	; void *
		call	sub_10010A1A
		mov	eax, esi
		pop	esi
		retn	4
sub_1000F9C9	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000F9F5	proc near		; CODE XREF: sub_10011C58+58p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	[esp+4+arg_4]	; size_t
		mov	esi, ecx
		push	[esp+8+arg_0]	; void *
		and	dword ptr [esi+10h], 0
		mov	dword ptr [esi+14h], 0Fh
		mov	byte ptr [esi],	0
		call	sub_10010A1A
		mov	eax, esi
		pop	esi
		retn	8
sub_1000F9F5	endp

; Exported entry   1. ??0Decimal@WebCore@@QAE@ABV01@@Z
; Exported entry   2. ??0Decimal@WebCore@@QAE@ABVEncodedData@01@@Z
; Exported entry   7. ??4Decimal@WebCore@@QAEAAV01@ABV01@@Z

; =============== S U B	R O U T	I N E =======================================


; public: class	WebCore::Decimal & __thiscall WebCore::Decimal::operator=(class	WebCore::Decimal const &)
		public ??4Decimal@WebCore@@QAEAAV01@ABV01@@Z
??4Decimal@WebCore@@QAEAAV01@ABV01@@Z proc near	; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

		push	esi		; public: __thiscall WebCore::Decimal::Decimal(class WebCore::Decimal const &)
					; public: __thiscall WebCore::Decimal::Decimal(class WebCore::Decimal::EncodedData const &)
		mov	esi, [esp+4+arg_0]
		mov	eax, ecx
		push	edi
		push	6
		pop	ecx
		mov	edi, eax
		rep movsd
		pop	edi
		pop	esi
		retn	4
??4Decimal@WebCore@@QAEAAV01@ABV01@@Z endp

; Exported entry   4. ??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall WebCore::Decimal::Decimal(enum  WebCore::Decimal::Sign, int, unsigned __int64)
		public ??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z
??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	proc near
					; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+17Bp
					; WebCore::Decimal::operator-(WebCore::Decimal const &)+AFp ...

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		or	eax, [ebp+arg_C]
		push	esi
		mov	esi, ecx
		jz	short loc_1000FA40
		mov	eax, [ebp+arg_4]
		jmp	short loc_1000FA42
; ---------------------------------------------------------------------------

loc_1000FA40:				; CODE XREF: WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned __int64)+Cj
		xor	eax, eax

loc_1000FA42:				; CODE XREF: WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned __int64)+11j
		push	[ebp+arg_C]
		push	[ebp+arg_8]
		push	eax
		push	[ebp+arg_0]
		call	sub_1000AE6E
		mov	eax, esi
		pop	esi
		pop	ebp
		retn	10h
??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	endp


; =============== S U B	R O U T	I N E =======================================


sub_1000FA58	proc near		; CODE XREF: sub_10010405+6p
		push	esi
		push	edi
		mov	edi, ecx
		mov	eax, [edi-50h]
		lea	esi, [edi-4Ch]
		mov	ecx, esi
		mov	eax, [eax+4]
		mov	dword ptr [eax+edi-50h], offset	off_100174BC
		mov	eax, [edi-50h]
		mov	edx, [eax+4]
		lea	eax, [edx-50h]
		mov	[edx+edi-54h], eax
		mov	dword ptr [esi], offset	off_10016430
		call	sub_10010627
		mov	ecx, esi
		call	ds:??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(void)
		lea	ecx, [edi-48h]
		pop	edi
		pop	esi
		jmp	ds:??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char>>::~basic_ostream<char,std::char_traits<char>>(void)
sub_1000FA58	endp

; Exported entry   8. ??8Decimal@WebCore@@QBE_NABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall WebCore::Decimal::operator==(class WebCore::Decimal const &)const
		public ??8Decimal@WebCore@@QBE_NABV01@@Z
??8Decimal@WebCore@@QBE_NABV01@@Z proc near ; DATA XREF: .rdata:off_100175A8o

var_18		= byte ptr -18h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 1Ch
		cmp	dword ptr [ecx+0Ch], 2
		push	esi
		jz	short loc_1000FAD7
		mov	esi, [ebp+arg_0]
		cmp	dword ptr [esi+0Ch], 2
		jz	short loc_1000FAD7
		push	esi
		call	sub_1000FAE0
		test	al, al
		jnz	short loc_1000FAD2
		push	esi
		lea	eax, [esp+24h+var_18]
		push	eax
		call	?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z ;	WebCore::Decimal::compareTo(WebCore::Decimal const &)
		cmp	dword ptr [eax+0Ch], 3
		jz	short loc_1000FAD2
		xor	eax, eax
		jmp	short loc_1000FAD9
; ---------------------------------------------------------------------------

loc_1000FAD2:				; CODE XREF: WebCore::Decimal::operator==(WebCore::Decimal const &)+21j
					; WebCore::Decimal::operator==(WebCore::Decimal	const &)+32j
		xor	eax, eax
		inc	eax
		jmp	short loc_1000FAD9
; ---------------------------------------------------------------------------

loc_1000FAD7:				; CODE XREF: WebCore::Decimal::operator==(WebCore::Decimal const &)+Ej
					; WebCore::Decimal::operator==(WebCore::Decimal	const &)+17j
		xor	al, al

loc_1000FAD9:				; CODE XREF: WebCore::Decimal::operator==(WebCore::Decimal const &)+36j
					; WebCore::Decimal::operator==(WebCore::Decimal	const &)+3Bj
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn	4
??8Decimal@WebCore@@QBE_NABV01@@Z endp


; =============== S U B	R O U T	I N E =======================================


sub_1000FAE0	proc near		; CODE XREF: WebCore::Decimal::operator==(WebCore::Decimal const &)+1Ap
					; WebCore::Decimal::operator!=(WebCore::Decimal	const &)+1Ap ...

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		mov	eax, [ecx+10h]
		cmp	eax, [edx+10h]
		jnz	short loc_1000FB11
		mov	eax, [ecx+0Ch]
		cmp	eax, [edx+0Ch]
		jnz	short loc_1000FB11
		mov	ax, [ecx+8]
		cmp	ax, [edx+8]
		jnz	short loc_1000FB11
		mov	eax, [ecx]
		cmp	eax, [edx]
		jnz	short loc_1000FB11
		mov	eax, [ecx+4]
		cmp	eax, [edx+4]
		jnz	short loc_1000FB11
		xor	eax, eax
		inc	eax
		jmp	short locret_1000FB13
; ---------------------------------------------------------------------------

loc_1000FB11:				; CODE XREF: sub_1000FAE0+Aj
					; sub_1000FAE0+12j ...
		xor	eax, eax

locret_1000FB13:			; CODE XREF: sub_1000FAE0+2Fj
		retn	4
sub_1000FAE0	endp

; Exported entry   9. ??9Decimal@WebCore@@QBE_NABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall WebCore::Decimal::operator!=(class WebCore::Decimal const &)const
		public ??9Decimal@WebCore@@QBE_NABV01@@Z
??9Decimal@WebCore@@QBE_NABV01@@Z proc near ; DATA XREF: .rdata:off_100175A8o

var_18		= byte ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 1Ch
		cmp	dword ptr [ecx+0Ch], 2
		push	esi
		jz	short loc_1000FB5B
		mov	esi, [ebp+arg_0]
		cmp	dword ptr [esi+0Ch], 2
		jz	short loc_1000FB5B
		push	esi
		call	sub_1000FAE0
		test	al, al
		jz	short loc_1000FB3D

loc_1000FB39:				; CODE XREF: WebCore::Decimal::operator!=(WebCore::Decimal const &)+37j
		xor	al, al
		jmp	short loc_1000FB5D
; ---------------------------------------------------------------------------

loc_1000FB3D:				; CODE XREF: WebCore::Decimal::operator!=(WebCore::Decimal const &)+21j
		push	esi
		lea	eax, [esp+24h+var_18]
		push	eax
		call	?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z ;	WebCore::Decimal::compareTo(WebCore::Decimal const &)
		cmp	[esp+20h+var_C], 2
		jz	short loc_1000FB39
		xor	eax, eax
		cmp	[esp+20h+var_C], 3
		setnz	al
		jmp	short loc_1000FB5D
; ---------------------------------------------------------------------------

loc_1000FB5B:				; CODE XREF: WebCore::Decimal::operator!=(WebCore::Decimal const &)+Ej
					; WebCore::Decimal::operator!=(WebCore::Decimal	const &)+17j
		mov	al, 1

loc_1000FB5D:				; CODE XREF: WebCore::Decimal::operator!=(WebCore::Decimal const &)+25j
					; WebCore::Decimal::operator!=(WebCore::Decimal	const &)+43j
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn	4
??9Decimal@WebCore@@QBE_NABV01@@Z endp

; Exported entry  10. ??DDecimal@WebCore@@QBE?AV01@ABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal __thiscall WebCore::Decimal::operator*(class WebCore::Decimal const &)const
		public ??DDecimal@WebCore@@QBE?AV01@ABV01@@Z
??DDecimal@WebCore@@QBE?AV01@ABV01@@Z proc near
					; CODE XREF: WebCore::Decimal::operator*=(WebCore::Decimal const &)+16p
					; WebCore::Decimal::remainder(WebCore::Decimal const &)+64p
					; DATA XREF: ...

var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_74		= dword	ptr -74h
var_70		= dword	ptr -70h
var_6C		= dword	ptr -6Ch
var_68		= dword	ptr -68h
var_64		= dword	ptr -64h
var_60		= byte ptr -60h
var_48		= byte ptr -48h
var_30		= byte ptr -30h
var_18		= byte ptr -18h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 7Ch
		push	ebx
		push	esi
		mov	esi, [ebp+arg_4]
		xor	ebx, ebx
		push	edi
		mov	edi, ecx
		mov	[esp+88h+var_6C], esi
		lea	ecx, [esp+88h+var_70]
		mov	[esp+88h+var_7C], edi
		mov	[esp+88h+var_70], edi
		mov	[esp+88h+var_68], 2
		mov	eax, [edi+10h]
		cmp	eax, [esi+10h]
		setnz	bl
		mov	[esp+88h+var_74], ebx
		call	sub_100111A6
		xor	edx, edx
		sub	eax, edx
		jz	short loc_1000FC20
		dec	eax
		jz	short loc_1000FC14
		dec	eax
		jz	short loc_1000FC03
		dec	eax
		jz	short loc_1000FBD3
		dec	eax
		jz	short loc_1000FBC1
		push	[ebp+arg_0]
		call	?nan@Decimal@WebCore@@SA?AV12@XZ ; WebCore::Decimal::nan(void)

loc_1000FBBB:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+BAj
		pop	ecx
		jmp	loc_1000FCE4
; ---------------------------------------------------------------------------

loc_1000FBC1:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+4Dj
		cmp	dword ptr [edi+0Ch], 3
		jnz	short loc_1000FBCD
		lea	eax, [esp+88h+var_60]
		jmp	short loc_1000FBDD
; ---------------------------------------------------------------------------

loc_1000FBCD:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+61j
		lea	eax, [esp+88h+var_48]
		jmp	short loc_1000FBE9
; ---------------------------------------------------------------------------

loc_1000FBD3:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+4Aj
		cmp	dword ptr [esi+0Ch], 3
		jnz	short loc_1000FBE5
		lea	eax, [esp+88h+var_30]

loc_1000FBDD:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+67j
		push	eax
		call	?nan@Decimal@WebCore@@SA?AV12@XZ ; WebCore::Decimal::nan(void)
		jmp	short loc_1000FBF1
; ---------------------------------------------------------------------------

loc_1000FBE5:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+73j
		lea	eax, [esp+88h+var_18]

loc_1000FBE9:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+6Dj
		push	ebx
		push	eax
		call	?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z	; WebCore::Decimal::infinity(WebCore::Decimal::Sign)
		pop	ecx

loc_1000FBF1:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+7Fj
		pop	ecx
		mov	esi, eax
		mov	eax, [ebp+arg_0]
		push	6
		pop	ecx
		mov	edi, eax
		rep movsd
		jmp	loc_1000FCE7
; ---------------------------------------------------------------------------

loc_1000FC03:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+47j
		push	[ebp+arg_0]
		lea	ecx, [esp+8Ch+var_70]
		call	sub_10012208
		jmp	loc_1000FCE4
; ---------------------------------------------------------------------------

loc_1000FC14:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+44j
		push	ebx
		push	[ebp+arg_0]
		call	?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z	; WebCore::Decimal::infinity(WebCore::Decimal::Sign)
		pop	ecx
		jmp	short loc_1000FBBB
; ---------------------------------------------------------------------------

loc_1000FC20:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+41j
		movsx	eax, word ptr [edi+8]
		movsx	ecx, word ptr [esi+8]
		push	edx
		push	dword ptr [edi]
		add	ecx, eax
		push	edx
		push	dword ptr [esi]
		mov	[esp+98h+var_78], ecx
		call	__allmul
		mov	eax, [esp+88h+var_7C]
		xor	edi, edi
		mov	ebx, [ebp+arg_4]
		mov	esi, edx
		push	edi
		push	dword ptr [eax+4]
		push	edi
		push	dword ptr [ebx]
		call	__allmul
		add	esi, eax
		mov	eax, [esp+88h+var_7C]
		push	0
		adc	edi, edx
		push	dword ptr [eax]
		push	0
		push	dword ptr [ebx+4]
		call	__allmul
		add	eax, esi
		mov	ebx, edx
		mov	eax, [esp+88h+var_7C]
		push	0
		pop	ecx
		adc	ebx, ecx
		xor	esi, esi
		push	ecx
		push	dword ptr [eax+4]
		add	ebx, edi
		mov	edi, [ebp+arg_4]
		push	ecx
		adc	esi, ecx
		push	dword ptr [edi+4]
		call	__allmul
		add	ebx, eax
		mov	eax, [esp+88h+var_7C]
		mov	[esp+88h+var_70], ebx
		adc	esi, edx
		mov	[esp+88h+var_6C], esi
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		push	dword ptr [edi+4]
		push	dword ptr [edi]
		call	__allmul
		or	ebx, esi
		mov	[esp+88h+var_68], eax
		mov	esi, [esp+88h+var_78]
		mov	[esp+88h+var_64], edx
		jz	short loc_1000FCD5

loc_1000FCB8:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+167j
		push	ecx
		lea	ecx, [esp+8Ch+var_70]
		call	sub_10010350
		mov	eax, [esp+88h+var_70]
		inc	esi
		or	eax, [esp+88h+var_6C]
		jnz	short loc_1000FCB8
		mov	edx, [esp+88h+var_64]
		mov	eax, [esp+88h+var_68]

loc_1000FCD5:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+152j
		mov	ecx, [ebp+arg_0]
		push	edx
		push	eax
		push	esi
		push	[esp+94h+var_74]
		call	??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	; WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned	__int64)

loc_1000FCE4:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+58j
					; WebCore::Decimal::operator*(WebCore::Decimal const &)+ABj
		mov	eax, [ebp+arg_0]

loc_1000FCE7:				; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+9Aj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??DDecimal@WebCore@@QBE?AV01@ABV01@@Z endp

; Exported entry  11. ??GDecimal@WebCore@@QBE?AV01@ABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal __thiscall WebCore::Decimal::operator-(class WebCore::Decimal const &)const
		public ??GDecimal@WebCore@@QBE?AV01@ABV01@@Z
??GDecimal@WebCore@@QBE?AV01@ABV01@@Z proc near
					; CODE XREF: WebCore::Decimal::operator-=(WebCore::Decimal const &)+16p
					; WebCore::Decimal::compareTo(WebCore::Decimal const &)+13p ...

var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_18		= byte ptr -18h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 34h
		mov	eax, [ebp+arg_4]
		push	ebx
		push	esi
		mov	esi, ecx
		mov	[esp+3Ch+var_2C], eax
		mov	ebx, [eax+10h]
		lea	ecx, [esp+3Ch+var_30]
		push	edi
		mov	[esp+40h+var_30], esi
		mov	edi, [esi+10h]
		mov	[esp+40h+var_34], edi
		mov	[esp+40h+var_28], 2
		call	sub_100111A6
		dec	eax
		jz	loc_1000FE00
		dec	eax
		jz	loc_1000FDEF
		dec	eax
		jz	loc_1000FE20
		dec	eax
		jz	loc_1000FDDA
		push	[ebp+arg_4]
		lea	eax, [esp+44h+var_18]
		push	esi
		push	eax
		call	?alignOperands@Decimal@WebCore@@CA?AUAlignedOperands@12@ABV12@0@Z ; WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)
		add	esp, 0Ch
		lea	edi, [esp+40h+var_30]
		mov	esi, eax
		push	6
		pop	ecx
		rep movsd
		mov	esi, [esp+40h+var_34]
		cmp	esi, ebx
		jnz	short loc_1000FD76
		mov	edx, [esp+40h+var_30]
		sub	edx, [esp+40h+var_28]
		mov	ecx, [esp+40h+var_2C]
		sbb	ecx, [esp+40h+var_24]
		jmp	short loc_1000FD86
; ---------------------------------------------------------------------------

loc_1000FD76:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+72j
		mov	edx, [esp+40h+var_28]
		add	edx, [esp+40h+var_30]
		mov	ecx, [esp+40h+var_24]
		adc	ecx, [esp+40h+var_2C]

loc_1000FD86:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+84j
		cmp	esi, 1
		jnz	short loc_1000FDA6
		cmp	ebx, esi
		jnz	short loc_1000FDA6
		mov	eax, edx
		or	eax, ecx
		jnz	short loc_1000FDA6
		mov	ecx, [ebp+arg_0]
		push	eax
		push	eax
		push	[esp+48h+var_20]
		push	eax
		call	??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	; WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned	__int64)
		jmp	short loc_1000FDFB
; ---------------------------------------------------------------------------

loc_1000FDA6:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+99j
					; WebCore::Decimal::operator-(WebCore::Decimal const &)+9Dj ...
		test	ecx, ecx
		jl	short loc_1000FDB9
		jg	short loc_1000FDB0
		test	edx, edx
		jb	short loc_1000FDB9

loc_1000FDB0:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+BAj
		push	ecx
		push	edx
		push	[esp+48h+var_20]
		push	esi
		jmp	short loc_1000FDCF
; ---------------------------------------------------------------------------

loc_1000FDB9:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+B8j
					; WebCore::Decimal::operator-(WebCore::Decimal const &)+BEj
		xor	eax, eax
		cmp	esi, 1
		setnz	al
		neg	edx
		adc	ecx, 0
		neg	ecx
		push	ecx
		push	edx
		push	[esp+48h+var_20]
		push	eax

loc_1000FDCF:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+C7j
		lea	ecx, [esp+50h+var_18]
		call	??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	; WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned	__int64)
		jmp	short loc_1000FE1E
; ---------------------------------------------------------------------------

loc_1000FDDA:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+4Aj
		xor	eax, eax
		cmp	ebx, 1
		setnz	al
		push	eax
		push	[ebp+arg_0]
		call	?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z	; WebCore::Decimal::infinity(WebCore::Decimal::Sign)
		pop	ecx
		pop	ecx
		jmp	short loc_1000FDFB
; ---------------------------------------------------------------------------

loc_1000FDEF:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+3Cj
		push	[ebp+arg_0]
		lea	ecx, [esp+44h+var_30]
		call	sub_10012208

loc_1000FDFB:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+B4j
					; WebCore::Decimal::operator-(WebCore::Decimal const &)+FDj
		mov	eax, [ebp+arg_0]
		jmp	short loc_1000FE2A
; ---------------------------------------------------------------------------

loc_1000FE00:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+35j
		cmp	edi, ebx
		jnz	short loc_1000FE11
		lea	eax, [esp+40h+var_18]
		push	eax
		call	?nan@Decimal@WebCore@@SA?AV12@XZ ; WebCore::Decimal::nan(void)
		pop	ecx
		jmp	short loc_1000FE1E
; ---------------------------------------------------------------------------

loc_1000FE11:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+112j
		push	6
		pop	ecx
		lea	edi, [esp+40h+var_30]
		rep movsd
		lea	eax, [esp+40h+var_30]

loc_1000FE1E:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+E8j
					; WebCore::Decimal::operator-(WebCore::Decimal const &)+11Fj
		mov	esi, eax

loc_1000FE20:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+43j
		mov	eax, [ebp+arg_0]
		mov	edi, eax
		push	6
		pop	ecx
		rep movsd

loc_1000FE2A:				; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+10Ej
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??GDecimal@WebCore@@QBE?AV01@ABV01@@Z endp

; Exported entry  12. ??GDecimal@WebCore@@QBE?AV01@XZ

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal __thiscall WebCore::Decimal::operator-(void)const
		public ??GDecimal@WebCore@@QBE?AV01@XZ
??GDecimal@WebCore@@QBE?AV01@XZ	proc near ; DATA XREF: .rdata:off_100175A8o

var_18		= byte ptr -18h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, ecx
		cmp	dword ptr [edx+0Ch], 2
		push	esi
		push	edi
		push	6
		mov	esi, edx
		pop	ecx
		jz	short loc_1000FE5F
		xor	eax, eax
		lea	edi, [ebp+var_18]
		cmp	dword ptr [edx+10h], 1
		rep movsd
		setnz	al
		lea	esi, [ebp+var_18]
		push	6
		mov	[ebp+var_8], eax
		pop	ecx

loc_1000FE5F:				; CODE XREF: WebCore::Decimal::operator-(void)+13j
		mov	eax, [ebp+arg_0]
		mov	edi, eax
		rep movsd
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn	4
??GDecimal@WebCore@@QBE?AV01@XZ	endp

; Exported entry  14. ??HDecimal@WebCore@@QBE?AV01@ABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal __thiscall WebCore::Decimal::operator+(class WebCore::Decimal const &)const
		public ??HDecimal@WebCore@@QBE?AV01@ABV01@@Z
??HDecimal@WebCore@@QBE?AV01@ABV01@@Z proc near
					; CODE XREF: WebCore::Decimal::operator+=(WebCore::Decimal const &)+16p
					; DATA XREF: .rdata:off_100175A8o

var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_18		= byte ptr -18h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 34h
		push	ebx
		push	esi
		push	edi
		mov	edi, [ebp+arg_4]
		mov	esi, ecx
		lea	ecx, [esp+40h+var_30]
		mov	[esp+40h+var_30], esi
		mov	[esp+40h+var_2C], edi
		mov	[esp+40h+var_28], 2
		mov	eax, [edi+10h]
		mov	ebx, [esi+10h]
		mov	[esp+40h+var_34], eax
		call	sub_100111A6
		dec	eax
		jz	loc_1000FF6B
		dec	eax
		jz	loc_1000FF5A
		dec	eax
		jz	loc_1000FF8D
		dec	eax
		jz	loc_1000FF56
		push	edi
		lea	eax, [esp+44h+var_18]
		push	esi
		push	eax
		call	?alignOperands@Decimal@WebCore@@CA?AUAlignedOperands@12@ABV12@0@Z ; WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)
		add	esp, 0Ch
		lea	edi, [esp+40h+var_30]
		mov	esi, eax
		mov	eax, [esp+40h+var_34]
		push	6
		pop	ecx
		rep movsd
		cmp	ebx, eax
		jnz	short loc_1000FEF2
		mov	edx, [esp+40h+var_28]
		add	edx, [esp+40h+var_30]
		mov	ecx, [esp+40h+var_24]
		adc	ecx, [esp+40h+var_2C]
		jmp	short loc_1000FF02
; ---------------------------------------------------------------------------

loc_1000FEF2:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+70j
		mov	edx, [esp+40h+var_30]
		sub	edx, [esp+40h+var_28]
		mov	ecx, [esp+40h+var_2C]
		sbb	ecx, [esp+40h+var_24]

loc_1000FF02:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+82j
		cmp	ebx, 1
		jnz	short loc_1000FF22
		test	eax, eax
		jnz	short loc_1000FF22
		mov	eax, edx
		or	eax, ecx
		jnz	short loc_1000FF22
		mov	ecx, [ebp+arg_0]
		push	eax
		push	eax
		push	[esp+48h+var_20]
		push	eax
		call	??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	; WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned	__int64)
		jmp	short loc_1000FF66
; ---------------------------------------------------------------------------

loc_1000FF22:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+97j
					; WebCore::Decimal::operator+(WebCore::Decimal const &)+9Bj ...
		test	ecx, ecx
		jl	short loc_1000FF35
		jg	short loc_1000FF2C
		test	edx, edx
		jb	short loc_1000FF35

loc_1000FF2C:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+B8j
		push	ecx
		push	edx
		push	[esp+48h+var_20]
		push	ebx
		jmp	short loc_1000FF4B
; ---------------------------------------------------------------------------

loc_1000FF35:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+B6j
					; WebCore::Decimal::operator+(WebCore::Decimal const &)+BCj
		xor	eax, eax
		cmp	ebx, 1
		setnz	al
		neg	edx
		adc	ecx, 0
		neg	ecx
		push	ecx
		push	edx
		push	[esp+48h+var_20]
		push	eax

loc_1000FF4B:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+C5j
		lea	ecx, [esp+50h+var_18]
		call	??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	; WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned	__int64)
		jmp	short loc_1000FF8B
; ---------------------------------------------------------------------------

loc_1000FF56:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+4Aj
		mov	esi, edi
		jmp	short loc_1000FF8D
; ---------------------------------------------------------------------------

loc_1000FF5A:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+3Cj
		push	[ebp+arg_0]
		lea	ecx, [esp+44h+var_30]
		call	sub_10012208

loc_1000FF66:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+B2j
		mov	eax, [ebp+arg_0]
		jmp	short loc_1000FF97
; ---------------------------------------------------------------------------

loc_1000FF6B:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+35j
		cmp	ebx, [esp+40h+var_34]
		jnz	short loc_1000FF80
		push	6
		pop	ecx
		lea	edi, [esp+40h+var_30]
		rep movsd
		lea	eax, [esp+40h+var_30]
		jmp	short loc_1000FF8B
; ---------------------------------------------------------------------------

loc_1000FF80:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+101j
		lea	eax, [esp+40h+var_18]
		push	eax
		call	?nan@Decimal@WebCore@@SA?AV12@XZ ; WebCore::Decimal::nan(void)
		pop	ecx

loc_1000FF8B:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+E6j
					; WebCore::Decimal::operator+(WebCore::Decimal const &)+110j
		mov	esi, eax

loc_1000FF8D:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+43j
					; WebCore::Decimal::operator+(WebCore::Decimal const &)+EAj
		mov	eax, [ebp+arg_0]
		mov	edi, eax
		push	6
		pop	ecx
		rep movsd

loc_1000FF97:				; CODE XREF: WebCore::Decimal::operator+(WebCore::Decimal const	&)+FBj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??HDecimal@WebCore@@QBE?AV01@ABV01@@Z endp

; Exported entry  15. ??KDecimal@WebCore@@QBE?AV01@ABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal __thiscall WebCore::Decimal::operator/(class WebCore::Decimal const &)const
		public ??KDecimal@WebCore@@QBE?AV01@ABV01@@Z
??KDecimal@WebCore@@QBE?AV01@ABV01@@Z proc near
					; CODE XREF: WebCore::Decimal::operator=/(WebCore::Decimal const &)+16p
					; WebCore::Decimal::remainder(WebCore::Decimal const &)+14p
					; DATA XREF: ...

var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 34h
		push	ebx
		push	esi
		mov	esi, ecx
		mov	[esp+3Ch+var_10], 2
		push	edi
		mov	edi, [ebp+arg_4]
		lea	ecx, [esp+40h+var_18]
		xor	ebx, ebx
		mov	[esp+40h+var_18], esi
		mov	eax, [esi+10h]
		mov	[esp+40h+var_14], edi
		cmp	eax, [edi+10h]
		setnz	bl
		mov	[esp+40h+var_1C], ebx
		call	sub_100111A6
		dec	eax
		jz	loc_1001015E
		dec	eax
		jz	loc_10010150
		dec	eax
		jz	loc_10010145
		dec	eax
		jz	loc_10010139
		cmp	dword ptr [edi+0Ch], 3
		jnz	short loc_10010027
		cmp	dword ptr [esi+0Ch], 3
		lea	eax, [esp+40h+var_18]
		jnz	short loc_1001000D
		push	eax
		call	?nan@Decimal@WebCore@@SA?AV12@XZ ; WebCore::Decimal::nan(void)
		jmp	short loc_10010015
; ---------------------------------------------------------------------------

loc_1001000D:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+63j
		push	ebx
		push	eax
		call	?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z	; WebCore::Decimal::infinity(WebCore::Decimal::Sign)
		pop	ecx

loc_10010015:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+6Bj
		pop	ecx
		mov	esi, eax
		mov	eax, [ebp+arg_0]
		push	6
		pop	ecx
		mov	edi, eax
		rep movsd
		jmp	loc_1001016A
; ---------------------------------------------------------------------------

loc_10010027:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+59j
		movsx	eax, word ptr [edi+8]
		movsx	ecx, word ptr [esi+8]
		sub	ecx, eax
		cmp	dword ptr [esi+0Ch], 3
		mov	[esp+40h+var_20], ecx
		jnz	short loc_1001004E
		xor	esi, esi
		push	esi
		push	esi
		push	ecx
		push	ebx

loc_10010041:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+194j
		mov	ecx, [ebp+arg_0]
		call	??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	; WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned	__int64)
		jmp	loc_10010167
; ---------------------------------------------------------------------------

loc_1001004E:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+99j
		mov	eax, [esi+4]
		mov	edx, [esi]
		xor	esi, esi
		mov	ecx, [edi]
		mov	ebx, esi
		mov	[esp+40h+var_34], eax
		mov	eax, [edi+4]
		mov	edi, esi
		mov	[esp+40h+var_2C], ecx
		mov	[esp+40h+var_28], eax
		mov	[esp+40h+var_24], esi

loc_1001006E:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+157j
					; WebCore::Decimal::operator/(WebCore::Decimal const &)+165j
		cmp	[esp+40h+var_34], eax
		ja	short loc_100100BD
		jb	short loc_1001007A
		cmp	edx, ecx
		jnb	short loc_100100BD

loc_1001007A:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+D4j
					; WebCore::Decimal::operator/(WebCore::Decimal const &)+10Dj ...
		push	esi
		push	0Ah
		push	[esp+48h+var_34]
		push	edx
		call	__allmul
		push	esi
		push	0Ah
		push	ebx
		push	edi
		mov	[esp+50h+var_30], eax
		mov	[esp+50h+var_34], edx
		call	__allmul
		dec	[esp+40h+var_20]
		mov	edi, eax
		mov	eax, [esp+40h+var_28]
		mov	ebx, edx
		mov	edx, [esp+40h+var_30]
		cmp	[esp+40h+var_34], eax
		jb	short loc_1001007A
		mov	ecx, [esp+40h+var_2C]
		ja	short loc_100100B9
		cmp	edx, ecx
		jb	short loc_1001007A

loc_100100B9:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+113j
		mov	[esp+40h+var_24], ebx

loc_100100BD:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+D2j
					; WebCore::Decimal::operator/(WebCore::Decimal const &)+D8j
		push	eax
		push	ecx
		push	[esp+48h+var_34]
		push	edx
		call	__aulldvrm
		mov	[esp+40h+var_30], ecx
		add	edi, eax
		mov	ecx, ebx
		mov	ebx, [esp+40h+var_24]
		adc	ebx, edx
		mov	[esp+40h+var_34], ecx
		mov	edx, [esp+40h+var_30]
		mov	eax, edx
		or	eax, ecx
		mov	[esp+40h+var_24], ebx
		jz	short loc_1001010B
		mov	eax, [esp+40h+var_28]
		mov	ecx, [esp+40h+var_2C]
		cmp	ebx, 38D7Eh
		jb	loc_1001006E
		ja	short loc_1001010B
		cmp	edi, 0A4C67FFFh
		jb	loc_1001006E

loc_1001010B:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+147j
					; WebCore::Decimal::operator/(WebCore::Decimal const &)+15Dj
		mov	eax, [esp+40h+var_28]
		mov	ecx, [esp+40h+var_2C]
		shrd	ecx, eax, 1
		shr	eax, 1
		cmp	[esp+40h+var_34], eax
		jb	short loc_1001012A
		ja	short loc_10010125
		cmp	edx, ecx
		jbe	short loc_1001012A

loc_10010125:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+17Fj
		add	edi, 1
		adc	ebx, esi

loc_1001012A:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+17Dj
					; WebCore::Decimal::operator/(WebCore::Decimal const &)+183j
		push	ebx
		push	edi
		push	[esp+48h+var_20]
		push	[esp+4Ch+var_1C]
		jmp	loc_10010041
; ---------------------------------------------------------------------------

loc_10010139:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+4Fj
		push	ebx
		push	[ebp+arg_0]
		call	?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z ; WebCore::Decimal::zero(WebCore::Decimal::Sign)

loc_10010142:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+1AEj
		pop	ecx
		jmp	short loc_10010166
; ---------------------------------------------------------------------------

loc_10010145:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+48j
		push	ebx
		push	[ebp+arg_0]
		call	?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z	; WebCore::Decimal::infinity(WebCore::Decimal::Sign)
		jmp	short loc_10010142
; ---------------------------------------------------------------------------

loc_10010150:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+41j
		push	[ebp+arg_0]
		lea	ecx, [esp+44h+var_18]
		call	sub_10012208
		jmp	short loc_10010167
; ---------------------------------------------------------------------------

loc_1001015E:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+3Aj
		push	[ebp+arg_0]
		call	?nan@Decimal@WebCore@@SA?AV12@XZ ; WebCore::Decimal::nan(void)

loc_10010166:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+1A3j
		pop	ecx

loc_10010167:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+A9j
					; WebCore::Decimal::operator/(WebCore::Decimal const &)+1BCj
		mov	eax, [ebp+arg_0]

loc_1001016A:				; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+82j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??KDecimal@WebCore@@QBE?AV01@ABV01@@Z endp

; Exported entry  16. ??MDecimal@WebCore@@QBE_NABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall WebCore::Decimal::operator<(class WebCore::Decimal const &)const
		public ??MDecimal@WebCore@@QBE_NABV01@@Z
??MDecimal@WebCore@@QBE_NABV01@@Z proc near ; DATA XREF: .rdata:off_100175A8o

var_18		= byte ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 18h
		push	[ebp+arg_0]
		lea	eax, [esp+1Ch+var_18]
		push	eax
		call	?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z ;	WebCore::Decimal::compareTo(WebCore::Decimal const &)
		cmp	[esp+18h+var_C], 2
		jnz	short loc_10010194
		xor	al, al
		jmp	short loc_100101A6
; ---------------------------------------------------------------------------

loc_10010194:				; CODE XREF: WebCore::Decimal::operator<(WebCore::Decimal const	&)+1Bj
		cmp	[esp+18h+var_C], 3
		jz	short loc_100101A4
		xor	eax, eax
		inc	eax
		cmp	[esp+18h+var_8], eax
		jz	short loc_100101A6

loc_100101A4:				; CODE XREF: WebCore::Decimal::operator<(WebCore::Decimal const	&)+26j
		xor	eax, eax

loc_100101A6:				; CODE XREF: WebCore::Decimal::operator<(WebCore::Decimal const	&)+1Fj
					; WebCore::Decimal::operator<(WebCore::Decimal const &)+2Fj
		mov	esp, ebp
		pop	ebp
		retn	4
??MDecimal@WebCore@@QBE_NABV01@@Z endp

; Exported entry  17. ??NDecimal@WebCore@@QBE_NABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall WebCore::Decimal::operator<=(class WebCore::Decimal const &)const
		public ??NDecimal@WebCore@@QBE_NABV01@@Z
??NDecimal@WebCore@@QBE_NABV01@@Z proc near ; DATA XREF: .rdata:off_100175A8o

var_18		= byte ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 1Ch
		cmp	dword ptr [ecx+0Ch], 2
		push	esi
		jz	short loc_100101F9
		mov	esi, [ebp+arg_0]
		cmp	dword ptr [esi+0Ch], 2
		jz	short loc_100101F9
		push	esi
		call	sub_1000FAE0
		test	al, al
		jz	short loc_100101D3
		mov	al, 1
		jmp	short loc_100101FB
; ---------------------------------------------------------------------------

loc_100101D3:				; CODE XREF: WebCore::Decimal::operator<=(WebCore::Decimal const &)+21j
		push	esi
		lea	eax, [esp+24h+var_18]
		push	eax
		call	?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z ;	WebCore::Decimal::compareTo(WebCore::Decimal const &)
		cmp	[esp+20h+var_C], 2
		jz	short loc_100101F9
		xor	eax, eax
		inc	eax
		cmp	[esp+20h+var_C], 3
		jz	short loc_100101FB
		cmp	[esp+20h+var_8], eax
		jz	short loc_100101FB
		xor	eax, eax
		jmp	short loc_100101FB
; ---------------------------------------------------------------------------

loc_100101F9:				; CODE XREF: WebCore::Decimal::operator<=(WebCore::Decimal const &)+Ej
					; WebCore::Decimal::operator<=(WebCore::Decimal	const &)+17j ...
		xor	al, al

loc_100101FB:				; CODE XREF: WebCore::Decimal::operator<=(WebCore::Decimal const &)+25j
					; WebCore::Decimal::operator<=(WebCore::Decimal	const &)+41j ...
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn	4
??NDecimal@WebCore@@QBE_NABV01@@Z endp

; Exported entry  18. ??ODecimal@WebCore@@QBE_NABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall WebCore::Decimal::operator>(class WebCore::Decimal const &)const
		public ??ODecimal@WebCore@@QBE_NABV01@@Z
??ODecimal@WebCore@@QBE_NABV01@@Z proc near ; DATA XREF: .rdata:off_100175A8o

var_18		= byte ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 18h
		push	[ebp+arg_0]
		lea	eax, [esp+1Ch+var_18]
		push	eax
		call	?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z ;	WebCore::Decimal::compareTo(WebCore::Decimal const &)
		cmp	[esp+18h+var_C], 2
		jnz	short loc_10010223
		xor	al, al
		jmp	short loc_10010238
; ---------------------------------------------------------------------------

loc_10010223:				; CODE XREF: WebCore::Decimal::operator>(WebCore::Decimal const	&)+1Bj
		cmp	[esp+18h+var_C], 3
		jz	short loc_10010236
		cmp	[esp+18h+var_8], 0
		jnz	short loc_10010236
		xor	eax, eax
		inc	eax
		jmp	short loc_10010238
; ---------------------------------------------------------------------------

loc_10010236:				; CODE XREF: WebCore::Decimal::operator>(WebCore::Decimal const	&)+26j
					; WebCore::Decimal::operator>(WebCore::Decimal const &)+2Dj
		xor	eax, eax

loc_10010238:				; CODE XREF: WebCore::Decimal::operator>(WebCore::Decimal const	&)+1Fj
					; WebCore::Decimal::operator>(WebCore::Decimal const &)+32j
		mov	esp, ebp
		pop	ebp
		retn	4
??ODecimal@WebCore@@QBE_NABV01@@Z endp

; Exported entry  19. ??PDecimal@WebCore@@QBE_NABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall WebCore::Decimal::operator>=(class WebCore::Decimal const &)const
		public ??PDecimal@WebCore@@QBE_NABV01@@Z
??PDecimal@WebCore@@QBE_NABV01@@Z proc near ; DATA XREF: .rdata:off_100175A8o

var_18		= byte ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 1Ch
		cmp	dword ptr [ecx+0Ch], 2
		push	esi
		jz	short loc_1001028B
		mov	esi, [ebp+arg_0]
		cmp	dword ptr [esi+0Ch], 2
		jz	short loc_1001028B
		push	esi
		call	sub_1000FAE0
		test	al, al
		jz	short loc_10010265
		mov	al, 1
		jmp	short loc_1001028D
; ---------------------------------------------------------------------------

loc_10010265:				; CODE XREF: WebCore::Decimal::operator>=(WebCore::Decimal const &)+21j
		push	esi
		lea	eax, [esp+24h+var_18]
		push	eax
		call	?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z ;	WebCore::Decimal::compareTo(WebCore::Decimal const &)
		cmp	[esp+20h+var_C], 2
		jz	short loc_1001028B
		xor	eax, eax
		inc	eax
		cmp	[esp+20h+var_C], 3
		jz	short loc_1001028D
		cmp	[esp+20h+var_8], eax
		jnz	short loc_1001028D
		xor	eax, eax
		jmp	short loc_1001028D
; ---------------------------------------------------------------------------

loc_1001028B:				; CODE XREF: WebCore::Decimal::operator>=(WebCore::Decimal const &)+Ej
					; WebCore::Decimal::operator>=(WebCore::Decimal	const &)+17j ...
		xor	al, al

loc_1001028D:				; CODE XREF: WebCore::Decimal::operator>=(WebCore::Decimal const &)+25j
					; WebCore::Decimal::operator>=(WebCore::Decimal	const &)+41j ...
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn	4
??PDecimal@WebCore@@QBE_NABV01@@Z endp

; Exported entry  20. ??XDecimal@WebCore@@QAEAAV01@ABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal & __thiscall WebCore::Decimal::operator*=(class WebCore::Decimal const	&)
		public ??XDecimal@WebCore@@QAEAAV01@ABV01@@Z
??XDecimal@WebCore@@QAEAAV01@ABV01@@Z proc near	; DATA XREF: .rdata:off_100175A8o

var_18		= byte ptr -18h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 1Ch
		lea	eax, [esp+1Ch+var_18]
		push	ebx
		push	esi
		push	edi
		push	[ebp+arg_0]
		mov	ebx, ecx
		push	eax
		call	??DDecimal@WebCore@@QBE?AV01@ABV01@@Z ;	WebCore::Decimal::operator*(WebCore::Decimal const &)
		push	6
		pop	ecx
		mov	esi, eax
		mov	edi, ebx
		rep movsd
		pop	edi
		pop	esi
		mov	eax, ebx
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??XDecimal@WebCore@@QAEAAV01@ABV01@@Z endp

; Exported entry  21. ??YDecimal@WebCore@@QAEAAV01@ABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal & __thiscall WebCore::Decimal::operator+=(class WebCore::Decimal const	&)
		public ??YDecimal@WebCore@@QAEAAV01@ABV01@@Z
??YDecimal@WebCore@@QAEAAV01@ABV01@@Z proc near	; DATA XREF: .rdata:off_100175A8o

var_18		= byte ptr -18h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 1Ch
		lea	eax, [esp+1Ch+var_18]
		push	ebx
		push	esi
		push	edi
		push	[ebp+arg_0]
		mov	ebx, ecx
		push	eax
		call	??HDecimal@WebCore@@QBE?AV01@ABV01@@Z ;	WebCore::Decimal::operator+(WebCore::Decimal const &)
		push	6
		pop	ecx
		mov	esi, eax
		mov	edi, ebx
		rep movsd
		pop	edi
		pop	esi
		mov	eax, ebx
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??YDecimal@WebCore@@QAEAAV01@ABV01@@Z endp

; Exported entry  23. ??ZDecimal@WebCore@@QAEAAV01@ABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal & __thiscall WebCore::Decimal::operator-=(class WebCore::Decimal const	&)
		public ??ZDecimal@WebCore@@QAEAAV01@ABV01@@Z
??ZDecimal@WebCore@@QAEAAV01@ABV01@@Z proc near	; DATA XREF: .rdata:off_100175A8o

var_18		= byte ptr -18h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 1Ch
		lea	eax, [esp+1Ch+var_18]
		push	ebx
		push	esi
		push	edi
		push	[ebp+arg_0]
		mov	ebx, ecx
		push	eax
		call	??GDecimal@WebCore@@QBE?AV01@ABV01@@Z ;	WebCore::Decimal::operator-(WebCore::Decimal const &)
		push	6
		pop	ecx
		mov	esi, eax
		mov	edi, ebx
		rep movsd
		pop	edi
		pop	esi
		mov	eax, ebx
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??ZDecimal@WebCore@@QAEAAV01@ABV01@@Z endp

; Exported entry  25. ??_0Decimal@WebCore@@QAEAAV01@ABV01@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal & __thiscall WebCore::Decimal::operator=/(class WebCore::Decimal const	&)
		public ??_0Decimal@WebCore@@QAEAAV01@ABV01@@Z
??_0Decimal@WebCore@@QAEAAV01@ABV01@@Z proc near ; DATA	XREF: .rdata:off_100175A8o

var_18		= byte ptr -18h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 1Ch
		lea	eax, [esp+1Ch+var_18]
		push	ebx
		push	esi
		push	edi
		push	[ebp+arg_0]
		mov	ebx, ecx
		push	eax
		call	??KDecimal@WebCore@@QBE?AV01@ABV01@@Z ;	WebCore::Decimal::operator/(WebCore::Decimal const &)
		push	6
		pop	ecx
		mov	esi, eax
		mov	edi, ebx
		rep movsd
		pop	edi
		pop	esi
		mov	eax, ebx
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??_0Decimal@WebCore@@QAEAAV01@ABV01@@Z endp


; =============== S U B	R O U T	I N E =======================================


sub_10010350	proc near		; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+159p

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		sub	esp, 2Ch
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+2Ch+var_4], eax
		push	esi
		mov	esi, ecx
		push	edi
		mov	eax, [esi]
		mov	edi, [esi+4]
		or	eax, edi
		jnz	short loc_10010381
		push	eax
		push	0Ah
		push	dword ptr [esi+0Ch]
		push	dword ptr [esi+8]
		call	__aulldiv
		mov	[esi+8], eax
		mov	[esi+0Ch], edx
		jmp	short loc_100103F0
; ---------------------------------------------------------------------------

loc_10010381:				; CODE XREF: sub_10010350+19j
		mov	eax, [esi+8]
		mov	cl, 20h
		mov	edx, [esi+0Ch]
		push	ebx
		push	ebp
		mov	[esp+3Ch+var_24], eax
		call	__aullshr
		mov	[esp+3Ch+var_20], eax
		xor	ebp, ebp
		mov	eax, [esi]
		mov	[esp+3Ch+var_18], edi
		xor	edi, edi
		mov	[esp+3Ch+var_1C], eax

loc_100103A6:				; CODE XREF: sub_10010350+7Dj
		mov	ecx, [esp+edi+3Ch+var_18]
		xor	eax, eax
		push	0
		push	0Ah
		or	eax, ebp
		push	eax
		push	ecx
		call	__aulldvrm
		mov	[esp+edi+3Ch+var_8], eax
		mov	ebp, ecx
		sub	edi, 4
		mov	[esp+3Ch+var_28], ebx
		mov	[esp+3Ch+var_28], edx
		cmp	edi, 0FFFFFFF4h
		jge	short loc_100103A6
		mov	ecx, [esp+3Ch+var_10]
		xor	eax, eax
		or	eax, [esp+3Ch+var_14]
		mov	[esi+8], eax
		xor	eax, eax
		or	eax, [esp+3Ch+var_C]
		mov	[esi+0Ch], ecx
		mov	ecx, [esp+3Ch+var_8]
		pop	ebp
		mov	[esi], eax
		mov	[esi+4], ecx
		pop	ebx

loc_100103F0:				; CODE XREF: sub_10010350+2Fj
		mov	ecx, [esp+34h+var_4]
		mov	eax, esi
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 2Ch
		retn	4
sub_10010350	endp


; =============== S U B	R O U T	I N E =======================================


sub_10010405	proc near		; CODE XREF: sub_1000BF69+44BEp
					; sub_100113D1+57p ...
		push	esi
		lea	esi, [ecx+50h]
		mov	ecx, esi
		call	sub_1000FA58
		mov	ecx, esi
		pop	esi
		jmp	ds:??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ;	std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(void)
sub_10010405	endp

; Exported entry  26. ??_FDecimal@WebCore@@QAEXXZ

; =============== S U B	R O U T	I N E =======================================


; public: void __thiscall WebCore::Decimal::`default constructor closure'(void)
		public ??_FDecimal@WebCore@@QAEXXZ
??_FDecimal@WebCore@@QAEXXZ proc near	; DATA XREF: .rdata:off_100175A8o
		push	0		; int
		call	??0Decimal@WebCore@@QAE@H@Z ; WebCore::Decimal::Decimal(int)
		retn
??_FDecimal@WebCore@@QAEXXZ endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1000BF69

loc_10010421:				; CODE XREF: sub_1000BF69+3j
		push	esi
		lea	esi, [ecx-50h]
		mov	ecx, esi
		call	sub_10010405
		test	[esp+4+arg_0], 1
		jz	short loc_1001043A
		push	esi		; void *
		call	free
		pop	ecx

loc_1001043A:				; CODE XREF: sub_1000BF69+44C8j
		mov	eax, esi
		pop	esi
		retn	4
; END OF FUNCTION CHUNK	FOR sub_1000BF69

; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_10010440(void *, char)
sub_10010440	proc near		; DATA XREF: .rdata:off_10016430o

arg_0		= byte ptr  4

		push	esi
		mov	esi, ecx
		mov	dword ptr [esi], offset	off_10016430
		call	sub_10010627
		mov	ecx, esi
		call	ds:??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(void)
		test	[esp+4+arg_0], 1
		jz	short loc_10010464
		push	esi		; void *
		call	free
		pop	ecx

loc_10010464:				; CODE XREF: sub_10010440+1Bj
		mov	eax, esi
		pop	esi
		retn	4
sub_10010440	endp

; [0000001D BYTES: COLLAPSED FUNCTION unknown_libname_1]

; =============== S U B	R O U T	I N E =======================================


; int __stdcall	sub_10010487(void *)
sub_10010487	proc near		; CODE XREF: sub_1000F9A9+15p

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	edi, ecx
		cmp	dword ptr [esi+14h], 10h
		jnb	short loc_100104A4
		mov	eax, [esi+10h]
		mov	edx, esi	; void *
		inc	eax
		push	eax		; size_t
		call	sub_100112DC
		pop	ecx
		jmp	short loc_100104AF
; ---------------------------------------------------------------------------

loc_100104A4:				; CODE XREF: sub_10010487+Cj
		test	edi, edi
		jz	short loc_100104AC
		mov	eax, [esi]
		mov	[edi], eax

loc_100104AC:				; CODE XREF: sub_10010487+1Fj
		and	dword ptr [esi], 0

loc_100104AF:				; CODE XREF: sub_10010487+1Bj
		mov	eax, [esi+10h]
		mov	[edi+10h], eax
		mov	eax, [esi+14h]
		mov	[edi+14h], eax
		and	dword ptr [esi+10h], 0
		mov	dword ptr [esi+14h], 0Fh
		pop	edi
		mov	byte ptr [esi],	0
		pop	esi
		retn	4
sub_10010487	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_100104CE(void *, int, size_t)
sub_100104CE	proc near		; CODE XREF: sub_10010572+18p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_0]
		mov	esi, ecx
		or	edi, 0Fh
		cmp	edi, 0FFFFFFFEh
		jbe	short loc_100104E6
		mov	edi, [esp+10h+arg_0]
		jmp	short loc_1001050B
; ---------------------------------------------------------------------------

loc_100104E6:				; CODE XREF: sub_100104CE+10j
		push	3
		xor	edx, edx
		mov	ebx, [esi+14h]
		mov	eax, edi
		mov	ecx, ebx
		pop	ebp
		div	ebp
		shr	ecx, 1
		cmp	ecx, eax
		jbe	short loc_1001050B
		push	0FFFFFFFEh
		pop	eax
		sub	eax, ecx
		cmp	ebx, eax
		ja	short loc_10010508
		lea	edi, [ecx+ebx]
		jmp	short loc_1001050B
; ---------------------------------------------------------------------------

loc_10010508:				; CODE XREF: sub_100104CE+33j
		push	0FFFFFFFEh
		pop	edi

loc_1001050B:				; CODE XREF: sub_100104CE+16j
					; sub_100104CE+2Aj ...
		lea	eax, [edi+1]
		xor	ebp, ebp
		test	eax, eax
		jz	short loc_1001052C
		cmp	eax, 0FFFFFFFFh
		ja	short loc_10010526
		push	eax
		call	moz_xmalloc
		mov	ebp, eax
		pop	ecx
		test	ebp, ebp
		jnz	short loc_1001052C

loc_10010526:				; CODE XREF: sub_100104CE+49j
		call	ds:?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)

loc_1001052C:				; CODE XREF: sub_100104CE+44j
					; sub_100104CE+56j
		mov	ebx, [esp+10h+arg_4]
		test	ebx, ebx
		jz	short loc_10010549
		cmp	dword ptr [esi+14h], 10h
		jb	short loc_1001053E
		mov	edx, [esi]
		jmp	short loc_10010540
; ---------------------------------------------------------------------------

loc_1001053E:				; CODE XREF: sub_100104CE+6Aj
		mov	edx, esi	; void *

loc_10010540:				; CODE XREF: sub_100104CE+6Ej
		push	ebx		; size_t
		mov	ecx, ebp	; void *
		call	sub_10010BC3
		pop	ecx

loc_10010549:				; CODE XREF: sub_100104CE+64j
		push	0		; size_t
		push	1		; char
		mov	ecx, esi
		call	sub_100105E7
		test	esi, esi
		jz	short loc_1001055A
		mov	[esi], ebp

loc_1001055A:				; CODE XREF: sub_100104CE+88j
		mov	[esi+14h], edi
		mov	[esi+10h], ebx
		cmp	edi, 10h
		jb	short loc_10010567
		mov	esi, [esi]

loc_10010567:				; CODE XREF: sub_100104CE+95j
		pop	edi
		mov	byte ptr [esi+ebx], 0
		pop	esi
		pop	ebp
		pop	ebx
		retn	8
sub_100104CE	endp


; =============== S U B	R O U T	I N E =======================================


sub_10010572	proc near		; CODE XREF: sub_100107D6+46p
					; sub_10010868+19p ...

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		cmp	esi, 0FFFFFFFEh
		jbe	short loc_10010581
		call	sub_10010683
; ---------------------------------------------------------------------------

loc_10010581:				; CODE XREF: sub_10010572+8j
		cmp	[ecx+14h], esi
		jnb	short loc_10010591
		push	dword ptr [ecx+10h] ; size_t
		push	esi		; int
		call	sub_100104CE
		jmp	short loc_100105A3
; ---------------------------------------------------------------------------

loc_10010591:				; CODE XREF: sub_10010572+12j
		test	esi, esi
		jnz	short loc_100105A3
		and	[ecx+10h], esi
		cmp	dword ptr [ecx+14h], 10h
		jb	short loc_100105A0
		mov	ecx, [ecx]

loc_100105A0:				; CODE XREF: sub_10010572+2Aj
		mov	byte ptr [ecx],	0

loc_100105A3:				; CODE XREF: sub_10010572+1Dj
					; sub_10010572+21j
		xor	eax, eax
		cmp	eax, esi
		pop	esi
		sbb	eax, eax
		neg	eax
		retn	8
sub_10010572	endp


; =============== S U B	R O U T	I N E =======================================


sub_100105AF	proc near		; CODE XREF: sub_100108BA+Ap
					; sub_10010A1A+9p

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		test	edx, edx
		jz	short loc_100105E2
		cmp	dword ptr [ecx+14h], 10h
		jb	short loc_100105C1
		mov	eax, [ecx]
		jmp	short loc_100105C3
; ---------------------------------------------------------------------------

loc_100105C1:				; CODE XREF: sub_100105AF+Cj
		mov	eax, ecx

loc_100105C3:				; CODE XREF: sub_100105AF+10j
		cmp	edx, eax
		jb	short loc_100105E2
		cmp	dword ptr [ecx+14h], 10h
		push	esi
		jb	short loc_100105D2
		mov	esi, [ecx]
		jmp	short loc_100105D4
; ---------------------------------------------------------------------------

loc_100105D2:				; CODE XREF: sub_100105AF+1Dj
		mov	esi, ecx

loc_100105D4:				; CODE XREF: sub_100105AF+21j
		mov	eax, [ecx+10h]
		add	eax, esi
		pop	esi
		cmp	eax, edx
		jbe	short loc_100105E2
		mov	al, 1
		jmp	short locret_100105E4
; ---------------------------------------------------------------------------

loc_100105E2:				; CODE XREF: sub_100105AF+6j
					; sub_100105AF+16j ...
		xor	al, al

locret_100105E4:			; CODE XREF: sub_100105AF+31j
		retn	4
sub_100105AF	endp


; =============== S U B	R O U T	I N E =======================================


; int __stdcall	sub_100105E7(char, size_t)
sub_100105E7	proc near		; CODE XREF: sub_100104CE+81p
					; sub_1001094B+36p ...

arg_0		= byte ptr  4
arg_4		= dword	ptr  8

		cmp	[esp+arg_0], 0
		push	esi
		push	edi
		mov	edi, [esp+8+arg_4]
		mov	esi, ecx
		jz	short loc_10010614
		cmp	dword ptr [esi+14h], 10h
		jb	short loc_10010614
		push	ebx
		mov	ebx, [esi]
		test	edi, edi
		jz	short loc_1001060C
		push	edi		; size_t
		mov	edx, ebx	; void *
		call	sub_10010BC3
		pop	ecx

loc_1001060C:				; CODE XREF: sub_100105E7+1Aj
		push	ebx		; void *
		call	free
		pop	ecx
		pop	ebx

loc_10010614:				; CODE XREF: sub_100105E7+Dj
					; sub_100105E7+13j
		mov	[esi+10h], edi
		mov	dword ptr [esi+14h], 0Fh
		mov	byte ptr [edi+esi], 0
		pop	edi
		pop	esi
		retn	8
sub_100105E7	endp


; =============== S U B	R O U T	I N E =======================================


sub_10010627	proc near		; CODE XREF: sub_1000FA58+2Ap
					; sub_10010440+9p
		push	esi
		mov	esi, ecx
		push	edi
		test	byte ptr [esi+3Ch], 1
		jz	short loc_10010662
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		mov	ecx, esi
		test	eax, eax
		jz	short loc_10010645
		call	ds:?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		jmp	short loc_1001064B
; ---------------------------------------------------------------------------

loc_10010645:				; CODE XREF: sub_10010627+14j
		call	ds:?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::egptr(void)

loc_1001064B:				; CODE XREF: sub_10010627+1Cj
		mov	ecx, esi
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, esi
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		push	eax		; void *
		call	free
		pop	ecx

loc_10010662:				; CODE XREF: sub_10010627+8j
		xor	edi, edi
		mov	ecx, esi
		push	edi
		push	edi
		push	edi
		call	ds:?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		push	edi
		push	edi
		mov	ecx, esi
		call	ds:?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *)
		and	dword ptr [esi+3Ch], 0FFFFFFFEh
		mov	[esi+38h], edi
		pop	edi
		pop	esi
		retn
sub_10010627	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

sub_10010683	proc near		; CODE XREF: sub_10010572+Ap
					; sub_100107D6+32p ...
		push	offset aStringTooLong ;	"string	too long"
		call	ds:?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
		int	3		; Trap to Debugger
sub_10010683	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

sub_1001068F	proc near		; CODE XREF: sub_100107D6+14p
					; sub_10010997+15p ...
		push	offset aInvalidStringP ; "invalid string position"
		call	ds:?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
		int	3		; Trap to Debugger
sub_1001068F	endp

; Exported entry  52. ?abs@Decimal@WebCore@@QBE?AV12@XZ

; =============== S U B	R O U T	I N E =======================================


; public: class	WebCore::Decimal __thiscall WebCore::Decimal::abs(void)const
		public ?abs@Decimal@WebCore@@QBE?AV12@XZ
?abs@Decimal@WebCore@@QBE?AV12@XZ proc near ; DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	esi
		push	edi
		push	6
		mov	esi, ecx
		mov	edi, eax
		pop	ecx
		rep movsd
		and	dword ptr [eax+10h], 0
		pop	edi
		pop	esi
		retn	4
?abs@Decimal@WebCore@@QBE?AV12@XZ endp

; Exported entry  53. ?alignOperands@Decimal@WebCore@@CA?AUAlignedOperands@12@ABV12@0@Z

; =============== S U B	R O U T	I N E =======================================


; private: static struct WebCore::Decimal::AlignedOperands __cdecl WebCore::Decimal::alignOperands(class WebCore::Decimal const	&, class WebCore::Decimal const	&)
		public ?alignOperands@Decimal@WebCore@@CA?AUAlignedOperands@12@ABV12@0@Z
?alignOperands@Decimal@WebCore@@CA?AUAlignedOperands@12@ABV12@0@Z proc near
					; CODE XREF: WebCore::Decimal::operator-(WebCore::Decimal const	&)+59p
					; WebCore::Decimal::operator+(WebCore::Decimal const &)+57p
					; DATA XREF: ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ecx
		push	ecx
		mov	ecx, [esp+8+arg_8]
		lea	eax, [esp+8+arg_4]
		push	ebx
		push	ebp
		mov	ebp, [esp+10h+arg_4]
		push	esi
		push	edi
		movsx	edi, word ptr [ecx+8]
		movsx	esi, word ptr [ebp+8]
		mov	[esp+18h+var_8], esi
		mov	[esp+18h+arg_4], edi
		cmp	edi, esi
		jl	short loc_100106DD
		lea	eax, [esp+18h+var_8]

loc_100106DD:				; CODE XREF: WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+24j
		mov	eax, [eax]
		mov	ebx, [ebp+0]
		mov	ebp, [ebp+4]
		mov	[esp+18h+var_8], eax
		mov	eax, [ecx]
		mov	ecx, [ecx+4]
		mov	[esp+18h+arg_4], eax
		mov	[esp+18h+arg_8], ecx
		cmp	esi, edi
		jle	short loc_10010772
		push	ebp
		push	ebx
		call	sub_10010BDD
		pop	ecx
		pop	ecx
		test	eax, eax
		jz	short loc_10010721
		sub	esi, edi
		push	ebp
		push	ebx
		lea	edi, [esi-12h]
		add	edi, eax
		test	edi, edi
		jg	short loc_10010746
		mov	ecx, esi
		call	sub_1001184F
		pop	ecx
		pop	ecx
		mov	ebx, eax
		mov	ebp, edx

loc_10010721:				; CODE XREF: WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+52j
					; WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+CCj
		mov	esi, [esp+18h+arg_4]

loc_10010725:				; CODE XREF: WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+BDj
					; WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+F5j ...
		mov	eax, [esp+18h+arg_0]
		mov	ecx, [esp+18h+var_8]
		pop	edi
		mov	[eax+8], esi
		pop	esi
		mov	[eax], ebx
		mov	ebx, [esp+10h+arg_8]
		mov	[eax+4], ebp
		pop	ebp
		mov	[eax+0Ch], ebx
		mov	[eax+10h], ecx
		pop	ebx
		pop	ecx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_10010746:				; CODE XREF: WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+5Fj
		sub	esi, edi
		mov	ecx, esi
		call	sub_1001184F
		push	[esp+20h+arg_8]
		mov	esi, [esp+24h+arg_4]
		mov	ecx, edi
		push	esi
		mov	ebx, eax
		mov	ebp, edx
		call	sub_10011824
		mov	esi, eax
		mov	[esp+28h+arg_8], edx

loc_10010769:				; CODE XREF: WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+11Aj
		add	esp, 10h
		add	[esp+18h+var_8], edi
		jmp	short loc_10010725
; ---------------------------------------------------------------------------

loc_10010772:				; CODE XREF: WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+45j
		jge	short loc_100107CF
		push	ecx
		push	eax
		call	sub_10010BDD
		pop	ecx
		pop	ecx
		test	eax, eax
		jz	short loc_10010721
		push	[esp+18h+arg_8]
		sub	edi, esi
		add	eax, 0FFFFFFEEh
		mov	esi, [esp+1Ch+arg_4]
		add	eax, edi
		mov	[esp+1Ch+var_4], eax
		push	esi
		test	eax, eax
		jg	short loc_100107AD
		mov	ecx, edi
		call	sub_1001184F
		pop	ecx
		pop	ecx
		mov	esi, eax
		mov	[esp+18h+arg_8], edx
		jmp	loc_10010725
; ---------------------------------------------------------------------------

loc_100107AD:				; CODE XREF: WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+E4j
		sub	edi, eax
		mov	ecx, edi
		call	sub_1001184F
		mov	edi, [esp+20h+var_4]
		mov	esi, eax
		push	ebp
		push	ebx
		mov	ecx, edi
		mov	[esp+28h+arg_8], edx
		call	sub_10011824
		mov	ebx, eax
		mov	ebp, edx
		jmp	short loc_10010769
; ---------------------------------------------------------------------------

loc_100107CF:				; CODE XREF: WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &):loc_10010772j
		mov	esi, eax
		jmp	loc_10010725
?alignOperands@Decimal@WebCore@@CA?AUAlignedOperands@12@ABV12@0@Z endp


; =============== S U B	R O U T	I N E =======================================


; int __stdcall	sub_100107D6(int, int, size_t)
sub_100107D6	proc near		; CODE XREF: sub_100108BA+29p
					; sub_1001094B+2Ap ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		mov	ebp, [esp+8+arg_4]
		push	esi
		mov	eax, [ebx+10h]
		mov	esi, ecx
		cmp	eax, ebp
		jnb	short loc_100107EF
		call	sub_1001068F
; ---------------------------------------------------------------------------

loc_100107EF:				; CODE XREF: sub_100107D6+12j
		push	edi
		mov	edi, [esp+10h+arg_8]
		sub	eax, ebp
		cmp	eax, edi
		jnb	short loc_100107FC
		mov	edi, eax

loc_100107FC:				; CODE XREF: sub_100107D6+22j
		mov	ecx, [esi+10h]
		or	eax, 0FFFFFFFFh
		sub	eax, ecx
		cmp	eax, edi
		ja	short loc_1001080D
		call	sub_10010683
; ---------------------------------------------------------------------------

loc_1001080D:				; CODE XREF: sub_100107D6+30j
		test	edi, edi
		jz	short loc_1001085F
		lea	eax, [ecx+edi]
		push	ecx
		push	eax
		mov	ecx, esi
		mov	[esp+18h+arg_0], eax
		call	sub_10010572
		test	al, al
		jz	short loc_1001085F
		cmp	dword ptr [ebx+14h], 10h
		jb	short loc_1001082D
		mov	ebx, [ebx]

loc_1001082D:				; CODE XREF: sub_100107D6+53j
		cmp	dword ptr [esi+14h], 10h
		jb	short loc_10010837
		mov	eax, [esi]
		jmp	short loc_10010839
; ---------------------------------------------------------------------------

loc_10010837:				; CODE XREF: sub_100107D6+5Bj
		mov	eax, esi

loc_10010839:				; CODE XREF: sub_100107D6+5Fj
		mov	ecx, [esi+10h]
		lea	edx, [ebx+ebp]	; void *
		push	edi		; size_t
		add	ecx, eax	; void *
		call	sub_10010BC3
		cmp	dword ptr [esi+14h], 10h
		pop	ecx
		mov	ecx, [esp+10h+arg_0]
		mov	[esi+10h], ecx
		jb	short loc_10010859
		mov	eax, [esi]
		jmp	short loc_1001085B
; ---------------------------------------------------------------------------

loc_10010859:				; CODE XREF: sub_100107D6+7Dj
		mov	eax, esi

loc_1001085B:				; CODE XREF: sub_100107D6+81j
		mov	byte ptr [eax+ecx], 0

loc_1001085F:				; CODE XREF: sub_100107D6+39j
					; sub_100107D6+4Dj
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebp
		pop	ebx
		retn	0Ch
sub_100107D6	endp


; =============== S U B	R O U T	I N E =======================================


sub_10010868	proc near		; CODE XREF: WebCore::Decimal::toString(void)+66p
					; WebCore::Decimal::toString(void)+1B1p ...

arg_4		= byte ptr  8

		push	esi
		mov	esi, ecx
		or	eax, 0FFFFFFFFh
		push	edi
		mov	edi, [esi+10h]
		sub	eax, edi
		cmp	eax, 1
		ja	short loc_1001087E
		call	sub_10010683
; ---------------------------------------------------------------------------

loc_1001087E:				; CODE XREF: sub_10010868+Fj
		push	ecx
		inc	edi
		push	edi
		call	sub_10010572
		test	al, al
		jz	short loc_100108B3
		cmp	dword ptr [esi+14h], 10h
		mov	edx, [esi+10h]
		jb	short loc_10010897
		mov	ecx, [esi]
		jmp	short loc_10010899
; ---------------------------------------------------------------------------

loc_10010897:				; CODE XREF: sub_10010868+29j
		mov	ecx, esi

loc_10010899:				; CODE XREF: sub_10010868+2Dj
		mov	al, [esp+8+arg_4]
		mov	[ecx+edx], al
		cmp	dword ptr [esi+14h], 10h
		mov	[esi+10h], edi
		jb	short loc_100108AD
		mov	eax, [esi]
		jmp	short loc_100108AF
; ---------------------------------------------------------------------------

loc_100108AD:				; CODE XREF: sub_10010868+3Fj
		mov	eax, esi

loc_100108AF:				; CODE XREF: sub_10010868+43j
		mov	byte ptr [eax+edi], 0

loc_100108B3:				; CODE XREF: sub_10010868+20j
		pop	edi
		mov	eax, esi
		pop	esi
		retn	8
sub_10010868	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_100108BA(int, int,	size_t)
sub_100108BA	proc near		; CODE XREF: WebCore::Decimal::toString(void)+1E6p

arg_4		= dword	ptr  8

		push	esi
		push	edi
		mov	edi, offset a0_	; "0."
		mov	esi, ecx
		push	edi
		call	sub_100105AF
		test	al, al
		jz	short loc_100108EA
		cmp	dword ptr [esi+14h], 10h
		jb	short loc_100108D7
		mov	eax, [esi]
		jmp	short loc_100108D9
; ---------------------------------------------------------------------------

loc_100108D7:				; CODE XREF: sub_100108BA+17j
		mov	eax, esi

loc_100108D9:				; CODE XREF: sub_100108BA+1Bj
		push	[esp+8+arg_4]	; size_t
		sub	edi, eax
		mov	ecx, esi
		push	edi		; int
		push	esi		; int
		call	sub_100107D6
		jmp	short loc_10010946
; ---------------------------------------------------------------------------

loc_100108EA:				; CODE XREF: sub_100108BA+11j
		mov	ecx, [esi+10h]
		or	eax, 0FFFFFFFFh
		push	ebx
		mov	ebx, [esp+0Ch+arg_4]
		sub	eax, ecx
		cmp	eax, ebx
		ja	short loc_10010900
		call	sub_10010683
; ---------------------------------------------------------------------------

loc_10010900:				; CODE XREF: sub_100108BA+3Fj
		test	ebx, ebx
		jz	short loc_10010943
		push	ebp
		lea	ebp, [ecx+ebx]
		push	ecx
		push	ebp
		mov	ecx, esi
		call	sub_10010572
		test	al, al
		jz	short loc_10010942
		cmp	dword ptr [esi+14h], 10h
		jb	short loc_1001091F
		mov	eax, [esi]
		jmp	short loc_10010921
; ---------------------------------------------------------------------------

loc_1001091F:				; CODE XREF: sub_100108BA+5Fj
		mov	eax, esi

loc_10010921:				; CODE XREF: sub_100108BA+63j
		mov	ecx, [esi+10h]
		mov	edx, edi	; void *
		push	ebx		; size_t
		add	ecx, eax	; void *
		call	sub_10010BC3
		cmp	dword ptr [esi+14h], 10h
		pop	ecx
		mov	[esi+10h], ebp
		jb	short loc_1001093C
		mov	eax, [esi]
		jmp	short loc_1001093E
; ---------------------------------------------------------------------------

loc_1001093C:				; CODE XREF: sub_100108BA+7Cj
		mov	eax, esi

loc_1001093E:				; CODE XREF: sub_100108BA+80j
		mov	byte ptr [eax+ebp], 0

loc_10010942:				; CODE XREF: sub_100108BA+59j
		pop	ebp

loc_10010943:				; CODE XREF: sub_100108BA+48j
		mov	eax, esi
		pop	ebx

loc_10010946:				; CODE XREF: sub_100108BA+2Ej
		pop	edi
		pop	esi
		retn	8
sub_100108BA	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1001094B	proc near		; CODE XREF: WebCore::Decimal::toString(void)+2D7p

var_20		= byte ptr -20h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 20h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]
		push	esi
		cdq
		mov	esi, ecx
		push	edx
		push	eax
		lea	ecx, [ebp+var_20]
		call	sub_100113D1
		pop	ecx
		pop	ecx
		push	0FFFFFFFFh	; size_t
		push	0		; int
		push	eax		; int
		mov	ecx, esi
		call	sub_100107D6
		push	0		; size_t
		push	1		; char
		lea	ecx, [ebp+var_20]
		call	sub_100105E7
		mov	ecx, [ebp+var_8]
		xor	ecx, ebp
		pop	esi
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn	4
sub_1001094B	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_10010997(void *, int, int,	int)
sub_10010997	proc near		; CODE XREF: sub_10010A1A+28p
					; WebCore::Decimal::toString(void)+165p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		mov	ebp, [esp+8+arg_4]
		push	esi
		push	edi
		mov	edi, [ebx+10h]
		mov	esi, ecx
		cmp	edi, ebp
		jnb	short loc_100109B1
		call	sub_1001068F
; ---------------------------------------------------------------------------

loc_100109B1:				; CODE XREF: sub_10010997+13j
		sub	edi, ebp
		cmp	[esp+10h+arg_8], edi
		jnb	short loc_100109BD
		mov	edi, [esp+10h+arg_8]

loc_100109BD:				; CODE XREF: sub_10010997+20j
		cmp	esi, ebx
		jnz	short loc_100109D5
		lea	eax, [edi+ebp]
		push	eax
		call	sub_10010C91
		push	ebp
		push	ecx
		mov	ecx, esi
		call	sub_10010CB7
		jmp	short loc_10010A11
; ---------------------------------------------------------------------------

loc_100109D5:				; CODE XREF: sub_10010997+28j
		push	ecx
		push	edi
		call	sub_10010572
		test	al, al
		jz	short loc_10010A11
		cmp	dword ptr [ebx+14h], 10h
		jb	short loc_100109E8
		mov	ebx, [ebx]

loc_100109E8:				; CODE XREF: sub_10010997+4Dj
		cmp	dword ptr [esi+14h], 10h
		jb	short loc_100109F2
		mov	ecx, [esi]
		jmp	short loc_100109F4
; ---------------------------------------------------------------------------

loc_100109F2:				; CODE XREF: sub_10010997+55j
		mov	ecx, esi	; void *

loc_100109F4:				; CODE XREF: sub_10010997+59j
		push	edi		; size_t
		lea	edx, [ebx+ebp]	; void *
		call	sub_10010BC3
		cmp	dword ptr [esi+14h], 10h
		pop	ecx
		mov	[esi+10h], edi
		jb	short loc_10010A0B
		mov	eax, [esi]
		jmp	short loc_10010A0D
; ---------------------------------------------------------------------------

loc_10010A0B:				; CODE XREF: sub_10010997+6Ej
		mov	eax, esi

loc_10010A0D:				; CODE XREF: sub_10010997+72j
		mov	byte ptr [eax+edi], 0

loc_10010A11:				; CODE XREF: sub_10010997+3Cj
					; sub_10010997+47j
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebp
		pop	ebx
		retn	0Ch
sub_10010997	endp


; =============== S U B	R O U T	I N E =======================================


; int __thiscall sub_10010A1A(void *, void *, size_t)
sub_10010A1A	proc near		; CODE XREF: sub_1000F9C9+21p
					; sub_1000F9F5+19p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	esi, ecx
		push	edi
		call	sub_100105AF
		test	al, al
		jz	short loc_10010A49
		cmp	dword ptr [esi+14h], 10h
		jb	short loc_10010A36
		mov	eax, [esi]
		jmp	short loc_10010A38
; ---------------------------------------------------------------------------

loc_10010A36:				; CODE XREF: sub_10010A1A+16j
		mov	eax, esi

loc_10010A38:				; CODE XREF: sub_10010A1A+1Aj
		push	[esp+8+arg_4]	; int
		sub	edi, eax
		mov	ecx, esi	; void *
		push	edi		; int
		push	esi		; int
		call	sub_10010997
		jmp	short loc_10010A86
; ---------------------------------------------------------------------------

loc_10010A49:				; CODE XREF: sub_10010A1A+10j
		push	ebx
		mov	ebx, [esp+0Ch+arg_4]
		push	ecx
		push	ebx
		mov	ecx, esi
		call	sub_10010572
		test	al, al
		jz	short loc_10010A83
		cmp	dword ptr [esi+14h], 10h
		jb	short loc_10010A65
		mov	ecx, [esi]
		jmp	short loc_10010A67
; ---------------------------------------------------------------------------

loc_10010A65:				; CODE XREF: sub_10010A1A+45j
		mov	ecx, esi	; void *

loc_10010A67:				; CODE XREF: sub_10010A1A+49j
		push	ebx		; size_t
		mov	edx, edi	; void *
		call	sub_10010BC3
		cmp	dword ptr [esi+14h], 10h
		pop	ecx
		mov	[esi+10h], ebx
		jb	short loc_10010A7D
		mov	eax, [esi]
		jmp	short loc_10010A7F
; ---------------------------------------------------------------------------

loc_10010A7D:				; CODE XREF: sub_10010A1A+5Dj
		mov	eax, esi

loc_10010A7F:				; CODE XREF: sub_10010A1A+61j
		mov	byte ptr [eax+ebx], 0

loc_10010A83:				; CODE XREF: sub_10010A1A+3Fj
		mov	eax, esi
		pop	ebx

loc_10010A86:				; CODE XREF: sub_10010A1A+2Dj
		pop	edi
		pop	esi
		retn	8
sub_10010A1A	endp

; Exported entry  54. ?ceiling@Decimal@WebCore@@QBE?AV12@XZ

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal __thiscall WebCore::Decimal::ceiling(void)const
		public ?ceiling@Decimal@WebCore@@QBE?AV12@XZ
?ceiling@Decimal@WebCore@@QBE?AV12@XZ proc near
					; CODE XREF: WebCore::Decimal::remainder(WebCore::Decimal const	&)+49p
					; DATA XREF: .rdata:off_100175A8o

var_1C		= dword	ptr -1Ch
var_18		= byte ptr -18h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 1Ch
		push	ebx
		push	esi
		push	edi
		mov	esi, ecx
		call	sub_1001123D
		test	al, al
		jz	short loc_10010AB1

loc_10010AA2:				; CODE XREF: WebCore::Decimal::ceiling(void)+2Dj
					; WebCore::Decimal::ceiling(void)+68j
		mov	eax, [ebp+arg_0]
		mov	edi, eax
		push	6
		pop	ecx
		rep movsd
		jmp	loc_10010B43
; ---------------------------------------------------------------------------

loc_10010AB1:				; CODE XREF: WebCore::Decimal::ceiling(void)+15j
		movzx	eax, word ptr [esi+8]
		test	ax, ax
		jns	short loc_10010AA2
		push	dword ptr [esi+4]
		mov	ebx, [esi]
		movsx	edi, ax
		push	ebx
		neg	edi
		call	sub_10010BDD
		pop	ecx
		pop	ecx
		cmp	eax, edi
		jge	short loc_10010AF5
		xor	eax, eax
		cmp	[esi+10h], eax
		jnz	short loc_10010AE4
		push	1		; int
		lea	ecx, [esp+2Ch+var_18] ;	this
		call	??0Decimal@WebCore@@QAE@H@Z ; WebCore::Decimal::Decimal(int)
		jmp	short loc_10010AF1
; ---------------------------------------------------------------------------

loc_10010AE4:				; CODE XREF: WebCore::Decimal::ceiling(void)+4Aj
		push	eax
		lea	eax, [esp+2Ch+var_18]
		push	eax
		call	?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z ; WebCore::Decimal::zero(WebCore::Decimal::Sign)
		pop	ecx
		pop	ecx

loc_10010AF1:				; CODE XREF: WebCore::Decimal::ceiling(void)+57j
		mov	esi, eax
		jmp	short loc_10010AA2
; ---------------------------------------------------------------------------

loc_10010AF5:				; CODE XREF: WebCore::Decimal::ceiling(void)+43j
		push	dword ptr [esi+4]
		mov	ecx, edi
		push	ebx
		call	sub_10011824
		mov	ebx, eax
		mov	ecx, edi
		mov	eax, edx
		push	eax
		push	ebx
		mov	[esp+38h+var_1C], eax
		call	sub_1001184F
		mov	ecx, [esi]
		add	esp, 10h
		sub	ecx, eax
		mov	eax, [esi+4]
		sbb	eax, edx
		or	ecx, eax
		mov	ecx, [esp+28h+var_1C]
		push	0
		pop	eax
		jz	short loc_10010B32
		cmp	[esi+10h], eax
		jnz	short loc_10010B32
		add	ebx, 1
		adc	ecx, eax

loc_10010B32:				; CODE XREF: WebCore::Decimal::ceiling(void)+9Bj
					; WebCore::Decimal::ceiling(void)+A0j
		push	ecx
		mov	ecx, [ebp+arg_0]
		push	ebx
		push	eax
		push	dword ptr [esi+10h]
		call	??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	; WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned	__int64)
		mov	eax, [ebp+arg_0]

loc_10010B43:				; CODE XREF: WebCore::Decimal::ceiling(void)+21j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?ceiling@Decimal@WebCore@@QBE?AV12@XZ endp

; Exported entry  55. ?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: class WebCore::Decimal __thiscall WebCore::Decimal::compareTo(class WebCore::Decimal	const &)const
		public ?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z
?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z proc near
					; CODE XREF: WebCore::Decimal::operator==(WebCore::Decimal const &)+29p
					; WebCore::Decimal::operator!=(WebCore::Decimal	const &)+2Dp ...

var_18		= byte ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 18h
		push	esi
		push	edi
		push	[ebp+arg_4]
		lea	eax, [esp+24h+var_18]
		push	eax
		call	??GDecimal@WebCore@@QBE?AV01@ABV01@@Z ;	WebCore::Decimal::operator-(WebCore::Decimal const &)
		mov	eax, [esp+20h+var_C]
		test	eax, eax
		jz	short loc_10010B99
		jle	short loc_10010B8F
		cmp	eax, 2
		jle	short loc_10010B89
		cmp	eax, 3
		jnz	short loc_10010B8F
		push	0
		push	[ebp+arg_0]
		call	?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z ; WebCore::Decimal::zero(WebCore::Decimal::Sign)
		pop	ecx

loc_10010B83:				; CODE XREF: WebCore::Decimal::compareTo(WebCore::Decimal const	&)+4Bj
		mov	eax, [ebp+arg_0]
		pop	ecx
		jmp	short loc_10010BBB
; ---------------------------------------------------------------------------

loc_10010B89:				; CODE XREF: WebCore::Decimal::compareTo(WebCore::Decimal const	&)+25j
		lea	esi, [esp+20h+var_18]
		jmp	short loc_10010BB1
; ---------------------------------------------------------------------------

loc_10010B8F:				; CODE XREF: WebCore::Decimal::compareTo(WebCore::Decimal const	&)+20j
					; WebCore::Decimal::compareTo(WebCore::Decimal const &)+2Aj
		push	[ebp+arg_0]
		call	?nan@Decimal@WebCore@@SA?AV12@XZ ; WebCore::Decimal::nan(void)
		jmp	short loc_10010B83
; ---------------------------------------------------------------------------

loc_10010B99:				; CODE XREF: WebCore::Decimal::compareTo(WebCore::Decimal const	&)+1Ej
		cmp	[esp+20h+var_8], 1
		lea	ecx, [esp+20h+var_18] ;	this
		jnz	short loc_10010BA8
		push	0FFFFFFFFh
		jmp	short loc_10010BAA
; ---------------------------------------------------------------------------

loc_10010BA8:				; CODE XREF: WebCore::Decimal::compareTo(WebCore::Decimal const	&)+56j
		push	1		; int

loc_10010BAA:				; CODE XREF: WebCore::Decimal::compareTo(WebCore::Decimal const	&)+5Aj
		call	??0Decimal@WebCore@@QAE@H@Z ; WebCore::Decimal::Decimal(int)
		mov	esi, eax

loc_10010BB1:				; CODE XREF: WebCore::Decimal::compareTo(WebCore::Decimal const	&)+41j
		mov	eax, [ebp+arg_0]
		mov	edi, eax
		push	6
		pop	ecx
		rep movsd

loc_10010BBB:				; CODE XREF: WebCore::Decimal::compareTo(WebCore::Decimal const	&)+3Bj
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn	8
?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z endp


; =============== S U B	R O U T	I N E =======================================


; int __usercall sub_10010BC3@<eax>(void *@<ecx>, void *@<edx>,	size_t)
sub_10010BC3	proc near		; CODE XREF: sub_100104CE+75p
					; sub_100105E7+1Fp ...

arg_0		= dword	ptr  4

		cmp	[esp+arg_0], 0
		jz	short loc_10010BDA
		push	[esp+arg_0]	; size_t
		push	edx		; void *
		push	ecx		; void *
		call	memcpy
		add	esp, 0Ch
		mov	ecx, eax

loc_10010BDA:				; CODE XREF: sub_10010BC3+5j
		mov	eax, ecx
		retn
sub_10010BC3	endp


; =============== S U B	R O U T	I N E =======================================


sub_10010BDD	proc near		; CODE XREF: WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+49p
					; WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+C3p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		xor	eax, eax
		xor	edx, edx
		push	esi
		xor	esi, esi
		inc	eax
		cmp	[esp+4+arg_4], edx
		jb	short loc_10010C18
		jbe	short loc_10010C12

loc_10010BED:				; CODE XREF: sub_10010BDD+31j
					; sub_10010BDD+39j
		inc	esi
		cmp	edx, 19999999h
		ja	short loc_10010C18
		jb	short loc_10010BFF
		cmp	eax, 99999999h
		jnb	short loc_10010C18

loc_10010BFF:				; CODE XREF: sub_10010BDD+19j
		push	0
		push	0Ah
		push	edx
		push	eax
		call	__allmul
		cmp	[esp+4+arg_4], edx
		ja	short loc_10010BED
		jb	short loc_10010C18

loc_10010C12:				; CODE XREF: sub_10010BDD+Ej
		cmp	[esp+4+arg_0], eax
		jnb	short loc_10010BED

loc_10010C18:				; CODE XREF: sub_10010BDD+Cj
					; sub_10010BDD+17j ...
		mov	eax, esi
		pop	esi
		retn
sub_10010BDD	endp


; =============== S U B	R O U T	I N E =======================================


sub_10010C1C	proc near		; DATA XREF: .rdata:10016370o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_4]
		push	esi
		call	ds:?_Syserror_map@std@@YAPBDH@Z	; std::_Syserror_map(int)
		test	eax, eax
		mov	eax, [esp+8+arg_0]
		pop	ecx
		mov	[eax], esi
		jz	short loc_10010C3C
		mov	dword ptr [eax+4], offset off_1001A02C
		jmp	short loc_10010C43
; ---------------------------------------------------------------------------

loc_10010C3C:				; CODE XREF: sub_10010C1C+15j
		mov	dword ptr [eax+4], offset dword_1001ABF0

loc_10010C43:				; CODE XREF: sub_10010C1C+1Ej
		pop	esi
		retn	8
sub_10010C1C	endp


; =============== S U B	R O U T	I N E =======================================


sub_10010C47	proc near		; DATA XREF: .rdata:1001635Co
					; .rdata:10016374o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		cmp	ecx, [eax+4]
		jnz	short loc_10010C5D
		mov	eax, [eax]
		cmp	eax, [esp+arg_4]
		jnz	short loc_10010C5D
		xor	eax, eax
		inc	eax
		jmp	short locret_10010C5F
; ---------------------------------------------------------------------------

loc_10010C5D:				; CODE XREF: sub_10010C47+7j
					; sub_10010C47+Fj
		xor	eax, eax

locret_10010C5F:			; CODE XREF: sub_10010C47+14j
		retn	8
sub_10010C47	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10010C62	proc near		; DATA XREF: .rdata:10016360o
					; .rdata:10016378o ...

var_8		= byte ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ecx
		push	[ebp+arg_0]
		mov	eax, [ecx]
		lea	edx, [ebp+var_8]
		push	edx
		call	dword ptr [eax+0Ch]
		mov	edx, [ebp+arg_4]
		mov	ecx, [eax+4]
		cmp	ecx, [edx+4]
		jnz	short loc_10010C89
		mov	eax, [eax]
		cmp	eax, [edx]
		jnz	short loc_10010C89
		xor	eax, eax
		inc	eax
		jmp	short loc_10010C8B
; ---------------------------------------------------------------------------

loc_10010C89:				; CODE XREF: sub_10010C62+1Aj
					; sub_10010C62+20j
		xor	eax, eax

loc_10010C8B:				; CODE XREF: sub_10010C62+25j
		mov	esp, ebp
		pop	ebp
		retn	8
sub_10010C62	endp


; =============== S U B	R O U T	I N E =======================================


sub_10010C91	proc near		; CODE XREF: sub_10010997+2Ep

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		cmp	[ecx+10h], eax
		jnb	short loc_10010C9F
		call	sub_1001068F
; ---------------------------------------------------------------------------

loc_10010C9F:				; CODE XREF: sub_10010C91+7j
		cmp	dword ptr [ecx+14h], 10h
		mov	[ecx+10h], eax
		jb	short loc_10010CAC
		mov	edx, [ecx]
		jmp	short loc_10010CAE
; ---------------------------------------------------------------------------

loc_10010CAC:				; CODE XREF: sub_10010C91+15j
		mov	edx, ecx

loc_10010CAE:				; CODE XREF: sub_10010C91+19j
		mov	byte ptr [edx+eax], 0
		mov	eax, ecx
		retn	4
sub_10010C91	endp


; =============== S U B	R O U T	I N E =======================================


sub_10010CB7	proc near		; CODE XREF: sub_10010997+37p

arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		push	esi
		mov	esi, ecx
		push	edi
		mov	edi, [esi+10h]
		cmp	edi, eax
		ja	short loc_10010CDB
		and	dword ptr [esi+10h], 0
		cmp	dword ptr [esi+14h], 10h
		jb	short loc_10010CD4
		mov	eax, [esi]
		jmp	short loc_10010CD6
; ---------------------------------------------------------------------------

loc_10010CD4:				; CODE XREF: sub_10010CB7+17j
		mov	eax, esi

loc_10010CD6:				; CODE XREF: sub_10010CB7+1Bj
		mov	byte ptr [eax],	0
		jmp	short loc_10010D06
; ---------------------------------------------------------------------------

loc_10010CDB:				; CODE XREF: sub_10010CB7+Dj
		test	eax, eax
		jz	short loc_10010D06
		cmp	dword ptr [esi+14h], 10h
		jb	short loc_10010CE7
		mov	ecx, [esi]	; void *

loc_10010CE7:				; CODE XREF: sub_10010CB7+2Cj
		sub	edi, eax
		lea	edx, [ecx+eax]	; void *
		push	edi		; size_t
		call	sub_100112DC
		cmp	dword ptr [esi+14h], 10h
		pop	ecx
		mov	[esi+10h], edi
		jb	short loc_10010D00
		mov	eax, [esi]
		jmp	short loc_10010D02
; ---------------------------------------------------------------------------

loc_10010D00:				; CODE XREF: sub_10010CB7+43j
		mov	eax, esi

loc_10010D02:				; CODE XREF: sub_10010CB7+47j
		mov	byte ptr [eax+edi], 0

loc_10010D06:				; CODE XREF: sub_10010CB7+22j
					; sub_10010CB7+26j
		pop	edi
		mov	eax, esi
		pop	esi
		retn	8
sub_10010CB7	endp

; Exported entry  61. ?floor@Decimal@WebCore@@QBE?AV12@XZ

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal __thiscall WebCore::Decimal::floor(void)const
		public ?floor@Decimal@WebCore@@QBE?AV12@XZ
?floor@Decimal@WebCore@@QBE?AV12@XZ proc near
					; CODE XREF: WebCore::Decimal::remainder(WebCore::Decimal const	&)+55p
					; DATA XREF: .rdata:off_100175A8o

var_1C		= dword	ptr -1Ch
var_18		= byte ptr -18h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 1Ch
		push	ebx
		push	esi
		push	edi
		mov	esi, ecx
		call	sub_1001123D
		test	al, al
		jz	short loc_10010D33

loc_10010D24:				; CODE XREF: WebCore::Decimal::floor(void)+2Dj
					; WebCore::Decimal::floor(void)+68j
		mov	eax, [ebp+arg_0]
		mov	edi, eax
		push	6
		pop	ecx
		rep movsd
		jmp	loc_10010DC5
; ---------------------------------------------------------------------------

loc_10010D33:				; CODE XREF: WebCore::Decimal::floor(void)+15j
		movzx	eax, word ptr [esi+8]
		test	ax, ax
		jns	short loc_10010D24
		push	dword ptr [esi+4]
		mov	ebx, [esi]
		movsx	edi, ax
		push	ebx
		neg	edi
		call	sub_10010BDD
		pop	ecx
		pop	ecx
		cmp	eax, edi
		jge	short loc_10010D77
		cmp	dword ptr [esi+10h], 0
		jnz	short loc_10010D68
		lea	eax, [esp+28h+var_18]
		push	0
		push	eax
		call	?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z ; WebCore::Decimal::zero(WebCore::Decimal::Sign)
		pop	ecx
		pop	ecx
		jmp	short loc_10010D73
; ---------------------------------------------------------------------------

loc_10010D68:				; CODE XREF: WebCore::Decimal::floor(void)+49j
		push	0FFFFFFFFh	; int
		lea	ecx, [esp+2Ch+var_18] ;	this
		call	??0Decimal@WebCore@@QAE@H@Z ; WebCore::Decimal::Decimal(int)

loc_10010D73:				; CODE XREF: WebCore::Decimal::floor(void)+59j
		mov	esi, eax
		jmp	short loc_10010D24
; ---------------------------------------------------------------------------

loc_10010D77:				; CODE XREF: WebCore::Decimal::floor(void)+43j
		push	dword ptr [esi+4]
		mov	ecx, edi
		push	ebx
		call	sub_10011824
		mov	ebx, eax
		mov	ecx, edi
		mov	eax, edx
		push	eax
		push	ebx
		mov	[esp+38h+var_1C], eax
		call	sub_1001184F
		mov	ecx, [esi]
		add	esp, 10h
		sub	ecx, eax
		mov	eax, [esi+4]
		sbb	eax, edx
		or	ecx, eax
		mov	eax, [esp+28h+var_1C]
		jz	short loc_10010DB3
		cmp	dword ptr [esi+10h], 1
		jnz	short loc_10010DB3
		add	ebx, 1
		adc	eax, 0

loc_10010DB3:				; CODE XREF: WebCore::Decimal::floor(void)+98j
					; WebCore::Decimal::floor(void)+9Ej
		mov	ecx, [ebp+arg_0]
		push	eax
		push	ebx
		push	0
		push	dword ptr [esi+10h]
		call	??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	; WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned	__int64)
		mov	eax, [ebp+arg_0]

loc_10010DC5:				; CODE XREF: WebCore::Decimal::floor(void)+21j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?floor@Decimal@WebCore@@QBE?AV12@XZ endp

; Exported entry  62. ?fromDouble@Decimal@WebCore@@SA?AV12@N@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static class WebCore::Decimal	__cdecl	WebCore::Decimal::fromDouble(double)
		public ?fromDouble@Decimal@WebCore@@SA?AV12@N@Z
?fromDouble@Decimal@WebCore@@SA?AV12@N@Z proc near ; DATA XREF:	.rdata:off_100175A8o

var_38		= qword	ptr -38h
var_28		= qword	ptr -28h
var_1C		= byte ptr -1Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= qword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 2Ch
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+2Ch+var_4], eax
		fld	[ebp+arg_4]
		push	esi
		mov	esi, [ebp+arg_0]
		push	ecx
		push	ecx
		fst	[esp+38h+var_28]
		fstp	[esp+38h+var_38] ; double
		call	sub_1000F90A
		fld	[esp+38h+var_28]
		pop	ecx
		pop	ecx
		push	ecx
		push	ecx
		fstp	[esp+38h+var_38] ; double
		test	al, al
		jz	short loc_10010E28
		lea	ecx, [esp+38h+var_1C]
		call	sub_10011370
		push	eax
		push	esi
		call	?fromString@Decimal@WebCore@@SA?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z	; WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
		add	esp, 10h
		lea	ecx, [esp+30h+var_1C]
		push	0		; size_t
		push	1		; char
		call	sub_100105E7
		jmp	short loc_10010E58
; ---------------------------------------------------------------------------

loc_10010E28:				; CODE XREF: WebCore::Decimal::fromDouble(double)+36j
		call	sub_1000F928
		pop	ecx
		pop	ecx
		test	al, al
		jz	short loc_10010E51
		fldz
		fcomp	[esp+30h+var_28]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_10010E45
		xor	eax, eax
		inc	eax
		jmp	short loc_10010E47
; ---------------------------------------------------------------------------

loc_10010E45:				; CODE XREF: WebCore::Decimal::fromDouble(double)+70j
		xor	eax, eax

loc_10010E47:				; CODE XREF: WebCore::Decimal::fromDouble(double)+75j
		push	eax
		push	esi
		call	?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z	; WebCore::Decimal::infinity(WebCore::Decimal::Sign)
		pop	ecx
		jmp	short loc_10010E57
; ---------------------------------------------------------------------------

loc_10010E51:				; CODE XREF: WebCore::Decimal::fromDouble(double)+63j
		push	esi
		call	?nan@Decimal@WebCore@@SA?AV12@XZ ; WebCore::Decimal::nan(void)

loc_10010E57:				; CODE XREF: WebCore::Decimal::fromDouble(double)+81j
		pop	ecx

loc_10010E58:				; CODE XREF: WebCore::Decimal::fromDouble(double)+58j
		mov	ecx, [esp+30h+var_4]
		mov	eax, esi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
?fromDouble@Decimal@WebCore@@SA?AV12@N@Z endp

; Exported entry  63. ?fromString@Decimal@WebCore@@SA?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z

; =============== S U B	R O U T	I N E =======================================


; public: static class WebCore::Decimal	__cdecl	WebCore::Decimal::fromString(class std::basic_string<char, struct std::char_traits<char>, class	std::allocator<char>> const &)
		public ?fromString@Decimal@WebCore@@SA?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
?fromString@Decimal@WebCore@@SA?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z	proc near
					; CODE XREF: WebCore::Decimal::fromDouble(double)+43p
					; DATA XREF: .rdata:off_100175A8o

var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= byte ptr -34h
var_1C		= byte ptr -1Ch
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		sub	esp, 5Ch
		and	[esp+5Ch+var_48], 0
		xor	eax, eax
		push	ebx
		push	ebp
		push	esi
		mov	[esp+68h+var_58], eax
		xor	ebx, ebx
		mov	[esp+68h+var_40], eax
		xor	ecx, ecx
		mov	eax, [esp+68h+arg_4]
		xor	edx, edx
		push	edi
		mov	[esp+6Ch+var_50], ebx
		xor	edi, edi
		push	7
		mov	ebx, [eax+10h]
		xor	ebp, ebp
		mov	[esp+70h+var_38], ebx
		cmp	ebx, ecx
		mov	[esp+70h+var_44], ecx
		mov	ebx, ecx
		mov	[esp+70h+var_54], edi
		pop	esi
		mov	[esp+6Ch+var_3C], ecx
		jbe	loc_10011169	; jumptable 10010EC7 default case

loc_10010EB2:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+B3j
		cmp	dword ptr [eax+14h], 10h
		jb	short loc_10010EBA
		mov	eax, [eax]

loc_10010EBA:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+4Cj
		movsx	ecx, byte ptr [eax+ecx]
		cmp	esi, 8		; switch 9 cases
		ja	loc_10011169	; jumptable 10010EC7 default case
		jmp	ds:off_10011182[esi*4] ; switch	jump
; ---------------------------------------------------------------------------

loc_10010ECE:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Dj
					; DATA XREF: .text:off_10011182o
		lea	edi, [ecx-30h]	; jumptable 10010EC7 case 0
		cmp	edi, 9
		ja	short loc_10010F25
		cmp	edx, 12h
		jge	short loc_10010F1F
		inc	edx

loc_10010EDC:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+135j
		push	0
		push	0Ah
		push	ebx
		push	ebp
		mov	[esp+7Ch+var_4C], edx
		call	__allmul
		mov	ebp, eax
		mov	ebx, edx
		mov	eax, edi
		cdq
		add	ebp, eax
		adc	ebx, edx
		mov	edx, [esp+6Ch+var_4C]
		mov	[esp+6Ch+var_50], ebx

loc_10010EFE:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+B9j
					; WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+C3j ...
		mov	edi, [esp+6Ch+var_54]

loc_10010F02:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+11Aj
					; WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+1DFj ...
		mov	eax, [esp+6Ch+var_58]

loc_10010F06:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+15Ej
		mov	ecx, [esp+6Ch+var_3C]
		inc	ecx
		mov	[esp+6Ch+var_3C], ecx
		cmp	ecx, [esp+6Ch+var_38]
		jnb	loc_100110E3
		mov	eax, [esp+6Ch+arg_4]
		jmp	short loc_10010EB2
; ---------------------------------------------------------------------------

loc_10010F1F:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+6Fj
		inc	[esp+6Ch+var_40]
		jmp	short loc_10010EFE
; ---------------------------------------------------------------------------

loc_10010F25:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+6Aj
		cmp	ecx, 2Eh
		jnz	short loc_10010F2F
		xor	esi, esi
		inc	esi
		jmp	short loc_10010EFE
; ---------------------------------------------------------------------------

loc_10010F2F:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+BEj
		cmp	ecx, 45h
		jz	short loc_10010F3D
		cmp	ecx, 65h
		jnz	loc_10011169	; jumptable 10010EC7 default case

loc_10010F3D:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+C8j
		push	3
		pop	esi
		jmp	short loc_10010EFE
; ---------------------------------------------------------------------------

loc_10010F42:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Dj
					; DATA XREF: .text:off_10011182o
		cmp	ecx, 30h	; jumptable 10010EC7 case 1
		jl	short loc_10010FA8
		cmp	ecx, 39h
		jg	short loc_10010F89 ; jumptable 10010EC7	case 2
		cmp	edx, 12h
		jge	short loc_10010F81
		push	0
		inc	edx
		lea	eax, [ecx-30h]
		inc	[esp+70h+var_44]
		push	0Ah
		mov	[esp+74h+var_4C], edx
		cdq
		push	ebx
		push	ebp
		mov	esi, eax
		mov	edi, edx
		call	__allmul
		add	esi, eax
		mov	ebp, esi
		adc	edi, edx
		mov	edx, [esp+6Ch+var_4C]
		mov	ebx, edi
		mov	edi, [esp+6Ch+var_54]
		mov	[esp+6Ch+var_50], ebx

loc_10010F81:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+E5j
		push	2

loc_10010F83:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+14Ej
					; WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+17Fj ...
		pop	esi
		jmp	loc_10010F02
; ---------------------------------------------------------------------------

loc_10010F89:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Dj
					; WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+E0j
					; DATA XREF: ...
		lea	edi, [ecx-30h]	; jumptable 10010EC7 case 2
		cmp	edi, 9
		ja	short loc_10010FA4
		cmp	edx, 12h
		jge	loc_10010EFE
		inc	edx
		inc	[esp+6Ch+var_44]
		jmp	loc_10010EDC
; ---------------------------------------------------------------------------

loc_10010FA4:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+125j
		mov	edi, [esp+6Ch+var_54]

loc_10010FA8:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+DBj
					; WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+242j
		cmp	ecx, 45h
		jz	short loc_10010FB6
		cmp	ecx, 65h
		jnz	loc_10011169	; jumptable 10010EC7 default case

loc_10010FB6:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+141j
		push	3
		jmp	short loc_10010F83
; ---------------------------------------------------------------------------

loc_10010FBA:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Dj
					; DATA XREF: .text:off_10011182o
		cmp	ecx, 2Bh	; jumptable 10010EC7 case 3
		jnz	short loc_10010FCD
		xor	eax, eax

loc_10010FC1:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+16Bj
		push	5
		mov	[esp+70h+var_58], eax
		pop	esi
		jmp	loc_10010F06
; ---------------------------------------------------------------------------

loc_10010FCD:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+153j
		cmp	ecx, 2Dh
		jnz	short loc_10010FD7 ; jumptable 10010EC7	case 5
		xor	eax, eax
		inc	eax
		jmp	short loc_10010FC1
; ---------------------------------------------------------------------------

loc_10010FD7:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Dj
					; WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+166j
					; DATA XREF: ...
		lea	eax, [ecx-30h]	; jumptable 10010EC7 case 5
		mov	[esp+6Ch+var_48], eax
		cmp	eax, 9
		ja	loc_10011169	; jumptable 10010EC7 default case

loc_10010FE7:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+1A0j
		push	4
		jmp	short loc_10010F83
; ---------------------------------------------------------------------------

loc_10010FEB:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Dj
					; DATA XREF: .text:off_10011182o
		lea	eax, [ecx-30h]	; jumptable 10010EC7 case 4
		cmp	eax, 9
		ja	loc_10011169	; jumptable 10010EC7 default case
		imul	eax, [esp+6Ch+var_48], 0Ah
		add	eax, 0FFFFFFD0h
		add	eax, ecx
		mov	[esp+6Ch+var_48], eax
		cmp	eax, 411h
		jle	short loc_10010FE7
		or	ebp, ebx
		jz	loc_100110D3
		cmp	[esp+6Ch+var_58], 1
		jnz	loc_100110B4
		lea	eax, [esp+6Ch+var_34]
		push	0
		push	eax
		call	?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z ; WebCore::Decimal::zero(WebCore::Decimal::Sign)
		jmp	loc_100110BF
; ---------------------------------------------------------------------------

loc_10011030:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Dj
					; DATA XREF: .text:off_10011182o
		lea	eax, [ecx-31h]	; jumptable 10010EC7 case 6
		cmp	eax, 8
		ja	short loc_1001104E

loc_10011038:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+1FAj
					; WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+23Dj
		lea	eax, [ecx-30h]
		cdq
		mov	ebx, edx
		mov	ebp, eax
		xor	edx, edx
		mov	[esp+6Ch+var_50], ebx
		inc	edx
		xor	esi, esi
		jmp	loc_10010F02
; ---------------------------------------------------------------------------

loc_1001104E:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+1CCj
		cmp	ecx, 30h
		jnz	loc_10011169	; jumptable 10010EC7 default case

loc_10011057:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+21Bj
		push	8
		jmp	loc_10010F83
; ---------------------------------------------------------------------------

loc_1001105E:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Dj
					; DATA XREF: .text:off_10011182o
		lea	eax, [ecx-31h]	; jumptable 10010EC7 case 7
		cmp	eax, 8
		jbe	short loc_10011038
		cmp	ecx, 2Dh
		jnz	short loc_10011079
		xor	edi, edi
		inc	edi

loc_1001106E:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+216j
		mov	[esp+6Ch+var_54], edi
		push	6
		jmp	loc_10010F83
; ---------------------------------------------------------------------------

loc_10011079:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+1FFj
		cmp	ecx, 2Bh
		jnz	short loc_10011082
		xor	edi, edi
		jmp	short loc_1001106E
; ---------------------------------------------------------------------------

loc_10011082:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+212j
		cmp	ecx, 30h
		jz	short loc_10011057
		cmp	ecx, 2Eh
		jnz	loc_10011169	; jumptable 10010EC7 default case

loc_10011090:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+248j
		xor	esi, esi
		inc	esi
		jmp	loc_10010F02
; ---------------------------------------------------------------------------

loc_10011098:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Dj
					; DATA XREF: .text:off_10011182o
		cmp	ecx, 30h	; jumptable 10010EC7 case 8
		jz	loc_10010F02
		lea	eax, [ecx-31h]
		cmp	eax, 8
		jbe	short loc_10011038
		cmp	ecx, 2Eh
		jnz	loc_10010FA8
		jmp	short loc_10011090
; ---------------------------------------------------------------------------

loc_100110B4:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+1AFj
		lea	eax, [esp+6Ch+var_1C]
		push	edi
		push	eax
		call	?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z	; WebCore::Decimal::infinity(WebCore::Decimal::Sign)

loc_100110BF:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+1C1j
		pop	ecx
		pop	ecx
		mov	esi, eax
		mov	eax, [esp+6Ch+arg_0]
		push	6
		pop	ecx
		mov	edi, eax
		rep movsd
		jmp	loc_10011177
; ---------------------------------------------------------------------------

loc_100110D3:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+1A4j
					; WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+27Cj
		push	edi

loc_100110D4:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+2B4j
		push	[esp+70h+arg_0]
		call	?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z ; WebCore::Decimal::zero(WebCore::Decimal::Sign)

loc_100110DD:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+2D5j
		pop	ecx
		jmp	loc_10011172
; ---------------------------------------------------------------------------

loc_100110E3:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+A9j
		cmp	esi, 8
		jz	short loc_100110D3
		test	esi, esi
		jz	short loc_100110F6
		cmp	esi, 4
		jz	short loc_100110F6
		cmp	esi, 2
		jnz	short loc_10011169 ; jumptable 10010EC7	default	case

loc_100110F6:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+280j
					; WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+285j
		mov	ecx, [esp+6Ch+var_44]
		xor	ebx, ebx
		cmp	eax, 1
		setnz	bl
		lea	ebx, ds:0FFFFFFFFh[ebx*2]
		imul	ebx, [esp+6Ch+var_48]
		sub	ebx, ecx
		add	ebx, [esp+6Ch+var_40]
		cmp	ebx, 0FFFFFC01h
		jge	short loc_10011120
		push	0
		jmp	short loc_100110D4
; ---------------------------------------------------------------------------

loc_10011120:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+2B0j
		lea	esi, [ebx-3FEh]
		test	esi, esi
		jle	short loc_10011156
		mov	eax, esi
		sub	eax, ecx
		add	eax, edx
		cmp	eax, 12h
		jle	short loc_10011141
		push	edi
		push	[esp+70h+arg_0]
		call	?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z	; WebCore::Decimal::infinity(WebCore::Decimal::Sign)
		jmp	short loc_100110DD
; ---------------------------------------------------------------------------

loc_10011141:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+2C9j
		mov	edx, [esp+6Ch+var_50]
		mov	ecx, esi
		push	edx
		push	ebp
		call	sub_1001184F
		pop	ecx
		pop	ecx
		mov	ebp, eax
		sub	ebx, esi
		jmp	short loc_1001115A
; ---------------------------------------------------------------------------

loc_10011156:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+2BEj
		mov	edx, [esp+6Ch+var_50]

loc_1001115A:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+2EAj
		mov	ecx, [esp+6Ch+arg_0]
		push	edx
		push	ebp
		push	ebx
		push	edi
		call	??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	; WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned	__int64)
		jmp	short loc_10011173
; ---------------------------------------------------------------------------

loc_10011169:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+42j
					; WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+57j ...
		push	[esp+6Ch+arg_0]	; jumptable 10010EC7 default case
		call	?nan@Decimal@WebCore@@SA?AV12@XZ ; WebCore::Decimal::nan(void)

loc_10011172:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+274j
		pop	ecx

loc_10011173:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+2FDj
		mov	eax, [esp+6Ch+arg_0]

loc_10011177:				; CODE XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+264j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 5Ch
		retn
?fromString@Decimal@WebCore@@SA?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z	endp

; ---------------------------------------------------------------------------
		db 8Dh,	49h, 0
off_10011182	dd offset loc_10010ECE	; DATA XREF: WebCore::Decimal::fromString(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Dr
		dd offset loc_10010F42	; jump table for switch	statement
		dd offset loc_10010F89
		dd offset loc_10010FBA
		dd offset loc_10010FEB
		dd offset loc_10010FD7
		dd offset loc_10011030
		dd offset loc_1001105E
		dd offset loc_10011098

; =============== S U B	R O U T	I N E =======================================


sub_100111A6	proc near		; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+38p
					; WebCore::Decimal::operator-(WebCore::Decimal const &)+2Fp ...
		push	esi
		mov	esi, ecx
		push	edi
		mov	edi, [esi]
		mov	ecx, edi
		call	sub_1001123D
		test	al, al
		jnz	short loc_100111C7
		mov	ecx, [esi+4]
		call	sub_1001123D
		test	al, al
		jnz	short loc_100111C7
		xor	eax, eax
		jmp	short loc_10011208
; ---------------------------------------------------------------------------

loc_100111C7:				; CODE XREF: sub_100111A6+Fj
					; sub_100111A6+1Bj
		mov	eax, [esi+4]
		push	2
		mov	ecx, [eax+0Ch]
		pop	eax
		cmp	[edi+0Ch], eax
		jnz	short loc_100111DB
		and	dword ptr [esi+8], 0
		jmp	short loc_10011208
; ---------------------------------------------------------------------------

loc_100111DB:				; CODE XREF: sub_100111A6+2Dj
		cmp	ecx, eax
		jnz	short loc_100111E8
		mov	dword ptr [esi+8], 1
		jmp	short loc_10011208
; ---------------------------------------------------------------------------

loc_100111E8:				; CODE XREF: sub_100111A6+37j
		cmp	dword ptr [edi+0Ch], 0
		jnz	short loc_100111FE
		xor	eax, eax
		test	ecx, ecx
		setnz	al
		lea	eax, ds:1[eax*2]
		jmp	short loc_10011208
; ---------------------------------------------------------------------------

loc_100111FE:				; CODE XREF: sub_100111A6+46j
		neg	ecx
		sbb	ecx, ecx
		and	ecx, 0FFFFFFFCh
		lea	eax, [ecx+4]

loc_10011208:				; CODE XREF: sub_100111A6+1Fj
					; sub_100111A6+33j ...
		pop	edi
		pop	esi
		retn
sub_100111A6	endp

; Exported entry  67. ?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static class WebCore::Decimal	__cdecl	WebCore::Decimal::infinity(enum	 WebCore::Decimal::Sign)
		public ?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z
?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z	proc near
					; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+87p
					; WebCore::Decimal::operator*(WebCore::Decimal const &)+B4p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= word ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	esi
		xor	ecx, ecx
		lea	esi, [ebp+var_18]
		push	edi
		xor	eax, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_10], ax
		mov	eax, [ebp+arg_4]
		push	6
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]
		mov	edi, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_C], ecx
		pop	ecx
		rep movsd
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z	endp


; =============== S U B	R O U T	I N E =======================================


sub_1001123D	proc near		; CODE XREF: WebCore::Decimal::ceiling(void)+Ep
					; WebCore::Decimal::floor(void)+Ep ...
		cmp	dword ptr [ecx+0Ch], 0
		jz	short loc_1001124C
		cmp	dword ptr [ecx+0Ch], 2
		jz	short loc_1001124C
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1001124C:				; CODE XREF: sub_1001123D+4j
					; sub_1001123D+Aj
		xor	eax, eax
		inc	eax
		retn
sub_1001123D	endp


; =============== S U B	R O U T	I N E =======================================


sub_10011250	proc near		; CODE XREF: sub_1000F9C9+15p
					; WebCore::Decimal::toString(void)+1DBp
		cmp	byte ptr [ecx],	0
		jnz	short loc_10011259
		xor	ecx, ecx
		jmp	short loc_10011265
; ---------------------------------------------------------------------------

loc_10011259:				; CODE XREF: sub_10011250+3j
		lea	edx, [ecx+1]

loc_1001125C:				; CODE XREF: sub_10011250+11j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1001125C
		sub	ecx, edx

loc_10011265:				; CODE XREF: sub_10011250+7j
		mov	eax, ecx
		retn
sub_10011250	endp


; =============== S U B	R O U T	I N E =======================================


sub_10011268	proc near		; CODE XREF: sub_1001128D+1Ep
					; DATA XREF: .rdata:10016384o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	[esp+arg_4]
		call	ds:?_Syserror_map@std@@YAPBDH@Z	; std::_Syserror_map(int)
		pop	ecx
		test	eax, eax
		jnz	short loc_1001127C
		mov	eax, offset aUnknownError ; "unknown error"

loc_1001127C:				; CODE XREF: sub_10011268+Dj
		mov	ecx, [esp+arg_0]
		push	eax
		call	sub_1000F9C9
		mov	eax, [esp+arg_0]
		retn	8
sub_10011268	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1001128D	proc near		; DATA XREF: .rdata:1001639Co

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		cmp	[ebp+arg_4], 1
		jnz	short loc_100112A5
		mov	ecx, [ebp+arg_0]
		push	offset aIostreamStream ; "iostream stream error"
		call	sub_1000F9C9
		jmp	short loc_100112B0
; ---------------------------------------------------------------------------

loc_100112A5:				; CODE XREF: sub_1001128D+7j
		push	[ebp+arg_4]
		push	[ebp+arg_0]
		call	sub_10011268

loc_100112B0:				; CODE XREF: sub_1001128D+16j
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn	8
sub_1001128D	endp


; =============== S U B	R O U T	I N E =======================================


sub_100112B7	proc near		; DATA XREF: .rdata:1001636Co

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	[esp+arg_4]
		call	ds:?_Winerror_map@std@@YAPBDH@Z	; std::_Winerror_map(int)
		pop	ecx
		test	eax, eax
		jnz	short loc_100112CB
		mov	eax, offset aUnknownError ; "unknown error"

loc_100112CB:				; CODE XREF: sub_100112B7+Dj
		mov	ecx, [esp+arg_0]
		push	eax
		call	sub_1000F9C9
		mov	eax, [esp+arg_0]
		retn	8
sub_100112B7	endp


; =============== S U B	R O U T	I N E =======================================


; int __usercall sub_100112DC@<eax>(void *@<ecx>, void *@<edx>,	size_t)
sub_100112DC	proc near		; CODE XREF: sub_10010487+15p
					; sub_10010CB7+36p

arg_0		= dword	ptr  4

		cmp	[esp+arg_0], 0
		jz	short loc_100112F4
		push	[esp+arg_0]	; size_t
		push	edx		; void *
		push	ecx		; void *
		call	ds:memmove
		add	esp, 0Ch
		mov	ecx, eax

loc_100112F4:				; CODE XREF: sub_100112DC+5j
		mov	eax, ecx
		retn
sub_100112DC	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100112F7	proc near		; CODE XREF: WebCore::Decimal::toDouble(void)+32p

var_30		= dword	ptr -30h
var_28		= qword	ptr -28h
var_20		= qword	ptr -20h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= qword	ptr -10h
var_8		= qword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 34h
		or	eax, 0FFFFFFFFh
		push	ebx
		push	esi
		mov	dword ptr [ebp+var_8], eax
		mov	esi, ecx
		mov	dword ptr [ebp+var_8+4], eax
		xor	ebx, ebx
		fld	[ebp+var_8]
		fstp	[ebp+var_28]
		cmp	dword ptr [esi+14h], 10h
		mov	dword ptr [ebp+var_10],	eax
		mov	dword ptr [ebp+var_10+4], eax
		fld	[ebp+var_10]
		push	edi
		fstp	[ebp+var_20]
		mov	edi, edx
		mov	[ebp+var_30], ebx
		mov	[ebp+var_18], ebx
		mov	[ebp+var_14], ebx
		jb	short loc_10011332
		mov	esi, [esi]

loc_10011332:				; CODE XREF: sub_100112F7+37j
		mov	ecx, esi
		lea	edx, [ecx+1]

loc_10011337:				; CODE XREF: sub_100112F7+45j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_10011337
		sub	ecx, edx
		lea	eax, [ebp+var_8+4]
		push	ecx
		push	eax
		push	ecx
		push	esi
		lea	ecx, [ebp+var_30]
		call	sub_10014341
		fst	[ebp+var_10]
		mov	eax, dword ptr [ebp+var_10+4]
		mov	ecx, 7FF00000h
		and	eax, ecx
		cmp	ebx, ebx
		jnz	short loc_10011364
		cmp	eax, ecx
		jz	short loc_10011367

loc_10011364:				; CODE XREF: sub_100112F7+67j
		xor	ebx, ebx
		inc	ebx

loc_10011367:				; CODE XREF: sub_100112F7+6Bj
		mov	[edi], bl
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
sub_100112F7	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_10011370(double)
sub_10011370	proc near		; CODE XREF: WebCore::Decimal::fromDouble(double)+3Cp

var_68		= qword	ptr -68h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= byte ptr -48h
var_4		= dword	ptr -4
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 54h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		push	esi
		mov	esi, ecx
		call	?EcmaScriptConverter@DoubleToStringConverter@double_conversion@@SAABV12@XZ ; double_conversion::DoubleToStringConverter::EcmaScriptConverter(void)
		fld	[ebp+arg_0]
		lea	ecx, [ebp+var_48]
		and	[ebp+var_4C], 0
		mov	[ebp+var_54], ecx
		lea	ecx, [ebp+var_54]
		push	0
		push	ecx
		push	ecx
		push	ecx
		mov	ecx, eax
		mov	[ebp+var_50], 40h
		fstp	[esp+68h+var_68]
		call	?ToShortestIeeeNumber@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@W4DtoaMode@12@@Z ; double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)
		mov	edx, [ebp+var_54]
		mov	ecx, [ebp+var_4C]
		push	edx
		mov	byte ptr [edx+ecx], 0
		mov	ecx, esi
		call	sub_1000F9C9
		mov	ecx, [ebp+var_4]
		mov	eax, esi
		xor	ecx, ebp
		pop	esi
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_10011370	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100113D1	proc near		; CODE XREF: sub_1001094B+1Cp

var_A8		= byte ptr -0A8h
var_A4		= byte ptr -0A4h
var_10		= byte ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0ACh
		push	esi
		push	ecx
		mov	esi, ecx
		push	ecx
		lea	ecx, [ebp+var_A8]
		call	sub_1000F947
		push	[ebp+arg_4]
		lea	eax, [ebp+var_10]
		push	[ebp+arg_0]
		push	0
		push	12h
		push	eax
		call	ds:?setprecision@std@@YA?AU?$_Smanip@_J@1@_J@Z ; std::setprecision(__int64)
		add	esp, 0Ch
		lea	ecx, [ebp+var_A8]
		mov	edx, eax
		call	sub_1000F8E8
		mov	ecx, eax
		call	ds:??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char>>::operator<<(__int64)
		push	esi
		lea	ecx, [ebp+var_A4]
		call	sub_10011C58
		lea	ecx, [ebp+var_A8]
		call	sub_10010405
		mov	eax, esi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
sub_100113D1	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10011434	proc near		; CODE XREF: WebCore::Decimal::toString(void)+113p

var_A8		= byte ptr -0A8h
var_A4		= byte ptr -0A4h
var_10		= byte ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0ACh
		push	esi
		push	ecx
		mov	esi, ecx
		push	ecx
		lea	ecx, [ebp+var_A8]
		call	sub_1000F947
		push	[ebp+arg_4]
		lea	eax, [ebp+var_10]
		push	[ebp+arg_0]
		push	0
		push	13h
		push	eax
		call	ds:?setprecision@std@@YA?AU?$_Smanip@_J@1@_J@Z ; std::setprecision(__int64)
		add	esp, 0Ch
		lea	ecx, [ebp+var_A8]
		mov	edx, eax
		call	sub_1000F8E8
		mov	ecx, eax
		call	ds:??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z ; std::basic_ostream<char,std::char_traits<char>>::operator<<(unsigned	__int64)
		push	esi
		lea	ecx, [ebp+var_A4]
		call	sub_10011C58
		lea	ecx, [ebp+var_A8]
		call	sub_10010405
		mov	eax, esi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
sub_10011434	endp

; Exported entry  79. ?nan@Decimal@WebCore@@SA?AV12@XZ

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static class WebCore::Decimal	__cdecl	WebCore::Decimal::nan(void)
		public ?nan@Decimal@WebCore@@SA?AV12@XZ
?nan@Decimal@WebCore@@SA?AV12@XZ proc near
					; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+52p
					; WebCore::Decimal::operator*(WebCore::Decimal const &)+7Ap ...

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= word ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 1Ch
		push	esi
		xor	ecx, ecx
		mov	[ebp+var_10], 2
		push	edi
		xor	eax, eax
		mov	[ebp+var_1C], ecx
		push	6
		mov	[ebp+var_14], ax
		lea	esi, [ebp+var_1C]
		mov	eax, [ebp+arg_0]
		mov	edi, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_C], ecx
		pop	ecx
		rep movsd
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
?nan@Decimal@WebCore@@SA?AV12@XZ endp


; =============== S U B	R O U T	I N E =======================================


sub_100114CA	proc near		; DATA XREF: .rdata:1001643Co

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ecx
		push	edi
		mov	edi, ecx
		test	byte ptr [edi+3Ch], 2
		jz	short loc_100114DC
		or	eax, 0FFFFFFFFh
		jmp	loc_10011690
; ---------------------------------------------------------------------------

loc_100114DC:				; CODE XREF: sub_100114CA+8j
		push	ebx
		mov	ebx, [esp+0Ch+arg_0]
		cmp	ebx, 0FFFFFFFFh
		jnz	short loc_100114ED
		xor	eax, eax
		jmp	loc_1001168F
; ---------------------------------------------------------------------------

loc_100114ED:				; CODE XREF: sub_100114CA+1Aj
		test	byte ptr [edi+3Ch], 8
		jz	short loc_10011527
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		test	eax, eax
		jz	short loc_10011527
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	eax, [edi+38h]
		jnb	short loc_10011527
		mov	ecx, edi
		call	ds:?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		push	eax
		push	dword ptr [edi+38h]
		mov	ecx, edi
		call	ds:?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		push	eax
		mov	ecx, edi
		call	ds:?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)

loc_10011527:				; CODE XREF: sub_100114CA+27j
					; sub_100114CA+31j ...
		push	esi
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		test	eax, eax
		jz	short loc_1001155B
		mov	ecx, edi
		call	ds:?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		mov	ecx, edi
		mov	esi, eax
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	eax, esi
		jnb	short loc_1001155B
		mov	ecx, edi
		call	ds:?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Pninc(void)
		mov	[eax], bl
		mov	eax, ebx
		jmp	loc_1001168E
; ---------------------------------------------------------------------------

loc_1001155B:				; CODE XREF: sub_100114CA+68j
					; sub_100114CA+7Ej
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		test	eax, eax
		jnz	short loc_1001156B
		xor	ebx, ebx
		jmp	short loc_10011581
; ---------------------------------------------------------------------------

loc_1001156B:				; CODE XREF: sub_100114CA+9Bj
		mov	ecx, edi
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, edi
		mov	esi, eax
		call	ds:?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		mov	ebx, eax
		sub	ebx, esi

loc_10011581:				; CODE XREF: sub_100114CA+9Fj
		mov	eax, ebx
		push	20h
		shr	eax, 1
		pop	ecx
		cmp	eax, ecx
		jb	short loc_10011592
		mov	ecx, eax
		test	ecx, ecx
		jz	short loc_100115A5

loc_10011592:				; CODE XREF: sub_100114CA+C0j
					; sub_100114CA+D5j
		mov	eax, 7FFFFFFFh
		sub	eax, ecx
		cmp	eax, ebx
		jnb	short loc_100115A1
		shr	ecx, 1
		jnz	short loc_10011592

loc_100115A1:				; CODE XREF: sub_100114CA+D1j
		test	ecx, ecx
		jnz	short loc_100115AD

loc_100115A5:				; CODE XREF: sub_100114CA+C6j
		or	eax, 0FFFFFFFFh
		jmp	loc_1001168E
; ---------------------------------------------------------------------------

loc_100115AD:				; CODE XREF: sub_100114CA+D9j
		push	ebp
		lea	ebp, [ecx+ebx]
		xor	esi, esi
		test	ebp, ebp
		jz	short loc_100115CF
		cmp	ebp, 0FFFFFFFFh
		ja	short loc_100115C9
		push	ebp
		call	moz_xmalloc
		mov	esi, eax
		pop	ecx
		test	esi, esi
		jnz	short loc_100115CF

loc_100115C9:				; CODE XREF: sub_100114CA+F0j
		call	ds:?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)

loc_100115CF:				; CODE XREF: sub_100114CA+EBj
					; sub_100114CA+FDj
		mov	ecx, edi
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, eax
		mov	[esp+8+arg_4], ecx
		test	ebx, ebx
		jz	short loc_100115F4
		mov	edx, ecx	; void *
		mov	ecx, esi	; void *
		push	ebx		; size_t
		call	sub_10010BC3
		pop	ecx
		mov	ecx, [esp+8+arg_4]
		test	ebx, ebx
		jnz	short loc_10011618

loc_100115F4:				; CODE XREF: sub_100114CA+115j
		lea	eax, [esi+ebp]
		mov	[edi+38h], esi
		push	eax
		push	esi
		mov	ecx, edi
		call	ds:?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *)
		test	byte ptr [edi+3Ch], 4
		mov	ecx, edi
		jz	short loc_10011611

loc_1001160C:				; CODE XREF: sub_100114CA+181j
		push	esi
		push	0
		jmp	short loc_10011662
; ---------------------------------------------------------------------------

loc_10011611:				; CODE XREF: sub_100114CA+140j
		lea	eax, [esi+1]
		push	eax
		push	esi
		jmp	short loc_10011662
; ---------------------------------------------------------------------------

loc_10011618:				; CODE XREF: sub_100114CA+128j
		mov	eax, esi
		mov	ebx, esi
		sub	eax, ecx
		sub	ebx, ecx
		add	[edi+38h], eax
		mov	ecx, edi
		lea	eax, [esi+ebp]
		push	eax
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		add	eax, ebx
		mov	ecx, edi
		push	eax
		call	ds:?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		add	eax, ebx
		mov	ecx, edi
		push	eax
		call	ds:?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		test	byte ptr [edi+3Ch], 4
		mov	ecx, edi
		jnz	short loc_1001160C
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		inc	eax
		mov	ecx, edi
		push	eax
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		add	eax, ebx
		mov	ecx, edi
		push	eax

loc_10011662:				; CODE XREF: sub_100114CA+145j
					; sub_100114CA+14Cj
		push	esi
		call	ds:?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		test	byte ptr [edi+3Ch], 1
		jz	short loc_10011679
		push	[esp+14h+var_4]	; void *
		call	free
		pop	ecx

loc_10011679:				; CODE XREF: sub_100114CA+1A3j
		or	dword ptr [edi+3Ch], 1
		mov	ecx, edi
		call	ds:?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Pninc(void)
		mov	ecx, [esp+14h+arg_0]
		pop	ebp
		mov	[eax], cl
		mov	eax, ecx

loc_1001168E:				; CODE XREF: sub_100114CA+8Cj
					; sub_100114CA+DEj
		pop	esi

loc_1001168F:				; CODE XREF: sub_100114CA+1Ej
		pop	ebx

loc_10011690:				; CODE XREF: sub_100114CA+Dj
		pop	edi
		pop	ecx
		retn	4
sub_100114CA	endp


; =============== S U B	R O U T	I N E =======================================


sub_10011695	proc near		; DATA XREF: .rdata:10016440o

arg_0		= dword	ptr  4

		push	ebx
		push	edi
		mov	edi, ecx
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		test	eax, eax
		jz	short loc_100116F8
		push	esi
		mov	ecx, edi
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, edi
		mov	esi, eax
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	eax, esi
		pop	esi
		jbe	short loc_100116F8
		mov	ebx, [esp+8+arg_0]
		cmp	ebx, 0FFFFFFFFh
		jz	short loc_100116D7
		mov	ecx, edi
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	bl, [eax-1]
		jz	short loc_100116D7
		test	byte ptr [edi+3Ch], 2
		jnz	short loc_100116F8

loc_100116D7:				; CODE XREF: sub_10011695+2Dj
					; sub_10011695+3Aj
		push	0FFFFFFFFh
		mov	ecx, edi
		call	ds:?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::gbump(int)
		cmp	ebx, 0FFFFFFFFh
		jz	short loc_100116F2
		mov	ecx, edi
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		mov	[eax], bl
		jmp	short loc_100116F4
; ---------------------------------------------------------------------------

loc_100116F2:				; CODE XREF: sub_10011695+4Fj
		xor	ebx, ebx

loc_100116F4:				; CODE XREF: sub_10011695+5Bj
		mov	eax, ebx
		jmp	short loc_100116FB
; ---------------------------------------------------------------------------

loc_100116F8:				; CODE XREF: sub_10011695+Cj
					; sub_10011695+24j ...
		or	eax, 0FFFFFFFFh

loc_100116FB:				; CODE XREF: sub_10011695+61j
		pop	edi
		pop	ebx
		retn	4
sub_10011695	endp

; Exported entry  80. ?remainder@Decimal@WebCore@@QBE?AV12@ABV12@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	WebCore::Decimal __thiscall WebCore::Decimal::remainder(class WebCore::Decimal const &)const
		public ?remainder@Decimal@WebCore@@QBE?AV12@ABV12@@Z
?remainder@Decimal@WebCore@@QBE?AV12@ABV12@@Z proc near	; DATA XREF: .rdata:off_100175A8o

var_78		= byte ptr -78h
var_68		= dword	ptr -68h
var_60		= byte ptr -60h
var_48		= byte ptr -48h
var_30		= byte ptr -30h
var_18		= byte ptr -18h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 78h
		lea	eax, [esp+78h+var_78]
		push	esi
		push	edi
		push	[ebp+arg_4]
		mov	esi, ecx
		push	eax
		call	??KDecimal@WebCore@@QBE?AV01@ABV01@@Z ;	WebCore::Decimal::operator/(WebCore::Decimal const &)
		lea	ecx, [esp+80h+var_78]
		call	sub_1001123D
		test	al, al
		jz	short loc_10011739
		push	6
		pop	ecx
		lea	esi, [esp+80h+var_78]
		lea	edi, [esp+80h+var_60]
		rep movsd
		lea	eax, [esp+80h+var_60]
		jmp	short loc_10011776
; ---------------------------------------------------------------------------

loc_10011739:				; CODE XREF: WebCore::Decimal::remainder(WebCore::Decimal const	&)+24j
		cmp	[esp+80h+var_68], 1
		lea	ecx, [esp+80h+var_78]
		jnz	short loc_10011750
		lea	eax, [esp+80h+var_60]
		push	eax
		call	?ceiling@Decimal@WebCore@@QBE?AV12@XZ ;	WebCore::Decimal::ceiling(void)
		jmp	short loc_1001175A
; ---------------------------------------------------------------------------

loc_10011750:				; CODE XREF: WebCore::Decimal::remainder(WebCore::Decimal const	&)+42j
		lea	eax, [esp+80h+var_48]
		push	eax
		call	?floor@Decimal@WebCore@@QBE?AV12@XZ ; WebCore::Decimal::floor(void)

loc_1001175A:				; CODE XREF: WebCore::Decimal::remainder(WebCore::Decimal const	&)+4Ej
		push	[ebp+arg_4]
		lea	ecx, [esp+84h+var_30]
		push	ecx
		mov	ecx, eax
		call	??DDecimal@WebCore@@QBE?AV01@ABV01@@Z ;	WebCore::Decimal::operator*(WebCore::Decimal const &)
		push	eax
		lea	eax, [esp+84h+var_18]
		mov	ecx, esi
		push	eax
		call	??GDecimal@WebCore@@QBE?AV01@ABV01@@Z ;	WebCore::Decimal::operator-(WebCore::Decimal const &)

loc_10011776:				; CODE XREF: WebCore::Decimal::remainder(WebCore::Decimal const	&)+37j
		push	6
		mov	esi, eax
		mov	eax, [ebp+arg_0]
		pop	ecx
		mov	edi, eax
		rep movsd
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn	8
?remainder@Decimal@WebCore@@QBE?AV12@ABV12@@Z endp

; Exported entry  81. ?round@Decimal@WebCore@@QBE?AV12@XZ

; =============== S U B	R O U T	I N E =======================================


; public: class	WebCore::Decimal __thiscall WebCore::Decimal::round(void)const
		public ?round@Decimal@WebCore@@QBE?AV12@XZ
?round@Decimal@WebCore@@QBE?AV12@XZ proc near ;	DATA XREF: .rdata:off_100175A8o

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	esi, ecx
		call	sub_1001123D
		test	al, al
		jz	short loc_100117A4

loc_10011797:				; CODE XREF: WebCore::Decimal::round(void)+21j
		mov	eax, [esp+8+arg_0]
		mov	edi, eax
		push	6
		pop	ecx
		rep movsd
		jmp	short loc_1001181F
; ---------------------------------------------------------------------------

loc_100117A4:				; CODE XREF: WebCore::Decimal::round(void)+Bj
		movzx	eax, word ptr [esi+8]
		test	ax, ax
		jns	short loc_10011797
		push	dword ptr [esi+4]
		movsx	edi, ax
		push	dword ptr [esi]
		neg	edi
		call	sub_10010BDD
		pop	ecx
		pop	ecx
		cmp	eax, edi
		jge	short loc_100117D1
		push	0
		push	[esp+0Ch+arg_0]
		call	?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z ; WebCore::Decimal::zero(WebCore::Decimal::Sign)
		pop	ecx
		pop	ecx
		jmp	short loc_1001181B
; ---------------------------------------------------------------------------

loc_100117D1:				; CODE XREF: WebCore::Decimal::round(void)+36j
		push	ebx
		push	ebp
		push	dword ptr [esi+4]
		lea	ecx, [edi-1]
		push	dword ptr [esi]
		call	sub_10011824
		pop	ecx
		pop	ecx
		xor	ebp, ebp
		mov	ebx, edx
		push	ebp
		push	0Ah
		mov	edi, eax
		push	ebx
		push	edi
		call	__aullrem
		cmp	edx, ebp
		ja	short loc_100117FB
		cmp	eax, 5
		jb	short loc_10011800

loc_100117FB:				; CODE XREF: WebCore::Decimal::round(void)+6Aj
		add	edi, 0Ah
		adc	ebx, ebp

loc_10011800:				; CODE XREF: WebCore::Decimal::round(void)+6Fj
		push	ebp
		push	0Ah
		push	ebx
		push	edi
		call	__aulldiv
		mov	ecx, [esp+10h+arg_0]
		push	edx
		push	eax
		push	ebp
		push	dword ptr [esi+10h]
		call	??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z	; WebCore::Decimal::Decimal(WebCore::Decimal::Sign,int,unsigned	__int64)
		pop	ebp
		pop	ebx

loc_1001181B:				; CODE XREF: WebCore::Decimal::round(void)+45j
		mov	eax, [esp+8+arg_0]

loc_1001181F:				; CODE XREF: WebCore::Decimal::round(void)+18j
		pop	edi
		pop	esi
		retn	4
?round@Decimal@WebCore@@QBE?AV12@XZ endp


; =============== S U B	R O U T	I N E =======================================


sub_10011824	proc near		; CODE XREF: WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+ABp
					; WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+111p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	edi, ecx

loc_10011830:				; CODE XREF: sub_10011824+24j
		test	edi, edi
		jle	short loc_1001184A
		mov	eax, esi
		or	eax, edx
		jz	short loc_1001184A
		push	0
		push	0Ah
		push	edx
		push	esi
		call	__aulldiv
		mov	esi, eax
		dec	edi
		jmp	short loc_10011830
; ---------------------------------------------------------------------------

loc_1001184A:				; CODE XREF: sub_10011824+Ej
					; sub_10011824+14j
		pop	edi
		mov	eax, esi
		pop	esi
		retn
sub_10011824	endp


; =============== S U B	R O U T	I N E =======================================


sub_1001184F	proc near		; CODE XREF: WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+63p
					; WebCore::Decimal::alignOperands(WebCore::Decimal const &,WebCore::Decimal const &)+97p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ecx
		push	ebx
		push	ebp
		push	esi
		xor	eax, eax
		mov	ebx, ecx
		push	edi
		inc	eax
		xor	esi, esi
		push	0Ah
		mov	[esp+18h+var_4], eax
		mov	ebp, esi
		pop	edi

loc_10011864:				; CODE XREF: sub_1001184F+3Ej
		test	bl, 1
		jz	short loc_10011878
		push	esi
		push	eax
		push	ebp
		push	edi
		call	__allmul
		mov	[esp+14h+var_4], eax
		mov	esi, edx

loc_10011878:				; CODE XREF: sub_1001184F+18j
		sar	ebx, 1
		jz	short loc_1001188F
		push	ebp
		push	edi
		push	ebp
		push	edi
		call	__allmul
		mov	edi, eax
		mov	ebp, edx
		mov	eax, [esp+14h+var_4]
		jmp	short loc_10011864
; ---------------------------------------------------------------------------

loc_1001188F:				; CODE XREF: sub_1001184F+2Bj
		push	[esp+14h+arg_4]
		push	[esp+18h+arg_0]
		push	esi
		push	eax
		call	__allmul
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
sub_1001184F	endp


; =============== S U B	R O U T	I N E =======================================


sub_100118A4	proc near		; DATA XREF: .rdata:10016458o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= byte ptr  14h

		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	ebx, ecx
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		test	eax, eax
		jz	short loc_100118CC
		mov	ecx, ebx
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	[ebx+38h], eax
		jnb	short loc_100118CC
		mov	ecx, ebx
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		mov	[ebx+38h], eax

loc_100118CC:				; CODE XREF: sub_100118A4+Ej
					; sub_100118A4+1Bj
		test	[esp+10h+arg_10], 1
		jz	loc_100119E0
		mov	ecx, ebx
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		test	eax, eax
		jz	loc_100119E0
		mov	eax, [esp+10h+arg_C]
		cmp	eax, 2
		jnz	short loc_10011901
		mov	ecx, ebx
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, [ebx+38h]
		sub	ecx, eax
		mov	eax, ecx
		jmp	short loc_10011921
; ---------------------------------------------------------------------------

loc_10011901:				; CODE XREF: sub_100118A4+4Aj
		cmp	eax, 1
		jnz	short loc_10011930
		test	[esp+10h+arg_10], 2
		jnz	short loc_10011934
		mov	ecx, ebx
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, ebx
		mov	esi, eax
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		sub	eax, esi

loc_10011921:				; CODE XREF: sub_100118A4+5Bj
		mov	edi, [esp+10h+arg_4]
		mov	ebp, [esp+10h+arg_8]
		cdq
		add	edi, eax
		adc	ebp, edx
		jmp	short loc_1001194A
; ---------------------------------------------------------------------------

loc_10011930:				; CODE XREF: sub_100118A4+60j
		test	eax, eax
		jz	short loc_10011942

loc_10011934:				; CODE XREF: sub_100118A4+67j
		mov	ebp, ds:?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	edi, [ebp+0]
		mov	ebp, [ebp+4]
		jmp	short loc_1001194A
; ---------------------------------------------------------------------------

loc_10011942:				; CODE XREF: sub_100118A4+8Ej
		mov	ebp, [esp+10h+arg_8]
		mov	edi, [esp+10h+arg_4]

loc_1001194A:				; CODE XREF: sub_100118A4+8Aj
					; sub_100118A4+9Cj
		test	ebp, ebp
		jl	loc_10011A9C
		jg	short loc_1001195C
		test	edi, edi
		jb	loc_10011A9C

loc_1001195C:				; CODE XREF: sub_100118A4+AEj
		mov	ecx, ebx
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, [ebx+38h]
		sub	ecx, eax
		mov	eax, ecx
		cdq
		cmp	ebp, edx
		jg	loc_10011A9C
		jl	short loc_1001197E
		cmp	edi, eax
		ja	loc_10011A9C

loc_1001197E:				; CODE XREF: sub_100118A4+D0j
		mov	ecx, ebx
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		mov	esi, edi
		mov	ecx, ebx
		sub	esi, eax
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		add	eax, esi
		mov	ecx, ebx
		push	eax
		call	ds:?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::gbump(int)
		test	[esp+10h+arg_10], 2
		jz	loc_10011AC2
		mov	ecx, ebx
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		test	eax, eax
		jz	loc_10011AC2
		mov	ecx, ebx
		call	ds:?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		push	eax
		mov	ecx, ebx
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		push	eax
		mov	ecx, ebx
		call	ds:?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		push	eax
		mov	ecx, ebx
		call	ds:?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		jmp	loc_10011AC2
; ---------------------------------------------------------------------------

loc_100119E0:				; CODE XREF: sub_100118A4+2Dj
					; sub_100118A4+3Dj
		test	[esp+10h+arg_10], 2
		jz	loc_10011AAA
		mov	ecx, ebx
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		test	eax, eax
		jz	loc_10011AAA
		mov	eax, [esp+10h+arg_C]
		cmp	eax, 2
		jnz	short loc_10011A15
		mov	ecx, ebx
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, [ebx+38h]
		sub	ecx, eax
		mov	eax, ecx
		jmp	short loc_10011A2E
; ---------------------------------------------------------------------------

loc_10011A15:				; CODE XREF: sub_100118A4+15Ej
		cmp	eax, 1
		jnz	short loc_10011A3D
		mov	ecx, ebx
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, ebx
		mov	esi, eax
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		sub	eax, esi

loc_10011A2E:				; CODE XREF: sub_100118A4+16Fj
		mov	edi, [esp+10h+arg_4]
		mov	ebp, [esp+10h+arg_8]
		cdq
		add	edi, eax
		adc	ebp, edx
		jmp	short loc_10011A57
; ---------------------------------------------------------------------------

loc_10011A3D:				; CODE XREF: sub_100118A4+174j
		test	eax, eax
		jz	short loc_10011A4F
		mov	ebp, ds:?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	edi, [ebp+0]
		mov	ebp, [ebp+4]
		jmp	short loc_10011A57
; ---------------------------------------------------------------------------

loc_10011A4F:				; CODE XREF: sub_100118A4+19Bj
		mov	ebp, [esp+10h+arg_8]
		mov	edi, [esp+10h+arg_4]

loc_10011A57:				; CODE XREF: sub_100118A4+197j
					; sub_100118A4+1A9j
		test	ebp, ebp
		jl	short loc_10011A9C
		jg	short loc_10011A61
		test	edi, edi
		jb	short loc_10011A9C

loc_10011A61:				; CODE XREF: sub_100118A4+1B7j
		mov	ecx, ebx
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, [ebx+38h]
		sub	ecx, eax
		mov	eax, ecx
		cdq
		cmp	ebp, edx
		jg	short loc_10011A9C
		jl	short loc_10011A7B
		cmp	edi, eax
		ja	short loc_10011A9C

loc_10011A7B:				; CODE XREF: sub_100118A4+1D1j
		mov	ecx, ebx
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		mov	esi, edi
		mov	ecx, ebx
		sub	esi, eax
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		add	eax, esi
		mov	ecx, ebx
		push	eax
		call	ds:?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::pbump(int)
		jmp	short loc_10011AC2
; ---------------------------------------------------------------------------

loc_10011A9C:				; CODE XREF: sub_100118A4+A8j
					; sub_100118A4+B2j ...
		mov	ebp, ds:?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	edi, [ebp+0]
		mov	ebp, [ebp+4]
		jmp	short loc_10011AC2
; ---------------------------------------------------------------------------

loc_10011AAA:				; CODE XREF: sub_100118A4+141j
					; sub_100118A4+151j
		mov	edi, [esp+10h+arg_4]
		mov	eax, edi
		mov	ebp, [esp+10h+arg_8]
		or	eax, ebp
		jz	short loc_10011AC2
		mov	eax, ds:?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	edi, [eax]
		mov	ebp, [eax+4]

loc_10011AC2:				; CODE XREF: sub_100118A4+FEj
					; sub_100118A4+10Ej ...
		mov	eax, [esp+10h+arg_0]
		xor	ecx, ecx
		mov	[eax], edi
		pop	edi
		pop	esi
		mov	[eax+4], ebp
		pop	ebp
		mov	[eax+8], ecx
		mov	[eax+0Ch], ecx
		mov	[eax+10h], ecx
		pop	ebx
		retn	14h
sub_100118A4	endp


; =============== S U B	R O U T	I N E =======================================


sub_10011ADD	proc near		; DATA XREF: .rdata:1001645Co

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_1C		= byte ptr  20h

		push	ebx
		mov	ebx, [esp+4+arg_C]
		add	ebx, [esp+4+arg_4]
		push	ebp
		mov	ebp, [esp+8+arg_10]
		adc	ebp, [esp+8+arg_8]
		push	edi
		mov	edi, ecx
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		test	eax, eax
		jz	short loc_10011B14
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	[edi+38h], eax
		jnb	short loc_10011B14
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		mov	[edi+38h], eax

loc_10011B14:				; CODE XREF: sub_10011ADD+1Dj
					; sub_10011ADD+2Aj
		mov	eax, ds:?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		cmp	ebx, [eax]
		jnz	short loc_10011B26
		cmp	ebp, [eax+4]
		jz	loc_10011C3D

loc_10011B26:				; CODE XREF: sub_10011ADD+3Ej
		test	[esp+0Ch+arg_1C], 1
		push	esi
		jz	loc_10011BDA
		mov	ecx, edi
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		test	eax, eax
		jz	loc_10011BD5
		test	ebp, ebp
		jl	loc_10011C32
		jg	short loc_10011B54
		test	ebx, ebx
		jb	loc_10011C32

loc_10011B54:				; CODE XREF: sub_10011ADD+6Dj
		mov	ecx, edi
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, [edi+38h]
		sub	ecx, eax
		mov	eax, ecx
		cdq
		cmp	ebp, edx
		jg	loc_10011C32
		jl	short loc_10011B76
		cmp	ebx, eax
		ja	loc_10011C32

loc_10011B76:				; CODE XREF: sub_10011ADD+8Fj
		mov	ecx, edi
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		mov	esi, ebx
		mov	ecx, edi
		sub	esi, eax
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		add	eax, esi
		mov	ecx, edi
		push	eax
		call	ds:?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::gbump(int)
		test	[esp+10h+arg_1C], 2
		jz	loc_10011C3C
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		test	eax, eax
		jz	loc_10011C3C
		mov	ecx, edi
		call	ds:?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		push	eax
		mov	ecx, edi
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		push	eax
		mov	ecx, edi
		call	ds:?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		push	eax
		mov	ecx, edi
		call	ds:?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		jmp	short loc_10011C3C
; ---------------------------------------------------------------------------

loc_10011BD5:				; CODE XREF: sub_10011ADD+5Fj
		mov	eax, ds:?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF

loc_10011BDA:				; CODE XREF: sub_10011ADD+4Fj
		test	[esp+10h+arg_1C], 2
		jz	short loc_10011C37
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		test	eax, eax
		jz	short loc_10011C32
		test	ebp, ebp
		jl	short loc_10011C32
		jg	short loc_10011BF7
		test	ebx, ebx
		jb	short loc_10011C32

loc_10011BF7:				; CODE XREF: sub_10011ADD+114j
		mov	ecx, edi
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, [edi+38h]
		sub	ecx, eax
		mov	eax, ecx
		cdq
		cmp	ebp, edx
		jg	short loc_10011C32
		jl	short loc_10011C11
		cmp	ebx, eax
		ja	short loc_10011C32

loc_10011C11:				; CODE XREF: sub_10011ADD+12Ej
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		mov	esi, ebx
		mov	ecx, edi
		sub	esi, eax
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		add	eax, esi
		mov	ecx, edi
		push	eax
		call	ds:?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::pbump(int)
		jmp	short loc_10011C3C
; ---------------------------------------------------------------------------

loc_10011C32:				; CODE XREF: sub_10011ADD+67j
					; sub_10011ADD+71j ...
		mov	eax, ds:?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF

loc_10011C37:				; CODE XREF: sub_10011ADD+102j
		mov	ebx, [eax]
		mov	ebp, [eax+4]

loc_10011C3C:				; CODE XREF: sub_10011ADD+BDj
					; sub_10011ADD+CDj ...
		pop	esi

loc_10011C3D:				; CODE XREF: sub_10011ADD+43j
		mov	eax, [esp+0Ch+arg_0]
		pop	edi
		and	dword ptr [eax+8], 0
		and	dword ptr [eax+0Ch], 0
		and	dword ptr [eax+10h], 0
		mov	[eax+4], ebp
		pop	ebp
		mov	[eax], ebx
		pop	ebx
		retn	20h
sub_10011ADD	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10011C58	proc near		; CODE XREF: sub_100113D1+4Cp
					; sub_10011434+4Cp

var_20		= byte ptr -20h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 20h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_8], eax
		push	ebx
		mov	ebx, [ebp+arg_0]
		push	esi
		push	edi
		mov	edi, ecx
		test	byte ptr [edi+3Ch], 2
		jnz	short loc_10011CB7
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		test	eax, eax
		jz	short loc_10011CB7
		mov	esi, [edi+38h]
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, eax
		jnb	short loc_10011C99
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		mov	esi, eax

loc_10011C99:				; CODE XREF: sub_10011C58+35j
		mov	ecx, edi
		call	ds:?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		sub	esi, eax
		mov	ecx, edi
		push	esi
		call	ds:?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)

loc_10011CAC:				; CODE XREF: sub_10011C58+8Ej
		push	eax
		lea	ecx, [ebp+var_20]
		call	sub_1000F9F5
		jmp	short loc_10011CF7
; ---------------------------------------------------------------------------

loc_10011CB7:				; CODE XREF: sub_10011C58+1Cj
					; sub_10011C58+26j
		test	byte ptr [edi+3Ch], 4
		jnz	short loc_10011CE8
		mov	ecx, edi
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		test	eax, eax
		jz	short loc_10011CE8
		mov	ecx, edi
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		mov	ecx, edi
		mov	esi, eax
		call	ds:?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::egptr(void)
		sub	eax, esi
		mov	ecx, edi
		push	eax
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		jmp	short loc_10011CAC
; ---------------------------------------------------------------------------

loc_10011CE8:				; CODE XREF: sub_10011C58+63j
					; sub_10011C58+6Fj
		and	[ebp+var_10], 0
		mov	[ebp+var_C], 0Fh
		mov	[ebp+var_20], 0

loc_10011CF7:				; CODE XREF: sub_10011C58+5Dj
		lea	eax, [ebp+var_20]
		mov	ecx, ebx
		push	eax		; void *
		call	sub_1000F9A9
		push	0		; size_t
		push	1		; char
		lea	ecx, [ebp+var_20]
		call	sub_100105E7
		mov	ecx, [ebp+var_8]
		mov	eax, ebx
		pop	edi
		pop	esi
		xor	ecx, ebp
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn	4
sub_10011C58	endp

; Exported entry  89. ?toDouble@Decimal@WebCore@@QBENXZ

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall WebCore::Decimal::toDouble(WebCore::Decimal	*__hidden this)
		public ?toDouble@Decimal@WebCore@@QBENXZ
?toDouble@Decimal@WebCore@@QBENXZ proc near ; DATA XREF: .rdata:off_100175A8o

var_29		= byte ptr -29h
var_28		= qword	ptr -28h
var_1C		= byte ptr -1Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 2Ch
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+2Ch+var_4], eax
		push	esi
		mov	esi, ecx
		call	sub_1001123D
		test	al, al
		jnz	short loc_10011D78
		lea	eax, [esp+30h+var_1C]
		mov	ecx, esi
		push	eax		; void *
		call	?toString@Decimal@WebCore@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; WebCore::Decimal::toString(void)
		lea	edx, [esp+30h+var_29]
		mov	ecx, eax
		call	sub_100112F7
		push	0		; size_t
		push	1		; char
		lea	ecx, [esp+38h+var_1C]
		fstp	[esp+38h+var_28]
		call	sub_100105E7
		cmp	[esp+30h+var_29], 0
		jz	short loc_10011D8F
		fld	[esp+30h+var_28]
		jmp	short loc_10011D96
; ---------------------------------------------------------------------------

loc_10011D78:				; CODE XREF: WebCore::Decimal::toDouble(void)+1Ej
		cmp	dword ptr [esi+0Ch], 0
		jnz	short loc_10011D8F
		cmp	dword ptr [esi+10h], 1
		mov	eax, ds:_Inf
		fld	qword ptr [eax]
		jnz	short loc_10011D96
		fchs
		jmp	short loc_10011D96
; ---------------------------------------------------------------------------

loc_10011D8F:				; CODE XREF: WebCore::Decimal::toDouble(void)+4Dj
					; WebCore::Decimal::toDouble(void)+59j
		mov	eax, ds:_Nan
		fld	qword ptr [eax]

loc_10011D96:				; CODE XREF: WebCore::Decimal::toDouble(void)+53j
					; WebCore::Decimal::toDouble(void)+66j	...
		mov	ecx, [esp+30h+var_4]
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
?toDouble@Decimal@WebCore@@QBENXZ endp

; Exported entry  90. ?toString@Decimal@WebCore@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	WebCore::Decimal::toString(void	*)
		public ?toString@Decimal@WebCore@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
?toString@Decimal@WebCore@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ proc near
					; CODE XREF: WebCore::Decimal::toDouble(void)+27p
					; WebCore::Decimal::toString(char *,uint)+22p
					; DATA XREF: ...

var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 64h
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+64h+var_4], eax
		push	ebx
		push	esi
		mov	esi, [ebp+arg_0]
		push	edi
		mov	edi, ecx
		mov	[esp+70h+var_54], esi
		xor	ecx, ecx
		mov	eax, [edi+0Ch]
		sub	eax, ecx
		jz	loc_100120B4
		dec	eax
		jz	short loc_10011DF0
		dec	eax
		jz	short loc_10011DE6
		dec	eax
		jz	short loc_10011DF0
		push	offset byte_1001680D
		jmp	loc_100120C4
; ---------------------------------------------------------------------------

loc_10011DE6:				; CODE XREF: WebCore::Decimal::toString(void)+31j
		push	offset aNan	; "NaN"
		jmp	loc_100120C4
; ---------------------------------------------------------------------------

loc_10011DF0:				; CODE XREF: WebCore::Decimal::toString(void)+2Ej
					; WebCore::Decimal::toString(void)+34j
		mov	[esp+70h+var_38], 0Fh
		mov	[esp+70h+var_3C], ecx
		mov	byte ptr [esp+70h+var_4C], cl
		cmp	[edi+10h], ecx
		jz	short loc_10011E13
		push	2Dh
		push	ecx
		lea	ecx, [esp+78h+var_4C]
		call	sub_10010868
		xor	ecx, ecx

loc_10011E13:				; CODE XREF: WebCore::Decimal::toString(void)+5Dj
		movsx	eax, word ptr [edi+8]
		mov	ebx, [edi]
		mov	edi, [edi+4]
		mov	[esp+70h+var_60], eax
		test	eax, eax
		jns	loc_10011EB3
		mov	[esp+70h+var_50], ecx
		mov	esi, eax

loc_10011E2E:				; CODE XREF: WebCore::Decimal::toString(void)+AEj
		push	edi
		push	ebx
		mov	[esp+78h+var_5C], ecx
		call	sub_10010BDD
		pop	ecx
		pop	ecx
		cmp	eax, 0Fh
		jle	short loc_10011E56
		push	0
		push	0Ah
		push	edi
		push	ebx
		call	__aulldvrm
		mov	[esp+70h+var_50], ebx
		mov	edi, edx
		mov	ebx, eax
		inc	esi
		jmp	short loc_10011E2E
; ---------------------------------------------------------------------------

loc_10011E56:				; CODE XREF: WebCore::Decimal::toString(void)+98j
		cmp	[esp+70h+var_50], 0
		mov	[esp+70h+var_60], esi
		mov	esi, [esp+70h+var_54]
		mov	[esp+70h+var_58], ebx
		ja	short loc_10011E70
		cmp	[esp+70h+var_5C], 5
		jb	short loc_10011E7A

loc_10011E70:				; CODE XREF: WebCore::Decimal::toString(void)+C1j
		add	ebx, 1
		mov	[esp+70h+var_58], ebx
		adc	edi, 0

loc_10011E7A:				; CODE XREF: WebCore::Decimal::toString(void)+C8j
		cmp	[esp+70h+var_60], 0
		jge	short loc_10011EB3
		mov	esi, [esp+70h+var_60]

loc_10011E85:				; CODE XREF: WebCore::Decimal::toString(void)+101j
		mov	eax, ebx
		or	eax, edi
		jz	short loc_10011EAF
		push	0
		push	0Ah
		push	edi
		push	ebx
		call	__aulldvrm
		or	ecx, ebx
		jnz	short loc_10011EAB
		mov	ebx, eax
		inc	esi
		mov	[esp+70h+var_58], ebx
		mov	edi, edx
		mov	[esp+70h+var_60], esi
		js	short loc_10011E85
		jmp	short loc_10011EAF
; ---------------------------------------------------------------------------

loc_10011EAB:				; CODE XREF: WebCore::Decimal::toString(void)+F2j
		mov	ebx, [esp+70h+var_58]

loc_10011EAF:				; CODE XREF: WebCore::Decimal::toString(void)+E3j
					; WebCore::Decimal::toString(void)+103j
		mov	esi, [esp+70h+var_54]

loc_10011EB3:				; CODE XREF: WebCore::Decimal::toString(void)+7Cj
					; WebCore::Decimal::toString(void)+D9j
		push	edi
		push	ebx
		lea	ecx, [esp+78h+var_34]
		call	sub_10011434
		mov	eax, [esp+78h+var_60]
		mov	edi, [esp+78h+var_24]
		pop	ecx
		pop	ecx
		lea	ebx, [eax-1]
		add	ebx, edi
		test	eax, eax
		jg	loc_10011FC0
		cmp	ebx, 0FFFFFFFAh
		jl	loc_10011FC0
		test	eax, eax
		jnz	short loc_10011F2D
		push	0FFFFFFFFh	; size_t
		xor	ebx, ebx
		lea	eax, [esp+74h+var_34]
		push	ebx		; int
		push	eax		; int
		lea	ecx, [esp+7Ch+var_4C]
		call	sub_100107D6

loc_10011EF5:				; CODE XREF: WebCore::Decimal::toString(void)+1D1j
		push	0FFFFFFFFh	; int
		push	ebx		; int
		lea	eax, [esp+78h+var_4C]
		mov	dword ptr [esi+14h], 0Fh
		mov	[esi+10h], ebx
		mov	ecx, esi	; void *
		push	eax		; int
		mov	[esi], bl
		call	sub_10010997
		push	ebx		; size_t
		push	1		; char
		lea	ecx, [esp+78h+var_34]
		call	sub_100105E7
		push	ebx		; size_t

loc_10011F1D:				; CODE XREF: WebCore::Decimal::toString(void)+309j
		push	1		; char
		lea	ecx, [esp+78h+var_4C]
		call	sub_100105E7
		jmp	loc_100120CB
; ---------------------------------------------------------------------------

loc_10011F2D:				; CODE XREF: WebCore::Decimal::toString(void)+13Aj
		test	ebx, ebx
		js	short loc_10011F7C
		and	[esp+70h+var_5C], 0
		test	edi, edi
		jle	short loc_10011F75
		mov	esi, [esp+70h+var_5C]

loc_10011F3E:				; CODE XREF: WebCore::Decimal::toString(void)+1C9j
		cmp	[esp+70h+var_20], 10h
		mov	eax, [esp+70h+var_34]
		jnb	short loc_10011F4D
		lea	eax, [esp+70h+var_34]

loc_10011F4D:				; CODE XREF: WebCore::Decimal::toString(void)+1A1j
		movzx	eax, byte ptr [eax+esi]
		push	eax
		push	ecx
		lea	ecx, [esp+78h+var_4C]
		call	sub_10010868
		cmp	esi, ebx
		jnz	short loc_10011F6C
		push	2Eh
		push	ecx
		lea	ecx, [esp+78h+var_4C]
		call	sub_10010868

loc_10011F6C:				; CODE XREF: WebCore::Decimal::toString(void)+1B8j
		inc	esi
		cmp	esi, edi
		jl	short loc_10011F3E
		mov	esi, [esp+70h+var_54]

loc_10011F75:				; CODE XREF: WebCore::Decimal::toString(void)+192j
		xor	ebx, ebx
		jmp	loc_10011EF5
; ---------------------------------------------------------------------------

loc_10011F7C:				; CODE XREF: WebCore::Decimal::toString(void)+189j
		mov	ecx, offset a0_	; "0."
		call	sub_10011250
		push	eax		; size_t
		push	ecx		; int
		lea	ecx, [esp+78h+var_4C] ;	int
		call	sub_100108BA
		lea	edi, [ebx+1]
		test	edi, edi
		jns	short loc_10011FA9
		neg	edi

loc_10011F9A:				; CODE XREF: WebCore::Decimal::toString(void)+201j
		push	30h
		push	ecx
		lea	ecx, [esp+78h+var_4C]
		call	sub_10010868
		dec	edi
		jnz	short loc_10011F9A

loc_10011FA9:				; CODE XREF: WebCore::Decimal::toString(void)+1F0j
		push	0FFFFFFFFh	; size_t
		push	0		; int
		lea	eax, [esp+78h+var_34]
		push	eax		; int
		lea	ecx, [esp+7Ch+var_4C]
		call	sub_100107D6
		jmp	loc_10012082
; ---------------------------------------------------------------------------

loc_10011FC0:				; CODE XREF: WebCore::Decimal::toString(void)+129j
					; WebCore::Decimal::toString(void)+132j
		cmp	[esp+70h+var_20], 10h
		mov	eax, [esp+70h+var_34]
		jnb	short loc_10011FCF
		lea	eax, [esp+70h+var_34]

loc_10011FCF:				; CODE XREF: WebCore::Decimal::toString(void)+223j
		movzx	eax, byte ptr [eax]
		push	eax
		push	ecx
		lea	ecx, [esp+78h+var_4C]
		call	sub_10010868
		cmp	edi, 2
		jl	short loc_1001203F

loc_10011FE2:				; CODE XREF: WebCore::Decimal::toString(void)+256j
		cmp	[esp+70h+var_20], 10h
		mov	eax, [esp+70h+var_34]
		jnb	short loc_10011FF1
		lea	eax, [esp+70h+var_34]

loc_10011FF1:				; CODE XREF: WebCore::Decimal::toString(void)+245j
		cmp	byte ptr [eax+edi-1], 30h
		jnz	short loc_10011FFE
		dec	edi
		cmp	edi, 2
		jge	short loc_10011FE2

loc_10011FFE:				; CODE XREF: WebCore::Decimal::toString(void)+250j
		cmp	edi, 2
		jl	short loc_1001203F
		push	2Eh
		push	ecx
		lea	ecx, [esp+78h+var_4C]
		call	sub_10010868
		xor	eax, eax
		inc	eax
		cmp	edi, eax
		jle	short loc_1001203F
		mov	esi, eax

loc_10012018:				; CODE XREF: WebCore::Decimal::toString(void)+293j
		cmp	[esp+70h+var_20], 10h
		mov	eax, [esp+70h+var_34]
		jnb	short loc_10012027
		lea	eax, [esp+70h+var_34]

loc_10012027:				; CODE XREF: WebCore::Decimal::toString(void)+27Bj
		movzx	eax, byte ptr [eax+esi]
		push	eax
		push	ecx
		lea	ecx, [esp+78h+var_4C]
		call	sub_10010868
		inc	esi
		cmp	esi, edi
		jl	short loc_10012018
		mov	esi, [esp+70h+var_54]

loc_1001203F:				; CODE XREF: WebCore::Decimal::toString(void)+23Aj
					; WebCore::Decimal::toString(void)+25Bj ...
		test	ebx, ebx
		jz	short loc_10012082
		mov	eax, offset aE	; "e"
		js	short loc_1001204F
		mov	eax, offset aE_0 ; "e+"

loc_1001204F:				; CODE XREF: WebCore::Decimal::toString(void)+2A2j
		push	eax
		lea	ecx, [esp+74h+var_1C]
		call	sub_1000F9C9
		push	0FFFFFFFFh	; size_t
		push	0		; int
		lea	eax, [esp+78h+var_1C]
		push	eax		; int
		lea	ecx, [esp+7Ch+var_4C]
		call	sub_100107D6
		push	0		; size_t
		push	1		; char
		lea	ecx, [esp+78h+var_1C]
		call	sub_100105E7
		push	ebx
		lea	ecx, [esp+74h+var_4C]
		call	sub_1001094B

loc_10012082:				; CODE XREF: WebCore::Decimal::toString(void)+215j
					; WebCore::Decimal::toString(void)+29Bj
		and	dword ptr [esi+10h], 0
		lea	eax, [esp+70h+var_4C]
		push	0FFFFFFFFh	; int
		push	0		; int
		mov	dword ptr [esi+14h], 0Fh
		mov	ecx, esi	; void *
		push	eax		; int
		mov	byte ptr [esi],	0
		call	sub_10010997
		push	0		; size_t
		push	1		; char
		lea	ecx, [esp+78h+var_34]
		call	sub_100105E7
		push	0
		jmp	loc_10011F1D
; ---------------------------------------------------------------------------

loc_100120B4:				; CODE XREF: WebCore::Decimal::toString(void)+27j
		mov	eax, offset aInfinity_0	; "-Infinity"
		cmp	[edi+10h], ecx
		jnz	short loc_100120C3
		mov	eax, offset aInfinity ;	"Infinity"

loc_100120C3:				; CODE XREF: WebCore::Decimal::toString(void)+316j
		push	eax

loc_100120C4:				; CODE XREF: WebCore::Decimal::toString(void)+3Bj
					; WebCore::Decimal::toString(void)+45j
		mov	ecx, esi
		call	sub_1000F9C9

loc_100120CB:				; CODE XREF: WebCore::Decimal::toString(void)+182j
		mov	ecx, [esp+70h+var_4]
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn	4
?toString@Decimal@WebCore@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ endp

; Exported entry  91. ?toString@Decimal@WebCore@@QBE_NPADI@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall WebCore::Decimal::toString(WebCore::Decimal *this, char *, unsigned int)
		public ?toString@Decimal@WebCore@@QBE_NPADI@Z
?toString@Decimal@WebCore@@QBE_NPADI@Z proc near ; DATA	XREF: .rdata:off_100175A8o

var_1C		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 1Ch
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+1Ch+var_4], eax
		push	ebx
		mov	ebx, [ebp+arg_4]
		lea	eax, [esp+20h+var_1C]
		push	esi
		push	edi
		mov	edi, [ebp+arg_0]
		push	eax		; void *
		call	?toString@Decimal@WebCore@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; WebCore::Decimal::toString(void)
		mov	esi, ebx
		cmp	[esp+28h+var_C], ebx
		jnb	short loc_10012114
		mov	esi, [esp+28h+var_C]

loc_10012114:				; CODE XREF: WebCore::Decimal::toString(char *,uint)+2Dj
		cmp	[esp+28h+var_8], 10h
		mov	edx, [esp+28h+var_1C]
		jnb	short loc_10012123
		lea	edx, [esp+28h+var_1C] ;	void *

loc_10012123:				; CODE XREF: WebCore::Decimal::toString(char *,uint)+3Cj
		push	esi		; size_t
		mov	ecx, edi	; void *
		call	sub_10010BC3
		pop	ecx
		cmp	esi, ebx
		jnb	short loc_10012138
		mov	byte ptr [edi+esi], 0
		mov	bl, 1
		jmp	short loc_1001213F
; ---------------------------------------------------------------------------

loc_10012138:				; CODE XREF: WebCore::Decimal::toString(char *,uint)+4Dj
		mov	byte ptr [edi+ebx-1], 0
		xor	bl, bl

loc_1001213F:				; CODE XREF: WebCore::Decimal::toString(char *,uint)+55j
		push	0		; size_t
		push	1		; char
		lea	ecx, [esp+30h+var_1C]
		call	sub_100105E7
		mov	ecx, [esp+28h+var_4]
		mov	al, bl
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn	8
?toString@Decimal@WebCore@@QBE_NPADI@Z endp


; =============== S U B	R O U T	I N E =======================================


sub_10012162	proc near		; DATA XREF: .rdata:10016448o
		push	edi
		mov	edi, ecx
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		test	eax, eax
		jnz	short loc_10012174
		or	eax, 0FFFFFFFFh
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_10012174:				; CODE XREF: sub_10012162+Bj
		push	esi
		mov	ecx, edi
		call	ds:?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::egptr(void)
		mov	ecx, edi
		mov	esi, eax
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	eax, esi
		jb	short loc_100121F5
		test	byte ptr [edi+3Ch], 4
		jnz	short loc_10012202
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		test	eax, eax
		jz	short loc_10012202
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		mov	ecx, edi
		mov	esi, eax
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, eax
		ja	short loc_100121C0
		mov	ecx, edi
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	[edi+38h], eax
		jbe	short loc_10012202

loc_100121C0:				; CODE XREF: sub_10012162+4Fj
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	[edi+38h], eax
		jnb	short loc_100121D8
		mov	ecx, edi
		call	ds:?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		mov	[edi+38h], eax

loc_100121D8:				; CODE XREF: sub_10012162+69j
		push	dword ptr [edi+38h]
		mov	ecx, edi
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		push	eax
		mov	ecx, edi
		call	ds:?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		push	eax
		mov	ecx, edi
		call	ds:?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)

loc_100121F5:				; CODE XREF: sub_10012162+27j
		mov	ecx, edi
		call	ds:?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		movzx	eax, byte ptr [eax]
		jmp	short loc_10012205
; ---------------------------------------------------------------------------

loc_10012202:				; CODE XREF: sub_10012162+2Dj
					; sub_10012162+39j ...
		or	eax, 0FFFFFFFFh

loc_10012205:				; CODE XREF: sub_10012162+9Ej
		pop	esi
		pop	edi
		retn
sub_10012162	endp


; =============== S U B	R O U T	I N E =======================================


sub_10012208	proc near		; CODE XREF: WebCore::Decimal::operator*(WebCore::Decimal const	&)+A6p
					; WebCore::Decimal::operator-(WebCore::Decimal const &)+106p ...

arg_0		= dword	ptr  4

		push	esi
		mov	esi, ecx
		push	edi
		push	6
		pop	ecx
		mov	eax, [esi+8]
		sub	eax, 0
		jz	short loc_10012225
		dec	eax
		mov	eax, [esp+8+arg_0]
		mov	edi, eax
		jnz	short loc_1001222B
		mov	esi, [esi+4]
		jmp	short loc_1001222D
; ---------------------------------------------------------------------------

loc_10012225:				; CODE XREF: sub_10012208+Dj
		mov	eax, [esp+8+arg_0]
		mov	edi, eax

loc_1001222B:				; CODE XREF: sub_10012208+16j
		mov	esi, [esi]

loc_1001222D:				; CODE XREF: sub_10012208+1Bj
		rep movsd
		pop	edi
		pop	esi
		retn	4
sub_10012208	endp

; Exported entry  94. ?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static class WebCore::Decimal	__cdecl	WebCore::Decimal::zero(enum  WebCore::Decimal::Sign)
		public ?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z
?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z proc near
					; CODE XREF: WebCore::Decimal::operator/(WebCore::Decimal const	&)+19Dp
					; WebCore::Decimal::ceiling(void)+5Fp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= word ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		and	[ebp+var_18], 0
		and	[ebp+var_14], 0
		xor	eax, eax
		push	esi
		push	edi
		mov	[ebp+var_10], ax
		lea	esi, [ebp+var_18]
		mov	eax, [ebp+arg_4]
		push	6
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]
		mov	edi, eax
		pop	ecx
		mov	[ebp+var_C], 3
		rep movsd
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_1001226A(char, char, int, int, double)
sub_1001226A	proc near		; CODE XREF: sub_10014341+3B4p

var_32		= byte ptr -32h
var_31		= byte ptr -31h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= qword	ptr -24h
var_1C		= qword	ptr -1Ch
var_14		= qword	ptr -14h
var_C		= dword	ptr -0Ch
arg_0		= byte ptr  4
arg_4		= byte ptr  8
arg_C		= dword	ptr  10h
arg_10		= qword	ptr  14h

		sub	esp, 34h
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, ecx
		mov	ebp, edx
		mov	[esp+44h+var_30], edi
		jmp	short loc_10012284
; ---------------------------------------------------------------------------

loc_1001227B:				; CODE XREF: sub_1001226A+1Dj
		inc	edi
		mov	[esp+44h+var_30], edi
		cmp	edi, ebp
		jz	short loc_100122EB

loc_10012284:				; CODE XREF: sub_1001226A+Fj
		cmp	byte ptr [edi],	30h
		jz	short loc_1001227B
		xor	ebx, ebx
		xor	esi, esi
		xor	eax, eax
		mov	dword ptr [esp+44h+var_14], ebx
		mov	dword ptr [esp+44h+var_14+4], esi
		mov	[esp+44h+var_2C], eax

loc_1001229B:				; CODE XREF: sub_1001226A+7Aj
		mov	al, [edi]
		cmp	al, 30h
		jl	loc_1001240C
		cmp	al, 39h
		jg	loc_1001240C
		cmp	al, 38h
		jge	loc_1001240C
		movsx	eax, al
		sub	eax, 30h
		shld	esi, ebx, 3
		cdq
		shl	ebx, 3
		add	ebx, eax
		mov	dword ptr [esp+44h+var_14], ebx
		adc	esi, edx
		mov	ecx, esi
		mov	dword ptr [esp+44h+var_14+4], esi
		mov	eax, esi
		sar	ecx, 15h
		sar	eax, 1Fh
		test	ecx, ecx
		jnz	short loc_10012303
		inc	edi
		mov	[esp+44h+var_30], edi
		cmp	edi, ebp
		jnz	short loc_1001229B
		jmp	loc_1001242F
; ---------------------------------------------------------------------------

loc_100122EB:				; CODE XREF: sub_1001226A+18j
		cmp	[esp+44h+arg_0], 0
		mov	eax, [esp+44h+arg_C]
		mov	[eax], ebp
		jnz	loc_10012449
		fldz
		jmp	loc_100124AD
; ---------------------------------------------------------------------------

loc_10012303:				; CODE XREF: sub_1001226A+71j
		xor	edx, edx
		inc	edx
		mov	[esp+44h+var_28], edx
		mov	eax, edx
		cmp	ecx, edx
		jle	short loc_1001231B

loc_10012310:				; CODE XREF: sub_1001226A+ABj
		sar	ecx, 1
		inc	eax
		cmp	ecx, edx
		jg	short loc_10012310
		mov	[esp+44h+var_28], eax

loc_1001231B:				; CODE XREF: sub_1001226A+A4j
		mov	ecx, eax
		mov	eax, ebx
		shl	edx, cl
		mov	ecx, [esp+44h+var_28]
		dec	edx
		and	edx, ebx
		mov	dword ptr [esp+44h+var_1C], edx
		mov	edx, esi
		call	__allshr
		mov	ebx, eax
		mov	[esp+44h+var_32], 1
		mov	eax, [esp+44h+var_28]
		inc	edi
		mov	dword ptr [esp+44h+var_24], ebx
		mov	esi, edx
		mov	dword ptr [esp+44h+var_14], ebx
		mov	dword ptr [esp+44h+var_14+4], esi
		mov	[esp+44h+var_2C], eax
		mov	[esp+44h+var_30], edi
		cmp	edi, ebp
		jz	short loc_1001239C
		mov	ebx, eax

loc_1001235B:				; CODE XREF: sub_1001226A+124j
		mov	al, [edi]
		push	8
		movsx	ecx, al
		pop	edx
		mov	[esp+44h+var_31], al
		call	sub_10014FD5
		test	al, al
		jz	short loc_10012390
		cmp	[esp+44h+var_32], 0
		jz	short loc_10012383
		cmp	[esp+44h+var_31], 30h
		mov	[esp+44h+var_32], 1
		jz	short loc_10012388

loc_10012383:				; CODE XREF: sub_1001226A+10Bj
		mov	[esp+44h+var_32], 0

loc_10012388:				; CODE XREF: sub_1001226A+117j
		add	ebx, 3
		inc	edi
		cmp	edi, ebp
		jnz	short loc_1001235B

loc_10012390:				; CODE XREF: sub_1001226A+104j
		mov	[esp+44h+var_2C], ebx
		mov	ebx, dword ptr [esp+44h+var_24]
		mov	[esp+44h+var_30], edi

loc_1001239C:				; CODE XREF: sub_1001226A+EDj
		cmp	[esp+44h+arg_4], 0
		jnz	short loc_100123B6
		mov	edx, ebp
		lea	ecx, [esp+44h+var_30]
		call	sub_100128E7
		test	al, al
		jnz	short loc_10012422
		mov	edi, [esp+44h+var_30]

loc_100123B6:				; CODE XREF: sub_1001226A+137j
		mov	ecx, [esp+44h+var_28]
		xor	edx, edx
		inc	edx
		mov	eax, edx
		lea	ecx, [ecx-1]
		shl	eax, cl
		mov	ecx, dword ptr [esp+44h+var_1C]
		cmp	ecx, eax
		jg	short loc_100123DD
		jnz	short loc_100123EA
		mov	eax, ebx
		and	eax, edx
		or	eax, 0
		jnz	short loc_100123DD
		cmp	[esp+44h+var_32], al
		jnz	short loc_100123EA

loc_100123DD:				; CODE XREF: sub_1001226A+160j
					; sub_1001226A+16Bj
		add	ebx, edx
		mov	dword ptr [esp+44h+var_14], ebx
		adc	esi, 0
		mov	dword ptr [esp+44h+var_14+4], esi

loc_100123EA:				; CODE XREF: sub_1001226A+162j
					; sub_1001226A+171j
		mov	ecx, esi
		xor	eax, eax
		and	ecx, 200000h
		or	eax, ecx
		jz	short loc_1001242F
		inc	[esp+44h+var_2C]
		shrd	ebx, esi, 1
		sar	esi, 1
		mov	dword ptr [esp+44h+var_14], ebx
		mov	dword ptr [esp+44h+var_14+4], esi
		jmp	short loc_1001242F
; ---------------------------------------------------------------------------

loc_1001240C:				; CODE XREF: sub_1001226A+35j
					; sub_1001226A+3Dj ...
		cmp	[esp+44h+arg_4], 0
		jnz	short loc_1001242F
		mov	edx, ebp
		lea	ecx, [esp+44h+var_30]
		call	sub_100128E7
		test	al, al
		jz	short loc_1001242B

loc_10012422:				; CODE XREF: sub_1001226A+146j
		fld	[esp+44h+arg_10]
		jmp	loc_100124AD
; ---------------------------------------------------------------------------

loc_1001242B:				; CODE XREF: sub_1001226A+1B6j
		mov	edi, [esp+44h+var_30]

loc_1001242F:				; CODE XREF: sub_1001226A+7Cj
					; sub_1001226A+18Cj ...
		mov	eax, [esp+44h+arg_C]
		mov	[eax], edi
		mov	eax, [esp+44h+var_2C]
		test	eax, eax
		jnz	short loc_1001246E
		cmp	[esp+44h+arg_0], al
		jz	short loc_10012460
		mov	eax, ebx
		or	eax, esi
		jnz	short loc_10012451

loc_10012449:				; CODE XREF: sub_1001226A+8Cj
		fld	ds:dbl_10016EB0
		jmp	short loc_100124AD
; ---------------------------------------------------------------------------

loc_10012451:				; CODE XREF: sub_1001226A+1DDj
		neg	ebx
		mov	dword ptr [esp+44h+var_14], ebx
		adc	esi, 0
		neg	esi
		mov	dword ptr [esp+44h+var_14+4], esi

loc_10012460:				; CODE XREF: sub_1001226A+1D7j
		fild	[esp+44h+var_14]
		fstp	[esp+44h+var_1C]
		fld	[esp+44h+var_1C]
		jmp	short loc_100124AD
; ---------------------------------------------------------------------------

loc_1001246E:				; CODE XREF: sub_1001226A+1D1j
		sub	esp, 10h
		mov	dword ptr [esp+54h+var_14+4], esi
		mov	[esp+54h+var_C], eax
		lea	esi, [esp+54h+var_14]
		mov	edi, esp
		mov	dword ptr [esp+54h+var_14], ebx
		movsd
		movsd
		movsd
		movsd
		call	sub_100130BD
		mov	dword ptr [esp+54h+var_14], eax
		lea	eax, [esp+54h+var_14]
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+5Ch+var_24]
		mov	dword ptr [esp+5Ch+var_14+4], edx
		push	eax		; void *
		call	ds:memmove
		fld	[esp+60h+var_24]
		add	esp, 1Ch

loc_100124AD:				; CODE XREF: sub_1001226A+94j
					; sub_1001226A+1BCj ...
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 34h
		retn
sub_1001226A	endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_100124B5(char, char, int, int, double)
sub_100124B5	proc near		; CODE XREF: sub_10014341+2A6p

var_32		= byte ptr -32h
var_31		= byte ptr -31h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= qword	ptr -24h
var_1C		= qword	ptr -1Ch
var_14		= qword	ptr -14h
var_C		= dword	ptr -0Ch
arg_0		= byte ptr  4
arg_4		= byte ptr  8
arg_C		= dword	ptr  10h
arg_10		= qword	ptr  14h

		sub	esp, 34h
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, ecx
		mov	ebp, edx
		mov	[esp+44h+var_30], edi
		jmp	short loc_100124CF
; ---------------------------------------------------------------------------

loc_100124C6:				; CODE XREF: sub_100124B5+1Dj
		inc	edi
		mov	[esp+44h+var_30], edi
		cmp	edi, ebp
		jz	short loc_100124FC

loc_100124CF:				; CODE XREF: sub_100124B5+Fj
		cmp	byte ptr [edi],	30h
		jz	short loc_100124C6
		xor	ebx, ebx
		xor	esi, esi
		xor	eax, eax
		mov	dword ptr [esp+44h+var_14], ebx
		mov	dword ptr [esp+44h+var_14+4], esi
		mov	[esp+44h+var_2C], eax

loc_100124E6:				; CODE XREF: sub_100124B5+AEj
		mov	al, [edi]
		cmp	al, 30h
		jl	short loc_10012514
		cmp	al, 39h
		jg	short loc_10012514
		cmp	al, 40h
		jge	short loc_10012514
		movsx	eax, al
		sub	eax, 30h
		jmp	short loc_1001253A
; ---------------------------------------------------------------------------

loc_100124FC:				; CODE XREF: sub_100124B5+18j
		cmp	[esp+44h+arg_0], 0
		mov	eax, [esp+44h+arg_C]
		mov	[eax], ebp
		jnz	loc_100126B0
		fldz
		jmp	loc_10012714
; ---------------------------------------------------------------------------

loc_10012514:				; CODE XREF: sub_100124B5+35j
					; sub_100124B5+39j ...
		cmp	al, 61h
		jl	short loc_10012524
		cmp	al, 67h
		jge	short loc_10012524
		movsx	eax, al
		sub	eax, 57h
		jmp	short loc_1001253A
; ---------------------------------------------------------------------------

loc_10012524:				; CODE XREF: sub_100124B5+61j
					; sub_100124B5+65j
		cmp	al, 41h
		jl	loc_10012673
		cmp	al, 47h
		jge	loc_10012673
		movsx	eax, al
		sub	eax, 37h

loc_1001253A:				; CODE XREF: sub_100124B5+45j
					; sub_100124B5+6Dj
		shld	esi, ebx, 4
		cdq
		shl	ebx, 4
		add	ebx, eax
		mov	dword ptr [esp+44h+var_14], ebx
		adc	esi, edx
		mov	ecx, esi
		mov	dword ptr [esp+44h+var_14+4], esi
		mov	eax, esi
		sar	ecx, 15h
		sar	eax, 1Fh
		test	ecx, ecx
		jnz	short loc_1001256A
		inc	edi
		mov	[esp+44h+var_30], edi
		cmp	edi, ebp
		jnz	short loc_100124E6
		jmp	loc_10012696
; ---------------------------------------------------------------------------

loc_1001256A:				; CODE XREF: sub_100124B5+A5j
		xor	edx, edx
		inc	edx
		mov	[esp+44h+var_28], edx
		mov	eax, edx
		cmp	ecx, edx
		jle	short loc_10012582

loc_10012577:				; CODE XREF: sub_100124B5+C7j
		sar	ecx, 1
		inc	eax
		cmp	ecx, edx
		jg	short loc_10012577
		mov	[esp+44h+var_28], eax

loc_10012582:				; CODE XREF: sub_100124B5+C0j
		mov	ecx, eax
		mov	eax, ebx
		shl	edx, cl
		mov	ecx, [esp+44h+var_28]
		dec	edx
		and	edx, ebx
		mov	dword ptr [esp+44h+var_1C], edx
		mov	edx, esi
		call	__allshr
		mov	ebx, eax
		mov	[esp+44h+var_32], 1
		mov	eax, [esp+44h+var_28]
		inc	edi
		mov	dword ptr [esp+44h+var_24], ebx
		mov	esi, edx
		mov	dword ptr [esp+44h+var_14], ebx
		mov	dword ptr [esp+44h+var_14+4], esi
		mov	[esp+44h+var_2C], eax
		mov	[esp+44h+var_30], edi
		cmp	edi, ebp
		jz	short loc_10012603
		mov	ebx, eax

loc_100125C2:				; CODE XREF: sub_100124B5+140j
		mov	al, [edi]
		push	10h
		movsx	ecx, al
		pop	edx
		mov	[esp+44h+var_31], al
		call	sub_10014FD5
		test	al, al
		jz	short loc_100125F7
		cmp	[esp+44h+var_32], 0
		jz	short loc_100125EA
		cmp	[esp+44h+var_31], 30h
		mov	[esp+44h+var_32], 1
		jz	short loc_100125EF

loc_100125EA:				; CODE XREF: sub_100124B5+127j
		mov	[esp+44h+var_32], 0

loc_100125EF:				; CODE XREF: sub_100124B5+133j
		add	ebx, 4
		inc	edi
		cmp	edi, ebp
		jnz	short loc_100125C2

loc_100125F7:				; CODE XREF: sub_100124B5+120j
		mov	[esp+44h+var_2C], ebx
		mov	ebx, dword ptr [esp+44h+var_24]
		mov	[esp+44h+var_30], edi

loc_10012603:				; CODE XREF: sub_100124B5+109j
		cmp	[esp+44h+arg_4], 0
		jnz	short loc_1001261D
		mov	edx, ebp
		lea	ecx, [esp+44h+var_30]
		call	sub_100128E7
		test	al, al
		jnz	short loc_10012689
		mov	edi, [esp+44h+var_30]

loc_1001261D:				; CODE XREF: sub_100124B5+153j
		mov	ecx, [esp+44h+var_28]
		xor	edx, edx
		inc	edx
		mov	eax, edx
		lea	ecx, [ecx-1]
		shl	eax, cl
		mov	ecx, dword ptr [esp+44h+var_1C]
		cmp	ecx, eax
		jg	short loc_10012644
		jnz	short loc_10012651
		mov	eax, ebx
		and	eax, edx
		or	eax, 0
		jnz	short loc_10012644
		cmp	[esp+44h+var_32], al
		jnz	short loc_10012651

loc_10012644:				; CODE XREF: sub_100124B5+17Cj
					; sub_100124B5+187j
		add	ebx, edx
		mov	dword ptr [esp+44h+var_14], ebx
		adc	esi, 0
		mov	dword ptr [esp+44h+var_14+4], esi

loc_10012651:				; CODE XREF: sub_100124B5+17Ej
					; sub_100124B5+18Dj
		mov	ecx, esi
		xor	eax, eax
		and	ecx, 200000h
		or	eax, ecx
		jz	short loc_10012696
		inc	[esp+44h+var_2C]
		shrd	ebx, esi, 1
		sar	esi, 1
		mov	dword ptr [esp+44h+var_14], ebx
		mov	dword ptr [esp+44h+var_14+4], esi
		jmp	short loc_10012696
; ---------------------------------------------------------------------------

loc_10012673:				; CODE XREF: sub_100124B5+71j
					; sub_100124B5+79j
		cmp	[esp+44h+arg_4], 0
		jnz	short loc_10012696
		mov	edx, ebp
		lea	ecx, [esp+44h+var_30]
		call	sub_100128E7
		test	al, al
		jz	short loc_10012692

loc_10012689:				; CODE XREF: sub_100124B5+162j
		fld	[esp+44h+arg_10]
		jmp	loc_10012714
; ---------------------------------------------------------------------------

loc_10012692:				; CODE XREF: sub_100124B5+1D2j
		mov	edi, [esp+44h+var_30]

loc_10012696:				; CODE XREF: sub_100124B5+B0j
					; sub_100124B5+1A8j ...
		mov	eax, [esp+44h+arg_C]
		mov	[eax], edi
		mov	eax, [esp+44h+var_2C]
		test	eax, eax
		jnz	short loc_100126D5
		cmp	[esp+44h+arg_0], al
		jz	short loc_100126C7
		mov	eax, ebx
		or	eax, esi
		jnz	short loc_100126B8

loc_100126B0:				; CODE XREF: sub_100124B5+52j
		fld	ds:dbl_10016EB0
		jmp	short loc_10012714
; ---------------------------------------------------------------------------

loc_100126B8:				; CODE XREF: sub_100124B5+1F9j
		neg	ebx
		mov	dword ptr [esp+44h+var_14], ebx
		adc	esi, 0
		neg	esi
		mov	dword ptr [esp+44h+var_14+4], esi

loc_100126C7:				; CODE XREF: sub_100124B5+1F3j
		fild	[esp+44h+var_14]
		fstp	[esp+44h+var_1C]
		fld	[esp+44h+var_1C]
		jmp	short loc_10012714
; ---------------------------------------------------------------------------

loc_100126D5:				; CODE XREF: sub_100124B5+1EDj
		sub	esp, 10h
		mov	dword ptr [esp+54h+var_14+4], esi
		mov	[esp+54h+var_C], eax
		lea	esi, [esp+54h+var_14]
		mov	edi, esp
		mov	dword ptr [esp+54h+var_14], ebx
		movsd
		movsd
		movsd
		movsd
		call	sub_100130BD
		mov	dword ptr [esp+54h+var_14], eax
		lea	eax, [esp+54h+var_14]
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+5Ch+var_24]
		mov	dword ptr [esp+5Ch+var_14+4], edx
		push	eax		; void *
		call	ds:memmove
		fld	[esp+60h+var_24]
		add	esp, 1Ch

loc_10012714:				; CODE XREF: sub_100124B5+5Aj
					; sub_100124B5+1D8j ...
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 34h
		retn
sub_100124B5	endp


; =============== S U B	R O U T	I N E =======================================


sub_1001271C	proc near		; CODE XREF: sub_100127ED+3Dp

arg_0		= dword	ptr  4

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		push	esi
		push	edi
		push	ebx
		mov	edi, ecx
		call	sub_10008E3F
		mov	eax, [ebx+208h]
		mov	ecx, [edi+208h]
		mov	edx, [edi+20Ch]
		add	ecx, edx
		add	eax, [ebx+20Ch]
		cmp	ecx, eax
		jl	short loc_1001274C
		mov	eax, ecx

loc_1001274C:				; CODE XREF: sub_1001271C+2Cj
		sub	eax, edx
		inc	eax
		push	eax
		call	sub_10009240
		mov	edx, [ebx+20Ch]
		xor	esi, esi
		sub	edx, [edi+20Ch]
		mov	ebp, esi
		cmp	[ebx+208h], esi
		jle	short loc_100127B5

loc_1001276D:				; CODE XREF: sub_1001271C+7Aj
		mov	eax, [ebx+200h]
		mov	ecx, [edi+200h]
		mov	eax, [eax+ebp*4]
		add	esi, eax
		add	esi, [ecx+edx*4]
		mov	eax, esi
		shr	esi, 1Ch
		and	eax, 0FFFFFFFh
		mov	[ecx+edx*4], eax
		inc	edx
		inc	ebp
		cmp	ebp, [ebx+208h]
		jl	short loc_1001276D
		jmp	short loc_100127B1
; ---------------------------------------------------------------------------

loc_1001279A:				; CODE XREF: sub_1001271C+97j
		mov	ecx, [edi+200h]
		add	esi, [ecx+edx*4]
		mov	eax, esi
		shr	esi, 1Ch
		and	eax, 0FFFFFFFh
		mov	[ecx+edx*4], eax
		inc	edx

loc_100127B1:				; CODE XREF: sub_1001271C+7Cj
		test	esi, esi
		jnz	short loc_1001279A

loc_100127B5:				; CODE XREF: sub_1001271C+4Fj
		mov	eax, [edi+208h]
		cmp	edx, eax
		jl	short loc_100127C1
		mov	eax, edx

loc_100127C1:				; CODE XREF: sub_1001271C+A1j
		mov	[edi+208h], eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn	4
sub_1001271C	endp


; =============== S U B	R O U T	I N E =======================================


; int __stdcall	sub_100127CE(void *)
sub_100127CE	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *):loc_100139C8p

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		push	esi
		lea	esi, [edx+1]

loc_100127D6:				; CODE XREF: sub_100127CE+Dj
		mov	al, [edx]
		inc	edx
		test	al, al
		jnz	short loc_100127D6
		sub	edx, esi
		push	edx		; size_t
		push	[esp+8+arg_0]	; void *
		call	sub_1000981D
		pop	esi
		retn	4
sub_100127CE	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100127ED	proc near		; CODE XREF: sub_100128FF+56p
					; sub_100128FF+94p

var_218		= byte ptr -218h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 21Ch
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		or	eax, [ebp+arg_4]
		push	esi
		mov	esi, ecx
		jz	short loc_1001282F
		lea	ecx, [ebp+var_218]
		call	sub_10009208
		push	[ebp+arg_4]
		push	[ebp+arg_0]
		call	sub_1000919E
		lea	eax, [ebp+var_218]
		mov	ecx, esi
		push	eax
		call	sub_1001271C

loc_1001282F:				; CODE XREF: sub_100127ED+1Cj
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		pop	esi
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn	8
sub_100127ED	endp


; =============== S U B	R O U T	I N E =======================================


sub_10012840	proc near		; CODE XREF: sub_10012D4D+AEp
		dec	edx
		jz	loc_100128D3
		dec	edx
		jz	short loc_100128C3
		dec	edx
		jz	short loc_100128B3
		dec	edx
		jz	short loc_100128A3
		dec	edx
		jz	short loc_10012893
		dec	edx
		jz	short loc_10012883
		dec	edx
		jz	short loc_10012873
		int	3		; Trap to Debugger
		push	3		; uExitCode
		mov	large dword ptr	ds:0, 109h
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:TerminateProcess

loc_10012873:				; CODE XREF: sub_10012840+17j
		mov	dword ptr [ecx+4], 98968000h
		mov	dword ptr [ecx+8], 0FFFFFFD8h
		jmp	short loc_100128E1
; ---------------------------------------------------------------------------

loc_10012883:				; CODE XREF: sub_10012840+14j
		mov	dword ptr [ecx+4], 0F4240000h
		mov	dword ptr [ecx+8], 0FFFFFFD4h
		jmp	short loc_100128E1
; ---------------------------------------------------------------------------

loc_10012893:				; CODE XREF: sub_10012840+11j
		mov	dword ptr [ecx+4], 0C3500000h
		mov	dword ptr [ecx+8], 0FFFFFFD1h
		jmp	short loc_100128E1
; ---------------------------------------------------------------------------

loc_100128A3:				; CODE XREF: sub_10012840+Ej
		mov	dword ptr [ecx+4], 9C400000h
		mov	dword ptr [ecx+8], 0FFFFFFCEh
		jmp	short loc_100128E1
; ---------------------------------------------------------------------------

loc_100128B3:				; CODE XREF: sub_10012840+Bj
		mov	dword ptr [ecx+4], 0FA000000h
		mov	dword ptr [ecx+8], 0FFFFFFCAh
		jmp	short loc_100128E1
; ---------------------------------------------------------------------------

loc_100128C3:				; CODE XREF: sub_10012840+8j
		mov	dword ptr [ecx+4], 0C8000000h
		mov	dword ptr [ecx+8], 0FFFFFFC7h
		jmp	short loc_100128E1
; ---------------------------------------------------------------------------

loc_100128D3:				; CODE XREF: sub_10012840+1j
		mov	dword ptr [ecx+4], 0A0000000h
		mov	dword ptr [ecx+8], 0FFFFFFC4h

loc_100128E1:				; CODE XREF: sub_10012840+41j
					; sub_10012840+51j ...
		and	dword ptr [ecx], 0
		mov	eax, ecx
		retn
sub_10012840	endp


; =============== S U B	R O U T	I N E =======================================


sub_100128E7	proc near		; CODE XREF: sub_1001226A+13Fp
					; sub_1001226A+1AFp ...
		cmp	[ecx], edx
		jz	short loc_100128F9

loc_100128EB:				; CODE XREF: sub_100128E7+10j
		mov	eax, [ecx]
		cmp	byte ptr [eax],	20h
		jnz	short loc_100128FC
		inc	eax
		mov	[ecx], eax
		cmp	eax, edx
		jnz	short loc_100128EB

loc_100128F9:				; CODE XREF: sub_100128E7+2j
		xor	al, al
		retn
; ---------------------------------------------------------------------------

loc_100128FC:				; CODE XREF: sub_100128E7+9j
		mov	al, 1
		retn
sub_100128E7	endp


; =============== S U B	R O U T	I N E =======================================


sub_100128FF	proc near		; CODE XREF: sub_10012A14+38p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		sub	esp, 0Ch
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	ebx, ecx
		call	sub_10008E60
		mov	esi, [esp+1Ch+arg_4]
		xor	ecx, ecx
		push	13h
		pop	edi
		mov	ebp, esi
		cmp	esi, edi
		jl	short loc_10012975
		xor	edx, edx
		mov	eax, esi
		div	edi
		imul	ecx, eax, 13h
		mov	[esp+1Ch+var_8], eax
		sub	ebp, ecx
		mov	[esp+1Ch+var_4], ebp
		xor	ebp, ebp

loc_10012931:				; CODE XREF: sub_100128FF+68j
		push	esi
		push	[esp+20h+arg_0]
		mov	edx, edi
		mov	ecx, ebp
		call	sub_10013FA3
		pop	ecx
		pop	ecx
		push	13h
		mov	ecx, ebx
		mov	edi, eax
		mov	esi, edx
		add	ebp, 13h
		call	sub_10013B86
		push	esi
		push	edi
		mov	ecx, ebx
		call	sub_100127ED
		dec	[esp+1Ch+var_8]
		mov	esi, [esp+1Ch+arg_4]
		jz	short loc_10012969
		push	13h
		pop	edi
		jmp	short loc_10012931
; ---------------------------------------------------------------------------

loc_10012969:				; CODE XREF: sub_100128FF+63j
		mov	[esp+1Ch+var_8], ebp
		mov	ebp, [esp+1Ch+var_4]
		mov	ecx, [esp+1Ch+var_8]

loc_10012975:				; CODE XREF: sub_100128FF+1Bj
		push	esi
		push	[esp+20h+arg_0]
		mov	edx, ebp
		call	sub_10013FA3
		pop	ecx
		pop	ecx
		push	ebp
		mov	ecx, ebx
		mov	edi, eax
		mov	esi, edx
		call	sub_10013B86
		push	esi
		push	edi
		mov	ecx, ebx
		call	sub_100127ED
		mov	ecx, ebx
		call	sub_10008E7F
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 0Ch
		retn	8
sub_100128FF	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100129A9	proc near		; CODE XREF: sub_10008958+4F4Cp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, edx
		mov	edx, [esi]
		mov	eax, edx
		neg	eax
		cmp	eax, ecx
		jle	short loc_100129C5
		neg	ecx
		mov	[esi], ecx

loc_100129BD:				; CODE XREF: sub_100129A9+38j
		mov	eax, [ebp+arg_8]
		and	dword ptr [eax], 0
		jmp	short loc_10012A11
; ---------------------------------------------------------------------------

loc_100129C5:				; CODE XREF: sub_100129A9+Ej
		jnz	short loc_100129F6
		mov	ecx, [ebp+arg_4]
		push	0Ah
		call	sub_10009096
		mov	ecx, [ebp+arg_0]
		mov	edx, ecx
		push	[ebp+arg_4]
		call	sub_10008C25
		pop	ecx
		test	eax, eax
		js	short loc_100129BD
		mov	eax, [ebp+arg_C]
		mov	byte ptr [eax],	31h
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		inc	dword ptr [esi]
		jmp	short loc_10012A11
; ---------------------------------------------------------------------------

loc_100129F6:				; CODE XREF: sub_100129A9:loc_100129C5j
		push	[ebp+arg_10]
		add	ecx, edx
		mov	edx, esi
		push	[ebp+arg_C]
		push	[ebp+arg_8]
		push	[ebp+arg_4]
		push	[ebp+arg_0]
		call	sub_10008D3A
		add	esp, 14h

loc_10012A11:				; CODE XREF: sub_100129A9+1Aj
					; sub_100129A9+4Bj
		pop	esi
		pop	ebp
		retn
sub_100129A9	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10012A14	proc near		; CODE XREF: sub_100148CE+E0p

var_428		= byte ptr -428h
var_218		= byte ptr -218h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 42Ch
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		push	esi
		mov	esi, ecx
		lea	ecx, [ebp+var_428]
		call	sub_10009208
		lea	ecx, [ebp+var_218]
		call	sub_10009208
		push	[ebp+arg_4]
		lea	ecx, [ebp+var_428]
		push	[ebp+arg_0]
		call	sub_100128FF
		push	[ebp+arg_C]
		lea	ecx, [ebp+var_218]
		push	[ebp+arg_8]
		call	sub_1000919E
		test	esi, esi
		js	short loc_10012A6E
		lea	ecx, [ebp+var_428]
		jmp	short loc_10012A76
; ---------------------------------------------------------------------------

loc_10012A6E:				; CODE XREF: sub_10012A14+50j
		neg	esi
		lea	ecx, [ebp+var_218]

loc_10012A76:				; CODE XREF: sub_10012A14+58j
		push	esi
		call	sub_10013B86
		mov	eax, [ebp+arg_10]
		test	eax, eax
		jle	short loc_10012A8B
		lea	ecx, [ebp+var_218]
		jmp	short loc_10012A93
; ---------------------------------------------------------------------------

loc_10012A8B:				; CODE XREF: sub_10012A14+6Dj
		neg	eax
		lea	ecx, [ebp+var_428]

loc_10012A93:				; CODE XREF: sub_10012A14+75j
		push	eax
		call	sub_1000911A
		lea	edx, [ebp+var_218]
		lea	ecx, [ebp+var_428]
		call	sub_1000A406
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		pop	esi
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_10012A14	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10012AB9	proc near		; CODE XREF: sub_100148CE+5Fp

var_10		= qword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		push	ebx
		push	esi
		push	edi
		mov	edi, [ebp+arg_4]
		mov	esi, edx
		mov	ebx, ecx
		test	edi, edi
		jnz	short loc_10012ADA

loc_10012ACD:				; CODE XREF: sub_10012AB9+57j
		fldz

loc_10012ACF:				; CODE XREF: sub_10012AB9+4Fj
		fstp	qword ptr [esi]

loc_10012AD1:				; CODE XREF: sub_10012AB9+68j
					; sub_10012AB9+7Bj ...
		mov	al, 1

loc_10012AD3:				; CODE XREF: sub_10012AB9+AFj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10012ADA:				; CODE XREF: sub_10012AB9+12j
		lea	ecx, [edi+ebx]
		lea	eax, [ecx-1]
		cmp	eax, 135h
		jl	short loc_10012B0A
		and	[ebp+var_8], 0
		lea	eax, [ebp+var_8]
		push	8		; size_t
		push	eax		; void *
		lea	eax, [ebp+var_10]
		mov	[ebp+var_4], 7FF00000h
		push	eax		; void *
		call	ds:memmove
		fld	[ebp+var_10]
		add	esp, 0Ch
		jmp	short loc_10012ACF
; ---------------------------------------------------------------------------

loc_10012B0A:				; CODE XREF: sub_10012AB9+2Cj
		cmp	ecx, 0FFFFFEBCh
		jle	short loc_10012ACD
		push	edi
		push	[ebp+arg_0]
		mov	ecx, ebx
		call	sub_10013162
		pop	ecx
		pop	ecx
		test	al, al
		jnz	short loc_10012AD1
		push	edi
		push	[ebp+arg_0]
		mov	edx, esi
		mov	ecx, ebx
		call	sub_10012D4D
		pop	ecx
		pop	ecx
		test	al, al
		jnz	short loc_10012AD1
		and	[ebp+var_8], 0
		lea	eax, [ebp+var_8]
		push	8		; size_t
		push	eax		; void *
		lea	eax, [ebp+var_10]
		mov	[ebp+var_4], 7FF00000h
		push	eax		; void *
		call	ds:memmove
		fld	qword ptr [esi]
		add	esp, 0Ch
		fld	[ebp+var_10]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jnp	loc_10012AD1
		xor	al, al
		jmp	loc_10012AD3
sub_10012AB9	endp


; =============== S U B	R O U T	I N E =======================================


sub_10012B6D	proc near		; CODE XREF: sub_10014341+127p
					; sub_10014341+1CDp

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	ebx
		push	esi
		mov	esi, edx
		jmp	short loc_10012B83
; ---------------------------------------------------------------------------

loc_10012B77:				; CODE XREF: sub_10012B6D+1Bj
		inc	dword ptr [ecx]
		mov	edx, [ecx]
		cmp	edx, esi
		jz	short loc_10012B91
		cmp	[edx], bl
		jnz	short loc_10012B91

loc_10012B83:				; CODE XREF: sub_10012B6D+8j
		inc	eax
		mov	bl, [eax]
		test	bl, bl
		jnz	short loc_10012B77
		inc	dword ptr [ecx]
		mov	al, 1

loc_10012B8E:				; CODE XREF: sub_10012B6D+26j
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_10012B91:				; CODE XREF: sub_10012B6D+10j
					; sub_10012B6D+14j
		xor	al, al
		jmp	short loc_10012B8E
sub_10012B6D	endp

; Exported entry  30. ?CreateExponentialRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHPAVStringBuilder@2@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(double_conversion::DoubleToStringConverter *this,	const char *, int, int,	struct double_conversion::StringBuilder	*)
		public ?CreateExponentialRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHPAVStringBuilder@2@@Z
?CreateExponentialRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHPAVStringBuilder@2@@Z proc	near
					; CODE XREF: double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+EDp
					; double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder *)+46F5p ...

var_C		= byte ptr -0Ch
var_7		= byte ptr -7
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		push	ebx
		push	esi
		mov	esi, [ebp+arg_C]
		mov	ebx, ecx
		push	edi
		mov	edi, [ebp+arg_0]
		mov	ecx, esi
		movzx	eax, byte ptr [edi]
		push	eax
		call	sub_10009860
		mov	edx, [ebp+arg_4]
		cmp	edx, 1
		jz	short loc_10012BE1
		mov	ecx, [esi+8]
		lea	eax, [ecx+1]
		mov	[esi+8], eax
		mov	eax, [esi]
		mov	byte ptr [ecx+eax], 2Eh
		lea	eax, [edx-1]
		push	eax		; size_t
		lea	eax, [edi+1]
		mov	ecx, esi
		push	eax		; void *
		call	sub_1000981D

loc_10012BE1:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)+2Cj
		movzx	eax, byte ptr [ebx+0Ch]
		mov	ecx, esi
		push	eax
		call	sub_10009860
		mov	edi, [ebp+arg_8]
		test	edi, edi
		jns	short loc_10012C07
		mov	ecx, [esi+8]
		neg	edi
		lea	eax, [ecx+1]
		mov	[esi+8], eax
		mov	eax, [esi]
		mov	byte ptr [ecx+eax], 2Dh
		jmp	short loc_10012C1B
; ---------------------------------------------------------------------------

loc_10012C07:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)+5Dj
		test	byte ptr [ebx],	1
		jz	short loc_10012C1B
		mov	ecx, [esi+8]
		lea	eax, [ecx+1]
		mov	[esi+8], eax
		mov	eax, [esi]
		mov	byte ptr [ecx+eax], 2Bh

loc_10012C1B:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)+70j
					; double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)+75j
		test	edi, edi
		jnz	short loc_10012C30
		mov	ecx, [esi+8]
		lea	eax, [ecx+1]
		mov	[esi+8], eax
		mov	eax, [esi]
		mov	byte ptr [ecx+eax], 30h
		jmp	short loc_10012C61
; ---------------------------------------------------------------------------

loc_10012C30:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)+88j
		push	5
		pop	ecx
		mov	[ebp+var_7], 0
		mov	ebx, ecx
		jmp	short loc_10012C4D
; ---------------------------------------------------------------------------

loc_10012C3B:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)+BAj
		mov	eax, edi
		dec	ebx
		push	0Ah
		pop	edi
		cdq
		idiv	edi
		add	dl, 30h
		mov	edi, eax
		mov	[ebp+ebx+var_C], dl

loc_10012C4D:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)+A4j
		test	edi, edi
		jg	short loc_10012C3B
		sub	ecx, ebx
		lea	eax, [ebp+var_C]
		push	ecx		; size_t
		add	eax, ebx
		mov	ecx, esi
		push	eax		; void *
		call	sub_1000981D

loc_10012C61:				; CODE XREF: double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)+99j
		mov	ecx, [ebp+var_4]
		pop	edi
		pop	esi
		xor	ecx, ebp
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn	10h
?CreateExponentialRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHPAVStringBuilder@2@@Z endp


; =============== S U B	R O U T	I N E =======================================


sub_10012C74	proc near		; CODE XREF: sub_10014ECB+57p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		mov	ebx, ecx
		mov	esi, edx
		sub	edi, edx
		mov	ecx, 30Bh

loc_10012C86:				; CODE XREF: sub_10012C74+19j
		mov	al, [edi+esi]
		mov	[esi], al
		inc	esi
		dec	ecx
		jnz	short loc_10012C86
		mov	ecx, [esp+0Ch+arg_8]
		mov	eax, [esp+0Ch+arg_0]
		add	ecx, 0FFFFFCF4h
		pop	edi
		add	ecx, ebx
		mov	byte ptr [edx+30Bh], 31h
		pop	esi
		mov	[eax], ecx
		pop	ebx
		retn
sub_10012C74	endp


; =============== S U B	R O U T	I N E =======================================


sub_10012CAC	proc near		; CODE XREF: sub_10013676+111p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		push	ecx
		push	ecx
		push	ebx
		push	ebp
		mov	ebx, ecx
		mov	ecx, [esp+10h+arg_0]
		mov	[esp+10h+var_8], ebx
		push	esi
		push	edi
		cmp	ecx, 40h
		jl	short loc_10012CEF
		mov	ebp, [ebx]
		lea	edi, [ecx-40h]
		mov	ebx, [ebx+4]
		mov	eax, ebp
		mov	edx, ebx
		mov	ecx, edi
		call	__aullshr
		mov	esi, eax
		mov	ecx, edi
		cdq
		call	__allshl
		sub	ebp, eax
		mov	eax, [esp+18h+var_8]
		sbb	ebx, edx
		mov	[eax], ebp
		mov	[eax+4], ebx
		mov	eax, esi
		jmp	short loc_10012D44
; ---------------------------------------------------------------------------

loc_10012CEF:				; CODE XREF: sub_10012CAC+13j
		mov	eax, [ebx+8]
		mov	ebp, [ebx+0Ch]
		mov	edx, ebp
		mov	[esp+18h+var_4], eax
		call	__aullshr
		push	40h
		pop	ecx
		sub	ecx, [esp+18h+arg_0]
		mov	esi, eax
		mov	eax, [ebx]
		mov	edi, edx
		mov	edx, [ebx+4]
		call	__allshl
		mov	ecx, [esp+18h+arg_0]
		mov	edx, edi
		lea	ebx, [esi+eax]
		mov	eax, [esp+18h+var_8]
		and	dword ptr [eax], 0
		and	dword ptr [eax+4], 0
		mov	eax, esi
		call	__allshl
		mov	ecx, [esp+18h+var_4]
		sub	ecx, eax
		mov	eax, [esp+18h+var_8]
		sbb	ebp, edx
		mov	[eax+8], ecx
		mov	[eax+0Ch], ebp
		mov	eax, ebx

loc_10012D44:				; CODE XREF: sub_10012CAC+41j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		pop	ecx
		retn	4
sub_10012CAC	endp


; =============== S U B	R O U T	I N E =======================================


sub_10012D4D	proc near		; CODE XREF: sub_10012AB9+72p

var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= qword	ptr -34h
var_2C		= dword	ptr -2Ch
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		sub	esp, 5Ch
		and	dword ptr [esp+5Ch+var_34], 0
		and	dword ptr [esp+5Ch+var_34+4], 0
		and	[esp+5Ch+var_2C], 0
		push	ebx
		push	ebp
		push	esi
		push	edi
		push	[esp+6Ch+arg_4]
		mov	edi, edx
		mov	ebp, ecx
		push	[esp+70h+arg_0]
		lea	edx, [esp+74h+var_50]
		mov	[esp+74h+var_40], edi
		lea	ecx, [esp+74h+var_34]
		call	sub_10013F42
		mov	ebx, [esp+74h+var_50]
		add	ebp, ebx
		mov	esi, [esp+74h+var_2C]
		neg	ebx
		pop	ecx
		pop	ecx
		sbb	ebx, ebx
		lea	ecx, [esp+6Ch+var_34]
		and	ebx, 4
		call	sub_10009F25
		mov	eax, [esp+6Ch+var_2C]
		sub	esi, eax
		mov	ecx, esi
		mov	[esp+6Ch+var_54], eax
		shl	ebx, cl
		mov	[esp+6Ch+var_58], ebx
		cmp	ebp, 0FFFFFEA4h
		jge	short loc_10012DC4
		fldz
		fstp	qword ptr [edi]

loc_10012DBA:				; CODE XREF: sub_10012D4D+343j
					; sub_10012D4D+34Dj ...
		mov	al, 1

loc_10012DBC:				; CODE XREF: sub_10012D4D+36Bj
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 5Ch
		retn
; ---------------------------------------------------------------------------

loc_10012DC4:				; CODE XREF: sub_10012D4D+67j
		xor	ebx, ebx
		lea	eax, [esp+6Ch+var_5C]
		push	eax
		lea	edx, [esp+70h+var_24]
		mov	[esp+70h+var_24], ebx
		mov	ecx, ebp
		mov	[esp+70h+var_20], ebx
		mov	[esp+70h+var_1C], ebx
		call	sub_10013904
		pop	ecx
		cmp	[esp+6Ch+var_5C], ebp
		jz	loc_10012E97
		sub	ebp, [esp+6Ch+var_5C]
		lea	ecx, [esp+6Ch+var_14]
		mov	edx, ebp
		mov	[esp+6Ch+var_4C], ebp
		call	sub_10012840
		push	ebx
		push	dword ptr [esp+70h+var_34]
		push	ebx
		push	[esp+78h+var_10]
		call	__allmul
		push	ebx
		push	dword ptr [esp+70h+var_34+4]
		mov	edi, eax
		mov	ebp, edx
		push	ebx
		push	[esp+78h+var_14]
		call	__allmul
		push	0
		push	dword ptr [esp+70h+var_34]
		mov	esi, eax
		mov	ebx, edx
		mov	eax, [esp+74h+var_2C]
		add	eax, 40h
		add	eax, [esp+74h+var_C]
		push	0
		push	[esp+78h+var_14]
		mov	[esp+7Ch+var_54], eax
		call	__allmul
		push	0
		add	edx, esi
		pop	esi
		push	esi
		pop	eax
		adc	esi, eax
		add	edx, edi
		push	eax
		push	dword ptr [esp+70h+var_34+4]
		adc	esi, eax
		add	edx, 80000000h
		push	eax
		push	[esp+78h+var_10]
		adc	esi, eax
		xor	edi, edi
		call	__allmul
		add	esi, eax
		push	0
		adc	edi, edx
		add	esi, ebx
		pop	ebx
		adc	edi, ebx
		add	esi, ebp
		push	13h
		adc	edi, ebx
		mov	[esp+70h+var_50], esi
		pop	eax
		sub	eax, [esp+6Ch+arg_4]
		mov	[esp+6Ch+var_5C], edi
		cmp	eax, [esp+6Ch+var_4C]
		jge	short loc_10012EA7
		add	[esp+6Ch+var_58], 4
		jmp	short loc_10012EA7
; ---------------------------------------------------------------------------

loc_10012E97:				; CODE XREF: sub_10012D4D+9Aj
		mov	eax, dword ptr [esp+6Ch+var_34+4]
		mov	esi, dword ptr [esp+6Ch+var_34]
		mov	[esp+6Ch+var_5C], eax
		mov	[esp+6Ch+var_50], esi

loc_10012EA7:				; CODE XREF: sub_10012D4D+141j
					; sub_10012D4D+148j
		push	ebx
		push	esi
		push	ebx
		push	[esp+78h+var_20]
		call	__allmul
		push	ebx
		push	[esp+70h+var_5C]
		mov	edi, eax
		mov	[esp+74h+var_4C], edx
		push	ebx
		push	[esp+78h+var_24]
		call	__allmul
		mov	esi, eax
		mov	ebp, edx
		mov	eax, [esp+6Ch+var_54]
		add	eax, 40h
		add	eax, [esp+6Ch+var_1C]
		push	ebx
		mov	[esp+70h+var_54], eax
		mov	[esp+70h+var_2C], eax
		mov	eax, [esp+70h+var_50]
		push	eax
		push	ebx
		push	[esp+78h+var_24]
		call	__allmul
		xor	ebx, ebx
		add	edx, esi
		push	0
		adc	ebx, ebx
		add	edx, edi
		pop	edi
		push	edi
		push	[esp+70h+var_5C]
		adc	ebx, edi
		add	edx, 80000000h
		push	edi
		push	[esp+78h+var_20]
		adc	ebx, edi
		xor	esi, esi
		call	__allmul
		add	ebx, eax
		lea	ecx, [esp+6Ch+var_34]
		adc	esi, edx
		add	ebx, ebp
		adc	esi, edi
		add	ebx, [esp+6Ch+var_4C]
		mov	dword ptr [esp+6Ch+var_34], ebx
		adc	esi, edi
		xor	ebx, ebx
		mov	dword ptr [esp+6Ch+var_34+4], esi
		mov	esi, [esp+6Ch+var_58]
		test	esi, esi
		setnz	bl
		call	sub_10009F25
		mov	edx, [esp+6Ch+var_2C]
		lea	edi, [esi+8]
		mov	ecx, [esp+6Ch+var_54]
		add	edi, ebx
		sub	ecx, edx
		mov	[esp+6Ch+var_50], edx
		shl	edi, cl
		lea	ecx, [edx+40h]
		call	sub_10014176
		push	40h
		pop	ebp
		sub	ebp, eax
		lea	eax, [ebp+3]
		cmp	eax, 40h
		jl	short loc_10012F98
		mov	eax, dword ptr [esp+6Ch+var_34]
		lea	esi, [ebp-3Ch]
		mov	edx, dword ptr [esp+6Ch+var_34+4]
		mov	ecx, esi
		call	__aullshr
		mov	[esp+6Ch+var_58], eax
		mov	ecx, esi
		mov	eax, [esp+6Ch+var_2C]
		sar	edi, cl
		add	eax, esi
		add	edi, 9
		mov	[esp+6Ch+var_5C], edx
		mov	[esp+6Ch+var_50], eax
		sub	ebp, esi
		jmp	short loc_10012FA8
; ---------------------------------------------------------------------------

loc_10012F98:				; CODE XREF: sub_10012D4D+21Aj
		mov	eax, dword ptr [esp+6Ch+var_34+4]
		mov	[esp+6Ch+var_5C], eax
		mov	eax, dword ptr [esp+6Ch+var_34]
		mov	[esp+6Ch+var_58], eax

loc_10012FA8:				; CODE XREF: sub_10012D4D+249j
		xor	eax, eax
		xor	edx, edx
		inc	eax
		mov	ecx, ebp
		call	__allshl
		mov	ebx, eax
		lea	ecx, [ebp-1]
		add	ebx, 0FFFFFFFFh
		mov	eax, edx
		adc	eax, 0FFFFFFFFh
		and	ebx, [esp+6Ch+var_58]
		and	eax, [esp+6Ch+var_5C]
		xor	edx, edx
		shld	eax, ebx, 3
		mov	[esp+6Ch+var_4C], eax
		xor	eax, eax
		inc	eax
		shl	ebx, 3
		call	__allshl
		mov	esi, eax
		mov	ecx, ebp
		mov	eax, edx
		mov	edx, [esp+6Ch+var_5C]
		shld	eax, esi, 3
		mov	[esp+6Ch+var_54], eax
		mov	eax, [esp+6Ch+var_58]
		shl	esi, 3
		mov	[esp+6Ch+var_3C], esi
		call	__aullshr
		mov	ecx, [esp+6Ch+var_50]
		mov	[esp+6Ch+var_24], eax
		add	ecx, ebp
		mov	ebp, [esp+6Ch+var_4C]
		mov	eax, edi
		mov	[esp+6Ch+var_20], edx
		cdq
		mov	[esp+6Ch+var_1C], ecx
		mov	ecx, edx
		mov	[esp+6Ch+var_50], eax
		add	eax, esi
		mov	[esp+6Ch+var_58], ecx
		adc	ecx, [esp+6Ch+var_54]
		mov	[esp+6Ch+var_38], eax
		mov	[esp+6Ch+var_5C], ecx
		cmp	ebp, ecx
		jb	short loc_10013045
		ja	short loc_1001303B
		cmp	ebx, eax
		jb	short loc_10013045

loc_1001303B:				; CODE XREF: sub_10012D4D+2E8j
		add	[esp+6Ch+var_24], 1
		adc	[esp+6Ch+var_20], 0

loc_10013045:				; CODE XREF: sub_10012D4D+2E6j
					; sub_10012D4D+2ECj
		sub	esp, 10h
		lea	esi, [esp+7Ch+var_24]
		mov	edi, esp
		movsd
		movsd
		movsd
		movsd
		call	sub_100130BD
		mov	[esp+7Ch+var_4C], eax
		lea	eax, [esp+7Ch+var_4C]
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+84h+var_34]
		mov	[esp+84h+var_48], edx
		push	eax		; void *
		call	ds:memmove
		mov	eax, [esp+88h+var_40]
		add	esp, 1Ch
		fld	[esp+6Ch+var_34]
		mov	ecx, [esp+6Ch+var_54]
		fstp	qword ptr [eax]
		mov	eax, [esp+6Ch+var_3C]
		sub	eax, [esp+6Ch+var_50]
		sbb	ecx, [esp+6Ch+var_58]
		cmp	ecx, ebp
		ja	loc_10012DBA
		jb	short loc_100130A0
		cmp	eax, ebx
		jnb	loc_10012DBA

loc_100130A0:				; CODE XREF: sub_10012D4D+349j
		cmp	ebp, [esp+6Ch+var_5C]
		ja	loc_10012DBA
		jb	short loc_100130B6
		cmp	ebx, [esp+6Ch+var_38]
		jnb	loc_10012DBA

loc_100130B6:				; CODE XREF: sub_10012D4D+35Dj
		xor	al, al
		jmp	loc_10012DBC
sub_10012D4D	endp


; =============== S U B	R O U T	I N E =======================================


sub_100130BD	proc near		; CODE XREF: sub_1001226A+21Dp
					; sub_100124B5+239p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	edx, [esp+arg_8]
		mov	eax, 1FFFFFh
		push	esi
		mov	esi, [esp+4+arg_4]
		push	edi
		mov	edi, [esp+8+arg_0]
		cmp	esi, eax
		jb	short loc_100130E8
		jbe	short loc_100130E3

loc_100130D6:				; CODE XREF: sub_100130BD+22j
					; sub_100130BD+29j
		shrd	edi, esi, 1
		shr	esi, 1
		inc	edx
		cmp	esi, eax
		ja	short loc_100130D6
		jb	short loc_100130E8

loc_100130E3:				; CODE XREF: sub_100130BD+17j
		cmp	edi, 0FFFFFFFFh
		ja	short loc_100130D6

loc_100130E8:				; CODE XREF: sub_100130BD+15j
					; sub_100130BD+24j
		cmp	edx, 3CCh
		jl	short loc_100130F9
		xor	eax, eax
		mov	edx, 7FF00000h
		jmp	short loc_1001315F
; ---------------------------------------------------------------------------

loc_100130F9:				; CODE XREF: sub_100130BD+31j
		push	ebp
		mov	ebp, 0FFFFFBCEh
		cmp	edx, ebp
		jge	short loc_10013109
		xor	eax, eax
		xor	edx, edx
		jmp	short loc_1001315E
; ---------------------------------------------------------------------------

loc_10013109:				; CODE XREF: sub_100130BD+44j
		push	ebx
		xor	ebx, ebx
		jmp	short loc_10013123
; ---------------------------------------------------------------------------

loc_1001310E:				; CODE XREF: sub_100130BD+68j
		mov	ecx, esi
		mov	eax, ebx
		and	ecx, 100000h
		or	eax, ecx
		jnz	short loc_10013127
		shld	esi, edi, 1
		add	edi, edi
		dec	edx

loc_10013123:				; CODE XREF: sub_100130BD+4Fj
		cmp	edx, ebp
		jg	short loc_1001310E

loc_10013127:				; CODE XREF: sub_100130BD+5Dj
		cmp	edx, ebp
		jnz	short loc_1001313F
		mov	ecx, esi
		mov	eax, ebx
		and	ecx, 100000h
		or	eax, ecx
		jnz	short loc_1001313F
		mov	[esp+10h+arg_4], ebx
		jmp	short loc_1001314C
; ---------------------------------------------------------------------------

loc_1001313F:				; CODE XREF: sub_100130BD+6Cj
					; sub_100130BD+7Aj
		lea	eax, [edx+433h]
		cdq
		mov	ebx, eax
		mov	[esp+10h+arg_4], edx

loc_1001314C:				; CODE XREF: sub_100130BD+80j
		xor	eax, eax
		shl	ebx, 14h
		and	esi, 0FFFFFh
		or	eax, edi
		or	ebx, esi
		mov	edx, ebx
		pop	ebx

loc_1001315E:				; CODE XREF: sub_100130BD+4Aj
		pop	ebp

loc_1001315F:				; CODE XREF: sub_100130BD+3Aj
		pop	edi
		pop	esi
		retn
sub_100130BD	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013162	proc near		; CODE XREF: sub_10012AB9+5Fp

var_4		= byte ptr -4
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ebx
		push	esi
		push	edi
		push	0Fh
		mov	esi, ecx
		mov	ebx, edx
		mov	ecx, dword ptr [ebp+arg_0+4]
		pop	edi
		cmp	ecx, edi
		jg	loc_1001325B
		test	esi, esi
		jns	short loc_100131D5
		mov	eax, esi
		neg	eax
		cmp	eax, 17h
		jge	short loc_100131D1
		push	ecx
		push	dword ptr [ebp+arg_0]
		lea	ecx, [ebp+var_4]
		call	sub_10013FED
		mov	dword ptr [ebp+arg_0], eax
		mov	eax, edx
		and	edx, 7FFFFFFFh
		and	eax, 80000000h
		mov	dword ptr [ebp+arg_0+4], edx
		fild	[ebp+arg_0]
		and	dword ptr [ebp+arg_0], 0
		mov	dword ptr [ebp+arg_0+4], eax
		mov	eax, esi
		pop	ecx
		fild	[ebp+arg_0]
		pop	ecx
		shl	eax, 3
		mov	ecx, offset dbl_10017110
		sub	ecx, eax
		fchs
		faddp	st(1), st
		fdiv	qword ptr [ecx]

loc_100131C8:				; CODE XREF: sub_10013162+B1j
		fstp	qword ptr [ebx]
		mov	al, 1
		jmp	loc_1001325D
; ---------------------------------------------------------------------------

loc_100131D1:				; CODE XREF: sub_10013162+24j
		test	esi, esi
		js	short loc_10013215

loc_100131D5:				; CODE XREF: sub_10013162+1Bj
		cmp	esi, 17h
		jge	short loc_10013215
		push	ecx
		push	dword ptr [ebp+arg_0]
		lea	ecx, [ebp+var_4]
		call	sub_10013FED
		mov	dword ptr [ebp+arg_0], eax
		mov	eax, edx
		and	edx, 7FFFFFFFh
		and	eax, 80000000h
		mov	dword ptr [ebp+arg_0+4], edx
		fild	[ebp+arg_0]
		and	dword ptr [ebp+arg_0], 0
		mov	dword ptr [ebp+arg_0+4], eax
		fild	[ebp+arg_0]
		fchs
		faddp	st(1), st

loc_1001320A:				; CODE XREF: sub_10013162+F7j
		fmul	ds:dbl_10017110[esi*8]
		pop	ecx
		pop	ecx
		jmp	short loc_100131C8
; ---------------------------------------------------------------------------

loc_10013215:				; CODE XREF: sub_10013162+71j
					; sub_10013162+76j
		sub	edi, ecx
		test	esi, esi
		js	short loc_1001325B
		sub	esi, edi
		cmp	esi, 17h
		jge	short loc_1001325B
		push	ecx
		push	dword ptr [ebp+arg_0]
		lea	ecx, [ebp+var_4]
		call	sub_10013FED
		mov	dword ptr [ebp+arg_0], eax
		mov	eax, edx
		and	edx, 7FFFFFFFh
		and	eax, 80000000h
		mov	dword ptr [ebp+arg_0+4], edx
		fild	[ebp+arg_0]
		and	dword ptr [ebp+arg_0], 0
		mov	dword ptr [ebp+arg_0+4], eax
		fild	[ebp+arg_0]
		fchs
		faddp	st(1), st
		fmul	ds:dbl_10017110[edi*8]
		jmp	short loc_1001320A
; ---------------------------------------------------------------------------

loc_1001325B:				; CODE XREF: sub_10013162+13j
					; sub_10013162+B7j ...
		xor	al, al

loc_1001325D:				; CODE XREF: sub_10013162+6Aj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
sub_10013162	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013264	proc near		; CODE XREF: sub_10008958+4E9Ap
					; sub_10013B14+8p ...
		mov	eax, [ecx]
		test	eax, 7F800000h
		jnz	short loc_10013273
		mov	eax, 0FFFFFF6Bh
		retn
; ---------------------------------------------------------------------------

loc_10013273:				; CODE XREF: sub_10013264+7j
		shr	eax, 17h
		and	eax, 0FFh
		sub	eax, 96h
		retn
sub_10013264	endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_10013281(int,	double,	int, int)
sub_10013281	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool *,int *,int *)+44AEp

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_8		= qword	ptr -8
arg_0		= dword	ptr  4
arg_4		= qword	ptr  8
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		sub	esp, 20h
		fld	[esp+20h+arg_4]
		lea	eax, [esp+20h+var_8]
		push	ebx
		push	ebp
		push	esi
		mov	esi, ds:memmove
		mov	ebx, ecx
		push	edi
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+38h+var_18]
		mov	[esp+38h+var_C], ebx
		push	eax		; void *
		fstp	[esp+3Ch+var_8]
		mov	edi, edx
		call	esi ; memmove
		mov	eax, [esp+3Ch+var_18]
		lea	ecx, [esp+3Ch+var_20]
		add	esp, 0Ch
		mov	[esp+30h+var_20], eax
		mov	eax, [esp+30h+var_14]
		mov	[esp+30h+var_1C], eax
		call	sub_10009CA5
		fld	[esp+30h+arg_4]
		mov	[esp+30h+var_18], eax
		lea	eax, [esp+30h+var_8]
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+38h+arg_4]
		mov	[esp+38h+var_20], edx
		push	eax		; void *
		fstp	[esp+3Ch+var_8]
		call	esi ; memmove
		mov	eax, dword ptr [esp+3Ch+arg_4]
		lea	ecx, [esp+3Ch+var_8]
		add	esp, 0Ch
		mov	dword ptr [esp+30h+var_8], eax
		mov	eax, dword ptr [esp+30h+arg_4+4]
		mov	dword ptr [esp+30h+var_8+4], eax
		call	sub_10009E0D
		mov	ebp, eax
		cmp	ebp, 14h
		jle	short loc_10013310

loc_10013309:				; CODE XREF: sub_10013281+92j
		xor	al, al
		jmp	loc_100134D2
; ---------------------------------------------------------------------------

loc_10013310:				; CODE XREF: sub_10013281+86j
		cmp	ebx, 14h
		jg	short loc_10013309
		xor	ecx, ecx
		lea	eax, [ebp+35h]
		mov	[edi], ecx
		cmp	eax, 40h
		jle	loc_100133CA
		push	11h
		pop	ecx
		cmp	ebp, ecx
		jle	short loc_1001335C
		mov	eax, [esp+30h+var_18]
		lea	ecx, [ebp-11h]
		mov	edx, [esp+30h+var_20]
		call	__allshl
		push	0B1h
		push	0A2BC2EC5h
		push	edx
		push	eax
		call	__aulldvrm
		mov	esi, ecx
		mov	dword ptr [esp+30h+arg_4+4], edx
		shld	ebx, esi, 11h
		shl	esi, 11h
		jmp	short loc_10013397
; ---------------------------------------------------------------------------

loc_1001335C:				; CODE XREF: sub_10013281+A9j
		sub	ecx, ebp
		mov	eax, 0A2BC2EC5h
		mov	edx, 0B1h
		call	__allshl
		push	edx
		push	eax
		push	[esp+38h+var_20]
		push	[esp+3Ch+var_18]
		call	__aulldvrm
		mov	dword ptr [esp+30h+arg_4], eax
		mov	eax, ecx
		mov	dword ptr [esp+30h+var_8+4], edx
		mov	ecx, ebp
		mov	edx, ebx
		call	__allshl
		mov	esi, eax
		mov	ebx, edx
		mov	eax, dword ptr [esp+30h+arg_4]

loc_10013397:				; CODE XREF: sub_10013281+D9j
		push	[esp+30h+arg_10]
		mov	edx, edi
		mov	ecx, eax
		push	[esp+34h+arg_C]
		call	sub_100134DA
		push	[esp+38h+arg_10]
		mov	edx, edi
		push	[esp+3Ch+arg_C]
		push	ebx
		push	esi
		call	sub_10013600
		mov	esi, [esp+48h+arg_0]
		mov	eax, [edi]
		mov	ebx, [esp+48h+var_C]
		mov	[esi], eax
		jmp	loc_100134A7
; ---------------------------------------------------------------------------

loc_100133CA:				; CODE XREF: sub_10013281+9Ej
		test	ebp, ebp
		js	short loc_100133FC
		push	[esp+30h+arg_10]
		mov	eax, [esp+34h+var_18]
		mov	ecx, ebp
		push	[esp+34h+arg_C]
		mov	edx, [esp+38h+var_20]
		call	__allshl
		push	edx
		push	eax
		mov	ecx, edi
		call	sub_1001355C
		mov	eax, [edi]
		add	esp, 10h
		mov	esi, [esp+30h+arg_0]
		jmp	loc_10013486
; ---------------------------------------------------------------------------

loc_100133FC:				; CODE XREF: sub_10013281+14Bj
		cmp	ebp, 0FFFFFFCBh
		jle	short loc_10013471
		mov	eax, [esp+30h+var_18]
		mov	esi, ebp
		mov	edx, [esp+30h+var_20]
		neg	esi
		mov	ecx, esi
		call	__aullshr
		mov	ecx, edx
		mov	dword ptr [esp+30h+arg_4], eax
		mov	[esp+30h+var_C], ecx
		mov	ecx, esi
		call	__allshl
		sub	[esp+30h+var_18], eax
		mov	ecx, [esp+30h+var_C]
		sbb	[esp+30h+var_20], edx
		mov	eax, dword ptr [esp+30h+arg_4]
		test	ecx, ecx
		jnz	short loc_10013453
		cmp	eax, 0FFFFFFFFh
		ja	short loc_10013453
		push	[esp+30h+arg_10]
		mov	edx, edi
		mov	ecx, eax
		push	[esp+34h+arg_C]
		call	sub_100134DA
		pop	ecx
		pop	ecx
		jmp	short loc_10013467
; ---------------------------------------------------------------------------

loc_10013453:				; CODE XREF: sub_10013281+1B6j
					; sub_10013281+1BBj
		push	[esp+30h+arg_10]
		push	[esp+34h+arg_C]
		push	ecx
		push	eax
		mov	ecx, edi
		call	sub_1001355C
		add	esp, 10h

loc_10013467:				; CODE XREF: sub_10013281+1D0j
		mov	esi, [esp+30h+arg_0]
		mov	eax, [edi]
		mov	[esi], eax
		jmp	short loc_1001348C
; ---------------------------------------------------------------------------

loc_10013471:				; CODE XREF: sub_10013281+17Ej
		mov	esi, [esp+30h+arg_0]
		cmp	ebp, 0FFFFFF80h
		jge	short loc_1001348A
		mov	eax, [esp+30h+arg_C]
		mov	[eax], cl
		mov	eax, ebx
		mov	[edi], ecx
		neg	eax

loc_10013486:				; CODE XREF: sub_10013281+176j
		mov	[esi], eax
		jmp	short loc_100134AA
; ---------------------------------------------------------------------------

loc_1001348A:				; CODE XREF: sub_10013281+1F7j
		mov	[esi], ecx

loc_1001348C:				; CODE XREF: sub_10013281+1EEj
		push	[esp+30h+arg_10]
		mov	edx, ebx
		mov	ecx, ebp
		push	[esp+34h+arg_C]
		push	esi
		push	edi
		push	[esp+40h+var_20]
		push	[esp+44h+var_18]
		call	sub_10013676

loc_100134A7:				; CODE XREF: sub_10013281+144j
		add	esp, 18h

loc_100134AA:				; CODE XREF: sub_10013281+207j
		push	[esp+30h+arg_10]
		mov	edx, esi
		mov	ecx, edi
		push	[esp+34h+arg_C]
		call	sub_10014F49
		mov	eax, [esp+38h+arg_C]
		pop	ecx
		pop	ecx
		mov	ecx, [edi]
		mov	byte ptr [eax+ecx], 0
		cmp	dword ptr [edi], 0
		jnz	short loc_100134D0
		neg	ebx
		mov	[esi], ebx

loc_100134D0:				; CODE XREF: sub_10013281+249j
		mov	al, 1

loc_100134D2:				; CODE XREF: sub_10013281+8Aj
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 20h
		retn
sub_10013281	endp


; =============== S U B	R O U T	I N E =======================================


sub_100134DA	proc near		; CODE XREF: sub_10013281+122p
					; sub_10013281+1C9p ...

arg_0		= dword	ptr  4

		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	ebx, edx
		xor	ebp, ebp
		jmp	short loc_100134FC
; ---------------------------------------------------------------------------

loc_100134E4:				; CODE XREF: sub_100134DA+24j
		mov	eax, ecx
		xor	edx, edx
		push	0Ah
		pop	ecx
		div	ecx
		mov	ecx, eax
		add	dl, 30h
		mov	eax, [ebx]
		add	eax, [esp+10h+arg_0]
		mov	[eax+ebp], dl
		inc	ebp

loc_100134FC:				; CODE XREF: sub_100134DA+8j
		test	ecx, ecx
		jnz	short loc_100134E4
		mov	esi, [ebx]
		lea	edi, [esi-1]
		add	edi, ebp
		jmp	short loc_1001351F
; ---------------------------------------------------------------------------

loc_10013509:				; CODE XREF: sub_100134DA+47j
		mov	ecx, [esp+10h+arg_0]
		mov	al, [ecx+edi]
		mov	dl, [ecx+esi]
		mov	[ecx+esi], al
		inc	esi
		mov	eax, [esp+10h+arg_0]
		mov	[eax+edi], dl
		dec	edi

loc_1001351F:				; CODE XREF: sub_100134DA+2Dj
		cmp	esi, edi
		jl	short loc_10013509
		add	[ebx], ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
sub_100134DA	endp


; =============== S U B	R O U T	I N E =======================================


sub_1001352A	proc near		; CODE XREF: sub_1001355C+58p
					; sub_1001355C+6Bp ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_0]
		mov	ebx, ecx
		push	edi
		mov	edi, edx
		lea	ecx, [edi-1]
		test	ecx, ecx
		js	short loc_10013556

loc_1001353C:				; CODE XREF: sub_1001352A+2Aj
		mov	eax, ebx
		xor	edx, edx
		push	0Ah
		pop	ebx
		div	ebx
		mov	ebx, eax
		add	dl, 30h
		mov	eax, [esi]
		add	eax, [esp+0Ch+arg_4]
		mov	[eax+ecx], dl
		dec	ecx
		jns	short loc_1001353C

loc_10013556:				; CODE XREF: sub_1001352A+10j
		add	[esi], edi
		pop	edi
		pop	esi
		pop	ebx
		retn
sub_1001352A	endp


; =============== S U B	R O U T	I N E =======================================


sub_1001355C	proc near		; CODE XREF: sub_10013281+168p
					; sub_10013281+1DEp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	ebp
		push	esi
		push	edi
		push	0
		mov	edi, 989680h
		mov	esi, ecx
		push	edi
		push	[esp+18h+arg_4]
		push	[esp+1Ch+arg_0]
		call	__aulldvrm
		push	0
		push	edi
		push	edx
		push	eax
		mov	ebp, ecx
		mov	[esp+20h+arg_4], ebx
		call	__aulldvrm
		mov	[esp+10h+arg_4], ebx
		mov	edi, ecx
		mov	[esp+10h+arg_4], edx
		mov	edx, esi
		push	[esp+10h+arg_C]
		push	[esp+14h+arg_8]
		test	eax, eax
		jz	short loc_100135D1
		mov	ecx, eax
		call	sub_100134DA
		push	[esp+18h+arg_C]
		mov	ecx, edi
		push	[esp+1Ch+arg_8]
		push	esi
		push	7
		pop	edx
		call	sub_1001352A
		push	[esp+24h+arg_C]
		mov	ecx, ebp
		push	[esp+28h+arg_8]
		push	esi
		push	7
		pop	edx
		call	sub_1001352A
		add	esp, 20h
		jmp	short loc_100135FB
; ---------------------------------------------------------------------------

loc_100135D1:				; CODE XREF: sub_1001355C+41j
		test	edi, edi
		jz	short loc_100135F2
		call	sub_100134DA
		push	[esp+18h+arg_C]
		mov	ecx, ebp
		push	[esp+1Ch+arg_8]
		push	esi
		push	7
		pop	edx
		call	sub_1001352A
		add	esp, 14h
		jmp	short loc_100135FB
; ---------------------------------------------------------------------------

loc_100135F2:				; CODE XREF: sub_1001355C+77j
		mov	ecx, ebp
		call	sub_100134DA
		pop	ecx
		pop	ecx

loc_100135FB:				; CODE XREF: sub_1001355C+73j
					; sub_1001355C+94j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
sub_1001355C	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013600	proc near		; CODE XREF: sub_10013281+133p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	ebp
		push	esi
		push	edi
		push	0
		mov	esi, 989680h
		mov	ebp, edx
		push	esi
		push	[esp+18h+arg_4]
		push	[esp+1Ch+arg_0]
		call	__aulldvrm
		push	0
		push	esi
		push	edx
		push	eax
		mov	edi, ecx
		mov	[esp+20h+arg_4], ebx
		call	__aulldvrm
		push	[esp+10h+arg_C]
		mov	esi, ecx
		mov	[esp+14h+arg_4], ebx
		push	[esp+14h+arg_8]
		mov	[esp+18h+arg_4], edx
		mov	ecx, eax
		push	ebp
		push	3
		pop	edx
		call	sub_1001352A
		push	[esp+1Ch+arg_C]
		mov	ecx, esi
		push	[esp+20h+arg_8]
		push	ebp
		push	7
		pop	edx
		call	sub_1001352A
		push	[esp+28h+arg_C]
		mov	ecx, edi
		push	[esp+2Ch+arg_8]
		push	ebp
		push	7
		pop	edx
		call	sub_1001352A
		add	esp, 24h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
sub_10013600	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013676	proc near		; CODE XREF: sub_10013281+221p

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		sub	esp, 24h
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, ecx
		mov	ebp, edx
		neg	edi
		mov	[esp+34h+var_18], ebp
		xor	esi, esi
		cmp	edi, 40h
		jg	loc_1001372B
		test	ebp, ebp
		mov	[esp+34h+var_1C], esi
		mov	ebp, [esp+34h+arg_4]
		jle	loc_10013725
		mov	ecx, [esp+34h+arg_0]
		mov	[esp+34h+var_20], ecx

loc_100136AA:				; CODE XREF: sub_10013676+89j
		mov	eax, ecx
		or	eax, ebp
		jz	short loc_10013701
		push	esi
		push	5
		push	ebp
		push	ecx
		call	__allmul
		dec	edi
		mov	[esp+34h+var_20], eax
		mov	ecx, edi
		mov	ebp, edx
		call	__aullshr
		mov	ecx, [esp+34h+arg_8]
		lea	ebx, [eax+30h]
		mov	edx, [ecx]
		mov	ecx, [esp+34h+arg_10]
		mov	[ecx+edx], bl
		mov	ecx, [esp+34h+arg_8]
		cdq
		inc	dword ptr [ecx]
		mov	ecx, edi
		call	__allshl
		mov	ecx, [esp+34h+var_20]
		sub	ecx, eax
		mov	[esp+34h+var_20], ecx
		sbb	ebp, edx
		mov	edx, [esp+34h+var_1C]
		inc	edx
		mov	[esp+34h+var_1C], edx
		cmp	edx, [esp+34h+var_18]
		jl	short loc_100136AA

loc_10013701:				; CODE XREF: sub_10013676+38j
		mov	eax, [esp+34h+var_20]

loc_10013705:				; CODE XREF: sub_10013676+B3j
		lea	ecx, [edi-1]
		mov	edx, ebp
		call	__aullshr
		and	eax, 1
		and	edx, esi
		or	eax, edx
		jz	loc_100137E1
		mov	ecx, [esp+34h+arg_8]
		jmp	loc_100137CE
; ---------------------------------------------------------------------------

loc_10013725:				; CODE XREF: sub_10013676+26j
		mov	eax, [esp+34h+arg_0]
		jmp	short loc_10013705
; ---------------------------------------------------------------------------

loc_1001372B:				; CODE XREF: sub_10013676+16j
		mov	eax, [esp+34h+arg_0]
		mov	[esp+34h+var_14], eax
		mov	eax, [esp+34h+arg_4]
		push	0FFFFFFC0h
		mov	[esp+38h+var_10], eax
		pop	eax
		sub	eax, ecx
		mov	[esp+34h+var_C], esi
		push	eax
		lea	ecx, [esp+38h+var_14]
		mov	[esp+38h+var_8], esi
		call	sub_10014099
		mov	edi, [esp+34h+arg_8]
		mov	ebx, 80h
		test	ebp, ebp
		jle	short loc_1001379E

loc_1001375F:				; CODE XREF: sub_10013676+126j
		mov	edx, [esp+34h+var_14]
		mov	eax, edx
		or	eax, [esp+34h+var_10]
		jnz	short loc_10013777
		mov	ecx, [esp+34h+var_C]
		mov	eax, ecx
		or	eax, [esp+34h+var_8]
		jz	short loc_100137A6

loc_10013777:				; CODE XREF: sub_10013676+F3j
		push	ecx
		lea	ecx, [esp+38h+var_14]
		call	sub_10013B2F
		dec	ebx
		lea	ecx, [esp+34h+var_14]
		push	ebx
		call	sub_10012CAC
		mov	edx, [edi]
		add	al, 30h
		mov	ecx, [esp+34h+arg_10]
		mov	[ecx+edx], al
		inc	dword ptr [edi]
		inc	esi
		cmp	esi, ebp
		jl	short loc_1001375F

loc_1001379E:				; CODE XREF: sub_10013676+E7j
		mov	ecx, [esp+34h+var_C]
		mov	edx, [esp+34h+var_14]

loc_100137A6:				; CODE XREF: sub_10013676+FFj
		dec	ebx
		cmp	ebx, 40h
		jl	short loc_100137B7
		mov	eax, edx
		lea	ecx, [ebx-40h]
		mov	edx, [esp+34h+var_10]
		jmp	short loc_100137BF
; ---------------------------------------------------------------------------

loc_100137B7:				; CODE XREF: sub_10013676+134j
		mov	edx, [esp+34h+var_8]
		mov	eax, ecx
		mov	ecx, ebx

loc_100137BF:				; CODE XREF: sub_10013676+13Fj
		call	__aullshr
		and	eax, 1
		cmp	eax, 1
		jnz	short loc_100137E1
		mov	ecx, edi

loc_100137CE:				; CODE XREF: sub_10013676+AAj
		push	[esp+34h+arg_14]
		mov	edx, [esp+38h+arg_C]
		push	[esp+38h+arg_10]
		call	sub_10014052
		pop	ecx
		pop	ecx

loc_100137E1:				; CODE XREF: sub_10013676+A0j
					; sub_10013676+154j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 24h
		retn
sub_10013676	endp


; =============== S U B	R O U T	I N E =======================================


sub_100137E9	proc near		; CODE XREF: sub_10008958+4F8Bp

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= byte ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	ecx
		push	ebx
		mov	ebx, [esp+8+arg_4]
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+14h+arg_0]
		mov	esi, ecx
		mov	[esp+14h+var_4], edx
		mov	ecx, edi
		mov	edx, ebx
		call	sub_1000A406
		test	eax, eax
		jnz	short loc_1001380B
		mov	ebx, edi

loc_1001380B:				; CODE XREF: sub_100137E9+1Ej
		mov	ebp, [esp+14h+arg_C]
		and	dword ptr [ebp+0], 0

loc_10013813:				; CODE XREF: sub_100137E9+9Fj
					; sub_100137E9+AAj
		push	[esp+14h+var_4]
		mov	ecx, esi
		call	sub_10008EE7
		mov	ecx, [ebp+0]
		movzx	edx, ax
		add	dl, 30h
		lea	eax, [ecx+1]
		mov	[ebp+0], eax
		mov	eax, [esp+14h+arg_10]
		mov	[ecx+eax], dl
		mov	edx, edi
		mov	ecx, esi
		call	sub_1000A406
		cmp	[esp+14h+arg_8], 0
		jz	short loc_1001384D
		test	eax, eax
		setle	byte ptr [esp+14h+arg_C]
		jmp	short loc_1001389D
; ---------------------------------------------------------------------------

loc_1001384D:				; CODE XREF: sub_100137E9+59j
		test	eax, eax
		jns	short loc_10013898
		mov	byte ptr [esp+14h+arg_C], 1

loc_10013856:				; CODE XREF: sub_100137E9+B9j
		push	[esp+14h+var_4]
		mov	edx, ebx
		mov	ecx, esi
		call	sub_10008C25
		test	eax, eax
		setnle	al

loc_10013868:				; CODE XREF: sub_100137E9+CDj
		cmp	byte ptr [esp+18h+arg_C], 0
		pop	ecx
		jnz	short loc_100138B8
		test	al, al
		jnz	short loc_100138D0
		push	0Ah
		mov	ecx, esi
		call	sub_10009096
		push	0Ah
		mov	ecx, edi
		call	sub_10009096
		cmp	edi, ebx
		jz	short loc_10013813
		push	0Ah
		mov	ecx, ebx
		call	sub_10009096
		jmp	loc_10013813
; ---------------------------------------------------------------------------

loc_10013898:				; CODE XREF: sub_100137E9+66j
		mov	byte ptr [esp+14h+arg_C], 0

loc_1001389D:				; CODE XREF: sub_100137E9+62j
		cmp	[esp+14h+arg_8], 0
		jz	short loc_10013856
		push	[esp+14h+var_4]
		mov	edx, ebx
		mov	ecx, esi
		call	sub_10008C25
		test	eax, eax
		setns	al
		jmp	short loc_10013868
; ---------------------------------------------------------------------------

loc_100138B8:				; CODE XREF: sub_100137E9+85j
		test	al, al
		jz	short loc_100138FE
		push	[esp+14h+var_4]
		mov	edx, esi
		mov	ecx, esi
		call	sub_10008C25
		pop	ecx
		test	eax, eax
		js	short loc_100138FE
		jle	short loc_100138DD

loc_100138D0:				; CODE XREF: sub_100137E9+89j
		mov	ecx, [ebp+0]
		mov	eax, [esp+14h+arg_10]
		inc	byte ptr [ecx+eax-1]
		jmp	short loc_100138FE
; ---------------------------------------------------------------------------

loc_100138DD:				; CODE XREF: sub_100137E9+E5j
		mov	esi, [ebp+0]
		mov	edi, [esp+14h+arg_10]
		push	2
		pop	ebx
		mov	cl, [esi+edi-1]
		movsx	eax, cl
		sub	eax, 30h
		cdq
		idiv	ebx
		test	edx, edx
		jz	short loc_100138FE
		inc	cl
		mov	[esi+edi-1], cl

loc_100138FE:				; CODE XREF: sub_100137E9+D1j
					; sub_100137E9+E3j ...
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
sub_100137E9	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013904	proc near		; CODE XREF: sub_10012D4D+90p

var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		push	ebx
		push	esi
		push	edi
		lea	eax, [ecx+15Ch]
		mov	ebx, edx
		cdq
		lea	edi, [ebp+var_14]
		push	8
		pop	ecx
		idiv	ecx
		shl	eax, 4
		add	eax, offset dword_10016940
		mov	esi, eax
		movsd
		movsd
		movsd
		movsd
		mov	eax, [ebp+var_14]
		lea	esi, [ebp+var_24]
		mov	ecx, [ebp+var_C]
		mov	edi, ebx
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_10]
		mov	[ebp+var_20], eax
		movsx	eax, cx
		mov	[ebp+var_1C], eax
		mov	eax, [ebp+arg_0]
		movsd
		shr	ecx, 10h
		movsx	ecx, cx
		mov	[eax], ecx
		movsd
		movsd
		movsd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
sub_10013904	endp

; Exported entry  36. ?HandleSpecialValues@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall double_conversion::DoubleToStringConverter::HandleSpecialValues(double_conversion::DoubleToStringConverter *this, double, struct double_conversion::StringBuilder *)
		public ?HandleSpecialValues@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@@Z
?HandleSpecialValues@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@@Z proc near
					; CODE XREF: double_conversion::DoubleToStringConverter::ToPrecision(double,int,bool *,double_conversion::StringBuilder	*)+46B9p
					; double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double,double_conversion::StringBuilder *,double_conversion::DoubleToStringConverter::DtoaMode)+458Bp ...

var_10		= qword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 14h
		fld	[ebp+arg_0]
		lea	eax, [esp+14h+var_10]
		push	esi
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+20h+var_8]
		mov	esi, ecx
		push	eax		; void *
		fstp	[esp+24h+var_10]
		call	ds:memmove
		mov	eax, [esp+24h+var_8]
		lea	ecx, [esp+24h+var_10]
		add	esp, 0Ch
		mov	dword ptr [esp+18h+var_10], eax
		mov	eax, [esp+18h+var_4]
		mov	dword ptr [esp+18h+var_10+4], eax
		call	sub_10013AC4
		test	al, al
		jz	short loc_100139D1
		cmp	dword ptr [esi+4], 0
		jz	short loc_100139EC
		fldz
		fcomp	[ebp+arg_0]
		mov	ecx, [ebp+arg_8]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_100139C5
		mov	edx, [ecx+8]
		lea	eax, [edx+1]
		mov	[ecx+8], eax
		mov	eax, [ecx]
		mov	byte ptr [edx+eax], 2Dh

loc_100139C5:				; CODE XREF: double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)+58j
		push	dword ptr [esi+4] ; void *

loc_100139C8:				; CODE XREF: double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)+8Ej
		call	sub_100127CE
		mov	al, 1
		jmp	short loc_100139EE
; ---------------------------------------------------------------------------

loc_100139D1:				; CODE XREF: double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)+43j
		lea	ecx, [esp+18h+var_10]
		call	sub_10013AEC
		test	al, al
		jz	short loc_100139EC
		cmp	dword ptr [esi+8], 0
		jz	short loc_100139EC
		push	dword ptr [esi+8]
		mov	ecx, [ebp+arg_8]
		jmp	short loc_100139C8
; ---------------------------------------------------------------------------

loc_100139EC:				; CODE XREF: double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)+49j
					; double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)+80j ...
		xor	al, al

loc_100139EE:				; CODE XREF: double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)+73j
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?HandleSpecialValues@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100139F5	proc near		; CODE XREF: sub_10008853:loc_100088A5p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		push	ebx
		push	esi
		mov	esi, [ebp+arg_C]
		neg	edx
		push	edi
		push	edx
		mov	edi, ecx
		push	ecx
		mov	ecx, esi
		call	sub_10008FB5
		mov	bl, [ebp+arg_8]
		test	bl, bl
		jz	short loc_10013A24
		mov	ecx, [ebp+arg_18]
		push	esi
		call	sub_10009150
		mov	ecx, [ebp+arg_14]
		push	esi
		call	sub_10009150

loc_10013A24:				; CODE XREF: sub_100139F5+1Bj
		push	[ebp+arg_4]
		mov	ecx, esi
		push	[ebp+arg_0]
		call	sub_10013C84
		push	ecx
		mov	ecx, [ebp+arg_10]
		call	sub_100091EF
		neg	edi
		push	edi
		call	sub_1000911A
		test	bl, bl
		jz	short loc_10013A59
		push	1
		mov	ecx, esi
		call	sub_1000911A
		mov	ecx, [ebp+arg_10]
		push	1
		call	sub_1000911A

loc_10013A59:				; CODE XREF: sub_100139F5+4Fj
		pop	edi
		pop	esi
		pop	ebx
		pop	ebp
		retn
sub_100139F5	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013A5E	proc near		; CODE XREF: sub_10008853:loc_1000889Ep

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		push	esi
		push	edi
		push	[ebp+arg_4]
		mov	edi, ecx
		mov	esi, edx
		push	[ebp+arg_0]
		mov	ecx, [ebp+arg_C]
		call	sub_1000919E
		mov	ecx, [ebp+arg_C]
		push	edi
		call	sub_1000911A
		push	esi
		push	ecx
		mov	ecx, [ebp+arg_10]
		call	sub_10008FB5
		cmp	[ebp+arg_8], 0
		jz	short loc_10013AC0
		mov	ecx, [ebp+arg_10]
		push	1
		call	sub_1000911A
		mov	ecx, [ebp+arg_C]
		push	1
		call	sub_1000911A
		push	ecx
		mov	ecx, [ebp+arg_18]
		call	sub_100091EF
		push	edi
		call	sub_1000911A
		push	ecx
		mov	ecx, [ebp+arg_14]
		call	sub_100091EF
		push	edi
		call	sub_1000911A

loc_10013AC0:				; CODE XREF: sub_10013A5E+2Ej
		pop	edi
		pop	esi
		pop	ebp
		retn
sub_10013A5E	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013AC4	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)+3Cp
		mov	edx, [ecx]
		xor	eax, eax
		mov	ecx, [ecx+4]
		push	esi
		push	edi
		mov	esi, ecx
		mov	edi, 7FF00000h
		and	esi, edi
		cmp	eax, eax
		jnz	short loc_10013AE9
		cmp	esi, edi
		jnz	short loc_10013AE9
		and	ecx, 0FFFFFh
		or	edx, ecx
		jnz	short loc_10013AE9
		inc	eax

loc_10013AE9:				; CODE XREF: sub_10013AC4+14j
					; sub_10013AC4+18j ...
		pop	edi
		pop	esi
		retn
sub_10013AC4	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013AEC	proc near		; CODE XREF: double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)+79p
		mov	edx, [ecx]
		xor	eax, eax
		mov	ecx, [ecx+4]
		push	esi
		push	edi
		mov	esi, ecx
		mov	edi, 7FF00000h
		and	esi, edi
		cmp	eax, eax
		jnz	short loc_10013B11
		cmp	esi, edi
		jnz	short loc_10013B11
		and	ecx, 0FFFFFh
		or	edx, ecx
		jz	short loc_10013B11
		inc	eax

loc_10013B11:				; CODE XREF: sub_10013AEC+14j
					; sub_10013AEC+18j ...
		pop	edi
		pop	esi
		retn
sub_10013AEC	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013B14	proc near		; CODE XREF: sub_10008958+4EC8p
					; sub_10013E1E+5Cp
		test	dword ptr [ecx], 7FFFFFh
		jnz	short loc_10013B2C
		call	sub_10013264
		cmp	eax, 0FFFFFF6Bh
		jz	short loc_10013B2C
		xor	eax, eax
		inc	eax
		retn
; ---------------------------------------------------------------------------

loc_10013B2C:				; CODE XREF: sub_10013B14+6j
					; sub_10013B14+12j
		xor	eax, eax
		retn
sub_10013B14	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013B2F	proc near		; CODE XREF: sub_10013676+106p
		push	ebx
		push	ebp
		push	esi
		mov	ebx, ecx
		push	edi
		push	5
		pop	ebp
		mov	eax, [ebx+8]
		mul	ebp
		push	0
		mov	esi, eax
		mov	ecx, edx
		mov	eax, [ebx+0Ch]
		mul	ebp
		pop	ebp
		add	eax, ecx
		mov	edi, edx
		push	5
		adc	edi, ebp
		xor	ecx, ecx
		add	ecx, esi
		mov	[ebx+8], ecx
		adc	eax, ebp
		mov	[ebx+0Ch], eax
		mov	eax, [ebx]
		pop	ecx
		mul	ecx
		push	5
		mov	esi, eax
		mov	ecx, edx
		mov	eax, [ebx+4]
		add	esi, edi
		pop	edx
		adc	ecx, ebp
		mul	edx
		pop	edi
		add	eax, ecx
		xor	ecx, ecx
		add	ecx, esi
		pop	esi
		adc	eax, ebp
		mov	[ebx], ecx
		pop	ebp
		mov	[ebx+4], eax
		pop	ebx
		retn	4
sub_10013B2F	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013B86	proc near		; CODE XREF: sub_100128FF+4Dp
					; sub_100128FF+8Bp ...

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		sub	esp, 34h
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+34h+var_4], eax
		push	ebx
		mov	ebx, [esp+38h+arg_0]
		mov	[esp+38h+var_34], 5
		mov	[esp+38h+var_30], 19h
		mov	[esp+38h+var_2C], 7Dh
		mov	[esp+38h+var_28], 271h
		mov	[esp+38h+var_24], 0C35h
		mov	[esp+38h+var_20], 3D09h
		mov	[esp+38h+var_1C], 1312Dh
		mov	[esp+38h+var_18], 5F5E1h
		mov	[esp+38h+var_14], 1DCD65h
		mov	[esp+38h+var_10], 9502F9h
		mov	[esp+38h+var_C], 2E90EDDh
		mov	[esp+38h+var_8], 0E8D4A51h
		push	edi
		mov	edi, ecx
		test	ebx, ebx
		jz	short loc_10013C71
		cmp	dword ptr [edi+208h], 0
		jz	short loc_10013C71
		push	ebp
		push	esi
		push	1Bh
		pop	ecx
		mov	esi, ebx
		cmp	ebx, ecx
		jl	short loc_10013C35
		xor	edx, edx
		mov	eax, ebx
		div	ecx
		mov	ebp, eax
		imul	ecx, ebp, 1Bh
		sub	esi, ecx

loc_10013C21:				; CODE XREF: sub_10013B86+ADj
		push	6765C793h
		push	0FA10079Dh
		mov	ecx, edi
		call	sub_10013C84
		dec	ebp
		jnz	short loc_10013C21

loc_10013C35:				; CODE XREF: sub_10013B86+8Cj
		push	0Dh
		pop	ecx
		cmp	esi, ecx
		jl	short loc_10013C58
		mov	eax, esi
		xor	edx, edx
		div	ecx
		mov	ebp, eax
		imul	ecx, ebp, -0Dh
		add	esi, ecx

loc_10013C49:				; CODE XREF: sub_10013B86+D0j
		push	48C27395h
		mov	ecx, edi
		call	sub_10009096
		dec	ebp
		jnz	short loc_10013C49

loc_10013C58:				; CODE XREF: sub_10013B86+B4j
		test	esi, esi
		jle	short loc_10013C67
		push	[esp+esi*4+44h+var_38]
		mov	ecx, edi
		call	sub_10009096

loc_10013C67:				; CODE XREF: sub_10013B86+D4j
		push	ebx
		mov	ecx, edi
		call	sub_1000911A
		pop	esi
		pop	ebp

loc_10013C71:				; CODE XREF: sub_10013B86+78j
					; sub_10013B86+81j
		mov	ecx, [esp+3Ch+var_4]
		pop	edi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 34h
		retn	4
sub_10013B86	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013C84	proc near		; CODE XREF: sub_100139F5+37p
					; sub_10013B86+A7p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		sub	esp, 10h
		push	ebx
		mov	ebx, ecx
		xor	ecx, ecx
		cmp	[esp+14h+arg_0], 1
		mov	[esp+14h+var_4], ebx
		jnz	short loc_10013CA1
		cmp	[esp+14h+arg_4], ecx
		jz	loc_10013D9E

loc_10013CA1:				; CODE XREF: sub_10013C84+11j
		mov	eax, [esp+14h+arg_0]
		or	eax, [esp+14h+arg_4]
		jnz	short loc_10013CB7
		mov	ecx, ebx
		call	sub_10008E60
		jmp	loc_10013D9E
; ---------------------------------------------------------------------------

loc_10013CB7:				; CODE XREF: sub_10013C84+25j
		mov	eax, ecx
		mov	[esp+14h+var_C], ecx
		push	ebp
		mov	ebp, ecx
		mov	[esp+18h+var_10], eax
		cmp	[ebx+208h], ecx
		jle	loc_10013D9D
		push	esi
		push	edi

loc_10013CD2:				; CODE XREF: sub_10013C84+D8j
		mov	esi, [ebx+200h]
		push	ecx
		push	[esp+24h+arg_4]
		push	ecx
		push	dword ptr [esi+eax*4]
		call	__allmul
		xor	ebx, ebx
		mov	[esp+20h+var_8], edx
		push	ebx
		push	[esp+24h+arg_0]
		mov	edi, eax
		mov	eax, [esp+28h+var_10]
		push	ebx
		push	dword ptr [esi+eax*4]
		call	__allmul
		mov	ecx, [esp+20h+var_C]
		and	ecx, 0FFFFFFFh
		add	eax, ecx
		mov	ecx, eax
		adc	edx, ebx
		and	ecx, 0FFFFFFFh
		mov	ebx, [esp+20h+var_10]
		shrd	eax, edx, 1Ch
		push	0
		shr	edx, 1Ch
		mov	[esi+ebx*4], ecx
		mov	ebx, [esp+24h+var_8]
		mov	esi, [esp+24h+var_C]
		shld	ebx, edi, 4
		pop	ecx
		shl	edi, 4
		add	eax, edi
		adc	edx, ebx
		mov	ebx, [esp+20h+var_4]
		shrd	esi, ebp, 1Ch
		shr	ebp, 1Ch
		add	esi, eax
		mov	eax, [esp+20h+var_10]
		adc	ebp, edx
		mov	[esp+20h+var_C], esi
		inc	eax
		mov	[esp+20h+var_10], eax
		cmp	eax, [ebx+208h]
		jl	loc_10013CD2
		jmp	short loc_10013D95
; ---------------------------------------------------------------------------

loc_10013D64:				; CODE XREF: sub_10013C84+115j
		mov	eax, [ebx+208h]
		inc	eax
		push	eax
		call	sub_10009240
		mov	ecx, [ebx+208h]
		mov	edx, esi
		mov	eax, [ebx+200h]
		and	edx, 0FFFFFFFh
		shrd	esi, ebp, 1Ch
		mov	[eax+ecx*4], edx
		inc	dword ptr [ebx+208h]
		shr	ebp, 1Ch

loc_10013D95:				; CODE XREF: sub_10013C84+DEj
		mov	eax, esi
		or	eax, ebp
		jnz	short loc_10013D64
		pop	edi
		pop	esi

loc_10013D9D:				; CODE XREF: sub_10013C84+46j
		pop	ebp

loc_10013D9E:				; CODE XREF: sub_10013C84+17j
					; sub_10013C84+2Ej
		pop	ebx
		add	esp, 10h
		retn	8
sub_10013C84	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013DA5	proc near		; CODE XREF: sub_100148CE+17Dp

var_10		= qword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	ebx
		mov	ebx, ecx
		push	esi
		push	edi
		mov	edi, [ebx]
		mov	esi, [ebx+4]
		test	edi, edi
		jnz	short loc_10013DCA
		mov	eax, 7FF00000h
		cmp	esi, eax
		jnz	short loc_10013DCA
		and	[ebp+var_8], edi
		mov	[ebp+var_4], eax
		jmp	short loc_10013E01
; ---------------------------------------------------------------------------

loc_10013DCA:				; CODE XREF: sub_10013DA5+12j
					; sub_10013DA5+1Bj
		call	sub_10009DC6
		test	eax, eax
		jns	short loc_10013DE2
		mov	ecx, ebx
		call	sub_10009CA5
		or	eax, edx
		jnz	short loc_10013DE2
		fldz
		jmp	short loc_10013E17
; ---------------------------------------------------------------------------

loc_10013DE2:				; CODE XREF: sub_10013DA5+2Cj
					; sub_10013DA5+37j
		mov	ecx, ebx
		call	sub_10009DC6
		test	eax, eax
		jns	short loc_10013DF5
		add	edi, 0FFFFFFFFh
		adc	esi, 0FFFFFFFFh
		jmp	short loc_10013DFB
; ---------------------------------------------------------------------------

loc_10013DF5:				; CODE XREF: sub_10013DA5+46j
		add	edi, 1
		adc	esi, 0

loc_10013DFB:				; CODE XREF: sub_10013DA5+4Ej
		mov	[ebp+var_4], esi
		mov	[ebp+var_8], edi

loc_10013E01:				; CODE XREF: sub_10013DA5+23j
		push	8		; size_t
		lea	eax, [ebp+var_8]
		push	eax		; void *
		lea	eax, [ebp+var_10]
		push	eax		; void *
		call	ds:memmove
		fld	[ebp+var_10]
		add	esp, 0Ch

loc_10013E17:				; CODE XREF: sub_10013DA5+3Bj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
sub_10013DA5	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013E1E	proc near		; CODE XREF: sub_1000999E+43D7p

var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_14		= byte ptr -14h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		sub	esp, 44h
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	ebx, ecx
		call	sub_10014161
		mov	ecx, ebx
		mov	ebp, eax
		xor	esi, esi
		call	sub_10013264
		mov	edi, eax
		mov	ecx, esi
		mov	eax, ebp
		mov	[esp+54h+var_40], edi
		shld	ecx, eax, 1
		add	eax, eax
		mov	[esp+54h+var_38], ecx
		mov	[esp+54h+var_3C], eax
		add	eax, 1
		mov	[esp+54h+var_34], eax
		lea	eax, [edi-1]
		adc	ecx, esi
		mov	[esp+54h+var_2C], eax
		mov	[esp+54h+var_30], ecx
		lea	esi, [esp+54h+var_34]
		lea	edi, [esp+54h+var_14]
		movsd
		lea	ecx, [esp+54h+var_14]
		movsd
		movsd
		movsd
		call	sub_10009F25
		mov	ecx, ebx
		call	sub_10013B14
		lea	esi, [esp+54h+var_24]
		lea	edi, [esp+54h+var_34]
		test	al, al
		jz	short loc_10013EAB
		xor	eax, eax
		shld	eax, ebp, 2
		shl	ebp, 2
		add	ebp, 0FFFFFFFFh
		mov	[esp+54h+var_24], ebp
		adc	eax, 0FFFFFFFFh
		mov	[esp+54h+var_20], eax
		mov	eax, [esp+54h+var_40]
		add	eax, 0FFFFFFFEh
		jmp	short loc_10013EC6
; ---------------------------------------------------------------------------

loc_10013EAB:				; CODE XREF: sub_10013E1E+6Bj
		mov	eax, [esp+54h+var_3C]
		mov	ecx, [esp+54h+var_38]
		add	eax, 0FFFFFFFFh
		mov	[esp+54h+var_24], eax
		mov	eax, [esp+54h+var_40]
		adc	ecx, 0FFFFFFFFh
		mov	[esp+54h+var_20], ecx
		dec	eax

loc_10013EC6:				; CODE XREF: sub_10013E1E+8Bj
		mov	[esp+54h+var_1C], eax
		movsd
		movsd
		movsd
		movsd
		mov	ecx, [esp+54h+var_2C]
		mov	esi, [esp+54h+var_C]
		sub	ecx, esi
		mov	eax, [esp+54h+var_34]
		mov	edx, [esp+54h+var_30]
		call	__allshl
		mov	edi, [esp+54h+arg_4]
		mov	[esp+54h+var_2C], esi
		lea	esi, [esp+54h+var_14]
		mov	[esp+54h+var_34], eax
		mov	[esp+54h+var_30], edx
		movsd
		movsd
		movsd
		movsd
		mov	edi, [esp+54h+arg_0]
		lea	esi, [esp+54h+var_34]
		movsd
		movsd
		movsd
		movsd
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 44h
		retn	8
sub_10013E1E	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013F13	proc near		; CODE XREF: mozPoisonValueInit+3483p

SystemInfo	= _SYSTEM_INFO ptr -24h

		push	ebp
		mov	ebp, esp
		sub	esp, 24h
		push	esi
		push	edi
		lea	eax, [ebp+SystemInfo]
		mov	edi, edx
		push	eax		; lpSystemInfo
		mov	esi, ecx
		call	ds:GetSystemInfo
		cmp	esi, [ebp+SystemInfo.lpMaximumApplicationAddress]
		jb	short loc_10013F3A
		lea	eax, [esi+edi]
		cmp	eax, [ebp+SystemInfo.lpMaximumApplicationAddress]
		jb	short loc_10013F3A
		mov	al, 1
		jmp	short loc_10013F3C
; ---------------------------------------------------------------------------

loc_10013F3A:				; CODE XREF: sub_10013F13+19j
					; sub_10013F13+21j
		xor	al, al

loc_10013F3C:				; CODE XREF: sub_10013F13+25j
		pop	edi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
sub_10013F13	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013F42	proc near		; CODE XREF: sub_10012D4D+2Ep

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		sub	esp, 1Ch
		push	ebx
		mov	ebx, [esp+20h+arg_4]
		push	ebp
		push	esi
		mov	esi, [esp+28h+arg_0]
		mov	ebp, edx
		push	edi
		mov	edi, ecx
		lea	ecx, [esp+2Ch+var_18]
		push	ebx
		push	esi
		call	sub_10013FED
		pop	ecx
		pop	ecx
		mov	ecx, [esp+2Ch+var_18]
		cmp	ebx, ecx
		jnz	short loc_10013F75
		and	[esp+2Ch+var_C], 0
		and	dword ptr [ebp+0], 0
		jmp	short loc_10013F8B
; ---------------------------------------------------------------------------

loc_10013F75:				; CODE XREF: sub_10013F42+26j
		cmp	byte ptr [esi+ecx], 35h
		jl	short loc_10013F81
		add	eax, 1
		adc	edx, 0

loc_10013F81:				; CODE XREF: sub_10013F42+37j
		and	[esp+2Ch+var_C], 0
		sub	ebx, ecx
		mov	[ebp+0], ebx

loc_10013F8B:				; CODE XREF: sub_10013F42+31j
		mov	[esp+2Ch+var_14], eax
		lea	esi, [esp+2Ch+var_14]
		mov	[esp+2Ch+var_10], edx
		movsd
		movsd
		movsd
		movsd
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 1Ch
		retn
sub_10013F42	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013FA3	proc near		; CODE XREF: sub_100128FF+3Bp
					; sub_100128FF+7Dp

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		push	ecx
		push	ebx
		mov	ebx, ecx
		xor	ecx, ecx
		push	ebp
		xor	ebp, ebp
		lea	eax, [ebx+edx]
		mov	[esp+0Ch+var_4], eax
		cmp	ebx, eax
		jge	short loc_10013FE5
		push	esi
		push	edi

loc_10013FB9:				; CODE XREF: sub_10013FA3+3Ej
		mov	eax, [esp+14h+arg_0]
		push	0
		push	0Ah
		push	ebp
		movsx	eax, byte ptr [eax+ebx]
		sub	eax, 30h
		cdq
		push	ecx
		mov	esi, eax
		mov	edi, edx
		call	__allmul
		add	esi, eax
		mov	ecx, esi
		adc	edi, edx
		inc	ebx
		mov	ebp, edi
		cmp	ebx, [esp+14h+var_4]
		jl	short loc_10013FB9
		pop	edi
		pop	esi

loc_10013FE5:				; CODE XREF: sub_10013FA3+12j
		mov	edx, ebp
		mov	eax, ecx
		pop	ebp
		pop	ebx
		pop	ecx
		retn
sub_10013FA3	endp


; =============== S U B	R O U T	I N E =======================================


sub_10013FED	proc near		; CODE XREF: sub_10013162+2Dp
					; sub_10013162+7Fp ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ecx
		push	ebx
		mov	eax, ecx
		xor	ebx, ebx
		push	ebp
		xor	ecx, ecx
		mov	[esp+0Ch+var_4], eax
		xor	ebp, ebp
		cmp	[esp+0Ch+arg_4], ecx
		jle	short loc_10014048
		push	esi
		push	edi

loc_10014004:				; CODE XREF: sub_10013FED+53j
		cmp	ebx, 19999999h
		ja	short loc_10014042
		jb	short loc_10014016
		cmp	ecx, 99999998h
		ja	short loc_10014042

loc_10014016:				; CODE XREF: sub_10013FED+1Fj
		mov	edx, [esp+14h+arg_0]
		mov	eax, ebp
		push	0
		push	0Ah
		push	ebx
		movsx	eax, byte ptr [eax+edx]
		inc	ebp
		sub	eax, 30h
		cdq
		push	ecx
		mov	esi, eax
		mov	edi, edx
		call	__allmul
		add	esi, eax
		mov	ecx, esi
		adc	edi, edx
		mov	ebx, edi
		cmp	ebp, [esp+14h+arg_4]
		jl	short loc_10014004

loc_10014042:				; CODE XREF: sub_10013FED+1Dj
					; sub_10013FED+27j
		mov	eax, [esp+14h+var_4]
		pop	edi
		pop	esi

loc_10014048:				; CODE XREF: sub_10013FED+13j
		mov	[eax], ebp
		mov	edx, ebx
		pop	ebp
		mov	eax, ecx
		pop	ebx
		pop	ecx
		retn
sub_10013FED	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10014052	proc near		; CODE XREF: sub_10013676+164p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	esi
		mov	esi, [ecx]
		test	esi, esi
		jnz	short loc_1001406B
		mov	byte ptr [eax],	31h
		xor	eax, eax
		inc	eax
		mov	[edx], eax
		mov	[ecx], eax
		jmp	short loc_10014096
; ---------------------------------------------------------------------------

loc_1001406B:				; CODE XREF: sub_10014052+Bj
		inc	byte ptr [esi+eax-1]
		mov	ecx, [ecx]
		jmp	short loc_10014084
; ---------------------------------------------------------------------------

loc_10014073:				; CODE XREF: sub_10014052+38j
		cmp	byte ptr [eax+ecx], 3Ah
		jnz	short loc_10014096
		mov	byte ptr [eax+ecx], 30h
		mov	eax, [ebp+arg_0]
		inc	byte ptr [eax+ecx-1]

loc_10014084:				; CODE XREF: sub_10014052+1Fj
		mov	eax, [ebp+arg_0]
		dec	ecx
		test	ecx, ecx
		jg	short loc_10014073
		cmp	byte ptr [eax],	3Ah
		jnz	short loc_10014096
		mov	byte ptr [eax],	31h
		inc	dword ptr [edx]

loc_10014096:				; CODE XREF: sub_10014052+17j
					; sub_10014052+25j ...
		pop	esi
		pop	ebp
		retn
sub_10014052	endp


; =============== S U B	R O U T	I N E =======================================


sub_10014099	proc near		; CODE XREF: sub_10013676+D7p

arg_0		= dword	ptr  4

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	edi
		mov	edi, ecx
		test	ebx, ebx
		jz	loc_1001415C
		cmp	ebx, 0FFFFFFC0h
		jnz	short loc_100140C6
		mov	eax, [edi+8]
		and	dword ptr [edi+8], 0
		mov	[edi], eax
		mov	eax, [edi+0Ch]
		and	dword ptr [edi+0Ch], 0
		mov	[edi+4], eax
		jmp	loc_1001415C
; ---------------------------------------------------------------------------

loc_100140C6:				; CODE XREF: sub_10014099+13j
		push	esi
		push	40h
		pop	esi
		cmp	ebx, esi
		jnz	short loc_100140E2
		mov	eax, [edi]
		and	dword ptr [edi], 0
		mov	[edi+8], eax
		mov	eax, [edi+4]
		and	dword ptr [edi+4], 0
		mov	[edi+0Ch], eax
		jmp	short loc_1001415B
; ---------------------------------------------------------------------------

loc_100140E2:				; CODE XREF: sub_10014099+33j
		test	ebx, ebx
		jg	short loc_10014123
		mov	eax, [edi]
		mov	esi, ebx
		mov	edx, [edi+4]
		neg	esi
		mov	ecx, esi
		call	__allshl
		mov	[edi], eax
		lea	ecx, [ebx+40h]
		mov	eax, [edi+8]
		mov	[edi+4], edx
		mov	edx, [edi+0Ch]
		call	__aullshr
		add	[edi], eax
		mov	ecx, esi
		mov	eax, [edi+8]
		adc	[edi+4], edx
		mov	edx, [edi+0Ch]
		call	__allshl
		mov	[edi+8], eax
		mov	[edi+0Ch], edx
		jmp	short loc_1001415B
; ---------------------------------------------------------------------------

loc_10014123:				; CODE XREF: sub_10014099+4Bj
		mov	eax, [edi+8]
		mov	ecx, ebx
		mov	edx, [edi+0Ch]
		call	__aullshr
		mov	[edi+8], eax
		sub	esi, ebx
		mov	eax, [edi]
		mov	ecx, esi
		mov	[edi+0Ch], edx
		mov	edx, [edi+4]
		call	__allshl
		add	[edi+8], eax
		mov	ecx, ebx
		mov	eax, [edi]
		adc	[edi+0Ch], edx
		mov	edx, [edi+4]
		call	__aullshr
		mov	[edi], eax
		mov	[edi+4], edx

loc_1001415B:				; CODE XREF: sub_10014099+47j
					; sub_10014099+88j
		pop	esi

loc_1001415C:				; CODE XREF: sub_10014099+Aj
					; sub_10014099+28j
		pop	edi
		pop	ebx
		retn	4
sub_10014099	endp


; =============== S U B	R O U T	I N E =======================================


sub_10014161	proc near		; CODE XREF: sub_10008958+4E66p
					; sub_10013E1E+9p
		mov	eax, [ecx]
		and	eax, 7FFFFFh
		test	dword ptr [ecx], 7F800000h
		jz	short locret_10014175
		add	eax, 800000h

locret_10014175:			; CODE XREF: sub_10014161+Dj
		retn
sub_10014161	endp


; =============== S U B	R O U T	I N E =======================================


sub_10014176	proc near		; CODE XREF: sub_10012D4D+20Ap
		cmp	ecx, 0FFFFFC03h
		jl	short loc_10014182
		push	35h
		pop	eax
		retn
; ---------------------------------------------------------------------------

loc_10014182:				; CODE XREF: sub_10014176+6j
		cmp	ecx, 0FFFFFBCEh
		jg	short loc_1001418D
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1001418D:				; CODE XREF: sub_10014176+12j
		lea	eax, [ecx+432h]
		retn
sub_10014176	endp


; =============== S U B	R O U T	I N E =======================================


sub_10014194	proc near		; CODE XREF: sub_10008FB5+4B0Fp

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		sub	esp, 1Ch
		push	ebp
		push	esi
		mov	esi, ecx
		mov	[esp+24h+var_C], esi
		mov	ebp, [esi+208h]
		add	ebp, ebp
		push	ebp
		mov	[esp+28h+var_1C], ebp
		call	sub_10009240
		mov	eax, [esi+208h]
		mov	[esp+24h+var_10], eax
		cmp	eax, 100h
		jl	short loc_100141DC
		int	3		; Trap to Debugger
		push	3		; uExitCode
		mov	large dword ptr	ds:0, 166h
		call	ds:GetCurrentProcess
		push	eax		; hProcess
		call	ds:TerminateProcess

loc_100141DC:				; CODE XREF: sub_10014194+2Cj
		push	ebx
		push	edi
		xor	edi, edi
		mov	ebx, edi
		mov	edx, edi
		test	eax, eax
		jle	short loc_1001420D
		mov	ebp, eax
		shl	ebp, 2

loc_100141ED:				; CODE XREF: sub_10014194+6Fj
		mov	ecx, [esi+200h]
		mov	eax, [ecx+edx*4]
		inc	edx
		mov	[ecx+ebp], eax
		lea	ebp, [ebp+4]
		cmp	edx, [esi+208h]
		jl	short loc_100141ED
		mov	ebp, [esp+2Ch+var_1C]
		mov	eax, [esp+2Ch+var_10]

loc_1001420D:				; CODE XREF: sub_10014194+52j
		mov	edx, edi
		mov	[esp+2Ch+var_18], edx
		cmp	[esi+208h], edi
		jle	short loc_1001428F
		shl	eax, 2
		mov	[esp+2Ch+var_8], eax
		mov	[esp+2Ch+var_14], eax

loc_10014226:				; CODE XREF: sub_10014194+F5j
		mov	ecx, edx
		test	edx, edx
		js	short loc_1001425B
		mov	edx, [esi+200h]
		mov	ebp, eax
		mov	esi, [esp+2Ch+var_8]
		mov	[esp+2Ch+var_4], edx

loc_1001423C:				; CODE XREF: sub_10014194+BDj
		mov	eax, [esi+edx]
		lea	esi, [esi+4]
		mul	dword ptr [edx+ebp]
		lea	ebp, [ebp-4]
		add	edi, eax
		adc	ebx, edx
		dec	ecx
		mov	edx, [esp+2Ch+var_4]
		jns	short loc_1001423C
		mov	esi, [esp+2Ch+var_C]
		mov	edx, [esp+2Ch+var_18]

loc_1001425B:				; CODE XREF: sub_10014194+96j
		mov	eax, [esi+200h]
		mov	ecx, edi
		and	ecx, 0FFFFFFFh
		shrd	edi, ebx, 1Ch
		mov	[eax+edx*4], ecx
		mov	eax, [esp+2Ch+var_14]
		shr	ebx, 1Ch
		add	eax, 4
		inc	edx
		mov	[esp+2Ch+var_14], eax
		mov	[esp+2Ch+var_18], edx
		cmp	edx, [esi+208h]
		jl	short loc_10014226
		mov	ebp, [esp+2Ch+var_1C]

loc_1001428F:				; CODE XREF: sub_10014194+85j
		mov	edx, [esi+208h]
		jmp	loc_1001431B
; ---------------------------------------------------------------------------

loc_1001429A:				; CODE XREF: sub_10014194+18Dj
		mov	ecx, [esi+208h]
		lea	eax, [ecx-1]
		mov	[esp+2Ch+var_4], eax
		mov	eax, edx
		sub	eax, [esp+2Ch+var_4]
		mov	[esp+2Ch+var_4], eax
		cmp	eax, ecx
		jge	short loc_10014302
		mov	eax, [esi+200h]
		mov	[esp+2Ch+var_18], eax
		mov	eax, [esp+2Ch+var_10]
		lea	edx, [eax-1]
		add	edx, ecx
		shl	edx, 2
		mov	[esp+2Ch+var_8], edx
		mov	edx, [esp+2Ch+var_4]
		mov	ebp, [esp+2Ch+var_8]
		lea	esi, [edx+eax]
		shl	esi, 2
		sub	ecx, edx

loc_100142DF:				; CODE XREF: sub_10014194+160j
		mov	edx, [esp+2Ch+var_18]
		mov	eax, [esi+edx]
		lea	esi, [esi+4]
		mul	dword ptr [edx+ebp]
		lea	ebp, [ebp-4]
		add	edi, eax
		adc	ebx, edx
		dec	ecx
		jnz	short loc_100142DF
		mov	esi, [esp+2Ch+var_C]
		mov	ebp, [esp+2Ch+var_1C]
		mov	edx, [esp+2Ch+var_14]

loc_10014302:				; CODE XREF: sub_10014194+11Fj
		mov	eax, [esi+200h]
		mov	ecx, edi
		shrd	edi, ebx, 1Ch
		and	ecx, 0FFFFFFFh
		shr	ebx, 1Ch
		mov	[eax+edx*4], ecx
		inc	edx

loc_1001431B:				; CODE XREF: sub_10014194+101j
		mov	[esp+2Ch+var_14], edx
		cmp	edx, ebp
		jl	loc_1001429A
		shl	dword ptr [esi+20Ch], 1
		mov	ecx, esi
		pop	edi
		pop	ebx
		mov	[esi+208h], ebp
		pop	esi
		pop	ebp
		add	esp, 1Ch
		jmp	sub_10008E7F
sub_10014194	endp


; =============== S U B	R O U T	I N E =======================================


sub_10014341	proc near		; CODE XREF: sub_100112F7+53p

var_364		= qword	ptr -364h
var_34A		= byte ptr -34Ah
var_349		= byte ptr -349h
var_348		= dword	ptr -348h
var_341		= byte ptr -341h
var_340		= dword	ptr -340h
var_33C		= byte ptr -33Ch
var_338		= dword	ptr -338h
var_32C		= byte ptr -32Ch
var_328		= dword	ptr -328h
var_324		= dword	ptr -324h
var_320		= dword	ptr -320h
var_31C		= dword	ptr -31Ch
var_318		= byte ptr -318h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		sub	esp, 34Ch
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+34Ch+var_4], eax
		mov	eax, [esp+34Ch+arg_4]
		push	ebx
		push	ebp
		mov	ebp, [esp+354h+arg_0]
		push	esi
		push	edi
		mov	edi, ecx
		mov	[esp+35Ch+var_324], ebp
		mov	ecx, [esp+35Ch+arg_8]
		lea	ebx, [eax+ebp]
		mov	[esp+35Ch+var_328], ecx
		mov	esi, ebp
		mov	[esp+35Ch+var_348], esi
		and	dword ptr [ecx], 0
		mov	al, [edi]
		mov	dl, [edi]
		mov	cl, [edi]
		shr	al, 2
		and	al, 1
		shr	dl, 4
		mov	[esp+35Ch+var_33C], al
		and	dl, 1
		mov	al, [edi]
		shr	al, 3
		shr	cl, 5
		and	al, 1
		and	cl, 1
		mov	[esp+35Ch+var_34A], al
		mov	[esp+35Ch+var_341], dl
		mov	[esp+35Ch+var_349], cl
		cmp	ebp, ebx
		jnz	short loc_100143BE

loc_100143B6:				; CODE XREF: sub_10014341+A0j
		fld	qword ptr [edi+8]
		jmp	loc_1001448B
; ---------------------------------------------------------------------------

loc_100143BE:				; CODE XREF: sub_10014341+73j
		test	al, al
		jnz	short loc_100143C6
		test	dl, dl
		jz	short loc_100143F6

loc_100143C6:				; CODE XREF: sub_10014341+7Fj
		mov	edx, ebx
		lea	ecx, [esp+35Ch+var_348]
		call	sub_100128E7
		test	al, al
		jnz	short loc_100143E3
		mov	ecx, [esp+35Ch+var_328]
		mov	eax, [esp+35Ch+var_348]
		sub	eax, ebp
		mov	[ecx], eax
		jmp	short loc_100143B6
; ---------------------------------------------------------------------------

loc_100143E3:				; CODE XREF: sub_10014341+92j
		cmp	[esp+35Ch+var_34A], 0
		mov	esi, [esp+35Ch+var_348]
		jnz	short loc_100143F6
		cmp	ebp, esi
		jnz	loc_10014488

loc_100143F6:				; CODE XREF: sub_10014341+83j
					; sub_10014341+ABj
		xor	eax, eax
		mov	edx, eax
		mov	[esp+35Ch+var_338], eax
		mov	ebp, eax
		mov	[esp+35Ch+var_320], eax
		mov	[esp+35Ch+var_34A], al
		mov	[esp+35Ch+var_32C], al
		mov	al, [esi]
		mov	[esp+35Ch+var_340], edx
		cmp	al, 2Bh
		jz	short loc_1001441A
		cmp	al, 2Dh
		jnz	short loc_1001444C

loc_1001441A:				; CODE XREF: sub_10014341+D3j
		cmp	al, 2Dh
		lea	ecx, [esp+35Ch+var_348]
		mov	edx, ebx
		setz	[esp+35Ch+var_32C]
		inc	esi
		mov	[esp+35Ch+var_348], esi
		call	sub_100128E7
		test	al, al
		jz	short loc_10014488
		cmp	[esp+35Ch+var_349], 0
		jnz	short loc_10014442
		cmp	esi, [esp+35Ch+var_348]
		jnz	short loc_10014488

loc_10014442:				; CODE XREF: sub_10014341+F9j
		mov	esi, [esp+35Ch+var_348]
		mov	edx, ebp
		mov	[esp+35Ch+var_348], esi

loc_1001444C:				; CODE XREF: sub_10014341+D7j
		mov	ecx, [edi+18h]
		test	ecx, ecx
		jz	loc_100144FA
		mov	al, [esi]
		cmp	al, [ecx]
		jnz	loc_100144FA
		push	ecx
		mov	edx, ebx
		lea	ecx, [esp+360h+var_348]
		call	sub_10012B6D
		add	esp, 4
		test	al, al
		jz	short loc_10014488
		cmp	[esp+35Ch+var_341], 0
		jnz	short loc_100144A6
		cmp	[esp+35Ch+var_33C], 0
		jnz	short loc_100144BC
		cmp	[esp+35Ch+var_348], ebx
		jz	short loc_100144AD

loc_10014488:				; CODE XREF: sub_10014341+AFj
					; sub_10014341+F2j ...
		fld	qword ptr [edi+10h]

loc_1001448B:				; CODE XREF: sub_10014341+78j
					; sub_10014341+1B3j ...
		mov	ecx, [esp+35Ch+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 34Ch
		retn	10h
; ---------------------------------------------------------------------------

loc_100144A6:				; CODE XREF: sub_10014341+138j
		cmp	[esp+35Ch+var_33C], 0
		jnz	short loc_100144BC

loc_100144AD:				; CODE XREF: sub_10014341+145j
		mov	edx, ebx
		lea	ecx, [esp+35Ch+var_348]
		call	sub_100128E7
		test	al, al
		jnz	short loc_10014488

loc_100144BC:				; CODE XREF: sub_10014341+13Fj
					; sub_10014341+16Aj
		mov	[esp+35Ch+var_31C], 7FF00000h

loc_100144C4:				; CODE XREF: sub_10014341+218j
		mov	ecx, [esp+35Ch+var_328]
		mov	eax, [esp+35Ch+var_348]
		sub	eax, [esp+35Ch+var_324]
		and	[esp+35Ch+var_320], ebp
		mov	[ecx], eax
		lea	eax, [esp+35Ch+var_320]
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+364h+var_338]
		push	eax		; void *
		call	ds:memmove
		fld	qword ptr [esp+368h+var_338]
		add	esp, 0Ch

loc_100144EF:				; CODE XREF: sub_10014341+582j
		cmp	[esp+35Ch+var_32C], 0
		jz	short loc_1001448B
		fchs
		jmp	short loc_1001448B
; ---------------------------------------------------------------------------

loc_100144FA:				; CODE XREF: sub_10014341+110j
					; sub_10014341+11Aj
		mov	ecx, [edi+1Ch]
		test	ecx, ecx
		jz	short loc_1001455E
		mov	al, [esi]
		cmp	al, [ecx]
		jnz	short loc_1001455E
		push	ecx
		mov	edx, ebx
		lea	ecx, [esp+360h+var_348]
		call	sub_10012B6D
		add	esp, 4
		test	al, al
		jz	loc_10014488
		cmp	[esp+35Ch+var_341], 0
		jnz	short loc_10014537
		cmp	[esp+35Ch+var_33C], 0
		jnz	short loc_10014551
		cmp	[esp+35Ch+var_348], ebx
		jz	short loc_1001453E
		jmp	loc_10014488
; ---------------------------------------------------------------------------

loc_10014537:				; CODE XREF: sub_10014341+1E2j
		cmp	[esp+35Ch+var_33C], 0
		jnz	short loc_10014551

loc_1001453E:				; CODE XREF: sub_10014341+1EFj
		mov	edx, ebx
		lea	ecx, [esp+35Ch+var_348]
		call	sub_100128E7
		test	al, al
		jnz	loc_10014488

loc_10014551:				; CODE XREF: sub_10014341+1E9j
					; sub_10014341+1FBj
		mov	[esp+35Ch+var_31C], 7FF80000h
		jmp	loc_100144C4
; ---------------------------------------------------------------------------

loc_1001455E:				; CODE XREF: sub_10014341+1BEj
					; sub_10014341+1C4j
		xor	ah, ah
		cmp	byte ptr [esi],	30h
		jnz	loc_1001463B
		inc	esi
		mov	[esp+35Ch+var_348], esi
		cmp	esi, ebx
		jnz	short loc_10014595

loc_10014572:				; CODE XREF: sub_10014341+2E6j
					; sub_10014341+3E9j
		mov	ecx, [esp+35Ch+var_328]
		sub	esi, [esp+35Ch+var_324]
		cmp	[esp+35Ch+var_32C], 0
		mov	[ecx], esi
		jz	short loc_1001458E
		fld	ds:dbl_10016EB0
		jmp	loc_1001448B
; ---------------------------------------------------------------------------

loc_1001458E:				; CODE XREF: sub_10014341+240j
		fldz
		jmp	loc_1001448B
; ---------------------------------------------------------------------------

loc_10014595:				; CODE XREF: sub_10014341+22Fj
		mov	ah, 1
		test	[edi], ah
		jz	loc_1001462D
		mov	al, [esi]
		cmp	al, 78h
		jz	short loc_100145AD
		cmp	al, 58h
		jnz	loc_1001462D

loc_100145AD:				; CODE XREF: sub_10014341+262j
		inc	esi
		cmp	esi, ebx
		jz	loc_10014488
		movsx	ecx, byte ptr [esi]
		push	10h
		pop	edx
		call	sub_10014FD5
		test	al, al
		jz	loc_10014488
		fld	qword ptr [edi+10h]
		lea	eax, [esp+35Ch+var_338]
		and	[esp+35Ch+var_338], ebp
		mov	edx, ebx
		push	ecx
		push	ecx
		fstp	[esp+364h+var_364] ; double
		push	eax		; int
		push	ecx		; int
		push	dword ptr [esp+36Ch+var_33C] ; char
		mov	ecx, esi
		push	dword ptr [esp+370h+var_32C] ; char
		call	sub_100124B5
		mov	eax, [esp+374h+var_338]
		add	esp, 18h
		test	eax, eax
		jz	loc_1001448B
		cmp	[esp+35Ch+var_341], 0
		jz	short loc_10014611
		mov	edx, ebx
		lea	ecx, [esp+35Ch+var_338]
		call	sub_100128E7
		mov	eax, [esp+35Ch+var_338]

loc_10014611:				; CODE XREF: sub_10014341+2BFj
		mov	ecx, [esp+35Ch+var_328]
		sub	eax, [esp+35Ch+var_324]
		mov	[ecx], eax
		jmp	loc_1001448B
; ---------------------------------------------------------------------------

loc_10014620:				; CODE XREF: sub_10014341+2EFj
		inc	esi
		mov	[esp+35Ch+var_348], esi
		cmp	esi, ebx
		jz	loc_10014572

loc_1001462D:				; CODE XREF: sub_10014341+258j
					; sub_10014341+266j
		cmp	byte ptr [esi],	30h
		jz	short loc_10014620
		test	byte ptr [edi],	2
		jz	short loc_1001463B
		mov	cl, 1
		jmp	short loc_1001463D
; ---------------------------------------------------------------------------

loc_1001463B:				; CODE XREF: sub_10014341+222j
					; sub_10014341+2F4j
		xor	cl, cl

loc_1001463D:				; CODE XREF: sub_10014341+2F8j
		mov	al, [esi]
		mov	[esp+35Ch+var_349], cl
		cmp	al, 30h
		jl	short loc_1001469D

loc_10014647:				; CODE XREF: sub_10014341+356j
		cmp	al, 39h
		jg	short loc_10014699
		cmp	ebp, 304h
		jge	short loc_1001465E
		inc	[esp+35Ch+var_338]
		mov	[esp+ebp+35Ch+var_318],	al
		inc	ebp
		jmp	short loc_10014677
; ---------------------------------------------------------------------------

loc_1001465E:				; CODE XREF: sub_10014341+310j
		inc	[esp+35Ch+var_320]
		cmp	[esp+35Ch+var_34A], 0
		jnz	short loc_10014672
		mov	[esp+35Ch+var_34A], 0
		cmp	al, 30h
		jz	short loc_10014677

loc_10014672:				; CODE XREF: sub_10014341+326j
		mov	[esp+35Ch+var_34A], 1

loc_10014677:				; CODE XREF: sub_10014341+31Bj
					; sub_10014341+32Fj
		test	cl, cl
		jz	short loc_10014684
		cmp	byte ptr [esi],	38h
		jge	short loc_10014684
		mov	cl, 1
		jmp	short loc_10014686
; ---------------------------------------------------------------------------

loc_10014684:				; CODE XREF: sub_10014341+338j
					; sub_10014341+33Dj
		xor	cl, cl

loc_10014686:				; CODE XREF: sub_10014341+341j
		inc	esi
		mov	[esp+35Ch+var_349], cl
		mov	[esp+35Ch+var_348], esi
		cmp	esi, ebx
		jz	short loc_100146BB
		mov	al, [esi]
		cmp	al, 30h
		jge	short loc_10014647

loc_10014699:				; CODE XREF: sub_10014341+308j
		test	ebp, ebp
		jnz	short loc_100146A3

loc_1001469D:				; CODE XREF: sub_10014341+304j
		xor	cl, cl
		mov	[esp+35Ch+var_349], cl

loc_100146A3:				; CODE XREF: sub_10014341+35Aj
		cmp	byte ptr [esi],	2Eh
		jnz	loc_1001478D
		test	cl, cl
		jz	short loc_1001470C

loc_100146B0:				; CODE XREF: sub_10014341+46Cj
					; sub_10014341+475j ...
		cmp	[esp+35Ch+var_33C], 0

loc_100146B5:				; CODE XREF: sub_10014341+3DAj
		jz	loc_10014488

loc_100146BB:				; CODE XREF: sub_10014341+350j
					; sub_10014341+3D6j ...
		mov	ebp, [esp+35Ch+var_340]

loc_100146BF:				; CODE XREF: sub_10014341+4FEj
					; sub_10014341+531j ...
		add	ebp, [esp+35Ch+var_320]
		cmp	[esp+35Ch+var_349], 0
		jz	loc_1001488C
		fld	qword ptr [edi+10h]
		lea	eax, [esp+35Ch+var_320]
		and	[esp+35Ch+var_320], 0
		lea	edx, [esp+35Ch+var_318]
		add	edx, [esp+35Ch+var_338]
		push	ecx
		push	ecx
		fstp	[esp+364h+var_364] ; double
		push	eax		; int
		push	ecx		; int
		push	dword ptr [esp+36Ch+var_33C] ; char
		lea	ecx, [esp+370h+var_318]
		push	dword ptr [esp+370h+var_32C] ; char
		call	sub_1001226A
		mov	ecx, [esp+374h+var_328]
		add	esp, 18h
		sub	esi, [esp+35Ch+var_324]
		mov	[ecx], esi
		jmp	loc_1001448B
; ---------------------------------------------------------------------------

loc_1001470C:				; CODE XREF: sub_10014341+36Dj
		inc	esi
		mov	[esp+35Ch+var_348], esi
		cmp	esi, ebx
		jnz	short loc_1001471D
		test	ebp, ebp
		jnz	short loc_100146BB
		test	ah, ah
		jmp	short loc_100146B5
; ---------------------------------------------------------------------------

loc_1001471D:				; CODE XREF: sub_10014341+3D2j
		test	ebp, ebp
		jnz	short loc_1001473A
		jmp	short loc_10014735
; ---------------------------------------------------------------------------

loc_10014723:				; CODE XREF: sub_10014341+3F7j
		inc	esi
		mov	[esp+35Ch+var_348], esi
		cmp	esi, ebx
		jz	loc_10014572
		dec	edx
		mov	[esp+35Ch+var_340], edx

loc_10014735:				; CODE XREF: sub_10014341+3E0j
		cmp	byte ptr [esi],	30h
		jz	short loc_10014723

loc_1001473A:				; CODE XREF: sub_10014341+3DEj
		mov	al, [esi]
		cmp	al, 30h
		jl	short loc_1001478D

loc_10014740:				; CODE XREF: sub_10014341+446j
		cmp	al, 39h
		jg	short loc_10014789
		cmp	ebp, 304h
		jge	short loc_10014761
		mov	ecx, [esp+35Ch+var_338]
		mov	[esp+ecx+35Ch+var_318],	al
		inc	ecx
		inc	ebp
		mov	[esp+35Ch+var_338], ecx
		dec	edx
		mov	[esp+35Ch+var_340], edx
		jmp	short loc_10014776
; ---------------------------------------------------------------------------

loc_10014761:				; CODE XREF: sub_10014341+409j
		cmp	[esp+35Ch+var_34A], 0
		jnz	short loc_10014771
		mov	[esp+35Ch+var_34A], 0
		cmp	al, 30h
		jz	short loc_10014776

loc_10014771:				; CODE XREF: sub_10014341+425j
		mov	[esp+35Ch+var_34A], 1

loc_10014776:				; CODE XREF: sub_10014341+41Ej
					; sub_10014341+42Ej
		inc	esi
		mov	[esp+35Ch+var_348], esi
		cmp	esi, ebx
		jz	loc_100146BB
		mov	al, [esi]
		cmp	al, 30h
		jge	short loc_10014740

loc_10014789:				; CODE XREF: sub_10014341+401j
		mov	cl, [esp+35Ch+var_349]

loc_1001478D:				; CODE XREF: sub_10014341+365j
					; sub_10014341+3FDj
		test	ah, ah
		jnz	short loc_1001479D
		test	edx, edx
		jnz	short loc_1001479D
		test	ebp, ebp
		jz	loc_10014488

loc_1001479D:				; CODE XREF: sub_10014341+44Ej
					; sub_10014341+452j
		mov	al, [esi]
		cmp	al, 65h
		jz	short loc_100147AB
		cmp	al, 45h
		jnz	loc_1001482F

loc_100147AB:				; CODE XREF: sub_10014341+460j
		test	cl, cl
		jnz	loc_100146B0
		inc	esi
		cmp	esi, ebx
		jz	loc_100146B0
		mov	al, [esi]
		mov	dl, 2Bh
		cmp	al, dl
		jz	short loc_100147C8
		cmp	al, 2Dh
		jnz	short loc_100147D3

loc_100147C8:				; CODE XREF: sub_10014341+481j
		inc	esi
		mov	dl, al
		cmp	esi, ebx
		jz	loc_100146B0

loc_100147D3:				; CODE XREF: sub_10014341+485j
		mov	cl, [esi]
		cmp	cl, 30h
		jl	loc_100146B0
		cmp	cl, 39h
		jg	loc_100146B0
		xor	eax, eax
		mov	ebp, 6666666h

loc_100147EE:				; CODE XREF: sub_10014341+4D9j
		movsx	ecx, cl
		sub	ecx, 30h
		cmp	eax, ebp
		jl	short loc_10014806
		jnz	short loc_100147FF
		cmp	ecx, 3
		jle	short loc_10014806

loc_100147FF:				; CODE XREF: sub_10014341+4B7j
		mov	eax, 3FFFFFFFh
		jmp	short loc_1001480B
; ---------------------------------------------------------------------------

loc_10014806:				; CODE XREF: sub_10014341+4B5j
					; sub_10014341+4BCj
		imul	eax, 0Ah
		add	eax, ecx

loc_1001480B:				; CODE XREF: sub_10014341+4C3j
		inc	esi
		cmp	esi, ebx
		jz	short loc_1001481C
		mov	cl, [esi]
		cmp	cl, 30h
		jl	short loc_1001481C
		cmp	cl, 39h
		jle	short loc_100147EE

loc_1001481C:				; CODE XREF: sub_10014341+4CDj
					; sub_10014341+4D4j
		mov	[esp+35Ch+var_348], esi
		cmp	dl, 2Dh
		jnz	short loc_10014827
		neg	eax

loc_10014827:				; CODE XREF: sub_10014341+4E2j
		mov	ebp, [esp+35Ch+var_340]
		add	ebp, eax
		jmp	short loc_10014833
; ---------------------------------------------------------------------------

loc_1001482F:				; CODE XREF: sub_10014341+464j
		mov	ebp, [esp+35Ch+var_340]

loc_10014833:				; CODE XREF: sub_10014341+4ECj
		mov	al, [esp+35Ch+var_341]
		test	al, al
		jnz	short loc_1001484E
		cmp	[esp+35Ch+var_33C], al
		jnz	loc_100146BF
		cmp	esi, ebx
		jz	short loc_10014855
		jmp	loc_10014488
; ---------------------------------------------------------------------------

loc_1001484E:				; CODE XREF: sub_10014341+4F8j
		cmp	[esp+35Ch+var_33C], 0
		jnz	short loc_10014870

loc_10014855:				; CODE XREF: sub_10014341+506j
		mov	edx, ebx
		lea	ecx, [esp+35Ch+var_348]
		call	sub_100128E7
		test	al, al
		jnz	loc_10014488
		mov	esi, [esp+35Ch+var_348]
		mov	al, [esp+35Ch+var_341]

loc_10014870:				; CODE XREF: sub_10014341+512j
		test	al, al
		jz	loc_100146BF
		mov	edx, ebx
		lea	ecx, [esp+35Ch+var_348]
		call	sub_100128E7
		mov	esi, [esp+35Ch+var_348]
		jmp	loc_100146BF
; ---------------------------------------------------------------------------

loc_1001488C:				; CODE XREF: sub_10014341+387j
		cmp	[esp+35Ch+var_34A], 0
		mov	eax, [esp+35Ch+var_338]
		jz	short loc_1001489E
		mov	[esp+eax+35Ch+var_318],	31h
		inc	eax
		dec	ebp

loc_1001489E:				; CODE XREF: sub_10014341+554j
		cmp	eax, 30Eh
		jnb	short loc_100148C8
		lea	ecx, [esp+35Ch+var_318]
		mov	[esp+eax+35Ch+var_318],	0
		push	eax
		push	ecx
		mov	ecx, ebp
		call	sub_100148CE
		sub	esi, [esp+364h+var_324]
		pop	ecx
		pop	ecx
		mov	ecx, [esp+35Ch+var_328]
		mov	[ecx], esi
		jmp	loc_100144EF
; ---------------------------------------------------------------------------

loc_100148C8:				; CODE XREF: sub_10014341+562j
		call	___report_rangecheckfailure
		int	3		; Trap to Debugger
sub_10014341	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100148CE	proc near		; CODE XREF: sub_10014341+571p

var_344		= dword	ptr -344h
var_340		= byte ptr -340h
var_338		= qword	ptr -338h
var_330		= qword	ptr -330h
var_328		= qword	ptr -328h
var_320		= qword	ptr -320h
var_318		= byte ptr -318h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 344h
		mov	eax, ___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		and	dword ptr [ebp+var_328], 0
		lea	eax, [ebp+var_344]
		and	dword ptr [ebp+var_328+4], 0
		lea	edx, [ebp+var_318]
		push	ebx
		push	esi
		push	edi
		push	[ebp+arg_4]
		push	[ebp+arg_0]
		push	eax
		lea	eax, [ebp+var_328]
		push	eax
		push	ecx
		call	sub_10014ECB
		mov	ecx, [ebp+var_344]
		lea	edx, [ebp+var_330]
		add	esp, 14h
		push	dword ptr [ebp+var_328+4]
		push	dword ptr [ebp+var_328]
		call	sub_10012AB9
		fld	[ebp+var_330]
		pop	ecx
		pop	ecx
		test	al, al
		jnz	loc_10014A50
		mov	ebx, ds:memmove
		lea	eax, [ebp+var_320]
		push	8		; size_t
		push	eax		; void *
		lea	eax, [ebp+var_338]
		push	eax		; void *
		fstp	[ebp+var_320]
		call	ebx ; memmove
		mov	eax, dword ptr [ebp+var_338]
		lea	ecx, [ebp+var_320]
		mov	dword ptr [ebp+var_320], eax
		add	esp, 0Ch
		mov	eax, dword ptr [ebp+var_338+4]
		mov	dword ptr [ebp+var_320+4], eax
		lea	eax, [ebp+var_340]
		push	eax
		call	sub_10014FA3
		mov	ecx, [ebp+var_344]
		lea	esi, [ebp+var_340]
		sub	esp, 10h
		mov	edi, esp
		push	dword ptr [ebp+var_328+4]
		movsd
		push	dword ptr [ebp+var_328]
		movsd
		movsd
		movsd
		call	sub_10012A14
		fld	[ebp+var_330]
		add	esp, 18h
		test	eax, eax
		js	loc_10014A50
		push	8		; size_t
		jg	short loc_10014A14
		lea	eax, [ebp+var_338]
		push	eax		; void *
		lea	eax, [ebp+var_320]
		push	eax		; void *
		fstp	[ebp+var_338]
		call	ebx ; memmove
		mov	eax, dword ptr [ebp+var_320]
		lea	ecx, [ebp+var_338]
		add	esp, 0Ch
		mov	dword ptr [ebp+var_338], eax
		mov	eax, dword ptr [ebp+var_320+4]
		mov	dword ptr [ebp+var_338+4], eax
		call	sub_10009CA5
		fld	[ebp+var_330]
		and	eax, 1
		or	eax, 0
		jz	short loc_10014A50
		push	8		; size_t

loc_10014A14:				; CODE XREF: sub_100148CE+F8j
		lea	eax, [ebp+var_328]
		push	eax		; void *
		lea	eax, [ebp+var_320]
		push	eax		; void *
		fstp	[ebp+var_328]
		call	ebx ; memmove
		mov	eax, dword ptr [ebp+var_320]
		lea	ecx, [ebp+var_338]
		add	esp, 0Ch
		mov	dword ptr [ebp+var_338], eax
		mov	eax, dword ptr [ebp+var_320+4]
		mov	dword ptr [ebp+var_338+4], eax
		call	sub_10013DA5

loc_10014A50:				; CODE XREF: sub_100148CE+6Ej
					; sub_100148CE+F0j ...
		mov	ecx, [ebp+var_4]
		pop	edi
		pop	esi
		xor	ecx, ebp
		pop	ebx
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
sub_100148CE	endp


; =============== S U B	R O U T	I N E =======================================


sub_10014A61	proc near		; CODE XREF: sub_10008EE7+4B3Dp
					; sub_10014B14+1Ep

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		push	ecx
		push	ecx
		push	ebx
		push	ebp
		mov	ebp, [esp+10h+arg_0]
		push	esi
		push	edi
		push	ebp
		mov	edi, ecx
		call	sub_10008E3F
		mov	ebx, [ebp+20Ch]
		xor	esi, esi
		sub	ebx, [edi+20Ch]
		mov	[esp+18h+var_4], ebx
		cmp	[ebp+208h], esi
		jle	short loc_10014B04
		mov	ecx, ebx
		mov	ebx, esi
		shl	ecx, 2
		mov	[esp+18h+var_8], ecx

loc_10014A98:				; CODE XREF: sub_10014A61+6Cj
		mov	edx, [edi+200h]
		mov	eax, [ebp+200h]
		mov	ecx, [ecx+edx]
		sub	ecx, [eax+ebx*4]
		sub	ecx, esi
		mov	esi, ecx
		mov	ecx, [esp+18h+var_8]
		mov	eax, esi
		shr	esi, 1Fh
		and	eax, 0FFFFFFFh
		inc	ebx
		mov	[ecx+edx], eax
		add	ecx, 4
		mov	[esp+18h+var_8], ecx
		cmp	ebx, [ebp+208h]
		jl	short loc_10014A98
		mov	[esp+18h+arg_0], ebx
		mov	ebx, [esp+18h+var_4]
		test	esi, esi
		jz	short loc_10014B04
		mov	edx, [esp+18h+arg_0]
		lea	edx, [edx+ebx]
		shl	edx, 2

loc_10014AE5:				; CODE XREF: sub_10014A61+A1j
		mov	ecx, [edi+200h]
		mov	eax, [edx+ecx]
		sub	eax, esi
		mov	esi, eax
		and	eax, 0FFFFFFFh
		shr	esi, 1Fh
		mov	[edx+ecx], eax
		lea	edx, [edx+4]
		test	esi, esi
		jnz	short loc_10014AE5

loc_10014B04:				; CODE XREF: sub_10014A61+2Aj
					; sub_10014A61+78j
		mov	ecx, edi
		call	sub_10008E7F
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		pop	ecx
		retn	4
sub_10014A61	endp


; =============== S U B	R O U T	I N E =======================================


sub_10014B14	proc near		; CODE XREF: sub_10008EE7+4AD8p
					; sub_10008EE7+4B1Ap

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		sub	esp, 10h
		push	esi
		mov	esi, [esp+14h+arg_4]
		push	edi
		mov	edi, ecx
		cmp	esi, 3
		jge	short loc_10014B3F
		test	esi, esi
		jle	loc_10014C2A

loc_10014B2C:				; CODE XREF: sub_10014B14+24j
		push	[esp+18h+arg_0]
		mov	ecx, edi
		call	sub_10014A61
		dec	esi
		jnz	short loc_10014B2C
		jmp	loc_10014C2A
; ---------------------------------------------------------------------------

loc_10014B3F:				; CODE XREF: sub_10014B14+Ej
		mov	edx, [esp+18h+arg_0]
		push	ebx
		push	ebp
		xor	ebx, ebx
		mov	ebp, [edx+20Ch]
		sub	ebp, [edi+20Ch]
		and	[esp+20h+arg_4], ebx
		mov	[esp+20h+var_4], ebp
		cmp	[edx+208h], ebx
		jle	loc_10014BF2
		mov	eax, esi
		mov	esi, ebp
		mov	ebp, [esp+20h+arg_0]
		cdq
		shl	esi, 2
		mov	[esp+20h+var_C], eax
		mov	eax, [esp+20h+arg_4]
		mov	[esp+20h+var_8], edx
		mov	[esp+20h+var_10], esi

loc_10014B83:				; CODE XREF: sub_10014B14+D4j
		mov	ecx, [ebp+200h]
		push	edx
		push	[esp+24h+var_C]
		push	0
		push	dword ptr [ecx+eax*4]
		call	__allmul
		mov	ecx, [edi+200h]
		add	ebx, eax
		mov	eax, ebx
		mov	ebp, 0FFFFFFFh
		adc	edx, 0
		and	eax, ebp
		shrd	ebx, edx, 1Ch
		mov	esi, [esi+ecx]
		sub	esi, eax
		shr	edx, 1Ch
		mov	edx, [esp+20h+var_8]
		mov	eax, esi
		and	eax, ebp
		shr	esi, 1Fh
		mov	ebp, [esp+20h+var_10]
		add	ebx, esi
		mov	esi, ebp
		add	esi, 4
		mov	[esp+20h+var_10], esi
		mov	[ecx+ebp], eax
		mov	eax, [esp+20h+arg_4]
		mov	ebp, [esp+20h+arg_0]
		inc	eax
		mov	[esp+20h+arg_4], eax
		cmp	eax, [ebp+208h]
		jl	short loc_10014B83
		mov	ebp, [esp+20h+var_4]
		mov	edx, [esp+20h+arg_0]

loc_10014BF2:				; CODE XREF: sub_10014B14+4Dj
		mov	edx, [edx+208h]
		add	edx, ebp
		jmp	short loc_10014C19
; ---------------------------------------------------------------------------

loc_10014BFC:				; CODE XREF: sub_10014B14+10Bj
		test	ebx, ebx
		jz	short loc_10014C28
		mov	ecx, [edi+200h]
		mov	eax, [ecx+edx*4]
		sub	eax, ebx
		mov	ebx, eax
		and	eax, 0FFFFFFFh
		mov	[ecx+edx*4], eax
		shr	ebx, 1Fh
		inc	edx

loc_10014C19:				; CODE XREF: sub_10014B14+E6j
		cmp	edx, [edi+208h]
		jl	short loc_10014BFC
		mov	ecx, edi
		call	sub_10008E7F

loc_10014C28:				; CODE XREF: sub_10014B14+EAj
		pop	ebp
		pop	ebx

loc_10014C2A:				; CODE XREF: sub_10014B14+12j
					; sub_10014B14+26j
		pop	edi
		pop	esi
		add	esp, 10h
		retn	8
sub_10014B14	endp

; Exported entry  46. ?ToExponential@DoubleToStringConverter@double_conversion@@QBE_NNHPAVStringBuilder@2@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall double_conversion::DoubleToStringConverter::ToExponential(double_conversion::DoubleToStringConverter *this, double, int, struct double_conversion::StringBuilder *)
		public ?ToExponential@DoubleToStringConverter@double_conversion@@QBE_NNHPAVStringBuilder@2@@Z
?ToExponential@DoubleToStringConverter@double_conversion@@QBE_NNHPAVStringBuilder@2@@Z proc near
					; DATA XREF: .rdata:off_100175A8o

var_D4		= qword	ptr -0D4h
var_BC		= qword	ptr -0BCh
var_A1		= byte ptr -0A1h
var_A0		= dword	ptr -0A0h
var_98		= dword	ptr -98h
var_94		= dword	ptr -94h
var_90		= qword	ptr -90h
var_88		= byte ptr -88h
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 0A4h
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+0A4h+var_4], eax
		fld	[ebp+arg_0]
		lea	eax, [esp+0A4h+var_A0]
		push	ebx
		push	esi
		mov	esi, [ebp+arg_C]
		mov	ebx, ecx
		push	edi
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+0B8h+var_98]
		fst	[esp+0B8h+var_90]
		push	eax		; void *
		fstp	qword ptr [esp+0BCh+var_A0]
		call	ds:memmove
		mov	eax, [esp+0BCh+var_98]
		lea	ecx, [esp+0BCh+var_A0]
		add	esp, 0Ch
		mov	[esp+0B0h+var_A0], eax
		mov	eax, [esp+0B0h+var_94]
		mov	[esp+0B0h+var_A0+4], eax
		call	sub_10009DDB
		test	al, al
		jz	short loc_10014CA7
		fld	[esp+0B0h+var_90]
		push	esi		; struct double_conversion::StringBuilder *
		push	ecx
		push	ecx
		mov	ecx, ebx	; this
		fstp	[esp+0BCh+var_BC] ; double
		call	?HandleSpecialValues@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@@Z ; double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)
		jmp	loc_10014D7F
; ---------------------------------------------------------------------------

loc_10014CA7:				; CODE XREF: double_conversion::DoubleToStringConverter::ToExponential(double,int,double_conversion::StringBuilder *)+5Dj
		mov	eax, [ebp+arg_8]
		cmp	eax, 0FFFFFFFFh
		jge	short loc_10014CB6

loc_10014CAF:				; CODE XREF: double_conversion::DoubleToStringConverter::ToExponential(double,int,double_conversion::StringBuilder *)+87j
		xor	al, al
		jmp	loc_10014D7F
; ---------------------------------------------------------------------------

loc_10014CB6:				; CODE XREF: double_conversion::DoubleToStringConverter::ToExponential(double,int,double_conversion::StringBuilder *)+7Bj
		cmp	eax, 78h
		jg	short loc_10014CAF
		fld	[esp+0B0h+var_90]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_10014CF1
		lea	eax, [esp+0B0h+var_98]
		push	eax
		lea	eax, [esp+0B4h+var_A0]
		push	eax
		lea	eax, [esp+0B8h+var_A1]
		push	eax
		push	7Ah
		lea	eax, [esp+0C0h+var_88]
		push	eax
		push	0
		push	0
		push	ecx
		push	ecx
		fstp	[esp+0D4h+var_D4]
		call	?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z ; double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool	*,int *,int *)
		mov	edi, [esp+0D4h+var_A0]
		add	esp, 24h
		jmp	short loc_10014D38
; ---------------------------------------------------------------------------

loc_10014CF1:				; CODE XREF: double_conversion::DoubleToStringConverter::ToExponential(double,int,double_conversion::StringBuilder *)+90j
		lea	edi, [eax+1]
		lea	eax, [esp+0B0h+var_98]
		push	eax
		lea	eax, [esp+0B4h+var_A0]
		push	eax
		lea	eax, [esp+0B8h+var_A1]
		push	eax
		push	7Ah
		lea	eax, [esp+0C0h+var_88]
		push	eax
		push	edi
		push	3
		push	ecx
		push	ecx
		fstp	[esp+0D4h+var_D4]
		call	?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z ; double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool	*,int *,int *)
		mov	edx, [esp+0D4h+var_A0]
		add	esp, 24h
		cmp	edx, edi
		jge	short loc_10014D38
		mov	eax, edi
		lea	ecx, [esp+0B0h+var_88]
		sub	eax, edx
		add	ecx, edx
		push	eax		; size_t
		push	30h		; int
		push	ecx		; void *
		call	memset
		add	esp, 0Ch

loc_10014D38:				; CODE XREF: double_conversion::DoubleToStringConverter::ToExponential(double,int,double_conversion::StringBuilder *)+BDj
					; double_conversion::DoubleToStringConverter::ToExponential(double,int,double_conversion::StringBuilder	*)+EEj
		mov	cl, [ebx]
		shr	cl, 3
		and	cl, 1
		cmp	[esp+0B0h+var_A1], 0
		jz	short loc_10014D69
		fldz
		fld	[esp+0B0h+var_90]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_10014D5A
		test	cl, cl
		jnz	short loc_10014D69

loc_10014D5A:				; CODE XREF: double_conversion::DoubleToStringConverter::ToExponential(double,int,double_conversion::StringBuilder *)+122j
		mov	ecx, [esi+8]
		lea	eax, [ecx+1]
		mov	[esi+8], eax
		mov	eax, [esi]
		mov	byte ptr [ecx+eax], 2Dh

loc_10014D69:				; CODE XREF: double_conversion::DoubleToStringConverter::ToExponential(double,int,double_conversion::StringBuilder *)+113j
					; double_conversion::DoubleToStringConverter::ToExponential(double,int,double_conversion::StringBuilder	*)+126j
		mov	eax, [esp+0B0h+var_98]
		mov	ecx, ebx	; this
		push	esi		; struct double_conversion::StringBuilder *
		dec	eax
		push	eax		; int
		push	edi		; int
		lea	eax, [esp+0BCh+var_88]
		push	eax		; char *
		call	?CreateExponentialRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHPAVStringBuilder@2@@Z ; double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(char const *,int,int,double_conversion::StringBuilder *)
		mov	al, 1

loc_10014D7F:				; CODE XREF: double_conversion::DoubleToStringConverter::ToExponential(double,int,double_conversion::StringBuilder *)+70j
					; double_conversion::DoubleToStringConverter::ToExponential(double,int,double_conversion::StringBuilder	*)+7Fj
		mov	ecx, [esp+0B0h+var_4]
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn	10h
?ToExponential@DoubleToStringConverter@double_conversion@@QBE_NNHPAVStringBuilder@2@@Z endp

; Exported entry  47. ?ToFixed@DoubleToStringConverter@double_conversion@@QBE_NNHPAVStringBuilder@2@@Z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall double_conversion::DoubleToStringConverter::ToFixed(double_conversion::DoubleToStringConverter *this,	double,	int, struct double_conversion::StringBuilder *)
		public ?ToFixed@DoubleToStringConverter@double_conversion@@QBE_NNHPAVStringBuilder@2@@Z
?ToFixed@DoubleToStringConverter@double_conversion@@QBE_NNHPAVStringBuilder@2@@Z proc near
					; DATA XREF: .rdata:off_100175A8o

var_D4		= qword	ptr -0D4h
var_BC		= qword	ptr -0BCh
var_A1		= byte ptr -0A1h
var_A0		= dword	ptr -0A0h
var_98		= dword	ptr -98h
var_94		= dword	ptr -94h
var_90		= qword	ptr -90h
var_88		= byte ptr -88h
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF8h
		sub	esp, 0A8h
		mov	eax, ___security_cookie
		xor	eax, esp
		mov	[esp+0A8h+var_4], eax
		fld	[ebp+arg_0]
		lea	eax, [esp+0A8h+var_A0]
		push	esi
		mov	esi, [ebp+arg_C]
		push	edi
		push	8		; size_t
		push	eax		; void *
		lea	eax, [esp+0B8h+var_98]
		mov	edi, ecx
		fst	[esp+0B8h+var_90]
		push	eax		; void *
		fstp	qword ptr [esp+0BCh+var_A0]
		call	ds:memmove
		mov	eax, [esp+0BCh+var_98]
		lea	ecx, [esp+0BCh+var_A0]
		add	esp, 0Ch
		mov	[esp+0B0h+var_A0], eax
		mov	eax, [esp+0B0h+var_94]
		mov	[esp+0B0h+var_A0+4], eax
		call	sub_10009DDB
		test	al, al
		jz	short loc_10014E0A
		fld	[esp+0B0h+var_90]
		push	esi		; struct double_conversion::StringBuilder *
		push	ecx
		push	ecx
		mov	ecx, edi	; this
		fstp	[esp+0BCh+var_BC] ; double
		call	?HandleSpecialValues@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@@Z ; double_conversion::DoubleToStringConverter::HandleSpecialValues(double,double_conversion::StringBuilder *)
		jmp	loc_10014EB5
; ---------------------------------------------------------------------------

loc_10014E0A:				; CODE XREF: double_conversion::DoubleToStringConverter::ToFixed(double,int,double_conversion::StringBuilder *)+5Cj
		cmp	[ebp+arg_8], 3Ch
		jg	loc_10014EB3
		fld	ds:dbl_100174D8
		fld	[esp+0B0h+var_90]
		fcom	st(1)
		fnstsw	ax
		fstp	st(1)
		test	ah, 1
		jz	loc_10014EB1
		fld	ds:dbl_100174E0
		fcomp	st(1)
		fnstsw	ax
		test	ah, 1
		jz	short loc_10014EB1
		lea	eax, [esp+0B0h+var_A0]
		push	eax
		lea	eax, [esp+0B4h+var_98]
		push	eax
		lea	eax, [esp+0B8h+var_A1]
		push	eax
		push	79h
		lea	eax, [esp+0C0h+var_88]
		push	eax
		push	[ebp+arg_8]
		push	2
		push	ecx
		push	ecx
		fstp	[esp+0D4h+var_D4]
		call	?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z ; double_conversion::DoubleToStringConverter::DoubleToAscii(double,double_conversion::DoubleToStringConverter::DtoaMode,int,char *,int,bool	*,int *,int *)
		mov	cl, [edi]
		add	esp, 24h
		shr	cl, 3
		and	cl, 1
		cmp	[esp+0B0h+var_A1], 0
		jz	short loc_10014E95
		fldz
		fld	[esp+0B0h+var_90]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_10014E86
		test	cl, cl
		jnz	short loc_10014E95

loc_10014E86:				; CODE XREF: double_conversion::DoubleToStringConverter::ToFixed(double,int,double_conversion::StringBuilder *)+EAj
		mov	ecx, [esi+8]
		lea	eax, [ecx+1]
		mov	[esi+8], eax
		mov	eax, [esi]
		mov	byte ptr [ecx+eax], 2Dh

loc_10014E95:				; CODE XREF: double_conversion::DoubleToStringConverter::ToFixed(double,int,double_conversion::StringBuilder *)+DBj
					; double_conversion::DoubleToStringConverter::ToFixed(double,int,double_conversion::StringBuilder *)+EEj
		push	esi		; struct double_conversion::StringBuilder *
		push	[ebp+arg_8]	; int
		lea	eax, [esp+0B8h+var_88]
		mov	ecx, edi	; this
		push	[esp+0B8h+var_A0] ; size_t
		push	[esp+0BCh+var_98] ; size_t
		push	eax		; char *
		call	?CreateDecimalRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHHPAVStringBuilder@2@@Z	; double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(char const *,int,int,int,double_conversion::StringBuilder *)
		mov	al, 1
		jmp	short loc_10014EB5
; ---------------------------------------------------------------------------

loc_10014EB1:				; CODE XREF: double_conversion::DoubleToStringConverter::ToFixed(double,int,double_conversion::StringBuilder *)+91j
					; double_conversion::DoubleToStringConverter::ToFixed(double,int,double_conversion::StringBuilder *)+A4j
		fstp	st

loc_10014EB3:				; CODE XREF: double_conversion::DoubleToStringConverter::ToFixed(double,int,double_conversion::StringBuilder *)+78j
		xor	al, al

loc_10014EB5:				; CODE XREF: double_conversion::DoubleToStringConverter::ToFixed(double,int,double_conversion::StringBuilder *)+6Fj
					; double_conversion::DoubleToStringConverter::ToFixed(double,int,double_conversion::StringBuilder *)+119j
		mov	ecx, [esp+0B0h+var_4]
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn	10h
?ToFixed@DoubleToStringConverter@double_conversion@@QBE_NNHPAVStringBuilder@2@@Z endp


; =============== S U B	R O U T	I N E =======================================


sub_10014ECB	proc near		; CODE XREF: sub_100148CE+3Fp

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, [esp+arg_10]
		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+0Ch+arg_C]
		mov	ebx, ecx
		xor	ecx, ecx
		mov	ebp, edx
		push	edi
		mov	edi, ecx
		test	eax, eax
		jle	short loc_10014EEE

loc_10014EE3:				; CODE XREF: sub_10014ECB+21j
		cmp	byte ptr [esi+edi], 30h
		jnz	short loc_10014F02
		inc	edi
		cmp	edi, eax
		jl	short loc_10014EE3

loc_10014EEE:				; CODE XREF: sub_10014ECB+16j
		mov	eax, ecx

loc_10014EF0:				; CODE XREF: sub_10014ECB+3Bj
		lea	edx, [eax-1]
		test	edx, edx
		js	short loc_10014F0B

loc_10014EF7:				; CODE XREF: sub_10014ECB+33j
		cmp	byte ptr [esi+edx], 30h
		jnz	short loc_10014F08
		dec	edx
		jns	short loc_10014EF7
		jmp	short loc_10014F0B
; ---------------------------------------------------------------------------

loc_10014F02:				; CODE XREF: sub_10014ECB+1Cj
		add	esi, edi
		sub	eax, edi
		jmp	short loc_10014EF0
; ---------------------------------------------------------------------------

loc_10014F08:				; CODE XREF: sub_10014ECB+30j
		lea	ecx, [edx+1]

loc_10014F0B:				; CODE XREF: sub_10014ECB+2Aj
					; sub_10014ECB+35j
		sub	eax, ecx
		mov	edi, 30Ch
		add	ebx, eax
		cmp	ecx, edi
		jle	short loc_10014F35
		push	ecx
		push	esi
		push	[esp+18h+arg_8]
		mov	edx, ebp
		mov	ecx, ebx
		call	sub_10012C74
		mov	eax, [esp+1Ch+arg_4]
		add	esp, 0Ch
		mov	[eax], ebp
		mov	[eax+4], edi
		jmp	short loc_10014F44
; ---------------------------------------------------------------------------

loc_10014F35:				; CODE XREF: sub_10014ECB+4Bj
		mov	eax, [esp+10h+arg_4]
		mov	[eax], esi
		mov	[eax+4], ecx
		mov	eax, [esp+10h+arg_8]
		mov	[eax], ebx

loc_10014F44:				; CODE XREF: sub_10014ECB+68j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
sub_10014ECB	endp


; =============== S U B	R O U T	I N E =======================================


sub_10014F49	proc near		; CODE XREF: sub_10013281+235p

arg_0		= dword	ptr  4

		push	ebp
		push	esi
		push	edi
		mov	edi, ecx
		xor	esi, esi
		mov	ebp, edx
		mov	edx, [esp+0Ch+arg_0]
		cmp	[edi], esi
		jle	short loc_10014F9F

loc_10014F5A:				; CODE XREF: sub_10014F49+1Fj
		mov	eax, [edi]
		cmp	byte ptr [eax+edx-1], 30h
		jnz	short loc_10014F6A
		dec	eax
		mov	[edi], eax
		test	eax, eax
		jg	short loc_10014F5A

loc_10014F6A:				; CODE XREF: sub_10014F49+18j
		cmp	[edi], esi
		jle	short loc_10014F9F

loc_10014F6E:				; CODE XREF: sub_10014F49+2Ej
		cmp	byte ptr [edx+esi], 30h
		jnz	short loc_10014F79
		inc	esi
		cmp	esi, [edi]
		jl	short loc_10014F6E

loc_10014F79:				; CODE XREF: sub_10014F49+29j
		test	esi, esi
		jz	short loc_10014F9F
		push	ebx
		mov	ebx, esi
		cmp	esi, [edi]
		jge	short loc_10014F99

loc_10014F84:				; CODE XREF: sub_10014F49+4Ej
		mov	al, [edx+ebx]
		mov	ecx, edx
		sub	ecx, esi
		mov	[ecx+ebx], al
		inc	ebx
		cmp	ebx, [edi]
		jge	short loc_10014F99
		mov	edx, [esp+10h+arg_0]
		jmp	short loc_10014F84
; ---------------------------------------------------------------------------

loc_10014F99:				; CODE XREF: sub_10014F49+39j
					; sub_10014F49+48j
		sub	[edi], esi
		sub	[ebp+0], esi
		pop	ebx

loc_10014F9F:				; CODE XREF: sub_10014F49+Fj
					; sub_10014F49+23j ...
		pop	edi
		pop	esi
		pop	ebp
		retn
sub_10014F49	endp


; =============== S U B	R O U T	I N E =======================================


sub_10014FA3	proc near		; CODE XREF: sub_100148CE+BAp

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	esi, ecx
		call	sub_10009E0D
		mov	ecx, esi
		lea	edi, [eax-1]
		call	sub_10009CA5
		mov	ecx, eax
		mov	eax, [esp+8+arg_0]
		shld	edx, ecx, 1
		add	ecx, ecx
		add	ecx, 1
		mov	[eax+8], edi
		pop	edi
		adc	edx, 0
		mov	[eax], ecx
		mov	[eax+4], edx
		pop	esi
		retn	4
sub_10014FA3	endp


; =============== S U B	R O U T	I N E =======================================


sub_10014FD5	proc near		; CODE XREF: sub_1001226A+FDp
					; sub_100124B5+119p ...
		lea	eax, [ecx-30h]
		cmp	eax, 9
		ja	short loc_10014FE4
		lea	eax, [edx+30h]
		cmp	ecx, eax
		jl	short loc_10015001

loc_10014FE4:				; CODE XREF: sub_10014FD5+6j
		cmp	edx, 0Ah
		jle	short loc_10015005
		cmp	ecx, 61h
		jl	short loc_10014FF5
		lea	eax, [edx+57h]
		cmp	ecx, eax
		jl	short loc_10015001

loc_10014FF5:				; CODE XREF: sub_10014FD5+17j
		cmp	ecx, 41h
		jl	short loc_10015005
		lea	eax, [edx+37h]
		cmp	ecx, eax
		jge	short loc_10015005

loc_10015001:				; CODE XREF: sub_10014FD5+Dj
					; sub_10014FD5+1Ej
		xor	eax, eax
		inc	eax
		retn
; ---------------------------------------------------------------------------

loc_10015005:				; CODE XREF: sub_10014FD5+12j
					; sub_10014FD5+23j ...
		xor	eax, eax
		retn
sub_10014FD5	endp

; ---------------------------------------------------------------------------
		align 200h
		dd 380h	dup(?)
_text		ends

; Section 2. (virtual address 00016000)
; Virtual size			: 00003F0C (  16140.)
; Section size in file		: 00004000 (  16384.)
; Offset to raw	data for section: 00014600
; Flags	40000040: Data Readable
; Alignment	: default
;
; Imports from KERNEL32.dll
;
; ===========================================================================

; Segment type:	Externs
; _idata
; DWORD	__stdcall SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
		extrn SearchPathW:dword	; CODE XREF: sub_1000AD10+1Bp
					; sub_1000AD10+55p
					; DATA XREF: ...
; LPVOID __stdcall MapViewOfFile(HANDLE	hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, DWORD	dwNumberOfBytesToMap)
		extrn MapViewOfFile:dword ; CODE XREF: sub_1000AC6A+36p
					; sub_1000ACC2+2Fp
					; DATA XREF: ...
; BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress)
		extrn UnmapViewOfFile:dword ; CODE XREF: sub_1000ABC8+76p
					; sub_1000ABC8+8Cp ...
; ULONGLONG __stdcall VerSetConditionMask(ULONGLONG ConditionMask, DWORD TypeMask, BYTE	Condition)
		extrn VerSetConditionMask:dword	; CODE XREF: sub_1000AAFC+7Dp
					; sub_1000AAFC+85p ...
; HANDLE __stdcall GetCurrentProcess()
		extrn GetCurrentProcess:dword ;	CODE XREF: sub_10001482+A1p
					; sub_10001482+CBp ...
; BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite,	LPDWORD	lpNumberOfBytesWritten,	LPOVERLAPPED lpOverlapped)
		extrn WriteFile:dword	; CODE XREF: DllBlocklist_WriteNotes(void *)+1Fp
					; DllBlocklist_WriteNotes(void *)+35p ...
; void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
		extrn InitializeCriticalSection:dword
					; CODE XREF: DllBlocklist_Initialize(void)+45p
					; DATA XREF: DllBlocklist_Initialize(void)+45r
; void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
		extrn LeaveCriticalSection:dword ; CODE	XREF: sub_10001850+3Fp
					; moz_xrealloc+16Ap ...
; BOOL __stdcall VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
		extrn VerifyVersionInfoA:dword ; CODE XREF: sub_1000AAFC+9Fp
					; DATA XREF: sub_1000AAFC+9Fr
; HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD	dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
		extrn CreateFileW:dword	; CODE XREF: sub_1000ABC8+1Bp
					; sub_1000E98B+1Bp
					; DATA XREF: ...
; BOOL __stdcall FlushInstructionCache(HANDLE hProcess,	LPCVOID	lpBaseAddress, DWORD dwSize)
		extrn FlushInstructionCache:dword ; CODE XREF: sub_100013FD+AC3Fp
					; DATA XREF: sub_100013FD+AC3Fr
; FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
		extrn GetProcAddress:dword ; CODE XREF:	sub_1000158C+Fp
					; mozilla::TimeStamp::Startup(void)+16p
					; DATA XREF: ...
; void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
		extrn EnterCriticalSection:dword ; CODE	XREF: sub_10001850+19p
					; moz_xrealloc+BFp ...
; BOOL __stdcall VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
		extrn VirtualProtectEx:dword ; CODE XREF: sub_10001482+AAp
					; sub_10001482+CEp ...
; LPVOID __stdcall VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect)
		extrn VirtualAllocEx:dword ; CODE XREF:	sub_100015D3+45p
					; DATA XREF: sub_100015D3+45r
; HANDLE __stdcall CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
		extrn CreateFileMappingW:dword ; CODE XREF: sub_1000ABC8+30p
					; sub_1000E98B+30p
					; DATA XREF: ...
; void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
		extrn GetSystemInfo:dword ; CODE XREF: sub_100066AB+31p
					; sub_1000AC6A+Ep ...
; HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName)
		extrn GetModuleHandleA:dword ; CODE XREF: DllBlocklist_Initialize(void)+5p
					; DATA XREF: DllBlocklist_Initialize(void)+5r
; HMODULE __stdcall LoadLibraryExA(LPCSTR lpLibFileName, HANDLE	hFile, DWORD dwFlags)
		extrn LoadLibraryExA:dword ; CODE XREF:	DllBlocklist_Initialize(void)+35p
					; sub_100015D3+10p
					; DATA XREF: ...
; BOOL __stdcall IsDebuggerPresent()
		extrn IsDebuggerPresent:dword ;	CODE XREF: ___raise_securityfailure+3p
					; sub_1000EC1C+13p
					; DATA XREF: ...
; void __stdcall OutputDebugStringA(LPCSTR lpOutputString)
		extrn OutputDebugStringA:dword ; CODE XREF: sub_1000EC1C+44p
					; DATA XREF: sub_1000EC1C+44r
; DWORD	__stdcall GetCurrentThreadId()
		extrn GetCurrentThreadId:dword ; CODE XREF: sub_1000A8A8:loc_1000A9FBp
					; DllBlocklist_SetInXPCOMLoadOnMainThread(bool)+7p ...
; BOOL __stdcall CloseHandle(HANDLE hObject)
		extrn CloseHandle:dword	; CODE XREF: sub_1000ABC8+7Dp
					; sub_1000ABC8+93p ...
; BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT	uExitCode)
		extrn TerminateProcess:dword ; CODE XREF: sub_10008958+4FACp
					; sub_10009240+490Cp ...
; LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex)
		extrn TlsGetValue:dword	; CODE XREF: sub_1000172B+3Ap
					; moz_xrealloc+6Fp ...
; BOOL __stdcall VirtualFree(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType)
		extrn VirtualFree:dword	; CODE XREF: sub_10005837+27p
					; sub_10005C56+8p ...
; BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
		extrn TlsSetValue:dword	; CODE XREF: sub_100016CF+1Cp
					; sub_100066AB+190p
					; DATA XREF: ...
; BOOL __stdcall InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
		extrn InitializeCriticalSectionAndSpinCount:dword
					; CODE XREF: sub_100068A1+6p
					; mozilla::TimeStamp::Startup(void)+2Fp
					; DATA XREF: ...
; DWORD	__stdcall GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
		extrn GetEnvironmentVariableA:dword ; CODE XREF: sub_100068E8+Ep
					; DATA XREF: sub_100068E8+Er
; LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, DWORD	dwSize,	DWORD flAllocationType,	DWORD flProtect)
		extrn VirtualAlloc:dword ; CODE	XREF: sub_100056A2+29p
					; sub_10005A6D+11p ...
; BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule)
		extrn DisableThreadLibraryCalls:dword ;	CODE XREF: DllMain(x,x,x)+Ap
					; DATA XREF: DllMain(x,x,x)+Ar
; DWORD	__stdcall TlsAlloc()
		extrn TlsAlloc:dword	; CODE XREF: sub_100066AB+21p
					; DATA XREF: sub_100066AB+21r
; BOOL __stdcall SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
		extrn SystemTimeToFileTime:dword
					; CODE XREF: mozilla::TimeStamp::ComputeProcessUptime(void)+22p
					; DATA XREF: mozilla::TimeStamp::ComputeProcessUptime(void)+22r
; BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
		extrn QueryPerformanceCounter:dword
					; CODE XREF: mozilla::TimeStamp::Now(bool)+1Ep
					; sub_1000700F+9p ...
; HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName)
		extrn GetModuleHandleW:dword
					; CODE XREF: mozilla::TimeStamp::Startup(void)+Ap
					; DATA XREF: mozilla::TimeStamp::Startup(void)+Ar
; DWORD	__stdcall GetTickCount()
		extrn GetTickCount:dword ; CODE	XREF: sub_1000F36F+4p
					; DATA XREF: sub_1000F36F+4r
; BOOL __stdcall GetProcessTimes(HANDLE	hProcess, LPFILETIME lpCreationTime, LPFILETIME	lpExitTime, LPFILETIME lpKernelTime, LPFILETIME	lpUserTime)
		extrn GetProcessTimes:dword
					; CODE XREF: mozilla::TimeStamp::ComputeProcessUptime(void)+43p
					; DATA XREF: mozilla::TimeStamp::ComputeProcessUptime(void)+43r
; BOOL __stdcall GetSystemTimeAdjustment(PDWORD	lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL	lpTimeAdjustmentDisabled)
		extrn GetSystemTimeAdjustment:dword ; CODE XREF: sub_10007034+20p
					; DATA XREF: sub_10007034+20r
; BOOL __stdcall QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
		extrn QueryPerformanceFrequency:dword
					; CODE XREF: mozilla::TimeStamp::Startup(void)+43p
					; DATA XREF: mozilla::TimeStamp::Startup(void)+43r
; void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
		extrn DeleteCriticalSection:dword
					; CODE XREF: mozilla::TimeStamp::Shutdown(void)+5p
					; DATA XREF: mozilla::TimeStamp::Shutdown(void)+5r
; void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime)
		extrn GetSystemTime:dword
					; CODE XREF: mozilla::TimeStamp::ComputeProcessUptime(void)+14p
					; DATA XREF: mozilla::TimeStamp::ComputeProcessUptime(void)+14r
; DWORD	__stdcall GetCurrentProcessId()
		extrn GetCurrentProcessId:dword	; CODE XREF: sub_1000B871+4Cp
					; DATA XREF: sub_1000B871+4Cr
; BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature)
		extrn __imp_IsProcessorFeaturePresent:dword
					; DATA XREF: IsProcessorFeaturePresentr
; PVOID	__stdcall DecodePointer(PVOID Ptr)
		extrn DecodePointer:dword ; CODE XREF: sub_1000B00B+1Cp
					; sub_1000B00B+44p ...
; PVOID	__stdcall EncodePointer(PVOID Ptr)
		extrn EncodePointer:dword ; CODE XREF: ___atonexitinit+1Cp
					; sub_1000B00B+65p ...
; void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
		extrn GetSystemTimeAsFileTime:dword ; CODE XREF: sub_1000B871+34p
					; DATA XREF: sub_1000B871+34r

;
; Imports from MSVCP120.dll
;
; char const * __cdecl std::_Winerror_map(int)
		extrn ?_Winerror_map@std@@YAPBDH@Z:dword ; CODE	XREF: sub_100112B7+4p
					; DATA XREF: sub_100112B7+4r ...
; public: virtual __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::~basic_streambuf<char, struct std::char_traits<char>>(void)
		extrn ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:dword
					; CODE XREF: sub_1000FA58+31p
					; sub_10010440+10p
					; DATA XREF: ...
; __declspec(dllimport)	public:	virtual	void __thiscall	std::basic_streambuf<char, struct std::char_traits<char>>::_Lock(void)
		extrn __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:dword
					; DATA XREF: std::basic_streambuf<char,std::char_traits<char>>::_Lock(void)r
; __declspec(dllimport)	public:	virtual	void __thiscall	std::basic_streambuf<char, struct std::char_traits<char>>::_Unlock(void)
		extrn __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:dword
					; DATA XREF: std::basic_streambuf<char,std::char_traits<char>>::_Unlock(void)r
; __declspec(dllimport)	protected: virtual __int64 __thiscall std::basic_streambuf<char, struct	std::char_traits<char>>::showmanyc(void)
		extrn __imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:dword
					; DATA XREF: std::basic_streambuf<char,std::char_traits<char>>::showmanyc(void)r
; __declspec(dllimport)	protected: virtual int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::uflow(void)
		extrn __imp_?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:dword
					; DATA XREF: std::basic_streambuf<char,std::char_traits<char>>::uflow(void)r
; __declspec(dllimport)	protected: virtual __int64 __thiscall std::basic_streambuf<char, struct	std::char_traits<char>>::xsgetn(char *,	__int64)
		extrn __imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:dword
					; DATA XREF: std::basic_streambuf<char,std::char_traits<char>>::xsgetn(char *,__int64)r
; __declspec(dllimport)	protected: virtual __int64 __thiscall std::basic_streambuf<char, struct	std::char_traits<char>>::xsputn(char const *, __int64)
		extrn __imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:dword
					; DATA XREF: std::basic_streambuf<char,std::char_traits<char>>::xsputn(char const *,__int64)r
; __declspec(dllimport)	protected: virtual class std::basic_streambuf<char, struct std::char_traits<char>> * __thiscall	std::basic_streambuf<char, struct std::char_traits<char>>::setbuf(char *, __int64)
		extrn __imp_?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:dword
					; DATA XREF: std::basic_streambuf<char,std::char_traits<char>>::setbuf(char *,__int64)r
; __declspec(dllimport)	protected: virtual int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::sync(void)
		extrn __imp_?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:dword
					; DATA XREF: std::basic_streambuf<char,std::char_traits<char>>::sync(void)r
; __declspec(dllimport)	protected: virtual void	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::imbue(class std::locale const &)
		extrn __imp_?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:dword
					; DATA XREF: std::basic_streambuf<char,std::char_traits<char>>::imbue(std::locale const	&)r
; public: virtual __thiscall std::basic_ios<char, struct std::char_traits<char>>::~basic_ios<char, struct std::char_traits<char>>(void)
		extrn ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:dword
					; DATA XREF: sub_10010405+Er
; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::basic_ostream<char, struct std::char_traits<char>>(class std::basic_streambuf<char, struct std::char_traits<char>> *, bool)
		extrn ??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:dword
					; CODE XREF: sub_1000F947+23p
					; DATA XREF: sub_1000F947+23r
; public: virtual __thiscall std::basic_ostream<char, struct std::char_traits<char>>::~basic_ostream<char, struct std::char_traits<char>>(void)
		extrn ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ:dword
					; DATA XREF: sub_1000FA58+3Cr
; public: class	std::basic_ostream<char, struct	std::char_traits<char>>	& __thiscall std::basic_ostream<char, struct std::char_traits<char>>::operator<<(__int64)
		extrn ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z:dword
					; CODE XREF: sub_100113D1+3Fp
					; DATA XREF: sub_100113D1+3Fr
; public: class	std::basic_ostream<char, struct	std::char_traits<char>>	& __thiscall std::basic_ostream<char, struct std::char_traits<char>>::operator<<(unsigned __int64)
		extrn ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z:dword
					; CODE XREF: sub_10011434+3Fp
					; DATA XREF: sub_10011434+3Fr
; protected: char * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::eback(void)const
		extrn ?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:dword
					; CODE XREF: sub_10010627+26p
					; sub_10010627+2Ep ...
; protected: char * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::gptr(void)const
		extrn ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:dword
					; CODE XREF: sub_100114CA+18Dp
					; sub_10011695+4p ...
; protected: char * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::pbase(void)const
		extrn ?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:dword
					; CODE XREF: sub_100114CA+4Ep
					; sub_100114CA+16Ap ...
; protected: char * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::pptr(void)const
		extrn ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:dword
					; CODE XREF: sub_10010627+Ap
					; sub_100114CA+29p ...
; protected: char * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::egptr(void)const
		extrn ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:dword
					; CODE XREF: sub_10010627:loc_10010645p
					; sub_10011C58+7Dp ...
; protected: void __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::gbump(int)
		extrn ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:dword
					; CODE XREF: sub_10011695+46p
					; sub_100118A4+F3p ...
; protected: void __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::setg(char *, char *, char *)
		extrn ?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:dword
					; CODE XREF: sub_10010627+42p
					; sub_100114CA+199p ...
; protected: char * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::epptr(void)const
		extrn ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:dword
					; CODE XREF: sub_10010627+16p
					; sub_100114CA+42p ...
; protected: void __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::pbump(int)
		extrn ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:dword
					; CODE XREF: sub_100118A4+1F0p
					; sub_10011ADD+14Dp
					; DATA XREF: ...
; protected: void __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::setp(char *, char *)
		extrn ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z:dword
					; CODE XREF: sub_10010627+4Cp
					; sub_100114CA+134p
					; DATA XREF: ...
; protected: void __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::setp(char *, char *, char *)
		extrn ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:dword
					; CODE XREF: sub_100114CA+57p
					; sub_100114CA+175p ...
; protected: char * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::_Pninc(void)
		extrn ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:dword
					; CODE XREF: sub_100114CA+82p
					; sub_100114CA+1B5p
					; DATA XREF: ...
; protected: __thiscall	std::basic_ios<char, struct std::char_traits<char>>::basic_ios<char, struct std::char_traits<char>>(void)
		extrn ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:dword
					; CODE XREF: sub_1000F947+15p
					; DATA XREF: sub_1000F947+15r
; protected: __thiscall	std::basic_streambuf<char, struct std::char_traits<char>>::basic_streambuf<char, struct	std::char_traits<char>>(void)
		extrn ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:dword
					; CODE XREF: sub_1000F947+43p
					; DATA XREF: sub_1000F947+43r
; const	_Dconst	Inf
		extrn _Inf:dword	; DATA XREF: WebCore::Decimal::toDouble(void)+5Fr
; const	_Dconst	Nan
		extrn _Nan:dword	; DATA XREF: WebCore::Decimal::toDouble(void):loc_10011D8Fr
; void __cdecl std::_Xout_of_range(char	const *)
		extrn ?_Xout_of_range@std@@YAXPBD@Z:dword ; CODE XREF: sub_1001068F+5p
					; DATA XREF: sub_1001068F+5r
; struct std::_Smanip<__int64> __cdecl std::setprecision(__int64)
		extrn ?setprecision@std@@YA?AU?$_Smanip@_J@1@_J@Z:dword
					; CODE XREF: sub_100113D1+27p
					; sub_10011434+27p
					; DATA XREF: ...
; __int64 const	std::_BADOFF
		extrn ?_BADOFF@std@@3_JB:dword ; DATA XREF: sub_100118A4:loc_10011934r
					; sub_100118A4+19Dr ...
; char const * __cdecl std::_Syserror_map(int)
		extrn ?_Syserror_map@std@@YAPBDH@Z:dword ; CODE	XREF: sub_10010C1C+6p
					; sub_10011268+4p
					; DATA XREF: ...
; void __cdecl std::_Xlength_error(char	const *)
		extrn ?_Xlength_error@std@@YAXPBD@Z:dword ; CODE XREF: sub_1000E3FC+21p
					; sub_10010683+5p
					; DATA XREF: ...
; void __cdecl std::_Xbad_alloc(void)
		extrn ?_Xbad_alloc@std@@YAXXZ:dword
					; CODE XREF: DllBlocklist_Initialize(void)+AC5Fp
					; sub_1000EB44+11p ...

;
; Imports from MSVCR120.dll
;
		extrn __imp__except_handler4_common:dword
					; DATA XREF: _except_handler4_commonr
					; .rdata:10018E00o
; unsigned __int64 __cdecl strtoui64(const char	*String, char **EndPtr,	int Radix)
		extrn _strtoui64:dword	; CODE XREF: sub_1000A8A8+3855p
					; DATA XREF: sub_1000A8A8+3855r
		extrn __imp__initterm_e:dword ;	DATA XREF: _initterm_er
		extrn __imp__initterm:dword ; DATA XREF: _inittermr
		extrn _malloc_crt:dword	; CODE XREF: _pre_c_init+6p
					; DATA XREF: _pre_c_init+6r
		extrn __imp__amsg_exit:dword ; DATA XREF: _amsg_exitr
		extrn __imp___CppXcptFilter:dword ; DATA XREF: __CppXcptFilterr
		extrn __imp___crtTerminateProcess:dword	; DATA XREF: __crtTerminateProcessr
		extrn __imp___crtUnhandledException:dword
					; DATA XREF: __crtUnhandledExceptionr
		extrn __imp__crt_debugger_hook:dword ; DATA XREF: _crt_debugger_hookr
; _onexit_t __cdecl onexit(_onexit_t)
		extrn _onexit:dword	; CODE XREF: sub_1000B00B+29p
					; DATA XREF: sub_1000B00B+29r
		extrn __imp___dllonexit:dword ;	DATA XREF: __dllonexitr
		extrn _calloc_crt:dword	; CODE XREF: ___atonexitinit+11p
					; DATA XREF: ___atonexitinit+11r
		extrn __imp__unlock:dword ; DATA XREF: _unlockr
		extrn __imp__lock:dword	; DATA XREF: _lockr
		extrn __imp__purecall:dword ; DATA XREF: _purecallr
		extrn _dtest:dword	; CODE XREF: sub_1000F90A+Dp
					; sub_1000F928+Dp
					; DATA XREF: ...
; void *__cdecl	memmove(void *,	const void *, size_t)
		extrn memmove:dword	; CODE XREF: sub_10008958+68p
					; sub_10008958+AEp ...
; void * __cdecl operator new[](unsigned int)
		extrn ??_U@YAPAXI@Z:dword ; CODE XREF: sub_1000AD10+3Ap
					; sub_1000A8A8+396Cp
					; DATA XREF: ...
; int __cdecl strnicmp(const char *, const char	*, size_t)
		extrn _strnicmp:dword	; CODE XREF: sub_100070FE+31p
					; DATA XREF: sub_100070FE+31r
; char *__cdecl	getenv(const char *)
		extrn getenv:dword	; CODE XREF: mozilla::TimeStamp::ProcessCreation(bool &)+3Bp
					; DATA XREF: mozilla::TimeStamp::ProcessCreation(bool &)+3Br
; int __cdecl write(int, const void *, unsigned	int)
		extrn _write:dword	; CODE XREF: sub_1000F2B1+1Fp
					; sub_1000F2B1+39p ...
; int __cdecl vsnprintf(char *,	size_t,	const char *, va_list)
		extrn _vsnprintf:dword	; CODE XREF: sub_1000EC1C+30p
					; DATA XREF: sub_1000EC1C+30r
; int errno
		extrn _errno:dword	; CODE XREF: strdup:loc_10002883p
					; moz_xrealloc:loc_1000C2CAp ...
; char *__cdecl	strncpy(char *,	const char *, size_t)
		extrn strncpy:dword	; CODE XREF: strdup+5Bp strndup+1Cp
					; DATA XREF: ...
; wchar_t *__cdecl wcsncpy(wchar_t *, const wchar_t *, size_t)
		extrn wcsncpy:dword	; CODE XREF: wcsdup+35p
					; DATA XREF: wcsdup+35r
; int __cdecl fputs(const char *, FILE *)
		extrn fputs:dword	; CODE XREF: mozalloc_abort(char const * const)+Ep
					; mozalloc_abort(char const * const)+23p
					; DATA XREF: ...
; int fprintf(FILE *, const char *, ...)
		extrn fprintf:dword	; CODE XREF: std::moz_Xinvalid_argument(char const *)-10p
					; DATA XREF: std::moz_Xinvalid_argument(char const *)-10r
; FILE *__cdecl	_iob_func()
		extrn __iob_func:dword	; CODE XREF: std::moz_Xinvalid_argument(char const *)-1Ap
					; mozalloc_abort(char const * const)p ...
; FILE *__cdecl	fdopen(int, const char *)
		extrn _fdopen:dword	; CODE XREF: sub_1000EC1C+5Ap
					; DATA XREF: sub_1000EC1C+5Ar
; int __cdecl isxdigit(int)
		extrn isxdigit:dword	; CODE XREF: sub_1000A8A8+1CEp
					; DATA XREF: sub_1000A8A8+1CEr
; int __cdecl fclose(FILE *)
		extrn fclose:dword	; CODE XREF: sub_1000EC1C+77p
					; DATA XREF: sub_1000EC1C+77r
; int __cdecl dup(int)
		extrn _dup:dword	; CODE XREF: sub_1000EC1C+52p
					; DATA XREF: sub_1000EC1C+52r
; int __cdecl vfprintf(FILE *, const char *, va_list)
		extrn vfprintf:dword	; CODE XREF: sub_1000EC1C+70p
					; DATA XREF: sub_1000EC1C+70r
; void __cdecl operator	delete[](void *)
		extrn ??_V@YAXPAX@Z:dword ; CODE XREF: sub_1000A8A8+17Ep
					; sub_1000A8A8+1FBp ...
; char *__cdecl	strchr(const char *, int)
		extrn strchr:dword	; CODE XREF: sub_1000A8A8+D6p
					; sub_1000A8A8+E6p
					; DATA XREF: ...
		extrn __imp___clean_type_info_names_internal:dword
					; DATA XREF: __clean_type_info_names_internalr
; int __cdecl stricmp(const char *, const char *)
		extrn _stricmp:dword	; CODE XREF: sub_1000E70F+34p
					; DATA XREF: sub_1000E70F+34r
; char *__cdecl	ltoa(__int32, char *, int)
		extrn _ltoa:dword	; CODE XREF: sub_1000EA23+A7p
					; DATA XREF: sub_1000EA23+A7r
; double __cdecl ceil(double)
		extrn __imp_ceil:dword	; DATA XREF: ceilr
; void *__cdecl	memcpy(void *, const void *, size_t)
		extrn __imp_memcpy:dword ; DATA	XREF: memcpyr
; void __cdecl free_0(void *)
		extrn free_0:dword	; CODE XREF: sub_1000B330+FFp
					; DATA XREF: sub_1000B330+FFr
; void *__cdecl	memset(void *, int, size_t)
		extrn __imp_memset:dword ; DATA	XREF: memsetr

;
; Imports from VERSION.dll
;
; BOOL __stdcall VerQueryValueW(const LPVOID pBlock, LPWSTR lpSubBlock,	LPVOID *lplpBuffer, PUINT puLen)
		extrn VerQueryValueW:dword ; CODE XREF:	sub_1000A8A8+3997p
					; DATA XREF: sub_1000A8A8+3997r ...
; BOOL __stdcall GetFileVersionInfoW(LPWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID	lpData)
		extrn GetFileVersionInfoW:dword	; CODE XREF: sub_1000A8A8+397Dp
					; DATA XREF: sub_1000A8A8+397Dr
; DWORD	__stdcall GetFileVersionInfoSizeW(LPWSTR lptstrFilename, LPDWORD lpdwHandle)
		extrn GetFileVersionInfoSizeW:dword ; CODE XREF: sub_1000A8A8+395Dp
					; DATA XREF: sub_1000A8A8+395Dr


; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 10016218h
dword_10016218	dd 0			; DATA XREF: sub_1000B330+1A6o
		dd offset sub_10001000
		dd offset sub_10001248
		dd offset sub_10001061
		dd offset sub_100010C2
		dd offset sub_100012A9
		dd offset sub_100011E2
		dd offset sub_10001120
		dd offset sub_10001181
		dd offset sub_1000130A
		dd offset sub_1000131B
		dd offset sub_1000132C
		dd offset sub_10001338
		dd offset sub_10001349
		dd offset sub_1000135A
dword_10016254	dd 0			; DATA XREF: sub_1000B330+1A1o
dword_10016258	dd 0			; DATA XREF: sub_1000B330+187o
		dd offset _pre_c_init
		dd offset ___atonexitinit
		dd offset sub_1000BDF0
dword_10016268	dd 2 dup(0)		; DATA XREF: sub_1000B330:loc_1000B4B2o
; CHAR LibFileName[]
LibFileName	db 'ntdll.dll',0        ; DATA XREF: DllBlocklist_Initialize(void)+23o
		align 4
; CHAR ProcName[]
ProcName	db 'LdrLoadDll',0       ; DATA XREF: sub_1000158C+8o
		align 4
; CHAR ModuleName[]
ModuleName	db 'user32.dll',0       ; DATA XREF: DllBlocklist_Initialize(void)o
		align 4
; CHAR Name[]
Name		db 'MALLOC_OPTIONS',0   ; DATA XREF: sub_100068E8+9o
		align 4
; char aMoz_app_restar[]
aMoz_app_restar	db 'MOZ_APP_RESTART',0  ; DATA XREF: mozilla::TimeStamp::ProcessCreation(bool &):loc_10006A33o
; CHAR aGettickcount64[]
aGettickcount64	db 'GetTickCount64',0   ; DATA XREF: mozilla::TimeStamp::Startup(void)+10o
		align 4
; const	WCHAR aKernel32_dll_0
aKernel32_dll_0:			; DATA XREF: mozilla::TimeStamp::Startup(void)+5o
		unicode	0, <kernel32.dll>,0
		align 10h
; char aGenuntelinei[]
aGenuntelinei	db 'GenuntelineI',0     ; DATA XREF: sub_100070FE+25o
		align 10h
aA		db '',0                ; DATA XREF: mozilla::SHA1Sum::finish(uchar (&)[20])+15o
		align 4
		dd 0Fh dup(0)
aNan		db 'NaN',0              ; DATA XREF: sub_100094D9+20o
					; WebCore::Decimal::toString(void):loc_10011DE6o
aInfinity	db 'Infinity',0         ; DATA XREF: sub_100094D9+16o
					; WebCore::Decimal::toString(void)+318o
		align 10h
; const	WCHAR Extension
Extension:				; DATA XREF: sub_1000AD10+14o
					; sub_1000AD10+4Eo
		unicode	0, <.dll>,0
		align 4
off_1001634C	dd offset unknown_libname_1 ; DATA XREF: sub_1000BF9Do
					; sub_1000BFA8o ...
					; Microsoft VisualC 2-11/net runtime
		dd offset _purecall
		dd offset _purecall
		dd offset sub_1000BF71
		dd offset sub_10010C47
		dd offset sub_10010C62
off_10016364	dd offset unknown_libname_1 ; DATA XREF: sub_1000AF86o
					; Microsoft VisualC 2-11/net runtime
		dd offset sub_1000BF8D
		dd offset sub_100112B7
		dd offset sub_10010C1C
		dd offset sub_10010C47
		dd offset sub_10010C62
off_1001637C	dd offset unknown_libname_1 ; DATA XREF: .data:off_1001A02Co
					; Microsoft VisualC 2-11/net runtime
		dd offset sub_1000BF81
		dd offset sub_10011268
		dd offset sub_1000BF71
		dd offset sub_10010C47
		dd offset sub_10010C62
off_10016394	dd offset unknown_libname_1 ; DATA XREF: sub_1000AF76o
					; Microsoft VisualC 2-11/net runtime
		dd offset sub_1000BF87
		dd offset sub_1001128D
		dd offset sub_1000BF71
		dd offset sub_10010C47
		dd offset sub_10010C62
		align 10h
; Debug	Directory entries
		dd 0			; Characteristics
		dd 5632BA58h		; TimeDateStamp: Fri Oct 30 00:31:20 2015
		dw 0			; MajorVersion
		dw 0			; MinorVersion
		dd 2			; Type:	IMAGE_DEBUG_TYPE_CODEVIEW
		dd 78h			; SizeOfData
		dd rva asc_10016EB8	; AddressOfRawData
		dd 154B8h		; PointerToRawData
		dd 0			; Characteristics
		dd 5632BA58h		; TimeDateStamp: Fri Oct 30 00:31:20 2015
		dw 0			; MajorVersion
		dw 0			; MinorVersion
		dd 0Ch			; Type
		dd 14h			; SizeOfData
		dd rva dword_10016F30	; AddressOfRawData
		dd 15530h		; PointerToRawData
		dd 0			; Characteristics
		dd 5632BA58h		; TimeDateStamp: Fri Oct 30 00:31:20 2015
		dw 0			; MajorVersion
		dw 0			; MinorVersion
		dd 0Ah			; Type:	IMAGE_DEBUG_TYPE_RESERVED10
		dd 4			; SizeOfData
		dd rva dword_10016F44	; AddressOfRawData
		dd 15544h		; PointerToRawData
off_10016404	dd offset dword_1001A4A8 ; DATA	XREF: ___report_gsfailure+EDo
					; ___report_securityfailure+C2o
		dd offset dword_1001A4F8
dword_1001640C	dd 0			; DATA XREF: ___DllMainCRTStartup:loc_1000B588r
					; ___DllMainCRTStartup+A8r ...
aGeneric	db 'generic',0          ; DATA XREF: sub_1000BF81o
aIostream	db 'iostream',0         ; DATA XREF: sub_1000BF87o
		align 4
aSystem		db 'system',0           ; DATA XREF: sub_1000BF8Do
		align 4
a0_		db '0.',0               ; DATA XREF: sub_100108BA+2o
					; WebCore::Decimal::toString(void):loc_10011F7Co
		align 10h
off_10016430	dd offset sub_10010440	; DATA XREF: sub_1000F947+4Fo
					; sub_1000FA58+24o ...
		dd offset ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Lock(void)
		dd offset ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Unlock(void)
		dd offset sub_100114CA
		dd offset sub_10011695
		dd offset ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ; std::basic_streambuf<char,std::char_traits<char>>::showmanyc(void)
		dd offset sub_10012162
		dd offset ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::uflow(void)
		dd offset ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ;	std::basic_streambuf<char,std::char_traits<char>>::xsgetn(char *,__int64)
		dd offset ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ;	std::basic_streambuf<char,std::char_traits<char>>::xsputn(char const *,__int64)
		dd offset sub_100118A4
		dd offset sub_10011ADD
		dd offset ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ; std::basic_streambuf<char,std::char_traits<char>>::setbuf(char *,__int64)
		dd offset ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ;	std::basic_streambuf<char,std::char_traits<char>>::sync(void)
		dd offset ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char>>::imbue(std::locale const	&)
		align 10h
__load_config_used dd 48h		; Size
		dd 0			; Time stamp
		dw 2 dup(0)		; Version: 0.0
		dd 0			; GlobalFlagsClear
		dd 0			; GlobalFlagsSet
		dd 0			; CriticalSectionDefaultTimeout
		dd 0			; DeCommitFreeBlockThreshold
		dd 0			; DeCommitTotalFreeThreshold
		dd 0			; LockPrefixTable
		dd 0			; MaximumAllocationSize
		dd 0			; VirtualMemoryThreshold
		dd 0			; ProcessAffinityMask
		dd 0			; ProcessHeapFlags
		dw 0			; CSDVersion
		dw 0			; Reserved1
		dd 0			; EditList
		dd offset ___security_cookie ; SecurityCookie
		dd offset ___safe_se_handler_table ; SEHandlerTable
		dd 1			; SEHandlerCount
		align 10h
dbl_100164C0	dq 1000.0		; DATA XREF: mozilla::TimeStamp::ProcessCreation(bool &)+9Br
					; mozilla::BaseTimeDurationPlatformUtils::ToSeconds(__int64)+1Ar
dbl_100164C8	dq -9.223372036854776e18
					; DATA XREF: mozilla::BaseTimeDurationPlatformUtils::TicksFromMilliseconds(double)+23r
dbl_100164D0	dq 9.223372036854776e18	; DATA XREF: mozilla::BaseTimeDurationPlatformUtils::TicksFromMilliseconds(double)+14r
dbl_100164D8	dq 0.3010299956639811	; DATA XREF: sub_10008958+178r
					; sub_1000A2C3+19r
dbl_100164E0	dq 1.0e-10		; DATA XREF: sub_10008958+17Er
aNpffaddon_dll	db 'npffaddon.dll',0    ; DATA XREF: .data:off_1001A030o
		align 4
aAvgrsstx_dll	db 'avgrsstx.dll',0     ; DATA XREF: .data:1001A048o
		align 4
aCalc_dll	db 'calc.dll',0         ; DATA XREF: .data:1001A060o
		align 4
aHook_dll	db 'hook.dll',0         ; DATA XREF: .data:1001A078o
		align 10h
aGoogledesktopn	db 'googledesktopnetwork3.dll',0 ; DATA XREF: .data:1001A090o
		align 4
aRdolib_dll	db 'rdolib.dll',0       ; DATA XREF: .data:1001A0A8o
		align 4
aFgjk4wvb_dll	db 'fgjk4wvb.dll',0     ; DATA XREF: .data:1001A0C0o
		align 4
aRadhslib_dll	db 'radhslib.dll',0     ; DATA XREF: .data:1001A0D8o
		align 4
aVksaver_dll	db 'vksaver.dll',0      ; DATA XREF: .data:1001A0F0o
aRlxf_dll	db 'rlxf.dll',0         ; DATA XREF: .data:1001A108o
		align 10h
aPsicon_dll	db 'psicon.dll',0       ; DATA XREF: .data:1001A120o
		align 4
aAccelerator_dl	db 'accelerator.dll',0  ; DATA XREF: .data:1001A138o
aRfFirefox_dll	db 'rf-firefox.dll',0   ; DATA XREF: .data:1001A150o
		align 4
aRoboform_dll	db 'roboform.dll',0     ; DATA XREF: .data:1001A168o
		align 4
aBabyfox_dll	db 'babyfox.dll',0      ; DATA XREF: .data:1001A180o
aSprotector_dll	db 'sprotector.dll',0   ; DATA XREF: .data:1001A198o
		align 4
aQipcap_dll	db 'qipcap.dll',0       ; DATA XREF: .data:1001A1B0o
		align 4
aMozdllblocking	db 'mozdllblockingtest.dll',0 ; DATA XREF: .data:1001A1C8o
		align 4
aMozdllblocki_0	db 'mozdllblockingtest_versioned.dll',0 ; DATA XREF: .data:1001A1E0o
		align 10h
aMfflac_dll	db 'mfflac.dll',0       ; DATA XREF: .data:1001A1F8o
		align 4
aRlnx_dll	db 'rlnx.dll',0         ; DATA XREF: .data:1001A210o
		align 4
aPmnx_dll	db 'pmnx.dll',0         ; DATA XREF: .data:1001A228o
		align 4
aOpnx_dll	db 'opnx.dll',0         ; DATA XREF: .data:1001A240o
		align 10h
aPrnx_dll	db 'prnx.dll',0         ; DATA XREF: .data:1001A258o
		align 4
aBeid35cardlaye	db 'beid35cardlayer.dll',0 ; DATA XREF: .data:1001A270o
aBitguard_dll	db 'bitguard.dll',0     ; DATA XREF: .data:1001A288o
		align 10h
aAtkdx11disp_dl	db 'atkdx11disp.dll',0  ; DATA XREF: .data:1001A2A0o
aSpvc32_dll	db 'spvc32.dll',0       ; DATA XREF: .data:1001A2B8o
		align 4
aFs_ccf_ni_umh3	db 'fs_ccf_ni_umh32.dll',0 ; DATA XREF: .data:1001A2D0o
aLibinject_dll	db 'libinject.dll',0    ; DATA XREF: .data:1001A2E8o
		align 10h
aLibinject2_dll	db 'libinject2.dll',0   ; DATA XREF: .data:1001A300o
		align 10h
aLibredir2_dll	db 'libredir2.dll',0    ; DATA XREF: .data:1001A318o
		align 10h
aRfFirefox22_dl	db 'rf-firefox-22.dll',0 ; DATA XREF: .data:1001A330o
		align 4
aRfFirefox40_dl	db 'rf-firefox-40.dll',0 ; DATA XREF: .data:1001A348o
		align 4
aDtwxsvc_dll	db 'dtwxsvc.dll',0      ; DATA XREF: .data:1001A360o
aActivedetect32	db 'activedetect32.dll',0 ; DATA XREF: .data:1001A378o
		align 4
aActivedetect64	db 'activedetect64.dll',0 ; DATA XREF: .data:1001A390o
		align 4
aWindowsapihook	db 'windowsapihookdll32.dll',0 ; DATA XREF: .data:1001A3A8o
aWindowsapiho_0	db 'windowsapihookdll64.dll',0 ; DATA XREF: .data:1001A3C0o
aRndlnpshimswf_	db 'rndlnpshimswf.dll',0 ; DATA XREF: .data:1001A3D8o
		align 10h
aRndlmainbrowse	db 'rndlmainbrowserrecordplugin.dll',0 ; DATA XREF: .data:1001A3F0o
aNprpffbrowserr	db 'nprpffbrowserrecordext.dll',0 ; DATA XREF: .data:1001A408o
		align 4
aNprndlffbrowse	db 'nprndlffbrowserrecordext.dll',0 ; DATA XREF: .data:1001A420o
		align 4
aYcwebcamerasou	db 'ycwebcamerasource.ax',0 ; DATA XREF: .data:1001A438o
		align 4
aVwcsource_ax	db 'vwcsource.ax',0     ; DATA XREF: .data:1001A450o
		align 4
aNlsp_dll	db 'nlsp.dll',0         ; DATA XREF: .data:1001A468o
byte_1001680D	db 2 dup(0)		; DATA XREF: sub_10005C56:loc_1000C6F8o
					; sub_100066AB:loc_1000D26Fo ...
byte_1001680F	db 0			; DATA XREF: realloc+1E7r realloc+353r ...
		dd 2000100h, 3000000h, 0
		dd 4000000h, 3 dup(0)
		dd 5000000h, 7 dup(0)
		dd 6000000h, 0Dh dup(0)
dword_10016884	dd 0			; DATA XREF: realloc+3BEr
					; sub_10002410+12Dr ...
		dd 0
		dd 7000000h, 0AAABh, 8001h, 6667h, 5556h, 4925h, 4001h
		dd 38E4h, 3334h, 2E8Ch,	2AABh, 2763h, 2493h, 2223h, 2001h
		dd 1E1Fh, 1C72h, 1AF3h,	199Ah, 1862h, 1746h, 1643h, 1556h
		dd 147Bh, 13B2h, 12F7h,	124Ah, 11A8h, 1112h, 1085h, 3 dup(0)
dword_10016910	dd 0			; DATA XREF: sub_1000A296:loc_1000A2A6r
					; sub_1000A296+1Dr
		dd 1, 0Ah, 64h,	3E8h, 2710h, 186A0h, 0F4240h, 989680h
		dd 5F5E100h, 3B9ACA00h,	0
dword_10016940	dd 81C0288h, 0FA8FD5A0h, 0FEA4FB3Ch, 0 ; DATA XREF: sub_1000A2C3+42o
					; sub_10013904+1Do
		dd 0A23EBF76h, 0BAAEE17Fh, 0FEACFB57h, 0
		dd 3055AC76h, 8B16FB20h, 0FEB4FB72h, 0
		dd 5DCE35EAh, 0CF42894Ah, 0FEBCFB8Ch, 0
		dd 55653B2Dh, 9A6BB0AAh, 0FEC4FBA7h, 0
		dd 3D1A45DFh, 0E61ACF03h, 0FECCFBC1h, 0
		dd 0C79AC6CAh, 0AB70FE17h, 0FED4FBDCh, 0
		dd 0BEBCDC4Fh, 0FF77B1FCh, 0FEDCFBF6h, 0
		dd 416BD60Ch, 0BE5691EFh, 0FEE4FC11h, 0
		dd 907FFC3Ch, 8DD01FADh, 0FEECFC2Ch, 0
		dd 31559A83h, 0D3515C28h, 0FEF4FC46h, 0
		dd 0ADA6C9B5h, 9D71AC8Fh, 0FEFCFC61h, 0
		dd 23EE8BCBh, 0EA9C2277h, 0FF04FC7Bh, 0
		dd 4078536Dh, 0AECC4991h, 0FF0CFC96h, 0
		dd 5DB6CE57h, 823C1279h, 0FF14FCB1h, 0
		dd 4DFB5637h, 0C2109436h, 0FF1CFCCBh, 0
		dd 3848984Fh, 9096EA6Fh, 0FF24FCE6h, 0
aVEt		db ':%t',0
		db 0FDh, 2Ch, 0FFh
		align 10h
		dd 97BF97F4h, 0A086CFCDh, 0FF34FD1Bh, 0
		dd 172AACE5h, 0EF340A98h, 0FF3CFD35h, 0
		dd 2A35B28Eh, 0B23867FBh, 0FF44FD50h, 0
		dd 0D2C63F3Bh, 84C8D4DFh, 0FF4CFD6Bh, 0
		dd 1AD3CDBAh, 0C5DD4427h, 0FF54FD85h, 0
		dd 0BB25C996h, 936B9FCEh, 0FF5CFDA0h, 0
		dd 7D62A584h, 0DBAC6C24h, 0FF64FDBAh, 0
		dd 0D5FDAF6h, 0A3AB6658h, 0FF6CFDD5h, 0
		dd 0DEC3F126h, 0F3E2F893h, 0FF74FDEFh, 0
		dd 0AAFF80B8h, 0B5B5ADA8h, 0FF7CFE0Ah, 0
		dd 6C7C4A8Bh, 87625F05h, 0FF84FE25h, 0
		dd 34C13053h, 0C9BCFF60h, 0FF8CFE3Fh, 0
		dd 91BA2655h, 964E858Ch, 0FF94FE5Ah, 0
		dd 70297EBDh, 0DFF97724h, 0FF9CFE74h, 0
		dd 0B8E5B88Fh, 0A6DFBD9Fh, 0FFA4FE8Fh, 0
		dd 88747D94h, 0F8A95FCFh, 0FFACFEA9h, 0
		dd 8FA89BCFh, 0B9447093h, 0FFB4FEC4h, 0
		dd 0BF0F156Bh, 8A08F0F8h, 0FFBCFEDFh, 0
		dd 653131B6h, 0CDB02555h, 0FFC4FEF9h, 0
		dd 0D07B7FACh, 993FE2C6h, 0FFCCFF14h, 0
		dd 2A2B3B06h, 0E45C10C4h, 0FFD4FF2Eh, 0
		dd 697392D3h, 0AA242499h, 0FFDCFF49h, 0
		dd 8300CA0Eh, 0FD87B5F2h, 0FFE4FF63h, 0
		dd 92111AEBh, 0BCE50864h, 0FFECFF7Eh, 0
		dd 6F5088CCh, 8CBCCC09h, 0FFF4FF99h, 0
		dd 0E219652Ch, 0D1B71758h, 0FFFCFFB3h, 2 dup(0)
		dd 9C400000h, 4FFCEh, 2	dup(0)
		dd 0E8D4A510h, 0CFFE8h,	0
		dd 0AC620000h, 0AD78EBC5h, 140003h, 0
		dd 0F8940984h, 813F3978h, 1C001Eh, 0
		dd 0C90715B3h, 0C097CE7Bh, 240038h, 0
aP2Ps		db 'p\{2~S',0
		db ',',0
		align 10h
aHasld8M	db 'h8m',0
a4		db '4',0
		align 10h
		dd 179A2245h, 9F4F2726h, 3C0088h, 0
		dd 0D4C4FB27h, 0ED63A231h, 4400A2h, 0
aInM8e		db '8e',0
		db 'L',0
		align 10h
		dd 1AAB65DBh, 83C7088Eh, 5400D8h, 0
		dd 42711D9Ah, 0C45D1DF9h, 5C00F2h, 0
		dd 0A61BE758h, 924D692Ch, 64010Dh, 0
		dd 1A708DEAh, 0DA01EE64h, 6C0127h, 0
		dd 9AEF774Ah, 0A26DA399h, 740142h, 0
		dd 0B47D6B85h, 0F209787Bh, 7C015Ch, 0
		dd 79DD1877h, 0B454E4A1h, 840177h, 0
		dd 5B9BC5C2h, 865B8692h, 8C0192h, 0
		dd 0C8965D3Dh, 0C83553C5h, 9401ACh, 0
		dd 0FA97A0B3h, 952AB45Ch, 9C01C7h, 0
		dd 99A05FE3h, 0DE469FBDh, 0A401E1h, 0
		dd 0DB398C25h, 0A59BC234h, 0AC01FCh, 0
		dd 0A3989F5Ch, 0F6C69A72h, 0B40216h, 0
		dd 54E9BECEh, 0B7DCBF53h, 0BC0231h, 0
		dd 0F22241E2h, 88FCF317h, 0C4024Ch, 0
		dd 0D35C78A5h, 0CC20CE9Bh, 0CC0266h, 0
		dd 7B2153DFh, 98165AF3h, 0D40281h, 0
		dd 971F303Ah, 0E2A0B5DCh, 0DC029Bh, 0
		dd 5CE3B396h, 0A8D9D153h, 0E402B6h, 0
		dd 0A4A7443Ch, 0FB9B7CD9h, 0EC02D0h, 0
		dd 0A7A44410h, 0BB764C4Ch, 0F402EBh, 0
		dd 0B6409C1Ah, 8BAB8EEFh, 0FC0306h, 0
		dd 0A657842Ch, 0D01FEF10h, 1040320h, 0
		dd 0E9913129h, 9B10A4E5h, 10C033Bh, 0
		dd 0A19C0C9Dh, 0E7109BFBh, 1140355h, 0
		dd 623BF429h, 0AC2820D9h, 11C0370h, 0
		dd 7AA7CF85h, 80444B5Eh, 124038Bh, 0
		dd 3ACDD2Dh, 0BF21E440h, 12C03A5h, 0
		dd 5E44FF8Fh, 8E679C2Fh, 13403C0h, 0
		dd 9C8CB841h, 0D433179Dh, 13C03DAh, 0
		dd 0B4E31BA9h, 9E19DB92h, 14403F5h, 0
		dd 0BADF77D9h, 0EB96BF6Eh, 14C040Fh, 0
		dd 9BF0EE6Bh, 0AF87023Bh, 154042Ah, 0
dbl_10016EB0	dq -0.0			; DATA XREF: sub_1001226A:loc_10012449r
					; sub_100124B5:loc_100126B0r ...
; Debug	information (IMAGE_DEBUG_TYPE_CODEVIEW)
asc_10016EB8	db 'RSDS'               ; DATA XREF: .rdata:100163C4o
					; CV signature
		dd 5DD29755h		; Data1	; GUID
		dw 0F397h		; Data2
		dw 41C1h		; Data3
		db 0ACh, 96h, 0FAh, 14h, 62h, 68h, 0ECh, 7Eh; Data4
		dd 2			; Age
		db 'c:\builds\moz2_slave\rel-m-rel-w32_bld-000000000000\build\obj-fir' ; PdbFileName
		db 'efox\mozglue\build\mozglue.pdb',0
; Debug	information (type 12)
dword_10016F30	dd 0			; DATA XREF: .rdata:100163E0o
		dd 2 dup(1Bh), 2 dup(0)
; Debug	information (IMAGE_DEBUG_TYPE_RESERVED10)
dword_10016F44	dd 50475500h, 2	dup(0)	; DATA XREF: .rdata:100163FCo
___safe_se_handler_table dd rva	__except_handler4 ; DATA XREF: .rdata:100164B0o
		align 10h
; char aA_0[2]
aA_0		db 'a',0                ; DATA XREF: sub_1000EC1C+4Bo
		align 4
asc_10016F64	db ',',0                ; DATA XREF: sub_1000EA23+69o
		align 4
a_		db '.',0                ; DATA XREF: sub_1000EA23+DCo
		align 4
asc_10016F6C	db ';',0                ; DATA XREF: sub_1000EA23+F4o
		align 10h
; char aLdrloaddllBloc[]
aLdrloaddllBloc	db 'LdrLoadDll: Blocking load of ',27h,'%s',27h,' (SearchPathW didn',27h,'t fi'
					; DATA XREF: sub_1000A8A8+386Fo
					; sub_1000A8A8+3A12o
		db 'nd it?)',0Ah,0
		align 4
; WCHAR	SubBlock
SubBlock	db '\',0                ; DATA XREF: sub_1000A8A8+3991o
		align 4
; char aLdrloaddllBl_0[]
aLdrloaddllBl_0	db 'LdrLoadDll: Blocking load of ',27h,'%s',27h,' -- see http://www.mozilla'
					; DATA XREF: sub_1000A8A8+39EBo
		db '.com/en-US/blocklist/',0Ah,0
		align 10h
; char aLdrloaddllBl_1[]
aLdrloaddllBl_1	db 'LdrLoadDll: Blocking load of ',27h,'%s',27h,'.  XPCOM components must s'
					; DATA XREF: sub_1000A8A8+3A36o
		db 'upport ASLR.',0Ah,0
		align 4
; char asc_1001705C[]
asc_1001705C	db 0Ah,0		; DATA XREF: DllBlocklist_WriteNotes(void *)+2Fo
					; mozalloc_abort(char const * const)+1Eo
		align 10h
aMapSetTTooLong	db 'map/set<T> too long',0 ; DATA XREF: sub_1000E3FC+1Ao
		align 8
aUser32beforebl	db 'User32BeforeBlocklist=1',0Ah,0
					; DATA XREF: DllBlocklist_WriteNotes(void *)+5Do
		align 4
aBlockeddlllist	db 'BlockedDllList=',0  ; DATA XREF: DllBlocklist_WriteNotes(void *)+19o
aBlocklistinitf	db 'BlocklistInitFailed=1',0Ah,0
					; DATA XREF: DllBlocklist_WriteNotes(void *)+46o
		align 4
		dd offset byte_10017340
		dd 0FFFFFh, 9, 1, 100000h, 2, 0
		dd 800h, 3, 1, 0Fh, 20h, 1, 8000000h, 1, 10h, 100h, 200h
		dd 2 dup(0)
		dd 41CDCD65h
dbl_10017110	dq 1.0			; DATA XREF: sub_10013162+59o
					; sub_10013162:loc_1001320Ar ...
		dd 0
		dd 40240000h, 0
		dd 40590000h, 0
		dd 408F4000h, 0
		dd 40C38800h, 0
		dd 40F86A00h, 0
aAd_a		db '.A',0
		align 4
		dd 416312D0h, 0
aDCa		db 'A',0
		align 4
aEA		db 'eA',0
		db 2 dup(0), 20h
		dd 4202A05Fh, 0E8000000h, 42374876h, 0A2000000h, 426D1A94h
		dd 0E5400000h, 42A2309Ch, 1E900000h, 42D6BCC4h,	26340000h
		dd 430C6BF5h, 37E08000h, 4341C379h, 85D8A000h, 43763457h
		dd 674EC800h, 43ABC16Dh, 60913D00h, 43E158E4h, 78B58C40h
		dd 4415AF1Dh, 0D6E2EF50h, 444B1AE4h, 64DD592h, 4480F0CFh
		dd 509F79FEh, 3FD34413h
; Exported entry  66. ?gTwoCharEscapes@detail@mozilla@@3QBDB
		public ?gTwoCharEscapes@detail@mozilla@@3QBDB
; char const * const mozilla::detail::gTwoCharEscapes
?gTwoCharEscapes@detail@mozilla@@3QBDB dd 2 dup(0) ; DATA XREF:	.rdata:off_100175A8o
		dd 6E7462h, 7266h, 4 dup(0)
		dd 220000h, 0Eh	dup(0)
		dd 5Ch,	28h dup(0)
; char aFatalStlThrewS[]
aFatalStlThrewS	db 'fatal: STL threw %s: ',0
					; DATA XREF: std::moz_Xinvalid_argument(char const *)-21o
		align 4
aInvalid_argume	db 'invalid_argument',0 ; DATA XREF: std::moz_Xinvalid_argument(char const *)+4o
		align 4
aLength_error	db 'length_error',0     ; DATA XREF: std::moz_Xlength_error(char const *)+4o
		align 4
aOut_of_range	db 'out_of_range',0     ; DATA XREF: std::moz_Xout_of_range(char const *)+4o
		align 4
aOverflow_error	db 'overflow_error',0   ; DATA XREF: std::moz_Xoverflow_error(char const *)+4o
		align 4
aRuntime_error	db 'runtime_error',0    ; DATA XREF: std::moz_Xruntime_error(char const *)+4o
		align 10h
byte_10017340	db 30h			; DATA XREF: mozalloc_handle_oom(uint)+44r
					; .rdata:100170BCo
a123456789abcde	db '123456789ABCDEF',0
		align 4
aOutOfMemory0x0	db 'out of memory: 0x0000000000000000 bytes requested',0
					; DATA XREF: mozalloc_handle_oom(uint)+1Eo
		align 4
aJemalloc	db '<jemalloc>',0       ; DATA XREF: sub_10005C56+6AAEo
					; sub_100066AB+6BD0o ...
		align 4
aMallocErrorInV	db ': (malloc) Error in VirtualFree()',0Ah,0 ; DATA XREF: sub_10005C56+6AA9o
		align 4
aMallocErrorIni	db ': (malloc) Error initializing arena',0Ah,0
					; DATA XREF: sub_100068B3+6B3Do
		align 10h
aCompileTimePag	db 'Compile-time page size does not divide the runtime one.',0Ah,0
					; DATA XREF: sub_100066AB+6BCBo
		align 4
asc_1001741C	db 27h,0Ah,0		; DATA XREF: sub_100066AB:loc_1000D344o
		align 10h
aMallocUnsuppor	db ': (malloc) Unsupported character in malloc options: ',27h,0
					; DATA XREF: sub_100066AB+6CA7o
		align 4
aUnknownError	db 'unknown error',0    ; DATA XREF: sub_10011268+Fo
					; sub_100112B7+Fo
		align 4
aIostreamStream	db 'iostream stream error',0 ; DATA XREF: sub_1001128D+Co
		align 10h
aInfinity_0	db '-Infinity',0        ; DATA XREF: WebCore::Decimal::toString(void):loc_100120B4o
		align 4
aE		db 'e',0                ; DATA XREF: WebCore::Decimal::toString(void)+29Do
		align 10h
aE_0		db 'e+',0               ; DATA XREF: WebCore::Decimal::toString(void)+2A4o
		align 4
aInvalidStringP	db 'invalid string position',0 ; DATA XREF: sub_1001068Fo
aStringTooLong	db 'string too long',0  ; DATA XREF: sub_10010683o
off_100174BC	dd offset sub_1000BF69	; DATA XREF: sub_1000F947+2Eo
					; sub_1000FA58+Fo
; Exported entry  68. ?kBase10MaximalLength@DoubleToStringConverter@double_conversion@@2HB
		public ?kBase10MaximalLength@DoubleToStringConverter@double_conversion@@2HB
; public: static int const double_conversion::DoubleToStringConverter::kBase10MaximalLength
?kBase10MaximalLength@DoubleToStringConverter@double_conversion@@2HB dd	11h
					; DATA XREF: .rdata:off_100175A8o
dword_100174C4	dd 0			; DATA XREF: sub_1000F947+Fo
		dd 50h,	0
dbl_100174D0	dq 1.0e9		; DATA XREF: mozilla::BaseTimeDurationPlatformUtils::ToSecondsSigDigits(__int64)+5Er
dbl_100174D8	dq 9.999999999999999e59	; DATA XREF: double_conversion::DoubleToStringConverter::ToFixed(double,int,double_conversion::StringBuilder *)+7Er
dbl_100174E0	dq -9.999999999999999e59
					; DATA XREF: double_conversion::DoubleToStringConverter::ToFixed(double,int,double_conversion::StringBuilder *)+97r
		dd 0
dword_100174EC	dd 2 dup(0)		; DATA XREF: sub_1000B90D+2o
					; sub_1000B90D+7o
dword_100174F4	dd 0			; DATA XREF: sub_1000B92D+2o
					; sub_1000B92D+7o
stru_100174F8	dd 0FFFFFFFEh		; GSCookieOffset ; DATA	XREF: sub_1000B00B+2o
		dd 0			; GSCookieXOROffset ; SEH scope	table for function 1000B00B
		dd 0FFFFFFCCh		; EHCookieOffset
		dd 0			; EHCookieXOROffset
		dd 0FFFFFFFEh		; ScopeRecord.EnclosingLevel
		dd 0			; ScopeRecord.FilterFunc
		dd offset loc_1000B0A8	; ScopeRecord.HandlerFunc
		align 8
stru_10017518	dd 0FFFFFFFEh		; GSCookieOffset
					; DATA XREF: ___DllMainCRTStartup+2o
		dd 0			; GSCookieXOROffset ; SEH scope	table for function 1000B54A
		dd 0FFFFFFD0h		; EHCookieOffset
		dd 0			; EHCookieXOROffset
		dd 0FFFFFFFEh		; ScopeRecord.EnclosingLevel
		dd 0			; ScopeRecord.FilterFunc
		dd offset $LN18		; ScopeRecord.HandlerFunc
		dd 0			; ScopeRecord.EnclosingLevel
		dd offset $LN22		; ScopeRecord.FilterFunc
		dd offset $LN23		; ScopeRecord.HandlerFunc
stru_10017540	dd 0FFFFFFFEh		; GSCookieOffset
					; DATA XREF: __IsNonwritableInCurrentImage+5o
		dd 0			; GSCookieXOROffset ; SEH scope	table for function 1000B780
		dd 0FFFFFFD8h		; EHCookieOffset
		dd 0			; EHCookieXOROffset
		dd 0FFFFFFFEh		; ScopeRecord.EnclosingLevel
		dd offset loc_1000B809	; ScopeRecord.FilterFunc
		dd offset loc_1000B81C	; ScopeRecord.HandlerFunc
		align 10h
stru_10017560	dd 0FFFFFFE4h		; GSCookieOffset ; DATA	XREF: sub_1000EA23+2o
		dd 0			; GSCookieXOROffset ; SEH scope	table for function 1000EA23
		dd 0FFFFFF9Ch		; EHCookieOffset
		dd 0			; EHCookieXOROffset
		dd 0FFFFFFFEh		; ScopeRecord.EnclosingLevel
		dd offset loc_1000EB27	; ScopeRecord.FilterFunc
		dd offset loc_1000EB2B	; ScopeRecord.HandlerFunc
		align 10h
;
; Export directory for mozglue.dll
;
		dd 0			; Characteristics
		dd 5632BA55h		; TimeDateStamp: Fri Oct 30 00:31:17 2015
		dw 0			; MajorVersion
		dw 0			; MinorVersion
		dd rva aMozglue_dll	; Name
		dd 1			; Base
		dd 7Fh			; NumberOfFunctions
		dd 7Fh			; NumberOfNames
		dd rva off_100175A8	; AddressOfFunctions
		dd rva off_100177A4	; AddressOfNames
		dd rva word_100179A0	; AddressOfNameOrdinals
;
; Export Address Table for mozglue.dll
;
off_100175A8	dd 2 dup(rva ??4Decimal@WebCore@@QAEAAV01@ABV01@@Z), rva ??0Decimal@WebCore@@QAE@H@Z
					; DATA XREF: .rdata:1001759Co
		dd rva ??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z,	rva ??0SHA1Sum@mozilla@@QAE@XZ ; DllBlocklist_Initialize(void)
		dd rva ??0TimeStampValue@mozilla@@AAE@_K0_N@Z, rva ??4Decimal@WebCore@@QAEAAV01@ABV01@@Z
		dd rva ??8Decimal@WebCore@@QBE_NABV01@@Z, rva ??9Decimal@WebCore@@QBE_NABV01@@Z
		dd rva ??DDecimal@WebCore@@QBE?AV01@ABV01@@Z, rva ??GDecimal@WebCore@@QBE?AV01@ABV01@@Z
		dd rva ??GDecimal@WebCore@@QBE?AV01@XZ,	rva ??GTimeStampValue@mozilla@@QBE_KABV01@@Z
		dd rva ??HDecimal@WebCore@@QBE?AV01@ABV01@@Z, rva ??KDecimal@WebCore@@QBE?AV01@ABV01@@Z
		dd rva ??MDecimal@WebCore@@QBE_NABV01@@Z, rva ??NDecimal@WebCore@@QBE_NABV01@@Z
		dd rva ??ODecimal@WebCore@@QBE_NABV01@@Z, rva ??PDecimal@WebCore@@QBE_NABV01@@Z
		dd rva ??XDecimal@WebCore@@QAEAAV01@ABV01@@Z, rva ??YDecimal@WebCore@@QAEAAV01@ABV01@@Z
		dd rva ??YTimeStampValue@mozilla@@QAEAAV01@_J@Z, rva ??ZDecimal@WebCore@@QAEAAV01@ABV01@@Z
		dd rva ??ZTimeStampValue@mozilla@@QAEAAV01@_J@Z, rva ??_0Decimal@WebCore@@QAEAAV01@ABV01@@Z
		dd rva ??_FDecimal@WebCore@@QAEXXZ, rva	?CheckQPC@TimeStampValue@mozilla@@ABE_KABV12@@Z
		dd rva ?ComputeProcessUptime@TimeStamp@mozilla@@CA_KXZ
		dd rva ?CreateDecimalRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHHPAVStringBuilder@2@@Z
		dd rva ?CreateExponentialRepresentation@DoubleToStringConverter@double_conversion@@ABEXPBDHHPAVStringBuilder@2@@Z
		dd rva ?DllBlocklist_Initialize@@YAXXZ,	rva ?DllBlocklist_SetInXPCOMLoadOnMainThread@@YAX_N@Z
		dd rva ?DllBlocklist_WriteNotes@@YAXPAX@Z, rva ?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4DtoaMode@12@HPADHPA_NPAH3@Z
		dd rva ?EcmaScriptConverter@DoubleToStringConverter@double_conversion@@SAABV12@XZ
		dd rva ?HandleSpecialValues@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@@Z
		dd rva ?HashBytes@mozilla@@YAIPBXI@Z, rva ?IsFloat32Representable@mozilla@@YA_NN@Z
		dd rva ?Now@TimeStamp@mozilla@@CA?AV12@_N@Z, rva ?ProcessCreation@TimeStamp@mozilla@@SA?AV12@AA_N@Z
		dd rva ?RecordProcessRestart@TimeStamp@mozilla@@SAXXZ
		dd rva ?ResolutionInTicks@BaseTimeDurationPlatformUtils@mozilla@@SA_JXZ
		dd rva ?Shutdown@TimeStamp@mozilla@@SAXXZ, rva ?Startup@TimeStamp@mozilla@@SAXXZ
		dd rva ?TicksFromMilliseconds@BaseTimeDurationPlatformUtils@mozilla@@SA_JN@Z
		dd rva ?ToExponential@DoubleToStringConverter@double_conversion@@QBE_NNHPAVStringBuilder@2@@Z
		dd rva ?ToFixed@DoubleToStringConverter@double_conversion@@QBE_NNHPAVStringBuilder@2@@Z
		dd rva ?ToPrecision@DoubleToStringConverter@double_conversion@@QBE_NNHPA_NPAVStringBuilder@2@@Z
		dd rva ?ToSeconds@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@Z
		dd rva ?ToSecondsSigDigits@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@Z
		dd rva ?ToShortestIeeeNumber@DoubleToStringConverter@double_conversion@@ABE_NNPAVStringBuilder@2@W4DtoaMode@12@@Z
		dd rva ?abs@Decimal@WebCore@@QBE?AV12@XZ, rva ?alignOperands@Decimal@WebCore@@CA?AUAlignedOperands@12@ABV12@0@Z
		dd rva ?ceiling@Decimal@WebCore@@QBE?AV12@XZ, rva ?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z
		dd rva ?compress@LZ4@Compression@mozilla@@SAIPBDIPAD@Z
		dd rva ?compressLimitedOutput@LZ4@Compression@mozilla@@SAIPBDIPADI@Z
		dd rva ?decompress@LZ4@Compression@mozilla@@SA_NPBDIPADIPAI@Z
		dd rva ?decompress@LZ4@Compression@mozilla@@SA_NPBDPADI@Z
		dd rva ?finish@SHA1Sum@mozilla@@QAEXAAY0BE@E@Z,	rva ?floor@Decimal@WebCore@@QBE?AV12@XZ
		dd rva ?fromDouble@Decimal@WebCore@@SA?AV12@N@Z, rva ?fromString@Decimal@WebCore@@SA?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
		dd rva ?gChaosFeatures@detail@mozilla@@3W4ChaosFeature@2@A
		dd rva ?gChaosModeCounter@detail@mozilla@@3V?$Atomic@I$01X@2@A
		dd rva ?gTwoCharEscapes@detail@mozilla@@3QBDB, rva ?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z
		dd rva ?kBase10MaximalLength@DoubleToStringConverter@double_conversion@@2HB
		dd rva ?mmx_enabled@sse_private@mozilla@@3_NA, rva ?moz_Xinvalid_argument@std@@YAXPBD@Z
		dd rva ?moz_Xlength_error@std@@YAXPBD@Z, rva ?moz_Xout_of_range@std@@YAXPBD@Z
		dd rva ?moz_Xoverflow_error@std@@YAXPBD@Z, rva ?moz_Xruntime_error@std@@YAXPBD@Z
		dd rva ?mozalloc_abort@@YAXQBD@Z, rva ?mozalloc_handle_oom@@YAXI@Z
		dd rva ?mozalloc_set_oom_abort_handler@@YAXP6AXI@Z@Z, rva ?mozilla_Throw@std@@YAXABVexception@stdext@@@Z
		dd rva ?nan@Decimal@WebCore@@SA?AV12@XZ, rva ?remainder@Decimal@WebCore@@QBE?AV12@ABV12@@Z
		dd rva ?round@Decimal@WebCore@@QBE?AV12@XZ, rva	?sse2_enabled@sse_private@mozilla@@3_NA
		dd rva ?sse3_enabled@sse_private@mozilla@@3_NA,	rva ?sse4_1_enabled@sse_private@mozilla@@3_NA
		dd rva ?sse4_2_enabled@sse_private@mozilla@@3_NA, rva ?sse4a_enabled@sse_private@mozilla@@3_NA
		dd rva ?sse_enabled@sse_private@mozilla@@3_NA, rva ?ssse3_enabled@sse_private@mozilla@@3_NA
		dd rva ?toDouble@Decimal@WebCore@@QBENXZ, rva ?toString@Decimal@WebCore@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
		dd rva ?toString@Decimal@WebCore@@QBE_NPADI@Z, rva ?unused@mozilla@@3Uunused_t@1@B
		dd rva ?update@SHA1Sum@mozilla@@QAEXPBXI@Z, rva	?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z
		dd rva free, rva _aligned_malloc, rva _expand, rva _malloc_message
		dd rva _malloc_options,	rva malloc_usable_size,	rva _recalloc
		dd rva strdup, rva wcsdup, rva calloc, rva free, rva jemalloc_purge_freed_pages
		dd rva gMozillaPoisonBase, rva gMozillaPoisonSize, rva gMozillaPoisonValue
		dd rva jemalloc_free_dirty_pages, rva jemalloc_purge_freed_pages
		dd rva jemalloc_stats, rva malloc, rva malloc_good_size
		dd rva malloc_usable_size, rva mozPoisonValueInit, rva moz_malloc_size_of
		dd rva moz_malloc_usable_size, rva moz_xcalloc,	rva moz_xmalloc
		dd rva moz_xrealloc, rva moz_xstrdup, rva posix_memalign
		dd rva realloc,	rva strdup, rva	strndup, rva wcsdup
;
; Export Names Table for mozglue.dll
;
off_100177A4	dd rva a??0decimal@web,	rva a??0decimal@w_0, rva a??0decimal@w_1
					; DATA XREF: .rdata:100175A0o
		dd rva a??0decimal@w_2,	rva a??0sha1sum@moz, rva a??0timestampva ; "??0Decimal@WebCore@@QAE@ABV01@@Z"
		dd rva a??4decimal@web,	rva a??8decimal@web, rva a??9decimal@web
		dd rva a??ddecimal@web,	rva a??gdecimal@web, rva a??gdecimal@w_0
		dd rva a??gtimestampva,	rva a??hdecimal@web, rva a??kdecimal@web
		dd rva a??mdecimal@web,	rva a??ndecimal@web, rva a??odecimal@web
		dd rva a??pdecimal@web,	rva a??xdecimal@web, rva a??ydecimal@web
		dd rva a??ytimestampva,	rva a??zdecimal@web, rva a??ztimestampva
		dd rva a??_0decimal@we,	rva a??_fdecimal@we, rva a?checkqpc@time
		dd rva a?computeproces,	rva a?createdecimal, rva a?createexponen
		dd rva a?dllblocklist_,	rva a?dllblocklis_0, rva a?dllblocklis_1
		dd rva a?doubletoascii,	rva a?ecmascriptcon, rva a?handlespecial
		dd rva a?hashbytes@moz,	rva a?isfloat32repr, rva a?now@timestamp
		dd rva a?processcreati,	rva a?recordprocess, rva a?resolutionint
		dd rva a?shutdown@time,	rva a?startup@times, rva a?ticksfrommill
		dd rva a?toexponential,	rva a?tofixed@doubl, rva a?toprecision@d
		dd rva a?toseconds@bas,	rva a?tosecondssigd, rva a?toshortestiee
		dd rva a?abs@decimal@w,	rva a?alignoperands, rva a?ceiling@decim
		dd rva a?compareto@dec,	rva a?compress@lz4@, rva a?compresslimit
		dd rva a?decompress@lz,	rva a?decompress@_0, rva a?finish@sha1su
		dd rva a?floor@decimal,	rva a?fromdouble@de, rva a?fromstring@de
		dd rva a?gchaosfeature,	rva a?gchaosmodecou, rva a?gtwocharescap
		dd rva a?infinity@deci,	rva a?kbase10maxima, rva a?mmx_enabled@s
		dd rva a?moz_xinvalid_,	rva a?moz_xlength_e, rva a?moz_xout_of_r
		dd rva a?moz_xoverflow,	rva a?moz_xruntime_, rva a?mozalloc_abor
		dd rva a?mozalloc_hand,	rva a?mozalloc_set_, rva a?mozilla_throw
		dd rva a?nan@decimal@w,	rva a?remainder@dec, rva a?round@decimal
		dd rva a?sse2_enabled@,	rva a?sse3_enabled@, rva a?sse4_1_enable
		dd rva a?sse4_2_enable,	rva a?sse4a_enabled, rva a?sse_enabled@s
		dd rva a?ssse3_enabled,	rva a?todouble@deci, rva a?tostring@deci
		dd rva a?tostring@de_0,	rva a?unused@mozill, rva a?update@sha1su
		dd rva a?zero@decimal@,	rva a_aligned_free, rva	a_aligned_mallo
		dd rva a_expand, rva a_malloc_messag, rva a_malloc_option
		dd rva a_msize,	rva a_recalloc,	rva a_strdup, rva a_wcsdup
		dd rva aCalloc,	rva aFree, rva aFrex, rva aGmozillapoison
		dd rva aGmozillapois_0,	rva aGmozillapois_1, rva aJemalloc_free_
		dd rva aJemalloc_purge,	rva aJemalloc_stats, rva aMalloc
		dd rva aMalloc_good_si,	rva aMalloc_usable_, rva aMozpoisonvalue
		dd rva aMoz_malloc_siz,	rva aMoz_malloc_usa, rva aMoz_xcalloc
		dd rva aMoz_xmalloc, rva aMoz_xrealloc,	rva aMoz_xstrdup
		dd rva aPosix_memalign,	rva aRealloc, rva aStrdup, rva aStrndup
		dd rva aWcsdup
;
; Export Ordinals Table	for mozglue.dll
;
word_100179A0	dw 0, 1, 2, 3, 4, 5, 6,	7, 8, 9, 0Ah, 0Bh, 0Ch,	0Dh, 0Eh
					; DATA XREF: .rdata:100175A4o
		dw 0Fh,	10h, 11h, 12h, 13h, 14h, 15h, 16h, 17h,	18h, 19h
		dw 1Ah,	1Bh, 1Ch, 1Dh, 1Eh, 1Fh, 20h, 21h, 22h,	23h, 24h
		dw 25h,	26h, 27h, 28h, 29h, 2Ah, 2Bh, 2Ch, 2Dh,	2Eh, 2Fh
		dw 30h,	31h, 32h, 33h, 34h, 35h, 36h, 37h, 38h,	39h, 3Ah
		dw 3Bh,	3Ch, 3Dh, 3Eh, 3Fh, 40h, 41h, 42h, 43h,	44h, 45h
		dw 46h,	47h, 48h, 49h, 4Ah, 4Bh, 4Ch, 4Dh, 4Eh,	4Fh, 50h
		dw 51h,	52h, 53h, 54h, 55h, 56h, 57h, 58h, 59h,	5Ah, 5Bh
		dw 5Ch,	5Dh, 5Eh, 5Fh, 60h, 61h, 62h, 63h, 64h,	65h, 66h
		dw 67h,	68h, 69h, 6Ah, 6Bh, 6Ch, 6Dh, 6Eh, 6Fh,	70h, 71h
		dw 72h,	73h, 74h, 75h, 76h, 77h, 78h, 79h, 7Ah,	7Bh, 7Ch
		dw 7Dh,	7Eh
aMozglue_dll	db 'mozglue.dll',0      ; DATA XREF: .rdata:1001758Co
a??0decimal@web	db '??0Decimal@WebCore@@QAE@ABV01@@Z',0 ; DATA XREF: .rdata:off_100177A4o
a??0decimal@w_0	db '??0Decimal@WebCore@@QAE@ABVEncodedData@01@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??0decimal@w_1	db '??0Decimal@WebCore@@QAE@H@Z',0 ; DATA XREF: .rdata:off_100177A4o
a??0decimal@w_2	db '??0Decimal@WebCore@@QAE@W4Sign@01@H_K@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??0sha1sum@moz	db '??0SHA1Sum@mozilla@@QAE@XZ',0 ; DATA XREF: .rdata:off_100177A4o
a??0timestampva	db '??0TimeStampValue@mozilla@@AAE@_K0_N@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??4decimal@web	db '??4Decimal@WebCore@@QAEAAV01@ABV01@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??8decimal@web	db '??8Decimal@WebCore@@QBE_NABV01@@Z',0 ; DATA XREF: .rdata:off_100177A4o
a??9decimal@web	db '??9Decimal@WebCore@@QBE_NABV01@@Z',0 ; DATA XREF: .rdata:off_100177A4o
a??ddecimal@web	db '??DDecimal@WebCore@@QBE?AV01@ABV01@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??gdecimal@web	db '??GDecimal@WebCore@@QBE?AV01@ABV01@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??gdecimal@w_0	db '??GDecimal@WebCore@@QBE?AV01@XZ',0 ; DATA XREF: .rdata:off_100177A4o
a??gtimestampva	db '??GTimeStampValue@mozilla@@QBE_KABV01@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??hdecimal@web	db '??HDecimal@WebCore@@QBE?AV01@ABV01@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??kdecimal@web	db '??KDecimal@WebCore@@QBE?AV01@ABV01@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??mdecimal@web	db '??MDecimal@WebCore@@QBE_NABV01@@Z',0 ; DATA XREF: .rdata:off_100177A4o
a??ndecimal@web	db '??NDecimal@WebCore@@QBE_NABV01@@Z',0 ; DATA XREF: .rdata:off_100177A4o
a??odecimal@web	db '??ODecimal@WebCore@@QBE_NABV01@@Z',0 ; DATA XREF: .rdata:off_100177A4o
a??pdecimal@web	db '??PDecimal@WebCore@@QBE_NABV01@@Z',0 ; DATA XREF: .rdata:off_100177A4o
a??xdecimal@web	db '??XDecimal@WebCore@@QAEAAV01@ABV01@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??ydecimal@web	db '??YDecimal@WebCore@@QAEAAV01@ABV01@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??ytimestampva	db '??YTimeStampValue@mozilla@@QAEAAV01@_J@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??zdecimal@web	db '??ZDecimal@WebCore@@QAEAAV01@ABV01@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??ztimestampva	db '??ZTimeStampValue@mozilla@@QAEAAV01@_J@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??_0decimal@we	db '??_0Decimal@WebCore@@QAEAAV01@ABV01@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a??_fdecimal@we	db '??_FDecimal@WebCore@@QAEXXZ',0 ; DATA XREF: .rdata:off_100177A4o
a?checkqpc@time	db '?CheckQPC@TimeStampValue@mozilla@@ABE_KABV12@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?computeproces	db '?ComputeProcessUptime@TimeStamp@mozilla@@CA_KXZ',0
					; DATA XREF: .rdata:off_100177A4o
a?createdecimal	db '?CreateDecimalRepresentation@DoubleToStringConverter@double_conve'
					; DATA XREF: .rdata:off_100177A4o
		db 'rsion@@ABEXPBDHHHPAVStringBuilder@2@@Z',0
a?createexponen	db '?CreateExponentialRepresentation@DoubleToStringConverter@double_c'
					; DATA XREF: .rdata:off_100177A4o
		db 'onversion@@ABEXPBDHHPAVStringBuilder@2@@Z',0
a?dllblocklist_	db '?DllBlocklist_Initialize@@YAXXZ',0 ; DATA XREF: .rdata:off_100177A4o
a?dllblocklis_0	db '?DllBlocklist_SetInXPCOMLoadOnMainThread@@YAX_N@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?dllblocklis_1	db '?DllBlocklist_WriteNotes@@YAXPAX@Z',0 ; DATA XREF: .rdata:off_100177A4o
a?doubletoascii	db '?DoubleToAscii@DoubleToStringConverter@double_conversion@@SAXNW4D'
					; DATA XREF: .rdata:off_100177A4o
		db 'toaMode@12@HPADHPA_NPAH3@Z',0
a?ecmascriptcon	db '?EcmaScriptConverter@DoubleToStringConverter@double_conversion@@S'
					; DATA XREF: .rdata:off_100177A4o
		db 'AABV12@XZ',0
a?handlespecial	db '?HandleSpecialValues@DoubleToStringConverter@double_conversion@@A'
					; DATA XREF: .rdata:off_100177A4o
		db 'BE_NNPAVStringBuilder@2@@Z',0
a?hashbytes@moz	db '?HashBytes@mozilla@@YAIPBXI@Z',0 ; DATA XREF: .rdata:off_100177A4o
a?isfloat32repr	db '?IsFloat32Representable@mozilla@@YA_NN@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?now@timestamp	db '?Now@TimeStamp@mozilla@@CA?AV12@_N@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?processcreati	db '?ProcessCreation@TimeStamp@mozilla@@SA?AV12@AA_N@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?recordprocess	db '?RecordProcessRestart@TimeStamp@mozilla@@SAXXZ',0
					; DATA XREF: .rdata:off_100177A4o
a?resolutionint	db '?ResolutionInTicks@BaseTimeDurationPlatformUtils@mozilla@@SA_JXZ',0
					; DATA XREF: .rdata:off_100177A4o
a?shutdown@time	db '?Shutdown@TimeStamp@mozilla@@SAXXZ',0 ; DATA XREF: .rdata:off_100177A4o
a?startup@times	db '?Startup@TimeStamp@mozilla@@SAXXZ',0 ; DATA XREF: .rdata:off_100177A4o
a?ticksfrommill	db '?TicksFromMilliseconds@BaseTimeDurationPlatformUtils@mozilla@@SA_'
					; DATA XREF: .rdata:off_100177A4o
		db 'JN@Z',0
a?toexponential	db '?ToExponential@DoubleToStringConverter@double_conversion@@QBE_NNH'
					; DATA XREF: .rdata:off_100177A4o
		db 'PAVStringBuilder@2@@Z',0
a?tofixed@doubl	db '?ToFixed@DoubleToStringConverter@double_conversion@@QBE_NNHPAVStr'
					; DATA XREF: .rdata:off_100177A4o
		db 'ingBuilder@2@@Z',0
a?toprecision@d	db '?ToPrecision@DoubleToStringConverter@double_conversion@@QBE_NNHPA'
					; DATA XREF: .rdata:off_100177A4o
		db '_NPAVStringBuilder@2@@Z',0
a?toseconds@bas	db '?ToSeconds@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?tosecondssigd	db '?ToSecondsSigDigits@BaseTimeDurationPlatformUtils@mozilla@@SAN_J@'
					; DATA XREF: .rdata:off_100177A4o
		db 'Z',0
a?toshortestiee	db '?ToShortestIeeeNumber@DoubleToStringConverter@double_conversion@@'
					; DATA XREF: .rdata:off_100177A4o
		db 'ABE_NNPAVStringBuilder@2@W4DtoaMode@12@@Z',0
a?abs@decimal@w	db '?abs@Decimal@WebCore@@QBE?AV12@XZ',0 ; DATA XREF: .rdata:off_100177A4o
a?alignoperands	db '?alignOperands@Decimal@WebCore@@CA?AUAlignedOperands@12@ABV12@0@Z'
					; DATA XREF: .rdata:off_100177A4o
		db 0
a?ceiling@decim	db '?ceiling@Decimal@WebCore@@QBE?AV12@XZ',0
					; DATA XREF: .rdata:off_100177A4o
a?compareto@dec	db '?compareTo@Decimal@WebCore@@ABE?AV12@ABV12@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?compress@lz4@	db '?compress@LZ4@Compression@mozilla@@SAIPBDIPAD@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?compresslimit	db '?compressLimitedOutput@LZ4@Compression@mozilla@@SAIPBDIPADI@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?decompress@lz	db '?decompress@LZ4@Compression@mozilla@@SA_NPBDIPADIPAI@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?decompress@_0	db '?decompress@LZ4@Compression@mozilla@@SA_NPBDPADI@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?finish@sha1su	db '?finish@SHA1Sum@mozilla@@QAEXAAY0BE@E@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?floor@decimal	db '?floor@Decimal@WebCore@@QBE?AV12@XZ',0 ; DATA XREF: .rdata:off_100177A4o
a?fromdouble@de	db '?fromDouble@Decimal@WebCore@@SA?AV12@N@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?fromstring@de	db '?fromString@Decimal@WebCore@@SA?AV12@ABV?$basic_string@DU?$char_t'
					; DATA XREF: .rdata:off_100177A4o
		db 'raits@D@std@@V?$allocator@D@2@@std@@@Z',0
a?gchaosfeature	db '?gChaosFeatures@detail@mozilla@@3W4ChaosFeature@2@A',0
					; DATA XREF: .rdata:off_100177A4o
a?gchaosmodecou	db '?gChaosModeCounter@detail@mozilla@@3V?$Atomic@I$01X@2@A',0
					; DATA XREF: .rdata:off_100177A4o
a?gtwocharescap	db '?gTwoCharEscapes@detail@mozilla@@3QBDB',0
					; DATA XREF: .rdata:off_100177A4o
a?infinity@deci	db '?infinity@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?kbase10maxima	db '?kBase10MaximalLength@DoubleToStringConverter@double_conversion@@'
					; DATA XREF: .rdata:off_100177A4o
		db '2HB',0
a?mmx_enabled@s	db '?mmx_enabled@sse_private@mozilla@@3_NA',0
					; DATA XREF: .rdata:off_100177A4o
a?moz_xinvalid_	db '?moz_Xinvalid_argument@std@@YAXPBD@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?moz_xlength_e	db '?moz_Xlength_error@std@@YAXPBD@Z',0 ; DATA XREF: .rdata:off_100177A4o
a?moz_xout_of_r	db '?moz_Xout_of_range@std@@YAXPBD@Z',0 ; DATA XREF: .rdata:off_100177A4o
a?moz_xoverflow	db '?moz_Xoverflow_error@std@@YAXPBD@Z',0 ; DATA XREF: .rdata:off_100177A4o
a?moz_xruntime_	db '?moz_Xruntime_error@std@@YAXPBD@Z',0 ; DATA XREF: .rdata:off_100177A4o
a?mozalloc_abor	db '?mozalloc_abort@@YAXQBD@Z',0 ; DATA XREF: .rdata:off_100177A4o
a?mozalloc_hand	db '?mozalloc_handle_oom@@YAXI@Z',0 ; DATA XREF: .rdata:off_100177A4o
a?mozalloc_set_	db '?mozalloc_set_oom_abort_handler@@YAXP6AXI@Z@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?mozilla_throw	db '?mozilla_Throw@std@@YAXABVexception@stdext@@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?nan@decimal@w	db '?nan@Decimal@WebCore@@SA?AV12@XZ',0 ; DATA XREF: .rdata:off_100177A4o
a?remainder@dec	db '?remainder@Decimal@WebCore@@QBE?AV12@ABV12@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?round@decimal	db '?round@Decimal@WebCore@@QBE?AV12@XZ',0 ; DATA XREF: .rdata:off_100177A4o
a?sse2_enabled@	db '?sse2_enabled@sse_private@mozilla@@3_NA',0
					; DATA XREF: .rdata:off_100177A4o
a?sse3_enabled@	db '?sse3_enabled@sse_private@mozilla@@3_NA',0
					; DATA XREF: .rdata:off_100177A4o
a?sse4_1_enable	db '?sse4_1_enabled@sse_private@mozilla@@3_NA',0
					; DATA XREF: .rdata:off_100177A4o
a?sse4_2_enable	db '?sse4_2_enabled@sse_private@mozilla@@3_NA',0
					; DATA XREF: .rdata:off_100177A4o
a?sse4a_enabled	db '?sse4a_enabled@sse_private@mozilla@@3_NA',0
					; DATA XREF: .rdata:off_100177A4o
a?sse_enabled@s	db '?sse_enabled@sse_private@mozilla@@3_NA',0
					; DATA XREF: .rdata:off_100177A4o
a?ssse3_enabled	db '?ssse3_enabled@sse_private@mozilla@@3_NA',0
					; DATA XREF: .rdata:off_100177A4o
a?todouble@deci	db '?toDouble@Decimal@WebCore@@QBENXZ',0 ; DATA XREF: .rdata:off_100177A4o
a?tostring@deci	db '?toString@Decimal@WebCore@@QBE?AV?$basic_string@DU?$char_traits@D'
					; DATA XREF: .rdata:off_100177A4o
		db '@std@@V?$allocator@D@2@@std@@XZ',0
a?tostring@de_0	db '?toString@Decimal@WebCore@@QBE_NPADI@Z',0
					; DATA XREF: .rdata:off_100177A4o
a?unused@mozill	db '?unused@mozilla@@3Uunused_t@1@B',0 ; DATA XREF: .rdata:off_100177A4o
a?update@sha1su	db '?update@SHA1Sum@mozilla@@QAEXPBXI@Z',0 ; DATA XREF: .rdata:off_100177A4o
a?zero@decimal@	db '?zero@Decimal@WebCore@@SA?AV12@W4Sign@12@@Z',0
					; DATA XREF: .rdata:off_100177A4o
a_aligned_free	db '_aligned_free',0    ; DATA XREF: .rdata:off_100177A4o
a_aligned_mallo	db '_aligned_malloc',0  ; DATA XREF: .rdata:off_100177A4o
a_expand	db '_expand',0          ; DATA XREF: .rdata:off_100177A4o
a_malloc_messag	db '_malloc_message',0  ; DATA XREF: .rdata:off_100177A4o
a_malloc_option	db '_malloc_options',0  ; DATA XREF: .rdata:off_100177A4o
a_msize		db '_msize',0           ; DATA XREF: .rdata:off_100177A4o
a_recalloc	db '_recalloc',0        ; DATA XREF: .rdata:off_100177A4o
a_strdup	db '_strdup',0          ; DATA XREF: .rdata:off_100177A4o
a_wcsdup	db '_wcsdup',0          ; DATA XREF: .rdata:off_100177A4o
aCalloc		db 'calloc',0           ; DATA XREF: .rdata:off_100177A4o
aFree		db 'free',0             ; DATA XREF: .rdata:off_100177A4o
aFrex		db 'frex',0             ; DATA XREF: .rdata:off_100177A4o
aGmozillapoison	db 'gMozillaPoisonBase',0 ; DATA XREF: .rdata:off_100177A4o
aGmozillapois_0	db 'gMozillaPoisonSize',0 ; DATA XREF: .rdata:off_100177A4o
aGmozillapois_1	db 'gMozillaPoisonValue',0 ; DATA XREF: .rdata:off_100177A4o
aJemalloc_free_	db 'jemalloc_free_dirty_pages',0 ; DATA XREF: .rdata:off_100177A4o
aJemalloc_purge	db 'jemalloc_purge_freed_pages',0 ; DATA XREF: .rdata:off_100177A4o
aJemalloc_stats	db 'jemalloc_stats',0   ; DATA XREF: .rdata:off_100177A4o
aMalloc		db 'malloc',0           ; DATA XREF: .rdata:off_100177A4o
aMalloc_good_si	db 'malloc_good_size',0 ; DATA XREF: .rdata:off_100177A4o
aMalloc_usable_	db 'malloc_usable_size',0 ; DATA XREF: .rdata:off_100177A4o
aMozpoisonvalue	db 'mozPoisonValueInit',0 ; DATA XREF: .rdata:off_100177A4o
aMoz_malloc_siz	db 'moz_malloc_size_of',0 ; DATA XREF: .rdata:off_100177A4o
aMoz_malloc_usa	db 'moz_malloc_usable_size',0 ; DATA XREF: .rdata:off_100177A4o
aMoz_xcalloc	db 'moz_xcalloc',0      ; DATA XREF: .rdata:off_100177A4o
aMoz_xmalloc	db 'moz_xmalloc',0      ; DATA XREF: .rdata:off_100177A4o
aMoz_xrealloc	db 'moz_xrealloc',0     ; DATA XREF: .rdata:off_100177A4o
aMoz_xstrdup	db 'moz_xstrdup',0      ; DATA XREF: .rdata:off_100177A4o
aPosix_memalign	db 'posix_memalign',0   ; DATA XREF: .rdata:off_100177A4o
aRealloc	db 'realloc',0          ; DATA XREF: .rdata:off_100177A4o
aStrdup		db 'strdup',0           ; DATA XREF: .rdata:off_100177A4o
aStrndup	db 'strndup',0          ; DATA XREF: .rdata:off_100177A4o
aWcsdup		db 'wcsdup',0           ; DATA XREF: .rdata:off_100177A4o
__IMPORT_DESCRIPTOR_KERNEL32 dd	rva off_10018E2C ; Import Name Table
		dd 0			; Time stamp
		dd 0			; Forwarder Chain
		dd rva aKernel32_dll	; DLL Name
		dd rva SearchPathW	; Import Address Table
__IMPORT_DESCRIPTOR_VERSION dd rva off_10019034	; Import Name Table
		dd 0			; Time stamp
		dd 0			; Forwarder Chain
		dd rva aVersion_dll	; DLL Name
		dd rva VerQueryValueW	; Import Address Table
__IMPORT_DESCRIPTOR_MSVCR120 dd	rva off_10018F84 ; Import Name Table
		dd 0			; Time stamp
		dd 0			; Forwarder Chain
		dd rva aMsvcr120_dll	; DLL Name
		dd rva __imp__except_handler4_common ; Import Address Table
__IMPORT_DESCRIPTOR_MSVCP120 dd	rva off_10018EE8 ; Import Name Table
		dd 0			; Time stamp
		dd 0			; Forwarder Chain
		dd rva aMsvcp120_dll	; DLL Name
		dd rva ?_Winerror_map@std@@YAPBDH@Z ; Import Address Table
		dd 5 dup(0)
;
; Import names for KERNEL32.dll
;
off_10018E2C	dd rva word_10019044	; DATA XREF: .rdata:__IMPORT_DESCRIPTOR_KERNEL32o
		dd rva word_10019052
		dd rva word_10019062
		dd rva word_10019074
		dd rva word_1001908A
		dd rva word_1001909E
		dd rva word_100190AA
		dd rva word_100190C6
		dd rva word_100190DE
		dd rva word_100190F4
		dd rva word_10019102
		dd rva word_1001911A
		dd rva word_1001912C
		dd rva word_10019144
		dd rva word_10019158
		dd rva word_1001916A
		dd rva word_10019180
		dd rva word_10019190
		dd rva word_100191A4
		dd rva word_100191B6
		dd rva word_100191CA
		dd rva word_100191E0
		dd rva word_100191F6
		dd rva word_10019204
		dd rva word_10019218
		dd rva word_10019226
		dd rva word_10019234
		dd rva word_10019242
		dd rva word_1001926A
		dd rva word_10019284
		dd rva word_10019294
		dd rva word_100192B0
		dd rva word_100192BC
		dd rva word_100192D4
		dd rva word_100192EE
		dd rva word_10019302
		dd rva word_10019312
		dd rva word_10019324
		dd rva word_1001933E
		dd rva word_1001935A
		dd rva word_10019372
		dd rva word_10019EAC
		dd rva word_10019E90
		dd rva word_10019E80
		dd rva word_10019E70
		dd rva word_10019EC2
		dd 0
;
; Import names for MSVCP120.dll
;
off_10018EE8	dd rva word_1001962C	; DATA XREF: .rdata:__IMPORT_DESCRIPTOR_MSVCP120o
		dd rva word_10019E26
		dd rva word_10019DE6
		dd rva word_10019DA4
		dd rva word_10019D60
		dd rva word_10019D20
		dd rva word_10019CDA
		dd rva word_10019C94
		dd rva word_10019C4A
		dd rva word_10019C0C
		dd rva word_10019BC0
		dd rva word_10019B8A
		dd rva word_10019B20
		dd rva word_10019AE6
		dd rva word_10019AA6
		dd rva word_10019A66
		dd rva word_10019A24
		dd rva word_100199E4
		dd rva word_100199A2
		dd rva word_10019962
		dd rva word_10019920
		dd rva word_100198E0
		dd rva word_1001989C
		dd rva word_1001985A
		dd rva word_1001981A
		dd rva word_100197D8
		dd rva word_10019794
		dd rva word_10019752
		dd rva word_1001971C
		dd rva word_100196E0
		dd rva word_100196D8
		dd rva word_100196D0
		dd rva word_100196B0
		dd rva word_10019682
		dd rva word_1001966C
		dd rva word_1001964C
		dd rva word_1001960C
		dd rva word_100195F2
		dd 0
;
; Import names for MSVCR120.dll
;
off_10018F84	dd rva word_100195B4	; DATA XREF: .rdata:__IMPORT_DESCRIPTOR_MSVCR120o
		dd rva word_100193EE
		dd rva word_100195A6
		dd rva word_1001959A
		dd rva word_1001958C
		dd rva word_1001957E
		dd rva word_1001956C
		dd rva word_10019554
		dd rva word_1001953A
		dd rva word_10019524
		dd rva word_1001951A
		dd rva word_1001950C
		dd rva word_100194FE
		dd rva word_100194F4
		dd rva word_100194EC
		dd rva word_100194D2
		dd rva word_100194C8
		dd rva word_100194BE
		dd rva word_100193DE
		dd rva word_100194AA
		dd rva word_100194A0
		dd rva word_10019496
		dd rva word_10019488
		dd rva word_1001947E
		dd rva word_10019474
		dd rva word_1001946A
		dd rva word_10019462
		dd rva word_10019458
		dd rva word_1001944A
		dd rva word_10019440
		dd rva word_10019434
		dd rva word_1001942A
		dd rva word_10019422
		dd rva word_10019416
		dd rva word_10019406
		dd rva word_100193FC
		dd rva word_100195CE
		dd rva word_10019EDC
		dd rva word_10019EE8
		dd rva word_10019EF0
		dd rva word_10019EF8
		dd rva word_100194B6
		dd rva word_10019F02
		dd 0
;
; Import names for VERSION.dll
;
off_10019034	dd rva word_100193A6	; DATA XREF: .rdata:__IMPORT_DESCRIPTOR_VERSIONo
		dd rva word_10019390
		dd rva word_100193B8
		dd 0
word_10019044	dw 4B1h			; DATA XREF: .rdata:off_10018E2Co
		db 'SearchPathW',0
word_10019052	dw 3C0h			; DATA XREF: .rdata:10018E30o
		db 'MapViewOfFile',0
word_10019062	dw 583h			; DATA XREF: .rdata:10018E34o
		db 'UnmapViewOfFile',0
word_10019074	dw 594h			; DATA XREF: .rdata:10018E38o
		db 'VerSetConditionMask',0
word_1001908A	dw 209h			; DATA XREF: .rdata:10018E3Co
		db 'GetCurrentProcess',0
word_1001909E	dw 5DFh			; DATA XREF: .rdata:10018E40o
		db 'WriteFile',0
word_100190AA	dw 347h			; DATA XREF: .rdata:10018E44o
		db 'InitializeCriticalSection',0
word_100190C6	dw 3A2h			; DATA XREF: .rdata:10018E48o
		db 'LeaveCriticalSection',0
		align 2
word_100190DE	dw 597h			; DATA XREF: .rdata:10018E4Co
		db 'VerifyVersionInfoA',0
		align 4
word_100190F4	dw 0C2h			; DATA XREF: .rdata:10018E50o
		db 'CreateFileW',0
word_10019102	dw 193h			; DATA XREF: .rdata:10018E54o
		db 'FlushInstructionCache',0
word_1001911A	dw 29Dh			; DATA XREF: .rdata:10018E58o
		db 'GetProcAddress',0
		align 4
word_1001912C	dw 125h			; DATA XREF: .rdata:10018E5Co
		db 'EnterCriticalSection',0
		align 4
word_10019144	dw 5A0h			; DATA XREF: .rdata:10018E60o
		db 'VirtualProtectEx',0
		align 4
word_10019158	dw 59Ah			; DATA XREF: .rdata:10018E64o
		db 'VirtualAllocEx',0
		align 2
word_1001916A	dw 0BFh			; DATA XREF: .rdata:10018E68o
		db 'CreateFileMappingW',0
		align 10h
word_10019180	dw 2D0h			; DATA XREF: .rdata:10018E6Co
		db 'GetSystemInfo',0
word_10019190	dw 264h			; DATA XREF: .rdata:10018E70o
		db 'GetModuleHandleA',0
		align 4
word_100191A4	dw 3A6h			; DATA XREF: .rdata:10018E74o
		db 'LoadLibraryExA',0
		align 2
word_100191B6	dw 367h			; DATA XREF: .rdata:10018E78o
		db 'IsDebuggerPresent',0
word_100191CA	dw 3F9h			; DATA XREF: .rdata:10018E7Co
		db 'OutputDebugStringA',0
		align 10h
word_100191E0	dw 20Eh			; DATA XREF: .rdata:10018E80o
		db 'GetCurrentThreadId',0
		align 2
word_100191F6	dw 7Fh			; DATA XREF: .rdata:10018E84o
		db 'CloseHandle',0
word_10019204	dw 55Fh			; DATA XREF: .rdata:10018E88o
		db 'TerminateProcess',0
		align 4
word_10019218	dw 573h			; DATA XREF: .rdata:10018E8Co
		db 'TlsGetValue',0
word_10019226	dw 59Ch			; DATA XREF: .rdata:10018E90o
		db 'VirtualFree',0
word_10019234	dw 574h			; DATA XREF: .rdata:10018E94o
		db 'TlsSetValue',0
word_10019242	dw 348h			; DATA XREF: .rdata:10018E98o
		db 'InitializeCriticalSectionAndSpinCount',0
word_1001926A	dw 228h			; DATA XREF: .rdata:10018E9Co
		db 'GetEnvironmentVariableA',0
word_10019284	dw 599h			; DATA XREF: .rdata:10018EA0o
		db 'VirtualAlloc',0
		align 4
word_10019294	dw 113h			; DATA XREF: .rdata:10018EA4o
		db 'DisableThreadLibraryCalls',0
word_100192B0	dw 571h			; DATA XREF: .rdata:10018EA8o
		db 'TlsAlloc',0
		align 4
word_100192BC	dw 55Bh			; DATA XREF: .rdata:10018EACo
		db 'SystemTimeToFileTime',0
		align 4
word_100192D4	dw 42Dh			; DATA XREF: .rdata:10018EB0o
		db 'QueryPerformanceCounter',0
word_100192EE	dw 267h			; DATA XREF: .rdata:10018EB4o
		db 'GetModuleHandleW',0
		align 2
word_10019302	dw 2F2h			; DATA XREF: .rdata:10018EB8o
		db 'GetTickCount',0
		align 2
word_10019312	dw 2ACh			; DATA XREF: .rdata:10018EBCo
		db 'GetProcessTimes',0
word_10019324	dw 2D5h			; DATA XREF: .rdata:10018EC0o
		db 'GetSystemTimeAdjustment',0
word_1001933E	dw 42Eh			; DATA XREF: .rdata:10018EC4o
		db 'QueryPerformanceFrequency',0
word_1001935A	dw 105h			; DATA XREF: .rdata:10018EC8o
		db 'DeleteCriticalSection',0
word_10019372	dw 2D4h			; DATA XREF: .rdata:10018ECCo
		db 'GetSystemTime',0
aKernel32_dll	db 'KERNEL32.dll',0     ; DATA XREF: .rdata:10018DD4o
		align 10h
word_10019390	dw 8			; DATA XREF: .rdata:10019038o
		db 'GetFileVersionInfoW',0
word_100193A6	dw 10h			; DATA XREF: .rdata:off_10019034o
		db 'VerQueryValueW',0
		align 4
word_100193B8	dw 7			; DATA XREF: .rdata:1001903Co
		db 'GetFileVersionInfoSizeW',0
aVersion_dll	db 'VERSION.dll',0      ; DATA XREF: .rdata:10018DE8o
word_100193DE	dw 87h			; DATA XREF: .rdata:10018FCCo
		db '??_U@YAPAXI@Z',0
word_100193EE	dw 4CFh			; DATA XREF: .rdata:10018F88o
		db '_strtoui64',0
		align 4
word_100193FC	dw 72Fh			; DATA XREF: .rdata:10019010o
		db 'strchr',0
		align 2
word_10019406	dw 89h			; DATA XREF: .rdata:1001900Co
		db '??_V@YAXPAX@Z',0
word_10019416	dw 766h			; DATA XREF: .rdata:10019008o
		db 'vfprintf',0
		align 2
word_10019422	dw 26Dh			; DATA XREF: .rdata:10019004o
		db '_dup',0
		align 2
word_1001942A	dw 657h			; DATA XREF: .rdata:10019000o
		db 'fclose',0
		align 4
word_10019434	dw 6B9h			; DATA XREF: .rdata:10018FFCo
		db 'isxdigit',0
		align 10h
word_10019440	dw 28Ah			; DATA XREF: .rdata:10018FF8o
		db '_fdopen',0
word_1001944A	dw 1B8h			; DATA XREF: .rdata:10018FF4o
		db '__iob_func',0
		align 4
word_10019458	dw 67Bh			; DATA XREF: .rdata:10018FF0o
		db 'fprintf',0
word_10019462	dw 67Eh			; DATA XREF: .rdata:10018FECo
		db 'fputs',0
word_1001946A	dw 78Ch			; DATA XREF: .rdata:10018FE8o
		db 'wcsncpy',0
word_10019474	dw 73Ch			; DATA XREF: .rdata:10018FE4o
		db 'strncpy',0
word_1001947E	dw 276h			; DATA XREF: .rdata:10018FE0o
		db '_errno',0
		align 4
word_10019488	dw 529h			; DATA XREF: .rdata:10018FDCo
		db '_vsnprintf',0
		align 2
word_10019496	dw 5ADh			; DATA XREF: .rdata:10018FD8o
		db '_write',0
		align 10h
word_100194A0	dw 693h			; DATA XREF: .rdata:10018FD4o
		db 'getenv',0
		align 2
word_100194AA	dw 4BCh			; DATA XREF: .rdata:10018FD0o
		db '_strnicmp',0
word_100194B6	dw 683h			; DATA XREF: .rdata:10019028o
		db 'free',0
		align 2
word_100194BE	dw 6E8h			; DATA XREF: .rdata:10018FC8o
		db 'memmove',0
word_100194C8	dw 26Ch			; DATA XREF: .rdata:10018FC4o
		db '_dtest',0
		align 2
word_100194D2	dw 449h			; DATA XREF: .rdata:10018FC0o
		db '_purecall',0
aMsvcr120_dll	db 'MSVCR120.dll',0     ; DATA XREF: .rdata:10018DFCo
		align 4
word_100194EC	dw 394h			; DATA XREF: .rdata:10018FBCo
		db '_lock',0
word_100194F4	dw 504h			; DATA XREF: .rdata:10018FB8o
		db '_unlock',0
word_100194FE	dw 22Eh			; DATA XREF: .rdata:10018FB4o
		db '_calloc_crt',0
word_1001950C	dw 1AEh			; DATA XREF: .rdata:10018FB0o
		db '__dllonexit',0
word_1001951A	dw 43Ah			; DATA XREF: .rdata:10018FACo
		db '_onexit',0
word_10019524	dw 250h			; DATA XREF: .rdata:10018FA8o
		db '_crt_debugger_hook',0
		align 2
word_1001953A	dw 1ACh			; DATA XREF: .rdata:10018FA4o
		db '__crtUnhandledException',0
word_10019554	dw 1ABh			; DATA XREF: .rdata:10018FA0o
		db '__crtTerminateProcess',0
word_1001956C	dw 16Fh			; DATA XREF: .rdata:10018F9Co
		db '__CppXcptFilter',0
word_1001957E	dw 217h			; DATA XREF: .rdata:10018F98o
		db '_amsg_exit',0
		align 4
word_1001958C	dw 3A5h			; DATA XREF: .rdata:10018F94o
		db '_malloc_crt',0
word_1001959A	dw 30Ch			; DATA XREF: .rdata:10018F90o
		db '_initterm',0
word_100195A6	dw 30Dh			; DATA XREF: .rdata:10018F8Co
		db '_initterm_e',0
word_100195B4	dw 27Ah			; DATA XREF: .rdata:off_10018F84o
		db '_except_handler4_common',0
word_100195CE	dw 18Ch			; DATA XREF: .rdata:10019014o
		db '__clean_type_info_names_internal',0
		align 2
word_100195F2	dw 2C9h			; DATA XREF: .rdata:10018F7Co
		db '?_Xbad_alloc@std@@YAXXZ',0
word_1001960C	dw 2CCh			; DATA XREF: .rdata:10018F78o
		db '?_Xlength_error@std@@YAXPBD@Z',0
word_1001962C	dw 2C5h			; DATA XREF: .rdata:off_10018EE8o
		db '?_Winerror_map@std@@YAPBDH@Z',0
		align 4
word_1001964C	dw 2B0h			; DATA XREF: .rdata:10018F74o
		db '?_Syserror_map@std@@YAPBDH@Z',0
		align 4
word_1001966C	dw 1A7h			; DATA XREF: .rdata:10018F70o
		db '?_BADOFF@std@@3_JB',0
		align 2
word_10019682	dw 4E5h			; DATA XREF: .rdata:10018F6Co
		db '?setprecision@std@@YA?AU?$_Smanip@_J@1@_J@Z',0
word_100196B0	dw 2CDh			; DATA XREF: .rdata:10018F68o
		db '?_Xout_of_range@std@@YAXPBD@Z',0
word_100196D0	dw 5DDh			; DATA XREF: .rdata:10018F64o
		db '_Nan',0
		align 4
word_100196D8	dw 5ADh			; DATA XREF: .rdata:10018F60o
		db '_Inf',0
		align 10h
word_100196E0	dw 2Ah			; DATA XREF: .rdata:10018F5Co
		db '??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ',0
		align 4
word_1001971C	dw 7			; DATA XREF: .rdata:10018F58o
		db '??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ',0
		align 2
word_10019752	dw 27Ch			; DATA XREF: .rdata:10018F54o
		db '?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ',0
word_10019794	dw 4DFh			; DATA XREF: .rdata:10018F50o
		db '?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z',0
		align 4
word_100197D8	dw 4E0h			; DATA XREF: .rdata:10018F4Co
		db '?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z',0
word_1001981A	dw 462h			; DATA XREF: .rdata:10018F48o
		db '?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z',0
word_1001985A	dw 37Fh			; DATA XREF: .rdata:10018F44o
		db '?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ',0
		align 4
word_1001989C	dw 4DBh			; DATA XREF: .rdata:10018F40o
		db '?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z',0
		align 10h
word_100198E0	dw 391h			; DATA XREF: .rdata:10018F3Co
		db '?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z',0
word_10019920	dw 378h			; DATA XREF: .rdata:10018F38o
		db '?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ',0
		align 2
word_10019962	dw 468h			; DATA XREF: .rdata:10018F34o
		db '?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ',0
word_100199A2	dw 45Fh			; DATA XREF: .rdata:10018F30o
		db '?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ',0
		align 4
word_100199E4	dw 3ECh			; DATA XREF: .rdata:10018F2Co
		db '?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ',0
word_10019A24	dw 375h			; DATA XREF: .rdata:10018F28o
		db '?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ',0
		align 2
word_10019A66	dw 10Bh			; DATA XREF: .rdata:10018F24o
		db '??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z',0
word_10019AA6	dw 10Ah			; DATA XREF: .rdata:10018F20o
		db '??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z',0
word_10019AE6	dw 84h			; DATA XREF: .rdata:10018F1Co
		db '??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ',0
		align 10h
word_10019B20	dw 20h			; DATA XREF: .rdata:10018F18o
		db '??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_st'
		db 'reambuf@DU?$char_traits@D@std@@@1@_N@Z',0
word_10019B8A	dw 7Bh			; DATA XREF: .rdata:10018F14o
		db '??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ',0
		align 10h
word_10019BC0	dw 41Ch			; DATA XREF: .rdata:10018F10o
		db '?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVloca'
		db 'le@2@@Z',0
		align 4
word_10019C0C	dw 521h			; DATA XREF: .rdata:10018F0Co
		db '?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ',0
word_10019C4A	dw 4D6h			; DATA XREF: .rdata:10018F08o
		db '?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@P'
		db 'AD_J@Z',0
word_10019C94	dw 56Eh			; DATA XREF: .rdata:10018F04o
		db '?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J'
		db '@Z',0
word_10019CDA	dw 56Bh			; DATA XREF: .rdata:10018F00o
		db '?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J'
		db '@Z',0
word_10019D20	dw 540h			; DATA XREF: .rdata:10018EFCo
		db '?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ',0
		align 10h
word_10019D60	dw 4F6h			; DATA XREF: .rdata:10018EF8o
		db '?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ'
		db 0
word_10019DA4	dw 2BFh			; DATA XREF: .rdata:10018EF4o
		db '?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ',0
		align 2
word_10019DE6	dw 258h			; DATA XREF: .rdata:10018EF0o
		db '?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ',0
		align 2
word_10019E26	dw 87h			; DATA XREF: .rdata:10018EECo
		db '??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ',0
		align 2
aMsvcp120_dll	db 'MSVCP120.dll',0     ; DATA XREF: .rdata:10018E10o
		align 10h
word_10019E70	dw 121h			; DATA XREF: .rdata:10018EDCo
		db 'EncodePointer',0
word_10019E80	dw 0FEh			; DATA XREF: .rdata:10018ED8o
		db 'DecodePointer',0
word_10019E90	dw 36Dh			; DATA XREF: .rdata:10018ED4o
		db 'IsProcessorFeaturePresent',0
word_10019EAC	dw 20Ah			; DATA XREF: .rdata:10018ED0o
		db 'GetCurrentProcessId',0
word_10019EC2	dw 2D6h			; DATA XREF: .rdata:10018EE0o
		db 'GetSystemTimeAsFileTime',0
word_10019EDC	dw 4B2h			; DATA XREF: .rdata:10019018o
		db '_stricmp',0
		align 4
word_10019EE8	dw 39Fh			; DATA XREF: .rdata:1001901Co
		db '_ltoa',0
word_10019EF0	dw 617h			; DATA XREF: .rdata:10019020o
		db 'ceil',0
		align 4
word_10019EF8	dw 6E6h			; DATA XREF: .rdata:10019024o
		db 'memcpy',0
		align 2
word_10019F02	dw 6EAh			; DATA XREF: .rdata:1001902Co
		db 'memset',0
		align 100h
_rdata		ends

; Section 3. (virtual address 0001A000)
; Virtual size			: 00000CBB (   3259.)
; Section size in file		: 00000600 (   1536.)
; Offset to raw	data for section: 00018600
; Flags	C0000040: Data Readable	Writable
; Alignment	: default
; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 1001A000h
___security_cookie dd 0BB40E64Eh	; DATA XREF: sub_10001000+6r
					; sub_10001061+6r ...
dword_1001A004	dd 44BF19B1h		; DATA XREF: ___report_gsfailure+E3r
					; sub_1000B871+29w ...
		align 10h
dword_1001A010	dd 0FFFFFFFFh		; DATA XREF: ___DllMainCRTStartup+1Cw
					; ___DllMainCRTStartup:$LN20w
		align 10h
dword_1001A020	dd 1			; DATA XREF: sub_1000BDF0+11w
					; sub_1000BDF0+33r ...
; DWORD	dwTlsIndex
dwTlsIndex	dd 0FFFFFFFFh		; DATA XREF: sub_100016CF+16r
					; sub_1000172B:loc_1000175Fr ...
byte_1001A028	db 1			; DATA XREF: mozilla::TimeStamp::Now(bool)+Er
					; mozilla::TimeStamp::Startup(void)+4Bw ...
		align 4
off_1001A02C	dd offset off_1001637C	; DATA XREF: sub_1000BF9Dw
					; sub_10010C1C+17o
off_1001A030	dd offset aNpffaddon_dll ; DATA	XREF: sub_1000A8A8:loc_1000A9AEr
					; sub_1000A8A8+10Bo
					; "npffaddon.dll"
		align 8
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aAvgrsstx_dll	; "avgrsstx.dll"
		align 10h
		dd 191h, 80005h, 2 dup(0)
		dd offset aCalc_dll	; "calc.dll"
		align 8
		dd 1, 10000h, 2	dup(0)
		dd offset aHook_dll	; "hook.dll"
		align 10h
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aGoogledesktopn ; "googledesktopnetwork3.dll"
		dd 5 dup(0)
		dd offset aRdolib_dll	; "rdolib.dll"
		align 10h
		dd 580004h, 60000h, 2 dup(0)
		dd offset aFgjk4wvb_dll	; "fgjk4wvb.dll"
		align 8
		dw 4 dup(8), 0
		align 8
		dd offset aRadhslib_dll	; "radhslib.dll"
		dd 5 dup(0)
		dd offset aVksaver_dll	; "vksaver.dll"
		dd 0
		dd 20000h, 20002h, 2 dup(0)
		dd offset aRlxf_dll	; "rlxf.dll"
		align 10h
		dd 1430001h, 10002h, 2 dup(0)
		dd offset aPsicon_dll	; "psicon.dll"
		align 8
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aAccelerator_dl ; "accelerator.dll"
		align 10h
		dd 10006h, 30002h, 2 dup(0)
		dd offset aRfFirefox_dll ; "rf-firefox.dll"
		dd 0
		dd 10000h, 70006h, 2 dup(0)
		dd offset aRoboform_dll	; "roboform.dll"
		dd 0
		dd 10000h, 70006h, 2 dup(0)
		dd offset aBabyfox_dll	; "babyfox.dll"
		align 8
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aSprotector_dll ; "sprotector.dll"
		align 10h
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aQipcap_dll	; "qipcap.dll"
		align 8
		dd 32F0001h, 70006h, 2 dup(0)
		dd offset aMozdllblocking ; "mozdllblockingtest.dll"
		align 10h
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aMozdllblocki_0 ; "mozdllblockingtest_versioned.dll"
		dd 2 dup(0)
		dd 4, 2	dup(0)
		dd offset aMfflac_dll	; "mfflac.dll"
		align 10h
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aRlnx_dll	; "rlnx.dll"
		align 8
		dd 14E0009h, 10003h, 2 dup(0)
		dd offset aPmnx_dll	; "pmnx.dll"
		align 10h
		dd 14E0009h, 10003h, 2 dup(0)
		dd offset aOpnx_dll	; "opnx.dll"
		align 8
		dd 14E0009h, 10003h, 2 dup(0)
		dd offset aPrnx_dll	; "prnx.dll"
		align 10h
		dd 14E0009h, 10003h, 2 dup(0)
		dd offset aBeid35cardlaye ; "beid35cardlayer.dll"
		align 8
		dd 61B38h, 30005h, 2 dup(0)
		dd offset aBitguard_dll	; "bitguard.dll"
		align 10h
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aAtkdx11disp_dl ; "atkdx11disp.dll"
		align 8
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aSpvc32_dll	; "spvc32.dll"
		align 10h
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aFs_ccf_ni_umh3 ; "fs_ccf_ni_umh32.dll"
		dd 0
		dd 650000h, 1002Ah, 2, 0
		dd offset aLibinject_dll ; "libinject.dll"
		align 20h
		dd offset aLibinject2_dll ; "libinject2.dll"
		align 8
aUS		db '}S',0
		align 10h
		dd 4, 0
		dd offset aLibredir2_dll ; "libredir2.dll"
		align 10h
aAEs		db 'S',0
		align 4
		dd 4, 0
		dd offset aRfFirefox22_dl ; "rf-firefox-22.dll"
		align 8
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aRfFirefox40_dl ; "rf-firefox-40.dll"
		align 10h
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aDtwxsvc_dll	; "dtwxsvc.dll"
		align 8
		dd 53153234h, 0
		dd 4, 0
		dd offset aActivedetect32 ; "activedetect32.dll"
		dd 5 dup(0)
		dd offset aActivedetect64 ; "activedetect64.dll"
		dd 5 dup(0)
		dd offset aWindowsapihook ; "windowsapihookdll32.dll"
		align 20h
		dd offset aWindowsapiho_0 ; "windowsapihookdll64.dll"
		dd 5 dup(0)
		dd offset aRndlnpshimswf_ ; "rndlnpshimswf.dll"
		align 10h
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aRndlmainbrowse ; "rndlmainbrowserrecordplugin.dll"
		align 8
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aNprpffbrowserr ; "nprpffbrowserrecordext.dll"
		align 10h
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aNprndlffbrowse ; "nprndlffbrowserrecordext.dll"
		align 8
		dd 2 dup(0FFFFFFFFh), 2	dup(0)
		dd offset aYcwebcamerasou ; "ycwebcamerasource.ax"
		align 10h
		dd 64Bh, 20000h, 2 dup(0)
		dd offset aVwcsource_ax	; "vwcsource.ax"
		dd 2 dup(0)
		dd 10005h, 2 dup(0)
		dd offset aNlsp_dll	; "nlsp.dll"
		align 10h
		dd 7DC0013h, 60017h, 8 dup(0)
dword_1001A498	dd 0FFFFFFFFh		; DATA XREF: sub_1000AAFC+24r
					; sub_1000AAFC:loc_1000ABBEw
dword_1001A49C	dd 400h			; DATA XREF: sub_10004A40+F1r
					; sub_10005710+Cr ...
; Exported entry  99. _malloc_options
		public _malloc_options
_malloc_options	dd offset byte_1001680D	; DATA XREF: sub_100066AB+1D4r
					; .rdata:off_100175A8o
; Exported entry  98. _malloc_message
		public _malloc_message
_malloc_message	dd offset sub_1000F2B1	; DATA XREF: sub_10005C56+6AB3r
					; sub_100066AB+6BD5r ...
dword_1001A4A8	dd 0			; DATA XREF: ___report_gsfailure+9Fw
					; ___report_securityfailure+95w ...
dword_1001A4AC	dd 0			; DATA XREF: ___report_gsfailure+A9w
					; ___report_securityfailure+9Fw
		dd 0
dword_1001A4B4	dd 0			; DATA XREF: ___report_gsfailure+9Aw
					; ___report_securityfailure+90w
dword_1001A4B8	dd 0			; DATA XREF: ___report_gsfailure+B3w
					; ___report_securityfailure+A9w
dword_1001A4BC	dd 0			; DATA XREF: ___report_gsfailure+C3w
					; ___report_securityfailure+BCw
		dd 0Eh dup(0)
dword_1001A4F8	dd 0			; DATA XREF: ___report_gsfailure+8Bw
					; .rdata:10016408o
		dd 22h dup(0)
word_1001A584	dw 0			; DATA XREF: ___report_gsfailure+5Fw
					; ___report_securityfailure+5Fw
		align 4
word_1001A588	dw 0			; DATA XREF: ___report_gsfailure+58w
					; ___report_securityfailure+58w
		align 4
word_1001A58C	dw 0			; DATA XREF: ___report_gsfailure+51w
					; ___report_securityfailure+51w
		align 10h
word_1001A590	dw 0			; DATA XREF: ___report_gsfailure+4Aw
					; ___report_securityfailure+4Aw
		align 4
dword_1001A594	dd 0			; DATA XREF: ___report_gsfailure+36w
					; ___report_securityfailure+36w
dword_1001A598	dd 0			; DATA XREF: ___report_gsfailure+30w
					; ___report_securityfailure+30w
dword_1001A59C	dd 0			; DATA XREF: ___report_gsfailure+2Aw
					; ___report_securityfailure+2Aw
dword_1001A5A0	dd 0			; DATA XREF: ___report_gsfailure+24w
					; ___report_securityfailure+24w
dword_1001A5A4	dd 0			; DATA XREF: ___report_gsfailure+1Ew
					; ___report_securityfailure+1Ew
dword_1001A5A8	dd 0			; DATA XREF: ___report_gsfailure:loc_1000B11Fw
					; ___report_securityfailure:loc_1000B226w
dword_1001A5AC	dd 0			; DATA XREF: ___report_gsfailure+70w
					; ___report_securityfailure+70w
dword_1001A5B0	dd 0			; DATA XREF: ___report_gsfailure+78w
					; ___report_gsfailure+95r ...
word_1001A5B4	dw 0			; DATA XREF: ___report_gsfailure+43w
					; ___report_securityfailure+43w
		align 4
dword_1001A5B8	dd 0			; DATA XREF: ___report_gsfailure+67w
					; ___report_securityfailure+67w
dword_1001A5BC	dd 0			; DATA XREF: ___report_gsfailure+80w
					; ___report_securityfailure+80w
word_1001A5C0	dw 0			; DATA XREF: ___report_gsfailure+3Cw
					; ___report_securityfailure+3Cw
		align 4
		dd 0Fh dup(0)
		dd 71h dup(?)
dword_1001A7C4	dd ?			; DATA XREF: ___raise_securityfailure+Bw
					; ___raise_securityfailure+1Dr
dword_1001A7C8	dd ?			; DATA XREF: sub_1000B330+12r
					; sub_1000B330+25w ...
dword_1001A7CC	dd 2 dup(?)		; DATA XREF: sub_1000B95Ao
dword_1001A7D4	dd ?			; DATA XREF: __ftol2_sser
					; .text:__ftol2_sse_excptr ...
dword_1001A7D8	dd ?			; DATA XREF: sub_1000BDF0:loc_1000BEB7r
					; sub_1000BDF0+D0w ...
dword_1001A7DC	dd ?			; DATA XREF: sub_1000B330+20o
					; sub_1000B330+112o ...
dword_1001A7E0	dd ?			; DATA XREF: sub_1000B330:loc_1000B383r
					; sub_1000B330:loc_1000B44Cw ...
dword_1001A7E4	dd ?			; DATA XREF: sub_1000B330:loc_1000B4F0r
					; sub_1000B330+1C9o ...
; PVOID	dword_1001A7E8
dword_1001A7E8	dd ?			; DATA XREF: ___atonexitinit+27w
					; sub_1000B00B+49r ...
; PVOID	Ptr
Ptr		dd ?			; DATA XREF: ___atonexitinitr
					; ___atonexitinit+22w ...
dword_1001A7F0	dd ?			; DATA XREF: sub_1000AAFC+18r
					; sub_1000AAFC+AAw
		align 10h
dword_1001A800	dd ?			; DATA XREF: sub_10001482+3w
					; sub_10001482+90w ...
; int dword_1001A804
dword_1001A804	dd ?			; DATA XREF: DllBlocklist_Initialize(void)+5Dw
					; DllBlocklist_Initialize(void)+6Fw ...
dword_1001A808	dd ?			; DATA XREF: sub_100066AB+14r
					; sub_100066AB+1AEw
byte_1001A80C	db ?			; DATA XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+2Ar
					; mozilla::TimeStamp::Startup(void)+3Aw
		align 10h
qword_1001A810	dq ?			; DATA XREF: mozilla::BaseTimeDurationPlatformUtils::ToSeconds(__int64)+Cr
					; mozilla::BaseTimeDurationPlatformUtils::TicksFromMilliseconds(double)+5r ...
dword_1001A818	dd ?			; DATA XREF: mozilla::TimeStamp::Now(bool):loc_10006E8Cr
					; mozilla::TimeStamp::Startup(void)+1Cw ...
; Exported entry 108. gMozillaPoisonSize
		public gMozillaPoisonSize
gMozillaPoisonSize dd ?			; DATA XREF: mozPoisonValueInit+21w
					; mozPoisonValueInit:loc_1000AF56r ...
; Exported entry 109. gMozillaPoisonValue
		public gMozillaPoisonValue
gMozillaPoisonValue dd ?		; DATA XREF: mozPoisonValueInit+54w
					; .rdata:off_100175A8o
; Exported entry 107. gMozillaPoisonBase
		public gMozillaPoisonBase
gMozillaPoisonBase dd ?			; DATA XREF: mozPoisonValueInit+45w
					; .rdata:off_100175A8o
; Exported entry  87. ?sse_enabled@sse_private@mozilla@@3_NA
		public ?sse_enabled@sse_private@mozilla@@3_NA
; bool mozilla::sse_private::sse_enabled
?sse_enabled@sse_private@mozilla@@3_NA db ? ; DATA XREF: sub_10001248+52w
					; .rdata:off_100175A8o
; Exported entry  69. ?mmx_enabled@sse_private@mozilla@@3_NA
		public ?mmx_enabled@sse_private@mozilla@@3_NA
; bool mozilla::sse_private::mmx_enabled
?mmx_enabled@sse_private@mozilla@@3_NA db ? ; DATA XREF: sub_10001000+52w
					; .rdata:off_100175A8o
; Exported entry  88. ?ssse3_enabled@sse_private@mozilla@@3_NA
		public ?ssse3_enabled@sse_private@mozilla@@3_NA
; bool mozilla::sse_private::ssse3_enabled
?ssse3_enabled@sse_private@mozilla@@3_NA db ? ;	DATA XREF: sub_100012A9+52w
					; .rdata:off_100175A8o
; Exported entry  86. ?sse4a_enabled@sse_private@mozilla@@3_NA
		public ?sse4a_enabled@sse_private@mozilla@@3_NA
; bool mozilla::sse_private::sse4a_enabled
?sse4a_enabled@sse_private@mozilla@@3_NA db ? ;	DATA XREF: sub_100011E2+57w
					; .rdata:off_100175A8o
; Exported entry  85. ?sse4_2_enabled@sse_private@mozilla@@3_NA
		public ?sse4_2_enabled@sse_private@mozilla@@3_NA
; bool mozilla::sse_private::sse4_2_enabled
?sse4_2_enabled@sse_private@mozilla@@3_NA db ? ; DATA XREF: sub_10001181+52w
					; .rdata:off_100175A8o
; Exported entry  82. ?sse2_enabled@sse_private@mozilla@@3_NA
		public ?sse2_enabled@sse_private@mozilla@@3_NA
; bool mozilla::sse_private::sse2_enabled
?sse2_enabled@sse_private@mozilla@@3_NA	db ? ; DATA XREF: sub_10001061+52w
					; .rdata:off_100175A8o
; Exported entry  84. ?sse4_1_enabled@sse_private@mozilla@@3_NA
		public ?sse4_1_enabled@sse_private@mozilla@@3_NA
; bool mozilla::sse_private::sse4_1_enabled
?sse4_1_enabled@sse_private@mozilla@@3_NA db ? ; DATA XREF: sub_10001120+52w
					; .rdata:off_100175A8o
; Exported entry  83. ?sse3_enabled@sse_private@mozilla@@3_NA
		public ?sse3_enabled@sse_private@mozilla@@3_NA
; bool mozilla::sse_private::sse3_enabled
?sse3_enabled@sse_private@mozilla@@3_NA	db ? ; DATA XREF: sub_100010C2+4Fw
					; .rdata:off_100175A8o
dword_1001A830	dd ?			; DATA XREF: DllBlocklist_Initialize(void)+3Bw
					; sub_10001452+2w ...
dword_1001A834	dd 80h dup(?)		; DATA XREF: sub_100013FD+ABFCo
dword_1001AA34	dd ?			; DATA XREF: sub_100013FD+Er
					; sub_10001452+7w ...
dword_1001AA38	dd ?			; DATA XREF: sub_100013FD+2o
					; sub_1000141A+9r ...
dword_1001AA3C	dd ?			; DATA XREF: sub_10001452+11w
dword_1001AA40	dd ?			; DATA XREF: sub_10001452+16w
dword_1001AA44	dd ?			; DATA XREF: sub_10001452+1Bw
; LPCSTR lpLibFileName
lpLibFileName	dd ?			; DATA XREF: DllBlocklist_Initialize(void)+1Ar
					; DllBlocklist_Initialize(void)+30w ...
; int dword_1001AA4C
dword_1001AA4C	dd ?			; DATA XREF: DllBlocklist_Initialize(void)+28w
					; sub_1000141A+18r ...
dword_1001AA50	dd ?			; DATA XREF: mozilla::TimeStamp::ProcessCreation(bool &)+C9o
					; sub_10006DC5+11w ...
dword_1001AA54	dd ?			; DATA XREF: sub_10006DC5+16w
dword_1001AA58	dd ?			; DATA XREF: sub_10006DC5+1Bw
dword_1001AA5C	dd ?			; DATA XREF: sub_10006DC5+20w
word_1001AA60	dw ?			; DATA XREF: sub_10006DC5+5w
		align 8
dword_1001AA68	dd ?			; DATA XREF: mozilla::TimeStamp::ProcessCreation(bool &)+Co
					; mozilla::TimeStamp::ProcessCreation(bool &)+23o ...
dword_1001AA6C	dd ?			; DATA XREF: sub_10006DC5+2Cw
dword_1001AA70	dd ?			; DATA XREF: sub_10006DC5+31w
dword_1001AA74	dd ?			; DATA XREF: sub_10006DC5+36w
word_1001AA78	dw ?			; DATA XREF: sub_10006DC5+3Bw
		align 4
		dd 2 dup(?)
; Exported entry  65. ?gChaosModeCounter@detail@mozilla@@3V?$Atomic@I$01X@2@A
		public ?gChaosModeCounter@detail@mozilla@@3V?$Atomic@I$01X@2@A
; class	mozilla::Atomic<unsigned int, 2, void> mozilla::detail::gChaosModeCounter
?gChaosModeCounter@detail@mozilla@@3V?$Atomic@I$01X@2@A	dd ? ; DATA XREF: sub_1000135A+2o
					; .rdata:off_100175A8o
; struct _RTL_CRITICAL_SECTION CriticalSection
CriticalSection	_RTL_CRITICAL_SECTION <?>
					; DATA XREF: DllBlocklist_Initialize(void):loc_100013B0o
					; sub_1000E70F+Fo ...
byte_1001AAA0	db ?			; DATA XREF: DllBlocklist_Initialize(void)+Fw
					; DllBlocklist_WriteNotes(void *):loc_1000E96Dr
byte_1001AAA1	db ?			; DATA XREF: DllBlocklist_Initialize(void):loc_100013F4w
					; DllBlocklist_WriteNotes(void *)+37r
		align 4
dword_1001AAA4	dd ?			; DATA XREF: sub_1000A8A8+159r
					; DllBlocklist_SetInXPCOMLoadOnMainThread(bool)+Dw ...
dword_1001AAA8	dd ?			; DATA XREF: mozalloc_set_oom_abort_handler(void (*)(uint))+4w
					; mozalloc_handle_oom(uint)+13r
dword_1001AAAC	dd ?			; DATA XREF: sub_10005C6D+7Cw
					; sub_10006073+46w ...
; struct _RTL_CRITICAL_SECTION stru_1001AAB0
stru_1001AAB0	_RTL_CRITICAL_SECTION <?> ; DATA XREF: sub_10005C6D+4Fo
					; sub_10005C6D+70o ...
; LPCRITICAL_SECTION lpCriticalSection
lpCriticalSection dd ?			; DATA XREF: sub_10005A0F+6r
					; sub_100066AB+1A5w ...
dword_1001AACC	dd ?			; DATA XREF: sub_10005C6D+5Fo
					; sub_10005E22+2r ...
dword_1001AAD0	dd 2 dup(?)		; DATA XREF: sub_10005E22+8o
					; sub_100066AB+CCo
dword_1001AAD8	dd ?			; DATA XREF: sub_100066AB+E1w
dword_1001AADC	dd ?			; DATA XREF: sub_100066AB+E9w
		dd 3 dup(?)
dword_1001AAEC	dd ?			; DATA XREF: sub_10005F8F+16r
					; sub_10005F8F+31w ...
dword_1001AAF0	dd ?			; DATA XREF: sub_100063E5+63w
					; sub_100066AB+112w ...
		align 8
dword_1001AAF8	dd ?			; DATA XREF: sub_10006073+30w
					; sub_100066AB+F4w
dword_1001AAFC	dd ?			; DATA XREF: sub_10006073+3Fw
					; sub_100066AB+FAw
dword_1001AB00	dd ?			; DATA XREF: sub_100016CF+Er
					; sub_100066AB+156w ...
dword_1001AB04	dd ?			; DATA XREF: sub_10005AAE+43o
					; sub_10005AAE+97o ...
dword_1001AB08	dd ?			; DATA XREF: sub_100066AB+94o
					; sub_100066AB+A3w
dword_1001AB0C	dd ?			; DATA XREF: sub_100066AB+ABw
		dd 5 dup(?)
dword_1001AB24	dd ?			; DATA XREF: sub_100066AB+146w
					; sub_100016CF+AA0Ar ...
dword_1001AB28	dd ?			; DATA XREF: sub_10005F8F+1Fr
					; sub_100063E5+45w
dword_1001AB2C	dd ?			; DATA XREF: sub_100016CFr
					; sub_100066AB+12Ew ...
; struct _RTL_CRITICAL_SECTION stru_1001AB30
stru_1001AB30	_RTL_CRITICAL_SECTION <?> ; DATA XREF: sub_100066AB+196o
					; sub_100016CF+A9FEo
dword_1001AB48	dd ?			; DATA XREF: sub_10005C6D+82w
					; sub_10006073+54w ...
		align 10h
dword_1001AB50	dd ?			; DATA XREF: sub_10005C6D+69w
					; sub_100066AB+D1w
dword_1001AB54	dd ?			; DATA XREF: sub_10005C6D+75w
					; sub_100066AB+EEw
dword_1001AB58	dd ?			; DATA XREF: sub_10005AAE+A3o
					; sub_100062B7+32r ...
dword_1001AB5C	dd 2 dup(?)		; DATA XREF: sub_100062B7+3Fo
					; sub_100066AB+B0o ...
dword_1001AB64	dd ?			; DATA XREF: sub_100066AB+BAw
dword_1001AB68	dd ?			; DATA XREF: sub_100066AB+C2w
		dd 3 dup(?)
; struct _RTL_CRITICAL_SECTION stru_1001AB78
stru_1001AB78	_RTL_CRITICAL_SECTION <?> ; DATA XREF: sub_10005AAE+2Fo
					; sub_10005AAE+CCo ...
dword_1001AB90	dd ?			; DATA XREF: sub_100063E5+24w
dword_1001AB94	dd ?			; DATA XREF: sub_10005AAE:loc_10005B74w
					; sub_10006035+Dr ...
; struct _RTL_CRITICAL_SECTION stru_1001AB98
stru_1001AB98	_RTL_CRITICAL_SECTION <?> ; DATA XREF: sub_10005DE5+2o
					; sub_10005F8F+7o ...
dword_1001ABB0	dd ?			; DATA XREF: sub_100063E5:loc_10006442w
					; sub_100066AB+10Cw ...
; LPVOID lpAddress
lpAddress	dd ?			; DATA XREF: sub_10005F8F:loc_10005FB6r
					; sub_10005F8F+71w ...
dword_1001ABB8	dd ?			; DATA XREF: sub_10005DE5+Er
					; sub_10005DE5+1Bw ...
		align 10h
dword_1001ABC0	dd ?			; DATA XREF: sub_10006F65+99w
					; mozilla::BaseTimeDurationPlatformUtils::ToSecondsSigDigits(__int64)+10r
dword_1001ABC4	dd ?			; DATA XREF: sub_10006F65+A1w
					; mozilla::BaseTimeDurationPlatformUtils::ToSecondsSigDigits(__int64)+16r
dword_1001ABC8	dd ?			; DATA XREF: sub_10006F65:loc_10006FDFw
					; mozilla::BaseTimeDurationPlatformUtils::ResolutionInTicks(void)r ...
dword_1001ABCC	dd ?			; DATA XREF: sub_10006F65+82w
					; mozilla::BaseTimeDurationPlatformUtils::ResolutionInTicks(void)+5r ...
dword_1001ABD0	dd ?			; DATA XREF: sub_10007034+70w
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+69B9r
dword_1001ABD4	dd ?			; DATA XREF: sub_10007034+75w
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+69B3r ...
dword_1001ABD8	dd ?			; DATA XREF: sub_10007034+B0w
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+69E5r
dword_1001ABDC	dd ?			; DATA XREF: sub_10007034+B5w
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+69D7r
dword_1001ABE0	dd ?			; DATA XREF: sub_10007034+9Dw
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &):loc_1000D5F5r ...
dword_1001ABE4	dd ?			; DATA XREF: sub_10007034+A2w
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A6Br ...
dword_1001ABE8	dd ?			; DATA XREF: sub_10007034+88w
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A16r
dword_1001ABEC	dd ?			; DATA XREF: sub_10007034+8Dw
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A08r
dword_1001ABF0	dd ?			; DATA XREF: sub_1000AF86w
					; sub_1000AF86+Ao ...
dword_1001ABF4	dd ?			; DATA XREF: sub_1000AF76w
					; sub_1000AF76+Ao ...
dword_1001ABF8	dd ?			; DATA XREF: double_conversion::DoubleToStringConverter::EcmaScriptConverter(void):loc_1000883Bo
					; sub_100094D9+7o ...
dword_1001ABFC	dd ?			; DATA XREF: sub_100094D9+16w
dword_1001AC00	dd ?			; DATA XREF: sub_100094D9+20w
byte_1001AC04	db ?			; DATA XREF: sub_100094D9+2Aw
		align 4
dword_1001AC08	dd ?			; DATA XREF: sub_100094D9+31w
dword_1001AC0C	dd ?			; DATA XREF: sub_100094D9+3Bw
dword_1001AC10	dd ?			; DATA XREF: sub_100094D9+45w
dword_1001AC14	dd ?			; DATA XREF: sub_100094D9w
dword_1001AC18	dd ?			; DATA XREF: double_conversion::DoubleToStringConverter::EcmaScriptConverter(void)r
					; double_conversion::DoubleToStringConverter::EcmaScriptConverter(void)+15w
		dd 3 dup(?)
; CHAR Buffer[64]
Buffer		db 40h dup(?)		; DATA XREF: sub_100068E8+3o
; struct _RTL_CRITICAL_SECTION stru_1001AC68
stru_1001AC68	_RTL_CRITICAL_SECTION <?> ; DATA XREF: mozilla::TimeStamp::Shutdown(void)o
					; mozilla::TimeStamp::Startup(void)+2Ao ...
		dd 2 dup(?)
dword_1001AC88	dd ?			; DATA XREF: sub_100066AB+123r
					; sub_100066AB:loc_1000D2ECw ...
		align 10h
dword_1001AC90	dd ?			; DATA XREF: sub_1000E885+11r
					; sub_1000E885:loc_1000E901r ...
dword_1001AC94	dd ?			; DATA XREF: sub_100066AB+6C36w
					; sub_100066AB+6C91w
dword_1001AC98	dd ?			; DATA XREF: sub_10005C56+6ABCr
					; sub_100066AB:loc_1000D318w ...
dword_1001AC9C	dd ?			; DATA XREF: sub_1000F36F+2Cr
					; sub_1000F36F+33w ...
dword_1001ACA0	dd ?			; DATA XREF: sub_1000F36F+18r
					; sub_1000F36F+43w
		align 8
dword_1001ACA8	dd ?			; DATA XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A4Ar
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6AB8w ...
dword_1001ACAC	dd ?			; DATA XREF: mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A52r
					; mozilla::TimeStampValue::CheckQPC(mozilla::TimeStampValue const &)+6A82r ...
; Exported entry  64. ?gChaosFeatures@detail@mozilla@@3W4ChaosFeature@2@A
		public ?gChaosFeatures@detail@mozilla@@3W4ChaosFeature@2@A
; enum	mozilla::ChaosFeature mozilla::detail::gChaosFeatures
?gChaosFeatures@detail@mozilla@@3W4ChaosFeature@2@A dd 2 dup(?)
					; DATA XREF: .rdata:off_100175A8o
		db ?
; Exported entry  92. ?unused@mozilla@@3Uunused_t@1@B
		public ?unused@mozilla@@3Uunused_t@1@B
; struct mozilla::unused_t const mozilla::unused
?unused@mozilla@@3Uunused_t@1@B	db 3 dup(?) ; DATA XREF: .rdata:off_100175A8o
		align 400h
_data		ends


		end DllEntryPoint
