;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	A30C89C206F417C27490982C63DF9C05
; Input	CRC32 :	DF727ABA

; File Name   :	D:\compspace\objfiles\firefox\genbrk\genbrk.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		public ??_C@_05PMBAOCDH@quiet?$AA@
; `string'
??_C@_05PMBAOCDH@quiet?$AA@ db 'quiet',0 ; DATA XREF: .data:000001DCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ??_C@_09JHBDCMB@copyright?$AA@
; `string'
??_C@_09JHBDCMB@copyright?$AA@ db 'copyright',0 ; DATA XREF: .data:000001C8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ??_C@_07HIFNFPHK@destdir?$AA@
; `string'
??_C@_07HIFNFPHK@destdir?$AA@ db 'destdir',0 ; DATA XREF: .data:000001B4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ??_C@_0L@JMMPKMPC@icudatadir?$AA@
; `string'
??_C@_0L@JMMPKMPC@icudatadir?$AA@ db 'icudatadir',0 ; DATA XREF: .data:000001A0o
					; .rdata:int const std::_Locbase<int>::messageso ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ??_C@_03KEJHNBPP@out?$AA@
; `string'
??_C@_03KEJHNBPP@out?$AA@ dd 74756Fh	; DATA XREF: .data:0000018Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ??_C@_05CBLPGGM@rules?$AA@
; `string'
??_C@_05CBLPGGM@rules?$AA@ db 'rules',0 ; DATA XREF: .data:00000178o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ??_C@_07KBAMPNJK@verbose?$AA@
; `string'
??_C@_07KBAMPNJK@verbose?$AA@ db 'verbose',0 ; DATA XREF: .data:00000164o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ??_C@_04PCJFHION@help?$AA@
; `string'
??_C@_04PCJFHION@help?$AA@ db 'help',0  ; DATA XREF: .data:_optionso
					; .data:00000150o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5 ; DATA XREF: .data:00000174o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ??_C@_0L@JMMPKMPC@icudatadir?$AA@+4 ;	"atadir"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ??_C@_04PCJFHION@help?$AA@+3 ; "p"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_0L@JMMPKMPC@icudatadir?$AA@+4	; "atadir"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_04PCJFHION@help?$AA@+4 ;	""
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB ; int const std::_Arithmetic_traits<float>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B ; std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	off_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	??_C@_0BPK@HAPFEGHF@?7Read?5in?5break?5iteration?5rules?5t@+178h ; "ta files,\n\t		     follow"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset ??_C@_0EF@FGLKDKKM@createRuleBasedBreakIterator?3?5IC@+30h ; " line %d, column %d\n"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd 2000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 3000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F8h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	3000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0FCh
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B db 3 dup(0)
byte_FF		db 0			; DATA XREF: .data:off_200o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 100h
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 104h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2 ;	DATA XREF: .data:00000204o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 108h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10Ch
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 110h
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 114h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 118h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 11Ch
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 120h
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 124h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ??_C@_04PCJFHION@help?$AA@+4 ; ""
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 128h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB ;	int const std::_Arithmetic_traits<float>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 12Ch
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ??_C@_0L@JMMPKMPC@icudatadir?$AA@+4 ; "atadir"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 130h
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 134h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 138h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 13Ch
_options	dd offset ??_C@_04PCJFHION@help?$AA@ ; DATA XREF: _main+60o
					; "help"
		dd 3 dup(0)
		db 68h,	0
byte_14E	db 0			; DATA XREF: _main:loc_588r
		align 10h
		dd offset ??_C@_04PCJFHION@help?$AA@ ; "help"
		align 10h
		db 3Fh,	0
byte_162	db 0			; DATA XREF: _main+CBr
		align 4
		dd offset ??_C@_07KBAMPNJK@verbose?$AA@	; "verbose"
		dd 3 dup(0)
		dd offset ?_Rank@?$_Arithmetic_traits@K@std@@2HB+2
		dd offset ??_C@_05CBLPGGM@rules?$AA@ ; "rules"
dword_17C	dd 0			; DATA XREF: _main:loc_5F2r
		dd 2 dup(0)
		db 72h,	1
byte_18A	db 0			; DATA XREF: _main:loc_5A8r
		align 4
		dd offset ??_C@_03KEJHNBPP@out?$AA@ ; `string'
dword_190	dd 0			; DATA XREF: _main+132r
		dd 2 dup(0)
		db 6Fh,	1
byte_19E	db 0			; DATA XREF: _main+EBr
		align 10h
		dd offset ??_C@_0L@JMMPKMPC@icudatadir?$AA@ ; "icudatadir"
dword_1A4	dd 0			; DATA XREF: _main+145r
		align 10h
		db 69h,	1
byte_1B2	db 0			; DATA XREF: _main+13Ar
		align 4
		dd offset ??_C@_07HIFNFPHK@destdir?$AA@	; "destdir"
dword_1B8	dd 0			; DATA XREF: _main+165r
		align 10h
dword_1C0	dd 0			; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		db 64h,	1
byte_1C6	db 0			; DATA XREF: _main+15Ar
		align 4
		dd offset ??_C@_09JHBDCMB@copyright?$AA@ ; "copyright"
		dd 3 dup(0)
		db 63h,	0
byte_1DA	db 0			; DATA XREF: _main:loc_635r
		align 4
		dd offset ??_C@_05PMBAOCDH@quiet?$AA@ ;	"quiet"
		dd 3 dup(0)
		db 71h,	0
byte_1EE	db 0			; DATA XREF: _main+8FFr
		align 10h
		public ?dh@@3UDataHeader@@A
; struct DataHeader dh
?dh@@3UDataHeader@@A dd	27DA0018h
dword_1F4	dd 14h,	20000h,	206B7242h ; DATA XREF: _main+722o
off_200		dd offset byte_FF	; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
					; _main+70Do
		dd offset ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B ; std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 208h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usageAndDie(int Code)
		public ?usageAndDie@@YAXH@Z
?usageAndDie@@YAXH@Z proc near		; CODE XREF: _main+B8p	_main+D8p ...

var_C0		= byte ptr -0C0h
Code		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, ds:_progName
		push	eax
		push	offset ??_C@_0DH@BIPILLDB@Usage?3?5?$CFs?5?$FL?9v?$FN?5?$FL?9options?$FN?5?9r?5rul@ ; "Usage: %s [-v] [-options] -r rule-file "...
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		call	_u_getDataDirectory_56
		mov	esi, esp
		push	eax
		push	offset ??_C@_0BPK@HAPFEGHF@?7Read?5in?5break?5iteration?5rules?5t@ ; "\tRead in	break iteration	rules text an"...
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+Code]
		push	eax		; Code
		call	dword ptr ds:__imp__exit
?usageAndDie@@YAXH@Z endp

; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 288h
		public ??_C@_0BPK@HAPFEGHF@?7Read?5in?5break?5iteration?5rules?5t@
; char `string'[]
??_C@_0BPK@HAPFEGHF@?7Read?5in?5break?5iteration?5rules?5t@ db 9,'Read in break iteration rules text and write out the binary data'
					; DATA XREF: usageAndDie(int)+43o
		db 0Ah
		db 'options:',0Ah
		db 9,'-h or -? or --help  this usage text',0Ah
		db 9,'-V or --version     show a version message',0Ah
		db 9,'-c or --copyright   include a copyright notice',0Ah
		db 9,'-v or --verbose     turn on verbose output',0Ah
		db 9,'-q or --quiet       do not display warnings and progress',0Ah
		db 9,'-i or --icudatadir  directory for locating any needed intermedia'
		db 'te data files,',0Ah
		db 9,'                    followed by path, defaults to %s',0Ah
		db 9,'-d or --destdir     destination directory, followed by the path',0Ah
		db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 484h
		public ??_C@_0DH@BIPILLDB@Usage?3?5?$CFs?5?$FL?9v?$FN?5?$FL?9options?$FN?5?9r?5rul@
; char `string'[]
??_C@_0DH@BIPILLDB@Usage?3?5?$CFs?5?$FL?9v?$FN?5?$FL?9options?$FN?5?9r?5rul@ db	'Usage: %s [-v] [-options] -r rule-file -o output-file',0Ah,0
					; DATA XREF: usageAndDie(int)+26o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 4BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_progName	dd ?			; DATA XREF: usageAndDie(int)+20r
					; _main+5Aw
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 4C0h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 4C4h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public _main
_main		proc near

var_2C8		= dword	ptr -2C8h
var_2C0		= dword	ptr -2C0h
var_2B4		= dword	ptr -2B4h
var_2A8		= dword	ptr -2A8h
var_29C		= dword	ptr -29Ch
var_290		= dword	ptr -290h
var_284		= dword	ptr -284h
var_278		= dword	ptr -278h
var_26C		= dword	ptr -26Ch
var_260		= dword	ptr -260h
var_194		= dword	ptr -194h
var_188		= dword	ptr -188h
var_17C		= dword	ptr -17Ch
var_170		= dword	ptr -170h
var_164		= dword	ptr -164h
var_158		= dword	ptr -158h
var_154		= dword	ptr -154h
var_108		= byte ptr -108h
var_C0		= dword	ptr -0C0h
var_B4		= dword	ptr -0B4h
var_A8		= dword	ptr -0A8h
var_9C		= dword	ptr -9Ch
var_90		= dword	ptr -90h
var_84		= dword	ptr -84h
DstBuf		= dword	ptr -78h
File		= dword	ptr -6Ch
Count		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
Format		= dword	ptr -30h
Filename	= dword	ptr -24h
Code		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
argc		= dword	ptr  8
argv		= dword	ptr  0Ch
envp		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$_main
		mov	eax, large fs:0
		push	eax
		sub	esp, 2BCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_2C8]
		mov	ecx, 0AFh ; '¯'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+Code], 0
		mov	[ebp+var_3C], 0
		mov	[ebp+var_48], 0
		mov	eax, [ebp+argv]
		mov	ecx, [eax]
		mov	ds:_progName, ecx
		push	offset _options
		push	9
		mov	eax, [ebp+argv]
		push	eax
		mov	ecx, [ebp+argc]
		push	ecx
		call	_u_parseArgs
		add	esp, 10h
		mov	[ebp+argc], eax
		cmp	[ebp+argc], 0
		jge	short loc_588
		mov	eax, [ebp+argc]
		neg	eax
		mov	esi, esp
		mov	ecx, [ebp+argv]
		mov	edx, [ecx+eax*4]
		push	edx
		push	offset ??_C@_0CF@BGPNLJEE@error?5in?5command?5line?5argument?5?$CC@ ; "error in	command	line argument \"%s\"\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	1		; Code
		call	?usageAndDie@@YAXH@Z ; usageAndDie(int)
; ---------------------------------------------------------------------------
		db  83h	; ƒ
		db 0C4h	; Ä
		db    4
; ---------------------------------------------------------------------------

loc_588:				; CODE XREF: _main+7Ej
		movsx	eax, ds:byte_14E
		test	eax, eax
		jnz	short loc_59E
		movsx	eax, ds:byte_162
		test	eax, eax
		jz	short loc_5A8

loc_59E:				; CODE XREF: _main+C9j
		push	0		; Code
		call	?usageAndDie@@YAXH@Z ; usageAndDie(int)
; ---------------------------------------------------------------------------
		db  83h	; ƒ
		db 0C4h	; Ä
		db    4
; ---------------------------------------------------------------------------

loc_5A8:				; CODE XREF: _main+D4j
		movsx	eax, ds:byte_18A
		test	eax, eax
		jz	short loc_5BE
		movsx	eax, ds:byte_19E
		test	eax, eax
		jnz	short loc_5F2

loc_5BE:				; CODE XREF: _main+E9j
		mov	esi, esp
		push	offset ??_C@_0DD@OCLOMIED@rule?5file?5and?5output?5file?5must?5b@ ; "rule file and output file must both be "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	1		; Code
		call	?usageAndDie@@YAXH@Z ; usageAndDie(int)
; ---------------------------------------------------------------------------
		db  83h	; ƒ
		db 0C4h	; Ä
		db    4
; ---------------------------------------------------------------------------

loc_5F2:				; CODE XREF: _main+F4j
		mov	eax, ds:dword_17C
		mov	[ebp+Filename],	eax
		mov	eax, ds:dword_190
		mov	[ebp+Format], eax
		movsx	eax, ds:byte_1B2
		test	eax, eax
		jz	short loc_61B
		mov	eax, ds:dword_1A4
		push	eax
		call	_u_setDataDirectory_56
		add	esp, 4

loc_61B:				; CODE XREF: _main+143j
		mov	[ebp+Code], 0
		movsx	eax, ds:byte_1C6
		test	eax, eax
		jz	short loc_635
		mov	eax, ds:dword_1B8
		mov	[ebp+var_3C], eax

loc_635:				; CODE XREF: _main+163j
		movsx	eax, ds:byte_1DA
		test	eax, eax
		jz	short loc_647
		mov	[ebp+var_48], offset ??_C@_0GD@IBBFEJOD@?5Copyright?5?$CIC?$CJ?52015?0?5Internation@ ; " Copyright (C) 2015, International Busi"...

loc_647:				; CODE XREF: _main+176j
		lea	eax, [ebp+Code]
		push	eax
		call	_u_init_56
		add	esp, 4
		mov	eax, [ebp+Code]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_6B4
		mov	eax, [ebp+Code]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+argv]
		mov	edx, [ecx]
		push	edx		; Format
		push	offset ??_C@_0CK@CCPENKNA@?$CFs?3?5can?5not?5initialize?5ICU?4?5?5sta@ ; "%s: can not initialize ICU.  status =	%"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	1		; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6B4:				; CODE XREF: _main+19Cj
		mov	[ebp+Code], 0
		mov	esi, esp
		push	offset ??_C@_02JDPG@rb?$AA@ ; "rb"
		mov	eax, [ebp+Filename]
		push	eax		; Filename
		call	dword ptr ds:__imp__fopen
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+File], eax
		cmp	[ebp+File], 0
		jnz	short loc_71E
		mov	esi, esp
		mov	eax, [ebp+Filename]
		push	eax
		push	offset ??_C@_0BK@GKEMPMBF@Could?5not?5open?5file?5?$CC?$CFs?$CC?6?$AA@ ; "Could	not open file \"%s\"\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0FFFFFFFFh	; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_71E:				; CODE XREF: _main+215j
		mov	esi, esp
		push	2		; Origin
		push	0		; Offset
		mov	eax, [ebp+File]
		push	eax		; File
		call	dword ptr ds:__imp__fseek
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+File]
		push	eax		; File
		call	dword ptr ds:__imp__ftell
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Count], eax
		mov	esi, esp
		push	0		; Origin
		push	0		; Offset
		mov	eax, [ebp+File]
		push	eax		; File
		call	dword ptr ds:__imp__fseek
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+Count]
		add	eax, 0Ah
		push	eax		; unsigned int
		call	??_U@YAPAXI@Z	; operator new[](uint)
		add	esp, 4
		mov	[ebp+var_2C0], eax
		mov	ecx, [ebp+var_2C0]
		mov	[ebp+DstBuf], ecx
		mov	esi, esp
		mov	eax, [ebp+File]
		push	eax		; File
		mov	ecx, [ebp+Count]
		push	ecx		; Count
		push	1		; ElementSize
		mov	edx, [ebp+DstBuf]
		push	edx		; DstBuf
		call	dword ptr ds:__imp__fread
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_54], eax
		mov	eax, [ebp+var_54]
		cmp	eax, [ebp+Count]
		jz	short loc_7F3
		mov	esi, esp
		mov	eax, [ebp+Filename]
		push	eax
		push	offset ??_C@_0BJ@KDFMPOJA@Error?5reading?5file?5?$CC?$CFs?$CC?6?$AA@ ; "Error reading file \"%s\"\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0FFFFFFFFh	; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7F3:				; CODE XREF: _main+2EAj
		mov	eax, [ebp+DstBuf]
		add	eax, [ebp+Count]
		mov	byte ptr [eax],	0
		mov	esi, esp

loc_7FE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		mov	eax, [ebp+File]
		push	eax		; File
		call	dword ptr ds:__imp__fclose
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+DstBuf]
		mov	[ebp+var_90], eax
		lea	eax, [ebp+Code]
		push	eax
		lea	ecx, [ebp+var_84]
		push	ecx
		mov	edx, [ebp+Count]
		push	edx
		mov	eax, [ebp+var_90]
		push	eax
		call	_ucnv_detectUnicodeSignature_56
		add	esp, 10h
		mov	[ebp+var_9C], eax
		mov	eax, [ebp+Code]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_865
		mov	esi, esp
		mov	eax, [ebp+Code]
		push	eax		; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_865:				; CODE XREF: _main+388j
		cmp	[ebp+var_9C], 0
		jz	short loc_88C
		mov	eax, [ebp+var_90]
		add	eax, [ebp+var_84]
		mov	[ebp+var_90], eax
		mov	eax, [ebp+Count]
		sub	eax, [ebp+var_84]
		mov	[ebp+Count], eax

loc_88C:				; CODE XREF: _main+3A4j
		lea	eax, [ebp+Code]
		push	eax
		mov	ecx, [ebp+var_9C]
		push	ecx
		call	_ucnv_open_56
		add	esp, 8
		mov	[ebp+var_A8], eax
		mov	eax, [ebp+Code]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_902
		mov	eax, [ebp+Code]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax		; Format
		push	offset ??_C@_0BL@KFLPHDLH@ucnv_open?3?5ICU?5Error?5?$CC?$CFs?$CC?6?$AA@	; "ucnv_open: ICU Error	\"%s\"\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+Code]
		push	eax		; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_902:				; CODE XREF: _main+3EEj
		lea	eax, [ebp+Code]
		push	eax
		mov	ecx, [ebp+Count]
		push	ecx
		mov	edx, [ebp+var_90]
		push	edx
		push	0
		push	0
		mov	eax, [ebp+var_A8]
		push	eax
		call	_ucnv_toUChars_56
		add	esp, 18h
		mov	[ebp+var_B4], eax
		cmp	[ebp+Code], 0Fh
		jz	short loc_97A
		mov	eax, [ebp+Code]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax		; Format
		push	offset ??_C@_0BP@CFBDPEPG@ucnv_toUChars?3?5ICU?5Error?5?$CC?$CFs?$CC?6?$AA@ ; "ucnv_toUChars: ICU Error	\"%s\"\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+Code]
		push	eax		; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_97A:				; CODE XREF: _main+466j
		mov	[ebp+Code], 0
		mov	eax, [ebp+var_B4]
		add	eax, 1
		xor	ecx, ecx
		mov	edx, 2
		mul	edx
		seto	cl
		neg	ecx
		or	ecx, eax
		push	ecx		; unsigned int
		call	??_U@YAPAXI@Z	; operator new[](uint)
		add	esp, 4
		mov	[ebp+var_2B4], eax
		mov	eax, [ebp+var_2B4]
		mov	[ebp+var_C0], eax
		lea	eax, [ebp+Code]
		push	eax
		mov	ecx, [ebp+Count]
		push	ecx
		mov	edx, [ebp+var_90]
		push	edx
		mov	eax, [ebp+var_B4]
		add	eax, 1
		push	eax
		mov	ecx, [ebp+var_C0]
		push	ecx
		mov	edx, [ebp+var_A8]
		push	edx
		call	_ucnv_toUChars_56
		add	esp, 18h
		mov	eax, [ebp+Code]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_A41
		mov	eax, [ebp+Code]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax		; Format
		push	offset ??_C@_0BP@CFBDPEPG@ucnv_toUChars?3?5ICU?5Error?5?$CC?$CFs?$CC?6?$AA@ ; "ucnv_toUChars: ICU Error	\"%s\"\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+Code]
		push	eax		; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A41:				; CODE XREF: _main+52Dj
		mov	eax, [ebp+var_A8]
		push	eax
		call	_ucnv_close_56
		add	esp, 4
		mov	esi, esp
		mov	eax, [ebp+var_B4]
		push	eax		; int
		mov	ecx, [ebp+var_C0]
		push	ecx		; wchar_t *
		push	0		; signed __int8
		lea	ecx, [ebp+var_108] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	[ebp+var_158], 0
		mov	[ebp+var_154], 0
		mov	esi, esp
		push	178h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_29C], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_29C], 0
		jz	short loc_AFB
		mov	esi, esp
		lea	eax, [ebp+Code]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_158]
		push	ecx		; struct UParseError *
		lea	edx, [ebp+var_108]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_29C] ; this
		call	dword ptr ds:__imp_??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::UnicodeString const &,UParseError &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_29C]
		mov	dword ptr [eax], offset	??_SRuleBasedBreakIterator@icu_56@@6B@ ; const icu_56::RuleBasedBreakIterator::`local vftable'
		mov	ecx, [ebp+var_29C]
		mov	[ebp+var_2C8], ecx
		jmp	short loc_B05
; ---------------------------------------------------------------------------

loc_AFB:				; CODE XREF: _main+5F0j
		mov	[ebp+var_2C8], 0

loc_B05:				; CODE XREF: _main+631j
		mov	edx, [ebp+var_2C8]
		mov	[ebp+var_2A8], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_2A8]
		mov	[ebp+var_164], eax
		mov	eax, [ebp+Code]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_B8C
		mov	esi, esp
		mov	eax, [ebp+var_154]
		push	eax
		mov	ecx, [ebp+var_158]
		push	ecx
		mov	edx, [ebp+Code]
		push	edx
		call	_u_errorName_56
		add	esp, 4
		push	eax		; Format
		push	offset ??_C@_0EF@FGLKDKKM@createRuleBasedBreakIterator?3?5IC@ ;	"createRuleBasedBreakIterator: ICU Error"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+Code]
		push	eax		; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_B8C:				; CODE XREF: _main+66Aj
		mov	esi, esp
		lea	eax, [ebp+var_170]
		push	eax
		mov	ecx, [ebp+var_164]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_164]
		mov	eax, [edx+60h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_17C], eax
		push	1
		mov	eax, [ebp+var_17C]
		add	eax, 4
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	4		; Size
		mov	ecx, [ebp+var_17C]
		add	ecx, 4
		push	ecx		; Src
		push	offset off_200	; Dst
		call	_memcpy
		add	esp, 0Ch
		lea	eax, [ebp+Code]
		push	eax
		mov	ecx, [ebp+var_48]
		push	ecx
		push	offset dword_1F4
		mov	edx, [ebp+Format]
		push	edx
		push	0
		mov	eax, [ebp+var_3C]
		push	eax
		call	_udata_create
		add	esp, 18h
		mov	[ebp+var_194], eax
		mov	eax, [ebp+Code]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_C68
		mov	eax, [ebp+Code]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+Format]
		push	ecx		; Format
		push	offset ??_C@_0CP@IFLBHPGC@genbrk?3?5Could?5not?5open?5output?5fi@ ; "genbrk: Could not open output file	\"%s"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+Code]
		push	eax		; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C68:				; CODE XREF: _main+750j
		mov	eax, [ebp+var_170]
		push	eax
		mov	ecx, [ebp+var_17C]
		push	ecx
		mov	edx, [ebp+var_194]
		push	edx
		call	_udata_writeBlock
		add	esp, 0Ch
		lea	eax, [ebp+Code]
		push	eax
		mov	ecx, [ebp+var_194]
		push	ecx
		call	_udata_finish
		add	esp, 8
		mov	[ebp+var_188], eax
		mov	eax, [ebp+Code]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_CF2
		mov	esi, esp
		mov	eax, [ebp+Code]
		push	eax
		push	offset ??_C@_0CK@GGBHJNNO@genbrk?3?5error?5?$CFd?5writing?5the?5out@ ; "genbrk:	error %d writing the output fil"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+Code]
		push	eax		; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_CF2:				; CODE XREF: _main+7E7j
		mov	eax, [ebp+var_188]
		cmp	eax, [ebp+var_170]
		jz	short loc_D3F
		mov	esi, esp
		mov	eax, [ebp+Format]
		push	eax
		push	offset ??_C@_0CD@IEKCIACJ@Error?5writing?5to?5output?5file?5?$CC?$CFs@ ; "Error	writing	to output file \"%s\"\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0FFFFFFFFh	; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_D3F:				; CODE XREF: _main+836j
		mov	eax, [ebp+var_164]
		mov	[ebp+var_284], eax
		mov	ecx, [ebp+var_284]
		mov	[ebp+var_290], ecx
		cmp	[ebp+var_290], 0
		jz	short loc_D85
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_290]
		mov	eax, [edx]
		mov	ecx, [ebp+var_290]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C8], eax
		jmp	short loc_D8F
; ---------------------------------------------------------------------------

loc_D85:				; CODE XREF: _main+896j
		mov	[ebp+var_2C8], 0

loc_D8F:				; CODE XREF: _main+8BBj
		mov	eax, [ebp+var_C0]
		mov	[ebp+var_278], eax
		mov	ecx, [ebp+var_278]
		push	ecx		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4
		mov	eax, [ebp+DstBuf]
		mov	[ebp+var_26C], eax
		mov	ecx, [ebp+var_26C]
		push	ecx		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4
		call	_u_cleanup_56
		movsx	eax, ds:byte_1EE
		test	eax, eax
		jnz	short loc_DE9
		mov	esi, esp
		push	offset ??_C@_0CG@BNLHCBNB@genbrk?3?5tool?5completed?5successfu@	; "genbrk: tool	completed successfully.\n"
		call	dword ptr ds:__imp__printf
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_DE9:				; CODE XREF: _main+908j
		mov	[ebp+var_260], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp

loc_DFC:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		lea	ecx, [ebp+var_108] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_260]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN37
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 2C8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_main		endp

; ---------------------------------------------------------------------------
		align 10h
$LN37		dd 5			; DATA XREF: _main+951o
		dd offset $LN36
$LN36		dd 0FFFFFFE8h, 4	; DATA XREF: .text:00000E54o
		dd offset $LN30		; "status"
		dd 0FFFFFF7Ch, 4
		dd offset $LN31		; "signatureLength"
		dd 0FFFFFEF8h, 40h
		dd offset $LN32		; "ruleSourceS"
		dd 0FFFFFEA8h, 48h
		dd offset $LN33		; "parseError"
		db 90h
		db 0FEh, 2 dup(0FFh)
		dd 4
		dd offset $LN34		; "outDataSize"
$LN34		db 'outDataSize',0      ; DATA XREF: .text:00000E90o
$LN33		db 'parseError',0       ; DATA XREF: .text:00000E84o
$LN32		db 'ruleSourceS',0      ; DATA XREF: .text:00000E78o
$LN31		db 'signatureLength',0  ; DATA XREF: .text:00000E6Co
$LN30		db 'status',0           ; DATA XREF: .text:00000E60o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0ED0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$_main$0	proc near	; DATA XREF: .xdata$x:000011F0o
		mov	esi, esp
		lea	ecx, [ebp-108h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$_main$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$_main$1	proc near	; DATA XREF: .xdata$x:000011F8o
		mov	esi, esp
		mov	eax, [ebp-29Ch]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$_main$1	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$_main proc near		; DATA XREF: _main+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-2CCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$_main
		jmp	___CxxFrameHandler3
__ehhandler$_main endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F28h
		public ??_C@_0CG@BNLHCBNB@genbrk?3?5tool?5completed?5successfu@
; char `string'[]
??_C@_0CG@BNLHCBNB@genbrk?3?5tool?5completed?5successfu@ db 'genbrk: tool completed successfully.',0Ah,0
					; DATA XREF: _main+90Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F50h
		public ??_C@_0CD@IEKCIACJ@Error?5writing?5to?5output?5file?5?$CC?$CFs@
; char `string'[]
??_C@_0CD@IEKCIACJ@Error?5writing?5to?5output?5file?5?$CC?$CFs@	db 'Error writing to output file "%s"',0Ah,0
					; DATA XREF: _main+83Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F74h
		public ??_C@_0CK@GGBHJNNO@genbrk?3?5error?5?$CFd?5writing?5the?5out@
; char `string'[]
??_C@_0CK@GGBHJNNO@genbrk?3?5error?5?$CFd?5writing?5the?5out@ db 'genbrk: error %d writing the output file',0Ah,0
					; DATA XREF: _main+7EFo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0FA0h
		public ??_C@_0CP@IFLBHPGC@genbrk?3?5Could?5not?5open?5output?5fi@
; char `string'[]
??_C@_0CP@IFLBHPGC@genbrk?3?5Could?5not?5open?5output?5fi@ db 'genbrk: Could not open output file "%s", "%s"',0Ah,0
					; DATA XREF: _main+765o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0FD0h
		public ??_C@_0EF@FGLKDKKM@createRuleBasedBreakIterator?3?5IC@
; char `string'[]
??_C@_0EF@FGLKDKKM@createRuleBasedBreakIterator?3?5IC@ db 'createRuleBasedBreakIterator: ICU Error "%s"  at line %d, column '
					; DATA XREF: _main+689o
		db '%d',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 1018h
		dd offset ??_R4RuleBasedBreakIterator@icu_56@@6B@ ; const icu_56::RuleBasedBreakIterator::`RTTI	Complete Object	Locator'
		public ??_SRuleBasedBreakIterator@icu_56@@6B@
; const	icu_56::RuleBasedBreakIterator::`local vftable'
??_SRuleBasedBreakIterator@icu_56@@6B@ dd offset ??_ERuleBasedBreakIterator@icu_56@@UAEPAXI@Z
					; DATA XREF: _main+61Fo
					; icu_56::RuleBasedBreakIterator::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@RuleBasedBreakIterator@icu_56@@UBEPAXXZ ; icu_56::RuleBasedBreakIterator::getDynamicClassID(void)
		dd offset ??8RuleBasedBreakIterator@icu_56@@UBECABVBreakIterator@1@@Z ;	icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)
		dd offset ?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ ; icu_56::RuleBasedBreakIterator::clone(void)
		dd offset ?getText@RuleBasedBreakIterator@icu_56@@UBEAAVCharacterIterator@2@XZ ; icu_56::RuleBasedBreakIterator::getText(void)
		dd offset ?getUText@RuleBasedBreakIterator@icu_56@@UBEPAUUText@@PAU3@AAW4UErrorCode@@@Z	; icu_56::RuleBasedBreakIterator::getUText(UText *,UErrorCode &)
		dd offset ?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)
		dd offset ?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z ; icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)
		dd offset ?adoptText@RuleBasedBreakIterator@icu_56@@UAEXPAVCharacterIterator@2@@Z ; icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator	*)
		dd offset ?first@RuleBasedBreakIterator@icu_56@@UAEHXZ ; icu_56::RuleBasedBreakIterator::first(void)
		dd offset ?last@RuleBasedBreakIterator@icu_56@@UAEHXZ ;	icu_56::RuleBasedBreakIterator::last(void)
		dd offset ?previous@RuleBasedBreakIterator@icu_56@@UAEHXZ ; icu_56::RuleBasedBreakIterator::previous(void)
		dd offset ?next@RuleBasedBreakIterator@icu_56@@UAEHH@Z ; icu_56::RuleBasedBreakIterator::next(int)
		dd offset ?next@RuleBasedBreakIterator@icu_56@@UAEHXZ ;	icu_56::RuleBasedBreakIterator::next(void)
		dd offset ?current@RuleBasedBreakIterator@icu_56@@UBEHXZ ; icu_56::RuleBasedBreakIterator::current(void)
		dd offset ?following@RuleBasedBreakIterator@icu_56@@UAEHH@Z ; icu_56::RuleBasedBreakIterator::following(int)
		dd offset ?preceding@RuleBasedBreakIterator@icu_56@@UAEHH@Z ; icu_56::RuleBasedBreakIterator::preceding(int)
		dd offset ?isBoundary@RuleBasedBreakIterator@icu_56@@UAECH@Z ; icu_56::RuleBasedBreakIterator::isBoundary(int)
		dd offset ?getRuleStatus@RuleBasedBreakIterator@icu_56@@UBEHXZ ; icu_56::RuleBasedBreakIterator::getRuleStatus(void)
		dd offset ?getRuleStatusVec@RuleBasedBreakIterator@icu_56@@UAEHPAHHAAW4UErrorCode@@@Z ;	icu_56::RuleBasedBreakIterator::getRuleStatusVec(int *,int,UErrorCode &)
		dd offset ?createBufferClone@RuleBasedBreakIterator@icu_56@@UAEPAVBreakIterator@2@PAXAAHAAW4UErrorCode@@@Z ; icu_56::RuleBasedBreakIterator::createBufferClone(void *,int &,UErrorCode &)
		dd offset ?refreshInputText@RuleBasedBreakIterator@icu_56@@UAEAAV12@PAUUText@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)
		dd offset ?hashCode@RuleBasedBreakIterator@icu_56@@UBEHXZ ; icu_56::RuleBasedBreakIterator::hashCode(void)
		dd offset ?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ ; icu_56::RuleBasedBreakIterator::getRules(void)
		dd offset ?getBinaryRules@RuleBasedBreakIterator@icu_56@@UAEPBEAAI@Z ; icu_56::RuleBasedBreakIterator::getBinaryRules(uint &)
		dd offset ?reset@RuleBasedBreakIterator@icu_56@@MAEXXZ ; icu_56::RuleBasedBreakIterator::reset(void)
		dd offset ?setBreakType@RuleBasedBreakIterator@icu_56@@MAEXH@Z ; icu_56::RuleBasedBreakIterator::setBreakType(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1088h
		public ??_C@_0BP@CFBDPEPG@ucnv_toUChars?3?5ICU?5Error?5?$CC?$CFs?$CC?6?$AA@
; char `string'[]
??_C@_0BP@CFBDPEPG@ucnv_toUChars?3?5ICU?5Error?5?$CC?$CFs?$CC?6?$AA@ db	'ucnv_toUChars: ICU Error "%s"',0Ah,0
					; DATA XREF: _main+477o _main+53Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10A8h
		public ??_C@_0BL@KFLPHDLH@ucnv_open?3?5ICU?5Error?5?$CC?$CFs?$CC?6?$AA@
; char `string'[]
??_C@_0BL@KFLPHDLH@ucnv_open?3?5ICU?5Error?5?$CC?$CFs?$CC?6?$AA@ db 'ucnv_open: ICU Error "%s"',0Ah,0
					; DATA XREF: _main+3FFo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10C4h
		public ??_C@_0BJ@KDFMPOJA@Error?5reading?5file?5?$CC?$CFs?$CC?6?$AA@
; char `string'[]
??_C@_0BJ@KDFMPOJA@Error?5reading?5file?5?$CC?$CFs?$CC?6?$AA@ db 'Error reading file "%s"',0Ah,0
					; DATA XREF: _main+2F2o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10E0h
		public ??_C@_0BK@GKEMPMBF@Could?5not?5open?5file?5?$CC?$CFs?$CC?6?$AA@
; char `string'[]
??_C@_0BK@GKEMPMBF@Could?5not?5open?5file?5?$CC?$CFs?$CC?6?$AA@	db 'Could not open file "%s"',0Ah,0
					; DATA XREF: _main+21Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10FCh
		public ??_C@_02JDPG@rb?$AA@
; char `string'[3]
??_C@_02JDPG@rb?$AA@ db	'rb',0          ; DATA XREF: _main+1F5o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1100h
		public ??_C@_0CK@CCPENKNA@?$CFs?3?5can?5not?5initialize?5ICU?4?5?5sta@
; char `string'[]
??_C@_0CK@CCPENKNA@?$CFs?3?5can?5not?5initialize?5ICU?4?5?5sta@	db '%s: can not initialize ICU.  status = %s',0Ah,0
					; DATA XREF: _main+1B3o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 112Ch
		public ??_C@_0GD@IBBFEJOD@?5Copyright?5?$CIC?$CJ?52015?0?5Internation@
; `string'
??_C@_0GD@IBBFEJOD@?5Copyright?5?$CIC?$CJ?52015?0?5Internation@	db ' Copyright (C) 2015, International Business Machines Corporation '
					; DATA XREF: _main+178o
		db 'and others. All Rights Reserved. ',0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1190h
		public ??_C@_0DD@OCLOMIED@rule?5file?5and?5output?5file?5must?5b@
; char `string'[]
??_C@_0DD@OCLOMIED@rule?5file?5and?5output?5file?5must?5b@ db 'rule file and output file must both be specified.',0Ah,0
					; DATA XREF: _main+F8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 11C4h
		public ??_C@_0CF@BGPNLJEE@error?5in?5command?5line?5argument?5?$CC@
; char `string'[]
??_C@_0CF@BGPNLJEE@error?5in?5command?5line?5argument?5?$CC@ db	'error in command line argument "%s"',0Ah,0
					; DATA XREF: _main+8Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 11ECh
__unwindtable$_main dd 0FFFFFFFFh	; DATA XREF: .xdata$x:00001204o
		dd offset __unwindfunclet$_main$0
		align 8
		dd offset __unwindfunclet$_main$1
__ehfuncinfo$_main dd 19930522h, 2	; DATA XREF: __ehhandler$_main+1Eo
		dd offset __unwindtable$_main
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1220h
		public ??_R4RuleBasedBreakIterator@icu_56@@6B@
; const	icu_56::RuleBasedBreakIterator::`RTTI Complete Object Locator'
??_R4RuleBasedBreakIterator@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:00001018o
		dd offset ??_R0?AVRuleBasedBreakIterator@icu_56@@@8 ; icu_56::RuleBasedBreakIterator `RTTI Type	Descriptor'
		dd offset ??_R3RuleBasedBreakIterator@icu_56@@8	; icu_56::RuleBasedBreakIterator::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1234h
		public ??_R0?AVRuleBasedBreakIterator@icu_56@@@8
; class	icu_56::RuleBasedBreakIterator `RTTI Type Descriptor'
??_R0?AVRuleBasedBreakIterator@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000122Co
					; .rdata$r:icu_56::RuleBasedBreakIterator::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avrulebasedb	db '.?AVRuleBasedBreakIterator@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1260h
		public ??_R3RuleBasedBreakIterator@icu_56@@8
; icu_56::RuleBasedBreakIterator::`RTTI	Class Hierarchy	Descriptor'
??_R3RuleBasedBreakIterator@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00001230o
					; .rdata$r:0000129Co
		dd 4
		dd offset ??_R2RuleBasedBreakIterator@icu_56@@8	; icu_56::RuleBasedBreakIterator::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1270h
		public ??_R2RuleBasedBreakIterator@icu_56@@8
; icu_56::RuleBasedBreakIterator::`RTTI	Base Class Array'
??_R2RuleBasedBreakIterator@icu_56@@8 dd offset	??_R1A@?0A@EA@RuleBasedBreakIterator@icu_56@@8
					; DATA XREF: .rdata$r:0000126Co
					; icu_56::RuleBasedBreakIterator::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@BreakIterator@icu_56@@8	; icu_56::BreakIterator::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1284h
		public ??_R1A@?0A@EA@RuleBasedBreakIterator@icu_56@@8
; icu_56::RuleBasedBreakIterator::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@RuleBasedBreakIterator@icu_56@@8 dd offset ??_R0?AVRuleBasedBreakIterator@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::RuleBasedBreakIterator::`RTTI Base Class Array'o
					; icu_56::RuleBasedBreakIterator `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_04PCJFHION@help?$AA@+4 ; ""
		dd offset ??_R3RuleBasedBreakIterator@icu_56@@8	; icu_56::RuleBasedBreakIterator::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 12A0h
		public ??_R1A@?0A@EA@BreakIterator@icu_56@@8
; icu_56::BreakIterator::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@BreakIterator@icu_56@@8 dd offset	??_R0?AVBreakIterator@icu_56@@@8
					; DATA XREF: .rdata$r:00001274o
					; .rdata$r:icu_56::BreakIterator::`RTTI	Base Class Array'o
					; icu_56::BreakIterator	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_04PCJFHION@help?$AA@+4 ; ""
		dd offset ??_R3BreakIterator@icu_56@@8 ; icu_56::BreakIterator::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 12BCh
		public ??_R0?AVBreakIterator@icu_56@@@8
; class	icu_56::BreakIterator `RTTI Type Descriptor'
??_R0?AVBreakIterator@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::BreakIterator::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avbreakitera	db '.?AVBreakIterator@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 12E0h
		public ??_R3BreakIterator@icu_56@@8
; icu_56::BreakIterator::`RTTI Class Hierarchy Descriptor'
??_R3BreakIterator@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:000012B8o
		dd 3
		dd offset ??_R2BreakIterator@icu_56@@8 ; icu_56::BreakIterator::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 12F0h
		public ??_R2BreakIterator@icu_56@@8
; icu_56::BreakIterator::`RTTI Base Class Array'
??_R2BreakIterator@icu_56@@8 dd	offset ??_R1A@?0A@EA@BreakIterator@icu_56@@8
					; DATA XREF: .rdata$r:000012ECo
					; icu_56::BreakIterator::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1300h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:00001278o
					; .rdata$r:000012F4o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_04PCJFHION@help?$AA@+4 ; ""
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 131Ch
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 133Ch
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00001318o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 134Ch
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00001348o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1358h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:0000127Co
					; .rdata$r:000012F8o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset ??_C@_04PCJFHION@help?$AA@+4 ; ""
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1374h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1394h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00001370o
					; .rdata$r:000013C4o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 13A4h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000013A0o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 13ACh
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_04PCJFHION@help?$AA@+4 ; ""
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _main+18Fp _main+37Bp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::RuleBasedBreakIterator::`scalar deleting destructor'(unsigned int)
		public ??_GRuleBasedBreakIterator@icu_56@@UAEPAXI@Z
??_GRuleBasedBreakIterator@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1RuleBasedBreakIterator@icu_56@@UAE@XZ ; icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1447
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1447:				; CODE XREF: icu_56::RuleBasedBreakIterator::`scalar deleting destructor'(uint)+3Bj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRuleBasedBreakIterator@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; void __cdecl __noreturn _exit(int Code)
		extrn __imp__exit:near	; CODE XREF: usageAndDie(int)+5Ep
					; _main+1DFp ...
		extrn _u_getDataDirectory_56:near ; CODE XREF: usageAndDie(int)+3Bp
; int _printf(const char *Format, ...)
		extrn __imp__printf:near ; CODE	XREF: usageAndDie(int)+2Bp
					; usageAndDie(int)+48p	...
		extrn __RTC_CheckEsp:near ; CODE XREF: usageAndDie(int)+36p
					; usageAndDie(int)+53p	...
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: __unwindfunclet$_main$1+9p
					; icu_56::RuleBasedBreakIterator::`scalar deleting destructor'(uint)+43p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near ; CODE	XREF: _main+93Ap
					; __unwindfunclet$_main$0+8p
					; DATA XREF: ...
		extrn _u_cleanup_56:near ; CODE	XREF: _main+8FAp
; void __cdecl operator	delete[](void *)
		extrn ??_V@YAXPAX@Z:near ; CODE	XREF: _main+8DAp _main+8F2p
		extrn _udata_finish:near ; CODE	XREF: _main+7C8p
		extrn _udata_writeBlock:near ; CODE XREF: _main+7B5p
		extrn _udata_create:near ; CODE	XREF: _main+731p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _main+712p
		extrn _uprv_checkValidMemory:near ; CODE XREF: _main+6F9p
; _DWORD __thiscall icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator *__hidden this, const	struct icu_56::UnicodeString *,	struct UParseError *, enum UErrorCode *)
		extrn __imp_??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z:near
					; CODE XREF: _main+60Cp
					; DATA XREF: _main+60Cr
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn __imp_??2UMemory@icu_56@@SAPAXI@Z:near ; CODE XREF: _main+5CFp
					; DATA XREF: _main+5CFr
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, signed __int8, const wchar_t *, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z:near
					; CODE XREF: _main+5A0p
					; DATA XREF: _main+5A0r
		extrn _ucnv_close_56:near ; CODE XREF: _main+580p
		extrn _ucnv_toUChars_56:near ; CODE XREF: _main+454p
					; _main+514p
		extrn _ucnv_open_56:near ; CODE	XREF: _main+3CFp
		extrn _ucnv_detectUnicodeSignature_56:near ; CODE XREF:	_main+369p
; int __cdecl _fclose(FILE *File)
		extrn __imp__fclose:near ; CODE	XREF: _main+33Ap
					; DATA XREF: _main+33Ar
; size_t __cdecl _fread(void *DstBuf, size_t ElementSize, size_t Count,	FILE *File)
		extrn __imp__fread:near	; CODE XREF: _main+2D1p
					; DATA XREF: _main+2D1r
; void *__cdecl	operator new[](unsigned	int)
		extrn ??_U@YAPAXI@Z:near ; CODE	XREF: _main+2AAp _main+4D3p
; __int32 __cdecl _ftell(FILE *File)
		extrn __imp__ftell:near	; CODE XREF: _main+276p
					; DATA XREF: _main+276r
; int __cdecl _fseek(FILE *File, __int32 Offset, int Origin)
		extrn __imp__fseek:near	; CODE XREF: _main+260p _main+293p
					; DATA XREF: ...
; FILE *__cdecl	_fopen(const char *Filename, const char	*Mode)
		extrn __imp__fopen:near	; CODE XREF: _main+1FEp
					; DATA XREF: _main+1FEr
		extrn _u_errorName_56:near ; CODE XREF:	_main+1A2p _main+3F4p	...
		extrn _u_init_56:near	; CODE XREF: _main+183p
		extrn _u_setDataDirectory_56:near ; CODE XREF: _main+14Bp
; int _fprintf(FILE *File, const char *Format, ...)
		extrn __imp__fprintf:near ; CODE XREF: _main+A6p _main+110p ...
; FILE *__cdecl	___iob_func()
		extrn __imp____iob_func:near ; CODE XREF: _main+95p _main+FFp	...
		extrn _u_parseArgs:near	; CODE XREF: _main+6Fp
		extrn ___security_cookie:near ;	DATA XREF: _main+2Cr
		extrn ___CxxFrameHandler3:near ; CODE XREF: __ehhandler$_main+23j
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _main+971p
					; __ehhandler$_main+Fp	...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near ; CODE XREF: _main+957p
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::RuleBasedBreakIterator `RTTI	Type Descriptor'o
					; .data:icu_56::BreakIterator `RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::RuleBasedBreakIterator::`scalar deleting destructor'(unsigned int)
		extrn ??_GRuleBasedBreakIterator@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::RuleBasedBreakIterator::`vector deleting destructor'(unsigned int)
		extrn ??_ERuleBasedBreakIterator@icu_56@@UAEPAXI@Z:near	; weak
					; DATA XREF: .rdata:const icu_56::RuleBasedBreakIterator::`local vftable'o
; public: virtual void * __thiscall icu_56::RuleBasedBreakIterator::getDynamicClassID(void)const
		extrn ?getDynamicClassID@RuleBasedBreakIterator@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001020o
; public: virtual signed char __thiscall icu_56::RuleBasedBreakIterator::operator==(class icu_56::BreakIterator	const &)const
		extrn ??8RuleBasedBreakIterator@icu_56@@UBECABVBreakIterator@1@@Z:near
					; DATA XREF: .rdata:00001024o
; public: virtual class	icu_56::BreakIterator *	__thiscall icu_56::RuleBasedBreakIterator::clone(void)const
		extrn ?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ:near
					; DATA XREF: .rdata:00001028o
; public: virtual class	icu_56::CharacterIterator & __thiscall icu_56::RuleBasedBreakIterator::getText(void)const
		extrn ?getText@RuleBasedBreakIterator@icu_56@@UBEAAVCharacterIterator@2@XZ:near
					; DATA XREF: .rdata:0000102Co
; public: virtual struct UText * __thiscall icu_56::RuleBasedBreakIterator::getUText(struct UText *, enum  UErrorCode &)const
		extrn ?getUText@RuleBasedBreakIterator@icu_56@@UBEPAUUText@@PAU3@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00001030o
; public: virtual void __thiscall icu_56::RuleBasedBreakIterator::setText(struct UText *, enum	UErrorCode &)
		extrn ?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00001034o
; public: virtual void __thiscall icu_56::RuleBasedBreakIterator::setText(class	icu_56::UnicodeString const &)
		extrn ?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z:near
					; DATA XREF: .rdata:00001038o
; public: virtual void __thiscall icu_56::RuleBasedBreakIterator::adoptText(class icu_56::CharacterIterator *)
		extrn ?adoptText@RuleBasedBreakIterator@icu_56@@UAEXPAVCharacterIterator@2@@Z:near
					; DATA XREF: .rdata:0000103Co
; public: virtual int __thiscall icu_56::RuleBasedBreakIterator::first(void)
		extrn ?first@RuleBasedBreakIterator@icu_56@@UAEHXZ:near
					; DATA XREF: .rdata:00001040o
; public: virtual int __thiscall icu_56::RuleBasedBreakIterator::last(void)
		extrn ?last@RuleBasedBreakIterator@icu_56@@UAEHXZ:near
					; DATA XREF: .rdata:00001044o
; public: virtual int __thiscall icu_56::RuleBasedBreakIterator::previous(void)
		extrn ?previous@RuleBasedBreakIterator@icu_56@@UAEHXZ:near
					; DATA XREF: .rdata:00001048o
; public: virtual int __thiscall icu_56::RuleBasedBreakIterator::next(int)
		extrn ?next@RuleBasedBreakIterator@icu_56@@UAEHH@Z:near
					; DATA XREF: .rdata:0000104Co
; public: virtual int __thiscall icu_56::RuleBasedBreakIterator::next(void)
		extrn ?next@RuleBasedBreakIterator@icu_56@@UAEHXZ:near
					; DATA XREF: .rdata:00001050o
; public: virtual int __thiscall icu_56::RuleBasedBreakIterator::current(void)const
		extrn ?current@RuleBasedBreakIterator@icu_56@@UBEHXZ:near
					; DATA XREF: .rdata:00001054o
; public: virtual int __thiscall icu_56::RuleBasedBreakIterator::following(int)
		extrn ?following@RuleBasedBreakIterator@icu_56@@UAEHH@Z:near
					; DATA XREF: .rdata:00001058o
; public: virtual int __thiscall icu_56::RuleBasedBreakIterator::preceding(int)
		extrn ?preceding@RuleBasedBreakIterator@icu_56@@UAEHH@Z:near
					; DATA XREF: .rdata:0000105Co
; public: virtual signed char __thiscall icu_56::RuleBasedBreakIterator::isBoundary(int)
		extrn ?isBoundary@RuleBasedBreakIterator@icu_56@@UAECH@Z:near
					; DATA XREF: .rdata:00001060o
; public: virtual int __thiscall icu_56::RuleBasedBreakIterator::getRuleStatus(void)const
		extrn ?getRuleStatus@RuleBasedBreakIterator@icu_56@@UBEHXZ:near
					; DATA XREF: .rdata:00001064o
; public: virtual int __thiscall icu_56::RuleBasedBreakIterator::getRuleStatusVec(int *, int, enum  UErrorCode &)
		extrn ?getRuleStatusVec@RuleBasedBreakIterator@icu_56@@UAEHPAHHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00001068o
; public: virtual class	icu_56::BreakIterator *	__thiscall icu_56::RuleBasedBreakIterator::createBufferClone(void *, int &, enum  UErrorCode &)
		extrn ?createBufferClone@RuleBasedBreakIterator@icu_56@@UAEPAVBreakIterator@2@PAXAAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:0000106Co
; public: virtual class	icu_56::RuleBasedBreakIterator & __thiscall icu_56::RuleBasedBreakIterator::refreshInputText(struct UText *, enum  UErrorCode &)
		extrn ?refreshInputText@RuleBasedBreakIterator@icu_56@@UAEAAV12@PAUUText@@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00001070o
; public: virtual int __thiscall icu_56::RuleBasedBreakIterator::hashCode(void)const
		extrn ?hashCode@RuleBasedBreakIterator@icu_56@@UBEHXZ:near
					; DATA XREF: .rdata:00001074o
; public: virtual class	icu_56::UnicodeString const & __thiscall icu_56::RuleBasedBreakIterator::getRules(void)const
		extrn ?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ:near
					; DATA XREF: .rdata:00001078o
; public: virtual unsigned char	const *	__thiscall icu_56::RuleBasedBreakIterator::getBinaryRules(unsigned int &)
		extrn ?getBinaryRules@RuleBasedBreakIterator@icu_56@@UAEPBEAAI@Z:near
					; DATA XREF: .rdata:0000107Co
; protected: virtual void __thiscall icu_56::RuleBasedBreakIterator::reset(void)
		extrn ?reset@RuleBasedBreakIterator@icu_56@@MAEXXZ:near
					; DATA XREF: .rdata:00001080o
; protected: virtual void __thiscall icu_56::RuleBasedBreakIterator::setBreakType(int)
		extrn ?setBreakType@RuleBasedBreakIterator@icu_56@@MAEXH@Z:near
					; DATA XREF: .rdata:00001084o
; _DWORD __thiscall icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator *__hidden this)
		extrn __imp_??1RuleBasedBreakIterator@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::`scalar deleting destructor'(uint)+28p
					; DATA XREF: icu_56::RuleBasedBreakIterator::`scalar deleting destructor'(uint)+28r


		end
