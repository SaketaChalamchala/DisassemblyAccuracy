;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	F9C6E7FC1CE8459D3D8990EB60BFD81A
; Input	CRC32 :	D394B09B

; File Name   :	D:\compspace\objfiles\firefox\uconv\uwmsg.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		public ??_C@_1EO@JHNPCCOG@?$AA?5?$AA?$CI?$AAU?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAN?$AAO?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AAT?$AAI?$AAN?$AAG?$AA?5?$AAs?$AAe?$AAe?$AA?5?$AAu?$AAc?$AAo?$AAn@
; `string'
??_C@_1EO@JHNPCCOG@?$AA?5?$AA?$CI?$AAU?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAN?$AAO?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AAT?$AAI?$AAN?$AAG?$AA?5?$AAs?$AAe?$AAe?$AA?5?$AAu?$AAc?$AAo?$AAn@:
					; DATA XREF: .data:_gNoFormattingo
		unicode	0, < (UCONFIG_NO_FORMATTING see	uconfig.h)>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_gBundle	dd ?			; DATA XREF: _u_wmsg_setPath:loc_8Ar
					; _u_wmsg_setPath+6Dw ...
		public _gInfoMessages
; void *gInfoMessages
_gInfoMessages	dd ?			; DATA XREF: _u_wmsg_errorName+14Er
					; _fetchErrorName+1Er ...
		public _gErrMessages
; void *gErrMessages
_gErrMessages	dd ?			; DATA XREF: _u_wmsg_errorName+13Dr
					; _fetchErrorName:loc_63Er ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 5Ch
_gNoFormatting	dd offset ??_C@_1EO@JHNPCCOG@?$AA?5?$AA?$CI?$AAU?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA_?$AAN?$AAO?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AAT?$AAI?$AAN?$AAG?$AA?5?$AAs?$AAe?$AAe?$AA?5?$AAu?$AAc?$AAo?$AAn@ ; " (UCONFIG_NO_FORMATTING	see uconfig.h)"
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _u_wmsg_setPath
_u_wmsg_setPath	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jle	short loc_8A
		xor	eax, eax
		jmp	short loc_D7
; ---------------------------------------------------------------------------

loc_8A:					; CODE XREF: _u_wmsg_setPath+24j
		cmp	ds:_gBundle, 0
		jz	short loc_A2
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_D7
; ---------------------------------------------------------------------------
		jmp	short loc_D2
; ---------------------------------------------------------------------------

loc_A2:					; CODE XREF: _u_wmsg_setPath+31j
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ures_open_56
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jle	short loc_CA
		xor	eax, eax
		jmp	short loc_D7
; ---------------------------------------------------------------------------

loc_CA:					; CODE XREF: _u_wmsg_setPath+64j
		mov	eax, [ebp+var_8]
		mov	ds:_gBundle, eax

loc_D2:					; CODE XREF: _u_wmsg_setPath+40j
		mov	eax, ds:_gBundle

loc_D7:					; CODE XREF: _u_wmsg_setPath+28j
					; _u_wmsg_setPath+3Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_u_wmsg_setPath	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 0ECh
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 0F0h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl u_wmsg(FILE *File, int, char)
		public _u_wmsg
_u_wmsg		proc near

var_2108	= byte ptr -2108h
var_2044	= dword	ptr -2044h
var_2038	= dword	ptr -2038h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
File		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, 2108h
		call	__chkstk
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_2108]
		mov	ecx, 842h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_24], 0
		mov	[ebp+var_2044],	1000h
		cmp	ds:_gBundle, 0
		jnz	short loc_142
		or	eax, 0FFFFFFFFh
		jmp	loc_201
; ---------------------------------------------------------------------------

loc_142:				; CODE XREF: _u_wmsg+44j
		lea	eax, [ebp+var_24]
		push	eax
		lea	ecx, [ebp+var_18]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, ds:_gBundle
		push	eax
		call	_ures_getStringByKey_56
		add	esp, 10h
		mov	[ebp+var_C], eax
		cmp	[ebp+var_24], 0
		jle	short loc_16D
		or	eax, 0FFFFFFFFh
		jmp	loc_201
; ---------------------------------------------------------------------------

loc_16D:				; CODE XREF: _u_wmsg+6Fj
		lea	eax, [ebp+arg_8]
		mov	[ebp+var_30], eax
		lea	eax, [ebp+var_24]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+var_2044]
		push	edx
		lea	eax, [ebp+var_2038]
		push	eax
		mov	ecx, [ebp+var_18]
		push	ecx
		mov	edx, [ebp+var_C]
		push	edx
		call	_uloc_getDefault_56
		push	eax
		call	_u_vformatMessage_56
		add	esp, 1Ch
		mov	[ebp+var_2044],	eax
		mov	[ebp+var_30], 0
		cmp	[ebp+var_24], 0
		jle	short loc_1D6
		mov	[ebp+var_24], 0
		lea	eax, [ebp+var_24]
		push	eax		; int
		mov	ecx, [ebp+File]
		push	ecx		; File
		mov	edx, [ebp+var_18]
		push	edx		; int
		mov	eax, [ebp+var_C]
		push	eax		; int
		call	_uprint
		add	esp, 10h
		or	eax, 0FFFFFFFFh
		jmp	short loc_201
; ---------------------------------------------------------------------------

loc_1D6:				; CODE XREF: _u_wmsg+BCj
		lea	eax, [ebp+var_24]
		push	eax		; int
		mov	ecx, [ebp+File]
		push	ecx		; File
		mov	edx, [ebp+var_2044]
		push	edx		; int
		lea	eax, [ebp+var_2038]
		push	eax		; int
		call	_uprint
		add	esp, 10h
		cmp	[ebp+var_24], 0
		jle	short loc_1FF
		or	eax, 0FFFFFFFFh
		jmp	short loc_201
; ---------------------------------------------------------------------------

loc_1FF:				; CODE XREF: _u_wmsg+104j
		xor	eax, eax

loc_201:				; CODE XREF: _u_wmsg+49j _u_wmsg+74j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 2108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_u_wmsg		endp

; ---------------------------------------------------------------------------
$LN11		dd 3			; DATA XREF: _u_wmsg+111o
		dd offset $LN10
$LN10		dd 0FFFFFFE8h, 4	; DATA XREF: .text:00000234o
		dd offset $LN7		; "msgLen"
		dd 0FFFFFFDCh, 4
		dd offset $LN8		; "err"
		dd 0FFFFDFC8h, 2000h
		dd offset $LN9		; "result"
$LN9		db 'result',0           ; DATA XREF: .text:00000258o
$LN8		db 'err',0              ; DATA XREF: .text:0000024Co
$LN7		db 'msgLen',0           ; DATA XREF: .text:00000240o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 270h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprint(int, int, FILE *File, int)
_uprint		proc near		; CODE XREF: _u_wmsg+D5p _u_wmsg+F8p

var_188		= byte ptr -188h
var_C4		= dword	ptr -0C4h
var_B8		= dword	ptr -0B8h
var_AC		= dword	ptr -0ACh
var_A0		= dword	ptr -0A0h
Str		= byte ptr -94h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
File		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 188h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_188]
		mov	ecx, 62h ; 'b'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		cmp	[ebp+arg_0], 0
		jnz	short loc_2A3
		jmp	loc_38D
; ---------------------------------------------------------------------------

loc_2A3:				; CODE XREF: _uprint+2Cj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_A0], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_A0]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_AC], edx
		lea	eax, [ebp+Str]
		mov	[ebp+var_B8], eax
		mov	[ebp+var_C4], 80h ; '€'
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		call	_ucnv_open_56
		add	esp, 8
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0
		jle	short loc_2F2
		jmp	$finish$7475
; ---------------------------------------------------------------------------

loc_2F2:				; CODE XREF: _uprint+7Bj _uprint+10Bj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_C]
		push	eax
		push	1
		push	0
		mov	ecx, [ebp+var_AC]
		push	ecx
		lea	edx, [ebp+var_A0]
		push	edx
		mov	eax, [ebp+var_B8]
		add	eax, [ebp+var_C4]
		push	eax
		lea	ecx, [ebp+var_B8]
		push	ecx
		mov	edx, [ebp+var_C]
		push	edx
		call	_ucnv_fromUnicode_56
		add	esp, 20h
		mov	esi, esp
		mov	eax, [ebp+File]
		push	eax		; File
		mov	ecx, [ebp+var_B8]
		lea	edx, [ebp+Str]
		sub	ecx, edx
		push	ecx		; Count
		push	1		; Size
		lea	eax, [ebp+Str]
		push	eax		; Str
		call	dword ptr ds:__imp__fwrite
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	eax, [ebp+Str]
		mov	[ebp+var_B8], eax
		mov	[ebp+var_C4], 80h ; '€'
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0Fh
		jz	loc_2F2

$finish$7475:				; CODE XREF: _uprint+7Dj
		mov	eax, [ebp+var_C]
		push	eax
		call	_ucnv_close_56
		add	esp, 4

loc_38D:				; CODE XREF: _uprint+2Ej
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 188h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprint		endp

; ---------------------------------------------------------------------------
$LN12		dd 3			; DATA XREF: _uprint+121o
		dd offset $LN11_0
$LN11_0		dd 0FFFFFF6Ch, 80h	; DATA XREF: .text:000003C0o
		dd offset $LN8_0	; "buf"
		dd 0FFFFFF60h, 4
		dd offset $LN9_0	; "mySource"
		dd 0FFFFFF48h, 4
		dd offset $LN10_0	; "myTarget"
$LN10_0		db 'myTarget',0         ; DATA XREF: .text:000003E4o
$LN9_0		db 'mySource',0         ; DATA XREF: .text:000003D8o
$LN8_0		db 'buf',0              ; DATA XREF: .text:000003CCo
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 400h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _u_wmsg_errorName
_u_wmsg_errorName proc near

var_188		= byte ptr -188h
Dest		= byte ptr -0C4h
var_3C		= dword	ptr -3Ch
Str		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= byte ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 188h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_188]
		mov	ecx, 62h ; 'b'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_24], 0
		mov	[ebp+Str], 0
		mov	eax, [ebp+arg_0]
		push	eax
		call	_fetchErrorName
		add	esp, 4
		mov	[ebp+var_C], eax
		cmp	[ebp+var_C], 0
		jz	short loc_453
		mov	eax, [ebp+var_C]
		jmp	loc_561
; ---------------------------------------------------------------------------

loc_453:				; CODE XREF: _u_wmsg_errorName+49j
		cmp	ds:_gBundle, 0
		jnz	short loc_465
		mov	[ebp+var_C], 0
		jmp	short loc_4A4
; ---------------------------------------------------------------------------

loc_465:				; CODE XREF: _u_wmsg_errorName+5Aj
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	[ebp+var_3C], eax
		cmp	[ebp+var_3C], 0
		jz	short loc_4A4
		lea	eax, [ebp+var_24]
		push	eax
		lea	ecx, [ebp+var_18]
		push	ecx
		mov	edx, [ebp+var_3C]
		push	edx
		mov	eax, ds:_gBundle
		push	eax
		call	_ures_getStringByKey_56
		add	esp, 10h
		mov	[ebp+var_C], eax
		cmp	[ebp+var_24], 0
		jle	short loc_4A4
		mov	[ebp+var_C], 0

loc_4A4:				; CODE XREF: _u_wmsg_errorName+63j
					; _u_wmsg_errorName+78j ...
		cmp	[ebp+var_C], 0
		jnz	loc_534
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	[ebp+Str], eax
		cmp	[ebp+Str], 0
		jnz	short loc_4EE
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		push	offset ??_C@_0BK@GOFKINGK@UNDOCUMENTED?5ICU?5ERROR?5?$CFd?$AA@ ; "UNDOCUMENTED ICU ERROR %d"
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	dword ptr ds:__imp__sprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	eax, [ebp+Dest]
		mov	[ebp+Str], eax

loc_4EE:				; CODE XREF: _u_wmsg_errorName+C1j
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		lea	ecx, [eax+eax+2]
		mov	esi, esp
		push	ecx		; Size
		call	dword ptr ds:__imp__malloc
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_C], eax
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		add	eax, 1
		push	eax
		mov	ecx, [ebp+var_C]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		call	_u_charsToUChars_56
		add	esp, 0Ch

loc_534:				; CODE XREF: _u_wmsg_errorName+A8j
		cmp	[ebp+arg_0], 0
		jl	short loc_54B
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:_gErrMessages
		mov	edx, [ebp+var_C]
		mov	[ecx+eax*4], edx
		jmp	short loc_55E
; ---------------------------------------------------------------------------

loc_54B:				; CODE XREF: _u_wmsg_errorName+138j
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:_gInfoMessages
		mov	edx, [ebp+var_C]
		mov	[ecx+eax*4+200h], edx

loc_55E:				; CODE XREF: _u_wmsg_errorName+149j
		mov	eax, [ebp+var_C]

loc_561:				; CODE XREF: _u_wmsg_errorName+4Ej
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN16
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 188h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_u_wmsg_errorName endp

; ---------------------------------------------------------------------------
$LN16		dd 3			; DATA XREF: _u_wmsg_errorName+165o
		dd offset $LN15
$LN15		dd 0FFFFFFE8h, 4	; DATA XREF: .text:00000594o
		dd offset $LN12_0	; "msgLen"
		dd 0FFFFFFDCh, 4
		dd offset $LN13		; "subErr"
		dd 0FFFFFF3Ch, 80h
		dd offset $LN14		; "error"
$LN14		db 'error',0            ; DATA XREF: .text:000005B8o
$LN13		db 'subErr',0           ; DATA XREF: .text:000005ACo
$LN12_0		db 'msgLen',0           ; DATA XREF: .text:000005A0o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5D0h
		public ??_C@_0BK@GOFKINGK@UNDOCUMENTED?5ICU?5ERROR?5?$CFd?$AA@
; char `string'[]
??_C@_0BK@GOFKINGK@UNDOCUMENTED?5ICU?5ERROR?5?$CFd?$AA@	db 'UNDOCUMENTED ICU ERROR %d',0
					; DATA XREF: _u_wmsg_errorName+C9o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_fetchErrorName	proc near		; CODE XREF: _u_wmsg_errorName+3Ap

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	ds:_gInfoMessages, 0
		jnz	short loc_63E
		mov	esi, esp
		push	24h ; '$'       ; Size
		call	dword ptr ds:__imp__malloc
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ds:_gInfoMessages, eax
		push	24h ; '$'       ; Size
		push	0		; Val
		mov	eax, ds:_gInfoMessages
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch

loc_63E:				; CODE XREF: _fetchErrorName+25j
		cmp	ds:_gErrMessages, 0
		jnz	short loc_678
		mov	esi, esp
		push	41408h		; Size
		call	dword ptr ds:__imp__malloc
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ds:_gErrMessages, eax
		push	41408h		; Size
		push	0		; Val
		mov	eax, ds:_gErrMessages
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch

loc_678:				; CODE XREF: _fetchErrorName+59j
		cmp	[ebp+arg_0], 0
		jl	short loc_68E
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:_gErrMessages
		mov	eax, [ecx+eax*4]
		jmp	short loc_69E
; ---------------------------------------------------------------------------
		jmp	short loc_69E
; ---------------------------------------------------------------------------

loc_68E:				; CODE XREF: _fetchErrorName+90j
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:_gInfoMessages
		mov	eax, [ecx+eax*4+200h]

loc_69E:				; CODE XREF: _fetchErrorName+9Ej
					; _fetchErrorName+A0j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_fetchErrorName	endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _ures_open_56:near ; CODE	XREF: _u_wmsg_setPath+53p
		extrn __RTC_CheckEsp:near ; CODE XREF: _u_wmsg_setPath+82p
					; _u_wmsg+133p	...
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn _u_vformatMessage_56:near	; CODE XREF: _u_wmsg+A3p
		extrn _uloc_getDefault_56:near ; CODE XREF: _u_wmsg+9Dp
		extrn _ures_getStringByKey_56:near ; CODE XREF:	_u_wmsg+60p
					; _u_wmsg_errorName+8Cp
		extrn ___security_cookie:near ;	DATA XREF: _u_wmsg+22r
					; _uprint+1Er ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _u_wmsg+126p
					; _uprint+136p	...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near ; CODE XREF: _u_wmsg+117p
					; _uprint+127p	...
		extrn __chkstk:near	; CODE XREF: _u_wmsg+8p
		extrn _ucnv_close_56:near ; CODE XREF: _uprint+115p
; size_t __cdecl _fwrite(const void *Str, size_t Size, size_t Count, FILE *File)
		extrn __imp__fwrite:near ; CODE	XREF: _uprint+DFp
					; DATA XREF: _uprint+DFr
		extrn _ucnv_fromUnicode_56:near	; CODE XREF: _uprint+B9p
		extrn _ucnv_open_56:near ; CODE	XREF: _uprint+6Ap
		extrn _u_charsToUChars_56:near ; CODE XREF: _u_wmsg_errorName+12Cp
; void *__cdecl	_malloc(size_t Size)
		extrn __imp__malloc:near ; CODE	XREF: _u_wmsg_errorName+101p
					; _fetchErrorName+2Bp ...
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: _u_wmsg_errorName+F2p
					; _u_wmsg_errorName+118p
; int _sprintf(char *Dest, const char *Format, ...)
		extrn __imp__sprintf:near ; CODE XREF: _u_wmsg_errorName+D5p
					; DATA XREF: _u_wmsg_errorName+D5r
		extrn _u_errorName_56:near ; CODE XREF:	_u_wmsg_errorName+69p
					; _u_wmsg_errorName+B2p
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _fetchErrorName+4Ap
					; _fetchErrorName+84p


		end
