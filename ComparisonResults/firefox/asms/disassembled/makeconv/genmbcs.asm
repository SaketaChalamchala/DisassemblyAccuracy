;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	8D8D7CC088A8A432870712865019C83D
; Input	CRC32 :	C00AC8DE

; File Name   :	D:\compspace\objfiles\firefox\makeconv\genmbcs.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_FB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_400
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_800
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset dword_1000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset dword_2000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset dword_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset dword_4000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset dword_8000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset dword_E00
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset dword_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _MBCSGetDummy
_MBCSGetDummy	proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp

loc_FB:					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	offset dword_6F72C ; Size
		push	0		; Val
		push	offset _gDummy	; Dst
		call	_memset
		add	esp, 0Ch
		mov	ds:byte_6F89E, 1
		movsx	eax, byte ptr ds:_SMALL
		test	eax, eax
		jz	short loc_150
		mov	eax, 0FFFFh
		mov	ds:word_6F89C, ax
		mov	ds:byte_6F89F, 1
		jmp	short loc_15B
; ---------------------------------------------------------------------------

loc_150:				; CODE XREF: _MBCSGetDummy+42j
		mov	eax, 0D7FFh
		mov	ds:word_6F89C, ax

loc_15B:				; CODE XREF: _MBCSGetDummy+56j
		mov	eax, offset _gDummy
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_MBCSGetDummy	endp

_text		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 174h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_gDummy		dd 13h dup(?)		; DATA XREF: _MBCSGetDummy+25o
					; _MBCSGetDummy:loc_15Bo
dword_1C0	dd 10h dup(?)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
dword_200	dd 80h dup(?)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
dword_400	dd 100h	dup(?)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
dword_800	dd 180h	dup(?)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
dword_E00	dd 80h dup(?)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
dword_1000	dd 400h	dup(?)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
dword_2000	dd 400h	dup(?)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
dword_3000	dd 400h	dup(?)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
dword_4000	dd 1000h dup(?)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
dword_8000	dd 2000h dup(?)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo
dword_10000	dd 5 dup(?)		; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+2E5o
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+3B2o ...
dword_10014	dd ?			; DATA XREF: setFallback(MBCSData *,uint,int)+25r
					; setFallback(MBCSData *,uint,int)+5Ar	...
dword_10018	dd ?			; DATA XREF: MBCSDestruct(MBCSData *)+21r
					; MBCSStartMappings(MBCSData *)+72w ...
word_1001C	dw ?			; DATA XREF: MBCSStartMappings(MBCSData	*)+1C8w
					; MBCSStartMappings(MBCSData *)+21Cr ...
		align 10h
		dd 21Eh	dup(?)
		db 2 dup(?)
word_1089A	dw ?			; DATA XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+C6r
word_1089C	dw ?			; DATA XREF: MBCSStartMappings(MBCSData	*)+22Dw
					; MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+19Ar ...
		align 10h
		dd 3DD8h dup(?)
dword_20000	dd 102h	dup(?)		; DATA XREF: MBCSStartMappings(MBCSData	*)+FFo
					; MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+2D2o
dword_20408	dd ?			; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+40r
					; MBCSPostprocess(MBCSData *,UConverterStaticData const	*)+2Dr	...
		align 10h
dword_20410	dd ?			; DATA XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+7Ar
					; MBCSStartMappings(MBCSData *)+F0r ...
dword_20414	dd ?			; DATA XREF: MBCSStartMappings(MBCSData	*)+24r
					; MBCSWrite(NewConverter *,UConverterStaticData	const *,UNewDataMemory *,int)+3AAr ...
		db ?
byte_20419	db ?			; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+86r
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+3Dr	...
		align 4
		dd 3EFFh dup(?)
dword_30018	dd ?			; DATA XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+1BAr
dword_3001C	dd ?			; DATA XREF: MBCSStartMappings(MBCSData	*)+287w
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+2FEr ...
		dd 0FBBFh dup(?)
dword_6EF1C	dd ?			; DATA XREF: MBCSDestruct(MBCSData *)+33r
					; MBCSStartMappings(MBCSData *)+120w ...
dword_6EF20	dd ?			; DATA XREF: MBCSStartMappings(MBCSData	*)+1E4w
					; MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+98r ...
dword_6EF24	dd ?			; DATA XREF: MBCSStartMappings(MBCSData	*)+2ECw
					; MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+1ADr ...
word_6EF28	dw ?			; DATA XREF: MBCSStartMappings(MBCSData	*)+2CCw
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+4EFw ...
		align 4
		dd 1FFh	dup(?)
word_6F728	dw ?			; DATA XREF: _MBCSOkForBaseFromUnicode+77r
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+AFw ...
byte_6F72A	db ?			; DATA XREF: _MBCSOkForBaseFromUnicode+60r
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+99w ...
byte_6F72B	db ?			; DATA XREF: _MBCSOkForBaseFromUnicode+9Dr
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+CAw ...
dword_6F72C	dd 5Ch dup(?)		; DATA XREF: _MBCSGetDummy+1Eo
					; _MBCSOpen+1Eo ...
word_6F89C	dw ?			; DATA XREF: _MBCSGetDummy+49w
					; _MBCSGetDummy+5Dw
byte_6F89E	db ?			; DATA XREF: _MBCSGetDummy+32w
byte_6F89F	db ?			; DATA XREF: _MBCSGetDummy+4Fw
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 6F8A0h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 6F8A4h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F8A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _MBCSOpen
_MBCSOpen	proc near

var_CC		= byte ptr -0CCh
Dst		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	offset dword_6F72C
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_6F904
		mov	esi, esp
		push	offset ??_C@_0P@PCJPAHLM@out?5of?5memory?6?$AA@	; "out of memory\n"
		call	dword ptr ds:__imp__printf
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	7		; Code
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6F904:				; CODE XREF: _MBCSOpen+32j
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+Dst]
		push	ecx		; Dst
		call	?MBCSInit@@YAXPAUMBCSData@@PAUUCMFile@@@Z ; MBCSInit(MBCSData *,UCMFile	*)
		add	esp, 8
		mov	eax, [ebp+Dst]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_MBCSOpen	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6F92Ch
		public ??_C@_0P@PCJPAHLM@out?5of?5memory?6?$AA@
; char `string'[]
??_C@_0P@PCJPAHLM@out?5of?5memory?6?$AA@ db 'out of memory',0Ah,0 ; DATA XREF: _MBCSOpen+36o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F93Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl MBCSInit(void *Dst, int)
?MBCSInit@@YAXPAUMBCSData@@PAUUCMFile@@@Z proc near ; CODE XREF: _MBCSOpen+64p

var_C0		= byte ptr -0C0h
Dst		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	offset dword_6F72C ; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+arg_4]
		mov	[eax+10h], ecx
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax], offset	?MBCSClose@@YAXPAUNewConverter@@@Z ; MBCSClose(NewConverter *)
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+4], offset ?MBCSIsValid@@YACPAUNewConverter@@PBEH@Z ; MBCSIsValid(NewConverter *,uchar const *,int)
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+8], offset ?MBCSAddTable@@YACPAUNewConverter@@PAUUCMTable@@PAUUConverterStaticData@@@Z ;	MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+0Ch], offset ?MBCSWrite@@YAIPAUNewConverter@@PBUUConverterStaticData@@PAUUNewDataMemory@@H@Z ; MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCSInit@@YAXPAUMBCSData@@PAUUCMFile@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F9B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl MBCSClose(struct	NewConverter *)
?MBCSClose@@YAXPAUNewConverter@@@Z proc	near ; DATA XREF: MBCSInit(MBCSData *,UCMFile *)+3Do

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_6F9F6
		mov	eax, [ebp+var_8]
		push	eax
		call	?MBCSDestruct@@YAXPAUMBCSData@@@Z ; MBCSDestruct(MBCSData *)
		add	esp, 4
		mov	eax, [ebp+var_8]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_6F9F6:				; CODE XREF: MBCSClose(NewConverter *)+28j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCSClose@@YAXPAUNewConverter@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6FA0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl MBCSDestruct(struct MBCSData *)
?MBCSDestruct@@YAXPAUMBCSData@@@Z proc near ; CODE XREF: MBCSClose(NewConverter	*)+2Ep

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF1C[eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCSDestruct@@YAXPAUMBCSData@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6FA64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl MBCSIsValid(struct NewConverter *, unsigned char const *,	int)
?MBCSIsValid@@YACPAUNewConverter@@PBEH@Z proc near
					; DATA XREF: MBCSInit(MBCSData *,UCMFile *)+46o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		add	eax, 8
		push	eax
		call	_ucm_countChars
		add	esp, 0Ch
		cmp	eax, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCSIsValid@@YACPAUNewConverter@@PBEH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6FABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _MBCSOkForBaseFromUnicode
_MBCSOkForBaseFromUnicode proc near	; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+290p
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+348p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movsx	eax, [ebp+arg_10]
		cmp	eax, 2
		jnz	short loc_6FAE9
		cmp	[ebp+arg_8], 1
		jz	short loc_6FB15

loc_6FAE9:				; CODE XREF: _MBCSOkForBaseFromUnicode+25j
		movsx	eax, [ebp+arg_10]
		cmp	eax, 1
		jnz	short loc_6FAFC
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_6FB15

loc_6FAFC:				; CODE XREF: _MBCSOkForBaseFromUnicode+34j
		movsx	eax, [ebp+arg_10]
		cmp	eax, 1
		jg	short loc_6FB19
		cmp	[ebp+arg_8], 1
		jle	short loc_6FB19
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_6FB19

loc_6FB15:				; CODE XREF: _MBCSOkForBaseFromUnicode+2Bj
					; _MBCSOkForBaseFromUnicode+3Ej
		xor	al, al
		jmp	short loc_6FB72
; ---------------------------------------------------------------------------

loc_6FB19:				; CODE XREF: _MBCSOkForBaseFromUnicode+47j
					; _MBCSOkForBaseFromUnicode+4Dj ...
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	short loc_6FB56
		movsx	eax, [ebp+arg_10]
		cmp	eax, 1
		jg	short loc_6FB56
		mov	eax, [ebp+arg_0]
		movzx	ecx, ds:word_6F728[eax]
		cmp	[ebp+arg_C], ecx
		jg	short loc_6FB56
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_6FB52
		movsx	eax, [ebp+arg_10]
		cmp	eax, 1
		jnz	short loc_6FB56

loc_6FB52:				; CODE XREF: _MBCSOkForBaseFromUnicode+8Bj
		xor	al, al
		jmp	short loc_6FB72
; ---------------------------------------------------------------------------

loc_6FB56:				; CODE XREF: _MBCSOkForBaseFromUnicode+69j
					; _MBCSOkForBaseFromUnicode+72j ...
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72B[eax]
		test	ecx, ecx
		jz	short loc_6FB70
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jz	short loc_6FB70
		xor	al, al
		jmp	short loc_6FB72
; ---------------------------------------------------------------------------

loc_6FB70:				; CODE XREF: _MBCSOkForBaseFromUnicode+A6j
					; _MBCSOkForBaseFromUnicode+AEj
		mov	al, 1

loc_6FB72:				; CODE XREF: _MBCSOkForBaseFromUnicode+5Bj
					; _MBCSOkForBaseFromUnicode+98j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_MBCSOkForBaseFromUnicode endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6FB7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl MBCSAddTable(struct NewConverter *, struct UCMTable *, struct UConverterStaticData *)
?MBCSAddTable@@YACPAUNewConverter@@PAUUCMTable@@PAUUConverterStaticData@@@Z proc near
					; DATA XREF: MBCSInit(MBCSData *,UCMFile *)+50o

var_124		= dword	ptr -124h
var_59		= byte ptr -59h
var_4D		= byte ptr -4Dh
var_41		= byte ptr -41h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_124]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+arg_4]
		mov	dl, [ecx+28h]
		mov	[eax+4Fh], dl
		mov	eax, [ebp+arg_8]
		movzx	ecx, byte ptr [eax+4Fh]
		cmp	ecx, 3
		jnz	short loc_6FBE3
		mov	esi, esp
		push	offset ??_C@_0EL@GIDGGLCP@error?3?5contains?5mappings?5for?5bot@ ; "error: contains mappings for both suppl"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_6FFF3
; ---------------------------------------------------------------------------

loc_6FBE3:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+34j
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax+45h], 2
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, ds:dword_20410[ecx]
		mov	[ebp+var_38], edx
		mov	eax, [ebp+arg_4]
		movsx	ecx, byte ptr [eax+29h]
		and	ecx, 1
		setnz	dl
		mov	[ebp+var_59], dl
		mov	eax, [ebp+var_8]
		mov	cl, [ebp+var_59]
		mov	ds:byte_6F72A[eax], cl
		movsx	eax, [ebp+var_59]
		test	eax, eax
		jz	short loc_6FC4F
		mov	eax, 0D7FFh
		mov	ecx, [ebp+var_8]
		mov	ds:word_6F728[ecx], ax
		movsx	eax, byte ptr ds:_SMALL
		test	eax, eax
		jz	short loc_6FC4D
		cmp	[ebp+var_38], 1
		jle	short loc_6FC4D
		mov	eax, [ebp+var_8]
		mov	ds:byte_6F72B[eax], 1

loc_6FC4D:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+BFj
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+C5j
		jmp	short loc_6FC96
; ---------------------------------------------------------------------------

loc_6FC4F:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+A5j
		xor	eax, eax
		mov	ecx, [ebp+var_8]
		mov	ds:word_6F728[ecx], ax
		movsx	eax, byte ptr ds:_SMALL
		test	eax, eax
		jz	short loc_6FC96
		cmp	[ebp+var_38], 1
		jle	short loc_6FC96
		mov	esi, esp
		push	offset ??_C@_0EI@NGLGFNMN@makeconv?5warning?3?5?9?9small?5not?5av@ ; "makeconv warning:	--small	not available"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6FC96:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *):loc_6FC4Dj
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+E8j ...
		mov	eax, [ebp+var_8]
		push	eax
		call	?MBCSStartMappings@@YACPAUMBCSData@@@Z ; MBCSStartMappings(MBCSData *)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_6FCB0
		xor	al, al
		jmp	loc_6FFF3
; ---------------------------------------------------------------------------

loc_6FCB0:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+12Bj
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax+4Eh], 0
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax+4Dh], 0
		mov	[ebp+var_4D], 1
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	[ebp+var_2C], 0
		jmp	short loc_6FCE5
; ---------------------------------------------------------------------------

loc_6FCD3:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *):loc_6FFDBj
		mov	eax, [ebp+var_14]
		add	eax, 0Ch
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+var_2C]
		add	ecx, 1
		mov	[ebp+var_2C], ecx

loc_6FCE5:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+155j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+8]
		jge	loc_6FFE0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_14]
		mov	cl, [eax+0Ah]
		mov	[ebp+var_41], cl
		mov	eax, [ebp+var_8]
		movsx	ecx, ds:byte_6F72B[eax]
		test	ecx, ecx
		jz	short loc_6FD55
		movsx	eax, [ebp+var_41]
		cmp	eax, 1
		jg	short loc_6FD55
		mov	eax, [ebp+var_8]
		movzx	ecx, ds:word_6F728[eax]
		cmp	ecx, [ebp+var_20]
		jge	short loc_6FD55
		cmp	[ebp+var_20], 0FFFFh
		jg	short loc_6FD55
		mov	eax, [ebp+var_8]
		movzx	ecx, ds:word_6F728[eax]
		cmp	ecx, 0FEFFh
		jge	short loc_6FD55
		mov	eax, 0FFFFh
		mov	ecx, [ebp+var_8]
		mov	ds:word_6F728[ecx], ax

loc_6FD55:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+195j
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+19Ej ...
		movsx	eax, [ebp+var_41]
		mov	[ebp+var_124], eax
		mov	ecx, [ebp+var_124]
		add	ecx, 1
		mov	[ebp+var_124], ecx
		cmp	[ebp+var_124], 5 ; switch 6 cases
		ja	loc_6FFA8	; jumptable 0006FD81 default case
		mov	edx, [ebp+var_124]
		jmp	ds:$LN30[edx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN15:					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+205j
					; DATA XREF: .text:$LN30o
		movzx	eax, [ebp+var_41] ; jumptable 0006FD81 cases 0,1
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [edx+9]
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	?MBCSAddToUnicode@@YACPAUMBCSData@@PBEHHC@Z ; MBCSAddToUnicode(MBCSData	*,uchar	const *,int,int,signed char)
		add	esp, 14h
		movsx	eax, al
		movsx	ecx, [ebp+var_4D]
		and	ecx, eax
		mov	[ebp+var_4D], cl
		cmp	[ebp+var_38], 1
		jnz	short loc_6FDF0
		movzx	eax, [ebp+var_41]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [edx+9]
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	?MBCSSingleAddFromUnicode@@YACPAUMBCSData@@PBEHHC@Z ; MBCSSingleAddFromUnicode(MBCSData	*,uchar	const *,int,int,signed char)
		add	esp, 14h
		movsx	eax, al
		movsx	ecx, [ebp+var_4D]
		and	ecx, eax
		mov	[ebp+var_4D], cl
		jmp	short loc_6FE64
; ---------------------------------------------------------------------------

loc_6FDF0:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+240j
		movzx	eax, [ebp+var_41]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [edx+9]
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	_MBCSOkForBaseFromUnicode
		add	esp, 14h
		movsx	eax, al
		test	eax, eax
		jz	short loc_6FE4D
		movzx	eax, [ebp+var_41]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [edx+9]
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	?MBCSAddFromUnicode@@YACPAUMBCSData@@PBEHHC@Z ;	MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)
		add	esp, 14h
		movsx	eax, al
		movsx	ecx, [ebp+var_4D]
		and	ecx, eax
		mov	[ebp+var_4D], cl
		jmp	short loc_6FE64
; ---------------------------------------------------------------------------

loc_6FE4D:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+29Dj
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+0Ah]
		or	ecx, 10h
		mov	edx, [ebp+var_14]
		mov	[edx+0Ah], cl
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+0Bh], 1

loc_6FE64:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+272j
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+2CFj
		jmp	loc_6FFDB
; ---------------------------------------------------------------------------

$LN10:					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+205j
					; DATA XREF: .text:$LN30o
		cmp	[ebp+var_38], 1	; jumptable 0006FD81 case 2
		jnz	short loc_6FEA8
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax+4Eh], 1
		movzx	eax, [ebp+var_41]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [edx+9]
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	?MBCSSingleAddFromUnicode@@YACPAUMBCSData@@PBEHHC@Z ; MBCSSingleAddFromUnicode(MBCSData	*,uchar	const *,int,int,signed char)
		add	esp, 14h
		movsx	eax, al
		movsx	ecx, [ebp+var_4D]
		and	ecx, eax
		mov	[ebp+var_4D], cl
		jmp	short loc_6FF23
; ---------------------------------------------------------------------------

loc_6FEA8:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+2F1j
		movzx	eax, [ebp+var_41]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [edx+9]
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	_MBCSOkForBaseFromUnicode
		add	esp, 14h
		movsx	eax, al
		test	eax, eax
		jz	short loc_6FF0C
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax+4Eh], 1
		movzx	eax, [ebp+var_41]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [edx+9]
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	?MBCSAddFromUnicode@@YACPAUMBCSData@@PBEHHC@Z ;	MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)
		add	esp, 14h
		movsx	eax, al
		movsx	ecx, [ebp+var_4D]
		and	ecx, eax
		mov	[ebp+var_4D], cl
		jmp	short loc_6FF23
; ---------------------------------------------------------------------------

loc_6FF0C:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+355j
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+0Ah]
		or	ecx, 10h
		mov	edx, [ebp+var_14]
		mov	[edx+0Ah], cl
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+0Bh], 1

loc_6FF23:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+32Aj
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+38Ej
		jmp	loc_6FFDB
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+205j
					; DATA XREF: .text:$LN30o
		cmp	[ebp+var_38], 1	; jumptable 0006FD81 case 3
		jle	short loc_6FF51
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+9]
		cmp	ecx, 1
		jnz	short loc_6FF51
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+0Ah]
		or	ecx, 10h
		mov	edx, [ebp+var_14]
		mov	[edx+0Ah], cl
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+0Bh], 1

loc_6FF51:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+3B0j
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+3BCj
		jmp	loc_6FFDB
; ---------------------------------------------------------------------------

$LN3:					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+205j
					; DATA XREF: .text:$LN30o
		mov	eax, [ebp+arg_8] ; jumptable 0006FD81 case 4
		mov	byte ptr [eax+4Dh], 1
		movzx	eax, [ebp+var_41]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [edx+9]
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	?MBCSAddToUnicode@@YACPAUMBCSData@@PBEHHC@Z ; MBCSAddToUnicode(MBCSData	*,uchar	const *,int,int,signed char)
		add	esp, 14h
		movsx	eax, al
		movsx	ecx, [ebp+var_4D]
		and	ecx, eax
		mov	[ebp+var_4D], cl
		jmp	short loc_6FFDB
; ---------------------------------------------------------------------------

$LN2:					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+205j
					; DATA XREF: .text:$LN30o
		mov	eax, [ebp+var_14] ; jumptable 0006FD81 case 5
		movsx	ecx, byte ptr [eax+0Ah]
		or	ecx, 10h
		mov	edx, [ebp+var_14]
		mov	[edx+0Ah], cl
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+0Bh], 1
		jmp	short loc_6FFDB
; ---------------------------------------------------------------------------

loc_6FFA8:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+1F9j
		movsx	eax, [ebp+var_41] ; jumptable 0006FD81 default case
		mov	esi, esp
		push	eax
		push	offset ??_C@_0CG@LMBBJPIA@error?3?5illegal?5fallback?5indicato@	; "error: illegal fallback indicator %d\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	short loc_6FFF3
; ---------------------------------------------------------------------------

loc_6FFDB:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *):loc_6FE64j
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *):loc_6FF23j ...
		jmp	loc_6FCD3
; ---------------------------------------------------------------------------

loc_6FFE0:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+172j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?MBCSPostprocess@@YAXPAUMBCSData@@PBUUConverterStaticData@@@Z ;	MBCSPostprocess(MBCSData *,UConverterStaticData	const *)
		add	esp, 8
		mov	al, [ebp+var_4D]

loc_6FFF3:				; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+62j
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+12Fj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCSAddTable@@YACPAUNewConverter@@PAUUCMTable@@PAUUConverterStaticData@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN30		dd offset $LN15		; DATA XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+205r
		dd offset $LN15		; jump table for switch	statement
		dd offset $LN10
		dd offset $LN5
		dd offset $LN3
		dd offset $LN2
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70020h
		public ??_C@_0CG@LMBBJPIA@error?3?5illegal?5fallback?5indicato@
; char `string'[]
??_C@_0CG@LMBBJPIA@error?3?5illegal?5fallback?5indicato@ db 'error: illegal fallback indicator %d',0Ah,0
					; DATA XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+433o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 70048h
		public ??_C@_0EI@NGLGFNMN@makeconv?5warning?3?5?9?9small?5not?5av@
; char `string'[]
??_C@_0EI@NGLGFNMN@makeconv?5warning?3?5?9?9small?5not?5av@ db 'makeconv warning: --small not available for .ucm files without |0'
					; DATA XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+F2o
		db ' etc.',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 70090h
		public ??_C@_0EL@GIDGGLCP@error?3?5contains?5mappings?5for?5bot@
; char `string'[]
??_C@_0EL@GIDGGLCP@error?3?5contains?5mappings?5for?5bot@ db 'error: contains mappings for both supplementary and surrogate cod'
					; DATA XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+38o
		db 'e points',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 700DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl MBCSStartMappings(struct MBCSData	*)
?MBCSStartMappings@@YACPAUMBCSData@@@Z proc near
					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+11Ep

var_114		= byte ptr -114h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
Size		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, ds:dword_20414[ecx]
		mov	[ebp+Size], edx
		movsx	eax, byte ptr ds:_VERBOSE
		test	eax, eax
		jz	short loc_70133
		mov	esi, esp
		mov	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+Size]
		push	ecx
		push	offset ??_C@_0CK@HMAMFBNL@the?5total?5number?5of?5offsets?5is?50@ ; "the total number of offsets is 0x%lx=%l"...
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_70133:				; CODE XREF: MBCSStartMappings(MBCSData	*)+36j
		cmp	[ebp+Size], 0
		jle	loc_701C6
		mov	eax, [ebp+Size]
		shl	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+arg_0]
		mov	ds:dword_10018[ecx], eax
		mov	eax, [ebp+arg_0]
		cmp	ds:dword_10018[eax], 0
		jnz	short loc_70195
		mov	esi, esp
		mov	eax, [ebp+Size]
		push	eax
		push	offset ??_C@_0DH@HHELGJEO@error?3?5out?5of?5memory?5allocating?5@ ; "error: out	of memory allocating %ld 16-"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_703D0
; ---------------------------------------------------------------------------

loc_70195:				; CODE XREF: MBCSStartMappings(MBCSData	*)+82j
		mov	[ebp+var_8], 0
		jmp	short loc_701A7
; ---------------------------------------------------------------------------

loc_7019E:				; CODE XREF: MBCSStartMappings(MBCSData	*)+E8j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_701A7:				; CODE XREF: MBCSStartMappings(MBCSData	*)+C0j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+Size]
		jge	short loc_701C6
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		mov	edx, 0FFFEh
		mov	eax, [ebp+var_8]
		mov	[ecx+eax*2], dx
		jmp	short loc_7019E
; ---------------------------------------------------------------------------

loc_701C6:				; CODE XREF: MBCSStartMappings(MBCSData	*)+5Bj
					; MBCSStartMappings(MBCSData *)+D1j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, ds:dword_20410[ecx]
		mov	[ebp+var_20], edx
		cmp	[ebp+var_20], 1
		jnz	short loc_701E4
		mov	[ebp+Size], offset dword_20000
		jmp	short loc_701ED
; ---------------------------------------------------------------------------

loc_701E4:				; CODE XREF: MBCSStartMappings(MBCSData	*)+FDj
		mov	eax, [ebp+var_20]
		shl	eax, 14h
		mov	[ebp+Size], eax

loc_701ED:				; CODE XREF: MBCSStartMappings(MBCSData	*)+106j
		mov	eax, [ebp+Size]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+arg_0]
		mov	ds:dword_6EF1C[ecx], eax
		mov	eax, [ebp+arg_0]
		cmp	ds:dword_6EF1C[eax], 0
		jnz	short loc_70243
		mov	esi, esp
		mov	eax, [ebp+Size]
		push	eax
		push	offset ??_C@_0DL@HLFAOCEM@error?3?5out?5of?5memory?5allocating?5@ ; "error: out	of memory allocating %ld B f"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_703D0
; ---------------------------------------------------------------------------

loc_70243:				; CODE XREF: MBCSStartMappings(MBCSData	*)+130j
		mov	eax, [ebp+Size]
		push	eax		; Size
		push	0		; Val
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_6EF1C[ecx]
		push	edx		; Dst
		call	_memset
		add	esp, 0Ch
		mov	[ebp+var_2C], 40h ; '@'
		mov	[ebp+var_38], 40h ; '@'
		mov	[ebp+var_44], 40h ; '@'
		mov	[ebp+var_50], 80h ; ''
		mov	eax, [ebp+var_2C]
		mov	[ebp+Size], eax
		mov	[ebp+var_8], 0
		jmp	short loc_7028F
; ---------------------------------------------------------------------------

loc_70286:				; CODE XREF: MBCSStartMappings(MBCSData	*)+1D9j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_7028F:				; CODE XREF: MBCSStartMappings(MBCSData	*)+1A8j
		mov	eax, [ebp+var_38]
		sar	eax, 6
		cmp	[ebp+var_8], eax
		jge	short loc_702B7
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dx, word ptr [ebp+Size]
		mov	ds:word_1001C[ecx+eax*2], dx
		mov	eax, [ebp+Size]
		add	eax, 40h ; '@'
		mov	[ebp+Size], eax
		jmp	short loc_70286
; ---------------------------------------------------------------------------

loc_702B7:				; CODE XREF: MBCSStartMappings(MBCSData	*)+1BCj
		mov	eax, [ebp+var_2C]
		add	eax, [ebp+var_38]
		mov	ecx, [ebp+arg_0]
		mov	ds:dword_6EF20[ecx], eax
		cmp	[ebp+var_20], 1
		jnz	short loc_7031E
		mov	eax, [ebp+var_44]
		mov	[ebp+Size], eax
		mov	[ebp+var_8], 0
		jmp	short loc_702E4
; ---------------------------------------------------------------------------

loc_702DB:				; CODE XREF: MBCSStartMappings(MBCSData	*)+23Ej
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_702E4:				; CODE XREF: MBCSStartMappings(MBCSData	*)+1FDj
		mov	eax, [ebp+var_50]
		cdq
		and	edx, 0Fh
		add	eax, edx
		sar	eax, 4
		cmp	[ebp+var_8], eax
		jge	short loc_7031C
		mov	eax, [ebp+arg_0]
		movzx	ecx, ds:word_1001C[eax]
		add	ecx, [ebp+var_8]
		mov	edx, [ebp+arg_0]
		mov	ax, word ptr [ebp+Size]
		mov	ds:word_1089C[edx+ecx*2], ax
		mov	eax, [ebp+Size]
		add	eax, 10h
		mov	[ebp+Size], eax
		jmp	short loc_702DB
; ---------------------------------------------------------------------------

loc_7031C:				; CODE XREF: MBCSStartMappings(MBCSData	*)+217j
		jmp	short loc_70375
; ---------------------------------------------------------------------------

loc_7031E:				; CODE XREF: MBCSStartMappings(MBCSData	*)+1EEj
		mov	eax, [ebp+var_44]
		cdq
		and	edx, 0Fh
		add	eax, edx
		sar	eax, 4
		mov	[ebp+Size], eax
		mov	[ebp+var_8], 0
		jmp	short loc_7033F
; ---------------------------------------------------------------------------

loc_70336:				; CODE XREF: MBCSStartMappings(MBCSData	*)+297j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_7033F:				; CODE XREF: MBCSStartMappings(MBCSData	*)+258j
		mov	eax, [ebp+var_50]
		cdq
		and	edx, 0Fh
		add	eax, edx
		sar	eax, 4
		cmp	[ebp+var_8], eax
		jge	short loc_70375
		mov	eax, [ebp+arg_0]
		movzx	ecx, ds:word_1001C[eax]
		add	ecx, [ebp+var_8]
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+Size]
		mov	ds:dword_3001C[edx+ecx*4], eax
		mov	eax, [ebp+Size]
		add	eax, 1
		mov	[ebp+Size], eax
		jmp	short loc_70336
; ---------------------------------------------------------------------------

loc_70375:				; CODE XREF: MBCSStartMappings(MBCSData	*):loc_7031Cj
					; MBCSStartMappings(MBCSData *)+272j
		mov	eax, [ebp+var_44]
		mov	[ebp+Size], eax
		mov	[ebp+var_8], 0
		jmp	short loc_7038D
; ---------------------------------------------------------------------------

loc_70384:				; CODE XREF: MBCSStartMappings(MBCSData	*)+2DDj
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_7038D:				; CODE XREF: MBCSStartMappings(MBCSData	*)+2A6j
		mov	eax, [ebp+var_50]
		cdq
		and	edx, 3Fh
		add	eax, edx
		sar	eax, 6
		cmp	[ebp+var_8], eax
		jge	short loc_703BB
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dx, word ptr [ebp+Size]
		mov	ds:word_6EF28[ecx+eax*2], dx
		mov	eax, [ebp+Size]
		add	eax, 40h ; '@'
		mov	[ebp+Size], eax
		jmp	short loc_70384
; ---------------------------------------------------------------------------

loc_703BB:				; CODE XREF: MBCSStartMappings(MBCSData	*)+2C0j
		mov	eax, [ebp+var_44]
		add	eax, [ebp+var_50]
		imul	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		mov	ds:dword_6EF24[ecx], eax
		mov	al, 1

loc_703D0:				; CODE XREF: MBCSStartMappings(MBCSData	*)+B4j
					; MBCSStartMappings(MBCSData *)+162j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCSStartMappings@@YACPAUMBCSData@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 703E4h
		public ??_C@_0DL@HLFAOCEM@error?3?5out?5of?5memory?5allocating?5@
; char `string'[]
??_C@_0DL@HLFAOCEM@error?3?5out?5of?5memory?5allocating?5@ db 'error: out of memory allocating %ld B for target mappings',0Ah,0
					; DATA XREF: MBCSStartMappings(MBCSData	*)+138o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70420h
		public ??_C@_0DH@HHELGJEO@error?3?5out?5of?5memory?5allocating?5@
; char `string'[]
??_C@_0DH@HHELGJEO@error?3?5out?5of?5memory?5allocating?5@ db 'error: out of memory allocating %ld 16-bit code units',0Ah,0
					; DATA XREF: MBCSStartMappings(MBCSData	*)+8Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70458h
		public ??_C@_0CK@HMAMFBNL@the?5total?5number?5of?5offsets?5is?50@
; char `string'[]
??_C@_0CK@HMAMFBNL@the?5total?5number?5of?5offsets?5is?50@ db 'the total number of offsets is 0x%lx=%ld',0Ah,0
					; DATA XREF: MBCSStartMappings(MBCSData	*)+42o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 70484h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl MBCSAddToUnicode(struct MBCSData *, unsigned char	const *, int, int, signed char)
?MBCSAddToUnicode@@YACPAUMBCSData@@PBEHHC@Z proc near
					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+228p
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+3FDp

var_124		= dword	ptr -124h
var_5C		= dword	ptr -5Ch
var_4D		= byte ptr -4Dh
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_124]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_20], 0
		mov	[ebp+var_2C], 0
		mov	[ebp+var_4D], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		cmp	ds:dword_20408[ecx], 0
		jnz	short loc_704FE
		mov	esi, esp
		push	offset ??_C@_0CH@IEHFNBLJ@error?3?5there?5is?5no?5state?5informa@ ; "error: there is no	state information!\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_70CF8
; ---------------------------------------------------------------------------

loc_704FE:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+47j
		cmp	[ebp+arg_8], 2
		jnz	short loc_7051A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movsx	edx, ds:byte_20419[ecx]
		cmp	edx, 0Ch
		jnz	short loc_7051A
		mov	[ebp+var_4D], 1

loc_7051A:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+7Ej
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+90j
		mov	[ebp+var_2C], 0

loc_70521:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char):loc_70CF3j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, [ebp+var_4D]
		shl	edx, 0Ah
		lea	eax, [ecx+edx+8]
		mov	ecx, [ebp+arg_4]
		add	ecx, [ebp+var_2C]
		movzx	edx, byte ptr [ecx]
		mov	eax, [eax+edx*4]
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_2C]
		add	ecx, 1
		mov	[ebp+var_2C], ecx
		cmp	[ebp+var_38], 0
		jl	short loc_705C3
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+arg_8]
		jnz	short loc_705A7
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		push	eax
		movzx	ecx, [ebp+var_4D]
		push	ecx
		push	offset ??_C@_0EK@IHMOJLEM@error?3?5byte?5sequence?5too?5short?0?5@ ; "error: byte sequence too short, ends in"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_70CF8
; ---------------------------------------------------------------------------

loc_705A7:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+D2j
		mov	eax, [ebp+var_38]
		shr	eax, 18h
		mov	[ebp+var_4D], al
		mov	eax, [ebp+var_38]
		and	eax, 0FFFFFFh
		add	eax, [ebp+var_20]
		mov	[ebp+var_20], eax
		jmp	loc_70CF3
; ---------------------------------------------------------------------------

loc_705C3:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+CAj
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+arg_8]
		jge	short loc_70621
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		push	eax
		movzx	ecx, [ebp+var_4D]
		push	ecx
		mov	edx, [ebp+arg_8]
		sub	edx, [ebp+var_2C]
		push	edx
		push	offset ??_C@_0EI@JPCHFLKG@error?3?5byte?5sequence?5too?5long?5by@ ; "error: byte sequence too long by %d byt"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_70CF8
; ---------------------------------------------------------------------------

loc_70621:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+145j
		mov	eax, [ebp+var_38]
		shr	eax, 14h
		and	eax, 0Fh
		mov	[ebp+var_124], eax
		cmp	[ebp+var_124], 8 ; switch 9 cases
		ja	loc_70CA4	; jumptable 00070643 default case
		mov	ecx, [ebp+var_124]
		jmp	ds:$LN60[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN44:					; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+1BFj
					; DATA XREF: .text:$LN60o
		mov	eax, [ebp+arg_8] ; jumptable 00070643 case 7
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		mov	esi, esp
		push	eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	offset ??_C@_0DN@INKFOFLD@error?3?5byte?5sequence?5ends?5in?5ill@ ; "error: byte sequence ends in illegal st"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_70CF8
; ---------------------------------------------------------------------------

$LN43:					; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+1BFj
					; DATA XREF: .text:$LN60o
		mov	eax, [ebp+arg_8] ; jumptable 00070643 case 8
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		mov	esi, esp
		push	eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	offset ??_C@_0EB@IHGDKPFP@error?3?5byte?5sequence?5ends?5in?5sta@ ; "error: byte sequence ends in state-chan"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_70CF8
; ---------------------------------------------------------------------------

$LN42:					; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+1BFj
					; DATA XREF: .text:$LN60o
		mov	eax, [ebp+arg_8] ; jumptable 00070643 case 6
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		mov	esi, esp
		push	eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	offset ??_C@_0EA@FOEEAGEJ@error?3?5byte?5sequence?5ends?5in?5una@ ; "error: byte sequence ends in unassigned"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_70CF8
; ---------------------------------------------------------------------------

$LN41:					; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+1BFj
					; DATA XREF: .text:$LN60o
		mov	eax, [ebp+var_38] ; jumptable 00070643 cases 0-3
		and	eax, 80FFFFFFh
		cmp	eax, 8000FFFEh
		jz	loc_7081B
		mov	eax, [ebp+var_38]
		shr	eax, 14h
		and	eax, 0Fh
		jz	short loc_70754
		mov	eax, [ebp+var_38]
		shr	eax, 14h
		and	eax, 0Fh
		cmp	eax, 2
		jnz	short loc_70761

loc_70754:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+2C0j
		mov	eax, [ebp+var_38]
		and	eax, 0FFFFFh
		mov	[ebp+var_44], eax
		jmp	short loc_70771
; ---------------------------------------------------------------------------

loc_70761:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+2CEj
		mov	eax, [ebp+var_38]
		and	eax, 0FFFFFh
		add	eax, offset dword_10000
		mov	[ebp+var_44], eax

loc_70771:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+2DBj
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jl	short loc_707C9
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	offset ??_C@_0EF@PGJNLKIL@error?3?5duplicate?5codepage?5byte?5s@ ; "error: duplicate codepage byte sequence"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_70CF8
; ---------------------------------------------------------------------------
		jmp	short loc_7081B
; ---------------------------------------------------------------------------

loc_707C9:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+2F3j
		movsx	eax, byte ptr ds:_VERBOSE
		test	eax, eax
		jz	short loc_7081B
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	offset ??_C@_0DO@MKHAKDC@duplicate?5codepage?5byte?5sequence@ ;	"duplicate codepage byte sequence at U+%"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7081B:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+2B1j
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+343j ...
		mov	eax, [ebp+var_38]
		and	eax, 0FF0FFFFFh
		movsx	ecx, [ebp+arg_10]
		sub	ecx, 3
		neg	ecx
		sbb	ecx, ecx
		and	ecx, 0FFFFFFFEh
		add	ecx, 2
		xor	edx, edx
		cmp	[ebp+arg_C], offset dword_10000
		setnl	dl
		add	ecx, edx
		shl	ecx, 14h
		or	eax, ecx
		mov	[ebp+var_38], eax
		cmp	[ebp+arg_C], 0FFFFh
		jg	short loc_70863
		mov	eax, [ebp+var_38]
		and	eax, 0FFF00000h
		or	eax, [ebp+arg_C]
		mov	[ebp+var_38], eax
		jmp	short loc_70879
; ---------------------------------------------------------------------------

loc_70863:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+3CDj
		mov	eax, [ebp+var_38]
		and	eax, 0FFF00000h
		mov	ecx, [ebp+arg_C]
		sub	ecx, offset dword_10000
		or	eax, ecx
		mov	[ebp+var_38], eax

loc_70879:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+3DDj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, [ebp+var_4D]
		shl	edx, 0Ah
		lea	eax, [ecx+edx+8]
		mov	ecx, [ebp+arg_4]
		add	ecx, [ebp+var_2C]
		movzx	edx, byte ptr [ecx-1]
		mov	ecx, [ebp+var_38]
		mov	[eax+edx*4], ecx
		jmp	loc_70CEF
; ---------------------------------------------------------------------------

$LN31:					; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+1BFj
					; DATA XREF: .text:$LN60o
		movzx	eax, word ptr [ebp+var_38] ; jumptable 00070643	case 4
		add	eax, [ebp+var_20]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		mov	edx, [ebp+var_20]
		movzx	eax, word ptr [ecx+edx*2]
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 0FFFEh
		jnz	short loc_708E2
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?removeFallback@@YAHPAUMBCSData@@I@Z ; removeFallback(MBCSData *,uint)
		add	esp, 8
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 0FFFFFFFFh
		jz	loc_7098C

loc_708E2:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+43Fj
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jl	short loc_7093A
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	offset ??_C@_0EF@PGJNLKIL@error?3?5duplicate?5codepage?5byte?5s@ ; "error: duplicate codepage byte sequence"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_70CF8
; ---------------------------------------------------------------------------
		jmp	short loc_7098C
; ---------------------------------------------------------------------------

loc_7093A:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+464j
		movsx	eax, byte ptr ds:_VERBOSE
		test	eax, eax
		jz	short loc_7098C
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	offset ??_C@_0DO@MKHAKDC@duplicate?5codepage?5byte?5sequence@ ;	"duplicate codepage byte sequence at U+%"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7098C:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+458j
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+4B4j ...
		cmp	[ebp+arg_C], offset dword_10000
		jl	short loc_709DF
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		mov	esi, esp
		push	eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	offset ??_C@_0EJ@MOMGMCDC@error?3?5code?5point?5does?5not?5fit?5i@ ; "error: code point	does not fit into val"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_70CF8
; ---------------------------------------------------------------------------

loc_709DF:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+50Fj
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jle	short loc_70A19
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		mov	edx, [ebp+var_20]
		movzx	eax, word ptr [ecx+edx*2]
		cmp	eax, 0FFFEh
		jnz	short loc_70A17
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?setFallback@@YACPAUMBCSData@@IH@Z ; setFallback(MBCSData *,uint,int)
		add	esp, 0Ch
		jmp	loc_70CF8
; ---------------------------------------------------------------------------

loc_70A17:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+578j
		jmp	short loc_70A2D
; ---------------------------------------------------------------------------

loc_70A19:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+561j
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		mov	edx, [ebp+var_20]
		mov	ax, word ptr [ebp+arg_C]
		mov	[ecx+edx*2], ax

loc_70A2D:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char):loc_70A17j
		jmp	loc_70CEF
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+1BFj
					; DATA XREF: .text:$LN60o
		movzx	eax, word ptr [ebp+var_38] ; jumptable 00070643	case 5
		add	eax, [ebp+var_20]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		mov	edx, [ebp+var_20]
		movzx	eax, word ptr [ecx+edx*2]
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 0FFFEh
		jge	loc_70B62
		cmp	[ebp+var_44], 0D800h
		jge	short loc_70A6D
		mov	eax, [ebp+var_44]
		mov	[ebp+var_5C], eax
		jmp	short loc_70AB8
; ---------------------------------------------------------------------------

loc_70A6D:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+5DFj
		cmp	[ebp+var_44], 0DFFFh
		jg	short loc_70AA4
		mov	eax, [ebp+var_44]
		and	eax, 3FFh
		shl	eax, 0Ah
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_10018[ecx]
		mov	ecx, [ebp+var_20]
		movzx	edx, word ptr [edx+ecx*2+2]
		and	edx, 3FFh
		lea	eax, dword_10000[eax+edx]
		mov	[ebp+var_5C], eax
		jmp	short loc_70AB8
; ---------------------------------------------------------------------------

loc_70AA4:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+5F0j
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		mov	edx, [ebp+var_20]
		movzx	eax, word ptr [ecx+edx*2+2]
		mov	[ebp+var_5C], eax

loc_70AB8:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+5E7j
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+61Ej
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jl	short loc_70B10
		mov	esi, esp
		mov	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	offset ??_C@_0EF@PGJNLKIL@error?3?5duplicate?5codepage?5byte?5s@ ; "error: duplicate codepage byte sequence"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_70CF8
; ---------------------------------------------------------------------------
		jmp	short loc_70B62
; ---------------------------------------------------------------------------

loc_70B10:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+63Aj
		movsx	eax, byte ptr ds:_VERBOSE
		test	eax, eax
		jz	short loc_70B62
		mov	esi, esp
		mov	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	offset ??_C@_0DO@MKHAKDC@duplicate?5codepage?5byte?5sequence@ ;	"duplicate codepage byte sequence at U+%"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_70B62:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+5D2j
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+68Aj ...
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jle	loc_70C05
		cmp	[ebp+var_44], 0DBFFh
		jle	short loc_70B80
		cmp	[ebp+var_44], 0E000h
		jnz	short loc_70B82

loc_70B80:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+6F1j
		jmp	short loc_70C00
; ---------------------------------------------------------------------------

loc_70B82:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+6FAj
		cmp	[ebp+arg_C], 0FFFFh
		jg	short loc_70BBF
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		mov	edx, 0E001h
		mov	eax, [ebp+var_20]
		mov	[ecx+eax*2], dx
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		mov	edx, [ebp+var_20]
		mov	ax, word ptr [ebp+arg_C]
		mov	[ecx+edx*2], ax
		jmp	short loc_70C00
; ---------------------------------------------------------------------------

loc_70BBF:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+705j
		mov	eax, [ebp+arg_C]
		sar	eax, 0Ah
		add	eax, 0DBC0h
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_10018[ecx]
		mov	ecx, [ebp+var_20]
		mov	[edx+ecx*2], ax
		mov	edx, [ebp+var_20]
		add	edx, 1
		mov	[ebp+var_20], edx
		mov	eax, [ebp+arg_C]
		and	eax, 3FFh
		add	eax, 0DC00h
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_10018[ecx]
		mov	ecx, [ebp+var_20]
		mov	[edx+ecx*2], ax

loc_70C00:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char):loc_70B80j
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+739j
		jmp	loc_70CA2
; ---------------------------------------------------------------------------

loc_70C05:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+6E4j
		cmp	[ebp+arg_C], 0D800h
		jge	short loc_70C24
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		mov	edx, [ebp+var_20]
		mov	ax, word ptr [ebp+arg_C]
		mov	[ecx+edx*2], ax
		jmp	short loc_70CA2
; ---------------------------------------------------------------------------

loc_70C24:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+788j
		cmp	[ebp+arg_C], 0FFFFh
		jg	short loc_70C61
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		mov	edx, 0E000h
		mov	eax, [ebp+var_20]
		mov	[ecx+eax*2], dx
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10018[eax]
		mov	edx, [ebp+var_20]
		mov	ax, word ptr [ebp+arg_C]
		mov	[ecx+edx*2], ax
		jmp	short loc_70CA2
; ---------------------------------------------------------------------------

loc_70C61:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+7A7j
		mov	eax, [ebp+arg_C]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_10018[ecx]
		mov	ecx, [ebp+var_20]
		mov	[edx+ecx*2], ax
		mov	edx, [ebp+var_20]
		add	edx, 1
		mov	[ebp+var_20], edx
		mov	eax, [ebp+arg_C]
		and	eax, 3FFh
		add	eax, 0DC00h
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_10018[ecx]
		mov	ecx, [ebp+var_20]
		mov	[edx+ecx*2], ax

loc_70CA2:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char):loc_70C00j
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+79Ej ...
		jmp	short loc_70CEF
; ---------------------------------------------------------------------------

loc_70CA4:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+1B3j
		mov	esi, esp	; jumptable 00070643 default case
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		push	offset ??_C@_0FH@KDCIKFOB@internal?5error?3?5byte?5sequence?5re@ ; "internal error: byte sequence reached r"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	short loc_70CF8
; ---------------------------------------------------------------------------

loc_70CEF:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+416j
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char):loc_70A2Dj ...
		mov	al, 1
		jmp	short loc_70CF8
; ---------------------------------------------------------------------------

loc_70CF3:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+13Aj
		jmp	loc_70521
; ---------------------------------------------------------------------------

loc_70CF8:				; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+75j
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+11Ej ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN59
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCSAddToUnicode@@YACPAUMBCSData@@PBEHHC@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN59		dd 1			; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+878o
		dd offset $LN58
$LN58		dd 0FFFFFFECh, 0Ah	; DATA XREF: .text:00070D2Co
		dd offset $LN57		; "buffer"
$LN57		db 'buffer',0           ; DATA XREF: .text:00070D38o
		align 4
$LN60		dd offset $LN41		; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+1BFr
		dd offset $LN41		; jump table for switch	statement
		dd offset $LN41
		dd offset $LN41
		dd offset $LN31
		dd offset $LN21
		dd offset $LN42
		dd offset $LN44
		dd offset $LN43
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 70D68h
		public ??_C@_0FH@KDCIKFOB@internal?5error?3?5byte?5sequence?5re@
; char `string'[]
??_C@_0FH@KDCIKFOB@internal?5error?3?5byte?5sequence?5re@ db 'internal error: byte sequence reached reserved action code, entry'
					; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+83Fo
		db ' 0x%02x: 0x%s (U+%x)',0Ah,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 70DC0h
		public ??_C@_0EJ@MOMGMCDC@error?3?5code?5point?5does?5not?5fit?5i@
; char `string'[]
??_C@_0EJ@MOMGMCDC@error?3?5code?5point?5does?5not?5fit?5i@ db 'error: code point does not fit into valid-16-bit state at U+%04x<'
					; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+52Co
		db '->0x%s',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70E0Ch
		public ??_C@_0DO@MKHAKDC@duplicate?5codepage?5byte?5sequence@
; char `string'[]
??_C@_0DO@MKHAKDC@duplicate?5codepage?5byte?5sequence@ db 'duplicate codepage byte sequence at U+%04x<->0x%s see U+%04x',0Ah,0
					; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+36Fo
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+4E0o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 70E4Ch
		public ??_C@_0EF@PGJNLKIL@error?3?5duplicate?5codepage?5byte?5s@
; char `string'[]
??_C@_0EF@PGJNLKIL@error?3?5duplicate?5codepage?5byte?5s@ db 'error: duplicate codepage byte sequence at U+%04x<->0x%s see U+%0'
					; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+314o
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+485o ...
		db '4x',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 70E94h
		public ??_C@_0EA@FOEEAGEJ@error?3?5byte?5sequence?5ends?5in?5una@
; char `string'[]
??_C@_0EA@FOEEAGEJ@error?3?5byte?5sequence?5ends?5in?5una@ db 'error: byte sequence ends in unassigned state at U+%04x<->0x%s',0Ah,0
					; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+275o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 70ED4h
		public ??_C@_0EB@IHGDKPFP@error?3?5byte?5sequence?5ends?5in?5sta@
; char `string'[]
??_C@_0EB@IHGDKPFP@error?3?5byte?5sequence?5ends?5in?5sta@ db 'error: byte sequence ends in state-change-only at U+%04x<->0x%s',0Ah
					; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+22Bo
		db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70F18h
		public ??_C@_0DN@INKFOFLD@error?3?5byte?5sequence?5ends?5in?5ill@
; char `string'[]
??_C@_0DN@INKFOFLD@error?3?5byte?5sequence?5ends?5in?5ill@ db 'error: byte sequence ends in illegal state at U+%04x<->0x%s',0Ah,0
					; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+1E1o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 70F58h
		public ??_C@_0EI@JPCHFLKG@error?3?5byte?5sequence?5too?5long?5by@
; char `string'[]
??_C@_0EI@JPCHFLKG@error?3?5byte?5sequence?5too?5long?5by@ db 'error: byte sequence too long by %d bytes, final state %u: 0x%s ('
					; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+16Eo
		db 'U+%x)',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 70FA0h
		public ??_C@_0EK@IHMOJLEM@error?3?5byte?5sequence?5too?5short?0?5@
; char `string'[]
??_C@_0EK@IHMOJLEM@error?3?5byte?5sequence?5too?5short?0?5@ db 'error: byte sequence too short, ends in non-final state %hu: 0x%s'
					; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+F4o
		db ' (U+%x)',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70FECh
		public ??_C@_0CH@IEHFNBLJ@error?3?5there?5is?5no?5state?5informa@
; char `string'[]
??_C@_0CH@IEHFNBLJ@error?3?5there?5is?5no?5state?5informa@ db 'error: there is no state information!',0Ah,0
					; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+4Bo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 71014h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * __cdecl printBytes(char *, unsigned char const	*, int)
?printBytes@@YAPADPADPBEH@Z proc near	; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+E6p
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+159p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax

loc_71038:				; CODE XREF: printBytes(char *,uchar const *,int)+7Cj
		cmp	[ebp+arg_8], 0
		jle	short loc_71092
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		sar	ecx, 4
		push	ecx
		call	?hexDigit@@YADE@Z ; hexDigit(uchar)
		add	esp, 4
		mov	edx, [ebp+var_8]
		mov	[edx], al
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		and	ecx, 0Fh
		push	ecx
		call	?hexDigit@@YADE@Z ; hexDigit(uchar)
		add	esp, 4
		mov	edx, [ebp+var_8]
		mov	[edx], al
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		add	eax, 1
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		jmp	short loc_71038
; ---------------------------------------------------------------------------

loc_71092:				; CODE XREF: printBytes(char *,uchar const *,int)+28j
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?printBytes@@YAPADPADPBEH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 710B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char __cdecl hexDigit(unsigned char)
?hexDigit@@YADE@Z proc near		; CODE XREF: printBytes(char *,uchar const *,int)+34p
					; printBytes(char *,uchar const	*,int)+54p

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movzx	eax, [ebp+arg_0]
		cmp	eax, 9
		jg	short loc_710E6
		movzx	ecx, [ebp+arg_0]
		add	ecx, 30h ; '0'
		mov	[ebp+var_C1], cl
		jmp	short loc_710F3
; ---------------------------------------------------------------------------

loc_710E6:				; CODE XREF: hexDigit(uchar)+25j
		movzx	edx, [ebp+arg_0]
		add	edx, 57h ; 'W'
		mov	[ebp+var_C1], dl

loc_710F3:				; CODE XREF: hexDigit(uchar)+34j
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hexDigit@@YADE@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 71100h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl setFallback(struct MBCSData *, unsigned int, int)
?setFallback@@YACPAUMBCSData@@IH@Z proc	near
					; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+586p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_10014[ecx]
		push	edx
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		push	eax
		call	_ucm_findFallback
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jl	short loc_71157
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_8]
		mov	[ecx+eax*8+18h], edx
		mov	al, 1
		jmp	short loc_711CB
; ---------------------------------------------------------------------------
		jmp	short loc_711CB
; ---------------------------------------------------------------------------

loc_71157:				; CODE XREF: setFallback(MBCSData *,uint,int)+42j
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10014[eax]
		mov	[ebp+var_8], ecx
		cmp	[ebp+var_8], 2000h
		jl	short loc_711A0
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		push	offset ??_C@_0DJ@MCOAJFMC@error?3?5too?5many?5toUnicode?5fallba@ ; "error: too many toUnicode fallbacks, cu"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	short loc_711CB
; ---------------------------------------------------------------------------
		jmp	short loc_711CB
; ---------------------------------------------------------------------------

loc_711A0:				; CODE XREF: setFallback(MBCSData *,uint,int)+6Aj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	[ecx+eax*8+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_8]
		mov	[ecx+eax*8+18h], edx
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	ecx, [ebp+arg_0]
		mov	ds:dword_10014[ecx], eax
		mov	al, 1

loc_711CB:				; CODE XREF: setFallback(MBCSData *,uint,int)+53j
					; setFallback(MBCSData *,uint,int)+55j	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setFallback@@YACPAUMBCSData@@IH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 711E0h
		public ??_C@_0DJ@MCOAJFMC@error?3?5too?5many?5toUnicode?5fallba@
; char `string'[]
??_C@_0DJ@MCOAJFMC@error?3?5too?5many?5toUnicode?5fallba@ db 'error: too many toUnicode fallbacks, currently at: U+%x',0Ah,0
					; DATA XREF: setFallback(MBCSData *,uint,int)+72o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7121Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl removeFallback(struct MBCSData *,	unsigned int)
?removeFallback@@YAHPAUMBCSData@@I@Z proc near
					; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+449p

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_10014[ecx]
		push	edx
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		push	eax
		call	_ucm_findFallback
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jl	short loc_712BF
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_10014[eax]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+eax*8+4]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_20]
		mov	esi, [ebp+var_14]
		mov	edx, [esi+edx*8-8]
		mov	[ecx+eax*8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_20]
		mov	esi, [ebp+var_14]
		mov	edx, [esi+edx*8-4]
		mov	[ecx+eax*8+4], edx
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	ecx, [ebp+arg_0]
		mov	ds:dword_10014[ecx], eax
		mov	eax, [ebp+var_2C]
		jmp	short loc_712C2
; ---------------------------------------------------------------------------
		jmp	short loc_712C2
; ---------------------------------------------------------------------------

loc_712BF:				; CODE XREF: removeFallback(MBCSData *,uint)+42j
		or	eax, 0FFFFFFFFh

loc_712C2:				; CODE XREF: removeFallback(MBCSData *,uint)+9Fj
					; removeFallback(MBCSData *,uint)+A1j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?removeFallback@@YAHPAUMBCSData@@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 712D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl MBCSSingleAddFromUnicode(struct MBCSData *, unsigned char	const *, int, int, signed char)
?MBCSSingleAddFromUnicode@@YACPAUMBCSData@@PBEHHC@Z proc near
					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+25Ep
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+316p

var_144		= byte ptr -144h
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_35		= byte ptr -35h
var_2C		= word ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 144h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_144]
		mov	ecx, 51h ; 'Q'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movsx	eax, [ebp+arg_10]
		cmp	eax, 2
		jnz	short loc_71306
		mov	al, 1
		jmp	loc_71675
; ---------------------------------------------------------------------------

loc_71306:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+25j
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF1C[eax]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	cl, [eax]
		mov	[ebp+var_35], cl
		mov	eax, [ebp+arg_C]
		sar	eax, 0Ah
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	short loc_7134B
		cmp	[ebp+arg_C], 1FFFh
		jg	short loc_7134B
		mov	eax, [ebp+arg_C]
		sar	eax, 4
		and	eax, 3Fh
		and	eax, 0FFFFFFFCh
		mov	[ebp+var_68], eax
		jmp	short loc_71357
; ---------------------------------------------------------------------------

loc_7134B:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+57j
					; MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+60j
		mov	eax, [ebp+arg_C]
		sar	eax, 4
		and	eax, 3Fh
		mov	[ebp+var_68], eax

loc_71357:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+71j
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		movzx	edx, ds:word_1001C[ecx+eax*2]
		test	edx, edx
		jnz	loc_7141F
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF20[eax]
		mov	[ebp+var_74], ecx
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	short loc_713B5
		mov	eax, [ebp+var_74]
		sub	eax, [ebp+var_68]
		mov	[ebp+var_80], eax

loc_71390:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+DBj
		mov	eax, [ebp+var_80]
		cmp	eax, [ebp+var_74]
		jnb	short loc_713B5
		mov	eax, [ebp+var_74]
		mov	ecx, [ebp+arg_0]
		movzx	edx, ds:word_1089A[ecx+eax*2]
		test	edx, edx
		jnz	short loc_713B5
		mov	eax, [ebp+var_74]
		sub	eax, 1
		mov	[ebp+var_74], eax
		jmp	short loc_71390
; ---------------------------------------------------------------------------

loc_713B5:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+ADj
					; MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+BEj ...
		mov	eax, [ebp+var_74]
		add	eax, 40h ; '@'
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], 0FBC0h
		jbe	short loc_71401
		movzx	eax, [ebp+var_35]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	offset ??_C@_0DE@MJJPHHL@error?3?5too?5many?5stage?52?5entries?5@ ; "error: too	many stage 2 entries at	U+%0"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_71675
; ---------------------------------------------------------------------------

loc_71401:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+EDj
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		mov	dx, word ptr [ebp+var_74]
		mov	ds:word_1001C[ecx+eax*2], dx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_50]
		mov	ds:dword_6EF20[eax], ecx

loc_7141F:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+8Fj
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		movzx	edx, ds:word_1001C[ecx+eax*2]
		add	edx, [ebp+var_68]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	short loc_7145C
		cmp	[ebp+arg_C], 1FFFh
		jg	short loc_7145C
		mov	[ebp+var_44], 40h ; '@'
		mov	eax, [ebp+arg_C]
		and	eax, 3Fh
		mov	[ebp+var_68], eax
		jmp	short loc_7146C
; ---------------------------------------------------------------------------

loc_7145C:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+167j
					; MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+170j
		mov	[ebp+var_44], 10h
		mov	eax, [ebp+arg_C]
		and	eax, 0Fh
		mov	[ebp+var_68], eax

loc_7146C:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+182j
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		movzx	edx, ds:word_1089C[ecx+eax*2]
		test	edx, edx
		jnz	loc_71553
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF24[eax]
		mov	[ebp+var_74], ecx
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	short loc_714C7
		mov	eax, [ebp+var_74]
		sub	eax, [ebp+var_68]
		mov	[ebp+var_80], eax

loc_714A5:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+1EDj
		mov	eax, [ebp+var_80]
		cmp	eax, [ebp+var_74]
		jnb	short loc_714C7
		mov	eax, [ebp+var_74]
		mov	ecx, [ebp+var_8]
		movzx	edx, word ptr [ecx+eax*2-2]
		test	edx, edx
		jnz	short loc_714C7
		mov	eax, [ebp+var_74]
		sub	eax, 1
		mov	[ebp+var_74], eax
		jmp	short loc_714A5
; ---------------------------------------------------------------------------

loc_714C7:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+1C2j
					; MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+1D3j ...
		mov	eax, [ebp+var_74]
		add	eax, [ebp+var_44]
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], offset dword_10000
		jbe	short loc_71513
		movzx	eax, [ebp+var_35]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	offset ??_C@_0DA@INMEGIJN@error?3?5too?5many?5code?5points?5at?5U@ ; "error: too many code points at U+%04x<-"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_71675
; ---------------------------------------------------------------------------

loc_71513:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+1FFj
		mov	eax, [ebp+var_20]
		mov	[ebp+var_5C], eax

loc_71519:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+26Dj
		mov	eax, [ebp+var_74]
		cmp	eax, [ebp+var_50]
		jnb	short loc_71547
		mov	eax, [ebp+var_5C]
		mov	ecx, [ebp+arg_0]
		mov	dx, word ptr [ebp+var_74]
		mov	ds:word_1089C[ecx+eax*2], dx
		mov	eax, [ebp+var_5C]
		add	eax, 1
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_74]
		add	eax, 10h
		mov	[ebp+var_74], eax
		jmp	short loc_71519
; ---------------------------------------------------------------------------

loc_71547:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+247j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_50]
		mov	ds:dword_6EF24[eax], ecx

loc_71553:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+1A4j
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		movzx	edx, ds:word_1089C[ecx+eax*2]
		mov	eax, [ebp+var_8]
		lea	ecx, [eax+edx*2]
		mov	edx, [ebp+var_68]
		lea	eax, [ecx+edx*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	cx, [eax]
		mov	[ebp+var_2C], cx
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jg	short loc_71593
		movzx	eax, [ebp+var_35]
		or	eax, 0F00h
		mov	ecx, [ebp+var_14]
		mov	[ecx], ax
		jmp	short loc_715D1
; ---------------------------------------------------------------------------

loc_71593:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+2A8j
		mov	eax, [ebp+arg_C]
		sub	eax, 0E000h
		cmp	eax, 1900h
		jb	short loc_715B1
		mov	eax, [ebp+arg_C]
		sub	eax, 0F0000h
		cmp	eax, offset dword_20000
		jnb	short loc_715C2

loc_715B1:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+2C8j
		movzx	eax, [ebp+var_35]
		or	eax, 0C00h
		mov	ecx, [ebp+var_14]
		mov	[ecx], ax
		jmp	short loc_715D1
; ---------------------------------------------------------------------------

loc_715C2:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+2D7j
		movzx	eax, [ebp+var_35]
		or	eax, 800h
		mov	ecx, [ebp+var_14]
		mov	[ecx], ax

loc_715D1:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+2B9j
					; MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+2E8j
		movzx	eax, [ebp+var_2C]
		cmp	eax, 100h
		jl	loc_71673
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jl	short loc_7162B
		movzx	eax, [ebp+var_2C]
		and	eax, 0FFh
		mov	esi, esp
		push	eax
		movzx	ecx, [ebp+var_35]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		push	offset ??_C@_0ED@DFBEPMBN@error?3?5duplicate?5Unicode?5code?5po@ ; "error: duplicate Unicode code point	at "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	short loc_71675
; ---------------------------------------------------------------------------
		jmp	short loc_71673
; ---------------------------------------------------------------------------

loc_7162B:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+30Ej
		movsx	eax, byte ptr ds:_VERBOSE
		test	eax, eax
		jz	short loc_71673
		movzx	eax, [ebp+var_2C]
		and	eax, 0FFh
		mov	esi, esp
		push	eax
		movzx	ecx, [ebp+var_35]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		push	offset ??_C@_0DM@NGGBIDF@duplicate?5Unicode?5code?5point?5at?5@	; "duplicate Unicode code point	at U+%04x<"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_71673:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+302j
					; MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+351j ...
		mov	al, 1

loc_71675:				; CODE XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+29j
					; MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+124j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCSSingleAddFromUnicode@@YACPAUMBCSData@@PBEHHC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7168Ch
		public ??_C@_0DM@NGGBIDF@duplicate?5Unicode?5code?5point?5at?5@
; char `string'[]
??_C@_0DM@NGGBIDF@duplicate?5Unicode?5code?5point?5at?5@ db 'duplicate Unicode code point at U+%04x<->0x%02x see 0x%02x',0Ah,0
					; DATA XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+373o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 716C8h
		public ??_C@_0ED@DFBEPMBN@error?3?5duplicate?5Unicode?5code?5po@
; char `string'[]
??_C@_0ED@DFBEPMBN@error?3?5duplicate?5Unicode?5code?5po@ db 'error: duplicate Unicode code point at U+%04x<->0x%02x see 0x%02x'
					; DATA XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+325o
		db 0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7170Ch
		public ??_C@_0DA@INMEGIJN@error?3?5too?5many?5code?5points?5at?5U@
; char `string'[]
??_C@_0DA@INMEGIJN@error?3?5too?5many?5code?5points?5at?5U@ db 'error: too many code points at U+%04x<->0x%02x',0Ah,0
					; DATA XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+20Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7173Ch
		public ??_C@_0DE@MJJPHHL@error?3?5too?5many?5stage?52?5entries?5@
; char `string'[]
??_C@_0DE@MJJPHHL@error?3?5too?5many?5stage?52?5entries?5@ db 'error: too many stage 2 entries at U+%04x<->0x%02x',0Ah,0
					; DATA XREF: MBCSSingleAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+FAo
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 71770h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl MBCSAddFromUnicode(struct	MBCSData *, unsigned char const	*, int,	int, signed char)
?MBCSAddFromUnicode@@YACPAUMBCSData@@PBEHHC@Z proc near
					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+2BBp
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+37Ap

var_19C		= dword	ptr -19Ch
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h
var_BC		= dword	ptr -0BCh
var_B0		= dword	ptr -0B0h
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_8C		= dword	ptr -8Ch
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 19Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_19C]
		mov	ecx, 67h ; 'g'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, ds:dword_20410[ecx]
		mov	[ebp+var_74], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movsx	edx, ds:byte_20419[ecx]
		cmp	edx, 0Ch
		jnz	short loc_71824
		movsx	eax, byte ptr ds:_IGNORE_SISO_CHECK
		test	eax, eax
		jnz	short loc_71824
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		cmp	ecx, 0Eh
		jz	short loc_717DA
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		cmp	ecx, 0Fh
		jnz	short loc_71824

loc_717DA:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+5Dj
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		mov	esi, esp
		push	eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	offset ??_C@_0EG@CCNIKDPG@error?3?5illegal?5mapping?5to?5SI?5or?5@ ; "error: illegal mapping to	SI or SO for "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_71EDA
; ---------------------------------------------------------------------------

loc_71824:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+47j
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+52j	...
		movsx	eax, [ebp+arg_10]
		cmp	eax, 1
		jnz	short loc_71879
		cmp	[ebp+arg_8], 1
		jnz	short loc_71879
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_71879
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		mov	esi, esp
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		push	offset ??_C@_0DN@MPOALDBM@error?3?5unable?5to?5encode?5a?5?$HM1?5fal@ ;	"error:	unable to encode a |1 fallback f"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_71EDA
; ---------------------------------------------------------------------------

loc_71879:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+BBj
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+C1j	...
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF1C[eax]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_C]
		sar	eax, 0Ah
		mov	[ebp+var_44], eax
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	short loc_718BF
		mov	eax, [ebp+arg_0]
		movzx	ecx, ds:word_6F728[eax]
		cmp	[ebp+arg_C], ecx
		jg	short loc_718BF
		mov	eax, [ebp+arg_C]
		sar	eax, 4
		and	eax, 3Fh
		and	eax, 0FFFFFFFCh
		mov	[ebp+var_A4], eax
		jmp	short loc_718CE
; ---------------------------------------------------------------------------

loc_718BF:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+12Aj
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+139j
		mov	eax, [ebp+arg_C]
		sar	eax, 4
		and	eax, 3Fh
		mov	[ebp+var_A4], eax

loc_718CE:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+14Dj
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_0]
		movzx	edx, ds:word_1001C[ecx+eax*2]
		test	edx, edx
		jnz	loc_71A08
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF20[eax]
		mov	[ebp+var_B0], ecx
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	short loc_71945
		mov	eax, [ebp+var_B0]
		sub	eax, [ebp+var_A4]
		mov	[ebp+var_BC], eax

loc_71913:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+1D3j
		mov	eax, [ebp+var_BC]
		cmp	eax, [ebp+var_B0]
		jnb	short loc_71945
		mov	eax, [ebp+var_B0]
		mov	ecx, [ebp+arg_0]
		cmp	ds:dword_30018[ecx+eax*4], 0
		jnz	short loc_71945
		mov	eax, [ebp+var_B0]
		sub	eax, 1
		mov	[ebp+var_B0], eax
		jmp	short loc_71913
; ---------------------------------------------------------------------------

loc_71945:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+18Fj
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+1AFj ...
		mov	eax, [ebp+var_B0]
		add	eax, 40h ; '@'
		mov	[ebp+var_8C], eax
		cmp	[ebp+var_8C], 0FBC0h
		jbe	short loc_719AA
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		mov	esi, esp
		push	eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	offset ??_C@_0DC@LIKCDKFK@error?3?5too?5many?5stage?52?5entries?5@ ; "error: too many stage 2 entries at U+%0"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_71EDA
; ---------------------------------------------------------------------------

loc_719AA:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+1EEj
		mov	eax, [ebp+var_44]
		mov	[ebp+var_98], eax

loc_719B3:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+287j
		mov	eax, [ebp+var_B0]
		cmp	eax, [ebp+var_8C]
		jnb	short loc_719F9
		mov	eax, [ebp+var_98]
		mov	ecx, [ebp+arg_0]
		mov	dx, word ptr [ebp+var_B0]
		mov	ds:word_1001C[ecx+eax*2], dx
		mov	eax, [ebp+var_98]
		add	eax, 1
		mov	[ebp+var_98], eax
		mov	eax, [ebp+var_B0]
		add	eax, 40h ; '@'
		mov	[ebp+var_B0], eax
		jmp	short loc_719B3
; ---------------------------------------------------------------------------

loc_719F9:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+24Fj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8C]
		mov	ds:dword_6EF20[eax], ecx

loc_71A08:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+16Ej
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_0]
		movzx	edx, ds:word_1001C[ecx+eax*2]
		add	edx, [ebp+var_A4]
		mov	[ebp+var_44], edx
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	short loc_71A53
		mov	eax, [ebp+arg_0]
		movzx	ecx, ds:word_6F728[eax]
		cmp	[ebp+arg_C], ecx
		jg	short loc_71A53
		mov	eax, [ebp+var_74]
		shl	eax, 6
		mov	[ebp+var_80], eax
		mov	eax, [ebp+arg_C]
		and	eax, 3Fh
		mov	[ebp+var_A4], eax
		jmp	short loc_71A68
; ---------------------------------------------------------------------------

loc_71A53:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+2BBj
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+2CAj
		mov	eax, [ebp+var_74]
		shl	eax, 4
		mov	[ebp+var_80], eax
		mov	eax, [ebp+arg_C]
		and	eax, 0Fh
		mov	[ebp+var_A4], eax

loc_71A68:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+2E1j
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_0]
		cmp	ds:dword_3001C[ecx+eax*4], 0
		jnz	loc_71C07
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF24[eax]
		mov	[ebp+var_B0], ecx
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	loc_71B39
		cmp	[ebp+var_A4], 10h
		jb	loc_71B39
		mov	eax, [ebp+var_A4]
		and	eax, 0FFFFFFF0h
		imul	eax, [ebp+var_74]
		mov	[ebp+var_D4], eax
		mov	[ebp+var_C8], 0
		jmp	short loc_71AD8
; ---------------------------------------------------------------------------

loc_71AC9:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+38Ej
		mov	eax, [ebp+var_C8]
		add	eax, 1
		mov	[ebp+var_C8], eax

loc_71AD8:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+357j
		mov	eax, [ebp+var_C8]
		cmp	eax, [ebp+var_D4]
		jnb	short loc_71B00
		mov	eax, [ebp+var_B0]
		sub	eax, [ebp+var_C8]
		mov	ecx, [ebp+var_2C]
		movzx	edx, byte ptr [ecx+eax-1]
		test	edx, edx
		jnz	short loc_71B00
		jmp	short loc_71AC9
; ---------------------------------------------------------------------------

loc_71B00:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+374j
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+38Cj
		mov	eax, [ebp+var_C8]
		shr	eax, 4
		xor	edx, edx
		div	[ebp+var_74]
		mov	[ebp+var_C8], eax
		mov	eax, [ebp+var_C8]
		shl	eax, 4
		imul	eax, [ebp+var_74]
		mov	[ebp+var_C8], eax
		mov	eax, [ebp+var_B0]
		sub	eax, [ebp+var_C8]
		mov	[ebp+var_B0], eax

loc_71B39:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+327j
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+334j
		mov	eax, [ebp+var_B0]
		add	eax, [ebp+var_80]
		mov	[ebp+var_8C], eax
		mov	eax, [ebp+var_74]
		shl	eax, 14h
		cmp	[ebp+var_8C], eax
		jbe	short loc_71BA0
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		mov	esi, esp
		push	eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	offset ??_C@_0CO@FCICPMNC@error?3?5too?5many?5code?5points?5at?5U@ ; "error: too many code points at U+%04x<-"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_71EDA
; ---------------------------------------------------------------------------

loc_71BA0:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+3E4j
		mov	eax, [ebp+var_44]
		mov	[ebp+var_98], eax

loc_71BA9:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+486j
		mov	eax, [ebp+var_B0]
		cmp	eax, [ebp+var_8C]
		jnb	short loc_71BF8
		mov	eax, [ebp+var_B0]
		shr	eax, 4
		xor	edx, edx
		div	[ebp+var_74]
		mov	ecx, [ebp+var_98]
		mov	edx, [ebp+arg_0]
		mov	ds:dword_3001C[edx+ecx*4], eax
		mov	eax, [ebp+var_98]
		add	eax, 1
		mov	[ebp+var_98], eax
		mov	eax, [ebp+var_74]
		shl	eax, 4
		add	eax, [ebp+var_B0]
		mov	[ebp+var_B0], eax
		jmp	short loc_71BA9
; ---------------------------------------------------------------------------

loc_71BF8:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+445j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8C]
		mov	ds:dword_6EF24[eax], ecx

loc_71C07:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+306j
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr ds:dword_3001C[ecx+eax*4]
		shl	edx, 4
		mov	[ebp+var_68], edx
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	short loc_71C67
		mov	eax, [ebp+arg_0]
		movzx	ecx, ds:word_6F728[eax]
		cmp	[ebp+arg_C], ecx
		jg	short loc_71C67
		cmp	[ebp+var_68], 0FFFFh
		jbe	short loc_71C52
		mov	eax, 0FEFFh
		mov	ecx, [ebp+arg_0]
		mov	ds:word_6F728[ecx], ax
		jmp	short loc_71C67
; ---------------------------------------------------------------------------

loc_71C52:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+4CFj
		mov	eax, [ebp+arg_C]
		sar	eax, 6
		mov	ecx, [ebp+arg_0]
		mov	dx, word ptr [ebp+var_68]
		mov	ds:word_6EF28[ecx+eax*2], dx

loc_71C67:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+4B7j
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+4C6j ...
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_20], eax
		mov	[ebp+var_50], 0
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_19C], eax
		cmp	[ebp+var_19C], 2
		jz	short loc_71CC6
		cmp	[ebp+var_19C], 3
		jz	short loc_71CAC
		cmp	[ebp+var_19C], 4
		jz	short loc_71C9A
		jmp	short loc_71CE0
; ---------------------------------------------------------------------------

loc_71C9A:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+526j
		mov	eax, [ebp+var_20]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_50], ecx
		mov	edx, [ebp+var_20]
		add	edx, 1
		mov	[ebp+var_20], edx

loc_71CAC:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+51Dj
		mov	eax, [ebp+var_50]
		shl	eax, 8
		mov	ecx, [ebp+var_20]
		movzx	edx, byte ptr [ecx]
		or	eax, edx
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_71CC6:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+514j
		mov	eax, [ebp+var_50]
		shl	eax, 8
		mov	ecx, [ebp+var_20]
		movzx	edx, byte ptr [ecx]
		or	eax, edx
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_71CE0:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+528j
		mov	eax, [ebp+var_50]
		shl	eax, 8
		mov	ecx, [ebp+var_20]
		movzx	edx, byte ptr [ecx]
		or	eax, edx
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		mov	[ebp+var_5C], 0
		mov	eax, [ebp+var_68]
		add	eax, [ebp+var_A4]
		imul	eax, [ebp+var_74]
		add	eax, [ebp+var_2C]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_74]
		mov	[ebp+var_19C], eax
		cmp	[ebp+var_19C], 2
		jz	short loc_71D3A
		cmp	[ebp+var_19C], 3
		jz	short loc_71D4F
		cmp	[ebp+var_19C], 4
		jz	short loc_71DA8
		jmp	short loc_71DB8
; ---------------------------------------------------------------------------

loc_71D3A:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+5B4j
		mov	eax, [ebp+var_38]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_38]
		mov	cx, word ptr [ebp+var_50]
		mov	[eax], cx
		jmp	short loc_71DB8
; ---------------------------------------------------------------------------

loc_71D4F:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+5BDj
		mov	eax, [ebp+var_38]
		movzx	ecx, byte ptr [eax]
		shl	ecx, 10h
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_50]
		shr	eax, 10h
		mov	ecx, [ebp+var_38]
		mov	[ecx], al
		mov	edx, [ebp+var_38]
		add	edx, 1
		mov	[ebp+var_38], edx
		mov	eax, [ebp+var_38]
		movzx	ecx, byte ptr [eax]
		shl	ecx, 8
		or	ecx, [ebp+var_5C]
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_50]
		shr	eax, 8
		mov	ecx, [ebp+var_38]
		mov	[ecx], al
		mov	edx, [ebp+var_38]
		add	edx, 1
		mov	[ebp+var_38], edx
		mov	eax, [ebp+var_38]
		movzx	ecx, byte ptr [eax]
		or	ecx, [ebp+var_5C]
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_38]
		mov	cl, byte ptr [ebp+var_50]
		mov	[eax], cl
		jmp	short loc_71DB8
; ---------------------------------------------------------------------------

loc_71DA8:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+5C6j
		mov	eax, [ebp+var_38]
		mov	ecx, [eax]
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_38]
		mov	ecx, [ebp+var_50]
		mov	[eax], ecx

loc_71DB8:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+5C8j
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+5DDj ...
		mov	eax, [ebp+var_A4]
		shr	eax, 4
		add	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_C]
		and	ecx, 0Fh
		add	ecx, 10h
		mov	edx, 1
		shl	edx, cl
		mov	ecx, [ebp+arg_0]
		and	edx, ds:dword_3001C[ecx+eax*4]
		jnz	short loc_71DEA
		cmp	[ebp+var_5C], 0
		jz	loc_71E94

loc_71DEA:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+66Ej
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jl	short loc_71E42
		mov	esi, esp
		mov	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	offset ??_C@_0EB@MIKNBNCN@error?3?5duplicate?5Unicode?5code?5po@ ; "error: duplicate Unicode code point	at "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_71EDA
; ---------------------------------------------------------------------------
		jmp	short loc_71E94
; ---------------------------------------------------------------------------

loc_71E42:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+680j
		movsx	eax, byte ptr ds:_VERBOSE
		test	eax, eax
		jz	short loc_71E94
		mov	esi, esp
		mov	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		call	?printBytes@@YAPADPADPBEH@Z ; printBytes(char *,uchar const *,int)
		add	esp, 0Ch
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	offset ??_C@_0DK@OEANOAED@duplicate?5Unicode?5code?5point?5at?5@ ; "duplicate Unicode code point at U+%04x<"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_71E94:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+674j
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+6D0j ...
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jg	short loc_71ED8
		mov	eax, [ebp+var_A4]
		shr	eax, 4
		add	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_C]
		and	ecx, 0Fh
		add	ecx, 10h
		mov	edx, 1
		shl	edx, cl
		mov	ecx, [ebp+arg_0]
		or	edx, ds:dword_3001C[ecx+eax*4]
		mov	eax, [ebp+var_A4]
		shr	eax, 4
		add	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_0]
		mov	ds:dword_3001C[ecx+eax*4], edx

loc_71ED8:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+72Aj
		mov	al, 1

loc_71EDA:				; CODE XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+AFj
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+104j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN48
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 19Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCSAddFromUnicode@@YACPAUMBCSData@@PBEHHC@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN48		dd 1			; DATA XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+76Eo
		dd offset $LN47
$LN47		dd 0FFFFFFECh, 0Ah	; DATA XREF: .text:00071F10o
		dd offset $LN46		; "buffer"
$LN46		db 'buffer',0           ; DATA XREF: .text:00071F1Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 71F28h
		public ??_C@_0DK@OEANOAED@duplicate?5Unicode?5code?5point?5at?5@
; char `string'[]
??_C@_0DK@OEANOAED@duplicate?5Unicode?5code?5point?5at?5@ db 'duplicate Unicode code point at U+%04x<->0x%s see 0x%02x',0Ah,0
					; DATA XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+6FCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 71F64h
		public ??_C@_0EB@MIKNBNCN@error?3?5duplicate?5Unicode?5code?5po@
; char `string'[]
??_C@_0EB@MIKNBNCN@error?3?5duplicate?5Unicode?5code?5po@ db 'error: duplicate Unicode code point at U+%04x<->0x%s see 0x%02x',0Ah
					; DATA XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+6A1o
		db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 71FA8h
		public ??_C@_0CO@FCICPMNC@error?3?5too?5many?5code?5points?5at?5U@
; char `string'[]
??_C@_0CO@FCICPMNC@error?3?5too?5many?5code?5points?5at?5U@ db 'error: too many code points at U+%04x<->0x%s',0Ah,0
					; DATA XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+401o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 71FD8h
		public ??_C@_0DC@LIKCDKFK@error?3?5too?5many?5stage?52?5entries?5@
; char `string'[]
??_C@_0DC@LIKCDKFK@error?3?5too?5many?5stage?52?5entries?5@ db 'error: too many stage 2 entries at U+%04x<->0x%s',0Ah,0
					; DATA XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+20Bo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7200Ch
		public ??_C@_0DN@MPOALDBM@error?3?5unable?5to?5encode?5a?5?$HM1?5fal@
; char `string'[]
??_C@_0DN@MPOALDBM@error?3?5unable?5to?5encode?5a?5?$HM1?5fal@ db 'error: unable to encode a |1 fallback from U+%04x to 0x%02x',0Ah,0
					; DATA XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+DAo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7204Ch
		public ??_C@_0EG@CCNIKDPG@error?3?5illegal?5mapping?5to?5SI?5or?5@
; char `string'[]
??_C@_0EG@CCNIKDPG@error?3?5illegal?5mapping?5to?5SI?5or?5@ db 'error: illegal mapping to SI or SO for SI/SO codepage: U+%04x<->0'
					; DATA XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+85o
		db 'x%s',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72094h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl MBCSPostprocess(struct MBCSData *, struct UConverterStaticData const *)
?MBCSPostprocess@@YAXPAUMBCSData@@PBUUConverterStaticData@@@Z proc near
					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+46Cp

var_E8		= dword	ptr -0E8h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		add	ecx, 8
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, ds:dword_20408[eax]
		mov	[ebp+var_14], ecx
		mov	edx, [ebp+var_14]
		mov	[ebp+var_20], edx
		movzx	eax, byte ptr ds:_VERBOSE
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_10014[ecx]
		push	edx
		mov	eax, [ebp+arg_0]
		add	eax, 14h
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, offset dword_10018
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	_ucm_optimizeStates
		add	esp, 14h
		mov	eax, [ebp+arg_0]
		push	eax
		call	?transformEUC@@YACPAUMBCSData@@@Z ; transformEUC(MBCSData *)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_7211B
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax

loc_7211B:				; CODE XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+7Cj
		mov	eax, [ebp+arg_0]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jnz	short loc_72155
		cmp	[ebp+var_14], 1
		jnz	short loc_72149
		mov	eax, [ebp+arg_0]
		push	eax
		call	?singleCompactStage3@@YAXPAUMBCSData@@@Z ; singleCompactStage3(MBCSData	*)
		add	esp, 4
		mov	eax, [ebp+arg_0]
		push	eax
		call	?singleCompactStage2@@YAXPAUMBCSData@@@Z ; singleCompactStage2(MBCSData	*)
		add	esp, 4
		jmp	short loc_72155
; ---------------------------------------------------------------------------

loc_72149:				; CODE XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+99j
		mov	eax, [ebp+arg_0]
		push	eax
		call	?compactStage2@@YAXPAUMBCSData@@@Z ; compactStage2(MBCSData *)
		add	esp, 4

loc_72155:				; CODE XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+93j
					; MBCSPostprocess(MBCSData *,UConverterStaticData const	*)+B3j
		movsx	eax, byte ptr ds:_VERBOSE
		test	eax, eax
		jz	loc_721EB
		cmp	[ebp+var_14], 1
		jnz	short loc_72176
		mov	[ebp+var_E8], offset ??_C@_02KMALDIDP@16?$AA@ ;	`string'
		jmp	short loc_72180
; ---------------------------------------------------------------------------

loc_72176:				; CODE XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+D4j
		mov	[ebp+var_E8], offset ??_C@_02MLODCJFF@32?$AA@ ;	`string'

loc_72180:				; CODE XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+E0j
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF20[eax]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, ds:dword_6EF20[edx]
		push	eax
		mov	ecx, [ebp+var_E8]
		push	ecx
		push	offset ??_C@_0DG@BECNOHKB@fromUnicode?5number?5of?5uint?$CFs_t?5i@ ; "fromUnicode number of uint%s_t in	stage"...
		call	dword ptr ds:__imp__printf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	eax, ds:dword_6EF24[eax]
		xor	edx, edx
		div	[ebp+var_20]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	eax, ds:dword_6EF24[ecx]
		xor	edx, edx
		div	[ebp+var_20]
		push	eax
		mov	edx, [ebp+var_20]
		push	edx
		push	offset ??_C@_0EC@FJCFIHFI@fromUnicode?5number?5of?5?$CFd?9byte?5st@ ; "fromUnicode number of %d-byte stage 3 m"...
		call	dword ptr ds:__imp__printf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_721EB:				; CODE XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+CAj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCSPostprocess@@YAXPAUMBCSData@@PBUUConverterStaticData@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 72200h
		public ??_C@_0EC@FJCFIHFI@fromUnicode?5number?5of?5?$CFd?9byte?5st@
; char `string'[]
??_C@_0EC@FJCFIHFI@fromUnicode?5number?5of?5?$CFd?9byte?5st@ db	'fromUnicode number of %d-byte stage 3 mapping entries: 0x%lx=%lu',0Ah
					; DATA XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+142o
		db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 72244h
		public ??_C@_0DG@BECNOHKB@fromUnicode?5number?5of?5uint?$CFs_t?5i@
; char `string'[]
??_C@_0DG@BECNOHKB@fromUnicode?5number?5of?5uint?$CFs_t?5i@ db 'fromUnicode number of uint%s_t in stage 2: 0x%lx=%lu',0Ah,0
					; DATA XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+109o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7227Ch
		public ??_C@_02MLODCJFF@32?$AA@
; `string'
??_C@_02MLODCJFF@32?$AA@ db 33h, 32h, 0	; DATA XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *):loc_72176o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 72280h
		public ??_C@_02KMALDIDP@16?$AA@
; `string'
??_C@_02KMALDIDP@16?$AA@ db 31h, 36h, 0	; DATA XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+D6o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72284h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl transformEUC(struct MBCSData *)
?transformEUC@@YACPAUMBCSData@@@Z proc near
					; CODE XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+6Fp

var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_41		= byte ptr -41h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, ds:dword_20410[ecx]
		mov	[ebp+var_2C], edx
		cmp	[ebp+var_2C], 3
		jnb	short loc_722BE
		xor	al, al
		jmp	loc_7253F
; ---------------------------------------------------------------------------

loc_722BE:				; CODE XREF: transformEUC(MBCSData *)+31j
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF24[eax]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF1C[eax]
		mov	[ebp+var_8], ecx
		cmp	[ebp+var_2C], 4
		jnz	short loc_722E5
		mov	eax, [ebp+var_8]
		add	eax, 3
		mov	[ebp+var_8], eax

loc_722E5:				; CODE XREF: transformEUC(MBCSData *)+56j
		mov	[ebp+var_14], 0
		jmp	short loc_722F7
; ---------------------------------------------------------------------------

loc_722EE:				; CODE XREF: transformEUC(MBCSData *):loc_7232Fj
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_2C]
		mov	[ebp+var_14], eax

loc_722F7:				; CODE XREF: transformEUC(MBCSData *)+68j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	short loc_72331
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_14]
		mov	cl, [eax]
		mov	[ebp+var_41], cl
		movzx	eax, [ebp+var_41]
		test	eax, eax
		jz	short loc_7232F
		movzx	eax, [ebp+var_41]
		cmp	eax, 8Eh ; ''
		jz	short loc_7232F
		movzx	eax, [ebp+var_41]
		cmp	eax, 8Fh ; ''
		jz	short loc_7232F
		xor	al, al
		jmp	loc_7253F
; ---------------------------------------------------------------------------

loc_7232F:				; CODE XREF: transformEUC(MBCSData *)+8Cj
					; transformEUC(MBCSData	*)+97j	...
		jmp	short loc_722EE
; ---------------------------------------------------------------------------

loc_72331:				; CODE XREF: transformEUC(MBCSData *)+79j
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF1C[eax]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_2C]
		add	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	ds:byte_20419[edx], al
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		imul	eax, [ebp+var_38]
		xor	edx, edx
		div	[ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	ds:dword_6EF24[ecx], eax
		cmp	[ebp+var_2C], 3
		jnz	loc_72433
		mov	eax, [ebp+var_8]
		mov	[ebp+var_50], eax
		mov	[ebp+var_14], 0
		jmp	short loc_72389
; ---------------------------------------------------------------------------

loc_72380:				; CODE XREF: transformEUC(MBCSData *)+1A5j
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_2C]
		mov	[ebp+var_14], eax

loc_72389:				; CODE XREF: transformEUC(MBCSData *)+FAj
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	loc_7242E
		mov	eax, [ebp+var_8]
		mov	cl, [eax]
		mov	[ebp+var_41], cl
		movzx	eax, [ebp+var_41]
		test	eax, eax
		jnz	short loc_723C9
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+1]
		shl	ecx, 8
		mov	edx, [ebp+var_8]
		movzx	eax, byte ptr [edx+2]
		or	ecx, eax
		mov	edx, [ebp+var_50]
		mov	[edx], cx
		mov	eax, [ebp+var_50]
		add	eax, 2
		mov	[ebp+var_50], eax
		jmp	short loc_72420
; ---------------------------------------------------------------------------

loc_723C9:				; CODE XREF: transformEUC(MBCSData *)+11Fj
		movzx	eax, [ebp+var_41]
		cmp	eax, 8Eh ; ''
		jnz	short loc_723FB
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+1]
		and	ecx, 7Fh
		shl	ecx, 8
		mov	edx, [ebp+var_8]
		movzx	eax, byte ptr [edx+2]
		or	ecx, eax
		mov	edx, [ebp+var_50]
		mov	[edx], cx
		mov	eax, [ebp+var_50]
		add	eax, 2
		mov	[ebp+var_50], eax
		jmp	short loc_72420
; ---------------------------------------------------------------------------

loc_723FB:				; CODE XREF: transformEUC(MBCSData *)+14Ej
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+1]
		shl	ecx, 8
		mov	edx, [ebp+var_8]
		movzx	eax, byte ptr [edx+2]
		and	eax, 7Fh
		or	ecx, eax
		mov	edx, [ebp+var_50]
		mov	[edx], cx
		mov	eax, [ebp+var_50]
		add	eax, 2
		mov	[ebp+var_50], eax

loc_72420:				; CODE XREF: transformEUC(MBCSData *)+143j
					; transformEUC(MBCSData	*)+175j
		mov	eax, [ebp+var_8]
		add	eax, 3
		mov	[ebp+var_8], eax
		jmp	loc_72380
; ---------------------------------------------------------------------------

loc_7242E:				; CODE XREF: transformEUC(MBCSData *)+10Bj
		jmp	loc_7253D
; ---------------------------------------------------------------------------

loc_72433:				; CODE XREF: transformEUC(MBCSData *)+E7j
		mov	eax, [ebp+var_8]
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_8]
		mov	[ebp+var_68], eax
		mov	[ebp+var_14], 0
		jmp	short loc_72451
; ---------------------------------------------------------------------------

loc_72448:				; CODE XREF: transformEUC(MBCSData *):loc_72538j
		mov	eax, [ebp+var_14]
		add	eax, 4
		mov	[ebp+var_14], eax

loc_72451:				; CODE XREF: transformEUC(MBCSData *)+1C2j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	loc_7253D
		mov	eax, [ebp+var_68]
		mov	ecx, [eax]
		mov	[ebp+var_20], ecx
		mov	edx, [ebp+var_68]
		add	edx, 4
		mov	[ebp+var_68], edx
		cmp	[ebp+var_20], 0FFFFFFh
		ja	short loc_724B5
		mov	eax, [ebp+var_20]
		shr	eax, 10h
		mov	ecx, [ebp+var_5C]
		mov	[ecx], al
		mov	edx, [ebp+var_5C]
		add	edx, 1
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+var_20]
		shr	eax, 8
		mov	ecx, [ebp+var_5C]
		mov	[ecx], al
		mov	edx, [ebp+var_5C]
		add	edx, 1
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+var_5C]
		mov	cl, byte ptr [ebp+var_20]
		mov	[eax], cl
		mov	edx, [ebp+var_5C]
		add	edx, 1
		mov	[ebp+var_5C], edx
		jmp	loc_72538
; ---------------------------------------------------------------------------

loc_724B5:				; CODE XREF: transformEUC(MBCSData *)+1F1j
		cmp	[ebp+var_20], 8EFFFFFFh
		ja	short loc_724FC
		mov	eax, [ebp+var_20]
		shr	eax, 10h
		and	eax, 7Fh
		mov	ecx, [ebp+var_5C]
		mov	[ecx], al
		mov	edx, [ebp+var_5C]
		add	edx, 1
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+var_20]
		shr	eax, 8
		mov	ecx, [ebp+var_5C]
		mov	[ecx], al
		mov	edx, [ebp+var_5C]
		add	edx, 1
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+var_5C]
		mov	cl, byte ptr [ebp+var_20]
		mov	[eax], cl
		mov	edx, [ebp+var_5C]
		add	edx, 1
		mov	[ebp+var_5C], edx
		jmp	short loc_72538
; ---------------------------------------------------------------------------

loc_724FC:				; CODE XREF: transformEUC(MBCSData *)+238j
		mov	eax, [ebp+var_20]
		shr	eax, 10h
		mov	ecx, [ebp+var_5C]
		mov	[ecx], al
		mov	edx, [ebp+var_5C]
		add	edx, 1
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+var_20]
		shr	eax, 8
		and	eax, 7Fh
		mov	ecx, [ebp+var_5C]
		mov	[ecx], al
		mov	edx, [ebp+var_5C]
		add	edx, 1
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+var_5C]
		mov	cl, byte ptr [ebp+var_20]
		mov	[eax], cl
		mov	edx, [ebp+var_5C]
		add	edx, 1
		mov	[ebp+var_5C], edx

loc_72538:				; CODE XREF: transformEUC(MBCSData *)+22Cj
					; transformEUC(MBCSData	*)+276j
		jmp	loc_72448
; ---------------------------------------------------------------------------

loc_7253D:				; CODE XREF: transformEUC(MBCSData *):loc_7242Ej
					; transformEUC(MBCSData	*)+1D3j
		mov	al, 1

loc_7253F:				; CODE XREF: transformEUC(MBCSData *)+35j
					; transformEUC(MBCSData	*)+A6j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?transformEUC@@YACPAUMBCSData@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72548h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl singleCompactStage2(struct MBCSData *)
?singleCompactStage2@@YAXPAUMBCSData@@@Z proc near
					; CODE XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+ABp

var_8DC		= byte ptr -8DCh
var_818		= word ptr -818h
var_80C		= word ptr -80Ch
var_800		= word ptr -800h
var_7F4		= word ptr -7F4h
var_7E8		= word ptr -7E8h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_8DC]
		mov	ecx, 237h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		mov	[ebp+var_7E8], ax
		mov	eax, 40h ; '@'
		mov	[ebp+var_818], ax
		mov	cx, [ebp+var_818]
		mov	[ebp+var_800], cx

loc_72593:				; CODE XREF: singleCompactStage2(MBCSData *):loc_727CCj
		movzx	eax, [ebp+var_800]
		mov	ecx, [ebp+arg_0]
		cmp	eax, ds:dword_6EF20[ecx]
		jnb	loc_727D1
		movzx	eax, [ebp+var_818]
		sub	eax, 1
		mov	[ebp+var_80C], ax
		xor	eax, eax
		mov	[ebp+var_7F4], ax
		jmp	short loc_725D7
; ---------------------------------------------------------------------------

loc_725C5:				; CODE XREF: singleCompactStage2(MBCSData *)+D9j
		mov	ax, [ebp+var_7F4]
		add	ax, 1
		mov	[ebp+var_7F4], ax

loc_725D7:				; CODE XREF: singleCompactStage2(MBCSData *)+7Bj
		movzx	eax, [ebp+var_7F4]
		cmp	eax, 40h ; '@'
		jge	short loc_72623
		movzx	eax, [ebp+var_800]
		movzx	ecx, [ebp+var_7F4]
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		movzx	eax, ds:word_1089C[edx+eax*2]
		test	eax, eax
		jnz	short loc_72623
		movzx	eax, [ebp+var_80C]
		movzx	ecx, [ebp+var_7F4]
		sub	eax, ecx
		mov	edx, [ebp+arg_0]
		movzx	eax, ds:word_1089C[edx+eax*2]
		test	eax, eax
		jnz	short loc_72623
		jmp	short loc_725C5
; ---------------------------------------------------------------------------

loc_72623:				; CODE XREF: singleCompactStage2(MBCSData *)+99j
					; singleCompactStage2(MBCSData *)+B8j ...
		movzx	eax, [ebp+var_7F4]
		test	eax, eax
		jle	loc_726EE
		movzx	eax, [ebp+var_818]
		movzx	ecx, [ebp+var_7F4]
		sub	eax, ecx
		movzx	edx, [ebp+var_800]
		sar	edx, 6
		mov	[ebp+edx*2+var_7E8], ax
		movzx	eax, [ebp+var_7F4]
		movzx	ecx, [ebp+var_800]
		add	ecx, eax
		mov	[ebp+var_800], cx
		movzx	eax, [ebp+var_7F4]
		mov	ecx, 40h ; '@'
		sub	ecx, eax
		mov	[ebp+var_7F4], cx
		jmp	short loc_72694
; ---------------------------------------------------------------------------

loc_72682:				; CODE XREF: singleCompactStage2(MBCSData *)+19Fj
		mov	ax, [ebp+var_7F4]
		sub	ax, 1
		mov	[ebp+var_7F4], ax

loc_72694:				; CODE XREF: singleCompactStage2(MBCSData *)+138j
		movzx	eax, [ebp+var_7F4]
		test	eax, eax
		jle	short loc_726E9
		movzx	eax, [ebp+var_800]
		movzx	ecx, [ebp+var_818]
		mov	edx, [ebp+arg_0]
		mov	esi, [ebp+arg_0]
		mov	ax, ds:word_1089C[esi+eax*2]
		mov	ds:word_1089C[edx+ecx*2], ax
		mov	cx, [ebp+var_818]
		add	cx, 1
		mov	[ebp+var_818], cx
		mov	dx, [ebp+var_800]
		add	dx, 1
		mov	[ebp+var_800], dx
		jmp	short loc_72682
; ---------------------------------------------------------------------------

loc_726E9:				; CODE XREF: singleCompactStage2(MBCSData *)+155j
		jmp	loc_727CC
; ---------------------------------------------------------------------------

loc_726EE:				; CODE XREF: singleCompactStage2(MBCSData *)+E4j
		movzx	eax, [ebp+var_818]
		movzx	ecx, [ebp+var_800]
		cmp	eax, ecx
		jge	loc_72794
		movzx	eax, [ebp+var_800]
		sar	eax, 6
		mov	cx, [ebp+var_818]
		mov	[ebp+eax*2+var_7E8], cx
		mov	eax, 40h ; '@'
		mov	[ebp+var_7F4], ax
		jmp	short loc_7273D
; ---------------------------------------------------------------------------

loc_7272B:				; CODE XREF: singleCompactStage2(MBCSData *)+248j
		mov	ax, [ebp+var_7F4]
		sub	ax, 1
		mov	[ebp+var_7F4], ax

loc_7273D:				; CODE XREF: singleCompactStage2(MBCSData *)+1E1j
		movzx	eax, [ebp+var_7F4]
		test	eax, eax
		jle	short loc_72792
		movzx	eax, [ebp+var_800]
		movzx	ecx, [ebp+var_818]
		mov	edx, [ebp+arg_0]
		mov	esi, [ebp+arg_0]
		mov	ax, ds:word_1089C[esi+eax*2]
		mov	ds:word_1089C[edx+ecx*2], ax
		mov	cx, [ebp+var_818]
		add	cx, 1
		mov	[ebp+var_818], cx
		mov	dx, [ebp+var_800]
		add	dx, 1
		mov	[ebp+var_800], dx
		jmp	short loc_7272B
; ---------------------------------------------------------------------------

loc_72792:				; CODE XREF: singleCompactStage2(MBCSData *)+1FEj
		jmp	short loc_727CC
; ---------------------------------------------------------------------------

loc_72794:				; CODE XREF: singleCompactStage2(MBCSData *)+1B6j
		movzx	eax, [ebp+var_800]
		sar	eax, 6
		mov	cx, [ebp+var_800]
		mov	[ebp+eax*2+var_7E8], cx
		movzx	eax, [ebp+var_818]
		add	eax, 40h ; '@'
		mov	[ebp+var_818], ax
		mov	cx, [ebp+var_818]
		mov	[ebp+var_800], cx

loc_727CC:				; CODE XREF: singleCompactStage2(MBCSData *):loc_726E9j
					; singleCompactStage2(MBCSData *):loc_72792j
		jmp	loc_72593
; ---------------------------------------------------------------------------

loc_727D1:				; CODE XREF: singleCompactStage2(MBCSData *)+5Bj
		movsx	eax, byte ptr ds:_VERBOSE
		test	eax, eax
		jz	short loc_7282C
		movzx	eax, [ebp+var_818]
		mov	ecx, [ebp+arg_0]
		cmp	eax, ds:dword_6EF20[ecx]
		jnb	short loc_7282C
		movzx	eax, [ebp+var_818]
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_6EF20[ecx]
		sub	edx, eax
		shl	edx, 1
		mov	esi, esp
		push	edx
		movzx	eax, [ebp+var_818]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_6EF20[ecx]
		push	edx
		push	offset ??_C@_0EE@JKLNCONI@compacting?5stage?52?5from?5stage2To@	; "compacting stage 2 from stage2Top=0x%lx"...
		call	dword ptr ds:__imp__printf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7282C:				; CODE XREF: singleCompactStage2(MBCSData *)+292j
					; singleCompactStage2(MBCSData *)+2A4j
		movzx	eax, [ebp+var_818]
		mov	ecx, [ebp+arg_0]
		mov	ds:dword_6EF20[ecx], eax
		xor	eax, eax
		mov	[ebp+var_7F4], ax
		jmp	short loc_72859
; ---------------------------------------------------------------------------

loc_72847:				; CODE XREF: singleCompactStage2(MBCSData *)+34Ej
		mov	ax, [ebp+var_7F4]
		add	ax, 1
		mov	[ebp+var_7F4], ax

loc_72859:				; CODE XREF: singleCompactStage2(MBCSData *)+2FDj
		movzx	eax, [ebp+var_7F4]
		cmp	eax, 440h
		jge	short loc_72898
		movzx	eax, [ebp+var_7F4]
		mov	ecx, [ebp+arg_0]
		movzx	edx, ds:word_1001C[ecx+eax*2]
		sar	edx, 6
		movzx	eax, [ebp+var_7F4]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ebp+edx*2+var_7E8]
		mov	ds:word_1001C[ecx+eax*2], dx
		jmp	short loc_72847
; ---------------------------------------------------------------------------

loc_72898:				; CODE XREF: singleCompactStage2(MBCSData *)+31Dj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN24
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 8DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?singleCompactStage2@@YAXPAUMBCSData@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN24		dd 1			; DATA XREF: singleCompactStage2(MBCSData *)+354o
		dd offset $LN23
$LN23		dd 0FFFFF818h, 7DEh	; DATA XREF: .text:000728CCo
		dd offset $LN22
$LN22		dd 70616Dh		; DATA XREF: .text:000728D8o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 728E0h
		public ??_C@_0EE@JKLNCONI@compacting?5stage?52?5from?5stage2To@
; char `string'[]
??_C@_0EE@JKLNCONI@compacting?5stage?52?5from?5stage2To@ db 'compacting stage 2 from stage2Top=0x%lx to 0x%lx, saving %ld byte'
					; DATA XREF: singleCompactStage2(MBCSData *)+2CFo
					; compactStage2(MBCSData *)+2C8o
		db 's',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72924h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl singleCompactStage3(struct MBCSData *)
?singleCompactStage3@@YAXPAUMBCSData@@@Z proc near
					; CODE XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+9Fp

var_2108	= byte ptr -2108h
var_2044	= word ptr -2044h
var_2038	= word ptr -2038h
var_202C	= word ptr -202Ch
var_2020	= word ptr -2020h
var_2014	= word ptr -2014h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, 2108h
		call	__chkstk
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_2108]
		mov	ecx, 842h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, ds:dword_6EF1C[eax]
		mov	[ebp+var_C], ecx
		xor	eax, eax
		mov	[ebp+var_2014],	ax
		mov	eax, 10h
		mov	[ebp+var_2044],	ax
		mov	cx, [ebp+var_2044]
		mov	[ebp+var_202C],	cx

loc_7297F:				; CODE XREF: singleCompactStage3(MBCSData *):loc_72BA0j
		movzx	eax, [ebp+var_202C]
		mov	ecx, [ebp+arg_0]
		cmp	eax, ds:dword_6EF24[ecx]
		jnb	loc_72BA5
		movzx	eax, [ebp+var_2044]
		sub	eax, 1
		mov	[ebp+var_2038],	ax
		xor	eax, eax
		mov	[ebp+var_2020],	ax
		jmp	short loc_729C3
; ---------------------------------------------------------------------------

loc_729B1:				; CODE XREF: singleCompactStage3(MBCSData *)+E1j
		mov	ax, [ebp+var_2020]
		add	ax, 1
		mov	[ebp+var_2020],	ax

loc_729C3:				; CODE XREF: singleCompactStage3(MBCSData *)+8Bj
		movzx	eax, [ebp+var_2020]
		cmp	eax, 10h
		jge	short loc_72A07
		movzx	eax, [ebp+var_202C]
		movzx	ecx, [ebp+var_2020]
		add	eax, ecx
		mov	edx, [ebp+var_C]
		movzx	eax, word ptr [edx+eax*2]
		test	eax, eax
		jnz	short loc_72A07
		movzx	eax, [ebp+var_2038]
		movzx	ecx, [ebp+var_2020]
		sub	eax, ecx
		mov	edx, [ebp+var_C]
		movzx	eax, word ptr [edx+eax*2]
		test	eax, eax
		jnz	short loc_72A07
		jmp	short loc_729B1
; ---------------------------------------------------------------------------

loc_72A07:				; CODE XREF: singleCompactStage3(MBCSData *)+A9j
					; singleCompactStage3(MBCSData *)+C4j ...
		movzx	eax, [ebp+var_2020]
		test	eax, eax
		jle	loc_72ACA
		movzx	eax, [ebp+var_2044]
		movzx	ecx, [ebp+var_2020]
		sub	eax, ecx
		movzx	edx, [ebp+var_202C]
		sar	edx, 4
		mov	[ebp+edx*2+var_2014], ax
		movzx	eax, [ebp+var_2020]
		movzx	ecx, [ebp+var_202C]
		add	ecx, eax
		mov	[ebp+var_202C],	cx
		movzx	eax, [ebp+var_2020]
		mov	ecx, 10h
		sub	ecx, eax
		mov	[ebp+var_2020],	cx
		jmp	short loc_72A78
; ---------------------------------------------------------------------------

loc_72A66:				; CODE XREF: singleCompactStage3(MBCSData *)+19Fj
		mov	ax, [ebp+var_2020]
		sub	ax, 1
		mov	[ebp+var_2020],	ax

loc_72A78:				; CODE XREF: singleCompactStage3(MBCSData *)+140j
		movzx	eax, [ebp+var_2020]
		test	eax, eax
		jle	short loc_72AC5
		movzx	eax, [ebp+var_202C]
		movzx	ecx, [ebp+var_2044]
		mov	edx, [ebp+var_C]
		mov	esi, [ebp+var_C]
		mov	ax, [esi+eax*2]
		mov	[edx+ecx*2], ax
		mov	cx, [ebp+var_2044]
		add	cx, 1
		mov	[ebp+var_2044],	cx
		mov	dx, [ebp+var_202C]
		add	dx, 1
		mov	[ebp+var_202C],	dx
		jmp	short loc_72A66
; ---------------------------------------------------------------------------

loc_72AC5:				; CODE XREF: singleCompactStage3(MBCSData *)+15Dj
		jmp	loc_72BA0
; ---------------------------------------------------------------------------

loc_72ACA:				; CODE XREF: singleCompactStage3(MBCSData *)+ECj
		movzx	eax, [ebp+var_2044]
		movzx	ecx, [ebp+var_202C]
		cmp	eax, ecx
		jge	loc_72B68
		movzx	eax, [ebp+var_202C]
		sar	eax, 4
		mov	cx, [ebp+var_2044]
		mov	[ebp+eax*2+var_2014], cx
		mov	eax, 10h
		mov	[ebp+var_2020],	ax
		jmp	short loc_72B19
; ---------------------------------------------------------------------------

loc_72B07:				; CODE XREF: singleCompactStage3(MBCSData *)+240j
		mov	ax, [ebp+var_2020]
		sub	ax, 1
		mov	[ebp+var_2020],	ax

loc_72B19:				; CODE XREF: singleCompactStage3(MBCSData *)+1E1j
		movzx	eax, [ebp+var_2020]
		test	eax, eax
		jle	short loc_72B66
		movzx	eax, [ebp+var_202C]
		movzx	ecx, [ebp+var_2044]
		mov	edx, [ebp+var_C]
		mov	esi, [ebp+var_C]
		mov	ax, [esi+eax*2]
		mov	[edx+ecx*2], ax
		mov	cx, [ebp+var_2044]
		add	cx, 1
		mov	[ebp+var_2044],	cx
		mov	dx, [ebp+var_202C]
		add	dx, 1
		mov	[ebp+var_202C],	dx
		jmp	short loc_72B07
; ---------------------------------------------------------------------------

loc_72B66:				; CODE XREF: singleCompactStage3(MBCSData *)+1FEj
		jmp	short loc_72BA0
; ---------------------------------------------------------------------------

loc_72B68:				; CODE XREF: singleCompactStage3(MBCSData *)+1B6j
		movzx	eax, [ebp+var_202C]
		sar	eax, 4
		mov	cx, [ebp+var_202C]
		mov	[ebp+eax*2+var_2014], cx
		movzx	eax, [ebp+var_2044]
		add	eax, 10h
		mov	[ebp+var_2044],	ax
		mov	cx, [ebp+var_2044]
		mov	[ebp+var_202C],	cx

loc_72BA0:				; CODE XREF: singleCompactStage3(MBCSData *):loc_72AC5j
					; singleCompactStage3(MBCSData *):loc_72B66j
		jmp	loc_7297F
; ---------------------------------------------------------------------------

loc_72BA5:				; CODE XREF: singleCompactStage3(MBCSData *)+6Bj
		movsx	eax, byte ptr ds:_VERBOSE
		test	eax, eax
		jz	short loc_72C00
		movzx	eax, [ebp+var_2044]
		mov	ecx, [ebp+arg_0]
		cmp	eax, ds:dword_6EF24[ecx]
		jnb	short loc_72C00
		movzx	eax, [ebp+var_2044]
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_6EF24[ecx]
		sub	edx, eax
		shl	edx, 1
		mov	esi, esp
		push	edx
		movzx	eax, [ebp+var_2044]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_6EF24[ecx]
		push	edx
		push	offset ??_C@_0EE@BOAKNGOC@compacting?5stage?53?5from?5stage3To@	; "compacting stage 3 from stage3Top=0x%lx"...
		call	dword ptr ds:__imp__printf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_72C00:				; CODE XREF: singleCompactStage3(MBCSData *)+28Aj
					; singleCompactStage3(MBCSData *)+29Cj
		movzx	eax, [ebp+var_2044]
		mov	ecx, [ebp+arg_0]
		mov	ds:dword_6EF24[ecx], eax
		xor	eax, eax
		mov	[ebp+var_2020],	ax
		jmp	short loc_72C2D
; ---------------------------------------------------------------------------

loc_72C1B:				; CODE XREF: singleCompactStage3(MBCSData *)+34Aj
		mov	ax, [ebp+var_2020]
		add	ax, 1
		mov	[ebp+var_2020],	ax

loc_72C2D:				; CODE XREF: singleCompactStage3(MBCSData *)+2F5j
		movzx	eax, [ebp+var_2020]
		mov	ecx, [ebp+arg_0]
		cmp	eax, ds:dword_6EF20[ecx]
		jnb	short loc_72C70
		movzx	eax, [ebp+var_2020]
		mov	ecx, [ebp+arg_0]
		movzx	edx, ds:word_1089C[ecx+eax*2]
		sar	edx, 4
		movzx	eax, [ebp+var_2020]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ebp+edx*2+var_2014]
		mov	ds:word_1089C[ecx+eax*2], dx
		jmp	short loc_72C1B
; ---------------------------------------------------------------------------

loc_72C70:				; CODE XREF: singleCompactStage3(MBCSData *)+319j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN24_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 2108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?singleCompactStage3@@YAXPAUMBCSData@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN24_0		dd 1			; DATA XREF: singleCompactStage3(MBCSData *)+350o
		dd offset $LN23_0
$LN23_0		dd 0FFFFDFECh, 2000h	; DATA XREF: .text:00072CA4o
		dd offset $LN22_0
$LN22_0		dd 70616Dh		; DATA XREF: .text:00072CB0o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 72CB8h
		public ??_C@_0EE@BOAKNGOC@compacting?5stage?53?5from?5stage3To@
; char `string'[]
??_C@_0EE@BOAKNGOC@compacting?5stage?53?5from?5stage3To@ db 'compacting stage 3 from stage3Top=0x%lx to 0x%lx, saving %ld byte'
					; DATA XREF: singleCompactStage3(MBCSData *)+2C7o
		db 's',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72CFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl compactStage2(struct MBCSData *)
?compactStage2@@YAXPAUMBCSData@@@Z proc	near
					; CODE XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+B9p

var_8DC		= byte ptr -8DCh
var_818		= word ptr -818h
var_80C		= word ptr -80Ch
var_800		= word ptr -800h
var_7F4		= word ptr -7F4h
var_7E8		= word ptr -7E8h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_8DC]
		mov	ecx, 237h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		mov	[ebp+var_7E8], ax
		mov	eax, 40h ; '@'
		mov	[ebp+var_818], ax
		mov	cx, [ebp+var_818]
		mov	[ebp+var_800], cx

loc_72D47:				; CODE XREF: compactStage2(MBCSData *):loc_72F78j
		movzx	eax, [ebp+var_800]
		mov	ecx, [ebp+arg_0]
		cmp	eax, ds:dword_6EF20[ecx]
		jnb	loc_72F7D
		movzx	eax, [ebp+var_818]
		sub	eax, 1
		mov	[ebp+var_80C], ax
		xor	eax, eax
		mov	[ebp+var_7F4], ax
		jmp	short loc_72D8B
; ---------------------------------------------------------------------------

loc_72D79:				; CODE XREF: compactStage2(MBCSData *)+D5j
		mov	ax, [ebp+var_7F4]
		add	ax, 1
		mov	[ebp+var_7F4], ax

loc_72D8B:				; CODE XREF: compactStage2(MBCSData *)+7Bj
		movzx	eax, [ebp+var_7F4]
		cmp	eax, 40h ; '@'
		jge	short loc_72DD3
		movzx	eax, [ebp+var_800]
		movzx	ecx, [ebp+var_7F4]
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		cmp	ds:dword_3001C[edx+eax*4], 0
		jnz	short loc_72DD3
		movzx	eax, [ebp+var_80C]
		movzx	ecx, [ebp+var_7F4]
		sub	eax, ecx
		mov	edx, [ebp+arg_0]
		cmp	ds:dword_3001C[edx+eax*4], 0
		jnz	short loc_72DD3
		jmp	short loc_72D79
; ---------------------------------------------------------------------------

loc_72DD3:				; CODE XREF: compactStage2(MBCSData *)+99j
					; compactStage2(MBCSData *)+B6j ...
		movzx	eax, [ebp+var_7F4]
		test	eax, eax
		jle	loc_72E9C
		movzx	eax, [ebp+var_818]
		movzx	ecx, [ebp+var_7F4]
		sub	eax, ecx
		movzx	edx, [ebp+var_800]
		sar	edx, 6
		mov	[ebp+edx*2+var_7E8], ax
		movzx	eax, [ebp+var_7F4]
		movzx	ecx, [ebp+var_800]
		add	ecx, eax
		mov	[ebp+var_800], cx
		movzx	eax, [ebp+var_7F4]
		mov	ecx, 40h ; '@'
		sub	ecx, eax
		mov	[ebp+var_7F4], cx
		jmp	short loc_72E44
; ---------------------------------------------------------------------------

loc_72E32:				; CODE XREF: compactStage2(MBCSData *)+199j
		mov	ax, [ebp+var_7F4]
		sub	ax, 1
		mov	[ebp+var_7F4], ax

loc_72E44:				; CODE XREF: compactStage2(MBCSData *)+134j
		movzx	eax, [ebp+var_7F4]
		test	eax, eax
		jle	short loc_72E97
		movzx	eax, [ebp+var_800]
		movzx	ecx, [ebp+var_818]
		mov	edx, [ebp+arg_0]
		mov	esi, [ebp+arg_0]
		mov	eax, ds:dword_3001C[esi+eax*4]
		mov	ds:dword_3001C[edx+ecx*4], eax
		mov	cx, [ebp+var_818]
		add	cx, 1
		mov	[ebp+var_818], cx
		mov	dx, [ebp+var_800]
		add	dx, 1
		mov	[ebp+var_800], dx
		jmp	short loc_72E32
; ---------------------------------------------------------------------------

loc_72E97:				; CODE XREF: compactStage2(MBCSData *)+151j
		jmp	loc_72F78
; ---------------------------------------------------------------------------

loc_72E9C:				; CODE XREF: compactStage2(MBCSData *)+E0j
		movzx	eax, [ebp+var_818]
		movzx	ecx, [ebp+var_800]
		cmp	eax, ecx
		jge	loc_72F40
		movzx	eax, [ebp+var_800]
		sar	eax, 6
		mov	cx, [ebp+var_818]
		mov	[ebp+eax*2+var_7E8], cx
		mov	eax, 40h ; '@'
		mov	[ebp+var_7F4], ax
		jmp	short loc_72EEB
; ---------------------------------------------------------------------------

loc_72ED9:				; CODE XREF: compactStage2(MBCSData *)+240j
		mov	ax, [ebp+var_7F4]
		sub	ax, 1
		mov	[ebp+var_7F4], ax

loc_72EEB:				; CODE XREF: compactStage2(MBCSData *)+1DBj
		movzx	eax, [ebp+var_7F4]
		test	eax, eax
		jle	short loc_72F3E
		movzx	eax, [ebp+var_800]
		movzx	ecx, [ebp+var_818]
		mov	edx, [ebp+arg_0]
		mov	esi, [ebp+arg_0]
		mov	eax, ds:dword_3001C[esi+eax*4]
		mov	ds:dword_3001C[edx+ecx*4], eax
		mov	cx, [ebp+var_818]
		add	cx, 1
		mov	[ebp+var_818], cx
		mov	dx, [ebp+var_800]
		add	dx, 1
		mov	[ebp+var_800], dx
		jmp	short loc_72ED9
; ---------------------------------------------------------------------------

loc_72F3E:				; CODE XREF: compactStage2(MBCSData *)+1F8j
		jmp	short loc_72F78
; ---------------------------------------------------------------------------

loc_72F40:				; CODE XREF: compactStage2(MBCSData *)+1B0j
		movzx	eax, [ebp+var_800]
		sar	eax, 6
		mov	cx, [ebp+var_800]
		mov	[ebp+eax*2+var_7E8], cx
		movzx	eax, [ebp+var_818]
		add	eax, 40h ; '@'
		mov	[ebp+var_818], ax
		mov	cx, [ebp+var_818]
		mov	[ebp+var_800], cx

loc_72F78:				; CODE XREF: compactStage2(MBCSData *):loc_72E97j
					; compactStage2(MBCSData *):loc_72F3Ej
		jmp	loc_72D47
; ---------------------------------------------------------------------------

loc_72F7D:				; CODE XREF: compactStage2(MBCSData *)+5Bj
		movsx	eax, byte ptr ds:_VERBOSE
		test	eax, eax
		jz	short loc_72FD9
		movzx	eax, [ebp+var_818]
		mov	ecx, [ebp+arg_0]
		cmp	eax, ds:dword_6EF20[ecx]
		jnb	short loc_72FD9
		movzx	eax, [ebp+var_818]
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_6EF20[ecx]
		sub	edx, eax
		shl	edx, 2
		mov	esi, esp
		push	edx
		movzx	eax, [ebp+var_818]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, ds:dword_6EF20[ecx]
		push	edx
		push	offset ??_C@_0EE@JKLNCONI@compacting?5stage?52?5from?5stage2To@	; "compacting stage 2 from stage2Top=0x%lx"...
		call	dword ptr ds:__imp__printf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_72FD9:				; CODE XREF: compactStage2(MBCSData *)+28Aj
					; compactStage2(MBCSData *)+29Cj
		movzx	eax, [ebp+var_818]
		mov	ecx, [ebp+arg_0]
		mov	ds:dword_6EF20[ecx], eax
		xor	eax, eax
		mov	[ebp+var_7F4], ax
		jmp	short loc_73006
; ---------------------------------------------------------------------------

loc_72FF4:				; CODE XREF: compactStage2(MBCSData *)+347j
		mov	ax, [ebp+var_7F4]
		add	ax, 1
		mov	[ebp+var_7F4], ax

loc_73006:				; CODE XREF: compactStage2(MBCSData *)+2F6j
		movzx	eax, [ebp+var_7F4]
		cmp	eax, 440h
		jge	short loc_73045
		movzx	eax, [ebp+var_7F4]
		mov	ecx, [ebp+arg_0]
		movzx	edx, ds:word_1001C[ecx+eax*2]
		sar	edx, 6
		movzx	eax, [ebp+var_7F4]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ebp+edx*2+var_7E8]
		mov	ds:word_1001C[ecx+eax*2], dx
		jmp	short loc_72FF4
; ---------------------------------------------------------------------------

loc_73045:				; CODE XREF: compactStage2(MBCSData *)+316j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN24_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 8DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?compactStage2@@YAXPAUMBCSData@@@Z endp

; ---------------------------------------------------------------------------
$LN24_1		dd 1			; DATA XREF: compactStage2(MBCSData *)+34Do
		dd offset $LN23_1
$LN23_1		dd 0FFFFF818h, 7DEh	; DATA XREF: .text:00073078o
		dd offset $LN22_1
$LN22_1		dd 70616Dh		; DATA XREF: .text:00073084o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7308Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl MBCSWrite(struct	NewConverter *,	struct UConverterStaticData const *, struct UNewDataMemory *, int)
?MBCSWrite@@YAIPAUNewConverter@@PBUUConverterStaticData@@PAUUNewDataMemory@@H@Z	proc near
					; DATA XREF: MBCSInit(MBCSData *,UCMFile *)+5Ao

var_16C		= byte ptr -16Ch
var_A8		= dword	ptr -0A8h
var_9C		= dword	ptr -9Ch
var_90		= byte ptr -90h
var_8F		= word ptr -8Fh
var_8D		= byte ptr -8Dh
var_8C		= dword	ptr -8Ch
var_88		= dword	ptr -88h
var_84		= dword	ptr -84h
var_80		= dword	ptr -80h
var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_74		= dword	ptr -74h
var_70		= dword	ptr -70h
var_6C		= dword	ptr -6Ch
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 16Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_16C]
		mov	ecx, 5Bh ; '['
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C], eax
		mov	[ebp+var_3C], 0
		mov	[ebp+var_90], 0
		xor	eax, eax
		mov	[ebp+var_8F], ax
		mov	[ebp+var_8D], al
		mov	[ebp+var_8C], 0
		mov	[ebp+var_88], 0
		mov	[ebp+var_84], 0
		mov	[ebp+var_80], 0
		mov	[ebp+var_7C], 0
		mov	[ebp+var_78], 0
		mov	[ebp+var_74], 0
		mov	[ebp+var_70], 0
		mov	[ebp+var_6C], 0
		mov	eax, [ebp+var_C]
		mov	ecx, ds:dword_6EF20[eax]
		mov	[ebp+var_24], ecx
		mov	eax, [ebp+var_C]
		movsx	ecx, ds:byte_6F72B[eax]
		test	ecx, ecx
		jz	loc_7325C
		mov	eax, [ebp+var_C]
		movzx	ecx, ds:word_6F728[eax]
		add	ecx, 1
		mov	[ebp+var_9C], ecx
		mov	[ebp+var_A8], 0
		mov	eax, [ebp+var_9C]
		sar	eax, 0Ah
		mov	[ebp+var_48], eax
		mov	eax, [ebp+var_9C]
		and	eax, 3FFh
		jz	short loc_731A7
		mov	eax, [ebp+var_48]
		mov	ecx, [ebp+var_C]
		movzx	edx, ds:word_1001C[ecx+eax*2]
		mov	[ebp+var_A8], edx
		cmp	[ebp+var_A8], 0
		jz	short loc_731A7
		mov	eax, [ebp+var_9C]
		sar	eax, 4
		and	eax, 3Fh
		add	eax, [ebp+var_A8]
		mov	[ebp+var_18], eax
		jmp	short loc_731E1
; ---------------------------------------------------------------------------

loc_731A7:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+E5j
					; MBCSWrite(NewConverter *,UConverterStaticData	const *,UNewDataMemory *,int)+102j ...
		cmp	[ebp+var_48], 0
		jle	short loc_731D5
		mov	eax, [ebp+var_48]
		sub	eax, 1
		mov	[ebp+var_48], eax
		mov	ecx, [ebp+var_48]
		mov	edx, [ebp+var_C]
		movzx	eax, ds:word_1001C[edx+ecx*2]
		mov	[ebp+var_A8], eax
		cmp	[ebp+var_A8], 0
		jnz	short loc_731D5
		jmp	short loc_731A7
; ---------------------------------------------------------------------------

loc_731D5:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+11Fj
					; MBCSWrite(NewConverter *,UConverterStaticData	const *,UNewDataMemory *,int)+145j
		mov	eax, [ebp+var_A8]
		add	eax, 40h ; '@'
		mov	[ebp+var_18], eax

loc_731E1:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+119j
		mov	eax, [ebp+var_70]
		or	eax, 40h
		mov	[ebp+var_70], eax
		mov	eax, [ebp+var_24]
		mov	[ebp+var_6C], eax
		mov	eax, [ebp+var_24]
		sub	eax, [ebp+var_18]
		mov	[ebp+var_24], eax
		movsx	eax, byte ptr ds:_VERBOSE
		test	eax, eax
		jz	short loc_7325A
		mov	esi, esp
		mov	eax, [ebp+var_C]
		mov	ecx, ds:dword_6EF24[eax]
		push	ecx
		mov	edx, [ebp+var_C]
		mov	eax, ds:dword_6EF20[edx]
		push	eax
		mov	ecx, [ebp+var_18]
		push	ecx
		push	offset ??_C@_0DN@KGEGBIPJ@?$CL?5omitting?5?$CFlu?5out?5of?5?$CFlu?5stage2@ ; "+	omitting %lu out of %lu	stage2 entrie"...
		call	dword ptr ds:__imp__printf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_C]
		mov	ecx, ds:dword_6EF24[eax]
		mov	edx, [ebp+var_18]
		lea	eax, [ecx+edx*4]
		mov	esi, esp
		push	eax
		push	offset ??_C@_0CB@FBPIBKCK@?$CL?5total?5size?5savings?3?5?$CFlu?5bytes?6@ ; "+ total size savings: %lu bytes\n"
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7325A:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+176j
		jmp	short loc_73263
; ---------------------------------------------------------------------------

loc_7325C:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+ABj
		mov	[ebp+var_18], 0

loc_73263:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int):loc_7325Aj
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax+4Fh]
		and	ecx, 1
		jz	short loc_73278
		mov	[ebp+var_54], 440h
		jmp	short loc_7327F
; ---------------------------------------------------------------------------

loc_73278:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+1E1j
		mov	[ebp+var_54], 40h ; '@'

loc_7327F:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+1EAj
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+10h]
		cmp	ds:dword_20410[ecx], 1
		jnz	short loc_73307
		mov	[ebp+var_48], 0
		jmp	short loc_732A0
; ---------------------------------------------------------------------------

loc_73297:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+23Ej
		mov	eax, [ebp+var_48]
		add	eax, 1
		mov	[ebp+var_48], eax

loc_732A0:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+209j
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_54]
		jge	short loc_732CC
		movzx	eax, word ptr [ebp+var_54]
		mov	ecx, [ebp+var_48]
		mov	edx, [ebp+var_C]
		movzx	ecx, ds:word_1001C[edx+ecx*2]
		add	ecx, eax
		mov	edx, [ebp+var_48]
		mov	eax, [ebp+var_C]
		mov	ds:word_1001C[eax+edx*2], cx
		jmp	short loc_73297
; ---------------------------------------------------------------------------

loc_732CC:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+21Aj
		mov	eax, [ebp+var_24]
		lea	ecx, [eax+eax+1]
		and	ecx, 0FFFFFFFEh
		mov	[ebp+var_24], ecx
		mov	eax, [ebp+var_C]
		mov	ecx, ds:dword_6EF24[eax]
		shl	ecx, 1
		mov	edx, [ebp+var_C]
		mov	ds:dword_6EF24[edx], ecx
		mov	eax, [ebp+var_C]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	short loc_73302
		mov	byte ptr [ebp+var_8F+1], 1Fh

loc_73302:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+26Dj
		jmp	loc_73387
; ---------------------------------------------------------------------------

loc_73307:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+200j
		mov	[ebp+var_48], 0
		jmp	short loc_73319
; ---------------------------------------------------------------------------

loc_73310:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+2BCj
		mov	eax, [ebp+var_48]
		add	eax, 1
		mov	[ebp+var_48], eax

loc_73319:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+282j
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_54]
		jge	short loc_7334A
		movzx	eax, word ptr [ebp+var_54]
		cdq
		sub	eax, edx
		sar	eax, 1
		mov	ecx, [ebp+var_48]
		mov	edx, [ebp+var_C]
		movzx	ecx, ds:word_1001C[edx+ecx*2]
		add	ecx, eax
		mov	edx, [ebp+var_48]
		mov	eax, [ebp+var_C]
		mov	ds:word_1001C[eax+edx*2], cx
		jmp	short loc_73310
; ---------------------------------------------------------------------------

loc_7334A:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+293j
		mov	eax, [ebp+var_24]
		shl	eax, 2
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_C]
		movsx	ecx, ds:byte_6F72A[eax]
		test	ecx, ecx
		jz	short loc_73387
		mov	eax, [ebp+var_C]
		movzx	ecx, ds:word_6F728[eax]
		add	ecx, 1
		sar	ecx, 6
		mov	[ebp+var_3C], ecx
		mov	eax, [ebp+var_C]
		movzx	ecx, ds:word_6F728[eax]
		sar	ecx, 8
		mov	byte ptr [ebp+var_8F+1], cl

loc_73387:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int):loc_73302j
					; MBCSWrite(NewConverter *,UConverterStaticData	const *,UNewDataMemory *,int)+2D3j
		mov	eax, [ebp+var_C]
		mov	ecx, ds:dword_6EF24[eax]
		add	ecx, 3
		and	ecx, 0FFFFFFFCh
		mov	edx, [ebp+var_C]
		mov	ds:dword_6EF24[edx], ecx
		mov	eax, [ebp+var_70]
		and	eax, 0FFC0h
		jz	short loc_733CA
		mov	[ebp+var_90], 5
		mov	eax, [ebp+var_70]
		and	eax, 40h
		jz	short loc_733C1
		mov	[ebp+var_60], 0Ah
		jmp	short loc_733C8
; ---------------------------------------------------------------------------

loc_733C1:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+32Aj
		mov	[ebp+var_60], 9

loc_733C8:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+333j
		jmp	short loc_733D8
; ---------------------------------------------------------------------------

loc_733CA:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+31Bj
		mov	[ebp+var_90], 4
		mov	[ebp+var_60], 8

loc_733D8:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int):loc_733C8j
		mov	byte ptr [ebp+var_8F], 4
		mov	eax, [ebp+var_70]
		or	eax, [ebp+var_60]
		mov	[ebp+var_70], eax
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+10h]
		mov	edx, ds:dword_20408[ecx]
		mov	[ebp+var_8C], edx
		mov	eax, [ebp+var_C]
		mov	ecx, ds:dword_10014[eax]
		mov	[ebp+var_88], ecx
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+10h]
		mov	edx, ds:dword_20408[ecx]
		shl	edx, 0Ah
		mov	eax, [ebp+var_60]
		lea	ecx, [edx+eax*4]
		mov	edx, [ebp+var_C]
		mov	eax, ds:dword_10014[edx]
		lea	ecx, [ecx+eax*8]
		mov	[ebp+var_84], ecx
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+10h]
		mov	edx, ds:dword_20414[ecx]
		mov	eax, [ebp+var_84]
		lea	ecx, [eax+edx*2]
		mov	[ebp+var_80], ecx
		mov	eax, [ebp+var_54]
		mov	ecx, [ebp+var_80]
		lea	edx, [ecx+eax*2]
		add	edx, [ebp+var_24]
		mov	[ebp+var_7C], edx
		mov	eax, [ebp+var_C]
		mov	ecx, ds:dword_6EF24[eax]
		mov	[ebp+var_74], ecx
		mov	eax, [ebp+var_3C]
		mov	ecx, [ebp+var_7C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_30], edx
		mov	eax, [ebp+var_70]
		and	eax, 40h
		jnz	short loc_73480
		mov	eax, [ebp+var_30]
		add	eax, [ebp+var_74]
		mov	[ebp+var_30], eax

loc_73480:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+3E9j
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+10h]
		movzx	edx, ds:byte_20419[ecx]
		mov	[ebp+var_78], edx
		mov	eax, [ebp+arg_C]
		and	eax, 2
		jz	short loc_734E2
		cmp	[ebp+var_30], 0FFFFFFh
		jbe	short loc_734D6
		mov	esi, esp
		mov	eax, [ebp+var_30]
		push	eax
		push	offset ??_C@_0DJ@MAFGALNE@error?3?5offset?50x?$CFlx?5to?5extension@ ; "error: offset 0x%lx to extension	table "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	eax, eax
		jmp	loc_73617
; ---------------------------------------------------------------------------

loc_734D6:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+413j
		mov	eax, [ebp+var_30]
		shl	eax, 8
		or	eax, [ebp+var_78]
		mov	[ebp+var_78], eax

loc_734E2:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+40Aj
		mov	eax, [ebp+var_60]
		shl	eax, 2
		push	eax
		lea	ecx, [ebp+var_90]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_udata_writeBlock
		add	esp, 0Ch
		mov	eax, [ebp+var_8C]
		shl	eax, 0Ah
		push	eax
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx+10h]
		add	edx, 8
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		call	_udata_writeBlock
		add	esp, 0Ch
		mov	eax, [ebp+var_C]
		mov	ecx, ds:dword_10014[eax]
		shl	ecx, 3
		push	ecx
		mov	edx, [ebp+var_C]
		add	edx, 14h
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		call	_udata_writeBlock
		add	esp, 0Ch
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+10h]
		mov	edx, ds:dword_20414[ecx]
		shl	edx, 1
		push	edx
		mov	eax, [ebp+var_C]
		mov	ecx, ds:dword_10018[eax]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_udata_writeBlock
		add	esp, 0Ch
		mov	eax, [ebp+var_54]
		shl	eax, 1
		push	eax
		mov	ecx, [ebp+var_C]
		add	ecx, offset word_1001C
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_udata_writeBlock
		add	esp, 0Ch
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+10h]
		cmp	ds:dword_20410[ecx], 1
		jnz	short loc_735AC
		mov	eax, [ebp+var_24]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ebp+var_C]
		lea	eax, word_1089C[edx+ecx*2]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	_udata_writeBlock
		add	esp, 0Ch
		jmp	short loc_735CA
; ---------------------------------------------------------------------------

loc_735AC:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+4FEj
		mov	eax, [ebp+var_24]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ebp+var_C]
		lea	eax, dword_3001C[edx+ecx*4]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	_udata_writeBlock
		add	esp, 0Ch

loc_735CA:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+51Ej
		mov	eax, [ebp+var_70]
		and	eax, 40h
		jnz	short loc_735F2
		mov	eax, [ebp+var_C]
		mov	ecx, ds:dword_6EF24[eax]
		push	ecx
		mov	edx, [ebp+var_C]
		mov	eax, ds:dword_6EF1C[edx]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	_udata_writeBlock
		add	esp, 0Ch

loc_735F2:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+544j
		cmp	[ebp+var_3C], 0
		jbe	short loc_73614
		mov	eax, [ebp+var_3C]
		shl	eax, 1
		push	eax
		mov	ecx, [ebp+var_C]
		add	ecx, offset word_6EF28
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_udata_writeBlock
		add	esp, 0Ch

loc_73614:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+56Aj
		mov	eax, [ebp+var_30]

loc_73617:				; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+445j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN35
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 16Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MBCSWrite@@YAIPAUNewConverter@@PBUUConverterStaticData@@PAUUNewDataMemory@@H@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN35		dd 1			; DATA XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+58Fo
		dd offset $LN34
$LN34		dd 0FFFFFF70h, 28h	; DATA XREF: .text:0007364Co
		dd offset $LN33		; "header"
$LN33		db 'header',0           ; DATA XREF: .text:00073658o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 73664h
		public ??_C@_0DJ@MAFGALNE@error?3?5offset?50x?$CFlx?5to?5extension@
; char `string'[]
??_C@_0DJ@MAFGALNE@error?3?5offset?50x?$CFlx?5to?5extension@ db	'error: offset 0x%lx to extension table exceeds 0xffffff',0Ah,0
					; DATA XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+41Bo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 736A0h
		public ??_C@_0CB@FBPIBKCK@?$CL?5total?5size?5savings?3?5?$CFlu?5bytes?6@
; char `string'[]
??_C@_0CB@FBPIBKCK@?$CL?5total?5size?5savings?3?5?$CFlu?5bytes?6@ db '+ total size savings: %lu bytes',0Ah,0
					; DATA XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+1B9o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 736C4h
		public ??_C@_0DN@KGEGBIPJ@?$CL?5omitting?5?$CFlu?5out?5of?5?$CFlu?5stage2@
; char `string'[]
??_C@_0DN@KGEGBIPJ@?$CL?5omitting?5?$CFlu?5out?5of?5?$CFlu?5stage2@ db '+ omitting %lu out of %lu stage2 entries and %lu fromUBytes',0Ah,0
					; DATA XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+192o
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _SMALL:near	; DATA XREF: _MBCSGetDummy+39r
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+B6r ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _MBCSGetDummy+2Ap
					; MBCSInit(MBCSData *,UCMFile *)+29p ...
		extrn __RTC_CheckEsp:near ; CODE XREF: _MBCSGetDummy+73p
					; _MBCSOpen+46p ...
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; void __cdecl __noreturn _exit(int Code)
		extrn __imp__exit:near	; CODE XREF: _MBCSOpen+4Fp
					; DATA XREF: _MBCSOpen+4Fr
; int _printf(const char *Format, ...)
		extrn __imp__printf:near ; CODE	XREF: _MBCSOpen+3Bp
					; MBCSStartMappings(MBCSData *)+47p ...
		extrn _uprv_malloc_56:near ; CODE XREF:	_MBCSOpen+23p
					; MBCSStartMappings(MBCSData *)+67p ...
		extrn _uprv_free_56:near ; CODE	XREF: MBCSClose(NewConverter *)+3Ap
					; MBCSDestruct(MBCSData	*)+28p	...
		extrn _ucm_countChars:near
					; CODE XREF: MBCSIsValid(NewConverter *,uchar const *,int)+36p
; int _fprintf(FILE *File, const char *Format, ...)
		extrn __imp__fprintf:near
					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+50p
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+10Ap ...
; FILE *__cdecl	___iob_func()
		extrn __imp____iob_func:near
					; CODE XREF: MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+3Fp
					; MBCSAddTable(NewConverter *,UCMTable *,UConverterStaticData *)+F9p ...
		extrn _VERBOSE:near	; DATA XREF: MBCSStartMappings(MBCSData	*)+2Dr
					; MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char):loc_707C9r ...
		extrn ___security_cookie:near
					; DATA XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+1Er
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+1Er	...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+88Dp
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+783p ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: MBCSAddToUnicode(MBCSData *,uchar const *,int,int,signed char)+87Ep
					; MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed char)+774p ...
		extrn _ucm_findFallback:near
					; CODE XREF: setFallback(MBCSData *,uint,int)+33p
					; removeFallback(MBCSData *,uint)+33p
		extrn _IGNORE_SISO_CHECK:near
					; DATA XREF: MBCSAddFromUnicode(MBCSData *,uchar const *,int,int,signed	char)+49r
		extrn _ucm_optimizeStates:near
					; CODE XREF: MBCSPostprocess(MBCSData *,UConverterStaticData const *)+63p
		extrn __chkstk:near	; CODE XREF: singleCompactStage3(MBCSData *)+8p
		extrn _udata_writeBlock:near
					; CODE XREF: MBCSWrite(NewConverter *,UConverterStaticData const *,UNewDataMemory *,int)+468p
					; MBCSWrite(NewConverter *,UConverterStaticData	const *,UNewDataMemory *,int)+488p ...


		end
