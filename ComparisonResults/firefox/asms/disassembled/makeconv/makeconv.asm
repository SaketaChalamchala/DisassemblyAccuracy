;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	706DFF151950B4F84D8C16168A893C3E
; Input	CRC32 :	E9B5F6EC

; File Name   :	D:\compspace\objfiles\firefox\makeconv\makeconv.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		public ??_C@_05PMBAOCDH@quiet?$AA@
; `string'
??_C@_05PMBAOCDH@quiet?$AA@ db 'quiet',0 ; DATA XREF: .data:00000204o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ??_C@_0BC@IGJCHNOE@ignore?9siso?9check?$AA@
; `string'
??_C@_0BC@IGJCHNOE@ignore?9siso?9check?$AA@ db 'ignore-siso-check',0
					; DATA XREF: .data:000001F0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ??_C@_05KJDGBEEG@small?$AA@
; `string'
??_C@_05KJDGBEEG@small?$AA@ db 'small',0 ; DATA XREF: .data:000001DCo
					; .rdata:int const std::_Locbase<int>::messageso ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ??_C@_07KBAMPNJK@verbose?$AA@
; `string'
??_C@_07KBAMPNJK@verbose?$AA@ db 'verbose',0 ; DATA XREF: .data:000001C8o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ??_C@_07HIFNFPHK@destdir?$AA@
; `string'
??_C@_07HIFNFPHK@destdir?$AA@ db 'destdir',0 ; DATA XREF: .data:000001B4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ??_C@_07CPCPJPKL@version?$AA@
; `string'
??_C@_07CPCPJPKL@version?$AA@ db 'version',0 ; DATA XREF: .data:000001A0o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ??_C@_09JHBDCMB@copyright?$AA@
; `string'
??_C@_09JHBDCMB@copyright?$AA@ db 'copyright',0 ; DATA XREF: .data:0000018Co
					; .rdata:int const std::_Locbase<int>::allo ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ??_C@_04PCJFHION@help?$AA@
; `string'
??_C@_04PCJFHION@help?$AA@ db 'help',0  ; DATA XREF: .data:_optionso
					; .data:00000178o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ??_C@_05KJDGBEEG@small?$AA@+4	; "l"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ??_C@_09JHBDCMB@copyright?$AA@+3 ;	"yright"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_05KJDGBEEG@small?$AA@+4 ; "l"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_09JHBDCMB@copyright?$AA@+4 ; "right"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?_Rank@?$_Arithmetic_traits@K@std@@2HB ; int const std::_Arithmetic_traits<ulong>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefield
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	byte_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset ??_C@_0BEA@MBIOMLNL@?7?5?5?5?5?5?5?9?9small?5?5?5?5?5?5?5Generate?5sm@+100h ; "	   --ignore-siso-check	       Use SI"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ??_C@_0DK@DHKEHOLK@error?3?5the?5?$DMicu?3base?$DO?5file?5?$CC?$CFs?$CC?5@+24h ; "ot a base table file\n"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 3000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0FCh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 100h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_0DG@BIFONMIB@Error?5creating?5converter?5for?5?$CC?$CFs@+20h
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
_rdata		ends			; "\" file for \"%s\" (%s)\n"

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 104h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	3000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 108h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10Ch
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 110h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 114h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 118h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 11Ch
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 120h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 124h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 128h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 12Ch
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 130h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ??_C@_09JHBDCMB@copyright?$AA@+4 ; "right"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 134h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?_Rank@?$_Arithmetic_traits@K@std@@2HB ;	int const std::_Arithmetic_traits<ulong>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 138h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ??_C@_05KJDGBEEG@small?$AA@+4 ; "l"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 13Ch
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 140h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 144h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 148h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public _VERBOSE
_VERBOSE	db ?			; DATA XREF: _main+212w _main+342r ...
		public ?QUIET@@3CA
; signed char QUIET
?QUIET@@3CA	db ?			; DATA XREF: _main+21Cw _main+772r
		public _SMALL
_SMALL		db ?			; DATA XREF: _main+226w
		public _IGNORE_SISO_CHECK
_IGNORE_SISO_CHECK db ?			; DATA XREF: _main+236w
					; readFile(ConvData *,char const *,UErrorCode *)+D6r
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 14Ch
		public ?haveCopyright@@3CA
; signed char haveCopyright
?haveCopyright@@3CA db 1		; DATA XREF: _main+1FDw
					; writeConverterData(ConvData *,char const *,char const	*,UErrorCode *)+75r
		align 10h
_dataInfo	dd 14h,	20000h,	74766E63h
					; DATA XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+87o
byte_15C	db 6			; DATA XREF: _main+1AEr
byte_15D	db 2			; DATA XREF: _main+1A4r
		align 10h
dword_160	dd 0			; DATA XREF: _main+69o
_options	dd offset ??_C@_04PCJFHION@help?$AA@ ; DATA XREF: .data:000001C4o
					; _main+80o
					; "help"
		dd 3 dup(0)
		db 68h,	0
byte_176	db 0			; DATA XREF: _main+EBr
		align 4
		dd offset ??_C@_04PCJFHION@help?$AA@ ; "help"
		dd 3 dup(0)
		db 3Fh,	0
byte_18A	db 0			; DATA XREF: _main+F6r
		align 4
		dd offset ??_C@_09JHBDCMB@copyright?$AA@ ; "copyright"
		dd 3 dup(0)
		db 63h,	0
byte_19E	db 0			; DATA XREF: _main:loc_478r
		align 10h
		dd offset ??_C@_07CPCPJPKL@version?$AA@	; "version"
		align 10h
		db 56h,	0
byte_1B2	db 0			; DATA XREF: _main:loc_419r
		align 4
		dd offset ??_C@_07HIFNFPHK@destdir?$AA@	; "destdir"
dword_1B8	dd 0			; DATA XREF: _main+7Bw	_main+202r
		align 10h
dword_1C0	dd 0			; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		dd offset _options
		dd offset ??_C@_07KBAMPNJK@verbose?$AA@	; "verbose"
		dd 3 dup(0)
		db 76h,	0
byte_1DA	db 0			; DATA XREF: _main+20Dr
		align 4
		dd offset ??_C@_05KJDGBEEG@small?$AA@ ;	"small"
		dd 3 dup(0)
		db 1, 0
byte_1EE	db 0			; DATA XREF: _main+221r
		align 10h
		dd offset ??_C@_0BC@IGJCHNOE@ignore?9siso?9check?$AA@ ;	"ignore-siso-check"
		align 10h
byte_200	db 1, 0			; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
byte_202	db 0			; DATA XREF: _main+22Br
		align 4
		dd offset ??_C@_05PMBAOCDH@quiet?$AA@ ;	"quiet"
		dd 3 dup(0)
		db 71h,	0
byte_216	db 0			; DATA XREF: _main+217r
		align 4
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 218h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_isInvariantUnicodeString(icu_56::UnicodeString *)
		public _uprv_isInvariantUnicodeString
_uprv_isInvariantUnicodeString proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ;	icu_56::UnicodeString::getBuffer(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	_uprv_isInvariantUString_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_isInvariantUnicodeString endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 278h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 27Ch
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 280h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public _main
_main		proc near

var_60C		= dword	ptr -60Ch
var_604		= byte ptr -604h
var_5F4		= dword	ptr -5F4h
var_5E8		= byte ptr -5E8h
var_5D8		= byte ptr -5D8h
var_5C8		= dword	ptr -5C8h
var_5BC		= dword	ptr -5BCh
var_5B0		= byte ptr -5B0h
var_5A0		= dword	ptr -5A0h
var_594		= dword	ptr -594h
var_4C8		= dword	ptr -4C8h
var_4BC		= dword	ptr -4BCh
var_4B0		= dword	ptr -4B0h
Source		= dword	ptr -4A4h
var_498		= dword	ptr -498h
var_489		= byte ptr -489h
var_480		= dword	ptr -480h
var_474		= dword	ptr -474h
var_468		= byte ptr -468h
var_428		= dword	ptr -428h
File		= dword	ptr -41Ch
Src		= byte ptr -410h
Dest		= byte ptr -404h
Dst		= byte ptr -168h
var_74		= byte ptr -74h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
argc		= dword	ptr  8
argv		= dword	ptr  0Ch
envp		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$_main
		mov	eax, large fs:0
		push	eax
		sub	esp, 600h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_60C]
		mov	ecx, 180h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		lea	eax, [ebp+Src]
		push	eax
		call	_u_getVersion_56
		add	esp, 4
		push	1
		lea	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	4		; Size
		lea	ecx, [ebp+Src]
		push	ecx		; Src
		push	offset dword_160 ; Dst
		call	_memcpy
		add	esp, 0Ch
		call	_u_getDataDirectory_56
		mov	ds:dword_1B8, eax
		push	offset _options
		push	9
		mov	eax, [ebp+argv]
		push	eax
		mov	ecx, [ebp+argc]
		push	ecx
		call	_u_parseArgs
		add	esp, 10h
		mov	[ebp+argc], eax
		cmp	[ebp+argc], 0
		jge	short loc_358
		mov	eax, [ebp+argc]
		neg	eax
		mov	esi, esp
		mov	ecx, [ebp+argv]
		mov	edx, [ecx+eax*4]
		push	edx
		push	offset ??_C@_0CF@BGPNLJEE@error?5in?5command?5line?5argument?5?$CC@ ; "error in	command	line argument \"%s\"\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_365
; ---------------------------------------------------------------------------

loc_358:				; CODE XREF: _main+9Ej
		cmp	[ebp+argc], 2
		jge	short loc_365
		mov	[ebp+argc], 0FFFFFFFFh

loc_365:				; CODE XREF: _main+D6j	_main+DCj
		cmp	[ebp+argc], 0
		jl	short loc_385
		movsx	eax, ds:byte_176
		test	eax, eax
		jnz	short loc_385
		movsx	eax, ds:byte_18A
		test	eax, eax
		jz	loc_419

loc_385:				; CODE XREF: _main+E9j	_main+F4j
		cmp	[ebp+argc], 0
		jge	short loc_3A5
		mov	esi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		mov	[ebp+var_60C], eax
		jmp	short loc_3BD
; ---------------------------------------------------------------------------

loc_3A5:				; CODE XREF: _main+109j
		mov	esi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		mov	[ebp+var_60C], eax

loc_3BD:				; CODE XREF: _main+123j
		mov	eax, [ebp+var_60C]
		mov	[ebp+File], eax
		mov	esi, esp
		mov	eax, [ebp+argv]
		mov	ecx, [eax]
		push	ecx
		push	offset ??_C@_0BIH@LEKGGKP@usage?3?5?$CFs?5?$FL?9options?$FN?5files?4?4?4?6?7r@ ; "usage: %s [-options] files...\n\tread	."...
		mov	edx, [ebp+File]
		push	edx		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	offset ??_C@_0BEA@MBIOMLNL@?7?5?5?5?5?5?5?9?9small?5?5?5?5?5?5?5Generate?5sm@ ;	"\t	 --small       Generate	smaller	"...
		mov	eax, [ebp+File]
		push	eax		; File

loc_3FB:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	eax, eax
		cmp	[ebp+argc], 0
		setl	al
		jmp	loc_C31
; ---------------------------------------------------------------------------

loc_419:				; CODE XREF: _main+FFj
		movsx	eax, ds:byte_1B2
		test	eax, eax
		jz	short loc_478
		movzx	eax, ds:byte_15D
		mov	esi, esp
		push	eax
		movzx	ecx, ds:byte_15C
		push	ecx
		push	offset ??_C@_0FL@GKOCANAO@makeconv?5version?5?$CFu?4?$CFu?0?5ICU?5tool@	; "makeconv version %u.%u, ICU tool to rea"...
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	offset ??_C@_0GD@IBBFEJOD@?5Copyright?5?$CIC?$CJ?52015?0?5Internation@ ; " Copyright (C) 2015, International Busi"...
		push	offset ??_C@_03OFAPEBGM@?$CFs?6?$AA@ ; "%s\n"
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0		; enum UErrorCode *
		call	dword ptr ds:__imp__exit
; ---------------------------------------------------------------------------
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_478:				; CODE XREF: _main+1A2j
		mov	al, ds:byte_19E
		mov	ds:?haveCopyright@@3CA,	al ; signed char haveCopyright
		mov	eax, ds:dword_1B8
		mov	[ebp+var_428], eax
		mov	al, ds:byte_1DA
		mov	ds:_VERBOSE, al
		mov	al, ds:byte_216
		mov	ds:?QUIET@@3CA,	al ; signed char QUIET
		mov	al, ds:byte_1EE
		mov	ds:_SMALL, al
		movsx	eax, ds:byte_202
		test	eax, eax
		jz	short loc_4BD
		mov	ds:_IGNORE_SISO_CHECK, 1

loc_4BD:				; CODE XREF: _main+234j
		mov	esi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_??0CharString@icu_56@@QAE@XZ	; icu_56::CharString::CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	[ebp+var_474], 0
		cmp	[ebp+var_428], 0
		jz	loc_5A1
		mov	eax, [ebp+var_428]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	loc_5A1
		mov	esi, esp
		mov	eax, [ebp+var_428]
		push	eax		; char *
		lea	ecx, [ebp+var_604] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_474]
		push	ecx		; enum UErrorCode *
		mov	edi, esp
		lea	edx, [ebp+var_474]
		push	edx		; enum UErrorCode *
		lea	eax, [ebp+var_604]
		push	eax		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z ; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax	; this
		call	dword ptr ds:__imp_?ensureEndsWithFileSeparator@CharString@icu_56@@QAEAAV12@AAW4UErrorCode@@@Z ; icu_56::CharString::ensureEndsWithFileSeparator(UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_474]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_5A1
		mov	eax, [ebp+var_474]
		mov	[ebp+var_5F4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_5F4]
		jmp	loc_C31
; ---------------------------------------------------------------------------

loc_5A1:				; CODE XREF: _main+26Aj _main+27Bj ...
		mov	esi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?length@CharString@icu_56@@QBEHXZ ; icu_56::CharString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_480], eax
		cmp	[ebp+argc], 2
		jg	short loc_5D6
		movsx	eax, ds:_VERBOSE
		test	eax, eax
		jnz	short loc_5D6
		mov	byte ptr [ebp+var_60C+3], 0
		jmp	short loc_5DD
; ---------------------------------------------------------------------------

loc_5D6:				; CODE XREF: _main+340j _main+34Bj
		mov	byte ptr [ebp+var_60C+3], 1

loc_5DD:				; CODE XREF: _main+354j
		mov	cl, byte ptr [ebp+var_60C+3]
		mov	[ebp+var_489], cl
		mov	eax, [ebp+argv]
		add	eax, 4
		mov	[ebp+argv], eax
		jmp	short loc_5FD
; ---------------------------------------------------------------------------

loc_5F4:				; CODE XREF: _main+97Ej
		mov	eax, [ebp+argv]
		add	eax, 4
		mov	[ebp+argv], eax

loc_5FD:				; CODE XREF: _main+372j
		mov	eax, [ebp+argc]
		sub	eax, 1
		mov	[ebp+argc], eax
		jz	loc_C03
		mov	[ebp+var_498], 0
		mov	eax, [ebp+argv]
		mov	ecx, [eax]
		push	ecx
		call	_getLongPathname
		add	esp, 4
		mov	[ebp+Source], eax
		mov	esi, esp
		mov	eax, [ebp+var_480]
		push	eax		; int
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?truncate@CharString@icu_56@@QAEAAV12@H@Z ; icu_56::CharString::truncate(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_480], 0
		jz	short loc_6A5
		mov	eax, [ebp+Source]
		push	eax
		call	_findBasename
		add	esp, 4
		mov	[ebp+var_4B0], eax
		mov	esi, esp
		mov	eax, [ebp+var_4B0]
		push	eax		; char *
		lea	ecx, [ebp+var_5E8] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_498]
		push	ecx		; enum UErrorCode *
		lea	edx, [ebp+var_5E8]
		push	edx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z ; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_6E4
; ---------------------------------------------------------------------------

loc_6A5:				; CODE XREF: _main+3CDj
		mov	esi, esp
		mov	eax, [ebp+Source]
		push	eax		; char *
		lea	ecx, [ebp+var_5D8] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_498]
		push	ecx		; enum UErrorCode *
		lea	edx, [ebp+var_5D8]
		push	edx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z ; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6E4:				; CODE XREF: _main+423j
		mov	eax, [ebp+var_498]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_72D
		mov	eax, [ebp+var_498]
		mov	[ebp+var_5C8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_5C8]
		jmp	loc_C31
; ---------------------------------------------------------------------------

loc_72D:				; CODE XREF: _main+478j
		mov	esi, esp
		push	2Eh ; '.'       ; char
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?lastIndexOf@CharString@icu_56@@QBEHD@Z ; icu_56::CharString::lastIndexOf(char)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4BC], eax
		mov	eax, [ebp+var_4BC]
		cmp	eax, [ebp+var_480]
		jl	short loc_774
		mov	esi, esp
		mov	eax, [ebp+var_4BC]
		push	eax		; int
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?truncate@CharString@icu_56@@QAEAAV12@H@Z ; icu_56::CharString::truncate(int)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_774:				; CODE XREF: _main+4D6j
		mov	esi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?length@CharString@icu_56@@QBEHXZ ; icu_56::CharString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+var_480]
		cmp	eax, 294h
		jl	short loc_80D
		mov	esi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, [ebp+var_480]
		mov	esi, esp
		push	eax
		push	offset ??_C@_0BM@NPOCIIDC@converter?5name?5?$CFs?5too?5long?6?$AA@ ; "converter	name %s	too long\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_5BC], 0Fh
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp

loc_7FD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_5BC]
		jmp	loc_C31
; ---------------------------------------------------------------------------

loc_80D:				; CODE XREF: _main+514j
		mov	esi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, [ebp+var_480]
		push	eax		; Source
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	_strcpy
		add	esp, 8
		mov	esi, esp
		push	offset ??_C@_04FFJDPJDA@?4cnv?$AA@ ; ".cnv"
		lea	ecx, [ebp+var_5B0] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	eax, [ebp+var_498]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_5B0]
		push	ecx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z ; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_498]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_8BE
		mov	eax, [ebp+var_498]
		mov	[ebp+var_5A0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_5A0]
		jmp	loc_C31
; ---------------------------------------------------------------------------

loc_8BE:				; CODE XREF: _main+609j
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	?initConvData@@YAXPAUConvData@@@Z ; initConvData(ConvData *)
		add	esp, 4
		lea	eax, [ebp+var_498]
		push	eax		; int
		mov	ecx, [ebp+Source]
		push	ecx		; Source
		lea	edx, [ebp+Dst]
		push	edx		; Dst
		call	?createConverter@@YAXPAUConvData@@PBDPAW4UErrorCode@@@Z	; createConverter(ConvData *,char const	*,UErrorCode *)
		add	esp, 0Ch
		mov	eax, [ebp+var_498]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_97E
		mov	eax, [ebp+var_498]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+Source]
		push	ecx
		mov	edi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		push	offset ??_C@_0DG@BIFONMIB@Error?5creating?5converter?5for?5?$CC?$CFs@ ;	"Error creating	converter for \"%s\" fil"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_474]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_979
		mov	eax, [ebp+var_498]
		mov	[ebp+var_474], eax

loc_979:				; CODE XREF: _main+6EBj
		jmp	loc_BA5
; ---------------------------------------------------------------------------

loc_97E:				; CODE XREF: _main+67Ej
		push	5Ch ; '\'       ; int
		lea	eax, [ebp+Dest]
		push	eax		; Str
		call	?strrchr@@YAPADPADH@Z ;	strrchr(char *,int)
		add	esp, 8
		mov	[ebp+var_4C8], eax
		cmp	[ebp+var_4C8], 0
		jnz	short loc_9CC
		push	2Fh ; '/'       ; int
		lea	eax, [ebp+Dest]
		push	eax		; Str
		call	?strrchr@@YAPADPADH@Z ;	strrchr(char *,int)
		add	esp, 8
		mov	[ebp+var_4C8], eax
		cmp	[ebp+var_4C8], 0
		jnz	short loc_9CA
		lea	eax, [ebp+Dest]
		mov	[ebp+var_4C8], eax

loc_9CA:				; CODE XREF: _main+73Cj
		jmp	short loc_9DB
; ---------------------------------------------------------------------------

loc_9CC:				; CODE XREF: _main+71Cj
		mov	eax, [ebp+var_4C8]
		add	eax, 1
		mov	[ebp+var_4C8], eax

loc_9DB:				; CODE XREF: _main:loc_9CAj
		lea	eax, [ebp+var_74]
		push	eax
		mov	ecx, [ebp+var_4C8]
		push	ecx
		call	_uprv_stricmp_56
		add	esp, 8
		test	eax, eax
		jz	short loc_A37
		movsx	eax, ds:?QUIET@@3CA ; signed char QUIET
		test	eax, eax
		jnz	short loc_A37
		mov	esi, esp
		lea	eax, [ebp+var_74]
		push	eax
		push	offset ??_C@_04FFJDPJDA@?4cnv?$AA@ ; ".cnv"
		lea	ecx, [ebp+Dest]
		push	ecx
		push	offset ??_C@_0CB@FAAGEOEI@Warning?3?5?$CFs?$CFs?5claims?5to?5be?5?8?$CFs?8?6@ ;	"Warning: %s%s claims to be '%s'\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A37:				; CODE XREF: _main+770j _main+77Bj
		lea	eax, [ebp+Dest]
		push	eax		; Source
		lea	ecx, [ebp+var_74]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		push	0FFFFFFFFh
		lea	eax, [ebp+var_74]
		push	eax
		call	_uprv_isInvariantString_56
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_AAD
		mov	esi, esp
		lea	eax, [ebp+var_74]
		push	eax
		push	offset ??_C@_0GD@PLKDPECN@Error?3?5A?5converter?5name?5must?5con@ ; "Error: A converter	name must contain on"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_474]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_AAD
		mov	[ebp+var_474], 0Dh

loc_AAD:				; CODE XREF: _main+7DDj _main+821j
		mov	[ebp+var_498], 0
		lea	eax, [ebp+var_498]
		push	eax
		mov	ecx, [ebp+var_428]
		push	ecx
		lea	edx, [ebp+Dest]
		push	edx
		lea	eax, [ebp+Dst]
		push	eax
		call	?writeConverterData@@YAXPAUConvData@@PBD1PAW4UErrorCode@@@Z ; writeConverterData(ConvData *,char const *,char const *,UErrorCode *)
		add	esp, 10h
		mov	eax, [ebp+var_498]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_B6C
		mov	eax, [ebp+var_498]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+Source]
		push	ecx
		mov	edi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		push	offset ??_C@_0CH@GKPFJOEP@Error?5writing?5?$CC?$CFs?$CC?5file?5for?5?$CC?$CFs?$CC@ ; "Error writing \"%s\" file	for \"%s\" (%"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_474]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_B6A
		mov	eax, [ebp+var_498]
		mov	[ebp+var_474], eax

loc_B6A:				; CODE XREF: _main+8DCj
		jmp	short loc_BA5
; ---------------------------------------------------------------------------

loc_B6C:				; CODE XREF: _main+86Fj
		movsx	eax, [ebp+var_489]
		test	eax, eax
		jz	short loc_BA5
		mov	esi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, [ebp+var_480]
		mov	esi, esp
		push	eax		; Str
		call	dword ptr ds:__imp__puts
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_BA5:				; CODE XREF: _main:loc_979j
					; _main:loc_B6Aj ...
		mov	esi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, 20h ; ' '
		mov	esi, esp
		push	eax		; File
		call	dword ptr ds:__imp__fflush
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		mov	esi, esp
		push	eax		; File
		call	dword ptr ds:__imp__fflush
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	eax, [ebp+Dst]
		push	eax
		call	?cleanupConvData@@YAXPAUConvData@@@Z ; cleanupConvData(ConvData	*)
		add	esp, 4
		jmp	loc_5F4
; ---------------------------------------------------------------------------

loc_C03:				; CODE XREF: _main+386j
		mov	eax, [ebp+var_474]
		mov	[ebp+var_594], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_468] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_594]

loc_C31:				; CODE XREF: _main+194j _main+31Cj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN47
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 60Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_main		endp

; ---------------------------------------------------------------------------
		align 4
$LN47		dd 6			; DATA XREF: _main+9B5o
		dd offset $LN46
$LN46		dd 0FFFFFE98h, 154h	; DATA XREF: .text:00000C70o
		dd offset $LN39		; "data"
		dd 0FFFFFBFCh, 294h
		dd offset $LN40		; "cnvName"
		dd 0FFFFFBF0h, 4
		dd offset $LN41		; "icuVersion"
		dd 0FFFFFB98h, 38h
		dd offset $LN42		; "outFileName"
		dd 0FFFFFB8Ch, 4
		dd offset $LN43		; "err"
		dd 0FFFFFB68h, 4
		dd offset $LN44		; "localError"
$LN44		db 'localError',0       ; DATA XREF: .text:00000CB8o
$LN43		db 'err',0              ; DATA XREF: .text:00000CACo
$LN42		db 'outFileName',0      ; DATA XREF: .text:00000CA0o
$LN41		db 'icuVersion',0       ; DATA XREF: .text:00000C94o
$LN40		db 'cnvName',0          ; DATA XREF: .text:00000C88o
$LN39		db 'data',0             ; DATA XREF: .text:00000C7Co
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0CF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$_main$0	proc near	; DATA XREF: .xdata$x:000011F4o
		mov	esi, esp
		lea	ecx, [ebp-468h]	; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$_main$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$_main proc near		; DATA XREF: _main+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-610h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$_main
		jmp	___CxxFrameHandler3
__ehhandler$_main endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D30h
		public ??_C@_0CH@GKPFJOEP@Error?5writing?5?$CC?$CFs?$CC?5file?5for?5?$CC?$CFs?$CC@
; char `string'[]
??_C@_0CH@GKPFJOEP@Error?5writing?5?$CC?$CFs?$CC?5file?5for?5?$CC?$CFs?$CC@ db 'Error writing "%s" file for "%s" (%s)',0Ah,0
					; DATA XREF: _main+8A0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0D58h
		public ??_C@_0GD@PLKDPECN@Error?3?5A?5converter?5name?5must?5con@
; char `string'[]
??_C@_0GD@PLKDPECN@Error?3?5A?5converter?5name?5must?5con@ db 'Error: A converter name must contain only invariant characters.',0Ah
					; DATA XREF: _main+7E5o
		db '%s is not a valid converter name.',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DBCh
		public ??_C@_0CB@FAAGEOEI@Warning?3?5?$CFs?$CFs?5claims?5to?5be?5?8?$CFs?8?6@
; char `string'[]
??_C@_0CB@FAAGEOEI@Warning?3?5?$CFs?$CFs?5claims?5to?5be?5?8?$CFs?8?6@ db 'Warning: %s%s claims to be ',27h,'%s',27h,0Ah,0
					; DATA XREF: _main+78Fo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DE0h
		public ??_C@_0DG@BIFONMIB@Error?5creating?5converter?5for?5?$CC?$CFs@
; char `string'[]
??_C@_0DG@BIFONMIB@Error?5creating?5converter?5for?5?$CC?$CFs@ db 'Error creating converter for "%s" file for "%s" (%s)',0Ah,0
					; DATA XREF: _main+6AFo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E18h
		public ??_C@_04FFJDPJDA@?4cnv?$AA@
; char `string'[]
??_C@_04FFJDPJDA@?4cnv?$AA@ db '.cnv',0 ; DATA XREF: _main+5BAo _main+783o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E20h
		public ??_C@_0BM@NPOCIIDC@converter?5name?5?$CFs?5too?5long?6?$AA@
; char `string'[]
??_C@_0BM@NPOCIIDC@converter?5name?5?$CFs?5too?5long?6?$AA@ db 'converter name %s too long',0Ah,0
					; DATA XREF: _main+534o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E3Ch
		public ??_C@_03OFAPEBGM@?$CFs?6?$AA@
; char `string'[]
??_C@_03OFAPEBGM@?$CFs?6?$AA@ db '%s',0Ah,0 ; DATA XREF: _main+1D2o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0E40h
		public ??_C@_0GD@IBBFEJOD@?5Copyright?5?$CIC?$CJ?52015?0?5Internation@
; `string'
??_C@_0GD@IBBFEJOD@?5Copyright?5?$CIC?$CJ?52015?0?5Internation@	db ' Copyright (C) 2015, International Business Machines Corporation '
					; DATA XREF: _main+1CDo
					; writeConverterData(ConvData *,char const *,char const	*,UErrorCode *)+80o
		db 'and others. All Rights Reserved. ',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0EA4h
		public ??_C@_0FL@GKOCANAO@makeconv?5version?5?$CFu?4?$CFu?0?5ICU?5tool@
; char `string'[]
??_C@_0FL@GKOCANAO@makeconv?5version?5?$CFu?4?$CFu?0?5ICU?5tool@ db 'makeconv version %u.%u, ICU tool to read .ucm codepage mapping fi'
					; DATA XREF: _main+1B6o
		db 'les and write .cnv files',0Ah,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F00h
		public ??_C@_0BEA@MBIOMLNL@?7?5?5?5?5?5?5?9?9small?5?5?5?5?5?5?5Generate?5sm@
; char `string'[]
??_C@_0BEA@MBIOMLNL@?7?5?5?5?5?5?5?9?9small?5?5?5?5?5?5?5Generate?5sm@ db 9,'      --small       Generate smaller .cnv files. They will be',0Ah
					; DATA XREF: _main+16Fo
		db 9,'                    significantly smaller but may not be compati'
		db 'ble with',0Ah
		db 9,'                    older versions of ICU and will require heap '
		db 'memory',0Ah
		db 9,'                    allocation when loaded.',0Ah
		db 9,'      --ignore-siso-check         Use SI/SO other than 0xf/0xe.',0Ah
		db 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 1040h
		public ??_C@_0BIH@LEKGGKP@usage?3?5?$CFs?5?$FL?9options?$FN?5files?4?4?4?6?7r@
; char `string'[]
??_C@_0BIH@LEKGGKP@usage?3?5?$CFs?5?$FL?9options?$FN?5files?4?4?4?6?7r@	db 'usage: %s [-options] files...',0Ah
					; DATA XREF: _main+151o
		db 9,'read .ucm codepage mapping files and write .cnv files',0Ah
		db 'options:',0Ah
		db 9,'-h or -? or --help  this usage text',0Ah
		db 9,'-V or --version     show a version message',0Ah
		db 9,'-c or --copyright   include a copyright notice',0Ah
		db 9,'-d or --destdir     destination directory, followed by the path',0Ah
		db 9,'-v or --verbose     Turn on verbose output',0Ah
		db 9,'-q or --quiet       do not display warnings and progress',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 11C8h
		public ??_C@_0CF@BGPNLJEE@error?5in?5command?5line?5argument?5?$CC@
; char `string'[]
??_C@_0CF@BGPNLJEE@error?5in?5command?5line?5argument?5?$CC@ db	'error in command line argument "%s"',0Ah,0
					; DATA XREF: _main+AEo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 11F0h
__unwindtable$_main dd 0FFFFFFFFh	; DATA XREF: .xdata$x:00001200o
		dd offset __unwindfunclet$_main$0
__ehfuncinfo$_main dd 19930522h, 1	; DATA XREF: __ehhandler$_main+1Eo
		dd offset __unwindtable$_main
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 121Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _main+6DEp _main+814p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1248h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _main+2DFp _main+46Bp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1274h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char *__cdecl	strrchr(char *Str, int)
		public ?strrchr@@YAPADPADH@Z
?strrchr@@YAPADPADH@Z proc near		; CODE XREF: _main+707p _main+727p

var_C0		= byte ptr -0C0h
Str		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; Ch
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strrchr
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?strrchr@@YAPADPADH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl initConvData(void	*Dst)
?initConvData@@YAXPAUConvData@@@Z proc near ; CODE XREF: _main+645p
					; createConverter(ConvData *,char const	*,UErrorCode *)+46p ...

var_C0		= byte ptr -0C0h
Dst		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	154h		; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+0Ch], 0E4h ; ''
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+0F0h], 64h ; 'd'
		mov	eax, [ebp+Dst]
		add	eax, 0F0h ; ''
		mov	ecx, [ebp+Dst]
		mov	[ecx+18h], eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initConvData@@YAXPAUConvData@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 132Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl cleanupConvData(struct ConvData *)
?cleanupConvData@@YAXPAUConvData@@@Z proc near ; CODE XREF: _main+976p
					; createConverter(ConvData *,char const	*,UErrorCode *)+895p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_13C7
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+4], 0
		jz	short loc_1380
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	ecx, [eax]
		call	ecx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+4], 0

loc_1380:				; CODE XREF: cleanupConvData(ConvData *)+2Bj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_13B0
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		mov	ecx, [eax]
		call	ecx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], 0

loc_13B0:				; CODE XREF: cleanupConvData(ConvData *)+5Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	_ucm_close
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0

loc_13C7:				; CODE XREF: cleanupConvData(ConvData *)+22j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?cleanupConvData@@YAXPAUConvData@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl writeConverterData(struct ConvData *, char const	*, char	const *, enum  UErrorCode *)
?writeConverterData@@YAXPAUConvData@@PBD1PAW4UErrorCode@@@Z proc near
					; CODE XREF: _main+853p

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	[ebp+var_20], 0
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1422
		jmp	loc_161F
; ---------------------------------------------------------------------------

loc_1422:				; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+3Fj
		mov	[ebp+var_2C], 0
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+4], 0
		jz	short loc_143B
		mov	eax, [ebp+var_2C]
		or	eax, 1
		mov	[ebp+var_2C], eax

loc_143B:				; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+54j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_144D
		mov	eax, [ebp+var_2C]
		or	eax, 2
		mov	[ebp+var_2C], eax

loc_144D:				; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+66j
		mov	eax, [ebp+arg_C]
		push	eax
		movsx	ecx, ds:?haveCopyright@@3CA ; signed char haveCopyright
		neg	ecx
		sbb	ecx, ecx
		and	ecx, offset ??_C@_0GD@IBBFEJOD@?5Copyright?5?$CIC?$CJ?52015?0?5Internation@ ; "	Copyright (C) 2015, International Busi"...
		push	ecx
		push	offset _dataInfo
		mov	edx, [ebp+arg_4]
		push	edx
		push	offset ??_C@_03MMAEEAFE@cnv?$AA@ ; `string'
		mov	eax, [ebp+arg_8]
		push	eax
		call	_udata_create
		add	esp, 18h
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_14DC
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax
		push	offset ??_C@_03MMAEEAFE@cnv?$AA@ ; `string'
		mov	edx, [ebp+arg_4]
		push	edx
		push	offset ??_C@_0CF@IKBMFADM@Couldn?8t?5create?5the?5udata?5?$CFs?4?$CFs?3@ ; "Couldn't create the udata %s.%s: %s\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_161F
; ---------------------------------------------------------------------------

loc_14DC:				; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+B7j
		movsx	eax, ds:_VERBOSE
		test	eax, eax
		jz	short loc_1507
		mov	esi, esp
		push	offset ??_C@_03MMAEEAFE@cnv?$AA@ ; `string'
		mov	eax, [ebp+arg_4]
		push	eax
		push	offset ??_C@_0BG@PJEDMNNG@?9?5Opened?5udata?5?$CFs?4?$CFs?6?$AA@ ; "- Opened udata %s.%s\n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1507:				; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+109j
		push	64h ; 'd'
		mov	eax, [ebp+arg_0]
		add	eax, 0F0h ; ''
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	_udata_writeBlock
		add	esp, 0Ch
		mov	eax, [ebp+var_20]
		add	eax, 64h ; 'd'
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_2C]
		and	eax, 1
		jz	short loc_1565
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		add	edx, 0F0h ; ''
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	ecx, [eax+0Ch]
		call	ecx
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, [ebp+var_20]
		mov	[ebp+var_20], eax

loc_1565:				; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+151j
		mov	eax, [ebp+var_2C]
		and	eax, 2
		jz	short loc_15A3
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		add	edx, 0F0h ; ''
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		mov	ecx, [eax+0Ch]
		call	ecx
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, [ebp+var_20]
		mov	[ebp+var_20], eax

loc_15A3:				; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+18Fj
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	_udata_finish
		add	esp, 8
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jz	short loc_15F9
		mov	esi, esp
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		push	offset ??_C@_0DN@INPLCDOJ@error?3?5wrote?5?$CFu?5bytes?5to?5the?5?4cn@ ; "error: wrote %u bytes	to the .cnv file "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 5

loc_15F9:				; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+1E0j
		movsx	eax, ds:_VERBOSE
		test	eax, eax
		jz	short loc_161F
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax
		push	offset ??_C@_0CA@EDMMBPAH@?9?5Wrote?5?$CFu?5bytes?5to?5the?5udata?4?6?$AA@ ; "-	Wrote %u bytes to the udata.\n"
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_161F:				; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+41j
					; writeConverterData(ConvData *,char const *,char const	*,UErrorCode *)+FBj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?writeConverterData@@YAXPAUConvData@@PBD1PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1634h
		public ??_C@_0CA@EDMMBPAH@?9?5Wrote?5?$CFu?5bytes?5to?5the?5udata?4?6?$AA@
; char `string'[]
??_C@_0CA@EDMMBPAH@?9?5Wrote?5?$CFu?5bytes?5to?5the?5udata?4?6?$AA@ db '- Wrote %u bytes to the udata.',0Ah,0
					; DATA XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+22Eo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1654h
		public ??_C@_0DN@INPLCDOJ@error?3?5wrote?5?$CFu?5bytes?5to?5the?5?4cn@
; char `string'[]
??_C@_0DN@INPLCDOJ@error?3?5wrote?5?$CFu?5bytes?5to?5the?5?4cn@	db 'error: wrote %u bytes to the .cnv file but counted %u bytes',0Ah,0
					; DATA XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+1ECo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1694h
		public ??_C@_0BG@PJEDMNNG@?9?5Opened?5udata?5?$CFs?4?$CFs?6?$AA@
; char `string'[]
??_C@_0BG@PJEDMNNG@?9?5Opened?5udata?5?$CFs?4?$CFs?6?$AA@ db '- Opened udata %s.%s',0Ah,0
					; DATA XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+116o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 16ACh
		public ??_C@_0CF@IKBMFADM@Couldn?8t?5create?5the?5udata?5?$CFs?4?$CFs?3@
; char `string'[]
??_C@_0CF@IKBMFADM@Couldn?8t?5create?5the?5udata?5?$CFs?4?$CFs?3@ db 'Couldn',27h,'t create the udata %s.%s: %s',0Ah,0
					; DATA XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+D3o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 16D4h
		public ??_C@_03MMAEEAFE@cnv?$AA@
; `string'
??_C@_03MMAEEAFE@cnv?$AA@ dd 766E63h	; DATA XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+90o
					; writeConverterData(ConvData *,char const *,char const	*,UErrorCode *)+CAo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl createConverter(void *Dst, char *Source, int)
?createConverter@@YAXPAUConvData@@PBDPAW4UErrorCode@@@Z	proc near ; CODE XREF: _main+662p

var_494		= byte ptr -494h
var_3D0		= dword	ptr -3D0h
var_3C4		= dword	ptr -3C4h
var_3B5		= byte ptr -3B5h
var_3AC		= dword	ptr -3ACh
var_3A0		= dword	ptr -3A0h
var_394		= dword	ptr -394h
Dest		= byte ptr -388h
var_18C		= dword	ptr -18Ch
var_180		= dword	ptr -180h
var_174		= dword	ptr -174h
var_165		= byte ptr -165h
var_15C		= dword	ptr -15Ch
Src		= byte ptr -24h
var_20		= byte ptr -20h
var_4		= dword	ptr -4
Dst		= dword	ptr  8
Source		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 494h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_494]
		mov	ecx, 125h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_171A
		jmp	loc_1F75
; ---------------------------------------------------------------------------

loc_171A:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+3Bj
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	?initConvData@@YAXPAUConvData@@@Z ; initConvData(ConvData *)
		add	esp, 4
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+Source]
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx
		call	?readFile@@YACPAUConvData@@PBDPAW4UErrorCode@@@Z ; readFile(ConvData *,char const *,UErrorCode *)
		add	esp, 0Ch
		mov	[ebp+var_165], al
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_175A
		jmp	loc_1F75
; ---------------------------------------------------------------------------

loc_175A:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+7Bj
		mov	eax, [ebp+Dst]
		add	eax, 0F0h ; ''
		mov	[ebp+var_174], eax
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		add	ecx, 8
		mov	[ebp+var_180], ecx
		movsx	eax, [ebp+var_165]
		test	eax, eax
		jz	loc_1A03
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		push	ecx
		call	_MBCSOpen
		add	esp, 4
		mov	edx, [ebp+Dst]
		mov	[edx+4], eax
		mov	eax, [ebp+Dst]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_17B0
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	loc_1901
; ---------------------------------------------------------------------------

loc_17B0:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+C8j
		mov	eax, [ebp+var_174]
		movsx	ecx, byte ptr [eax+4Ch]
		mov	esi, esp
		push	ecx
		mov	edx, [ebp+var_174]
		add	edx, 48h ; 'H'
		push	edx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+4]
		push	ecx
		mov	edx, [ebp+Dst]
		mov	eax, [edx+4]
		mov	ecx, [eax+4]
		call	ecx
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1822
		mov	esi, esp
		push	offset ??_C@_0FI@KLHCIHED@?5?5?5?5?5?5?5the?5substitution?5characte@ ; "       the substitution	character byte "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh
		jmp	loc_1901
; ---------------------------------------------------------------------------

loc_1822:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+110j
		mov	eax, [ebp+var_174]
		movzx	ecx, byte ptr [eax+50h]
		test	ecx, ecx
		jz	short loc_1896
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_174]
		add	eax, 50h ; 'P'
		push	eax
		mov	ecx, [ebp+Dst]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+4]
		mov	edx, [ecx+4]
		call	edx
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_1896
		mov	esi, esp
		push	offset ??_C@_0EB@PMEFADGL@?5?5?5?5?5?5?5the?5subchar1?5byte?5is?5ille@ ; "	 the subchar1 byte is illegal in "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh
		jmp	short loc_1901
; ---------------------------------------------------------------------------

loc_1896:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+156j
					; createConverter(ConvData *,char const	*,UErrorCode *)+187j
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		cmp	dword ptr [edx+8], 0
		jle	short loc_18E1
		push	0
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+var_180]
		push	eax
		call	_ucm_checkBaseExt
		add	esp, 14h
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_18E1
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh
		jmp	short loc_1901
; ---------------------------------------------------------------------------

loc_18E1:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+1CAj
					; createConverter(ConvData *,char const	*,UErrorCode *)+1FCj
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx]
		movsx	eax, byte ptr [edx+29h]
		and	eax, 1
		jz	short loc_1901
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx]
		push	edx
		call	_ucm_sortTable
		add	esp, 4

loc_1901:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+D3j
					; createConverter(ConvData *,char const	*,UErrorCode *)+145j ...
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_19FE
		mov	eax, [ebp+Dst]
		add	eax, 0F0h ; ''
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+Dst]
		mov	edx, [ecx]
		mov	eax, [edx]
		push	eax
		mov	ecx, [ebp+Dst]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+4]
		mov	edx, [ecx+8]
		call	edx
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_195E
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh
		jmp	loc_19FE
; ---------------------------------------------------------------------------

loc_195E:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+276j
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx]
		push	edx
		call	_ucm_moveMappings
		add	esp, 8
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		push	edx
		call	_ucm_sortTable
		add	esp, 4
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		cmp	dword ptr [edx+8], 0
		jle	short loc_19FE
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		push	ecx
		call	_CnvExtOpen
		add	esp, 4
		mov	edx, [ebp+Dst]
		mov	[edx+8], eax
		mov	eax, [ebp+Dst]
		cmp	dword ptr [eax+8], 0
		jnz	short loc_19BE
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	short loc_19FE
; ---------------------------------------------------------------------------

loc_19BE:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+2D9j
		mov	eax, [ebp+Dst]
		add	eax, 0F0h ; ''
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+Dst]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+Dst]
		mov	edx, [ecx+8]
		push	edx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+8]
		mov	edx, [ecx+8]
		call	edx
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_19FE
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh

loc_19FE:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+23Cj
					; createConverter(ConvData *,char const	*,UErrorCode *)+281j ...
		jmp	loc_1F75
; ---------------------------------------------------------------------------

loc_1A03:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+A7j
		lea	eax, [ebp+var_15C]
		push	eax		; Dst
		call	?initConvData@@YAXPAUConvData@@@Z ; initConvData(ConvData *)
		add	esp, 4
		mov	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		lea	eax, [ebp+Dest]
		push	eax
		call	_findBasename
		add	esp, 4
		mov	[ebp+var_394], eax
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		add	ecx, 2041Ch
		push	ecx		; Source
		mov	edx, [ebp+var_394]
		push	edx		; Dest
		call	_strcpy
		add	esp, 8
		push	offset ??_C@_04IBAPKJLK@?4ucm?$AA@ ; ".ucm"
		mov	eax, [ebp+var_394]
		push	eax		; Dest
		call	_strcat
		add	esp, 8
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+Dest]
		push	ecx
		lea	edx, [ebp+var_15C]
		push	edx
		call	?readFile@@YACPAUConvData@@PBDPAW4UErrorCode@@@Z ; readFile(ConvData *,char const *,UErrorCode *)
		add	esp, 0Ch
		mov	[ebp+var_165], al
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1AA8
		jmp	loc_1F75
; ---------------------------------------------------------------------------
		jmp	loc_1F66
; ---------------------------------------------------------------------------

loc_1AA8:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+3C4j
		movsx	eax, [ebp+var_165]
		test	eax, eax
		jnz	short loc_1AF2
		mov	esi, esp
		lea	eax, [ebp+Dest]
		push	eax
		push	offset ??_C@_0DK@DHKEHOLK@error?3?5the?5?$DMicu?3base?$DO?5file?5?$CC?$CFs?$CC?5@ ; "error: the	<icu:base> file	\"%s\" is no"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh
		jmp	loc_1F66
; ---------------------------------------------------------------------------

loc_1AF2:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+3D9j
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		push	ecx
		call	_CnvExtOpen
		add	esp, 4
		mov	edx, [ebp+Dst]
		mov	[edx+8], eax
		mov	eax, [ebp+Dst]
		cmp	dword ptr [eax+8], 0
		jnz	short loc_1B1D
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	loc_1F66
; ---------------------------------------------------------------------------

loc_1B1D:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+435j
		mov	eax, [ebp+var_15C]
		add	eax, 8
		mov	[ebp+var_18C], eax
		mov	eax, [ebp+var_180]
		movsx	ecx, byte ptr [eax+20410h]
		cmp	ecx, 1
		jnz	short loc_1B5A
		mov	eax, [ebp+var_180]
		mov	dword ptr [eax+20404h],	2
		mov	ecx, [ebp+var_174]
		mov	byte ptr [ecx+46h], 2
		jmp	short loc_1B96
; ---------------------------------------------------------------------------

loc_1B5A:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+464j
		mov	eax, [ebp+var_180]
		cmp	dword ptr [eax+20404h],	0
		jnz	short loc_1B96
		mov	eax, [ebp+var_180]
		mov	ecx, [ebp+var_18C]
		mov	edx, [ecx+20404h]
		mov	[eax+20404h], edx
		mov	eax, [ebp+var_174]
		mov	ecx, [ebp+var_180]
		mov	dl, [ecx+20404h]
		mov	[eax+46h], dl

loc_1B96:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+480j
					; createConverter(ConvData *,char const	*,UErrorCode *)+48Fj
		mov	eax, [ebp+var_180]
		mov	ecx, [ebp+var_180]
		mov	edx, [eax+20408h]
		cmp	edx, [ecx+20404h]
		jge	short loc_1BDD
		mov	eax, [ebp+var_180]
		mov	ecx, [ebp+var_18C]
		mov	edx, [ecx+20408h]
		mov	[eax+20408h], edx
		mov	eax, [ebp+var_174]
		mov	ecx, [ebp+var_180]
		mov	dl, [ecx+20408h]
		mov	[eax+47h], dl

loc_1BDD:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+4D6j
		mov	eax, [ebp+var_174]
		movsx	ecx, byte ptr [eax+4Ch]
		test	ecx, ecx
		jnz	short loc_1C1D
		push	1
		lea	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	4		; Size
		lea	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+var_174]
		add	edx, 48h ; 'H'
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_174]
		mov	cl, [ebp+var_20]
		mov	[eax+4Ch], cl

loc_1C1D:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+511j
		mov	[ebp+var_3B5], 0
		mov	eax, [ebp+var_15C]
		mov	ecx, [eax]
		mov	edx, [ecx]
		mov	[ebp+var_3A0], edx
		mov	eax, [ebp+var_15C]
		mov	ecx, [eax]
		mov	edx, [ecx+8]
		imul	edx, 0Ch
		add	edx, [ebp+var_3A0]
		mov	[ebp+var_3AC], edx
		jmp	short loc_1C5F
; ---------------------------------------------------------------------------

loc_1C50:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*):loc_1CB9j
		mov	eax, [ebp+var_3A0]
		add	eax, 0Ch
		mov	[ebp+var_3A0], eax

loc_1C5F:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+576j
		mov	eax, [ebp+var_3A0]
		cmp	eax, [ebp+var_3AC]
		jnb	short loc_1CBB
		movzx	eax, [ebp+var_3B5]
		cmp	eax, 3
		jz	short loc_1CBB
		mov	eax, [ebp+var_3A0]
		movsx	ecx, byte ptr [eax+0Ah]
		cmp	ecx, 1
		jnz	short loc_1C9A
		movzx	eax, [ebp+var_3B5]
		or	eax, 1
		mov	[ebp+var_3B5], al
		jmp	short loc_1CB9
; ---------------------------------------------------------------------------

loc_1C9A:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+5AEj
		mov	eax, [ebp+var_3A0]
		movsx	ecx, byte ptr [eax+0Ah]
		cmp	ecx, 3
		jnz	short loc_1CB9
		movzx	eax, [ebp+var_3B5]
		or	eax, 2
		mov	[ebp+var_3B5], al

loc_1CB9:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+5C0j
					; createConverter(ConvData *,char const	*,UErrorCode *)+5CFj
		jmp	short loc_1C50
; ---------------------------------------------------------------------------

loc_1CBB:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+593j
					; createConverter(ConvData *,char const	*,UErrorCode *)+59Fj
		movzx	eax, [ebp+var_3B5]
		and	eax, 1
		jz	short loc_1CD1
		mov	eax, [ebp+var_174]
		mov	byte ptr [eax+4Eh], 1

loc_1CD1:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+5EDj
		movzx	eax, [ebp+var_3B5]
		and	eax, 2
		jz	short loc_1CE7
		mov	eax, [ebp+var_174]
		mov	byte ptr [eax+4Dh], 1

loc_1CE7:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+603j
		mov	eax, [ebp+var_174]
		movsx	ecx, byte ptr [eax+4Ch]
		push	ecx
		mov	edx, [ebp+var_174]
		add	edx, 48h ; 'H'
		push	edx
		mov	eax, [ebp+var_18C]
		push	eax
		call	_ucm_countChars
		add	esp, 0Ch
		cmp	eax, 1
		jz	short loc_1D48
		mov	esi, esp
		push	offset ??_C@_0FI@KLHCIHED@?5?5?5?5?5?5?5the?5substitution?5characte@ ; "       the substitution	character byte "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh
		jmp	loc_1F66
; ---------------------------------------------------------------------------

loc_1D48:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+636j
		mov	eax, [ebp+var_174]
		movzx	ecx, byte ptr [eax+50h]
		test	ecx, ecx
		jz	short loc_1DAE
		push	1
		mov	eax, [ebp+var_174]
		add	eax, 50h ; 'P'
		push	eax
		mov	ecx, [ebp+var_18C]
		push	ecx
		call	_ucm_countChars
		add	esp, 0Ch
		cmp	eax, 1
		jz	short loc_1DAE
		mov	esi, esp
		push	offset ??_C@_0EB@PMEFADGL@?5?5?5?5?5?5?5the?5subchar1?5byte?5is?5ille@ ; "	 the subchar1 byte is illegal in "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh
		jmp	loc_1F66
; ---------------------------------------------------------------------------

loc_1DAE:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+67Cj
					; createConverter(ConvData *,char const	*,UErrorCode *)+69Cj
		mov	eax, [ebp+var_18C]
		push	eax
		mov	ecx, [ebp+Dst]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		call	_ucm_checkValidity
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_1E00
		push	0
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+var_15C]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+var_18C]
		push	edx
		call	_ucm_checkBaseExt
		add	esp, 14h
		movsx	eax, al
		test	eax, eax
		jnz	short loc_1E0E

loc_1E00:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+6F3j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh
		jmp	loc_1F66
; ---------------------------------------------------------------------------

loc_1E0E:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+726j
		mov	eax, [ebp+var_180]
		cmp	dword ptr [eax+20408h],	1
		jle	loc_1F26
		call	_MBCSGetDummy
		mov	[ebp+var_3C4], eax
		mov	[ebp+var_3D0], 0
		mov	eax, [ebp+var_15C]
		mov	ecx, [eax]
		mov	edx, [ecx]
		mov	[ebp+var_3A0], edx
		mov	eax, [ebp+var_15C]
		mov	ecx, [eax]
		mov	edx, [ecx+8]
		imul	edx, 0Ch
		add	edx, [ebp+var_3A0]
		mov	[ebp+var_3AC], edx
		jmp	short loc_1E71
; ---------------------------------------------------------------------------

loc_1E62:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*):loc_1EEDj
		mov	eax, [ebp+var_3A0]
		add	eax, 0Ch
		mov	[ebp+var_3A0], eax

loc_1E71:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+788j
		mov	eax, [ebp+var_3A0]
		cmp	eax, [ebp+var_3AC]
		jnb	short loc_1EF2
		mov	eax, [ebp+var_3A0]
		movzx	ecx, byte ptr [eax+0Ah]
		push	ecx
		mov	edx, [ebp+var_3A0]
		mov	eax, [edx]
		push	eax
		mov	ecx, [ebp+var_3A0]
		movsx	edx, byte ptr [ecx+9]
		push	edx
		mov	eax, [ebp+var_3A0]
		add	eax, 4
		push	eax
		mov	ecx, [ebp+var_3C4]
		push	ecx
		call	_MBCSOkForBaseFromUnicode
		add	esp, 14h
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1EED
		mov	eax, [ebp+var_3A0]
		movsx	ecx, byte ptr [eax+0Ah]
		or	ecx, 10h
		mov	edx, [ebp+var_3A0]
		mov	[edx+0Ah], cl
		mov	eax, [ebp+var_3A0]
		mov	byte ptr [eax+0Bh], 1
		mov	eax, [ebp+var_3D0]
		add	eax, 1
		mov	[ebp+var_3D0], eax

loc_1EED:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+7E4j
		jmp	loc_1E62
; ---------------------------------------------------------------------------

loc_1EF2:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+7A5j
		cmp	[ebp+var_3D0], 0
		jz	short loc_1F26
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+var_15C]
		mov	ecx, [eax]
		push	ecx
		call	_ucm_moveMappings
		add	esp, 8
		mov	eax, [ebp+Dst]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		push	edx
		call	_ucm_sortTable
		add	esp, 4

loc_1F26:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+743j
					; createConverter(ConvData *,char const	*,UErrorCode *)+821j
		mov	eax, [ebp+Dst]
		add	eax, 0F0h ; ''
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+Dst]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+Dst]
		mov	edx, [ecx+8]
		push	edx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+8]
		mov	edx, [ecx+8]
		call	edx
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_1F66
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh

loc_1F66:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+3CBj
					; createConverter(ConvData *,char const	*,UErrorCode *)+415j ...
		lea	eax, [ebp+var_15C]
		push	eax
		call	?cleanupConvData@@YAXPAUConvData@@@Z ; cleanupConvData(ConvData	*)
		add	esp, 4

loc_1F75:				; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+3Dj
					; createConverter(ConvData *,char const	*,UErrorCode *)+7Dj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN59
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 494h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?createConverter@@YAXPAUConvData@@PBDPAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
$LN59		dd 2			; DATA XREF: createConverter(ConvData *,char const *,UErrorCode	*)+8A1o
		dd offset $LN58
$LN58		dd 0FFFFFEA4h, 154h	; DATA XREF: .text:00001FA8o
		dd offset $LN56		; "baseData"
		dd 0FFFFFC78h, 1F4h
		dd offset $LN57		; "baseFilename"
$LN57		db 'baseFilename',0     ; DATA XREF: .text:00001FC0o
$LN56		db 'baseData',0         ; DATA XREF: .text:00001FB4o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1FDCh
		public ??_C@_0DK@DHKEHOLK@error?3?5the?5?$DMicu?3base?$DO?5file?5?$CC?$CFs?$CC?5@
; char `string'[]
??_C@_0DK@DHKEHOLK@error?3?5the?5?$DMicu?3base?$DO?5file?5?$CC?$CFs?$CC?5@ db 'error: the <icu:base> file "%s" is not a base table file',0Ah,0
					; DATA XREF: createConverter(ConvData *,char const *,UErrorCode	*)+3E4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2018h
		public ??_C@_04IBAPKJLK@?4ucm?$AA@
; char `string'[]
??_C@_04IBAPKJLK@?4ucm?$AA@ db '.ucm',0 ; DATA XREF: createConverter(ConvData *,char const *,UErrorCode *)+37Do
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2020h
		public ??_C@_0EB@PMEFADGL@?5?5?5?5?5?5?5the?5subchar1?5byte?5is?5ille@
; char `string'[]
??_C@_0EB@PMEFADGL@?5?5?5?5?5?5?5the?5subchar1?5byte?5is?5ille@	db '       the subchar1 byte is illegal in this codepage structure!',0Ah
					; DATA XREF: createConverter(ConvData *,char const *,UErrorCode	*)+18Bo
					; createConverter(ConvData *,char const	*,UErrorCode *)+6A0o
		db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2064h
		public ??_C@_0FI@KLHCIHED@?5?5?5?5?5?5?5the?5substitution?5characte@
; char `string'[]
??_C@_0FI@KLHCIHED@?5?5?5?5?5?5?5the?5substitution?5characte@ db '       the substitution character byte sequence is illegal in thi'
					; DATA XREF: createConverter(ConvData *,char const *,UErrorCode	*)+114o
					; createConverter(ConvData *,char const	*,UErrorCode *)+63Ao
		db 's codepage structure!',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl readFile(struct ConvData *, char const *,	enum  UErrorCode *)
?readFile@@YACPAUConvData@@PBDPAW4UErrorCode@@@Z proc near
					; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+5Ap
					; createConverter(ConvData *,char const	*,UErrorCode *)+3A3p

var_4FC		= byte ptr -4FCh
var_435		= byte ptr -435h
var_42C		= dword	ptr -42Ch
var_420		= dword	ptr -420h
var_414		= dword	ptr -414h
Str1		= byte ptr -408h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 4FCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_4FC]
		mov	ecx, 13Fh
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2100
		xor	al, al
		jmp	loc_239C
; ---------------------------------------------------------------------------

loc_2100:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+3Bj
		call	_ucm_open
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax
		push	offset ??_C@_01KDCPPGHE@r?$AA@ ; "r"
		mov	eax, [ebp+arg_4]
		push	eax
		call	_T_FileStream_open
		add	esp, 8
		mov	[ebp+var_420], eax
		cmp	[ebp+var_420], 0
		jnz	short loc_213A
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 4
		xor	al, al
		jmp	loc_239C
; ---------------------------------------------------------------------------

loc_213A:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+6Cj
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_420]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?readHeader@@YAXPAUConvData@@PAU_FileStream@@PAW4UErrorCode@@@Z	; readHeader(ConvData *,_FileStream *,UErrorCode *)
		add	esp, 0Ch
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_216D
		xor	al, al
		jmp	loc_239C
; ---------------------------------------------------------------------------

loc_216D:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+A8j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movsx	edx, byte ptr [ecx+2041Ch]
		test	edx, edx
		jnz	short loc_21AB
		mov	[ebp+var_435], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		add	ecx, 8
		mov	[ebp+var_42C], ecx
		movzx	eax, ds:_IGNORE_SISO_CHECK
		push	eax
		mov	ecx, [ebp+var_42C]
		push	ecx
		call	_ucm_processStates
		add	esp, 8
		jmp	short loc_21BC
; ---------------------------------------------------------------------------

loc_21AB:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+BFj
		mov	[ebp+var_435], 0
		mov	[ebp+var_42C], 0

loc_21BC:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+EDj
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_42C]
		push	ecx
		movzx	edx, [ebp+var_435]
		push	edx
		mov	eax, [ebp+var_420]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		push	edx
		call	_ucm_readTable
		add	esp, 14h
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2200
		xor	al, al
		jmp	loc_239C
; ---------------------------------------------------------------------------

loc_2200:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+13Bj
					; readFile(ConvData *,char const *,UErrorCode *):loc_22C1j ...
		push	400h
		lea	eax, [ebp+Str1]
		push	eax
		mov	ecx, [ebp+var_420]
		push	ecx
		call	_T_FileStream_readLine
		add	esp, 0Ch
		test	eax, eax
		jz	loc_2333
		push	0		; Val
		lea	eax, [ebp+Str1]
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_414], eax

loc_223A:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+1D7j
		lea	eax, [ebp+Str1]
		cmp	eax, [ebp+var_414]
		jnb	short loc_2295
		mov	eax, [ebp+var_414]
		movsx	ecx, byte ptr [eax-1]
		cmp	ecx, 0Ah
		jz	short loc_2284
		mov	eax, [ebp+var_414]
		movsx	ecx, byte ptr [eax-1]
		cmp	ecx, 0Dh
		jz	short loc_2284
		mov	eax, [ebp+var_414]
		movsx	ecx, byte ptr [eax-1]
		cmp	ecx, 20h ; ' '
		jz	short loc_2284
		mov	eax, [ebp+var_414]
		movsx	ecx, byte ptr [eax-1]
		cmp	ecx, 9
		jnz	short loc_2295

loc_2284:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+199j
					; readFile(ConvData *,char const *,UErrorCode *)+1A8j ...
		mov	eax, [ebp+var_414]
		sub	eax, 1
		mov	[ebp+var_414], eax
		jmp	short loc_223A
; ---------------------------------------------------------------------------

loc_2295:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+18Aj
					; readFile(ConvData *,char const *,UErrorCode *)+1C6j
		mov	eax, [ebp+var_414]
		mov	byte ptr [eax],	0
		movsx	eax, [ebp+Str1]
		cmp	eax, 23h ; '#'
		jz	short loc_22C1
		lea	eax, [ebp+Str1]
		push	eax
		call	_u_skipWhitespace
		add	esp, 4
		cmp	eax, [ebp+var_414]
		jnz	short loc_22C6

loc_22C1:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+1ECj
		jmp	loc_2200
; ---------------------------------------------------------------------------

loc_22C6:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+203j
		push	offset ??_C@_07GOGBKBKH@CHARMAP?$AA@ ; "CHARMAP"
		lea	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_2302
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_42C]
		push	ecx
		push	0
		mov	edx, [ebp+var_420]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	_ucm_readTable
		add	esp, 14h
		jmp	short loc_232C
; ---------------------------------------------------------------------------

loc_2302:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+220j
		mov	esi, esp
		push	offset ??_C@_0CO@BNKIBFOH@unexpected?5text?5after?5the?5base?5m@ ; "unexpected text after the base mapping "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_232C:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+244j
		jmp	short loc_2333
; ---------------------------------------------------------------------------
		jmp	loc_2200
; ---------------------------------------------------------------------------

loc_2333:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+161j
					; readFile(ConvData *,char const *,UErrorCode *):loc_232Cj
		mov	eax, [ebp+var_420]
		push	eax
		call	_T_FileStream_close
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx]
		movsx	eax, byte ptr [edx+29h]
		cmp	eax, 3
		jz	short loc_2363
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		movsx	eax, byte ptr [edx+29h]
		cmp	eax, 3
		jnz	short loc_2396

loc_2363:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+294j
		mov	esi, esp
		push	offset ??_C@_0EI@JJAOHFPI@error?3?5some?5entries?5have?5the?5map@ ; "error: some entries have the mapping pr"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh

loc_2396:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+2A5j
		mov	al, [ebp+var_435]

loc_239C:				; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+3Fj
					; readFile(ConvData *,char const *,UErrorCode *)+79j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN22
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 4FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?readFile@@YACPAUConvData@@PBDPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN22		dd 1			; DATA XREF: readFile(ConvData *,char const *,UErrorCode *)+2E4o
		dd offset $LN21
$LN21		dd 0FFFFFBF8h, 400h	; DATA XREF: .text:000023D0o
		dd offset $LN20		; "line"
$LN20		db 'line',0             ; DATA XREF: .text:000023DCo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 23E8h
		public ??_C@_0EI@JJAOHFPI@error?3?5some?5entries?5have?5the?5map@
; char `string'[]
??_C@_0EI@JJAOHFPI@error?3?5some?5entries?5have?5the?5map@ db 'error: some entries have the mapping precision (with ',27h,'|',27h,'), '
					; DATA XREF: readFile(ConvData *,char const *,UErrorCode *)+2A9o
		db 'some do not',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2430h
		public ??_C@_0CO@BNKIBFOH@unexpected?5text?5after?5the?5base?5m@
; char `string'[]
??_C@_0CO@BNKIBFOH@unexpected?5text?5after?5the?5base?5m@ db 'unexpected text after the base mapping table',0Ah,0
					; DATA XREF: readFile(ConvData *,char const *,UErrorCode *)+248o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2460h
		public ??_C@_07GOGBKBKH@CHARMAP?$AA@
; char `string'[]
??_C@_07GOGBKBKH@CHARMAP?$AA@ db 'CHARMAP',0
					; DATA XREF: readFile(ConvData *,char const *,UErrorCode *):loc_22C6o
					; readHeader(ConvData *,_FileStream *,UErrorCode *):loc_2568o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2468h
		public ??_C@_01KDCPPGHE@r?$AA@
; `string'
??_C@_01KDCPPGHE@r?$AA@	db 'r',0        ; DATA XREF: readFile(ConvData *,char const *,UErrorCode *)+4Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 246Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char *__cdecl	strchr(char *Str, int Val)
		public ?strchr@@YAPADPADH@Z
?strchr@@YAPADPADH@Z proc near		; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+170p

var_C0		= byte ptr -0C0h
Str		= dword	ptr  8
Val		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+Val]
		push	eax		; Val
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?strchr@@YAPADPADH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl readHeader(struct ConvData *, struct _FileStream	*, enum	 UErrorCode *)
?readHeader@@YAXPAUConvData@@PAU_FileStream@@PAW4UErrorCode@@@Z	proc near
					; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+8Dp

var_564		= byte ptr -564h
var_4A0		= byte ptr -4A0h
var_475		= byte ptr -475h
Src		= byte ptr -46Ch
var_444		= dword	ptr -444h
var_438		= dword	ptr -438h
Source		= dword	ptr -42Ch
var_420		= dword	ptr -420h
var_414		= dword	ptr -414h
Str1		= byte ptr -408h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 564h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_564]
		mov	ecx, 159h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_24FA
		jmp	loc_29F5
; ---------------------------------------------------------------------------

loc_24FA:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+3Bj
		mov	eax, [ebp+arg_0]
		add	eax, 0F0h ; ''
		mov	[ebp+var_444], eax
		mov	eax, [ebp+var_444]
		mov	byte ptr [eax+44h], 0
		mov	eax, [ebp+var_444]
		mov	byte ptr [eax+4Ch], 0

loc_251C:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+AEj
					; readHeader(ConvData *,_FileStream *,UErrorCode *):loc_278Cj
		push	400h
		lea	eax, [ebp+Str1]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	_T_FileStream_readLine
		add	esp, 0Ch
		test	eax, eax
		jz	loc_2791
		lea	eax, [ebp+Source]
		push	eax
		lea	ecx, [ebp+var_420]
		push	ecx
		lea	edx, [ebp+Str1]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	_ucm_parseHeaderLine
		add	esp, 10h
		movsx	edx, al
		test	edx, edx
		jz	short loc_2568
		jmp	short loc_251C
; ---------------------------------------------------------------------------

loc_2568:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+ACj
		push	offset ??_C@_07GOGBKBKH@CHARMAP?$AA@ ; "CHARMAP"
		lea	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_2585
		jmp	loc_2791
; ---------------------------------------------------------------------------

loc_2585:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+C6j
		push	offset ??_C@_0O@PMHEBCGH@code_set_name?$AA@ ; "code_set_name"
		mov	eax, [ebp+var_420]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_25EB
		mov	eax, [ebp+Source]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_25E6
		mov	eax, [ebp+Source]
		push	eax		; Source
		mov	ecx, [ebp+var_444]
		add	ecx, 4
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8
		mov	eax, [ebp+var_444]
		add	eax, 40h ; '@'
		push	eax		; int
		mov	ecx, [ebp+var_444]
		add	ecx, 44h ; 'D'
		push	ecx		; int
		mov	edx, [ebp+Source]
		push	edx		; Str
		call	?getPlatformAndCCSIDFromName@@YAXPBDPACPAH@Z ; getPlatformAndCCSIDFromName(char	const *,signed char *,int *)
		add	esp, 0Ch

loc_25E6:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+F0j
		jmp	loc_278C
; ---------------------------------------------------------------------------

loc_25EB:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+E3j
		push	offset ??_C@_07DHHCIPCK@subchar?$AA@ ; "subchar"
		mov	eax, [ebp+var_420]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	loc_26E2
		mov	eax, [ebp+Source]
		mov	[ebp+var_414], eax
		lea	eax, [ebp+var_414]
		push	eax
		lea	ecx, [ebp+Str1]
		push	ecx
		lea	edx, [ebp+Src]
		push	edx
		call	_ucm_parseBytes
		add	esp, 0Ch
		mov	[ebp+var_475], al
		movsx	eax, [ebp+var_475]
		cmp	eax, 1
		jl	short loc_269E
		movsx	eax, [ebp+var_475]
		cmp	eax, 4
		jg	short loc_269E
		mov	eax, [ebp+var_414]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_269E
		mov	eax, [ebp+var_444]
		mov	cl, [ebp+var_475]
		mov	[eax+4Ch], cl
		push	1
		lea	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		movsx	ecx, [ebp+var_475]
		push	ecx		; Size
		lea	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+var_444]
		add	eax, 48h ; 'H'
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		jmp	short loc_26DD
; ---------------------------------------------------------------------------

loc_269E:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+188j
					; readHeader(ConvData *,_FileStream *,UErrorCode *)+194j ...
		mov	esi, esp
		mov	eax, [ebp+Source]
		push	eax
		push	offset ??_C@_0BN@IKIAJPCK@error?3?5illegal?5?$DMsubchar?$DO?5?$CFs?6?$AA@ ; "error: illegal <subchar> %s\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh
		jmp	loc_29F5
; ---------------------------------------------------------------------------

loc_26DD:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+1E4j
		jmp	loc_278C
; ---------------------------------------------------------------------------

loc_26E2:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+149j
		push	offset ??_C@_08BNNBLMOL@subchar1?$AA@ ;	"subchar1"
		mov	eax, [ebp+var_420]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	loc_278C
		mov	eax, [ebp+Source]
		mov	[ebp+var_414], eax
		lea	eax, [ebp+var_414]
		push	eax
		lea	ecx, [ebp+Str1]
		push	ecx
		lea	edx, [ebp+var_4A0]
		push	edx
		call	_ucm_parseBytes
		add	esp, 0Ch
		movsx	eax, al
		cmp	eax, 1
		jnz	short loc_274D
		mov	eax, [ebp+var_414]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_274D
		mov	eax, [ebp+var_444]
		mov	cl, [ebp+var_4A0]
		mov	[eax+50h], cl
		jmp	short loc_278C
; ---------------------------------------------------------------------------

loc_274D:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+275j
					; readHeader(ConvData *,_FileStream *,UErrorCode *)+282j
		mov	esi, esp
		mov	eax, [ebp+Source]
		push	eax
		push	offset ??_C@_0BO@JDOMDOBA@error?3?5illegal?5?$DMsubchar1?$DO?5?$CFs?6?$AA@ ; "error: illegal <subchar1>	%s\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh
		jmp	loc_29F5
; ---------------------------------------------------------------------------

loc_278C:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *):loc_25E6j
					; readHeader(ConvData *,_FileStream *,UErrorCode *):loc_26DDj ...
		jmp	loc_251C
; ---------------------------------------------------------------------------

loc_2791:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+7Ej
					; readHeader(ConvData *,_FileStream *,UErrorCode *)+C8j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_444]
		mov	al, [ecx+20410h]
		mov	[edx+47h], al
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_444]
		mov	al, [ecx+2040Ch]
		mov	[edx+46h], al
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_444]
		mov	al, [ecx+20418h]
		mov	[edx+45h], al
		mov	eax, [ebp+var_444]
		movsx	ecx, byte ptr [eax+45h]
		cmp	ecx, 0FFFFFFFFh
		jnz	short loc_2814
		mov	esi, esp
		push	offset ??_C@_0DE@KDMCFGMF@ucm?5error?3?5missing?5conversion?5ty@ ; "ucm	error: missing conversion type (<uc"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh
		jmp	loc_29F5
; ---------------------------------------------------------------------------

loc_2814:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+322j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movsx	edx, byte ptr [ecx+2041Ch]
		test	edx, edx
		jnz	loc_295D
		mov	eax, [ebp+var_444]
		movsx	ecx, byte ptr [eax+45h]
		mov	edx, dword ptr ds:_ucnv_converterStaticData[ecx*4]
		mov	[ebp+var_438], edx
		cmp	[ebp+var_438], 0
		jz	loc_295D
		mov	eax, [ebp+var_444]
		movsx	ecx, byte ptr [eax+4]
		test	ecx, ecx
		jnz	short loc_2876
		mov	eax, [ebp+var_438]
		add	eax, 4
		push	eax		; Source
		mov	ecx, [ebp+var_444]
		add	ecx, 4
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8

loc_2876:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+3A0j
		mov	eax, [ebp+var_444]
		cmp	dword ptr [eax+40h], 0
		jnz	short loc_2894
		mov	eax, [ebp+var_444]
		mov	ecx, [ebp+var_438]
		mov	edx, [ecx+40h]
		mov	[eax+40h], edx

loc_2894:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+3C8j
		mov	eax, [ebp+var_444]
		movsx	ecx, byte ptr [eax+44h]
		test	ecx, ecx
		jnz	short loc_28B4
		mov	eax, [ebp+var_444]
		mov	ecx, [ebp+var_438]
		mov	dl, [ecx+44h]
		mov	[eax+44h], dl

loc_28B4:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+3E8j
		mov	eax, [ebp+var_444]
		movsx	ecx, byte ptr [eax+46h]
		test	ecx, ecx
		jnz	short loc_28D4
		mov	eax, [ebp+var_444]
		mov	ecx, [ebp+var_438]
		mov	dl, [ecx+46h]
		mov	[eax+46h], dl

loc_28D4:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+408j
		mov	eax, [ebp+var_444]
		movsx	ecx, byte ptr [eax+47h]
		test	ecx, ecx
		jnz	short loc_28F4
		mov	eax, [ebp+var_444]
		mov	ecx, [ebp+var_438]
		mov	dl, [ecx+47h]
		mov	[eax+47h], dl

loc_28F4:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+428j
		mov	eax, [ebp+var_444]
		movsx	ecx, byte ptr [eax+4Ch]
		test	ecx, ecx
		jnz	short loc_295D
		mov	eax, [ebp+var_444]
		mov	ecx, [ebp+var_438]
		mov	dl, [ecx+4Ch]
		mov	[eax+4Ch], dl
		mov	eax, [ebp+var_438]
		movsx	ecx, byte ptr [eax+4Ch]
		test	ecx, ecx
		jle	short loc_295D
		push	1
		mov	eax, [ebp+var_438]
		add	eax, 48h ; 'H'
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+var_438]
		movsx	edx, byte ptr [ecx+4Ch]
		push	edx		; Size
		mov	eax, [ebp+var_438]
		add	eax, 48h ; 'H'
		push	eax		; Src
		mov	ecx, [ebp+var_444]
		add	ecx, 48h ; 'H'
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_295D:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+36Aj
					; readHeader(ConvData *,_FileStream *,UErrorCode *)+38Ej ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movsx	edx, byte ptr [ecx+20419h]
		test	edx, edx
		jge	short loc_2987
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movsx	edx, byte ptr [ecx+20410h]
		sub	edx, 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ecx+20419h], dl

loc_2987:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+4B3j
		mov	eax, [ebp+var_444]
		movzx	ecx, byte ptr [eax+50h]
		test	ecx, ecx
		jz	short loc_29F5
		mov	eax, [ebp+var_444]
		movsx	ecx, byte ptr [eax+46h]
		cmp	ecx, 1
		jg	short loc_29C2
		mov	eax, [ebp+var_444]
		movsx	ecx, byte ptr [eax+45h]
		cmp	ecx, 2
		jz	short loc_29F5
		mov	eax, [ebp+var_444]
		movsx	ecx, byte ptr [eax+45h]
		cmp	ecx, 9
		jz	short loc_29F5

loc_29C2:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+4EAj
		mov	esi, esp
		push	offset ??_C@_0EJ@LKLPEECH@error?3?5?$DMsubchar1?$DO?5defined?5for?5a?5@	; "error: <subchar1> defined for a type	ot"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Dh

loc_29F5:				; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+3Dj
					; readHeader(ConvData *,_FileStream *,UErrorCode *)+220j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN39_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 564h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?readHeader@@YAXPAUConvData@@PAU_FileStream@@PAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
$LN39_0		dd 6			; DATA XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+541o
		dd offset $LN38
$LN38		dd 0FFFFFBF8h, 400h	; DATA XREF: .text:00002A28o
		dd offset $LN32		; "line"
		dd 0FFFFFBECh, 4
		dd offset $LN33		; "s"
		dd 0FFFFFBE0h, 4
		dd offset $LN34		; "key"
		dd 0FFFFFBD4h, 4
		dd offset $LN35		; "value"
		dd 0FFFFFB94h, 1Fh
		dd offset $LN36		; "bytes"
		dd 0FFFFFB60h, 1Fh
		dd offset $LN37		; "bytes"
$LN37		db 'bytes',0            ; DATA XREF: .text:00002A70o
$LN36		db 'bytes',0            ; DATA XREF: .text:00002A64o
$LN35		db 'value',0            ; DATA XREF: .text:00002A58o
$LN34		db 'key',0              ; DATA XREF: .text:00002A4Co
$LN33		db 's',0                ; DATA XREF: .text:00002A40o
$LN32		db 'line',0             ; DATA XREF: .text:00002A34o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2A94h
		public ??_C@_0EJ@LKLPEECH@error?3?5?$DMsubchar1?$DO?5defined?5for?5a?5@
; char `string'[]
??_C@_0EJ@LKLPEECH@error?3?5?$DMsubchar1?$DO?5defined?5for?5a?5@ db 'error: <subchar1> defined for a type other than MBCS or EBCDIC_ST'
					; DATA XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+50Co
		db 'ATEFUL',0Ah,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2AE0h
		public ??_C@_0DE@KDMCFGMF@ucm?5error?3?5missing?5conversion?5ty@
; char `string'[]
??_C@_0DE@KDMCFGMF@ucm?5error?3?5missing?5conversion?5ty@ db 'ucm error: missing conversion type (<uconv_class>)',0Ah,0
					; DATA XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+326o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2B14h
		public ??_C@_0BO@JDOMDOBA@error?3?5illegal?5?$DMsubchar1?$DO?5?$CFs?6?$AA@
; char `string'[]
??_C@_0BO@JDOMDOBA@error?3?5illegal?5?$DMsubchar1?$DO?5?$CFs?6?$AA@ db 'error: illegal <subchar1> %s',0Ah,0
					; DATA XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+29Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2B34h
		public ??_C@_08BNNBLMOL@subchar1?$AA@
; char `string'[]
??_C@_08BNNBLMOL@subchar1?$AA@ db 'subchar1',0
					; DATA XREF: readHeader(ConvData *,_FileStream *,UErrorCode *):loc_26E2o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2B40h
		public ??_C@_0BN@IKIAJPCK@error?3?5illegal?5?$DMsubchar?$DO?5?$CFs?6?$AA@
; char `string'[]
??_C@_0BN@IKIAJPCK@error?3?5illegal?5?$DMsubchar?$DO?5?$CFs?6?$AA@ db 'error: illegal <subchar> %s',0Ah,0
					; DATA XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+1EFo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2B60h
		public ??_C@_07DHHCIPCK@subchar?$AA@
; char `string'[]
??_C@_07DHHCIPCK@subchar?$AA@ db 'subchar',0
					; DATA XREF: readHeader(ConvData *,_FileStream *,UErrorCode *):loc_25EBo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2B68h
		public ??_C@_0O@PMHEBCGH@code_set_name?$AA@
; char `string'[]
??_C@_0O@PMHEBCGH@code_set_name?$AA@ db	'code_set_name',0
					; DATA XREF: readHeader(ConvData *,_FileStream *,UErrorCode *):loc_2585o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl getPlatformAndCCSIDFromName(char *Str, int, int)
?getPlatformAndCCSIDFromName@@YAXPBDPACPAH@Z proc near
					; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+126p

var_C0		= byte ptr -0C0h
Str		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax]
		cmp	ecx, 69h ; 'i'
		jz	short loc_2BAC
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax]
		cmp	ecx, 49h ; 'I'
		jnz	short loc_2C20

loc_2BAC:				; CODE XREF: getPlatformAndCCSIDFromName(char const *,signed char *,int	*)+27j
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax+1]
		cmp	ecx, 62h ; 'b'
		jz	short loc_2BC4
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax+1]
		cmp	ecx, 42h ; 'B'
		jnz	short loc_2C20

loc_2BC4:				; CODE XREF: getPlatformAndCCSIDFromName(char const *,signed char *,int	*)+3Ej
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax+2]
		cmp	ecx, 6Dh ; 'm'
		jz	short loc_2BDC
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax+2]
		cmp	ecx, 4Dh ; 'M'
		jnz	short loc_2C20

loc_2BDC:				; CODE XREF: getPlatformAndCCSIDFromName(char const *,signed char *,int	*)+56j
		mov	eax, [ebp+Str]
		add	eax, 3
		mov	[ebp+Str], eax
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax]
		cmp	ecx, 2Dh ; '-'
		jnz	short loc_2BF9
		mov	eax, [ebp+Str]
		add	eax, 1
		mov	[ebp+Str], eax

loc_2BF9:				; CODE XREF: getPlatformAndCCSIDFromName(char const *,signed char *,int	*)+76j
		mov	eax, [ebp+arg_4]
		mov	byte ptr [eax],	0
		mov	esi, esp
		push	0Ah		; Radix
		push	0		; EndPtr
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	dword ptr ds:__imp__strtoul
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+arg_8]
		mov	[ecx], eax
		jmp	short loc_2C2F
; ---------------------------------------------------------------------------

loc_2C20:				; CODE XREF: getPlatformAndCCSIDFromName(char const *,signed char *,int	*)+32j
					; getPlatformAndCCSIDFromName(char const *,signed char *,int *)+4Aj ...
		mov	eax, [ebp+arg_4]
		mov	byte ptr [eax],	0FFh
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0

loc_2C2F:				; CODE XREF: getPlatformAndCCSIDFromName(char const *,signed char *,int	*)+A6j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getPlatformAndCCSIDFromName@@YAXPBDPACPAH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _uprv_isInvariantUString_56:near
					; CODE XREF: _uprv_isInvariantUnicodeString+44p
; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		extrn __imp_?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ:near
					; CODE XREF: _uprv_isInvariantUnicodeString+36p
					; DATA XREF: _uprv_isInvariantUnicodeString+36r
; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		extrn __imp_?length@UnicodeString@icu_56@@QBEHXZ:near
					; CODE XREF: _uprv_isInvariantUnicodeString+23p
					; DATA XREF: _uprv_isInvariantUnicodeString+23r
		extrn __RTC_CheckEsp:near ; CODE XREF: _uprv_isInvariantUnicodeString+2Bp
					; _uprv_isInvariantUnicodeString+3Ep ...
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; int __cdecl _fflush(FILE *File)
		extrn __imp__fflush:near ; CODE	XREF: _main+93Ap _main+95Fp
					; DATA XREF: ...
; int __cdecl _puts(const char *Str)
		extrn __imp__puts:near	; CODE XREF: _main+915p
					; DATA XREF: _main+915r
		extrn _uprv_isInvariantString_56:near ;	CODE XREF: _main+7D0p
		extrn _uprv_stricmp_56:near ; CODE XREF: _main+766p
		extrn _u_errorName_56:near ; CODE XREF:	_main+687p _main+878p	...
; char *__cdecl	strcpy(char *Dest, const char *Source)
		extrn _strcpy:near	; CODE XREF: _main+5B0p _main+7C2p ...
; char *__thiscall icu_56::CharString::data(icu_56::CharString *__hidden this)
		extrn __imp_?data@CharString@icu_56@@QAEPADXZ:near ; CODE XREF:	_main+51Ep
					; _main+595p ...
; int __thiscall icu_56::CharString::lastIndexOf(icu_56::CharString *__hidden this, char)
		extrn __imp_?lastIndexOf@CharString@icu_56@@QBEHD@Z:near
					; CODE XREF: _main+4B7p
					; DATA XREF: _main+4B7r
		extrn _findBasename:near ; CODE	XREF: _main+3D6p
					; createConverter(ConvData *,char const	*,UErrorCode *)+354p
; struct icu_56::CharString *__thiscall	icu_56::CharString::truncate(icu_56::CharString	*__hidden this,	int)
		extrn __imp_?truncate@CharString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: _main+3B9p _main+4E7p
					; DATA XREF: ...
		extrn _getLongPathname:near ; CODE XREF: _main+39Cp
; int __thiscall icu_56::CharString::length(icu_56::CharString *__hidden this)
		extrn __imp_?length@CharString@icu_56@@QBEHXZ:near ; CODE XREF:	_main+329p
					; _main+4FCp
					; DATA XREF: ...
; _DWORD __thiscall icu_56::CharString::~CharString(icu_56::CharString *__hidden this)
		extrn __imp_??1CharString@icu_56@@QAE@XZ:near ;	CODE XREF: _main+309p
					; _main+495p ...
; struct icu_56::CharString *__thiscall	icu_56::CharString::ensureEndsWithFileSeparator(icu_56::CharString *__hidden this, enum	UErrorCode *)
		extrn __imp_?ensureEndsWithFileSeparator@CharString@icu_56@@QAEAAV12@AAW4UErrorCode@@@Z:near
					; CODE XREF: _main+2CBp
					; DATA XREF: _main+2CBr
; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *__hidden	this, const struct icu_56::StringPiece *, enum UErrorCode *)
		extrn __imp_?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: _main+2BCp _main+416p ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const char *)
		extrn __imp_??0StringPiece@icu_56@@QAE@PBD@Z:near ; CODE XREF: _main+290p
					; _main+3F3p ...
; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *__hidden	this)
		extrn __imp_??0CharString@icu_56@@QAE@XZ:near ;	CODE XREF: _main+245p
					; DATA XREF: _main+245r
; void __cdecl __noreturn _exit(int Code)
		extrn __imp__exit:near	; CODE XREF: _main+1EBp
					; DATA XREF: _main+1EBr
; int _printf(const char *Format, ...)
		extrn __imp__printf:near ; CODE	XREF: _main+1BBp _main+1D7p ...
; int _fprintf(FILE *File, const char *Format, ...)
		extrn __imp__fprintf:near ; CODE XREF: _main+C6p _main+15Dp ...
; FILE *__cdecl	___iob_func()
		extrn __imp____iob_func:near ; CODE XREF: _main+B5p _main+10Dp ...
		extrn _u_parseArgs:near	; CODE XREF: _main+8Fp
		extrn _u_getDataDirectory_56:near ; CODE XREF: _main+76p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _main+6Ep
					; createConverter(ConvData *,char const	*,UErrorCode *)+531p ...
		extrn _uprv_checkValidMemory:near ; CODE XREF: _main+58p
					; createConverter(ConvData *,char const	*,UErrorCode *)+519p ...
		extrn _u_getVersion_56:near ; CODE XREF: _main+47p
		extrn ___security_cookie:near ;	DATA XREF: _main+2Cr
					; createConverter(ConvData *,char const	*,UErrorCode *)+1Er ...
		extrn ___CxxFrameHandler3:near ; CODE XREF: __ehhandler$_main+23j
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _main+9D5p
					; __ehhandler$_main+Fp	...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near ; CODE XREF: _main+9BBp
					; createConverter(ConvData *,char const	*,UErrorCode *)+8A7p ...
; char *__cdecl	_strrchr(const char *Str, int Ch)
		extrn __imp__strrchr:near ; CODE XREF: strrchr(char *,int)+28p
					; DATA XREF: strrchr(char *,int)+28r
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: initConvData(ConvData *)+29p
		extrn _ucm_close:near	; CODE XREF: cleanupConvData(ConvData *)+8Ap
		extrn _udata_finish:near
					; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+1CFp
		extrn _udata_writeBlock:near
					; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+13Ap
		extrn _udata_create:near
					; CODE XREF: writeConverterData(ConvData *,char	const *,char const *,UErrorCode	*)+99p
		extrn _MBCSOkForBaseFromUnicode:near
					; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+7D7p
		extrn _MBCSGetDummy:near
					; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+749p
		extrn _ucm_checkValidity:near
					; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+6E6p
		extrn _ucm_countChars:near
					; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+62Bp
					; createConverter(ConvData *,char const	*,UErrorCode *)+691p
; char *__cdecl	strcat(char *Dest, const char *Source)
		extrn _strcat:near	; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+389p
		extrn _CnvExtOpen:near	; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+2C4p
					; createConverter(ConvData *,char const	*,UErrorCode *)+420p
		extrn _ucm_moveMappings:near
					; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+297p
					; createConverter(ConvData *,char const	*,UErrorCode *)+835p
		extrn _ucm_sortTable:near
					; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+221p
					; createConverter(ConvData *,char const	*,UErrorCode *)+2A8p ...
		extrn _ucm_checkBaseExt:near
					; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+1EFp
					; createConverter(ConvData *,char const	*,UErrorCode *)+719p
		extrn _MBCSOpen:near	; CODE XREF: createConverter(ConvData *,char const *,UErrorCode	*)+B3p
		extrn _T_FileStream_close:near
					; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+27Ep
; int __cdecl strcmp(const char	*Str1, const char *Str2)
		extrn _strcmp:near	; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+216p
					; readHeader(ConvData *,_FileStream *,UErrorCode *)+BCp ...
		extrn _u_skipWhitespace:near
					; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+1F5p
		extrn _T_FileStream_readLine:near
					; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+157p
					; readHeader(ConvData *,_FileStream *,UErrorCode *)+74p
		extrn _ucm_readTable:near
					; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+120p
					; readFile(ConvData *,char const *,UErrorCode *)+23Cp
		extrn _ucm_processStates:near
					; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+E5p
		extrn _T_FileStream_open:near
					; CODE XREF: readFile(ConvData *,char const *,UErrorCode *)+57p
		extrn _ucm_open:near	; CODE XREF: readFile(ConvData *,char const *,UErrorCode *):loc_2100p
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: strchr(char *,int)+28p
					; DATA XREF: strchr(char *,int)+28r
		extrn _ucnv_converterStaticData:near
					; DATA XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+37Ar
		extrn _ucm_parseBytes:near
					; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+170p
					; readHeader(ConvData *,_FileStream *,UErrorCode *)+267p
		extrn _ucm_parseHeaderLine:near
					; CODE XREF: readHeader(ConvData *,_FileStream *,UErrorCode *)+9Fp
; unsigned __int32 __cdecl _strtoul(const char *Str, char **EndPtr, int	Radix)
		extrn __imp__strtoul:near
					; CODE XREF: getPlatformAndCCSIDFromName(char const *,signed char *,int	*)+91p
					; DATA XREF: getPlatformAndCCSIDFromName(char const *,signed char *,int	*)+91r


		end
