;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	9D15EAEDF7A300EBE8C4A811BD01F926
; Input	CRC32 :	D774B8FF

; File Name   :	D:\compspace\objfiles\firefox\i18n\rbnf.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB db 3, 0
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
word_22		dw 0			; DATA XREF: .rdata:_DQUOTE_STOPLISTo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB db 4, 2 dup(0)
byte_27		db 0			; DATA XREF: .rdata:_SQUOTE_STOPLISTo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1	; DATA XREF: .text:000055A0o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset _gPercentPercent ;	"%%"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_FFB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_4000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_7FFC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .text:00008088o
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F8h
		public ?MAX_LENGTH@Part@MessagePattern@icu_56@@0HB
; private: static int const icu_56::MessagePattern::Part::MAX_LENGTH
?MAX_LENGTH@Part@MessagePattern@icu_56@@0HB dd 0FFFFh
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0FCh
		public ?MAX_VALUE@Part@MessagePattern@icu_56@@0HB
; private: static int const icu_56::MessagePattern::Part::MAX_VALUE
?MAX_VALUE@Part@MessagePattern@icu_56@@0HB dd offset loc_7FFC+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 100h
; wchar_t gPercentPercent
_gPercentPercent:			; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
					; icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString const	&,icu_56::UnicodeString	&,icu_56::FieldPosition	&,UErrorCode &)+42o ...
		unicode	0, <%%>,0
		align 4
; wchar_t gLenientParse
_gLenientParse:				; DATA XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+148o
					; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode	&):loc_8D0Bo
		unicode	0, <%%lenient-parse:>,0
		align 4
; wchar_t gSemiPercent
_gSemiPercent:				; DATA XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+19Do
					; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode	&)+342o ...
		unicode	0, <;%>,0
		align 4
_DQUOTE_STOPLIST dd offset word_22	; DATA XREF: icu_56::LocDataParser::nextString(void)+95o
_SQUOTE_STOPLIST dd offset byte_27	; DATA XREF: icu_56::LocDataParser::nextString(void):loc_3CB1o
_NOQUOTE_STOPLIST:			; DATA XREF: icu_56::LocDataParser::nextString(void):loc_3CC6o
		unicode	0, < ,>
		dw 3Eh,	3Ch, 27h
		unicode	0, <">,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 14Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; char `public:	static void * __cdecl icu_56::RuleBasedNumberFormat::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@RuleBasedNumberFormat@icu_56@@SAPAXXZ@4DA	db ?
					; DATA XREF: icu_56::RuleBasedNumberFormat::getStaticClassID(void)+1Eo
		align 10h
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 150h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 188h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 18Ch
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 190h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp

loc_1C0:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::DecimalFormatSymbols::operator!=(class	icu_56::DecimalFormatSymbols const &)const
		public ??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z
??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8DecimalFormatSymbols@icu_56@@QBECABV01@@Z ; icu_56::DecimalFormatSymbols::operator==(icu_56::DecimalFormatSymbols const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx

loc_1FE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 214h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DecimalFormatSymbols::isCustomCurrencySymbol(icu_56::DecimalFormatSymbols *__hidden this)
		public ?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ
?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+0AD0h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 248h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DecimalFormatSymbols::isCustomIntlCurrencySymbol(icu_56::DecimalFormatSymbols *__hidden this)
		public ?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ
?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+0AD1h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::DecimalFormatSymbols::getSymbol(enum  icu_56::DecimalFormatSymbols::ENumberFormatSymbol)const
		public ?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z
?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+A6p
					; icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode &)+A6p

var_E4		= byte ptr -0E4h
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_E0], 0
		cmp	[ebp+arg_4], 1Ch
		jge	short loc_2C1
		mov	eax, [ebp+arg_4]
		shl	eax, 6
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax+4]
		mov	[ebp+var_14], edx
		jmp	short loc_2CC
; ---------------------------------------------------------------------------

loc_2C1:				; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+31j
		mov	eax, [ebp+var_8]
		add	eax, 704h
		mov	[ebp+var_14], eax

loc_2CC:				; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+43j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_E0]
		or	ecx, 1
		mov	[ebp+var_E0], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString const & __thiscall icu_56::DecimalFormatSymbols::getConstSymbol(enum  icu_56::DecimalFormatSymbols::ENumberFormatSymbol)const
		public ?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z
?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 1Ch
		jge	short loc_347
		mov	eax, [ebp+arg_0]
		shl	eax, 6
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax+4]
		mov	[ebp+var_14], edx
		jmp	short loc_352
; ---------------------------------------------------------------------------

loc_347:				; CODE XREF: icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+27j
		mov	eax, [ebp+var_8]
		add	eax, 704h
		mov	[ebp+var_14], eax

loc_352:				; CODE XREF: icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+39j
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 360h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::DecimalFormatSymbols::setSymbol(enum	icu_56::DecimalFormatSymbols::ENumberFormatSymbol, class icu_56::UnicodeString const &,	signed char)
		public ?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z proc near

var_144		= dword	ptr -144h
var_140		= dword	ptr -140h
var_138		= byte ptr -138h
var_2D		= byte ptr -2Dh
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_144]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_0], 8
		jnz	short loc_3B7
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+0AD0h], 1
		jmp	short loc_3C7
; ---------------------------------------------------------------------------

loc_3B7:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+49j
		cmp	[ebp+arg_0], 9
		jnz	short loc_3C7
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+0AD1h], 1

loc_3C7:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+55j
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+5Bj
		cmp	[ebp+arg_0], 1Ch
		jge	short loc_3ED
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		shl	ecx, 6
		mov	edx, [ebp+var_18]
		lea	ecx, [edx+ecx+4]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3ED:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+6Bj
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_4EE
		cmp	[ebp+arg_0], 4

loc_3FD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		jnz	loc_4EE
		mov	esi, esp
		push	7FFFFFFFh	; int
		push	0		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z ; icu_56::UnicodeString::countChar32(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	loc_4EE
		mov	esi, esp
		push	0		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?char32At@UnicodeString@icu_56@@QBEHH@Z ; icu_56::UnicodeString::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		push	eax
		call	_u_charDigitValue_56
		add	esp, 4
		test	eax, eax
		jnz	loc_4EE
		mov	[ebp+var_2D], 1
		jmp	short loc_45E
; ---------------------------------------------------------------------------

loc_456:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+189j
		mov	al, [ebp+var_2D]
		add	al, 1
		mov	[ebp+var_2D], al

loc_45E:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+F4j
		movsx	eax, [ebp+var_2D]
		cmp	eax, 9
		jg	loc_4EE
		mov	eax, [ebp+var_24]
		add	eax, 1
		mov	[ebp+var_24], eax
		mov	esi, esp
		mov	eax, [ebp+var_24]
		push	eax		; int
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@H@Z ; icu_56::UnicodeString::UnicodeString(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_140], eax
		mov	ecx, [ebp+var_140]
		mov	[ebp+var_144], ecx
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	edx, [ebp+var_144]
		push	edx
		movsx	eax, [ebp+var_2D]
		add	eax, 11h
		shl	eax, 6
		mov	ecx, [ebp+var_18]
		lea	ecx, [ecx+eax+4]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z	; icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_456
; ---------------------------------------------------------------------------

loc_4EE:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+93j
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char):loc_3FDj ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 51Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0 proc near
					; DATA XREF: .xdata$x:00000560o
		mov	esi, esp
		lea	ecx, [ebp-138h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z	proc near
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-148h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		jmp	___CxxFrameHandler3
__ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 55Ch
__unwindtable$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000056Co
		dd offset __unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0
__ehfuncinfo$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+1Eo
		dd offset __unwindtable$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 588h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Locale __thiscall icu_56::DecimalFormatSymbols::getLocale(void)const
		public ?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ
?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+var_8]
		add	eax, 744h
		mov	esi, esp
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_D4]
		or	ecx, 1
		mov	[ebp+var_D4], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::DecimalFormatSymbols::getCurrencyPattern(icu_56::DecimalFormatSymbols *__hidden this)
		public ?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ
?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+94Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 62Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Formattable::operator!=(class icu_56::Formattable const &)const
		public ??9Formattable@icu_56@@QBECABV01@@Z
??9Formattable@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8Formattable@icu_56@@QBECABV01@@Z ; icu_56::Formattable::operator==(icu_56::Formattable const	&)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Formattable@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 67Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDouble(icu_56::Formattable *__hidden this)
		public ?getDouble@Formattable@icu_56@@QBENXZ
?getDouble@Formattable@icu_56@@QBENXZ proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+37Dp
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+39Cp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDouble@Formattable@icu_56@@QBENXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *__hidden this)
		public ?getLong@Formattable@icu_56@@QBEHXZ
?getLong@Formattable@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLong@Formattable@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __thiscall icu_56::Formattable::getInt64(icu_56::Formattable *__hidden this)
		public ?getInt64@Formattable@icu_56@@QBE_JXZ
?getInt64@Formattable@icu_56@@QBE_JXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx+8]
		mov	edx, [ecx+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getInt64@Formattable@icu_56@@QBE_JXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 710h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDate(icu_56::Formattable *__hidden this)
		public ?getDate@Formattable@icu_56@@QBENXZ
?getDate@Formattable@icu_56@@QBENXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDate@Formattable@icu_56@@QBENXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 740h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *this, struct icu_56::UnicodeString *)
		public ?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 798h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__thiscall icu_56::Formattable::getArray(icu_56::Formattable *this,	int *)
		public ?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z
?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Formattable & __thiscall icu_56::Formattable::operator[](int)
		public ??AFormattable@icu_56@@QAEAAV01@H@Z
??AFormattable@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]

loc_7FE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		imul	eax, 0E0h
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??AFormattable@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 814h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::DigitList *__thiscall icu_56::Formattable::getDigitList(icu_56::Formattable *__hidden this)
		public ?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ
?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 844h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDate(icu_56::Formattable *this, enum UErrorCode *)
		public ?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z
?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+98h], 0
		jz	short loc_895
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_891
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 3

loc_891:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+42j
		fldz
		jmp	short loc_89B
; ---------------------------------------------------------------------------

loc_895:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+2Dj
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]

loc_89B:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+4Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8B4h
		public __real@0000000000000000
__real@0000000000000000	dd 2 dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+35p
					; icu_56::LocDataParser::doParse(void)+214p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *__hidden this)
		public ?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ
?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 918h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *__hidden	this)
		public ?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ
?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 948h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *this, enum UErrorCode *)
		public ?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z
?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?getLong@Formattable@icu_56@@QBEHAAW4UErrorCode@@@Z ; icu_56::Formattable::getLong(UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 990h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void **__thiscall icu_56::Formattable::toUFormattable(icu_56::Formattable *__hidden this)
		public ?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ
?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *const *__thiscall icu_56::Formattable::toUFormattable(icu_56::Formattable *__hidden this)
		public ?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ
?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::Formattable *__cdecl icu_56::Formattable::fromUFormattable(void **)
		public ?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z
?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__cdecl icu_56::Formattable::fromUFormattable(void *const *)
		public ?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z
?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *__hidden this)
		public ??0FieldPosition@icu_56@@QAE@XZ
??0FieldPosition@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0FieldPosition@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0AB4h
		dd offset ??_R4FieldPosition@icu_56@@6B@ ; const icu_56::FieldPosition::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7FieldPosition@icu_56@@6B@
; const	icu_56::FieldPosition::`vftable'
??_7FieldPosition@icu_56@@6B@ dd offset	??_EFieldPosition@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::FieldPosition::FieldPosition(void)+38o
					; icu_56::FieldPosition::FieldPosition(int)+38o ...
					; icu_56::FieldPosition::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@FieldPosition@icu_56@@UBEPAXXZ ; icu_56::FieldPosition::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AC0h
		public ??_R4FieldPosition@icu_56@@6B@
; const	icu_56::FieldPosition::`RTTI Complete Object Locator'
??_R4FieldPosition@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00000AB4o
		dd offset ??_R0?AVFieldPosition@icu_56@@@8 ; icu_56::FieldPosition `RTTI Type Descriptor'
		dd offset ??_R3FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0AD4h
		public ??_R0?AVFieldPosition@icu_56@@@8
; class	icu_56::FieldPosition `RTTI Type Descriptor'
??_R0?AVFieldPosition@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00000ACCo
					; .rdata$r:icu_56::FieldPosition::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avfieldposit	db '.?AVFieldPosition@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AF8h
		public ??_R3FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
??_R3FieldPosition@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00000AD0o
					; .rdata$r:00000B30o
		dd 3
		dd offset ??_R2FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B08h
		public ??_R2FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Base Class Array'
??_R2FieldPosition@icu_56@@8 dd	offset ??_R1A@?0A@EA@FieldPosition@icu_56@@8
					; DATA XREF: .rdata$r:00000B04o
					; icu_56::FieldPosition::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B18h
		public ??_R1A@?0A@EA@FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@FieldPosition@icu_56@@8 dd offset	??_R0?AVFieldPosition@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::FieldPosition::`RTTI Base	Class Array'o
					; icu_56::FieldPosition	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B34h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:00000B0Co
					; .rdata$r:icu_56::UObject::`RTTI Base Class Array'o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0B50h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B70h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000B4Co
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B80h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000B7Co
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B8Ch
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000B10o
					; .rdata$r:00000B84o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0BA8h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BC8h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000BA4o
					; .rdata$r:00000BF8o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BD8h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00000BD4o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BE0h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *this, int)
		public ??0FieldPosition@icu_56@@QAE@H@Z
??0FieldPosition@icu_56@@QAE@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FieldPosition@icu_56@@QAE@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *this, const struct icu_56::FieldPosition *)
		public ??0FieldPosition@icu_56@@QAE@ABV01@@Z
??0FieldPosition@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FieldPosition@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getField(icu_56::FieldPosition *__hidden this)
		public ?getField@FieldPosition@icu_56@@QBEHXZ
?getField@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getField@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getBeginIndex(icu_56::FieldPosition *__hidden this)
		public ?getBeginIndex@FieldPosition@icu_56@@QBEHXZ
?getBeginIndex@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBeginIndex@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getEndIndex(icu_56::FieldPosition *__hidden this)
		public ?getEndIndex@FieldPosition@icu_56@@QBEHXZ
?getEndIndex@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getEndIndex@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setField(icu_56::FieldPosition	*this, int)
		public ?setField@FieldPosition@icu_56@@QAEXH@Z
?setField@FieldPosition@icu_56@@QAEXH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setField@FieldPosition@icu_56@@QAEXH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setBeginIndex(icu_56::FieldPosition *this, int)
		public ?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z
?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setEndIndex(icu_56::FieldPosition *this, int)
		public ?setEndIndex@FieldPosition@icu_56@@QAEXH@Z
?setEndIndex@FieldPosition@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx

loc_DFD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setEndIndex@FieldPosition@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPosition::`scalar deleting destructor'(unsigned int)
		public ??_GFieldPosition@icu_56@@UAEPAXI@Z
??_GFieldPosition@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPosition@icu_56@@UAE@XZ	; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E71
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_E71:				; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GFieldPosition@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPosition::`vector deleting destructor'(unsigned int)
		public ??_EFieldPosition@icu_56@@UAEPAXI@Z
??_EFieldPosition@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::FieldPosition::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_EF7
		push	offset ??1FieldPosition@icu_56@@UAE@XZ ; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_EEF
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_EEF:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_F20
; ---------------------------------------------------------------------------

loc_EF7:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPosition@icu_56@@UAE@XZ	; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F1D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_F1D:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_F20:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EFieldPosition@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FieldPosition &	__thiscall icu_56::FieldPosition::operator=(class icu_56::FieldPosition	const &)
		public ??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z
??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPosition::operator==(class icu_56::FieldPosition const &)const
		public ??8FieldPosition@icu_56@@QBECABV01@@Z
??8FieldPosition@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::FieldPosition::operator!=(icu_56::FieldPosition const &)+2Ap

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_FE2
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+0Ch]
		cmp	edx, [ecx+0Ch]
		jnz	short loc_FE2
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+8]
		cmp	edx, [ecx+8]
		jnz	short loc_FE2
		mov	[ebp+var_CD], 1
		jmp	short loc_FE9
; ---------------------------------------------------------------------------

loc_FE2:				; CODE XREF: icu_56::FieldPosition::operator==(icu_56::FieldPosition const &)+2Fj
					; icu_56::FieldPosition::operator==(icu_56::FieldPosition const	&)+3Dj	...
		mov	[ebp+var_CD], 0

loc_FE9:				; CODE XREF: icu_56::FieldPosition::operator==(icu_56::FieldPosition const &)+54j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8FieldPosition@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPosition::operator!=(class icu_56::FieldPosition const &)const
		public ??9FieldPosition@icu_56@@QBECABV01@@Z
??9FieldPosition@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp

loc_FFB:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8FieldPosition@icu_56@@QBECABV01@@Z ;	icu_56::FieldPosition::operator==(icu_56::FieldPosition	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9FieldPosition@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1048h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPositionIterator::operator!=(class icu_56::FieldPositionIterator const &)const
		public ??9FieldPositionIterator@icu_56@@QBECABV01@@Z
??9FieldPositionIterator@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8FieldPositionIterator@icu_56@@QBECABV01@@Z ;	icu_56::FieldPositionIterator::operator==(icu_56::FieldPositionIterator	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9FieldPositionIterator@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1098h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FieldPositionIterator &	__thiscall icu_56::FieldPositionIterator::operator=(class icu_56::FieldPositionIterator	const &)
		public ??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z
??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1104h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Format::operator!=(class icu_56::Format const &)const
		public ??9Format@icu_56@@QBECABV01@@Z
??9Format@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Format@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1160h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__thiscall icu_56::Measure::getNumber(icu_56::Measure *__hidden this)
		public ?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ
?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 8
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1190h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::MeasureUnit *__thiscall icu_56::Measure::getUnit(icu_56::Measure	*__hidden this)
		public ?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ
?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	proc near
					; CODE XREF: icu_56::CurrencyAmount::getCurrency(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0E8h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MeasureUnit::MeasureUnit(icu_56::MeasureUnit *__hidden this)
		public ??0MeasureUnit@icu_56@@QAE@XZ
??0MeasureUnit@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0MeasureUnit@icu_56@@QAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1234h
		dd offset ??_R4MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7MeasureUnit@icu_56@@6B@
; const	icu_56::MeasureUnit::`vftable'
??_7MeasureUnit@icu_56@@6B@ dd offset ??_EMeasureUnit@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::MeasureUnit::MeasureUnit(void)+38o
					; icu_56::MeasureUnit::MeasureUnit(int,int)+38o
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@MeasureUnit@icu_56@@UBEPAXXZ ; icu_56::MeasureUnit::getDynamicClassID(void)
		dd offset ?clone@MeasureUnit@icu_56@@UBEPAVUObject@2@XZ	; icu_56::MeasureUnit::clone(void)
		dd offset ??8MeasureUnit@icu_56@@UBECABVUObject@1@@Z ; icu_56::MeasureUnit::operator==(icu_56::UObject const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1248h
		public ??_R4MeasureUnit@icu_56@@6B@
; const	icu_56::MeasureUnit::`RTTI Complete Object Locator'
??_R4MeasureUnit@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00001234o
		dd offset ??_R0?AVMeasureUnit@icu_56@@@8 ; icu_56::MeasureUnit `RTTI Type Descriptor'
		dd offset ??_R3MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 125Ch
		public ??_R0?AVMeasureUnit@icu_56@@@8
; class	icu_56::MeasureUnit `RTTI Type Descriptor'
??_R0?AVMeasureUnit@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00001254o
					; .rdata$r:icu_56::MeasureUnit::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avmeasureuni	db '.?AVMeasureUnit@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1280h
		public ??_R3MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Class Hierarchy Descriptor'
??_R3MeasureUnit@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00001258o
					; .rdata$r:000012B8o
		dd 3
		dd offset ??_R2MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1290h
		public ??_R2MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Base Class	Array'
??_R2MeasureUnit@icu_56@@8 dd offset ??_R1A@?0A@EA@MeasureUnit@icu_56@@8
					; DATA XREF: .rdata$r:0000128Co
					; icu_56::MeasureUnit::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 12A0h
		public ??_R1A@?0A@EA@MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@MeasureUnit@icu_56@@8 dd offset ??_R0?AVMeasureUnit@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::MeasureUnit::`RTTI Base Class Array'o
					; icu_56::MeasureUnit `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MeasureUnit::operator!=(class icu_56::UObject const &)const
		public ??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z
??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1318h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MeasureUnit::MeasureUnit(icu_56::MeasureUnit *this,	int, int)
		public ??0MeasureUnit@icu_56@@AAE@HH@Z
??0MeasureUnit@icu_56@@AAE@HH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0MeasureUnit@icu_56@@AAE@HH@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1388h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MeasureUnit::`scalar deleting destructor'(unsigned int)
		public ??_GMeasureUnit@icu_56@@UAEPAXI@Z
??_GMeasureUnit@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1MeasureUnit@icu_56@@UAE@XZ ;	icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_13D1
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_13D1:				; CODE XREF: icu_56::MeasureUnit::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GMeasureUnit@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MeasureUnit::`vector deleting destructor'(unsigned int)
		public ??_EMeasureUnit@icu_56@@UAEPAXI@Z
??_EMeasureUnit@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::MeasureUnit::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1457
		push	offset ??1MeasureUnit@icu_56@@UAE@XZ ; icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_144F
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_144F:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1480
; ---------------------------------------------------------------------------

loc_1457:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1MeasureUnit@icu_56@@UAE@XZ ;	icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_147D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_147D:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_1480:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EMeasureUnit@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1498h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::CurrencyUnit::getISOCurrency(icu_56::CurrencyUnit *__hidden	this)
		public ?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ
?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ proc near
					; CODE XREF: icu_56::CurrencyAmount::getISOCurrency(void)+2Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 10h
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::CurrencyUnit *__thiscall	icu_56::CurrencyAmount::getCurrency(icu_56::CurrencyAmount *__hidden this)
		public ?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ
?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ proc near
					; CODE XREF: icu_56::CurrencyAmount::getISOCurrency(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	; icu_56::Measure::getUnit(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1508h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::CurrencyAmount::getISOCurrency(icu_56::CurrencyAmount *__hidden this)
		public ?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ
?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ ; icu_56::CurrencyAmount::getCurrency(void)
		mov	ecx, eax	; this
		call	?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ ; icu_56::CurrencyUnit::getISOCurrency(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1550h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory *__hidden this)
		public ??0NumberFormatFactory@icu_56@@QAE@XZ
??0NumberFormatFactory@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0NumberFormatFactory@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 15A8h
		dd offset ??_R4NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7NumberFormatFactory@icu_56@@6B@
; const	icu_56::NumberFormatFactory::`vftable'
??_7NumberFormatFactory@icu_56@@6B@ dd offset ??_ENumberFormatFactory@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::NumberFormatFactory::NumberFormatFactory(void)+38o
					; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)+3Co
					; icu_56::NumberFormatFactory::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 15C0h
		public ??_R4NumberFormatFactory@icu_56@@6B@
; const	icu_56::NumberFormatFactory::`RTTI Complete Object Locator'
??_R4NumberFormatFactory@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:000015A8o
		dd offset ??_R0?AVNumberFormatFactory@icu_56@@@8 ; icu_56::NumberFormatFactory `RTTI Type Descriptor'
		dd offset ??_R3NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 15D4h
		public ??_R0?AVNumberFormatFactory@icu_56@@@8
; class	icu_56::NumberFormatFactory `RTTI Type Descriptor'
??_R0?AVNumberFormatFactory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000015CCo
					; .rdata$r:icu_56::NumberFormatFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avnumberform	db '.?AVNumberFormatFactory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1600h
		public ??_R3NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Class Hierarchy Descriptor'
??_R3NumberFormatFactory@icu_56@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:000015D0o
					; .rdata$r:00001638o
		dd 3
		dd offset ??_R2NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1610h
		public ??_R2NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Base Class	Array'
??_R2NumberFormatFactory@icu_56@@8 dd offset ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8
					; DATA XREF: .rdata$r:0000160Co
					; icu_56::NumberFormatFactory::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1620h
		public ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8 dd offset ??_R0?AVNumberFormatFactory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::NumberFormatFactory::`RTTI Base Class Array'o
					; .rdata$r:00001974o
					; icu_56::NumberFormatFactory `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 163Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory *this,	const struct icu_56::NumberFormatFactory *)
		public ??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z
??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+49p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1698h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::NumberFormatFactory & __thiscall icu_56::NumberFormatFactory::operator=(class icu_56::NumberFormatFactory const	&)
		public ??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z
??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::NumberFormatFactory::`scalar deleting destructor'(unsigned int)
		public ??_GNumberFormatFactory@icu_56@@UAEPAXI@Z
??_GNumberFormatFactory@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1735
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1735:				; CODE XREF: icu_56::NumberFormatFactory::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GNumberFormatFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1750h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::NumberFormatFactory::`vector deleting destructor'(unsigned int)
		public ??_ENumberFormatFactory@icu_56@@UAEPAXI@Z
??_ENumberFormatFactory@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::NumberFormatFactory::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_17BB
		push	offset ??1NumberFormatFactory@icu_56@@UAE@XZ ; icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_17B3
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_17B3:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_17E4
; ---------------------------------------------------------------------------

loc_17BB:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_17E1
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_17E1:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_17E4:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ENumberFormatFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory *this, const	struct icu_56::SimpleNumberFormatFactory *)
		public ??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::NumberFormatFactory *
		mov	ecx, [ebp+var_14] ; this
		call	??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z ; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7SimpleNumberFormatFactory@icu_56@@6B@ ; const icu_56::SimpleNumberFormatFactory::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+4]
		mov	[eax+4], dl
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 18B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:000018F4o
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
__unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18D8h
		dd offset ??_R4SimpleNumberFormatFactory@icu_56@@6B@ ; const icu_56::SimpleNumberFormatFactory::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7SimpleNumberFormatFactory@icu_56@@6B@
; const	icu_56::SimpleNumberFormatFactory::`vftable'
??_7SimpleNumberFormatFactory@icu_56@@6B@ dd offset ??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+58o
					; icu_56::SimpleNumberFormatFactory::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?visible@SimpleNumberFormatFactory@icu_56@@UBECXZ ; icu_56::SimpleNumberFormatFactory::visible(void)
		dd offset ?getSupportedIDs@SimpleNumberFormatFactory@icu_56@@UBEPBVUnicodeString@2@AAHAAW4UErrorCode@@@Z ; icu_56::SimpleNumberFormatFactory::getSupportedIDs(int &,UErrorCode &)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 18F0h
__unwindtable$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001900o
		dd offset __unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 191Ch
		public ??_R4SimpleNumberFormatFactory@icu_56@@6B@
; const	icu_56::SimpleNumberFormatFactory::`RTTI Complete Object Locator'
??_R4SimpleNumberFormatFactory@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:000018D8o
		dd offset ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8 ; icu_56::SimpleNumberFormatFactory `RTTI Type Descriptor'
		dd offset ??_R3SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1930h
		public ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8
; class	icu_56::SimpleNumberFormatFactory `RTTI	Type Descriptor'
??_R0?AVSimpleNumberFormatFactory@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001928o
					; .rdata$r:icu_56::SimpleNumberFormatFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avsimplenumb	db '.?AVSimpleNumberFormatFactory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1960h
		public ??_R3SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
??_R3SimpleNumberFormatFactory@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:0000192Co
					; .rdata$r:0000199Co
		dd 4
		dd offset ??_R2SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1970h
		public ??_R2SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Array'
??_R2SimpleNumberFormatFactory@icu_56@@8 dd offset ??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8
					; DATA XREF: .rdata$r:0000196Co
					; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8 ;	icu_56::NumberFormatFactory::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1984h
		public ??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8 dd offset ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::SimpleNumberFormatFactory::`RTTI Base Class Array'o
					; icu_56::SimpleNumberFormatFactory `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SimpleNumberFormatFactory::`scalar deleting	destructor'(unsigned int)
		public ??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_19E9
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_19E9:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SimpleNumberFormatFactory::`vector deleting	destructor'(unsigned int)
		public ??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::SimpleNumberFormatFactory::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1A6F
		push	offset ??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	48h ; 'H'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1A67
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1A67:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1A98
; ---------------------------------------------------------------------------

loc_1A6F:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1A95
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1A95:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_1A98:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NumberFormat::isParseIntegerOnly(icu_56::NumberFormat *__hidden this)
		public ?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ
?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+154h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NumberFormat::isLenient(icu_56::NumberFormat	*__hidden this)
		public ?isLenient@NumberFormat@icu_56@@UBECXZ
?isLenient@NumberFormat@icu_56@@UBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+155h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLenient@NumberFormat@icu_56@@UBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::RuleBasedNumberFormat::`scalar deleting destructor'(unsigned int)
		public ??_GRuleBasedNumberFormat@icu_56@@UAEPAXI@Z
??_GRuleBasedNumberFormat@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1RuleBasedNumberFormat@icu_56@@UAE@XZ	; icu_56::RuleBasedNumberFormat::~RuleBasedNumberFormat(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1B61
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1B61:				; CODE XREF: icu_56::RuleBasedNumberFormat::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRuleBasedNumberFormat@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::RuleBasedNumberFormat::`vector deleting destructor'(unsigned int)
		public ??_ERuleBasedNumberFormat@icu_56@@UAEPAXI@Z
??_ERuleBasedNumberFormat@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::RuleBasedNumberFormat::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1BEA
		push	offset ??1RuleBasedNumberFormat@icu_56@@UAE@XZ ; icu_56::RuleBasedNumberFormat::~RuleBasedNumberFormat(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	2A4h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1BE2
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1BE2:				; CODE XREF: icu_56::RuleBasedNumberFormat::`vector deleting destructor'(uint)+4Bj
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1C13
; ---------------------------------------------------------------------------

loc_1BEA:				; CODE XREF: icu_56::RuleBasedNumberFormat::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1RuleBasedNumberFormat@icu_56@@UAE@XZ	; icu_56::RuleBasedNumberFormat::~RuleBasedNumberFormat(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1C10
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1C10:				; CODE XREF: icu_56::RuleBasedNumberFormat::`vector deleting destructor'(uint)+7Cj
		mov	eax, [ebp+var_8]

loc_1C13:				; CODE XREF: icu_56::RuleBasedNumberFormat::`vector deleting destructor'(uint)+6Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ERuleBasedNumberFormat@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleBasedNumberFormat::isLenient(icu_56::RuleBasedNumberFormat *__hidden this)
		public ?isLenient@RuleBasedNumberFormat@icu_56@@UBECXZ
?isLenient@RuleBasedNumberFormat@icu_56@@UBECXZ	proc near ; DATA XREF: .rdata:000046F0o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+250h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLenient@RuleBasedNumberFormat@icu_56@@UBECXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::NFRuleSet *__thiscall icu_56::RuleBasedNumberFormat::getDefaultRuleSet(icu_56::RuleBasedNumberFormat *__hidden	this)
		public ?getDefaultRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@XZ
?getDefaultRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@XZ proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+9A0p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+170h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDefaultRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::PluralRules::operator!=(class icu_56::PluralRules const &)const
		public ??9PluralRules@icu_56@@QBECABV01@@Z
??9PluralRules@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9PluralRules@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralFormat::PluralSelectorAdapter::PluralSelectorAdapter(icu_56::PluralFormat::PluralSelectorAdapter *__hidden this)
		public ??0PluralSelectorAdapter@PluralFormat@icu_56@@QAE@XZ
??0PluralSelectorAdapter@PluralFormat@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0PluralSelector@PluralFormat@icu_56@@QAE@XZ ;	icu_56::PluralFormat::PluralSelector::PluralSelector(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7PluralSelectorAdapter@PluralFormat@icu_56@@6B@ ; const icu_56::PluralFormat::PluralSelectorAdapter::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0PluralSelectorAdapter@PluralFormat@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1D48h
		dd offset ??_R4PluralSelectorAdapter@PluralFormat@icu_56@@6B@ ;	const icu_56::PluralFormat::PluralSelectorAdapter::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7PluralSelectorAdapter@PluralFormat@icu_56@@6B@
; const	icu_56::PluralFormat::PluralSelectorAdapter::`vftable'
??_7PluralSelectorAdapter@PluralFormat@icu_56@@6B@ dd offset ??_EPluralSelectorAdapter@PluralFormat@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::PluralFormat::PluralSelectorAdapter::PluralSelectorAdapter(void)+2Eo
					; icu_56::PluralFormat::PluralSelectorAdapter::PluralSelectorAdapter(icu_56::PluralFormat::PluralSelectorAdapter const &)+32o
					; icu_56::PluralFormat::PluralSelectorAdapter::`vector deleting	destructor'(uint)
		dd offset ?select@PluralSelectorAdapter@PluralFormat@icu_56@@UBE?AVUnicodeString@3@PAXNAAW4UErrorCode@@@Z ; icu_56::PluralFormat::PluralSelectorAdapter::select(void *,double,UErrorCode &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1D54h
		public ??_R4PluralSelectorAdapter@PluralFormat@icu_56@@6B@
; const	icu_56::PluralFormat::PluralSelectorAdapter::`RTTI Complete Object Locator'
??_R4PluralSelectorAdapter@PluralFormat@icu_56@@6B@ dd 3 dup(0)
					; DATA XREF: .rdata:00001D48o
		dd offset ??_R0?AVPluralSelectorAdapter@PluralFormat@icu_56@@@8	; icu_56::PluralFormat::PluralSelectorAdapter `RTTI Type Descriptor'
		dd offset ??_R3PluralSelectorAdapter@PluralFormat@icu_56@@8 ; icu_56::PluralFormat::PluralSelectorAdapter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1D68h
		public ??_R0?AVPluralSelectorAdapter@PluralFormat@icu_56@@@8
; class	icu_56::PluralFormat::PluralSelectorAdapter `RTTI Type Descriptor'
??_R0?AVPluralSelectorAdapter@PluralFormat@icu_56@@@8 dd offset	??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001D60o
					; .rdata$r:icu_56::PluralFormat::PluralSelectorAdapter::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avpluralsele	db '.?AVPluralSelectorAdapter@PluralFormat@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1DA0h
		public ??_R3PluralSelectorAdapter@PluralFormat@icu_56@@8
; icu_56::PluralFormat::PluralSelectorAdapter::`RTTI Class Hierarchy Descriptor'
??_R3PluralSelectorAdapter@PluralFormat@icu_56@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:00001D64o
					; .rdata$r:00001DD8o
		dd 3
		dd offset ??_R2PluralSelectorAdapter@PluralFormat@icu_56@@8 ; icu_56::PluralFormat::PluralSelectorAdapter::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1DB0h
		public ??_R2PluralSelectorAdapter@PluralFormat@icu_56@@8
; icu_56::PluralFormat::PluralSelectorAdapter::`RTTI Base Class	Array'
??_R2PluralSelectorAdapter@PluralFormat@icu_56@@8 dd offset ??_R1A@?0A@EA@PluralSelectorAdapter@PluralFormat@icu_56@@8
					; DATA XREF: .rdata$r:00001DACo
					; icu_56::PluralFormat::PluralSelectorAdapter::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@PluralSelector@PluralFormat@icu_56@@8 ;	icu_56::PluralFormat::PluralSelector::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1DC0h
		public ??_R1A@?0A@EA@PluralSelectorAdapter@PluralFormat@icu_56@@8
; icu_56::PluralFormat::PluralSelectorAdapter::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@PluralSelectorAdapter@PluralFormat@icu_56@@8 dd offset ??_R0?AVPluralSelectorAdapter@PluralFormat@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::PluralFormat::PluralSelectorAdapter::`RTTI Base Class Array'o
					; icu_56::PluralFormat::PluralSelectorAdapter `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3PluralSelectorAdapter@PluralFormat@icu_56@@8 ; icu_56::PluralFormat::PluralSelectorAdapter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1DDCh
		public ??_R1A@?0A@EA@PluralSelector@PluralFormat@icu_56@@8
; icu_56::PluralFormat::PluralSelector::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@PluralSelector@PluralFormat@icu_56@@8 dd offset ??_R0?AVPluralSelector@PluralFormat@icu_56@@@8
					; DATA XREF: .rdata$r:00001DB4o
					; .rdata$r:icu_56::PluralFormat::PluralSelector::`RTTI Base Class Array'o
					; icu_56::PluralFormat::PluralSelector `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3PluralSelector@PluralFormat@icu_56@@8 ; icu_56::PluralFormat::PluralSelector::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1DF8h
		public ??_R0?AVPluralSelector@PluralFormat@icu_56@@@8
; class	icu_56::PluralFormat::PluralSelector `RTTI Type	Descriptor'
??_R0?AVPluralSelector@PluralFormat@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::PluralFormat::PluralSelector::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; .rdata$r:00001E98o
					; const	type_info::`vftable'
		align 10h
a_?avpluralse_0	db '.?AVPluralSelector@PluralFormat@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1E2Ch
		public ??_R3PluralSelector@PluralFormat@icu_56@@8
; icu_56::PluralFormat::PluralSelector::`RTTI Class Hierarchy Descriptor'
??_R3PluralSelector@PluralFormat@icu_56@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:00001DF4o
					; .rdata$r:00001E9Co
		dd 2
		dd offset ??_R2PluralSelector@PluralFormat@icu_56@@8 ; icu_56::PluralFormat::PluralSelector::`RTTI Base	Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1E3Ch
		public ??_R2PluralSelector@PluralFormat@icu_56@@8
; icu_56::PluralFormat::PluralSelector::`RTTI Base Class Array'
??_R2PluralSelector@PluralFormat@icu_56@@8 dd offset ??_R1A@?0A@EA@PluralSelector@PluralFormat@icu_56@@8
					; DATA XREF: .rdata$r:00001E38o
					; icu_56::PluralFormat::PluralSelector::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralFormat::PluralSelector::PluralSelector(icu_56::PluralFormat::PluralSelector *__hidden	this)
		public ??0PluralSelector@PluralFormat@icu_56@@QAE@XZ
??0PluralSelector@PluralFormat@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::PluralFormat::PluralSelectorAdapter::PluralSelectorAdapter(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7PluralSelector@PluralFormat@icu_56@@6B@ ; const icu_56::PluralFormat::PluralSelector::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0PluralSelector@PluralFormat@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1E80h
		dd offset ??_R4PluralSelector@PluralFormat@icu_56@@6B@ ; const icu_56::PluralFormat::PluralSelector::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7PluralSelector@PluralFormat@icu_56@@6B@
; const	icu_56::PluralFormat::PluralSelector::`vftable'
??_7PluralSelector@PluralFormat@icu_56@@6B@ dd offset ??_EPluralSelector@PluralFormat@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::PluralFormat::PluralSelector::PluralSelector(void)+26o
					; icu_56::PluralFormat::PluralSelector::PluralSelector(icu_56::PluralFormat::PluralSelector const &)+44o
					; icu_56::PluralFormat::PluralSelector::`vector	deleting destructor'(uint)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1E8Ch
		public ??_R4PluralSelector@PluralFormat@icu_56@@6B@
; const	icu_56::PluralFormat::PluralSelector::`RTTI Complete Object Locator'
??_R4PluralSelector@PluralFormat@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00001E80o
		dd offset ??_R0?AVPluralSelector@PluralFormat@icu_56@@@8 ; icu_56::PluralFormat::PluralSelector	`RTTI Type Descriptor'
		dd offset ??_R3PluralSelector@PluralFormat@icu_56@@8 ; icu_56::PluralFormat::PluralSelector::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralFormat::PluralSelector::PluralSelector(icu_56::PluralFormat::PluralSelector *this, const struct icu_56::PluralFormat::PluralSelector *)
		public ??0PluralSelector@PluralFormat@icu_56@@QAE@ABV012@@Z
??0PluralSelector@PluralFormat@icu_56@@QAE@ABV012@@Z proc near
					; CODE XREF: icu_56::PluralFormat::PluralSelectorAdapter::PluralSelectorAdapter(icu_56::PluralFormat::PluralSelectorAdapter const &)+2Ap

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_1ED7
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_1EE1
; ---------------------------------------------------------------------------

loc_1ED7:				; CODE XREF: icu_56::PluralFormat::PluralSelector::PluralSelector(icu_56::PluralFormat::PluralSelector const &)+27j
		mov	[ebp+var_D0], 0

loc_1EE1:				; CODE XREF: icu_56::PluralFormat::PluralSelector::PluralSelector(icu_56::PluralFormat::PluralSelector const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7PluralSelector@PluralFormat@icu_56@@6B@ ; const icu_56::PluralFormat::PluralSelector::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0PluralSelector@PluralFormat@icu_56@@QAE@ABV012@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::PluralFormat::PluralSelector & __thiscall icu_56::PluralFormat::PluralSelector::operator=(class	icu_56::PluralFormat::PluralSelector const &)
		public ??4PluralSelector@PluralFormat@icu_56@@QAEAAV012@ABV012@@Z
??4PluralSelector@PluralFormat@icu_56@@QAEAAV012@ABV012@@Z proc	near
					; CODE XREF: icu_56::PluralFormat::PluralSelectorAdapter::operator=(icu_56::PluralFormat::PluralSelectorAdapter	const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4PluralSelector@PluralFormat@icu_56@@QAEAAV012@ABV012@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralFormat::PluralSelector::`scalar deleting destructor'(unsigned int)
		public ??_GPluralSelector@PluralFormat@icu_56@@UAEPAXI@Z
??_GPluralSelector@PluralFormat@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralSelector@PluralFormat@icu_56@@UAE@XZ ;	icu_56::PluralFormat::PluralSelector::~PluralSelector(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1F71
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1F71:				; CODE XREF: icu_56::PluralFormat::PluralSelector::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GPluralSelector@PluralFormat@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralFormat::PluralSelector::`vector deleting destructor'(unsigned int)
		public ??_EPluralSelector@PluralFormat@icu_56@@UAEPAXI@Z
??_EPluralSelector@PluralFormat@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::PluralFormat::PluralSelector::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1FF7
		push	offset ??1PluralSelector@PluralFormat@icu_56@@UAE@XZ ; icu_56::PluralFormat::PluralSelector::~PluralSelector(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1FEF
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1FEF:				; CODE XREF: icu_56::PluralFormat::PluralSelector::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_2020
; ---------------------------------------------------------------------------

loc_1FF7:				; CODE XREF: icu_56::PluralFormat::PluralSelector::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralSelector@PluralFormat@icu_56@@UAE@XZ ;	icu_56::PluralFormat::PluralSelector::~PluralSelector(void)

loc_1FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_201D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_201D:				; CODE XREF: icu_56::PluralFormat::PluralSelector::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_2020:				; CODE XREF: icu_56::PluralFormat::PluralSelector::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EPluralSelector@PluralFormat@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2038h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralFormat::PluralSelectorAdapter::PluralSelectorAdapter(icu_56::PluralFormat::PluralSelectorAdapter *this, const	struct icu_56::PluralFormat::PluralSelectorAdapter *)
		public ??0PluralSelectorAdapter@PluralFormat@icu_56@@QAE@ABV012@@Z
??0PluralSelectorAdapter@PluralFormat@icu_56@@QAE@ABV012@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::PluralFormat::PluralSelector *
		mov	ecx, [ebp+var_8] ; this
		call	??0PluralSelector@PluralFormat@icu_56@@QAE@ABV012@@Z ; icu_56::PluralFormat::PluralSelector::PluralSelector(icu_56::PluralFormat::PluralSelector const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7PluralSelectorAdapter@PluralFormat@icu_56@@6B@ ; const icu_56::PluralFormat::PluralSelectorAdapter::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0PluralSelectorAdapter@PluralFormat@icu_56@@QAE@ABV012@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2098h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::PluralFormat::PluralSelectorAdapter & __thiscall icu_56::PluralFormat::PluralSelectorAdapter::operator=(class icu_56::PluralFormat::PluralSelectorAdapter const	&)
		public ??4PluralSelectorAdapter@PluralFormat@icu_56@@QAEAAV012@ABV012@@Z
??4PluralSelectorAdapter@PluralFormat@icu_56@@QAEAAV012@ABV012@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4PluralSelector@PluralFormat@icu_56@@QAEAAV012@ABV012@@Z ; icu_56::PluralFormat::PluralSelector::operator=(icu_56::PluralFormat::PluralSelector const	&)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4PluralSelectorAdapter@PluralFormat@icu_56@@QAEAAV012@ABV012@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralFormat::PluralSelectorAdapter::`scalar deleting destructor'(unsigned int)
		public ??_GPluralSelectorAdapter@PluralFormat@icu_56@@UAEPAXI@Z
??_GPluralSelectorAdapter@PluralFormat@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralSelectorAdapter@PluralFormat@icu_56@@UAE@XZ ; icu_56::PluralFormat::PluralSelectorAdapter::~PluralSelectorAdapter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_2135
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2135:				; CODE XREF: icu_56::PluralFormat::PluralSelectorAdapter::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GPluralSelectorAdapter@PluralFormat@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2150h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralFormat::PluralSelectorAdapter::`vector deleting destructor'(unsigned int)
		public ??_EPluralSelectorAdapter@PluralFormat@icu_56@@UAEPAXI@Z
??_EPluralSelectorAdapter@PluralFormat@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::PluralFormat::PluralSelectorAdapter::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_21BB
		push	offset ??1PluralSelectorAdapter@PluralFormat@icu_56@@UAE@XZ ; icu_56::PluralFormat::PluralSelectorAdapter::~PluralSelectorAdapter(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	8
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_21B3
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_21B3:				; CODE XREF: icu_56::PluralFormat::PluralSelectorAdapter::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_21E4
; ---------------------------------------------------------------------------

loc_21BB:				; CODE XREF: icu_56::PluralFormat::PluralSelectorAdapter::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralSelectorAdapter@PluralFormat@icu_56@@UAE@XZ ; icu_56::PluralFormat::PluralSelectorAdapter::~PluralSelectorAdapter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_21E1
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_21E1:				; CODE XREF: icu_56::PluralFormat::PluralSelectorAdapter::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_21E4:				; CODE XREF: icu_56::PluralFormat::PluralSelectorAdapter::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EPluralSelectorAdapter@PluralFormat@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::Collator *__cdecl icu_56::Collator::fromUCollator(struct UCollator *)
		public ?fromUCollator@Collator@icu_56@@SAPAV12@PAUUCollator@@@Z
?fromUCollator@Collator@icu_56@@SAPAV12@PAUUCollator@@@Z proc near
					; CODE XREF: icu_56::RuleBasedCollator::rbcFromUCollator(UCollator *)+2Ep

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUCollator@Collator@icu_56@@SAPAV12@PAUUCollator@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2224h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Collator	*__cdecl icu_56::Collator::fromUCollator(const struct UCollator	*)
		public ?fromUCollator@Collator@icu_56@@SAPBV12@PBUUCollator@@@Z
?fromUCollator@Collator@icu_56@@SAPBV12@PBUUCollator@@@Z proc near
					; CODE XREF: icu_56::RuleBasedCollator::rbcFromUCollator(UCollator const *)+2Ep

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUCollator@Collator@icu_56@@SAPBV12@PBUUCollator@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 224Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct UCollator *__thiscall icu_56::Collator::toUCollator(icu_56::Collator *__hidden	this)
		public ?toUCollator@Collator@icu_56@@QAEPAUUCollator@@XZ
?toUCollator@Collator@icu_56@@QAEPAUUCollator@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUCollator@Collator@icu_56@@QAEPAUUCollator@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 227Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct UCollator *__thiscall icu_56::Collator::toUCollator(icu_56::Collator *__hidden this)
		public ?toUCollator@Collator@icu_56@@QBEPBUUCollator@@XZ
?toUCollator@Collator@icu_56@@QBEPBUUCollator@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUCollator@Collator@icu_56@@QBEPBUUCollator@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CollatorFactory::CollatorFactory(icu_56::CollatorFactory *__hidden this)
		public ??0CollatorFactory@icu_56@@QAE@XZ
??0CollatorFactory@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7CollatorFactory@icu_56@@6B@	; const	icu_56::CollatorFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0CollatorFactory@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2304h
		dd offset ??_R4CollatorFactory@icu_56@@6B@ ; const icu_56::CollatorFactory::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7CollatorFactory@icu_56@@6B@
; const	icu_56::CollatorFactory::`vftable'
??_7CollatorFactory@icu_56@@6B@	dd offset ??_ECollatorFactory@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::CollatorFactory::CollatorFactory(void)+38o
					; icu_56::CollatorFactory::CollatorFactory(icu_56::CollatorFactory const &)+3Co
					; icu_56::CollatorFactory::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?visible@CollatorFactory@icu_56@@UBECXZ ; icu_56::CollatorFactory::visible(void)
		dd offset __purecall
		dd offset ?getDisplayName@CollatorFactory@icu_56@@UAEAAVUnicodeString@2@ABVLocale@2@0AAV32@@Z ;	icu_56::CollatorFactory::getDisplayName(icu_56::Locale const &,icu_56::Locale const &,icu_56::UnicodeString &)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2320h
		public ??_R4CollatorFactory@icu_56@@6B@
; const	icu_56::CollatorFactory::`RTTI Complete	Object Locator'
??_R4CollatorFactory@icu_56@@6B@ dd 3 dup(0) ; DATA XREF: .rdata:00002304o
		dd offset ??_R0?AVCollatorFactory@icu_56@@@8 ; icu_56::CollatorFactory `RTTI Type Descriptor'
		dd offset ??_R3CollatorFactory@icu_56@@8 ; icu_56::CollatorFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2334h
		public ??_R0?AVCollatorFactory@icu_56@@@8
; class	icu_56::CollatorFactory	`RTTI Type Descriptor'
??_R0?AVCollatorFactory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000232Co
					; .rdata$r:icu_56::CollatorFactory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avcollatorfa	db '.?AVCollatorFactory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 235Ch
		public ??_R3CollatorFactory@icu_56@@8
; icu_56::CollatorFactory::`RTTI Class Hierarchy Descriptor'
??_R3CollatorFactory@icu_56@@8 dd 2 dup(0) ; DATA XREF:	.rdata$r:00002330o
					; .rdata$r:00002394o
		dd 3
		dd offset ??_R2CollatorFactory@icu_56@@8 ; icu_56::CollatorFactory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 236Ch
		public ??_R2CollatorFactory@icu_56@@8
; icu_56::CollatorFactory::`RTTI Base Class Array'
??_R2CollatorFactory@icu_56@@8 dd offset ??_R1A@?0A@EA@CollatorFactory@icu_56@@8
					; DATA XREF: .rdata$r:00002368o
					; icu_56::CollatorFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 237Ch
		public ??_R1A@?0A@EA@CollatorFactory@icu_56@@8
; icu_56::CollatorFactory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@CollatorFactory@icu_56@@8	dd offset ??_R0?AVCollatorFactory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::CollatorFactory::`RTTI Base Class	Array'o
					; icu_56::CollatorFactory `RTTI	Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3CollatorFactory@icu_56@@8 ; icu_56::CollatorFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2398h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CollatorFactory::CollatorFactory(icu_56::CollatorFactory *this, const struct icu_56::CollatorFactory *)
		public ??0CollatorFactory@icu_56@@QAE@ABV01@@Z
??0CollatorFactory@icu_56@@QAE@ABV01@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7CollatorFactory@icu_56@@6B@	; const	icu_56::CollatorFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0CollatorFactory@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::CollatorFactory	& __thiscall icu_56::CollatorFactory::operator=(class icu_56::CollatorFactory const &)
		public ??4CollatorFactory@icu_56@@QAEAAV01@ABV01@@Z
??4CollatorFactory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4CollatorFactory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2448h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::CollatorFactory::`scalar deleting destructor'(unsigned int)
		public ??_GCollatorFactory@icu_56@@UAEPAXI@Z
??_GCollatorFactory@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1CollatorFactory@icu_56@@UAE@XZ ; icu_56::CollatorFactory::~CollatorFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_2491
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2491:				; CODE XREF: icu_56::CollatorFactory::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GCollatorFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::CollatorFactory::`vector deleting destructor'(unsigned int)
		public ??_ECollatorFactory@icu_56@@UAEPAXI@Z
??_ECollatorFactory@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::CollatorFactory::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_2517
		push	offset ??1CollatorFactory@icu_56@@UAE@XZ ; icu_56::CollatorFactory::~CollatorFactory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_250F
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_250F:				; CODE XREF: icu_56::CollatorFactory::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_2540
; ---------------------------------------------------------------------------

loc_2517:				; CODE XREF: icu_56::CollatorFactory::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1CollatorFactory@icu_56@@UAE@XZ ; icu_56::CollatorFactory::~CollatorFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_253D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_253D:				; CODE XREF: icu_56::CollatorFactory::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_2540:				; CODE XREF: icu_56::CollatorFactory::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ECollatorFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2558h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::RuleBasedCollator *__cdecl icu_56::RuleBasedCollator::rbcFromUCollator(struct UCollator *)
		public ?rbcFromUCollator@RuleBasedCollator@icu_56@@SAPAV12@PAUUCollator@@@Z
?rbcFromUCollator@RuleBasedCollator@icu_56@@SAPAV12@PAUUCollator@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	0
		push	offset ??_R0?AVRuleBasedCollator@icu_56@@@8 ; icu_56::RuleBasedCollator	`RTTI Type Descriptor'
		push	offset ??_R0?AVCollator@icu_56@@@8 ; icu_56::Collator `RTTI Type Descriptor'
		mov	eax, [ebp+arg_0]
		push	eax		; struct UCollator *
		call	?fromUCollator@Collator@icu_56@@SAPAV12@PAUUCollator@@@Z ; icu_56::Collator::fromUCollator(UCollator *)
		add	esp, 4
		push	0
		push	eax
		call	___RTDynamicCast
		add	esp, 14h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?rbcFromUCollator@RuleBasedCollator@icu_56@@SAPAV12@PAUUCollator@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 25B0h
		public ??_R0?AVCollator@icu_56@@@8
; class	icu_56::Collator `RTTI Type Descriptor'
??_R0?AVCollator@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: icu_56::RuleBasedCollator::rbcFromUCollator(UCollator *)+25o
					; icu_56::RuleBasedCollator::rbcFromUCollator(UCollator	const *)+25o ...
					; const	type_info::`vftable'
		align 8
a_?avcollator@i	db '.?AVCollator@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 25D0h
		public ??_R0?AVRuleBasedCollator@icu_56@@@8
; class	icu_56::RuleBasedCollator `RTTI	Type Descriptor'
??_R0?AVRuleBasedCollator@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: icu_56::RuleBasedCollator::rbcFromUCollator(UCollator *)+20o
					; icu_56::RuleBasedCollator::rbcFromUCollator(UCollator	const *)+20o ...
					; const	type_info::`vftable'
		align 8
a_?avrulebasedc	db '.?AVRuleBasedCollator@icu_56@@',0
		align 4
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::RuleBasedCollator *__cdecl icu_56::RuleBasedCollator::rbcFromUCollator(const struct UCollator *)
		public ?rbcFromUCollator@RuleBasedCollator@icu_56@@SAPBV12@PBUUCollator@@@Z
?rbcFromUCollator@RuleBasedCollator@icu_56@@SAPBV12@PBUUCollator@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	0
		push	offset ??_R0?AVRuleBasedCollator@icu_56@@@8 ; icu_56::RuleBasedCollator	`RTTI Type Descriptor'
		push	offset ??_R0?AVCollator@icu_56@@@8 ; icu_56::Collator `RTTI Type Descriptor'
		mov	eax, [ebp+arg_0]
		push	eax		; struct UCollator *
		call	?fromUCollator@Collator@icu_56@@SAPBV12@PBUUCollator@@@Z ; icu_56::Collator::fromUCollator(UCollator const *)
		add	esp, 4
		push	0
		push	eax
		call	___RTDynamicCast
		add	esp, 14h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?rbcFromUCollator@RuleBasedCollator@icu_56@@SAPBV12@PBUUCollator@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2650h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedCollator::setAttributeDefault(icu_56::RuleBasedCollator *this, int)
		public ?setAttributeDefault@RuleBasedCollator@icu_56@@AAEXH@Z
?setAttributeDefault@RuleBasedCollator@icu_56@@AAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 1
		mov	ecx, [ebp+arg_0]
		shl	eax, cl
		not	eax
		mov	ecx, [ebp+var_8]
		and	eax, [ecx+0E0h]
		mov	edx, [ebp+var_8]
		mov	[edx+0E0h], eax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setAttributeDefault@RuleBasedCollator@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 269Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedCollator::setAttributeExplicitly(icu_56::RuleBasedCollator *this, int)
		public ?setAttributeExplicitly@RuleBasedCollator@icu_56@@AAEXH@Z
?setAttributeExplicitly@RuleBasedCollator@icu_56@@AAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 1
		mov	ecx, [ebp+arg_0]
		shl	eax, cl
		mov	ecx, [ebp+var_8]
		or	eax, [ecx+0E0h]
		mov	edx, [ebp+var_8]
		mov	[edx+0E0h], eax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setAttributeExplicitly@RuleBasedCollator@icu_56@@AAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleBasedCollator::attributeHasBeenSetExplicitly(icu_56::RuleBasedCollator *this, int)
		public ?attributeHasBeenSetExplicitly@RuleBasedCollator@icu_56@@ABECH@Z
?attributeHasBeenSetExplicitly@RuleBasedCollator@icu_56@@ABECH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 1
		mov	ecx, [ebp+arg_0]
		shl	eax, cl
		mov	ecx, [ebp+var_8]
		and	eax, [ecx+0E0h]
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?attributeHasBeenSetExplicitly@RuleBasedCollator@icu_56@@ABECH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2728h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::RuleBasedNumberFormat::getStaticClassID()
		public ?getStaticClassID@RuleBasedNumberFormat@icu_56@@SAPAXXZ
?getStaticClassID@RuleBasedNumberFormat@icu_56@@SAPAXXZ	proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@RuleBasedNumberFormat@icu_56@@SAPAXXZ@4DA ; char `icu_56::RuleBasedNumberFormat::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@RuleBasedNumberFormat@icu_56@@SAPAXXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2754h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::RuleBasedNumberFormat::getDynamicClassID(icu_56::RuleBasedNumberFormat *__hidden this)
		public ?getDynamicClassID@RuleBasedNumberFormat@icu_56@@UBEPAXXZ
?getDynamicClassID@RuleBasedNumberFormat@icu_56@@UBEPAXXZ proc near
					; DATA XREF: .rdata:00004694o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@RuleBasedNumberFormat@icu_56@@SAPAXXZ	; icu_56::RuleBasedNumberFormat::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@RuleBasedNumberFormat@icu_56@@UBEPAXXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2790h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::LocalizationInfo::~LocalizationInfo(icu_56::LocalizationInfo *__hidden this)
		public ??1LocalizationInfo@icu_56@@MAE@XZ
??1LocalizationInfo@icu_56@@MAE@XZ proc	near
					; CODE XREF: icu_56::LocalizationInfo::`scalar deleting	destructor'(uint)+26p
					; icu_56::StringLocalizationInfo::~StringLocalizationInfo(void)+93p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7LocalizationInfo@icu_56@@6B@ ; const icu_56::LocalizationInfo::`vftable'
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1LocalizationInfo@icu_56@@MAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 27C4h
		dd offset ??_R4LocalizationInfo@icu_56@@6B@ ; const icu_56::LocalizationInfo::`RTTI Complete Object Locator'
		public ??_7LocalizationInfo@icu_56@@6B@
; const	icu_56::LocalizationInfo::`vftable'
??_7LocalizationInfo@icu_56@@6B@ dd offset ??_ELocalizationInfo@icu_56@@MAEPAXI@Z
					; DATA XREF: icu_56::LocalizationInfo::~LocalizationInfo(void)+26o
					; icu_56::LocalizationInfo::LocalizationInfo(void)+26o
					; icu_56::LocalizationInfo::`vector deleting destructor'(uint)
		dd offset ??8LocalizationInfo@icu_56@@UBECPBV01@@Z ; icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?indexForLocale@LocalizationInfo@icu_56@@UBEHPB_W@Z ;	icu_56::LocalizationInfo::indexForLocale(wchar_t const *)
		dd offset ?indexForRuleSet@LocalizationInfo@icu_56@@UBEHPB_W@Z ; icu_56::LocalizationInfo::indexForRuleSet(wchar_t const *)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 27ECh
		public ??_R4LocalizationInfo@icu_56@@6B@
; const	icu_56::LocalizationInfo::`RTTI	Complete Object	Locator'
??_R4LocalizationInfo@icu_56@@6B@ dd 3 dup(0) ;	DATA XREF: .rdata:000027C4o
		dd offset ??_R0?AVLocalizationInfo@icu_56@@@8 ;	icu_56::LocalizationInfo `RTTI Type Descriptor'
		dd offset ??_R3LocalizationInfo@icu_56@@8 ; icu_56::LocalizationInfo::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2800h
		public ??_R0?AVLocalizationInfo@icu_56@@@8
; class	icu_56::LocalizationInfo `RTTI Type Descriptor'
??_R0?AVLocalizationInfo@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000027F8o
					; .rdata$r:icu_56::LocalizationInfo::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avlocalizati	db '.?AVLocalizationInfo@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2828h
		public ??_R3LocalizationInfo@icu_56@@8
; icu_56::LocalizationInfo::`RTTI Class	Hierarchy Descriptor'
??_R3LocalizationInfo@icu_56@@8	dd 2 dup(0) ; DATA XREF: .rdata$r:000027FCo
					; .rdata$r:0000285Co
		dd 2
		dd offset ??_R2LocalizationInfo@icu_56@@8 ; icu_56::LocalizationInfo::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2838h
		public ??_R2LocalizationInfo@icu_56@@8
; icu_56::LocalizationInfo::`RTTI Base Class Array'
??_R2LocalizationInfo@icu_56@@8	dd offset ??_R1A@?0A@EA@LocalizationInfo@icu_56@@8
					; DATA XREF: .rdata$r:00002834o
					; icu_56::LocalizationInfo::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2844h
		public ??_R1A@?0A@EA@LocalizationInfo@icu_56@@8
; icu_56::LocalizationInfo::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@LocalizationInfo@icu_56@@8 dd offset ??_R0?AVLocalizationInfo@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::LocalizationInfo::`RTTI Base Class Array'o
					; .rdata$r:00003540o
					; icu_56::LocalizationInfo `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3LocalizationInfo@icu_56@@8 ; icu_56::LocalizationInfo::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2860h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: virtual void * __thiscall icu_56::LocalizationInfo::`scalar deleting destructor'(unsigned int)
		public ??_GLocalizationInfo@icu_56@@MAEPAXI@Z
??_GLocalizationInfo@icu_56@@MAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1LocalizationInfo@icu_56@@MAE@XZ ; icu_56::LocalizationInfo::~LocalizationInfo(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_28A9
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_28A9:				; CODE XREF: icu_56::LocalizationInfo::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GLocalizationInfo@icu_56@@MAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::LocalizationInfo::operator==(class icu_56::LocalizationInfo const *)const
		public ??8LocalizationInfo@icu_56@@UBECPBV01@@Z
??8LocalizationInfo@icu_56@@UBECPBV01@@Z proc near ; DATA XREF:	.rdata:000027CCo
					; .rdata:000034CCo

var_120		= byte ptr -120h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	loc_2AD8
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_2900
		mov	al, 1
		jmp	loc_2ADA
; ---------------------------------------------------------------------------

loc_2900:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+33j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_14], eax
		jnz	loc_2AD8
		mov	[ebp+var_20], 0
		jmp	short loc_294A
; ---------------------------------------------------------------------------

loc_2941:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *):loc_299Ej
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_294A:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+7Bj
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	short loc_29A0
		mov	esi, esp
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	esi, esp
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+0Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	?streq@icu_56@@YACPB_W0@Z ; icu_56::streq(wchar_t const	*,wchar_t const	*)
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jnz	short loc_299E
		xor	al, al
		jmp	loc_2ADA
; ---------------------------------------------------------------------------

loc_299E:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+D1j
		jmp	short loc_2941
; ---------------------------------------------------------------------------

loc_29A0:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+8Cj
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+arg_0]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_2C], eax
		jnz	loc_2AD8
		mov	[ebp+var_38], 0
		jmp	short loc_29EA
; ---------------------------------------------------------------------------

loc_29E1:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *):loc_2ACFj
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax

loc_29EA:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+11Bj
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_2C]
		jge	loc_2AD4
		mov	esi, esp
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+14h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_44], eax
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_50], eax
		mov	esi, esp
		mov	eax, [ebp+var_50]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+14h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		call	?streq@icu_56@@YACPB_W0@Z ; icu_56::streq(wchar_t const	*,wchar_t const	*)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2A62
		xor	al, al
		jmp	short loc_2ADA
; ---------------------------------------------------------------------------

loc_2A62:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+198j
		mov	[ebp+var_5C], 0
		jmp	short loc_2A74
; ---------------------------------------------------------------------------

loc_2A6B:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *):loc_2ACDj
		mov	eax, [ebp+var_5C]
		add	eax, 1
		mov	[ebp+var_5C], eax

loc_2A74:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+1A5j
		mov	eax, [ebp+var_5C]
		cmp	eax, [ebp+var_14]
		jge	short loc_2ACF
		mov	esi, esp
		mov	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+var_50]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+18h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	esi, esp
		mov	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+18h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	?streq@icu_56@@YACPB_W0@Z ; icu_56::streq(wchar_t const	*,wchar_t const	*)
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jnz	short loc_2ACD
		xor	al, al
		jmp	short loc_2ADA
; ---------------------------------------------------------------------------

loc_2ACD:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+203j
		jmp	short loc_2A6B
; ---------------------------------------------------------------------------

loc_2ACF:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+1B6j
		jmp	loc_29E1
; ---------------------------------------------------------------------------

loc_2AD4:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+12Cj
		mov	al, 1
		jmp	short loc_2ADA
; ---------------------------------------------------------------------------

loc_2AD8:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+27j
					; icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo	const *)+6Ej ...
		xor	al, al

loc_2ADA:				; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+37j
					; icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo	const *)+D5j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8LocalizationInfo@icu_56@@UBECPBV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2AF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl icu_56::streq(wchar_t const *, wchar_t const *)
?streq@icu_56@@YACPB_W0@Z proc near	; CODE XREF: icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)+C4p
					; icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo	const *)+18Bp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_2B1A
		mov	al, 1
		jmp	short loc_2B3F
; ---------------------------------------------------------------------------

loc_2B1A:				; CODE XREF: icu_56::streq(wchar_t const *,wchar_t const *)+24j
		cmp	[ebp+arg_0], 0
		jz	short loc_2B3D
		cmp	[ebp+arg_4], 0
		jz	short loc_2B3D
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_u_strcmp_56
		add	esp, 8
		test	eax, eax
		setz	al
		jmp	short loc_2B3F
; ---------------------------------------------------------------------------

loc_2B3D:				; CODE XREF: icu_56::streq(wchar_t const *,wchar_t const *)+2Ej
					; icu_56::streq(wchar_t	const *,wchar_t	const *)+34j
		xor	al, al

loc_2B3F:				; CODE XREF: icu_56::streq(wchar_t const *,wchar_t const *)+28j
					; icu_56::streq(wchar_t	const *,wchar_t	const *)+4Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?streq@icu_56@@YACPB_W0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::LocalizationInfo::indexForLocale(icu_56::LocalizationInfo *this, const	wchar_t	*)
		public ?indexForLocale@LocalizationInfo@icu_56@@UBEHPB_W@Z
?indexForLocale@LocalizationInfo@icu_56@@UBEHPB_W@Z proc near ;	DATA XREF: .rdata:000027E4o
					; .rdata:000034E4o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		jmp	short loc_2B89
; ---------------------------------------------------------------------------

loc_2B80:				; CODE XREF: icu_56::LocalizationInfo::indexForLocale(wchar_t const *):loc_2BD7j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_2B89:				; CODE XREF: icu_56::LocalizationInfo::indexForLocale(wchar_t const *)+2Aj
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_14], eax
		jge	short loc_2BD9
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+14h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?streq@icu_56@@YACPB_W0@Z ; icu_56::streq(wchar_t const	*,wchar_t const	*)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_2BD7
		mov	eax, [ebp+var_14]
		jmp	short loc_2BDC
; ---------------------------------------------------------------------------

loc_2BD7:				; CODE XREF: icu_56::LocalizationInfo::indexForLocale(wchar_t const *)+7Cj
		jmp	short loc_2B80
; ---------------------------------------------------------------------------

loc_2BD9:				; CODE XREF: icu_56::LocalizationInfo::indexForLocale(wchar_t const *)+4Ej
		or	eax, 0FFFFFFFFh

loc_2BDC:				; CODE XREF: icu_56::LocalizationInfo::indexForLocale(wchar_t const *)+81j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexForLocale@LocalizationInfo@icu_56@@UBEHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::LocalizationInfo::indexForRuleSet(icu_56::LocalizationInfo *this, const wchar_t *)
		public ?indexForRuleSet@LocalizationInfo@icu_56@@UBEHPB_W@Z
?indexForRuleSet@LocalizationInfo@icu_56@@UBEHPB_W@Z proc near ; DATA XREF: .rdata:000027E8o
					; .rdata:000034E8o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_2C7F
		mov	[ebp+var_14], 0
		jmp	short loc_2C2F
; ---------------------------------------------------------------------------

loc_2C26:				; CODE XREF: icu_56::LocalizationInfo::indexForRuleSet(wchar_t const *):loc_2C7Dj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_2C2F:				; CODE XREF: icu_56::LocalizationInfo::indexForRuleSet(wchar_t const *)+30j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_14], eax
		jge	short loc_2C7F
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?streq@icu_56@@YACPB_W0@Z ; icu_56::streq(wchar_t const	*,wchar_t const	*)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_2C7D
		mov	eax, [ebp+var_14]
		jmp	short loc_2C82
; ---------------------------------------------------------------------------

loc_2C7D:				; CODE XREF: icu_56::LocalizationInfo::indexForRuleSet(wchar_t const *)+82j
		jmp	short loc_2C26
; ---------------------------------------------------------------------------

loc_2C7F:				; CODE XREF: icu_56::LocalizationInfo::indexForRuleSet(wchar_t const *)+27j
					; icu_56::LocalizationInfo::indexForRuleSet(wchar_t const *)+54j
		or	eax, 0FFFFFFFFh

loc_2C82:				; CODE XREF: icu_56::LocalizationInfo::indexForRuleSet(wchar_t const *)+87j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexForRuleSet@LocalizationInfo@icu_56@@UBEHPB_W@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::StringLocalizationInfo	*__thiscall icu_56::LocDataParser::parse(icu_56::LocDataParser *this, wchar_t *, int)
		public ?parse@LocDataParser@icu_56@@QAEPAVStringLocalizationInfo@2@PA_WH@Z
?parse@LocDataParser@icu_56@@QAEPAVStringLocalizationInfo@2@PA_WH@Z proc near
					; CODE XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+FDp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ecx]
		push	edx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	eax, al
		test	eax, eax
		jz	short loc_2CEC
		cmp	[ebp+arg_0], 0
		jz	short loc_2CE5
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_2CE5:				; CODE XREF: icu_56::LocDataParser::parse(wchar_t *,int)+3Fj
		xor	eax, eax
		jmp	loc_2D8B
; ---------------------------------------------------------------------------

loc_2CEC:				; CODE XREF: icu_56::LocDataParser::parse(wchar_t *,int)+39j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	dword ptr [ecx], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	dword ptr [ecx+4], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		xor	edx, edx
		mov	[ecx+28h], dx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		xor	edx, edx
		mov	[ecx+8], dx
		cmp	[ebp+arg_0], 0
		jnz	short loc_2D33
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	dword ptr [ecx], 1
		xor	eax, eax
		jmp	short loc_2D8B
; ---------------------------------------------------------------------------

loc_2D33:				; CODE XREF: icu_56::LocDataParser::parse(wchar_t *,int)+89j
		cmp	[ebp+arg_4], 0
		jg	short loc_2D55
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	dword ptr [ecx], 1
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	short loc_2D8B
; ---------------------------------------------------------------------------

loc_2D55:				; CODE XREF: icu_56::LocDataParser::parse(wchar_t *,int)+9Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		lea	eax, [ecx+edx*2]
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		mov	eax, 0FFFFh
		mov	ecx, [ebp+var_8]
		mov	[ecx+0Ch], ax
		mov	ecx, [ebp+var_8] ; this
		call	?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ ; icu_56::LocDataParser::doParse(void)

loc_2D8B:				; CODE XREF: icu_56::LocDataParser::parse(wchar_t *,int)+4Fj
					; icu_56::LocDataParser::parse(wchar_t *,int)+99j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?parse@LocDataParser@icu_56@@QAEPAVStringLocalizationInfo@2@PA_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::LocDataParser::parse(wchar_t *,int)+2Cp
					; icu_56::LocDataParser::nextArray(int &)+4Bp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::StringLocalizationInfo	*__thiscall icu_56::LocDataParser::doParse(icu_56::LocDataParser *__hidden this)
		public ?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ
?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ proc near
					; CODE XREF: icu_56::LocDataParser::parse(wchar_t *,int)+EEp

var_190		= dword	ptr -190h
var_188		= dword	ptr -188h
var_17C		= dword	ptr -17Ch
var_170		= dword	ptr -170h
var_164		= dword	ptr -164h
var_158		= dword	ptr -158h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_59		= byte ptr -59h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_35		= byte ptr -35h
var_2C		= byte ptr -2Ch
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 184h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_190]
		mov	ecx, 61h ; 'a'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	?skipWhitespace@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::skipWhitespace(void)
		push	3Ch ; '<'       ; wchar_t
		mov	ecx, [ebp+var_14] ; this
		call	?checkInc@LocDataParser@icu_56@@AAEC_W@Z ; icu_56::LocDataParser::checkInc(wchar_t)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_2E41
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		xor	eax, eax
		jmp	loc_30B7
; ---------------------------------------------------------------------------
		jmp	loc_30AB
; ---------------------------------------------------------------------------

loc_2E41:				; CODE XREF: icu_56::LocDataParser::doParse(void)+59j
		push	offset ?DeleteFn@icu_56@@YAXPAX@Z ; void (__cdecl *)(void *)
		lea	ecx, [ebp+var_2C] ; this
		call	??0VArray@icu_56@@QAE@P6AXPAX@Z@Z ; icu_56::VArray::VArray(void	(*)(void *))
		mov	[ebp+var_4], 0
		mov	[ebp+var_35], 1
		mov	[ebp+var_44], 0FFFFFFFFh

loc_2E60:				; CODE XREF: icu_56::LocDataParser::doParse(void):loc_2EF9j
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jz	loc_2EFE
		mov	[ebp+var_35], 0
		lea	eax, [ebp+var_44]
		push	eax		; int *
		mov	ecx, [ebp+var_14] ; this
		call	?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z	; icu_56::LocDataParser::nextArray(int &)
		mov	[ebp+var_50], eax
		mov	ecx, [ebp+var_14] ; this
		call	?skipWhitespace@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::skipWhitespace(void)
		push	2Ch ; ','       ; wchar_t
		mov	ecx, [ebp+var_14] ; this
		call	?check@LocDataParser@icu_56@@AAEC_W@Z ;	icu_56::LocDataParser::check(wchar_t)
		mov	[ebp+var_59], al
		cmp	[ebp+var_50], 0
		jz	short loc_2EC3
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		push	ecx		; enum UErrorCode *
		mov	edx, [ebp+var_50]
		push	edx		; void *
		lea	ecx, [ebp+var_2C] ; this
		call	?add@VArray@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ;	icu_56::VArray::add(void *,UErrorCode &)
		movsx	eax, [ebp+var_59]
		test	eax, eax
		jz	short loc_2EC1
		mov	ecx, [ebp+var_14] ; this
		call	?inc@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::inc(void)
		mov	[ebp+var_35], 1

loc_2EC1:				; CODE XREF: icu_56::LocDataParser::doParse(void)+E3j
		jmp	short loc_2EF9
; ---------------------------------------------------------------------------

loc_2EC3:				; CODE XREF: icu_56::LocDataParser::doParse(void)+C8j
		movsx	eax, [ebp+var_59]
		test	eax, eax
		jz	short loc_2EF9
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		mov	[ebp+var_188], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
		mov	eax, [ebp+var_188]
		jmp	loc_30B7
; ---------------------------------------------------------------------------

loc_2EF9:				; CODE XREF: icu_56::LocDataParser::doParse(void):loc_2EC1j
					; icu_56::LocDataParser::doParse(void)+F9j
		jmp	loc_2E60
; ---------------------------------------------------------------------------

loc_2EFE:				; CODE XREF: icu_56::LocDataParser::doParse(void)+96j
		mov	ecx, [ebp+var_14] ; this
		call	?skipWhitespace@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::skipWhitespace(void)
		push	3Eh ; '>'       ; wchar_t
		mov	ecx, [ebp+var_14] ; this
		call	?checkInc@LocDataParser@icu_56@@AAEC_W@Z ; icu_56::LocDataParser::checkInc(wchar_t)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_2F86
		push	3Ch ; '<'       ; wchar_t
		mov	ecx, [ebp+var_14] ; this
		call	?check@LocDataParser@icu_56@@AAEC_W@Z ;	icu_56::LocDataParser::check(wchar_t)
		movsx	eax, al
		test	eax, eax
		jz	short loc_2F58
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		mov	[ebp+var_17C], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
		mov	eax, [ebp+var_17C]
		jmp	loc_30B7
; ---------------------------------------------------------------------------
		jmp	short loc_2F86
; ---------------------------------------------------------------------------

loc_2F58:				; CODE XREF: icu_56::LocDataParser::doParse(void)+156j
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		mov	[ebp+var_170], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
		mov	eax, [ebp+var_170]
		jmp	loc_30B7
; ---------------------------------------------------------------------------

loc_2F86:				; CODE XREF: icu_56::LocDataParser::doParse(void)+145j
					; icu_56::LocDataParser::doParse(void)+186j
		mov	ecx, [ebp+var_14] ; this
		call	?skipWhitespace@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::skipWhitespace(void)
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+8]
		cmp	edx, [ecx+4]
		jz	short loc_2FCA
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		mov	[ebp+var_164], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
		mov	eax, [ebp+var_164]
		jmp	loc_30B7
; ---------------------------------------------------------------------------

loc_2FCA:				; CODE XREF: icu_56::LocDataParser::doParse(void)+1CAj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		push	ecx		; enum UErrorCode *
		push	0		; void *
		lea	ecx, [ebp+var_2C] ; this
		call	?add@VArray@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ;	icu_56::VArray::add(void *,UErrorCode &)
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	edx, [ecx]
		push	edx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	eax, al
		test	eax, eax
		jz	loc_309C
		lea	ecx, [ebp+var_2C] ; this
		call	?length@VArray@icu_56@@QAEHXZ ;	icu_56::VArray::length(void)

loc_2FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		sub	eax, 2
		mov	[ebp+var_68], eax
		lea	ecx, [ebp+var_2C] ; this
		call	?release@VArray@icu_56@@QAEPAPAXXZ ; icu_56::VArray::release(void)
		mov	[ebp+var_74], eax
		mov	esi, esp
		push	18h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_140], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_140], 0
		jz	short loc_305F
		mov	eax, [ebp+var_68]
		push	eax		; int
		mov	ecx, [ebp+var_44]
		sub	ecx, 2
		push	ecx		; int
		mov	edx, [ebp+var_74]
		push	edx		; wchar_t ***
		mov	eax, [ebp+var_14]
		mov	ecx, [eax]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_140] ; this
		call	??0StringLocalizationInfo@icu_56@@AAE@PA_WPAPAPA_WHH@Z ; icu_56::StringLocalizationInfo::StringLocalizationInfo(wchar_t	*,wchar_t * * *,int,int)
		mov	[ebp+var_190], eax
		jmp	short loc_3069
; ---------------------------------------------------------------------------

loc_305F:				; CODE XREF: icu_56::LocDataParser::doParse(void)+265j
		mov	[ebp+var_190], 0

loc_3069:				; CODE XREF: icu_56::LocDataParser::doParse(void)+28Dj
		mov	edx, [ebp+var_190]
		mov	[ebp+var_14C], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_14C]
		mov	[ebp+var_158], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
		mov	eax, [ebp+var_158]
		jmp	short loc_30B7
; ---------------------------------------------------------------------------

loc_309C:				; CODE XREF: icu_56::LocDataParser::doParse(void)+221j
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)

loc_30AB:				; CODE XREF: icu_56::LocDataParser::doParse(void)+6Cj
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		xor	eax, eax

loc_30B7:				; CODE XREF: icu_56::LocDataParser::doParse(void)+67j
					; icu_56::LocDataParser::doParse(void)+124j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN24
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 190h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
$LN24		dd 2			; DATA XREF: icu_56::LocDataParser::doParse(void)+2EBo
		dd offset $LN23
$LN23		dd 0FFFFFFD4h, 10h	; DATA XREF: .text:000030ECo
		dd offset $LN20		; "array"
		dd 0FFFFFFBCh, 4
		dd offset $LN21		; "requiredLength"
$LN21		db 'requiredLength',0   ; DATA XREF: .text:00003104o
$LN20		db 'array',0            ; DATA XREF: .text:000030F8o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3120h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ$0 proc	near
					; DATA XREF: .xdata$x:00003164o
		lea	ecx, [ebp-2Ch]	; this
		jmp	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
__unwindfunclet$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ$1 proc	near
					; DATA XREF: .xdata$x:0000316Co
		mov	esi, esp
		mov	eax, [ebp-140h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ proc near
					; DATA XREF: icu_56::LocDataParser::doParse(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-194h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3160h
__unwindtable$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003178o
		dd offset __unwindfunclet$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ$0
		dd 0
		dd offset __unwindfunclet$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ$1
__ehfuncinfo$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ+14o
		dd offset __unwindtable$?doParse@LocDataParser@icu_56@@AAEPAVStringLocalizationInfo@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3194h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::VArray::VArray(icu_56::VArray *this, void (__cdecl *)(void *))
		public ??0VArray@icu_56@@QAE@P6AXPAX@Z@Z
??0VArray@icu_56@@QAE@P6AXPAX@Z@Z proc near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+79p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0VArray@icu_56@@QAE@P6AXPAX@Z@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::VArray::~VArray(icu_56::VArray *__hidden this)
		public ??1VArray@icu_56@@QAE@XZ
??1VArray@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::LocDataParser::doParse(void)+119p
					; icu_56::LocDataParser::doParse(void)+176p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_3257
		mov	[ebp+var_14], 0
		jmp	short loc_322A
; ---------------------------------------------------------------------------

loc_3221:				; CODE XREF: icu_56::VArray::~VArray(void)+69j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_322A:				; CODE XREF: icu_56::VArray::~VArray(void)+33j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+8]
		jge	short loc_3257
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		call	edx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_3221
; ---------------------------------------------------------------------------

loc_3257:				; CODE XREF: icu_56::VArray::~VArray(void)+2Aj
					; icu_56::VArray::~VArray(void)+47j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1VArray@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 327Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::VArray::length(icu_56::VArray *__hidden this)
		public ?length@VArray@icu_56@@QAEHXZ
?length@VArray@icu_56@@QAEHXZ proc near	; CODE XREF: icu_56::LocDataParser::doParse(void)+22Ap
					; icu_56::LocDataParser::nextArray(int &)+1F8p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@VArray@icu_56@@QAEHXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::VArray::add(icu_56::VArray *this, void *, enum UErrorCode *)
		public ?add@VArray@icu_56@@QAEXPAXAAW4UErrorCode@@@Z
?add@VArray@icu_56@@QAEXPAXAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+D8p
					; icu_56::LocDataParser::doParse(void)+206p ...

var_E4		= byte ptr -0E4h
Size		= dword	ptr -20h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_33E3
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		cmp	edx, [ecx+4]
		jnz	loc_33C3
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_330F
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 1
		jmp	short loc_333D
; ---------------------------------------------------------------------------

loc_330F:				; CODE XREF: icu_56::VArray::add(void *,UErrorCode &)+55j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 100h
		jge	short loc_332B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		shl	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		jmp	short loc_333D
; ---------------------------------------------------------------------------

loc_332B:				; CODE XREF: icu_56::VArray::add(void *,UErrorCode &)+6Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 100h
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_333D:				; CODE XREF: icu_56::VArray::add(void *,UErrorCode &)+61j
					; icu_56::VArray::add(void *,UErrorCode	&)+7Dj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		jnz	short loc_335E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		shl	ecx, 2
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	edx, [ebp+var_8]
		mov	[edx], eax
		jmp	short loc_337B
; ---------------------------------------------------------------------------

loc_335E:				; CODE XREF: icu_56::VArray::add(void *,UErrorCode &)+97j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		shl	ecx, 2
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		push	eax
		call	_uprv_realloc_56
		add	esp, 8
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax

loc_337B:				; CODE XREF: icu_56::VArray::add(void *,UErrorCode &)+B0j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		jnz	short loc_338E
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		jmp	short loc_33E3
; ---------------------------------------------------------------------------

loc_338E:				; CODE XREF: icu_56::VArray::add(void *,UErrorCode &)+D5j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		lea	ecx, [eax+ecx*4]
		mov	[ebp+Dst], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+4]
		sub	edx, [ecx+8]
		shl	edx, 2
		mov	[ebp+Size], edx
		mov	eax, [ebp+Size]
		push	eax		; Size
		push	0		; Val
		mov	ecx, [ebp+Dst]
		push	ecx		; Dst
		call	_memset
		add	esp, 0Ch

loc_33C3:				; CODE XREF: icu_56::VArray::add(void *,UErrorCode &)+48j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	edx, [ebp+arg_0]
		mov	[eax+ecx*4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx

loc_33E3:				; CODE XREF: icu_56::VArray::add(void *,UErrorCode &)+36j
					; icu_56::VArray::add(void *,UErrorCode	&)+E0j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?add@VArray@icu_56@@QAEXPAXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 33FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void **__thiscall icu_56::VArray::release(icu_56::VArray *__hidden this)
		public ?release@VArray@icu_56@@QAEPAPAXXZ
?release@VArray@icu_56@@QAEPAPAXXZ proc	near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+238p
					; icu_56::LocDataParser::nextArray(int &)+250p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?release@VArray@icu_56@@QAEPAPAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3450h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringLocalizationInfo::StringLocalizationInfo(icu_56::StringLocalizationInfo *this, wchar_t *, wchar_t ***, int, int)
		public ??0StringLocalizationInfo@icu_56@@AAE@PA_WPAPAPA_WHH@Z
??0StringLocalizationInfo@icu_56@@AAE@PA_WPAPAPA_WHH@Z proc near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+282p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0LocalizationInfo@icu_56@@QAE@XZ ; icu_56::LocalizationInfo::LocalizationInfo(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7StringLocalizationInfo@icu_56@@6B@ ; const icu_56::StringLocalizationInfo::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_C]
		mov	[eax+14h], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??0StringLocalizationInfo@icu_56@@AAE@PA_WPAPAPA_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34C4h
		dd offset ??_R4StringLocalizationInfo@icu_56@@6B@ ; const icu_56::StringLocalizationInfo::`RTTI	Complete Object	Locator'
		public ??_7StringLocalizationInfo@icu_56@@6B@
; const	icu_56::StringLocalizationInfo::`vftable'
??_7StringLocalizationInfo@icu_56@@6B@ dd offset ??_EStringLocalizationInfo@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::StringLocalizationInfo::StringLocalizationInfo(wchar_t *,wchar_t *	* *,int,int)+2Eo
					; icu_56::StringLocalizationInfo::~StringLocalizationInfo(void)+26o
					; icu_56::StringLocalizationInfo::`vector deleting destructor'(uint)
		dd offset ??8LocalizationInfo@icu_56@@UBECPBV01@@Z ; icu_56::LocalizationInfo::operator==(icu_56::LocalizationInfo const *)
		dd offset ?getNumberOfRuleSets@StringLocalizationInfo@icu_56@@UBEHXZ ; icu_56::StringLocalizationInfo::getNumberOfRuleSets(void)
		dd offset ?getRuleSetName@StringLocalizationInfo@icu_56@@UBEPB_WH@Z ; icu_56::StringLocalizationInfo::getRuleSetName(int)
		dd offset ?getNumberOfDisplayLocales@StringLocalizationInfo@icu_56@@UBEHXZ ; icu_56::StringLocalizationInfo::getNumberOfDisplayLocales(void)
		dd offset ?getLocaleName@StringLocalizationInfo@icu_56@@UBEPB_WH@Z ; icu_56::StringLocalizationInfo::getLocaleName(int)
		dd offset ?getDisplayName@StringLocalizationInfo@icu_56@@UBEPB_WHH@Z ; icu_56::StringLocalizationInfo::getDisplayName(int,int)
		dd offset ?indexForLocale@LocalizationInfo@icu_56@@UBEHPB_W@Z ;	icu_56::LocalizationInfo::indexForLocale(wchar_t const *)
		dd offset ?indexForRuleSet@LocalizationInfo@icu_56@@UBEHPB_W@Z ; icu_56::LocalizationInfo::indexForRuleSet(wchar_t const *)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 34ECh
		public ??_R4StringLocalizationInfo@icu_56@@6B@
; const	icu_56::StringLocalizationInfo::`RTTI Complete Object Locator'
??_R4StringLocalizationInfo@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:000034C4o
		dd offset ??_R0?AVStringLocalizationInfo@icu_56@@@8 ; icu_56::StringLocalizationInfo `RTTI Type	Descriptor'
		dd offset ??_R3StringLocalizationInfo@icu_56@@8	; icu_56::StringLocalizationInfo::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 3500h
		public ??_R0?AVStringLocalizationInfo@icu_56@@@8
; class	icu_56::StringLocalizationInfo `RTTI Type Descriptor'
??_R0?AVStringLocalizationInfo@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000034F8o
					; .rdata$r:icu_56::StringLocalizationInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avstringloca	db '.?AVStringLocalizationInfo@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 352Ch
		public ??_R3StringLocalizationInfo@icu_56@@8
; icu_56::StringLocalizationInfo::`RTTI	Class Hierarchy	Descriptor'
??_R3StringLocalizationInfo@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:000034FCo
					; .rdata$r:00003564o
		dd 3
		dd offset ??_R2StringLocalizationInfo@icu_56@@8	; icu_56::StringLocalizationInfo::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 353Ch
		public ??_R2StringLocalizationInfo@icu_56@@8
; icu_56::StringLocalizationInfo::`RTTI	Base Class Array'
??_R2StringLocalizationInfo@icu_56@@8 dd offset	??_R1A@?0A@EA@StringLocalizationInfo@icu_56@@8
					; DATA XREF: .rdata$r:00003538o
					; icu_56::StringLocalizationInfo::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@LocalizationInfo@icu_56@@8 ; icu_56::LocalizationInfo::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 354Ch
		public ??_R1A@?0A@EA@StringLocalizationInfo@icu_56@@8
; icu_56::StringLocalizationInfo::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@StringLocalizationInfo@icu_56@@8 dd offset ??_R0?AVStringLocalizationInfo@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::StringLocalizationInfo::`RTTI Base Class Array'o
					; icu_56::StringLocalizationInfo `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3StringLocalizationInfo@icu_56@@8	; icu_56::StringLocalizationInfo::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3568h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::LocalizationInfo::LocalizationInfo(icu_56::LocalizationInfo	*__hidden this)
		public ??0LocalizationInfo@icu_56@@QAE@XZ
??0LocalizationInfo@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::StringLocalizationInfo::StringLocalizationInfo(wchar_t *,wchar_t *	* *,int,int)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7LocalizationInfo@icu_56@@6B@ ; const icu_56::LocalizationInfo::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0LocalizationInfo@icu_56@@QAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringLocalizationInfo::getNumberOfRuleSets(icu_56::StringLocalizationInfo *__hidden this)
		public ?getNumberOfRuleSets@StringLocalizationInfo@icu_56@@UBEHXZ
?getNumberOfRuleSets@StringLocalizationInfo@icu_56@@UBEHXZ proc	near
					; DATA XREF: .rdata:000034D0o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getNumberOfRuleSets@StringLocalizationInfo@icu_56@@UBEHXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringLocalizationInfo::getNumberOfDisplayLocales(icu_56::StringLocalizationInfo *__hidden this)
		public ?getNumberOfDisplayLocales@StringLocalizationInfo@icu_56@@UBEHXZ
?getNumberOfDisplayLocales@StringLocalizationInfo@icu_56@@UBEHXZ proc near
					; DATA XREF: .rdata:000034D8o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getNumberOfDisplayLocales@StringLocalizationInfo@icu_56@@UBEHXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3608h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::StringLocalizationInfo::`scalar deleting destructor'(unsigned int)
		public ??_GStringLocalizationInfo@icu_56@@UAEPAXI@Z
??_GStringLocalizationInfo@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1StringLocalizationInfo@icu_56@@UAE@XZ ; icu_56::StringLocalizationInfo::~StringLocalizationInfo(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3651
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3651:				; CODE XREF: icu_56::StringLocalizationInfo::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GStringLocalizationInfo@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 366Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::LocDataParser::inc(icu_56::LocDataParser *__hidden this)
		public ?inc@LocDataParser@icu_56@@AAEXXZ
?inc@LocDataParser@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+E8p
					; icu_56::LocDataParser::checkInc(wchar_t)+54p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		add	ecx, 2
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx
		mov	eax, 0FFFFh
		mov	ecx, [ebp+var_8]
		mov	[ecx+0Ch], ax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?inc@LocDataParser@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 36B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::LocDataParser::checkInc(icu_56::LocDataParser *this,	wchar_t)
		public ?checkInc@LocDataParser@icu_56@@AAEC_W@Z
?checkInc@LocDataParser@icu_56@@AAEC_W@Z proc near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+4Fp
					; icu_56::LocDataParser::doParse(void)+13Bp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		cmp	edx, [ecx+4]
		jnb	short loc_3711
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax+0Ch]
		movzx	edx, [ebp+arg_0]
		cmp	ecx, edx
		jz	short loc_3705
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		movzx	edx, word ptr [ecx]
		movzx	eax, [ebp+arg_0]
		cmp	edx, eax
		jnz	short loc_3711

loc_3705:				; CODE XREF: icu_56::LocDataParser::checkInc(wchar_t)+3Ej
		mov	ecx, [ebp+var_8] ; this
		call	?inc@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::inc(void)
		mov	al, 1
		jmp	short loc_3713
; ---------------------------------------------------------------------------

loc_3711:				; CODE XREF: icu_56::LocDataParser::checkInc(wchar_t)+2Fj
					; icu_56::LocDataParser::checkInc(wchar_t)+4Fj
		xor	al, al

loc_3713:				; CODE XREF: icu_56::LocDataParser::checkInc(wchar_t)+5Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?checkInc@LocDataParser@icu_56@@AAEC_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 372Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::LocDataParser::check(icu_56::LocDataParser *this, wchar_t)
		public ?check@LocDataParser@icu_56@@AAEC_W@Z
?check@LocDataParser@icu_56@@AAEC_W@Z proc near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+BCp
					; icu_56::LocDataParser::doParse(void)+14Cp ...

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		cmp	edx, [ecx+4]
		jnb	short loc_3786
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax+0Ch]
		movzx	edx, [ebp+arg_0]
		cmp	ecx, edx
		jz	short loc_377D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		movzx	edx, word ptr [ecx]
		movzx	eax, [ebp+arg_0]
		cmp	edx, eax
		jnz	short loc_3786

loc_377D:				; CODE XREF: icu_56::LocDataParser::check(wchar_t)+3Ej
		mov	[ebp+var_CD], 1
		jmp	short loc_378D
; ---------------------------------------------------------------------------

loc_3786:				; CODE XREF: icu_56::LocDataParser::check(wchar_t)+2Fj
					; icu_56::LocDataParser::check(wchar_t)+4Fj
		mov	[ebp+var_CD], 0

loc_378D:				; CODE XREF: icu_56::LocDataParser::check(wchar_t)+58j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?check@LocDataParser@icu_56@@AAEC_W@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 379Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::LocDataParser::skipWhitespace(icu_56::LocDataParser *__hidden	this)
		public ?skipWhitespace@LocDataParser@icu_56@@AAEXXZ
?skipWhitespace@LocDataParser@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+45p
					; icu_56::LocDataParser::doParse(void)+B2p ...

var_D0		= byte ptr -0D0h
var_CE		= word ptr -0CEh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx

loc_37BF:				; CODE XREF: icu_56::LocDataParser::skipWhitespace(void)+89j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		cmp	edx, [ecx+4]
		jnb	short loc_3827
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax+0Ch]
		cmp	ecx, 0FFFFh
		jz	short loc_37EC
		mov	edx, [ebp+var_8]
		mov	ax, [edx+0Ch]
		mov	[ebp+var_CE], ax
		jmp	short loc_37FC
; ---------------------------------------------------------------------------

loc_37EC:				; CODE XREF: icu_56::LocDataParser::skipWhitespace(void)+3Ej
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	ax, [edx]
		mov	[ebp+var_CE], ax

loc_37FC:				; CODE XREF: icu_56::LocDataParser::skipWhitespace(void)+4Ej
		movzx	ecx, [ebp+var_CE]
		mov	esi, esp
		push	ecx		; int
		call	dword ptr ds:__imp_?isWhiteSpace@PatternProps@icu_56@@SACH@Z ; icu_56::PatternProps::isWhiteSpace(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	edx, al
		test	edx, edx
		jz	short loc_3827
		mov	ecx, [ebp+var_8] ; this
		call	?inc@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::inc(void)
		jmp	short loc_37BF
; ---------------------------------------------------------------------------

loc_3827:				; CODE XREF: icu_56::LocDataParser::skipWhitespace(void)+2Fj
					; icu_56::LocDataParser::skipWhitespace(void)+7Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?skipWhitespace@LocDataParser@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 383Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::DeleteFn(void *)
?DeleteFn@icu_56@@YAXPAX@Z proc	near	; DATA XREF: icu_56::LocDataParser::doParse(void):loc_2E41o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?DeleteFn@icu_56@@YAXPAX@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 387Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t **__thiscall icu_56::LocDataParser::nextArray(icu_56::LocDataParser *this, int *)
		public ?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z
?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z	proc near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+A7p

var_15C		= byte ptr -15Ch
var_158		= dword	ptr -158h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_4D		= byte ptr -4Dh
var_44		= dword	ptr -44h
var_35		= byte ptr -35h
var_2C		= byte ptr -2Ch
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 150h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_15C]
		mov	ecx, 54h ; 'T'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	edx, [ecx]
		push	edx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	eax, al
		test	eax, eax
		jz	short loc_38DD
		xor	eax, eax
		jmp	loc_3B17
; ---------------------------------------------------------------------------

loc_38DD:				; CODE XREF: icu_56::LocDataParser::nextArray(int &)+58j
		mov	ecx, [ebp+var_14] ; this
		call	?skipWhitespace@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::skipWhitespace(void)
		push	3Ch ; '<'       ; wchar_t
		mov	ecx, [ebp+var_14] ; this
		call	?checkInc@LocDataParser@icu_56@@AAEC_W@Z ; icu_56::LocDataParser::checkInc(wchar_t)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_3907
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		xor	eax, eax
		jmp	loc_3B17
; ---------------------------------------------------------------------------

loc_3907:				; CODE XREF: icu_56::LocDataParser::nextArray(int &)+78j
		lea	ecx, [ebp+var_2C] ; this
		call	??0VArray@icu_56@@QAE@XZ ; icu_56::VArray::VArray(void)
		mov	[ebp+var_4], 0
		mov	[ebp+var_35], 1

loc_391A:				; CODE XREF: icu_56::LocDataParser::nextArray(int &):loc_39AFj
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jz	loc_39B4
		mov	[ebp+var_35], 0
		mov	ecx, [ebp+var_14] ; this
		call	?nextString@LocDataParser@icu_56@@AAEPA_WXZ ; icu_56::LocDataParser::nextString(void)
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_14] ; this
		call	?skipWhitespace@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::skipWhitespace(void)
		push	2Ch ; ','       ; wchar_t
		mov	ecx, [ebp+var_14] ; this
		call	?check@LocDataParser@icu_56@@AAEC_W@Z ;	icu_56::LocDataParser::check(wchar_t)
		mov	[ebp+var_4D], al
		cmp	[ebp+var_44], 0
		jz	short loc_3979
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		push	ecx		; enum UErrorCode *
		mov	edx, [ebp+var_44]
		push	edx		; void *
		lea	ecx, [ebp+var_2C] ; this
		call	?add@VArray@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ;	icu_56::VArray::add(void *,UErrorCode &)
		movsx	eax, [ebp+var_4D]
		test	eax, eax
		jz	short loc_3977
		mov	ecx, [ebp+var_14] ; this
		call	?inc@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::inc(void)
		mov	[ebp+var_35], 1

loc_3977:				; CODE XREF: icu_56::LocDataParser::nextArray(int &)+EDj
		jmp	short loc_39AF
; ---------------------------------------------------------------------------

loc_3979:				; CODE XREF: icu_56::LocDataParser::nextArray(int &)+D2j
		movsx	eax, [ebp+var_4D]
		test	eax, eax
		jz	short loc_39AF
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		mov	[ebp+var_158], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
		mov	eax, [ebp+var_158]
		jmp	loc_3B17
; ---------------------------------------------------------------------------

loc_39AF:				; CODE XREF: icu_56::LocDataParser::nextArray(int &):loc_3977j
					; icu_56::LocDataParser::nextArray(int &)+103j
		jmp	loc_391A
; ---------------------------------------------------------------------------

loc_39B4:				; CODE XREF: icu_56::LocDataParser::nextArray(int &)+A4j
		mov	ecx, [ebp+var_14] ; this
		call	?skipWhitespace@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::skipWhitespace(void)
		push	3Eh ; '>'       ; wchar_t
		mov	ecx, [ebp+var_14] ; this
		call	?checkInc@LocDataParser@icu_56@@AAEC_W@Z ; icu_56::LocDataParser::checkInc(wchar_t)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_3A3C
		push	3Ch ; '<'       ; wchar_t
		mov	ecx, [ebp+var_14] ; this
		call	?check@LocDataParser@icu_56@@AAEC_W@Z ;	icu_56::LocDataParser::check(wchar_t)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3A0E
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		mov	[ebp+var_14C], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
		mov	eax, [ebp+var_14C]
		jmp	loc_3B17
; ---------------------------------------------------------------------------
		jmp	short loc_3A3C
; ---------------------------------------------------------------------------

loc_3A0E:				; CODE XREF: icu_56::LocDataParser::nextArray(int &)+160j
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		mov	[ebp+var_140], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
		mov	eax, [ebp+var_140]
		jmp	loc_3B17
; ---------------------------------------------------------------------------

loc_3A3C:				; CODE XREF: icu_56::LocDataParser::nextArray(int &)+14Fj
					; icu_56::LocDataParser::nextArray(int &)+190j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		push	ecx		; enum UErrorCode *
		push	0		; void *
		lea	ecx, [ebp+var_2C] ; this
		call	?add@VArray@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ;	icu_56::VArray::add(void *,UErrorCode &)
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	edx, [ecx]
		push	edx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	eax, al
		test	eax, eax
		jz	loc_3AEE
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0FFFFFFFFh
		jnz	short loc_3A83
		lea	ecx, [ebp+var_2C] ; this
		call	?length@VArray@icu_56@@QAEHXZ ;	icu_56::VArray::length(void)
		add	eax, 1
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax
		jmp	short loc_3AC9
; ---------------------------------------------------------------------------

loc_3A83:				; CODE XREF: icu_56::LocDataParser::nextArray(int &)+1F3j
		lea	ecx, [ebp+var_2C] ; this
		call	?length@VArray@icu_56@@QAEHXZ ;	icu_56::VArray::length(void)
		mov	ecx, [ebp+arg_0]
		cmp	eax, [ecx]
		jz	short loc_3AC9
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	dword ptr [ecx], 1
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		mov	[ebp+var_134], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
		mov	eax, [ebp+var_134]
		jmp	short loc_3B17
; ---------------------------------------------------------------------------

loc_3AC9:				; CODE XREF: icu_56::LocDataParser::nextArray(int &)+205j
					; icu_56::LocDataParser::nextArray(int &)+214j
		lea	ecx, [ebp+var_2C] ; this
		call	?release@VArray@icu_56@@QAEPAPAXXZ ; icu_56::VArray::release(void)
		mov	[ebp+var_128], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
		mov	eax, [ebp+var_128]
		jmp	short loc_3B17
; ---------------------------------------------------------------------------

loc_3AEE:				; CODE XREF: icu_56::LocDataParser::nextArray(int &)+1E7j
		push	0		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		mov	[ebp+var_11C], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
		mov	eax, [ebp+var_11C]

loc_3B17:				; CODE XREF: icu_56::LocDataParser::nextArray(int &)+5Cj
					; icu_56::LocDataParser::nextArray(int &)+86j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN22
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 15Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN22		dd 1			; DATA XREF: icu_56::LocDataParser::nextArray(int &)+29Fo
		dd offset $LN21_0
$LN21_0		dd 0FFFFFFD4h, 10h	; DATA XREF: .text:00003B50o
		dd offset $LN19		; "array"
$LN19		db 'array',0            ; DATA XREF: .text:00003B5Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3B68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z$0 proc near
					; DATA XREF: .xdata$x:00003B94o
		lea	ecx, [ebp-2Ch]	; this
		jmp	??1VArray@icu_56@@QAE@XZ ; icu_56::VArray::~VArray(void)
__unwindfunclet$?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z proc near
					; DATA XREF: icu_56::LocDataParser::nextArray(int &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-160h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z
		jmp	___CxxFrameHandler3
__ehhandler$?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3B90h
__unwindtable$?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003BA0o
		dd offset __unwindfunclet$?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z$0
__ehfuncinfo$?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z+14o
		dd offset __unwindtable$?nextArray@LocDataParser@icu_56@@AAEPAPA_WAAH@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::VArray::VArray(icu_56::VArray *__hidden this)
		public ??0VArray@icu_56@@QAE@XZ
??0VArray@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::LocDataParser::nextArray(int &)+8Ep

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0VArray@icu_56@@QAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t *__thiscall icu_56::LocDataParser::nextString(icu_56::LocDataParser *__hidden	this)
		public ?nextString@LocDataParser@icu_56@@AAEPA_WXZ
?nextString@LocDataParser@icu_56@@AAEPA_WXZ proc near
					; CODE XREF: icu_56::LocDataParser::nextArray(int &)+B1p

var_118		= dword	ptr -118h
var_50		= word ptr -50h
var_44		= dword	ptr -44h
var_35		= byte ptr -35h
var_2C		= word ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	ecx, [ebp+var_8] ; this
		call	?skipWhitespace@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::skipWhitespace(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		cmp	edx, [ecx+4]
		jnb	loc_3DD5
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	dx, [ecx]
		mov	[ebp+var_2C], dx
		movzx	eax, [ebp+var_2C]
		cmp	eax, 22h ; '"'
		jz	short loc_3C7C
		movzx	ecx, [ebp+var_2C]
		cmp	ecx, 27h ; '''
		jz	short loc_3C7C
		mov	byte ptr [ebp+var_118+3], 0
		jmp	short loc_3C83
; ---------------------------------------------------------------------------

loc_3C7C:				; CODE XREF: icu_56::LocDataParser::nextString(void)+58j
					; icu_56::LocDataParser::nextString(void)+61j
		mov	byte ptr [ebp+var_118+3], 1

loc_3C83:				; CODE XREF: icu_56::LocDataParser::nextString(void)+6Aj
		mov	dl, byte ptr [ebp+var_118+3]
		mov	[ebp+var_35], dl
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jz	short loc_3CC6
		mov	ecx, [ebp+var_8] ; this
		call	?inc@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::inc(void)
		movzx	eax, [ebp+var_2C]
		cmp	eax, 22h ; '"'
		jnz	short loc_3CB1
		mov	[ebp+var_118], offset _DQUOTE_STOPLIST
		jmp	short loc_3CBB
; ---------------------------------------------------------------------------

loc_3CB1:				; CODE XREF: icu_56::LocDataParser::nextString(void)+93j
		mov	[ebp+var_118], offset _SQUOTE_STOPLIST

loc_3CBB:				; CODE XREF: icu_56::LocDataParser::nextString(void)+9Fj
		mov	ecx, [ebp+var_118]
		mov	[ebp+var_20], ecx
		jmp	short loc_3CCD
; ---------------------------------------------------------------------------

loc_3CC6:				; CODE XREF: icu_56::LocDataParser::nextString(void)+82j
		mov	[ebp+var_20], offset _NOQUOTE_STOPLIST ; " ,><'\""

loc_3CCD:				; CODE XREF: icu_56::LocDataParser::nextString(void)+B4j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	[ebp+var_44], ecx

loc_3CD6:				; CODE XREF: icu_56::LocDataParser::nextString(void)+100j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		cmp	edx, [ecx+4]
		jnb	short loc_3D12
		mov	eax, [ebp+var_20]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		movzx	eax, word ptr [edx]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?inList@LocDataParser@icu_56@@ABEC_WPB_W@Z ; icu_56::LocDataParser::inList(wchar_t,wchar_t const *)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_3D12
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		add	ecx, 2
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx
		jmp	short loc_3CD6
; ---------------------------------------------------------------------------

loc_3D12:				; CODE XREF: icu_56::LocDataParser::nextString(void)+D2j
					; icu_56::LocDataParser::nextString(void)+EFj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		cmp	edx, [ecx+4]
		jnz	short loc_3D31
		push	0		; char *
		mov	ecx, [ebp+var_8] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		xor	eax, eax
		jmp	loc_3DD8
; ---------------------------------------------------------------------------

loc_3D31:				; CODE XREF: icu_56::LocDataParser::nextString(void)+10Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	dx, [ecx]
		mov	[ebp+var_50], dx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		cmp	ecx, [ebp+var_44]
		jbe	short loc_3D65
		mov	eax, [ebp+var_8]
		mov	cx, [ebp+var_50]
		mov	[eax+0Ch], cx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		xor	edx, edx
		mov	[ecx], dx
		mov	eax, [ebp+var_44]
		mov	[ebp+var_14], eax

loc_3D65:				; CODE XREF: icu_56::LocDataParser::nextString(void)+137j
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jz	short loc_3DAC
		movzx	eax, [ebp+var_50]
		movzx	ecx, [ebp+var_2C]
		cmp	eax, ecx
		jz	short loc_3D89
		push	0		; char *
		mov	ecx, [ebp+var_8] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		xor	eax, eax
		jmp	short loc_3DD8
; ---------------------------------------------------------------------------
		jmp	short loc_3DA2
; ---------------------------------------------------------------------------

loc_3D89:				; CODE XREF: icu_56::LocDataParser::nextString(void)+167j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		cmp	ecx, [ebp+var_44]
		jnz	short loc_3DA2
		push	0		; char *
		mov	ecx, [ebp+var_8] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		xor	eax, eax
		jmp	short loc_3DD8
; ---------------------------------------------------------------------------

loc_3DA2:				; CODE XREF: icu_56::LocDataParser::nextString(void)+177j
					; icu_56::LocDataParser::nextString(void)+182j
		mov	ecx, [ebp+var_8] ; this
		call	?inc@LocDataParser@icu_56@@AAEXXZ ; icu_56::LocDataParser::inc(void)
		jmp	short loc_3DD5
; ---------------------------------------------------------------------------

loc_3DAC:				; CODE XREF: icu_56::LocDataParser::nextString(void)+15Bj
		movzx	eax, [ebp+var_50]
		cmp	eax, 3Ch ; '<'
		jz	short loc_3DC7
		movzx	eax, [ebp+var_50]
		cmp	eax, 27h ; '''
		jz	short loc_3DC7
		movzx	eax, [ebp+var_50]
		cmp	eax, 22h ; '"'
		jnz	short loc_3DD5

loc_3DC7:				; CODE XREF: icu_56::LocDataParser::nextString(void)+1A3j
					; icu_56::LocDataParser::nextString(void)+1ACj
		push	0		; char *
		mov	ecx, [ebp+var_8] ; this
		call	?parseError@LocDataParser@icu_56@@AAEXPBD@Z ; icu_56::LocDataParser::parseError(char const *)
		xor	eax, eax
		jmp	short loc_3DD8
; ---------------------------------------------------------------------------

loc_3DD5:				; CODE XREF: icu_56::LocDataParser::nextString(void)+3Ej
					; icu_56::LocDataParser::nextString(void)+19Aj	...
		mov	eax, [ebp+var_14]

loc_3DD8:				; CODE XREF: icu_56::LocDataParser::nextString(void)+11Cj
					; icu_56::LocDataParser::nextString(void)+175j	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?nextString@LocDataParser@icu_56@@AAEPA_WXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3DECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::LocDataParser::inList(icu_56::LocDataParser *this, wchar_t, const wchar_t *)
		public ?inList@LocDataParser@icu_56@@ABEC_WPB_W@Z
?inList@LocDataParser@icu_56@@ABEC_WPB_W@Z proc	near
					; CODE XREF: icu_56::LocDataParser::nextString(void)+E5p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		movzx	ecx, word ptr [eax]
		cmp	ecx, 20h ; ' '
		jnz	short loc_3E3C
		movzx	eax, [ebp+arg_0]
		mov	esi, esp
		push	eax		; int
		call	dword ptr ds:__imp_?isWhiteSpace@PatternProps@icu_56@@SACH@Z ; icu_56::PatternProps::isWhiteSpace(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_3E3C
		mov	al, 1
		jmp	short loc_3E6E
; ---------------------------------------------------------------------------

loc_3E3C:				; CODE XREF: icu_56::LocDataParser::inList(wchar_t,wchar_t const *)+2Cj
					; icu_56::LocDataParser::inList(wchar_t,wchar_t	const *)+4Aj ...
		mov	eax, [ebp+arg_4]
		movzx	ecx, word ptr [eax]
		test	ecx, ecx
		jz	short loc_3E5F
		mov	eax, [ebp+arg_4]
		movzx	ecx, word ptr [eax]
		movzx	edx, [ebp+arg_0]
		cmp	ecx, edx
		jz	short loc_3E5F
		mov	eax, [ebp+arg_4]
		add	eax, 2
		mov	[ebp+arg_4], eax
		jmp	short loc_3E3C
; ---------------------------------------------------------------------------

loc_3E5F:				; CODE XREF: icu_56::LocDataParser::inList(wchar_t,wchar_t const *)+58j
					; icu_56::LocDataParser::inList(wchar_t,wchar_t	const *)+66j
		mov	eax, [ebp+arg_4]
		movzx	ecx, word ptr [eax]
		movzx	edx, [ebp+arg_0]
		cmp	ecx, edx
		setz	al

loc_3E6E:				; CODE XREF: icu_56::LocDataParser::inList(wchar_t,wchar_t const *)+4Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?inList@LocDataParser@icu_56@@ABEC_WPB_W@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::LocDataParser::parseError(icu_56::LocDataParser *this, const char *)
		public ?parseError@LocDataParser@icu_56@@AAEXPBD@Z
?parseError@LocDataParser@icu_56@@AAEXPBD@Z proc near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+60p
					; icu_56::LocDataParser::doParse(void)+100p ...

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		jnz	short loc_3EB4
		jmp	loc_3FFF
; ---------------------------------------------------------------------------

loc_3EB4:				; CODE XREF: icu_56::LocDataParser::parseError(char const *)+29j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		sub	ecx, 22h ; '"'
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax]
		jnb	short loc_3ED2
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx

loc_3ED2:				; CODE XREF: icu_56::LocDataParser::parseError(char const *)+44j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	[ebp+var_20], ecx

loc_3EDB:				; CODE XREF: icu_56::LocDataParser::parseError(char const *):loc_3F01j
		mov	eax, [ebp+var_20]
		sub	eax, 2
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+var_20]
		cmp	ecx, [ebp+var_14]
		jb	short loc_3F03
		mov	eax, [ebp+var_20]
		movzx	ecx, word ptr [eax]
		test	ecx, ecx
		jnz	short loc_3F01
		mov	eax, [ebp+var_20]
		add	eax, 2
		mov	[ebp+var_14], eax
		jmp	short loc_3F03
; ---------------------------------------------------------------------------

loc_3F01:				; CODE XREF: icu_56::LocDataParser::parseError(char const *)+70j
		jmp	short loc_3EDB
; ---------------------------------------------------------------------------

loc_3F03:				; CODE XREF: icu_56::LocDataParser::parseError(char const *)+66j
					; icu_56::LocDataParser::parseError(char const *)+7Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		add	ecx, 1Eh
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+4]
		jbe	short loc_3F23
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_2C], ecx

loc_3F23:				; CODE XREF: icu_56::LocDataParser::parseError(char const *)+94j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		sub	ecx, [ebp+var_14]
		sar	ecx, 1
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		add	ecx, 8
		push	ecx
		call	_u_strncpy_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+8]
		sub	eax, [ebp+var_14]
		sar	eax, 1
		xor	edx, edx
		mov	[ecx+eax*2+8], dx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_2C]
		sub	ecx, [eax+8]
		sar	ecx, 1
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		add	edx, 28h ; '('
		push	edx
		call	_u_strncpy_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+var_2C]
		sub	eax, [edx+8]
		sar	eax, 1
		xor	edx, edx
		mov	[ecx+eax*2+28h], dx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		sub	edx, [ecx]
		sar	edx, 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ecx+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ecx]
		push	edx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	eax, al
		test	eax, eax
		jz	short loc_3FFF
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	dword ptr [ecx], 9

loc_3FFF:				; CODE XREF: icu_56::LocDataParser::parseError(char const *)+2Bj
					; icu_56::LocDataParser::parseError(char const *)+16Dj
		pop	edi

loc_4000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?parseError@LocDataParser@icu_56@@AAEXPBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4018h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::StringLocalizationInfo	*__cdecl icu_56::StringLocalizationInfo::create(const struct icu_56::UnicodeString *, struct UParseError *, enum UErrorCode *)
		public ?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z
?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString	const &,icu_56::UnicodeString const &,icu_56::Locale const &,UParseError &,UErrorCode &)+159p
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString const &,icu_56::UnicodeString const &,UParseError &,UErrorCode &)+165p

var_110		= byte ptr -110h
var_10C		= dword	ptr -10Ch
var_40		= byte ptr -40h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 104h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_110]
		mov	ecx, 41h ; 'A'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4071
		xor	eax, eax
		jmp	loc_4135
; ---------------------------------------------------------------------------

loc_4071:				; CODE XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+50j
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_4093
		xor	eax, eax
		jmp	loc_4135
; ---------------------------------------------------------------------------

loc_4093:				; CODE XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+72j
		mov	eax, [ebp+var_14]
		shl	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jnz	short loc_40B7
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	short loc_4135
; ---------------------------------------------------------------------------

loc_40B7:				; CODE XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+90j
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14]
		push	ecx		; int
		mov	edx, [ebp+var_20]
		push	edx		; wchar_t *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?extract@UnicodeString@icu_56@@QBEHPA_WHAAW4UErrorCode@@@Z ;	icu_56::UnicodeString::extract(wchar_t *,int,UErrorCode	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	short loc_40F3
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0

loc_40F3:				; CODE XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+D0j
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		lea	ecx, [ebp+var_40] ; this
		call	??0LocDataParser@icu_56@@QAE@AAUUParseError@@AAW4UErrorCode@@@Z	; icu_56::LocDataParser::LocDataParser(UParseError &,UErrorCode	&)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_20]
		push	ecx		; wchar_t *
		lea	ecx, [ebp+var_40] ; this
		call	?parse@LocDataParser@icu_56@@QAEPAVStringLocalizationInfo@2@PA_WH@Z ; icu_56::LocDataParser::parse(wchar_t *,int)
		mov	[ebp+var_10C], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_40] ; this
		call	??1LocDataParser@icu_56@@QAE@XZ	; icu_56::LocDataParser::~LocDataParser(void)
		mov	eax, [ebp+var_10C]

loc_4135:				; CODE XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+54j
					; icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const &,UParseError &,UErrorCode	&)+76j	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 110h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN11		dd 1			; DATA XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+121o
		dd offset $LN10
$LN10		dd 0FFFFFFC0h, 18h	; DATA XREF: .text:0000416Co
		dd offset $LN8		; "parser"
$LN8		db 'parser',0           ; DATA XREF: .text:00004178o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4184h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000041B0o
		lea	ecx, [ebp-40h]	; this
		jmp	??1LocDataParser@icu_56@@QAE@XZ	; icu_56::LocDataParser::~LocDataParser(void)
__unwindfunclet$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-114h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 41ACh
__unwindtable$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000041BCo
		dd offset __unwindfunclet$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::LocDataParser::LocDataParser(icu_56::LocDataParser *this, struct UParseError *, enum UErrorCode *)
		public ??0LocDataParser@icu_56@@QAE@AAUUParseError@@AAW4UErrorCode@@@Z
??0LocDataParser@icu_56@@QAE@AAUUParseError@@AAW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+E6p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, 0FFFFh
		mov	ecx, [ebp+var_8]
		mov	[ecx+0Ch], ax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+14h], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??0LocDataParser@icu_56@@QAE@AAUUParseError@@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4244h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::LocDataParser::~LocDataParser(icu_56::LocDataParser	*__hidden this)
		public ??1LocDataParser@icu_56@@QAE@XZ
??1LocDataParser@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+112p
					; __unwindfunclet$?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z$0+3j

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1LocDataParser@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4270h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringLocalizationInfo::~StringLocalizationInfo(icu_56::StringLocalizationInfo *__hidden this)
		public ??1StringLocalizationInfo@icu_56@@UAE@XZ
??1StringLocalizationInfo@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::StringLocalizationInfo::`scalar deleting destructor'(uint)+26p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7StringLocalizationInfo@icu_56@@6B@ ; const icu_56::StringLocalizationInfo::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_14], ecx
		jmp	short loc_42B0
; ---------------------------------------------------------------------------

loc_42A7:				; CODE XREF: icu_56::StringLocalizationInfo::~StringLocalizationInfo(void):loc_42CEj
		mov	eax, [ebp+var_14]
		add	eax, 4
		mov	[ebp+var_14], eax

loc_42B0:				; CODE XREF: icu_56::StringLocalizationInfo::~StringLocalizationInfo(void)+35j
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax], 0
		jz	short loc_42D0
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax], 0
		jz	short loc_42CE
		mov	eax, [ebp+var_14]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_42CE:				; CODE XREF: icu_56::StringLocalizationInfo::~StringLocalizationInfo(void)+4Ej
		jmp	short loc_42A7
; ---------------------------------------------------------------------------

loc_42D0:				; CODE XREF: icu_56::StringLocalizationInfo::~StringLocalizationInfo(void)+46j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_42E8
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_42E8:				; CODE XREF: icu_56::StringLocalizationInfo::~StringLocalizationInfo(void)+67j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	short loc_4300
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_4300:				; CODE XREF: icu_56::StringLocalizationInfo::~StringLocalizationInfo(void)+7Fj
		mov	ecx, [ebp+var_8] ; this
		call	??1LocalizationInfo@icu_56@@MAE@XZ ; icu_56::LocalizationInfo::~LocalizationInfo(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1StringLocalizationInfo@icu_56@@UAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 431Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::StringLocalizationInfo::getRuleSetName(icu_56::StringLocalizationInfo *this, int)
		public ?getRuleSetName@StringLocalizationInfo@icu_56@@UBEPB_WH@Z
?getRuleSetName@StringLocalizationInfo@icu_56@@UBEPB_WH@Z proc near
					; DATA XREF: .rdata:000034D4o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_4370
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+arg_0], eax
		jge	short loc_4370
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_0]
		mov	eax, [edx+eax*4]
		jmp	short loc_4372
; ---------------------------------------------------------------------------

loc_4370:				; CODE XREF: icu_56::StringLocalizationInfo::getRuleSetName(int)+27j
					; icu_56::StringLocalizationInfo::getRuleSetName(int)+42j
		xor	eax, eax

loc_4372:				; CODE XREF: icu_56::StringLocalizationInfo::getRuleSetName(int)+52j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getRuleSetName@StringLocalizationInfo@icu_56@@UBEPB_WH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4388h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::StringLocalizationInfo::getLocaleName(icu_56::StringLocalizationInfo *this,	int)
		public ?getLocaleName@StringLocalizationInfo@icu_56@@UBEPB_WH@Z
?getLocaleName@StringLocalizationInfo@icu_56@@UBEPB_WH@Z proc near
					; DATA XREF: .rdata:000034DCo

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_43DD
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+arg_0], eax
		jge	short loc_43DD
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_0]
		mov	eax, [ecx+edx*4+4]
		mov	eax, [eax]
		jmp	short loc_43DF
; ---------------------------------------------------------------------------

loc_43DD:				; CODE XREF: icu_56::StringLocalizationInfo::getLocaleName(int)+27j
					; icu_56::StringLocalizationInfo::getLocaleName(int)+42j
		xor	eax, eax

loc_43DF:				; CODE XREF: icu_56::StringLocalizationInfo::getLocaleName(int)+53j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLocaleName@StringLocalizationInfo@icu_56@@UBEPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::StringLocalizationInfo::getDisplayName(icu_56::StringLocalizationInfo *this, int, int)
		public ?getDisplayName@StringLocalizationInfo@icu_56@@UBEPB_WHH@Z
?getDisplayName@StringLocalizationInfo@icu_56@@UBEPB_WHH@Z proc	near
					; DATA XREF: .rdata:000034E0o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_4473
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+arg_0], eax
		jge	short loc_4473
		cmp	[ebp+arg_4], 0
		jl	short loc_4473
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+arg_4], eax
		jge	short loc_4473
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_0]
		mov	eax, [ecx+edx*4+4]
		mov	ecx, [ebp+arg_4]
		mov	eax, [eax+ecx*4+4]
		jmp	short loc_4475
; ---------------------------------------------------------------------------

loc_4473:				; CODE XREF: icu_56::StringLocalizationInfo::getDisplayName(int,int)+27j
					; icu_56::StringLocalizationInfo::getDisplayName(int,int)+42j ...
		xor	eax, eax

loc_4475:				; CODE XREF: icu_56::StringLocalizationInfo::getDisplayName(int,int)+79j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getDisplayName@StringLocalizationInfo@icu_56@@UBEPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 448Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::RuleBasedNumberFormat *this, const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *, const	struct icu_56::Locale *, struct	UParseError *Dst, enum UErrorCode *)
		public ??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z	proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
Dst		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0NumberFormat@icu_56@@IAE@XZ ; icu_56::NumberFormat::NumberFormat(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedNumberFormat@icu_56@@6B@ ;	const icu_56::RuleBasedNumberFormat::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+164h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+168h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+16Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+170h], 0
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_14]
		add	ecx, 174h	; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+240h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+244h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+248h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+24Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+250h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+254h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+258h], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Dh], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Eh], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2A0h], 0
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+Dst]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		call	?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const &,UParseError	&,UErrorCode &)
		add	esp, 0Ch
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+Dst]
		push	ecx		; Dst
		mov	edx, [ebp+var_20]
		push	edx		; struct icu_56::LocalizationInfo *
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString	const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4634h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00004754o
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormat@icu_56@@UAE@XZ ; icu_56::NumberFormat::~NumberFormat(void)
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000475Co
		mov	ecx, [ebp-14h]
		add	ecx, 174h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00004764o
		mov	ecx, [ebp-14h]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString	const &,icu_56::UnicodeString const &,icu_56::Locale const &,UParseError &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 468Ch
		dd offset ??_R4RuleBasedNumberFormat@icu_56@@6B@ ; const icu_56::RuleBasedNumberFormat::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7RuleBasedNumberFormat@icu_56@@6B@
; const	icu_56::RuleBasedNumberFormat::`vftable'
??_7RuleBasedNumberFormat@icu_56@@6B@ dd offset	??_ERuleBasedNumberFormat@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString	const &,icu_56::UnicodeString const &,icu_56::Locale const &,UParseError &,UErrorCode &)+54o
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString const &,icu_56::UnicodeString const &,UParseError &,UErrorCode &)+54o ...
					; icu_56::RuleBasedNumberFormat::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@RuleBasedNumberFormat@icu_56@@UBEPAXXZ ; icu_56::RuleBasedNumberFormat::getDynamicClassID(void)
		dd offset ??8RuleBasedNumberFormat@icu_56@@UBECABVFormat@1@@Z ;	icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)
		dd offset ?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ ; icu_56::RuleBasedNumberFormat::clone(void)
		dd offset ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@ABVFormattable@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::format(icu_56::Formattable const &,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode	&)
		dd offset ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@ABVFormattable@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::format(icu_56::Formattable const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode	&)
		dd offset ?parseObject@NumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z ; icu_56::NumberFormat::parseObject(icu_56::UnicodeString const &,icu_56::Formattable	&,icu_56::ParsePosition	&)
		dd offset ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z	; icu_56::NumberFormat::format(icu_56::DigitList const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)
		dd offset ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z	; icu_56::NumberFormat::format(icu_56::DigitList const &,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)
		dd offset ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::format(icu_56::StringPiece const &,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode	&)
		dd offset ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::format(__int64,icu_56::UnicodeString	&,icu_56::FieldPositionIterator	*,UErrorCode &)
		dd offset ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::format(__int64,icu_56::UnicodeString	&,icu_56::FieldPosition	&,UErrorCode &)
		dd offset ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@@Z ; icu_56::RuleBasedNumberFormat::format(__int64,icu_56::UnicodeString &,icu_56::FieldPosition &)
		dd offset ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::format(int,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode	&)
		dd offset ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode	&)
		dd offset ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@@Z ; icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &)
		dd offset ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::format(double,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)
		dd offset ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::format(double,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)
		dd offset ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@@Z ; icu_56::RuleBasedNumberFormat::format(double,icu_56::UnicodeString	&,icu_56::FieldPosition	&)
		dd offset ?parse@NumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,UErrorCode &)
		dd offset ?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z ; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const	&,icu_56::Formattable &,icu_56::ParsePosition &)
		dd offset ?parseCurrency@NumberFormat@icu_56@@UBEPAVCurrencyAmount@2@ABVUnicodeString@2@AAVParsePosition@2@@Z ;	icu_56::NumberFormat::parseCurrency(icu_56::UnicodeString const	&,icu_56::ParsePosition	&)
		dd offset ?setParseIntegerOnly@NumberFormat@icu_56@@UAEXC@Z ; icu_56::NumberFormat::setParseIntegerOnly(signed char)
		dd offset ?setLenient@RuleBasedNumberFormat@icu_56@@UAEXC@Z ; icu_56::RuleBasedNumberFormat::setLenient(signed char)
		dd offset ?isLenient@RuleBasedNumberFormat@icu_56@@UBECXZ ; icu_56::RuleBasedNumberFormat::isLenient(void)
		dd offset ?setGroupingUsed@NumberFormat@icu_56@@UAEXC@Z	; icu_56::NumberFormat::setGroupingUsed(signed char)
		dd offset ?setMaximumIntegerDigits@NumberFormat@icu_56@@UAEXH@Z	; icu_56::NumberFormat::setMaximumIntegerDigits(int)
		dd offset ?setMinimumIntegerDigits@NumberFormat@icu_56@@UAEXH@Z	; icu_56::NumberFormat::setMinimumIntegerDigits(int)
		dd offset ?setMaximumFractionDigits@NumberFormat@icu_56@@UAEXH@Z ; icu_56::NumberFormat::setMaximumFractionDigits(int)
		dd offset ?setMinimumFractionDigits@NumberFormat@icu_56@@UAEXH@Z ; icu_56::NumberFormat::setMinimumFractionDigits(int)
		dd offset ?setCurrency@NumberFormat@icu_56@@UAEXPB_WAAW4UErrorCode@@@Z ; icu_56::NumberFormat::setCurrency(wchar_t const *,UErrorCode &)
		dd offset ?setContext@RuleBasedNumberFormat@icu_56@@UAEXW4UDisplayContext@@AAW4UErrorCode@@@Z ;	icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)
		dd offset ?getContext@NumberFormat@icu_56@@UBE?AW4UDisplayContext@@W4UDisplayContextType@@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::getContext(UDisplayContextType,UErrorCode &)
		dd offset ?getEffectiveCurrency@NumberFormat@icu_56@@MBEXPA_WAAW4UErrorCode@@@Z	; icu_56::NumberFormat::getEffectiveCurrency(wchar_t *,UErrorCode &)
		dd offset ?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ ; icu_56::RuleBasedNumberFormat::getRules(void)
		dd offset ?getNumberOfRuleSetNames@RuleBasedNumberFormat@icu_56@@UBEHXZ	; icu_56::RuleBasedNumberFormat::getNumberOfRuleSetNames(void)
		dd offset ?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z ; icu_56::RuleBasedNumberFormat::getRuleSetName(int)
		dd offset ?getNumberOfRuleSetDisplayNameLocales@RuleBasedNumberFormat@icu_56@@UBEHXZ ; icu_56::RuleBasedNumberFormat::getNumberOfRuleSetDisplayNameLocales(void)
		dd offset ?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z	; icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)
		dd offset ?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z ; icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(icu_56::UnicodeString const &,icu_56::Locale const &)
		dd offset ?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z ; icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)
		dd offset ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@NABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::format(double,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)
		dd offset ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@_JABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::format(__int64,icu_56::UnicodeString	const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)
		dd offset ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@HABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)
		dd offset ?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)
		dd offset ?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ	; icu_56::RuleBasedNumberFormat::getDefaultRuleSetName(void)
		dd offset ?adoptDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXPAVDecimalFormatSymbols@2@@Z ; icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)
		dd offset ?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z ; icu_56::RuleBasedNumberFormat::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols	const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4750h
__unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004770o
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$2
__ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z dd	19930522h, 3
					; DATA XREF: __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 478Ch
		public ??_R4RuleBasedNumberFormat@icu_56@@6B@
; const	icu_56::RuleBasedNumberFormat::`RTTI Complete Object Locator'
??_R4RuleBasedNumberFormat@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:0000468Co
		dd offset ??_R0?AVRuleBasedNumberFormat@icu_56@@@8 ; icu_56::RuleBasedNumberFormat `RTTI Type Descriptor'
		dd offset ??_R3RuleBasedNumberFormat@icu_56@@8 ; icu_56::RuleBasedNumberFormat::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 47A0h
		public ??_R0?AVRuleBasedNumberFormat@icu_56@@@8
; class	icu_56::RuleBasedNumberFormat `RTTI Type Descriptor'
??_R0?AVRuleBasedNumberFormat@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00004798o
					; .rdata$r:icu_56::RuleBasedNumberFormat::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avrulebasedn	db '.?AVRuleBasedNumberFormat@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 47CCh
		public ??_R3RuleBasedNumberFormat@icu_56@@8
; icu_56::RuleBasedNumberFormat::`RTTI Class Hierarchy Descriptor'
??_R3RuleBasedNumberFormat@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:0000479Co
					; .rdata$r:0000480Co
		dd 5
		dd offset ??_R2RuleBasedNumberFormat@icu_56@@8 ; icu_56::RuleBasedNumberFormat::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 47DCh
		public ??_R2RuleBasedNumberFormat@icu_56@@8
; icu_56::RuleBasedNumberFormat::`RTTI Base Class Array'
??_R2RuleBasedNumberFormat@icu_56@@8 dd	offset ??_R1A@?0A@EA@RuleBasedNumberFormat@icu_56@@8
					; DATA XREF: .rdata$r:000047D8o
					; icu_56::RuleBasedNumberFormat::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@NumberFormat@icu_56@@8 ; icu_56::NumberFormat::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Format@icu_56@@8 ; icu_56::Format::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 47F4h
		public ??_R1A@?0A@EA@RuleBasedNumberFormat@icu_56@@8
; icu_56::RuleBasedNumberFormat::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@RuleBasedNumberFormat@icu_56@@8 dd offset	??_R0?AVRuleBasedNumberFormat@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::RuleBasedNumberFormat::`RTTI Base	Class Array'o
					; icu_56::RuleBasedNumberFormat	`RTTI Type Descriptor'
		dd 4, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3RuleBasedNumberFormat@icu_56@@8 ; icu_56::RuleBasedNumberFormat::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4810h
		public ??_R1A@?0A@EA@NumberFormat@icu_56@@8
; icu_56::NumberFormat::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@NumberFormat@icu_56@@8 dd	offset ??_R0?AVNumberFormat@icu_56@@@8
					; DATA XREF: .rdata$r:000047E0o
					; .rdata$r:icu_56::NumberFormat::`RTTI Base Class Array'o
					; icu_56::NumberFormat `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3NumberFormat@icu_56@@8 ;	icu_56::NumberFormat::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 482Ch
		public ??_R0?AVNumberFormat@icu_56@@@8
; class	icu_56::NumberFormat `RTTI Type	Descriptor'
??_R0?AVNumberFormat@icu_56@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::NumberFormat::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avnumberfo_0	db '.?AVNumberFormat@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4850h
		public ??_R3NumberFormat@icu_56@@8
; icu_56::NumberFormat::`RTTI Class Hierarchy Descriptor'
??_R3NumberFormat@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00004828o
		dd 4
		dd offset ??_R2NumberFormat@icu_56@@8 ;	icu_56::NumberFormat::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4860h
		public ??_R2NumberFormat@icu_56@@8
; icu_56::NumberFormat::`RTTI Base Class Array'
??_R2NumberFormat@icu_56@@8 dd offset ??_R1A@?0A@EA@NumberFormat@icu_56@@8
					; DATA XREF: .rdata$r:0000485Co
					; icu_56::NumberFormat::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Format@icu_56@@8 ; icu_56::Format::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4874h
		public ??_R1A@?0A@EA@Format@icu_56@@8
; icu_56::Format::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Format@icu_56@@8 dd offset ??_R0?AVFormat@icu_56@@@8
					; DATA XREF: .rdata$r:000047E4o
					; .rdata$r:00004864o ...
					; icu_56::Format `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Format@icu_56@@8	; icu_56::Format::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4890h
		public ??_R0?AVFormat@icu_56@@@8
; class	icu_56::Format `RTTI Type Descriptor'
??_R0?AVFormat@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::Format::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avformat@icu	db '.?AVFormat@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 48ACh
		public ??_R3Format@icu_56@@8
; icu_56::Format::`RTTI	Class Hierarchy	Descriptor'
??_R3Format@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000488Co
		dd 3
		dd offset ??_R2Format@icu_56@@8	; icu_56::Format::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 48BCh
		public ??_R2Format@icu_56@@8
; icu_56::Format::`RTTI	Base Class Array'
??_R2Format@icu_56@@8 dd offset	??_R1A@?0A@EA@Format@icu_56@@8
					; DATA XREF: .rdata$r:000048B8o
					; icu_56::Format::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 48CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::RuleBasedNumberFormat *this, const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *, struct UParseError *Dst, enum	UErrorCode *)
		public ??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z
??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0NumberFormat@icu_56@@IAE@XZ ; icu_56::NumberFormat::NumberFormat(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedNumberFormat@icu_56@@6B@ ;	const icu_56::RuleBasedNumberFormat::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+164h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+168h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+16Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+170h], 0
		mov	esi, esp
		call	dword ptr ds:__imp_?getDefault@Locale@icu_56@@SAABV12@XZ ; icu_56::Locale::getDefault(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_14]
		add	ecx, 174h	; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+240h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+244h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+248h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+24Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+250h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+254h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+258h], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Dh], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Eh], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2A0h], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+Dst]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		call	?create@StringLocalizationInfo@icu_56@@SAPAV12@ABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const &,UParseError	&,UErrorCode &)
		add	esp, 0Ch
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+Dst]
		push	ecx		; Dst
		mov	edx, [ebp+var_20]
		push	edx		; struct icu_56::LocalizationInfo *
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString	const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4A80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00004ADCo
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormat@icu_56@@UAE@XZ ; icu_56::NumberFormat::~NumberFormat(void)
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00004AE4o
		mov	ecx, [ebp-14h]
		add	ecx, 174h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00004AECo
		mov	ecx, [ebp-14h]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString	const &,icu_56::UnicodeString const &,UParseError &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4AD8h
__unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004AF8o
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z$2
__ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::RuleBasedNumberFormat *this, const struct icu_56::UnicodeString *, struct icu_56::LocalizationInfo *, const struct icu_56::Locale *, struct UParseError *Dst, enum UErrorCode *)
		public ??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
Dst		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0NumberFormat@icu_56@@IAE@XZ ; icu_56::NumberFormat::NumberFormat(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedNumberFormat@icu_56@@6B@ ;	const icu_56::RuleBasedNumberFormat::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+164h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+168h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+16Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+170h], 0
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_14]
		add	ecx, 174h	; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+240h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+244h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+248h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+24Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+250h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+254h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+258h], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Dh], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Eh], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2A0h], 0
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+Dst]
		push	ecx		; Dst
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::LocalizationInfo *
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString	const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4CA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00004D00o
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormat@icu_56@@UAE@XZ ; icu_56::NumberFormat::~NumberFormat(void)
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00004D08o
		mov	ecx, [ebp-14h]
		add	ecx, 174h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00004D10o
		mov	ecx, [ebp-14h]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString	const &,icu_56::LocalizationInfo *,icu_56::Locale const	&,UParseError &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4CFCh
__unwindtable$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004D1Co
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$0
		align 8
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$2
__ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z dd 19930522h,	3
					; DATA XREF: __ehhandler$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0RuleBasedNumberFormat@icu_56@@AAE@ABVUnicodeString@1@PAVLocalizationInfo@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::RuleBasedNumberFormat *this, const struct icu_56::UnicodeString *, struct UParseError *Dst, enum UErrorCode *)
		public ??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z
??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z proc	near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
Dst		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0NumberFormat@icu_56@@IAE@XZ ; icu_56::NumberFormat::NumberFormat(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedNumberFormat@icu_56@@6B@ ;	const icu_56::RuleBasedNumberFormat::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+164h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+168h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+16Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+170h], 0
		mov	esi, esp
		call	dword ptr ds:__imp_?getDefault@Locale@icu_56@@SAABV12@XZ ; icu_56::Locale::getDefault(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_14]
		add	ecx, 174h	; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+240h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+244h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+248h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+24Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+250h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+254h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+258h], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Dh], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Eh], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2A0h], 0
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+Dst]
		push	ecx		; Dst
		push	0		; struct icu_56::LocalizationInfo *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString	const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4ED4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00004F30o
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormat@icu_56@@UAE@XZ ; icu_56::NumberFormat::~NumberFormat(void)
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00004F38o
		mov	ecx, [ebp-14h]
		add	ecx, 174h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00004F40o
		mov	ecx, [ebp-14h]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString	const &,UParseError &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4F2Ch
__unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004F4Co
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$0
		align 8
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$2
__ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z	dd 19930522h, 3
					; DATA XREF: __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::RuleBasedNumberFormat *this, const struct icu_56::UnicodeString *, const struct icu_56::Locale	*, struct UParseError *Dst, enum UErrorCode *)
		public ??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0NumberFormat@icu_56@@IAE@XZ ; icu_56::NumberFormat::NumberFormat(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedNumberFormat@icu_56@@6B@ ;	const icu_56::RuleBasedNumberFormat::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+164h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+168h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+16Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+170h], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_14]
		add	ecx, 174h	; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+240h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+244h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+248h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+24Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+250h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+254h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+258h], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Dh], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Eh], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2A0h], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+Dst]
		push	ecx		; Dst
		push	0		; struct icu_56::LocalizationInfo *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString	const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 50F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00005154o
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormat@icu_56@@UAE@XZ ; icu_56::NumberFormat::~NumberFormat(void)
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000515Co
		mov	ecx, [ebp-14h]
		add	ecx, 174h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00005164o
		mov	ecx, [ebp-14h]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z proc	near
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString	const &,icu_56::Locale const &,UParseError &,UErrorCode	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5150h
__unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00005170o
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$2
__ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 518Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(enum	icu_56::URBNFRuleSetTag, class icu_56::Locale const &, enum  UErrorCode	&)
		public ??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z
??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z	proc near

var_20C		= dword	ptr -20Ch
var_208		= dword	ptr -208h
var_200		= byte ptr -200h
var_F8		= byte ptr -0F8h
var_A8		= byte ptr -0A8h
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 200h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_20C]
		mov	ecx, 80h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	ecx, [ebp+var_18] ; this
		call	??0NumberFormat@icu_56@@IAE@XZ ; icu_56::NumberFormat::NumberFormat(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax], offset	??_7RuleBasedNumberFormat@icu_56@@6B@ ;	const icu_56::RuleBasedNumberFormat::`vftable'
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+164h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+168h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+16Ch], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+170h], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_18]
		add	ecx, 174h	; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+240h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+244h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+248h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+24Ch], 0
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+250h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+254h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+258h], 0
		mov	ecx, [ebp+var_18]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+29Ch], 0
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+29Dh], 0
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+29Eh], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+2A0h], 0
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_52F6
		jmp	loc_5542
; ---------------------------------------------------------------------------

loc_52F6:				; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+163j
		mov	[ebp+var_24], offset ??_C@_09BLGNHOH@RBNFRules?$AA@ ; "RBNFRules"
		mov	[ebp+var_30], offset ??_C@_00CNPNBAHC@?$AA@ ; `string'
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_208], eax
		cmp	[ebp+var_208], 3 ; switch 4 cases
		ja	short loc_5347	; jumptable 0000531C default case
		mov	ecx, [ebp+var_208]
		jmp	ds:$LN26[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN10_0:				; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+190j
					; DATA XREF: .text:$LN26o
		mov	[ebp+var_30], offset ??_C@_0O@NKPJGHFM@SpelloutRules?$AA@ ; jumptable 0000531C case 0
		jmp	short loc_5355
; ---------------------------------------------------------------------------

$LN9:					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+190j
					; DATA XREF: .text:$LN26o
		mov	[ebp+var_30], offset ??_C@_0N@OAIEFJAM@OrdinalRules?$AA@ ; jumptable 0000531C case 1
		jmp	short loc_5355
; ---------------------------------------------------------------------------

$LN8_0:					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+190j
					; DATA XREF: .text:$LN26o
		mov	[ebp+var_30], offset ??_C@_0O@BOALFNGC@DurationRules?$AA@ ; jumptable 0000531C case 2
		jmp	short loc_5355
; ---------------------------------------------------------------------------

$LN7:					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+190j
					; DATA XREF: .text:$LN26o
		mov	[ebp+var_30], offset ??_C@_0BF@FLHJEGCN@NumberingSystemRules?$AA@ ; jumptable 0000531C case 3
		jmp	short loc_5355
; ---------------------------------------------------------------------------

loc_5347:				; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+188j
		mov	eax, [ebp+arg_8] ; jumptable 0000531C default case
		mov	dword ptr [eax], 1
		jmp	loc_5542
; ---------------------------------------------------------------------------

loc_5355:				; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+19Ej
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+1A7j ...
		mov	[ebp+var_3C], 0
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_18]
		add	ecx, 174h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_?getName@Locale@icu_56@@QBEPBDXZ ; icu_56::Locale::getName(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		push	offset ??_C@_0O@KPEDDPEP@icudt56l?9rbnf?$AA@ ; "icudt56l-rbnf"
		call	_ures_open_56
		add	esp, 0Ch
		mov	[ebp+var_48], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_5536
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_48]
		push	ecx
		call	_ures_getLocaleByType_56
		add	esp, 0Ch
		push	eax		; char *
		mov	edx, [ebp+arg_8]
		push	edx
		push	1
		mov	eax, [ebp+var_48]
		push	eax
		call	_ures_getLocaleByType_56
		add	esp, 0Ch
		push	eax		; char *
		mov	ecx, [ebp+var_18] ; this
		call	?setLocaleIDs@Format@icu_56@@IAEXPBD0@Z	; icu_56::Format::setLocaleIDs(char const *,char const *)
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_24]
		push	ecx
		mov	edx, [ebp+var_48]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	[ebp+var_54], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_540A
		mov	eax, [ebp+var_48]
		push	eax
		call	_ures_close_56
		add	esp, 4

loc_540A:				; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+270j
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+var_54]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	[ebp+var_60], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5455
		mov	eax, [ebp+var_54]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_48]
		push	eax
		call	_ures_close_56
		add	esp, 4
		jmp	loc_5542
; ---------------------------------------------------------------------------

loc_5455:				; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+2AAj
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 3

loc_546E:				; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+359j
		mov	eax, [ebp+var_60]
		push	eax
		call	_ures_hasNext_56
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_54E7
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_60]
		push	ecx
		lea	edx, [ebp+var_200]
		push	edx
		call	?ures_getNextUnicodeString@icu_56@@YA?AVUnicodeString@1@PAUUResourceBundle@@PAPBDPAW4UErrorCode@@@Z ; icu_56::ures_getNextUnicodeString(UResourceBundle	*,char const * *,UErrorCode *)
		add	esp, 10h
		mov	[ebp+var_208], eax
		mov	eax, [ebp+var_208]
		mov	[ebp+var_20C], eax
		mov	byte ptr [ebp+var_4], 4
		mov	esi, esp
		mov	ecx, [ebp+var_20C]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 3
		mov	esi, esp
		lea	ecx, [ebp+var_200] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_546E
; ---------------------------------------------------------------------------

loc_54E7:				; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+2F3j
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_F8]
		push	ecx		; Dst
		mov	edx, [ebp+var_3C]
		push	edx		; struct icu_56::LocalizationInfo *
		lea	eax, [ebp+var_A8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString	const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode &)
		mov	eax, [ebp+var_60]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_54]
		push	eax
		call	_ures_close_56
		add	esp, 4
		mov	byte ptr [ebp+var_4], 2
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5536:				; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+210j
		mov	eax, [ebp+var_48]
		push	eax
		call	_ures_close_56
		add	esp, 4

loc_5542:				; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+165j
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+1C4j ...
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_18]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN25
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 20Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
$LN25		dd 2			; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+3C4o
		dd offset $LN24_0
$LN24_0		dd 0FFFFFF58h, 40h	; DATA XREF: .text:0000558Co
		dd offset $LN21_1	; "desc"
		db 8, 0FFh
		dw 0FFFFh
		dd offset ?collate@?$_Locbase@H@std@@2HB ; int const std::_Locbase<int>::collate
		dd offset $LN22_0	; "perror"
$LN22_0		db 'perror',0           ; DATA XREF: .text:000055A4o
$LN21_1		db 'desc',0             ; DATA XREF: .text:00005598o
$LN26		dd offset $LN10_0	; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+190r
		dd offset $LN9		; jump table for switch	statement
		dd offset $LN8_0
		dd offset $LN7
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 55C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000056E0o
		mov	ecx, [ebp-18h]	; this
		jmp	??1NumberFormat@icu_56@@UAE@XZ ; icu_56::NumberFormat::~NumberFormat(void)
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:000056E8o
		mov	ecx, [ebp-18h]
		add	ecx, 174h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:000056F0o
		mov	ecx, [ebp-18h]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:000056F8o
		mov	esi, esp
		lea	ecx, [ebp-0A8h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$4 proc near
					; DATA XREF: .xdata$x:00005700o
		mov	esi, esp
		lea	ecx, [ebp-200h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-210h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5650h
		public ??_C@_0O@KPEDDPEP@icudt56l?9rbnf?$AA@
; `string'
??_C@_0O@KPEDDPEP@icudt56l?9rbnf?$AA@ db 'icudt56l-rbnf',0
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+1EDo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5660h
		public ??_C@_0BF@FLHJEGCN@NumberingSystemRules?$AA@
; `string'
??_C@_0BF@FLHJEGCN@NumberingSystemRules?$AA@ db	'NumberingSystemRules',0
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &):$LN7o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5678h
		public ??_C@_0O@BOALFNGC@DurationRules?$AA@
; `string'
??_C@_0O@BOALFNGC@DurationRules?$AA@ db	'DurationRules',0
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &):$LN8_0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5688h
		public ??_C@_0N@OAIEFJAM@OrdinalRules?$AA@
; `string'
??_C@_0N@OAIEFJAM@OrdinalRules?$AA@ db 'OrdinalRules',0
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &):$LN9o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5698h
		public ??_C@_0O@NKPJGHFM@SpelloutRules?$AA@
; `string'
??_C@_0O@NKPJGHFM@SpelloutRules?$AA@ db	'SpelloutRules',0
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &):$LN10_0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 56A8h
		public ??_C@_00CNPNBAHC@?$AA@
; char `string'
??_C@_00CNPNBAHC@?$AA@ db 0		; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+171o
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+6Co ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 56ACh
		public ??_C@_09BLGNHOH@RBNFRules?$AA@
; `string'
??_C@_09BLGNHOH@RBNFRules?$AA@ db 'RBNFRules',0
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &):loc_52F6o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 56B8h
__ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z dd	19930522h, 5
					; DATA XREF: __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000056C0o
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$0
		align 8
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$2
		dd 2
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$3
		dd 3
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@W4URBNFRuleSetTag@1@ABVLocale@1@AAW4UErrorCode@@@Z$4
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5704h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	icu_56::UnicodeString __cdecl icu_56::ures_getNextUnicodeString(struct UResourceBundle *, char const * *, enum	UErrorCode *)
		public ?ures_getNextUnicodeString@icu_56@@YA?AVUnicodeString@1@PAUUResourceBundle@@PAPBDPAW4UErrorCode@@@Z
?ures_getNextUnicodeString@icu_56@@YA?AVUnicodeString@1@PAUUResourceBundle@@PAPBDPAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+306p

var_E4		= byte ptr -0E4h
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_E0], 0
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		lea	edx, [ebp+var_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		call	_ures_getNextString_56
		add	esp, 10h
		mov	[ebp+var_14], eax
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		push	ecx		; wchar_t *
		push	1		; signed __int8
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_E0]
		or	edx, 1
		mov	[ebp+var_E0], edx
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_getNextUnicodeString@icu_56@@YA?AVUnicodeString@1@PAUUResourceBundle@@PAPBDPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_0		dd 1			; DATA XREF: icu_56::ures_getNextUnicodeString(UResourceBundle *,char const * *,UErrorCode *)+7Co
		dd offset $LN6
$LN6		dd 0FFFFFFF8h, 4	; DATA XREF: .text:000057A8o
		dd offset $LN5
$LN5		dd 6E656Ch		; DATA XREF: .text:000057B4o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 57BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::RuleBasedNumberFormat *this, const struct icu_56::RuleBasedNumberFormat *)
		public ??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z
??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::clone(void)+79p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::NumberFormat *
		mov	ecx, [ebp+var_14] ; this
		call	??0NumberFormat@icu_56@@IAE@ABV01@@Z ; icu_56::NumberFormat::NumberFormat(icu_56::NumberFormat const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedNumberFormat@icu_56@@6B@ ;	const icu_56::RuleBasedNumberFormat::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+164h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+168h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+16Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+170h], 0
		mov	eax, [ebp+arg_0]
		add	eax, 174h
		mov	esi, esp
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_14]
		add	ecx, 174h	; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+240h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+244h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+248h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+24Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+250h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+254h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+258h], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Dh], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+29Eh], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2A0h], 0
		mov	eax, [ebp+arg_0]
		push	eax		; icu_56::RuleBasedNumberFormat	*
		mov	ecx, [ebp+var_14]
		call	??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 594Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z$0	proc near
					; DATA XREF: .xdata$x:000059A8o
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormat@icu_56@@UAE@XZ ; icu_56::NumberFormat::~NumberFormat(void)
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z$1	proc near
					; DATA XREF: .xdata$x:000059B0o
		mov	ecx, [ebp-14h]
		add	ecx, 174h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z$1	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z$2	proc near
					; DATA XREF: .xdata$x:000059B8o
		mov	ecx, [ebp-14h]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z$2	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::RuleBasedNumberFormat	const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 59A4h
__unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000059C4o
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z$0
		align 10h
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z$1
		dd 1
		dd offset __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z$2
__ehfuncinfo$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 59E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat *)
		public ??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z
??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z proc	near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::RuleBasedNumberFormat	const &)+15Dp

var_188		= dword	ptr -188h
var_184		= dword	ptr -184h
var_17C		= byte ptr -17Ch
var_74		= byte ptr -74h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 17Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_188]
		mov	ecx, 5Fh ; '_'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_18]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_5A35
		mov	eax, [ebp+var_18]
		jmp	loc_5BF3
; ---------------------------------------------------------------------------

loc_5A35:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+4Bj
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_18]
		call	??4NumberFormat@icu_56@@IAEAAV01@ABV01@@Z ; icu_56::NumberFormat::operator=(icu_56::NumberFormat const &)
		mov	[ebp+var_24], 0
		mov	ecx, [ebp+var_18] ; this
		call	?dispose@RuleBasedNumberFormat@icu_56@@AAEXXZ ;	icu_56::RuleBasedNumberFormat::dispose(void)
		mov	eax, [ebp+arg_0]
		add	eax, 174h
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_18]
		add	ecx, 174h
		call	dword ptr ds:__imp_??4Locale@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::Locale::operator=(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+250h]
		mov	[eax+250h], dl
		mov	ecx, [ebp+arg_0] ; this
		call	?getDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@ABEPBVDecimalFormatSymbols@2@XZ ; icu_56::RuleBasedNumberFormat::getDecimalFormatSymbols(void)
		mov	esi, esp
		push	eax
		mov	eax, [ebp+var_18]
		mov	edx, [eax]
		mov	ecx, [ebp+var_18]
		mov	eax, [edx+0BCh]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+258h], 0
		jz	short loc_5AC7
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+258h]	; this
		call	?ref@LocalizationInfo@icu_56@@QAEPAV12@XZ ; icu_56::LocalizationInfo::ref(void)
		mov	[ebp+var_184], eax
		jmp	short loc_5AD1
; ---------------------------------------------------------------------------

loc_5AC7:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+CFj
		mov	[ebp+var_184], 0

loc_5AD1:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+E5j
		lea	edx, [ebp+var_24]
		push	edx		; enum UErrorCode *
		lea	eax, [ebp+var_74]
		push	eax		; Dst
		mov	ecx, [ebp+var_184]
		push	ecx		; struct icu_56::LocalizationInfo *
		mov	edx, [ebp+arg_0]
		add	edx, 25Ch
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString	const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode &)
		mov	esi, esp
		lea	eax, [ebp+var_24]
		push	eax
		mov	edi, esp
		lea	ecx, [ebp+var_17C]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+0B4h]
		call	edx
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_184], eax
		mov	eax, [ebp+var_184]
		mov	[ebp+var_188], eax
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_188]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	eax, [edx]
		mov	ecx, [ebp+var_18]
		mov	edx, [eax+0B0h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_17C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+29Ch]
		mov	[eax+29Ch], dl
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+29Dh]
		mov	[eax+29Dh], dl
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+29Eh]
		mov	[eax+29Eh], dl
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+2A0h], 0
		jz	short loc_5BD7
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2A0h]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+2A0h]
		mov	edx, [edx]
		mov	esi, esp
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_184], eax
		jmp	short loc_5BE1
; ---------------------------------------------------------------------------

loc_5BD7:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+1CBj
		mov	[ebp+var_184], 0

loc_5BE1:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+1F5j
		mov	ecx, [ebp+var_18]
		mov	edx, [ebp+var_184]
		mov	[ecx+2A0h], edx
		mov	eax, [ebp+var_18]

loc_5BF3:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+50j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 188h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN13		dd 2			; DATA XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+217o
		dd offset $LN12
$LN12		dd 0FFFFFFDCh, 4	; DATA XREF: .text:00005C34o
		dd offset $LN9_0	; "status"
		dd 0FFFFFF8Ch, 48h
		dd offset $LN10_1	; "perror"
$LN10_1		db 'perror',0           ; DATA XREF: .text:00005C4Co
$LN9_0		db 'status',0           ; DATA XREF: .text:00005C40o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5C60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00005CA4o
		mov	esi, esp
		lea	ecx, [ebp-17Ch]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-18Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5CA0h
__unwindtable$??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005CB0o
		dd offset __unwindfunclet$??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z+1Eo
		dd offset __unwindtable$??4RuleBasedNumberFormat@icu_56@@QAEAAV01@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5CCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::LocalizationInfo *__thiscall icu_56::LocalizationInfo::ref(icu_56::LocalizationInfo *__hidden this)
		public ?ref@LocalizationInfo@icu_56@@QAEPAV12@XZ
?ref@LocalizationInfo@icu_56@@QAEPAV12@XZ proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+DAp
					; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode	&)+C2p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?ref@LocalizationInfo@icu_56@@QAEPAV12@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5D08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedNumberFormat::~RuleBasedNumberFormat(icu_56::RuleBasedNumberFormat	*__hidden this)
		public ??1RuleBasedNumberFormat@icu_56@@UAE@XZ
??1RuleBasedNumberFormat@icu_56@@UAE@XZ	proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::`scalar deleting destructor'(uint)+26p
					; icu_56::RuleBasedNumberFormat::`vector deleting destructor'(uint)+71p
					; DATA XREF: ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1RuleBasedNumberFormat@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedNumberFormat@icu_56@@6B@ ;	const icu_56::RuleBasedNumberFormat::`vftable'
		mov	[ebp+var_4], 2
		mov	ecx, [ebp+var_14] ; this
		call	?dispose@RuleBasedNumberFormat@icu_56@@AAEXXZ ;	icu_56::RuleBasedNumberFormat::dispose(void)
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 174h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1NumberFormat@icu_56@@UAE@XZ ; icu_56::NumberFormat::~NumberFormat(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1RuleBasedNumberFormat@icu_56@@UAE@XZ	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5DC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1RuleBasedNumberFormat@icu_56@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00005E24o
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormat@icu_56@@UAE@XZ ; icu_56::NumberFormat::~NumberFormat(void)
__unwindfunclet$??1RuleBasedNumberFormat@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1RuleBasedNumberFormat@icu_56@@UAE@XZ$1 proc near
					; DATA XREF: .xdata$x:00005E2Co
		mov	ecx, [ebp-14h]
		add	ecx, 174h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1RuleBasedNumberFormat@icu_56@@UAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1RuleBasedNumberFormat@icu_56@@UAE@XZ$2 proc near
					; DATA XREF: .xdata$x:00005E34o
		mov	ecx, [ebp-14h]
		add	ecx, 25Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1RuleBasedNumberFormat@icu_56@@UAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1RuleBasedNumberFormat@icu_56@@UAE@XZ proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::~RuleBasedNumberFormat(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1RuleBasedNumberFormat@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1RuleBasedNumberFormat@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5E20h
__unwindtable$??1RuleBasedNumberFormat@icu_56@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005E40o
		dd offset __unwindfunclet$??1RuleBasedNumberFormat@icu_56@@UAE@XZ$0
		dd 0
		dd offset __unwindfunclet$??1RuleBasedNumberFormat@icu_56@@UAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??1RuleBasedNumberFormat@icu_56@@UAE@XZ$2
__ehfuncinfo$??1RuleBasedNumberFormat@icu_56@@UAE@XZ dd	19930522h, 3
					; DATA XREF: __ehhandler$??1RuleBasedNumberFormat@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1RuleBasedNumberFormat@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5E5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::Format	*__thiscall icu_56::RuleBasedNumberFormat::clone(icu_56::RuleBasedNumberFormat *__hidden this)
		public ?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ
?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ proc near
					; DATA XREF: .rdata:0000469Co

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		push	2A4h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_5EE2
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::RuleBasedNumberFormat *
		mov	ecx, [ebp+var_E0] ; this
		call	??0RuleBasedNumberFormat@icu_56@@QAE@ABV01@@Z ;	icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::RuleBasedNumberFormat const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_5EEC
; ---------------------------------------------------------------------------

loc_5EE2:				; CODE XREF: icu_56::RuleBasedNumberFormat::clone(void)+6Dj
		mov	[ebp+var_F4], 0

loc_5EEC:				; CODE XREF: icu_56::RuleBasedNumberFormat::clone(void)+84j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_EC]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5F24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ$0 proc near
					; DATA XREF: .xdata$x:00005F60o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ proc	near
					; DATA XREF: icu_56::RuleBasedNumberFormat::clone(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5F5Ch
__unwindtable$?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00005F6Co
		dd offset __unwindfunclet$?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ$0
__ehfuncinfo$?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ+14o
		dd offset __unwindtable$?clone@RuleBasedNumberFormat@icu_56@@UBEPAVFormat@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5F88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::RuleBasedNumberFormat::operator==(class icu_56::Format	const &)const
		public ??8RuleBasedNumberFormat@icu_56@@UBECABVFormat@1@@Z
??8RuleBasedNumberFormat@icu_56@@UBECABVFormat@1@@Z proc near ;	DATA XREF: .rdata:00004698o

var_F8		= dword	ptr -0F8h
var_F4		= dword	ptr -0F4h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F8]
		mov	ecx, 3Eh ; '>'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_5FBA
		mov	al, 1
		jmp	loc_6160
; ---------------------------------------------------------------------------

loc_5FBA:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+29j
		mov	eax, [ebp+arg_0]
		push	eax
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??8type_info@@QBE_NABV0@@Z ;	type_info::operator==(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, al
		test	edx, edx
		jz	loc_615E
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		add	eax, 174h
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 174h
		call	dword ptr ds:__imp_??8Locale@icu_56@@QBECABV01@@Z ; icu_56::Locale::operator==(icu_56::Locale const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_615E
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+250h]
		mov	edx, [ebp+var_14]
		movsx	eax, byte ptr [edx+250h]
		cmp	ecx, eax
		jnz	loc_615E
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+258h], 0
		jnz	short loc_6060
		mov	ecx, [ebp+var_14]
		xor	edx, edx
		cmp	dword ptr [ecx+258h], 0
		setz	dl
		mov	[ebp+var_F4], edx
		jmp	short loc_60BB
; ---------------------------------------------------------------------------

loc_6060:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+BFj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+258h], 0
		jnz	short loc_6078
		mov	[ebp+var_F8], 0
		jmp	short loc_60AF
; ---------------------------------------------------------------------------

loc_6078:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+E2j
		mov	esi, esp
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+258h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+258h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+258h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		mov	[ebp+var_F8], ecx

loc_60AF:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+EEj
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_F4], edx

loc_60BB:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+D6j
		cmp	[ebp+var_F4], 0
		jz	loc_615E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+164h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+164h]
		mov	[ebp+var_2C], ecx
		cmp	[ebp+var_20], 0
		jnz	short loc_60F1
		cmp	[ebp+var_2C], 0
		setz	al
		jmp	short loc_6160
; ---------------------------------------------------------------------------
		jmp	short loc_60FB
; ---------------------------------------------------------------------------

loc_60F1:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+15Cj
		cmp	[ebp+var_2C], 0
		jnz	short loc_60FB
		xor	al, al
		jmp	short loc_6160
; ---------------------------------------------------------------------------

loc_60FB:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+167j
					; icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+16Dj ...
		mov	eax, [ebp+var_20]
		cmp	dword ptr [eax], 0
		jz	short loc_6136
		mov	eax, [ebp+var_2C]
		cmp	dword ptr [eax], 0
		jz	short loc_6136
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+var_20]
		mov	ecx, [edx]
		call	??8NFRuleSet@icu_56@@QBECABV01@@Z ; icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_6136
		mov	eax, [ebp+var_20]
		add	eax, 4
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_2C]
		add	eax, 4
		mov	[ebp+var_2C], eax
		jmp	short loc_60FB
; ---------------------------------------------------------------------------

loc_6136:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+179j
					; icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+181j ...
		mov	eax, [ebp+var_2C]
		cmp	dword ptr [eax], 0
		jnz	short loc_614F
		mov	ecx, [ebp+var_20]
		cmp	dword ptr [ecx], 0
		jnz	short loc_614F
		mov	byte ptr [ebp+var_F4+3], 1
		jmp	short loc_6156
; ---------------------------------------------------------------------------

loc_614F:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+1B4j
					; icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+1BCj
		mov	byte ptr [ebp+var_F4+3], 0

loc_6156:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+1C5j
		mov	al, byte ptr [ebp+var_F4+3]
		jmp	short loc_6160
; ---------------------------------------------------------------------------

loc_615E:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+61j
					; icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+93j ...
		xor	al, al

loc_6160:				; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+2Dj
					; icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+165j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8RuleBasedNumberFormat@icu_56@@UBECABVFormat@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6178h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	icu_56::UnicodeString __thiscall icu_56::RuleBasedNumberFormat::getRules(void)const
		public ?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ
?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ proc near
					; DATA XREF: .rdata:00004718o

var_13C		= byte ptr -13Ch
var_138		= dword	ptr -138h
var_6C		= dword	ptr -6Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 130h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Ch ; 'L'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_138], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+164h], 0
		jz	short loc_621B
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+164h]
		mov	[ebp+var_6C], ecx
		jmp	short loc_6203
; ---------------------------------------------------------------------------

loc_61FA:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRules(void)+A1j
		mov	eax, [ebp+var_6C]
		add	eax, 4
		mov	[ebp+var_6C], eax

loc_6203:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRules(void)+80j
		mov	eax, [ebp+var_6C]
		cmp	dword ptr [eax], 0
		jz	short loc_621B
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_6C]
		mov	ecx, [ecx]	; this
		call	?appendRules@NFRuleSet@icu_56@@QBEXAAVUnicodeString@2@@Z ; icu_56::NFRuleSet::appendRules(icu_56::UnicodeString	&)
		jmp	short loc_61FA
; ---------------------------------------------------------------------------

loc_621B:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRules(void)+72j
					; icu_56::RuleBasedNumberFormat::getRules(void)+91j
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_138]
		or	ecx, 1
		mov	[ebp+var_138], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
$LN13_0		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::getRules(void)+E5o
		dd offset $LN12_0
$LN12_0		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:0000629Co
		dd offset $LN10_2	; "result"
$LN10_2		db 'result',0           ; DATA XREF: .text:000062A8o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 62B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$0 proc	near
					; DATA XREF: .xdata$x:00006324o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$1 proc	near
					; DATA XREF: .xdata$x:0000631Co
		mov	eax, [ebp-138h]
		and	eax, 1
		jz	$LN9_1
		and	dword ptr [ebp-138h], 0FFFFFFFEh
		mov	esi, esp
		mov	ecx, [ebp+8]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN9_1:					; CODE XREF: __unwindfunclet$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$1+9j
		retn
__unwindfunclet$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::getRules(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-140h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6318h
__unwindtable$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006330o
		dd offset __unwindfunclet$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$1
		dd 0
		dd offset __unwindfunclet$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$0
__ehfuncinfo$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ+1Eo
		dd offset __unwindtable$?getRules@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 634Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	icu_56::UnicodeString __thiscall icu_56::RuleBasedNumberFormat::getRuleSetName(int)const
		public ?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z
?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z	proc near
					; DATA XREF: .rdata:00004720o

var_1D8		= byte ptr -1D8h
var_1D4		= dword	ptr -1D4h
var_108		= byte ptr -108h
var_C0		= dword	ptr -0C0h
var_B4		= dword	ptr -0B4h
var_A8		= byte ptr -0A8h
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1D8]
		mov	ecx, 73h ; 's'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax		; int
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_1D4], 0
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+258h], 0
		jz	loc_6437
		mov	esi, esp
		push	0FFFFFFFFh	; int
		mov	edi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+258h]
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+258h]
		mov	edx, [edx]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax		; wchar_t *
		push	1		; signed __int8
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_1D4]
		or	ecx, 1
		mov	[ebp+var_1D4], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	loc_6597
; ---------------------------------------------------------------------------
		jmp	loc_6537
; ---------------------------------------------------------------------------

loc_6437:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetName(int)+59j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+164h], 0
		jz	loc_6537
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 2
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+164h]
		mov	[ebp+var_B4], ecx
		jmp	short loc_6483
; ---------------------------------------------------------------------------

loc_6474:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetName(int):loc_6519j
		mov	eax, [ebp+var_B4]
		add	eax, 4
		mov	[ebp+var_B4], eax

loc_6483:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetName(int)+126j
		mov	eax, [ebp+var_B4]
		cmp	dword ptr [eax], 0
		jz	loc_651E
		mov	eax, [ebp+var_B4]
		mov	ecx, [eax]
		mov	[ebp+var_C0], ecx
		mov	ecx, [ebp+var_C0] ; this
		call	?isPublic@NFRuleSet@icu_56@@QBECXZ ; icu_56::NFRuleSet::isPublic(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_6519
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jnz	short loc_6519
		lea	eax, [ebp+var_A8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_C0] ; this
		call	?getName@NFRuleSet@icu_56@@QBEXAAVUnicodeString@2@@Z ; icu_56::NFRuleSet::getName(icu_56::UnicodeString	&)
		mov	esi, esp
		lea	eax, [ebp+var_A8]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_1D4]
		or	ecx, 1
		mov	[ebp+var_1D4], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	short loc_6597
; ---------------------------------------------------------------------------

loc_6519:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetName(int)+164j
					; icu_56::RuleBasedNumberFormat::getRuleSetName(int)+173j
		jmp	loc_6474
; ---------------------------------------------------------------------------

loc_651E:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetName(int)+140j
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6537:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetName(int)+E6j
					; icu_56::RuleBasedNumberFormat::getRuleSetName(int)+F5j
		mov	esi, esp
		lea	ecx, [ebp+var_108] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 3
		mov	esi, esp
		lea	eax, [ebp+var_108]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_1D4]
		or	ecx, 1
		mov	[ebp+var_1D4], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_108] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]

loc_6597:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetName(int)+E1j
					; icu_56::RuleBasedNumberFormat::getRuleSetName(int)+1CBj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN21_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN21_2		dd 3			; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetName(int)+24Fo
		dd offset $LN20_0
$LN20_0		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:000065D8o
		dd offset $LN16		; "string"
		dd 0FFFFFF58h, 40h
		dd offset $LN17		; "result"
		dd 0FFFFFEF8h, 40h
		dd offset $LN18		; "empty"
$LN18		db 'empty',0            ; DATA XREF: .text:000065FCo
$LN17		db 'result',0           ; DATA XREF: .text:000065F0o
$LN16		db 'string',0           ; DATA XREF: .text:000065E4o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6614h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$0 proc near
					; DATA XREF: .xdata$x:000066B0o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$1 proc near
					; DATA XREF: .xdata$x:000066A8o
		mov	eax, [ebp-1D4h]
		and	eax, 1
		jz	$LN13_1
		and	dword ptr [ebp-1D4h], 0FFFFFFFEh
		mov	esi, esp
		mov	ecx, [ebp+8]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN13_1:				; CODE XREF: __unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$1+9j
		retn
__unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$2 proc near
					; DATA XREF: .xdata$x:000066B8o
		mov	esi, esp
		lea	ecx, [ebp-0A8h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$3 proc near
					; DATA XREF: .xdata$x:000066C0o
		mov	esi, esp
		lea	ecx, [ebp-108h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetName(int)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 66A4h
__unwindtable$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000066CCo
		dd offset __unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$1
		align 10h
		dd offset __unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$0
		align 8
		dd offset __unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$2
		align 10h
		dd offset __unwindfunclet$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z$3
__ehfuncinfo$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z dd	19930522h, 4
					; DATA XREF: __ehhandler$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z+1Eo
		dd offset __unwindtable$?getRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@H@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 66E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NFRuleSet::isPublic(icu_56::NFRuleSet *__hidden this)
		public ?isPublic@NFRuleSet@icu_56@@QBECXZ
?isPublic@NFRuleSet@icu_56@@QBECXZ proc	near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetName(int)+15Ap
					; icu_56::RuleBasedNumberFormat::getNumberOfRuleSetNames(void)+8Fp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+75h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isPublic@NFRuleSet@icu_56@@QBECXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6718h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::NFRuleSet::getName(icu_56::NFRuleSet *this, struct icu_56::UnicodeString *)
		public ?getName@NFRuleSet@icu_56@@QBEXAAVUnicodeString@2@@Z
?getName@NFRuleSet@icu_56@@QBEXAAVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetName(int)+182p
					; icu_56::RuleBasedNumberFormat::getDefaultRuleSetName(void)+96p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getName@NFRuleSet@icu_56@@QBEXAAVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6768h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedNumberFormat::getNumberOfRuleSetNames(icu_56::RuleBasedNumberFormat *__hidden	this)
		public ?getNumberOfRuleSetNames@RuleBasedNumberFormat@icu_56@@UBEHXZ
?getNumberOfRuleSetNames@RuleBasedNumberFormat@icu_56@@UBEHXZ proc near
					; DATA XREF: .rdata:0000471Co

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+258h], 0
		jz	short loc_67C7
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+258h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+258h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		jmp	short loc_680E
; ---------------------------------------------------------------------------

loc_67C7:				; CODE XREF: icu_56::RuleBasedNumberFormat::getNumberOfRuleSetNames(void)+34j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+164h], 0
		jz	short loc_680E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+164h]
		mov	[ebp+var_20], ecx
		jmp	short loc_67EA
; ---------------------------------------------------------------------------

loc_67E1:				; CODE XREF: icu_56::RuleBasedNumberFormat::getNumberOfRuleSetNames(void):loc_680Cj
		mov	eax, [ebp+var_20]
		add	eax, 4
		mov	[ebp+var_20], eax

loc_67EA:				; CODE XREF: icu_56::RuleBasedNumberFormat::getNumberOfRuleSetNames(void)+77j
		mov	eax, [ebp+var_20]
		cmp	dword ptr [eax], 0
		jz	short loc_680E
		mov	eax, [ebp+var_20]
		mov	ecx, [eax]	; this
		call	?isPublic@NFRuleSet@icu_56@@QBECXZ ; icu_56::NFRuleSet::isPublic(void)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_680C
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_680C:				; CODE XREF: icu_56::RuleBasedNumberFormat::getNumberOfRuleSetNames(void)+99j
		jmp	short loc_67E1
; ---------------------------------------------------------------------------

loc_680E:				; CODE XREF: icu_56::RuleBasedNumberFormat::getNumberOfRuleSetNames(void)+5Dj
					; icu_56::RuleBasedNumberFormat::getNumberOfRuleSetNames(void)+69j ...
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getNumberOfRuleSetNames@RuleBasedNumberFormat@icu_56@@UBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6828h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedNumberFormat::getNumberOfRuleSetDisplayNameLocales(icu_56::RuleBasedNumberFormat *__hidden this)
		public ?getNumberOfRuleSetDisplayNameLocales@RuleBasedNumberFormat@icu_56@@UBEHXZ
?getNumberOfRuleSetDisplayNameLocales@RuleBasedNumberFormat@icu_56@@UBEHXZ proc	near
					; DATA XREF: .rdata:00004724o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+258h], 0
		jz	short loc_687D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+258h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+258h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_687F
; ---------------------------------------------------------------------------

loc_687D:				; CODE XREF: icu_56::RuleBasedNumberFormat::getNumberOfRuleSetDisplayNameLocales(void)+2Dj
		xor	eax, eax

loc_687F:				; CODE XREF: icu_56::RuleBasedNumberFormat::getNumberOfRuleSetDisplayNameLocales(void)+53j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getNumberOfRuleSetDisplayNameLocales@RuleBasedNumberFormat@icu_56@@UBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6894h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::Locale	__thiscall __high icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int, enum UErrorCode *)
		public ?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z
?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00004728o

var_338		= byte ptr -338h
var_334		= dword	ptr -334h
var_268		= byte ptr -268h
var_194		= byte ptr -194h
var_C0		= dword	ptr -0C0h
var_B4		= dword	ptr -0B4h
var_A8		= byte ptr -0A8h
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 32Ch
		push	ebx
		push	esi
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_338]
		mov	ecx, 0CBh ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_334], 0
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6933
		mov	esi, esp
		push	0		; char *
		push	0		; char *
		push	0		; char *
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	char *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@PBD000@Z ; icu_56::Locale::Locale(char	const *,char const *,char const	*,char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_334]
		or	eax, 1
		mov	[ebp+var_334], eax
		mov	eax, [ebp+arg_0]
		jmp	loc_6BA0
; ---------------------------------------------------------------------------

loc_6933:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+62j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+258h], 0
		jz	loc_6B37
		cmp	[ebp+arg_4], 0
		jl	loc_6B37
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+258h]
		mov	edx, [ebp+var_18]
		mov	eax, [edx+258h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+arg_4], eax
		jge	loc_6B37
		mov	esi, esp
		push	0FFFFFFFFh	; int
		mov	edi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+258h]
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+258h]
		mov	edx, [edx]
		mov	eax, [edx+14h]
		call	eax
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax		; wchar_t *
		push	1		; signed __int8
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, 1
		mov	[ebp+var_B4], eax
		lea	eax, [ebp+var_A8]
		mov	[ebp+var_C0], eax
		cmp	[ebp+var_B4], 40h ; '@'
		jle	short loc_6A5F
		mov	eax, [ebp+var_B4]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_C0], eax
		cmp	[ebp+var_C0], 0
		jnz	short loc_6A5F
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		mov	esi, esp
		push	0		; char *
		push	0		; char *
		push	0		; char *
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	char *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@PBD000@Z ; icu_56::Locale::Locale(char	const *,char const *,char const	*,char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_334]
		or	eax, 1
		mov	[ebp+var_334], eax
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	loc_6BA0
; ---------------------------------------------------------------------------

loc_6A5F:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+158j
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+176j
		mov	esi, esp
		push	0
		mov	eax, [ebp+var_B4]
		push	eax
		mov	ecx, [ebp+var_C0]
		push	ecx
		mov	edi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		push	0
		lea	ecx, [ebp+var_60]
		call	dword ptr ds:__imp_?extract@UnicodeString@icu_56@@QBEHHHPADHW4EInvariant@12@@Z ; icu_56::UnicodeString::extract(int,int,char *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0		; char *
		push	0		; char *
		push	0		; char *
		mov	eax, [ebp+var_C0]
		push	eax		; char *
		lea	ecx, [ebp+var_194] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@PBD000@Z ; icu_56::Locale::Locale(char	const *,char const *,char const	*,char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_C0]
		lea	ecx, [ebp+var_A8]
		cmp	eax, ecx
		jz	short loc_6ADB
		mov	eax, [ebp+var_C0]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_6ADB:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+236j
		mov	esi, esp
		lea	eax, [ebp+var_194]
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_334]
		or	ecx, 1
		mov	[ebp+var_334], ecx
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_194] ; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	short loc_6BA0
; ---------------------------------------------------------------------------

loc_6B37:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+A9j
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+B3j ...
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		mov	esi, esp
		lea	ecx, [ebp+var_268] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@XZ ; icu_56::Locale::Locale(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 3
		mov	esi, esp
		lea	eax, [ebp+var_268]
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_334]
		or	ecx, 1
		mov	[ebp+var_334], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_268] ; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]

loc_6BA0:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+9Aj
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+1C6j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN19_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 338h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN19_0		dd 4			; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+310o
		dd offset $LN18_0
$LN18_0		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:00006BE0o
		dd offset $LN13_2	; "name"
		dd 0FFFFFF58h, 40h
		dd offset $LN14		; "buffer"
		dd 0FFFFFE6Ch, 0CCh
		dd offset $LN15		; "retLocale"
		dd 0FFFFFD98h, 0CCh
		dd offset $LN16_0	; "retLocale"
$LN16_0		db 'retLocale',0        ; DATA XREF: .text:00006C10o
$LN15		db 'retLocale',0        ; DATA XREF: .text:00006C04o
$LN14		db 'buffer',0           ; DATA XREF: .text:00006BF8o
$LN13_2		db 'name',0             ; DATA XREF: .text:00006BECo
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6C34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:00006CC8o
		mov	eax, [ebp-334h]
		and	eax, 1
		jz	$LN9_2
		and	dword ptr [ebp-334h], 0FFFFFFFEh
		mov	esi, esp
		mov	ecx, [ebp+8]	; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN9_2:					; CODE XREF: __unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$0+9j
		retn
__unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$1	proc near
					; DATA XREF: .xdata$x:00006CD0o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$1	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$2	proc near
					; DATA XREF: .xdata$x:00006CD8o
		mov	esi, esp
		lea	ecx, [ebp-194h]	; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$2	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$3	proc near
					; DATA XREF: .xdata$x:00006CE0o
		mov	esi, esp
		lea	ecx, [ebp-268h]	; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$3	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-33Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6CC4h
__unwindtable$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006CECo
		dd offset __unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$0
		align 10h
		dd offset __unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$2
		align 10h
		dd offset __unwindfunclet$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z$3
__ehfuncinfo$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z dd 19930522h, 4
					; DATA XREF: __ehhandler$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?getRuleSetDisplayNameLocale@RuleBasedNumberFormat@icu_56@@UBE?AVLocale@2@HAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6D08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	icu_56::UnicodeString __thiscall icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int, class icu_56::Locale	const &)
		public ?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z
?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z proc	near
					; DATA XREF: .rdata:00004730o

var_22C		= byte ptr -22Ch
var_228		= dword	ptr -228h
var_15C		= byte ptr -15Ch
var_114		= byte ptr -114h
var_CC		= byte ptr -0CCh
var_84		= dword	ptr -84h
var_78		= dword	ptr -78h
var_6C		= dword	ptr -6Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 220h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_22C]
		mov	ecx, 88h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_228], 0
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+258h], 0
		jz	loc_6FDC
		cmp	[ebp+arg_4], 0
		jl	loc_6FDC
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+258h]
		mov	edx, [ebp+var_18]
		mov	eax, [edx+258h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+arg_4], eax
		jge	loc_6FDC
		mov	esi, esp
		push	0
		push	0FFFFFFFFh
		mov	edi, esp
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?getBaseName@Locale@icu_56@@QBEPBDXZ	; icu_56::Locale::getBaseName(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		lea	ecx, [ebp+var_60]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_6C], eax
		mov	eax, [ebp+var_6C]
		add	eax, 1
		mov	esi, esp
		push	eax		; int
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?getBuffer@UnicodeString@icu_56@@QAEPA_WH@Z ; icu_56::UnicodeString::getBuffer(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_78], eax

loc_6DFF:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &):loc_6F37j
		cmp	[ebp+var_6C], 0
		jl	loc_6F3C
		xor	eax, eax
		mov	ecx, [ebp+var_6C]
		mov	edx, [ebp+var_78]
		mov	[edx+ecx*2], ax
		mov	esi, esp
		mov	eax, [ebp+var_78]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+258h]
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+258h]
		mov	edx, [edx]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_84], eax
		cmp	[ebp+var_84], 0
		jl	loc_6EF8
		mov	esi, esp
		push	0FFFFFFFFh	; int
		mov	edi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_84]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	eax, [edx+258h]
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+258h]
		mov	edx, [eax]
		mov	eax, [edx+18h]
		call	eax
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax		; wchar_t *
		push	1		; signed __int8
		lea	ecx, [ebp+var_CC] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	esi, esp
		lea	eax, [ebp+var_CC]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_228]
		or	ecx, 1
		mov	[ebp+var_228], ecx
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_CC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	loc_7051
; ---------------------------------------------------------------------------

loc_6EF8:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+140j
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const	&)+20Cj
		mov	eax, [ebp+var_6C]
		sub	eax, 1
		mov	[ebp+var_6C], eax
		cmp	[ebp+var_6C], 0
		jle	short loc_6F16
		mov	eax, [ebp+var_6C]
		mov	ecx, [ebp+var_78]
		movzx	edx, word ptr [ecx+eax*2]
		cmp	edx, 5Fh ; '_'
		jnz	short loc_6EF8

loc_6F16:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+1FDj
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const	&)+22Dj
		cmp	[ebp+var_6C], 0
		jle	short loc_6F37
		mov	eax, [ebp+var_6C]
		mov	ecx, [ebp+var_78]
		movzx	edx, word ptr [ecx+eax*2-2]
		cmp	edx, 5Fh ; '_'
		jnz	short loc_6F37
		mov	eax, [ebp+var_6C]
		sub	eax, 1
		mov	[ebp+var_6C], eax
		jmp	short loc_6F16
; ---------------------------------------------------------------------------

loc_6F37:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+212j
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const	&)+222j
		jmp	loc_6DFF
; ---------------------------------------------------------------------------

loc_6F3C:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+FBj
		mov	esi, esp
		push	0FFFFFFFFh	; int
		mov	edi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+258h]
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+258h]
		mov	edx, [edx]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax		; wchar_t *
		push	1		; signed __int8
		lea	ecx, [ebp+var_114] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 3
		mov	esi, esp
		lea	eax, [ebp+var_114]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_228]
		or	ecx, 1
		mov	[ebp+var_228], ecx
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_114] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	short loc_7051
; ---------------------------------------------------------------------------

loc_6FDC:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+59j
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const	&)+63j	...
		mov	esi, esp
		lea	ecx, [ebp+var_15C] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 4
		mov	esi, esp
		lea	ecx, [ebp+var_15C] ; this
		call	dword ptr ds:__imp_?setToBogus@UnicodeString@icu_56@@QAEXXZ ; icu_56::UnicodeString::setToBogus(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	eax, [ebp+var_15C]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_228]
		or	ecx, 1
		mov	[ebp+var_228], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_15C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]

loc_7051:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+1EBj
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const	&)+2D2j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN25_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 22Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN25_0		dd 4			; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+34Do
		dd offset $LN24_1
$LN24_1		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:00007094o
		dd offset $LN19_1	; "localeName"
		dd 0FFFFFF34h, 40h
		dd offset $LN20_1	; "name"
		dd 0FFFFFEECh, 40h
		dd offset $LN21_3	; "name"
		dd 0FFFFFEA4h, 40h
		dd offset $LN22_1	; "bogus"
$LN22_1		db 'bogus',0            ; DATA XREF: .text:000070C4o
$LN21_3		db 'name',0             ; DATA XREF: .text:000070B8o
$LN20_1		db 'name',0             ; DATA XREF: .text:000070ACo
$LN19_1		db 'localeName',0       ; DATA XREF: .text:000070A0o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 70E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$0 proc near
					; DATA XREF: .xdata$x:000071B8o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$1 proc near
					; DATA XREF: .xdata$x:000071C0o
		mov	esi, esp
		lea	ecx, [ebp-0CCh]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$2 proc near
					; DATA XREF: .xdata$x:000071B0o
		mov	eax, [ebp-228h]
		and	eax, 1
		jz	$LN16_1
		and	dword ptr [ebp-228h], 0FFFFFFFEh
		mov	esi, esp
		mov	ecx, [ebp+8]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN16_1:				; CODE XREF: __unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$2+9j
		retn
__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$3 proc near
					; DATA XREF: .xdata$x:000071C8o
		mov	esi, esp
		lea	ecx, [ebp-114h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$4 proc near
					; DATA XREF: .xdata$x:000071D0o
		mov	esi, esp
		lea	ecx, [ebp-15Ch]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-230h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7188h
__ehfuncinfo$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z	dd 19930522h, 5
					; DATA XREF: __ehhandler$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z+1Eo
		dd offset __unwindtable$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007190o
		dd offset __unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$2
		align 8
		dd offset __unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$0
		dd 1
		dd offset __unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$1
		dd 1
		dd offset __unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$3
		align 10h
		dd offset __unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@HABVLocale@2@@Z$4
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 71D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	icu_56::UnicodeString __thiscall icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(class icu_56::UnicodeString const	&, class icu_56::Locale	const &)
		public ?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z
?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z	proc near
					; DATA XREF: .rdata:0000472Co

var_184		= byte ptr -184h
var_180		= dword	ptr -180h
var_B4		= byte ptr -0B4h
var_6C		= dword	ptr -6Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 178h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_184]
		mov	ecx, 5Eh ; '^'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_180], 0
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+258h], 0
		jz	loc_72D9
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?getTerminatedBuffer@UnicodeString@icu_56@@QAEPB_WXZ	; icu_56::UnicodeString::getTerminatedBuffer(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+258h]
		mov	edx, [ebp+var_18]
		mov	eax, [edx+258h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_6C], eax
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_6C]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_18]
		mov	edx, [eax]
		mov	ecx, [ebp+var_18]
		mov	eax, [edx+0A0h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_180]
		or	ecx, 1
		mov	[ebp+var_180], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	short loc_734E
; ---------------------------------------------------------------------------

loc_72D9:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(icu_56::UnicodeString	const &,icu_56::Locale const &)+59j
		mov	esi, esp
		lea	ecx, [ebp+var_B4] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 2
		mov	esi, esp
		lea	ecx, [ebp+var_B4] ; this
		call	dword ptr ds:__imp_?setToBogus@UnicodeString@icu_56@@QAEXXZ ; icu_56::UnicodeString::setToBogus(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	eax, [ebp+var_B4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_180]
		or	ecx, 1
		mov	[ebp+var_180], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_B4] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]

loc_734E:				; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(icu_56::UnicodeString	const &,icu_56::Locale const &)+103j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 184h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN12_1		dd 2			; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(icu_56::UnicodeString	const &,icu_56::Locale const &)+17Eo
		dd offset $LN11_0
$LN11_0		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:00007390o
		dd offset $LN8_1	; "rsn"
		dd 0FFFFFF4Ch, 40h
		dd offset $LN9_3	; "bogus"
$LN9_3		db 'bogus',0            ; DATA XREF: .text:000073A8o
$LN8_1		db 'rsn',0              ; DATA XREF: .text:0000739Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 73B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z$0 proc near
					; DATA XREF: .xdata$x:0000743Co
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z$1 proc near
					; DATA XREF: .xdata$x:00007434o
		mov	eax, [ebp-180h]
		and	eax, 1
		jz	$LN6_0
		and	dword ptr [ebp-180h], 0FFFFFFFEh
		mov	esi, esp
		mov	ecx, [ebp+8]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN6_0:					; CODE XREF: __unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z$1+9j
		retn
__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z$2 proc near
					; DATA XREF: .xdata$x:00007444o
		mov	esi, esp
		lea	ecx, [ebp-0B4h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(icu_56::UnicodeString	const &,icu_56::Locale const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-188h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7430h
__unwindtable$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007450o
		dd offset __unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z$1
		dd 0
		dd offset __unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z$0
		dd 0
		dd offset __unwindfunclet$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z$2
__ehfuncinfo$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z dd	19930522h, 3
					; DATA XREF: __ehhandler$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z+1Eo
		dd offset __unwindtable$?getRuleSetDisplayName@RuleBasedNumberFormat@icu_56@@UAE?AVUnicodeString@2@ABV32@ABVLocale@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 746Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::NFRuleSet *__thiscall icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::RuleBasedNumberFormat	*this, const struct icu_56::UnicodeString *, enum UErrorCode *)
		public ?findRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@ABVUnicodeString@2@AAW4UErrorCode@@@Z
?findRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@ABVUnicodeString@2@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode	&)+71p
					; icu_56::RuleBasedNumberFormat::format(__int64,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+71p ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_74FA
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+164h], 0
		jz	short loc_74FA
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+164h]
		mov	[ebp+var_14], ecx
		jmp	short loc_74C7
; ---------------------------------------------------------------------------

loc_74BE:				; CODE XREF: icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &):loc_74EFj
		mov	eax, [ebp+var_14]
		add	eax, 4
		mov	[ebp+var_14], eax

loc_74C7:				; CODE XREF: icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)+50j
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax], 0
		jz	short loc_74F1
		mov	eax, [ebp+var_14]
		mov	ecx, [eax]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_20] ; this
		call	?isNamed@NFRuleSet@icu_56@@QBECABVUnicodeString@2@@Z ; icu_56::NFRuleSet::isNamed(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_74EF
		mov	eax, [ebp+var_20]
		jmp	short loc_74FC
; ---------------------------------------------------------------------------

loc_74EF:				; CODE XREF: icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)+7Cj
		jmp	short loc_74BE
; ---------------------------------------------------------------------------

loc_74F1:				; CODE XREF: icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)+61j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1

loc_74FA:				; CODE XREF: icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)+36j
					; icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)+42j
		xor	eax, eax

loc_74FC:				; CODE XREF: icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)+81j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@ABVUnicodeString@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7514h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NFRuleSet::isNamed(icu_56::NFRuleSet	*this, const struct icu_56::UnicodeString *)
		public ?isNamed@NFRuleSet@icu_56@@QBECABVUnicodeString@2@@Z
?isNamed@NFRuleSet@icu_56@@QBECABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)+72p
					; icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+F3p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isNamed@NFRuleSet@icu_56@@QBECABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7564h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::RuleBasedNumberFormat::format(icu_56::RuleBasedNumberFormat *__hidden this, int, struct icu_56::UnicodeString *, struct icu_56::FieldPosition *)
		public ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@@Z
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@@Z proc near
					; DATA XREF: .rdata:000046CCo

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi		; enum UErrorCode *
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+170h], 0
		jz	short loc_75F0
		mov	[ebp+var_14], 0
		mov	esi, esp
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		push	0		; int
		mov	esi, esp
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_0]
		cdq
		push	edx
		push	eax		; __int64
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+170h]	; this
		call	?format@NFRuleSet@icu_56@@QBEX_JAAVUnicodeString@2@HHAAW4UErrorCode@@@Z	; icu_56::NFRuleSet::format(__int64,icu_56::UnicodeString &,int,int,UErrorCode &)
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?adjustForCapitalizationContext@RuleBasedNumberFormat@icu_56@@ABEAAVUnicodeString@2@HAAV32@@Z ;	icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString	&)

loc_75F0:				; CODE XREF: icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &)+2Dj
		mov	eax, [ebp+arg_4]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN6_1		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &)+93o
		dd offset $LN5_0
$LN5_0		dd 0FFFFFFECh, 4	; DATA XREF: .text:00007620o
		dd offset $LN4		; "status"
$LN4		db 'status',0           ; DATA XREF: .text:0000762Co
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7638h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::RuleBasedNumberFormat::format(icu_56::RuleBasedNumberFormat *__hidden this, __int64,	struct icu_56::UnicodeString *,	struct icu_56::FieldPosition *)
		public ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@@Z
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@@Z proc near
					; DATA XREF: .rdata:000046C0o

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi		; enum UErrorCode *
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+170h], 0
		jz	short loc_76C6
		mov	[ebp+var_14], 0
		mov	esi, esp
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		push	0		; int
		mov	esi, esp
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, dword ptr [ebp+arg_0+4]
		push	edx
		mov	eax, dword ptr [ebp+arg_0]
		push	eax		; __int64
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+170h]	; this
		call	?format@NFRuleSet@icu_56@@QBEX_JAAVUnicodeString@2@HHAAW4UErrorCode@@@Z	; icu_56::NFRuleSet::format(__int64,icu_56::UnicodeString &,int,int,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?adjustForCapitalizationContext@RuleBasedNumberFormat@icu_56@@ABEAAVUnicodeString@2@HAAV32@@Z ;	icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString	&)

loc_76C6:				; CODE XREF: icu_56::RuleBasedNumberFormat::format(__int64,icu_56::UnicodeString &,icu_56::FieldPosition &)+2Dj
		mov	eax, [ebp+arg_8]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@@Z endp

; ---------------------------------------------------------------------------
$LN6_2		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::format(__int64,icu_56::UnicodeString &,icu_56::FieldPosition &)+95o
		dd offset $LN5_1
$LN5_1		dd 0FFFFFFECh, 4	; DATA XREF: .text:000076F4o
		dd offset $LN4_0	; "status"
$LN4_0		db 'status',0           ; DATA XREF: .text:00007700o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 770Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::RuleBasedNumberFormat::format(icu_56::RuleBasedNumberFormat *__hidden this, double, struct icu_56::UnicodeString *, struct icu_56::FieldPosition *)
		public ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@@Z
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@@Z proc near
					; DATA XREF: .rdata:000046D8o

var_108		= qword	ptr -108h
var_100		= qword	ptr -100h
var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi		; enum UErrorCode *
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+170h], 0
		jz	short loc_778B
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		push	0		; int
		mov	esi, esp
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+108h+var_108] ; double
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+170h]	; this
		call	?format@NFRuleSet@icu_56@@QBEXNAAVUnicodeString@2@HHAAW4UErrorCode@@@Z ; icu_56::NFRuleSet::format(double,icu_56::UnicodeString	&,int,int,UErrorCode &)

loc_778B:				; CODE XREF: icu_56::RuleBasedNumberFormat::format(double,icu_56::UnicodeString	&,icu_56::FieldPosition	&)+42j
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?adjustForCapitalizationContext@RuleBasedNumberFormat@icu_56@@ABEAAVUnicodeString@2@HAAV32@@Z ;	icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString	&)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN6_3		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::format(double,icu_56::UnicodeString	&,icu_56::FieldPosition	&)+93o
		dd offset $LN5_2
$LN5_2		dd 0FFFFFFE0h, 4	; DATA XREF: .text:000077C8o
		dd offset $LN4_1	; "status"
$LN4_1		db 'status',0           ; DATA XREF: .text:000077D4o
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 77E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::RuleBasedNumberFormat::format(icu_56::RuleBasedNumberFormat *__hidden this, int, const struct icu_56::UnicodeString *, struct icu_56::UnicodeString *, struct icu_56::FieldPosition *, enum UErrorCode *)
		public ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@HABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@HABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:0000473Co

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi		; enum UErrorCode *
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_78AF
		mov	esi, esp
		push	0		; int
		push	2		; int
		push	offset _gPercentPercent	; "%%"
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z ; icu_56::UnicodeString::indexOf(wchar_t	const *,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_7846
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		jmp	short loc_78AF
; ---------------------------------------------------------------------------

loc_7846:				; CODE XREF: icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode	&)+59j
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?findRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_78AF
		mov	esi, esp
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		push	0		; int
		mov	esi, esp
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_0]
		cdq
		push	edx
		push	eax		; __int64
		mov	ecx, [ebp+var_14] ; this
		call	?format@NFRuleSet@icu_56@@QBEX_JAAVUnicodeString@2@HHAAW4UErrorCode@@@Z	; icu_56::NFRuleSet::format(__int64,icu_56::UnicodeString &,int,int,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?adjustForCapitalizationContext@RuleBasedNumberFormat@icu_56@@ABEAAVUnicodeString@2@HAAV32@@Z ;	icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString	&)

loc_78AF:				; CODE XREF: icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode	&)+36j
					; icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString const	&,icu_56::UnicodeString	&,icu_56::FieldPosition	&,UErrorCode &)+64j ...
		mov	eax, [ebp+arg_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@HABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 78C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::RuleBasedNumberFormat::format(icu_56::RuleBasedNumberFormat *__hidden this, __int64,	const struct icu_56::UnicodeString *, struct icu_56::UnicodeString *, struct icu_56::FieldPosition *, enum UErrorCode *)
		public ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@_JABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@_JABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: .rdata:00004738o

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi		; enum UErrorCode *
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_7999
		mov	esi, esp
		push	0		; int
		push	2		; int
		push	offset _gPercentPercent	; "%%"
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z ; icu_56::UnicodeString::indexOf(wchar_t	const *,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_792E
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		jmp	short loc_7999
; ---------------------------------------------------------------------------

loc_792E:				; CODE XREF: icu_56::RuleBasedNumberFormat::format(__int64,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+59j
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?findRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_7999
		mov	esi, esp
		mov	ecx, [ebp+arg_C] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		push	0		; int
		mov	esi, esp
		mov	ecx, [ebp+arg_C] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, dword ptr [ebp+arg_0+4]
		push	edx
		mov	eax, dword ptr [ebp+arg_0]
		push	eax		; __int64
		mov	ecx, [ebp+var_14] ; this
		call	?format@NFRuleSet@icu_56@@QBEX_JAAVUnicodeString@2@HHAAW4UErrorCode@@@Z	; icu_56::NFRuleSet::format(__int64,icu_56::UnicodeString &,int,int,UErrorCode &)
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?adjustForCapitalizationContext@RuleBasedNumberFormat@icu_56@@ABEAAVUnicodeString@2@HAAV32@@Z ;	icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString	&)

loc_7999:				; CODE XREF: icu_56::RuleBasedNumberFormat::format(__int64,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+36j
					; icu_56::RuleBasedNumberFormat::format(__int64,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+64j ...
		mov	eax, [ebp+arg_C]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@_JABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 79B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::RuleBasedNumberFormat::format(icu_56::RuleBasedNumberFormat *__hidden this, double, const struct icu_56::UnicodeString *, struct icu_56::UnicodeString *, struct icu_56::FieldPosition *, enum UErrorCode *)
		public ?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@NABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@NABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00004734o

var_108		= qword	ptr -108h
var_100		= qword	ptr -100h
var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi		; enum UErrorCode *
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_7A86
		mov	esi, esp
		push	0		; int
		push	2		; int
		push	offset _gPercentPercent	; "%%"
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z ; icu_56::UnicodeString::indexOf(wchar_t	const *,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_7A1A
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		jmp	short loc_7A86
; ---------------------------------------------------------------------------

loc_7A1A:				; CODE XREF: icu_56::RuleBasedNumberFormat::format(double,icu_56::UnicodeString	const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+59j
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?findRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_7A86
		mov	esi, esp
		mov	ecx, [ebp+arg_C] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		push	0		; int
		mov	esi, esp
		mov	ecx, [ebp+arg_C] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct icu_56::UnicodeString *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+108h+var_108] ; double
		mov	ecx, [ebp+var_14] ; this
		call	?format@NFRuleSet@icu_56@@QBEXNAAVUnicodeString@2@HHAAW4UErrorCode@@@Z ; icu_56::NFRuleSet::format(double,icu_56::UnicodeString	&,int,int,UErrorCode &)
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?adjustForCapitalizationContext@RuleBasedNumberFormat@icu_56@@ABEAAVUnicodeString@2@HAAV32@@Z ;	icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString	&)

loc_7A86:				; CODE XREF: icu_56::RuleBasedNumberFormat::format(double,icu_56::UnicodeString	const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+36j
					; icu_56::RuleBasedNumberFormat::format(double,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode	&)+64j	...
		mov	eax, [ebp+arg_C]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?format@RuleBasedNumberFormat@icu_56@@UBEAAVUnicodeString@2@NABV32@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7AA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(icu_56::RuleBasedNumberFormat *this, int, struct icu_56::UnicodeString	*)
		public ?adjustForCapitalizationContext@RuleBasedNumberFormat@icu_56@@ABEAAVUnicodeString@2@HAAV32@@Z
?adjustForCapitalizationContext@RuleBasedNumberFormat@icu_56@@ABEAAVUnicodeString@2@HAAV32@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &)+87p
					; icu_56::RuleBasedNumberFormat::format(__int64,icu_56::UnicodeString &,icu_56::FieldPosition &)+89p ...

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jnz	loc_7BBE
		mov	esi, esp
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jle	loc_7BBE
		mov	esi, esp
		push	0		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?char32At@UnicodeString@icu_56@@QBEHH@Z ; icu_56::UnicodeString::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	[ebp+var_20], 0
		mov	esi, esp
		lea	eax, [ebp+var_20]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+80h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_14]
		push	eax
		call	_u_islower_56
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_7BBE
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_7BBE
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+2A0h], 0
		jz	short loc_7BBE
		cmp	[ebp+var_2C], 102h
		jz	short loc_7B94
		cmp	[ebp+var_2C], 103h
		jnz	short loc_7B7D
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+29Dh]
		test	ecx, ecx
		jnz	short loc_7B94

loc_7B7D:				; CODE XREF: icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString &)+CDj
		cmp	[ebp+var_2C], 104h
		jnz	short loc_7BBE
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+29Eh]
		test	ecx, ecx
		jz	short loc_7BBE

loc_7B94:				; CODE XREF: icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString &)+C4j
					; icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString &)+DBj
		mov	esi, esp
		push	300h		; unsigned int
		mov	eax, [ebp+var_8]
		add	eax, 174h
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+2A0h]
		push	edx		; struct icu_56::BreakIterator *
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?toTitle@UnicodeString@icu_56@@QAEAAV12@PAVBreakIterator@2@ABVLocale@2@I@Z ;	icu_56::UnicodeString::toTitle(icu_56::BreakIterator *,icu_56::Locale const &,uint)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7BBE:				; CODE XREF: icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString &)+27j
					; icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString &)+41j ...
		mov	eax, [ebp+arg_4]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?adjustForCapitalizationContext@RuleBasedNumberFormat@icu_56@@ABEAAVUnicodeString@2@HAAV32@@Z endp

; ---------------------------------------------------------------------------
$LN9_4		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString &)+125o
		dd offset $LN8_2
$LN8_2		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00007BECo
		dd offset $LN7_1	; "status"
$LN7_1		db 'status',0           ; DATA XREF: .text:00007BF8o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedNumberFormat::parse(icu_56::RuleBasedNumberFormat *this, const struct icu_56::UnicodeString *, struct icu_56::Formattable *,	struct icu_56::ParsePosition *)
		public ?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z
?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z proc	near
					; DATA XREF: .rdata:000046E0o

var_38C		= qword	ptr -38Ch
var_374		= qword	ptr -374h
var_2A8		= dword	ptr -2A8h
var_29C		= dword	ptr -29Ch
var_290		= dword	ptr -290h
var_284		= byte ptr -284h
var_19C		= byte ptr -19Ch
var_188		= dword	ptr -188h
var_17C		= dword	ptr -17Ch
var_170		= byte ptr -170h
var_88		= byte ptr -88h
var_74		= byte ptr -74h
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 368h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_374]
		mov	ecx, 0DAh ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+164h], 0
		jnz	short loc_7C6E
		mov	esi, esp
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?setErrorIndex@ParsePosition@icu_56@@QAEXH@Z	; icu_56::ParsePosition::setErrorIndex(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_801A
; ---------------------------------------------------------------------------

loc_7C6E:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+4Fj
		mov	esi, esp
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@H@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		push	0		; int
		lea	ecx, [ebp+var_74] ; this
		call	dword ptr ds:__imp_??0ParsePosition@icu_56@@QAE@H@Z ; icu_56::ParsePosition::ParsePosition(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		push	0		; int
		lea	ecx, [ebp+var_88] ; this
		call	dword ptr ds:__imp_??0ParsePosition@icu_56@@QAE@H@Z ; icu_56::ParsePosition::ParsePosition(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_170] ; this
		call	??0Formattable@icu_56@@QAE@XZ ;	icu_56::Formattable::Formattable(void)
		mov	byte ptr [ebp+var_4], 3
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+164h]
		mov	[ebp+var_17C], ecx
		jmp	short loc_7D00
; ---------------------------------------------------------------------------

loc_7CF1:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &):loc_7E7Dj
		mov	eax, [ebp+var_17C]
		add	eax, 4
		mov	[ebp+var_17C], eax

loc_7D00:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+EBj
		mov	eax, [ebp+var_17C]
		cmp	dword ptr [eax], 0
		jz	loc_7E82
		mov	eax, [ebp+var_17C]
		mov	ecx, [eax]
		mov	[ebp+var_188], ecx
		mov	ecx, [ebp+var_188] ; this
		call	?isPublic@NFRuleSet@icu_56@@QBECXZ ; icu_56::NFRuleSet::isPublic(void)
		movsx	eax, al
		test	eax, eax
		jz	loc_7E7D
		mov	ecx, [ebp+var_188] ; this
		call	?isParseable@NFRuleSet@icu_56@@QBECXZ ;	icu_56::NFRuleSet::isParseable(void)
		movsx	eax, al
		test	eax, eax
		jz	loc_7E7D
		mov	esi, esp
		push	0		; int
		lea	ecx, [ebp+var_19C] ; this
		call	dword ptr ds:__imp_??0ParsePosition@icu_56@@QAE@H@Z ; icu_56::ParsePosition::ParsePosition(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 4
		lea	ecx, [ebp+var_284] ; this
		call	??0Formattable@icu_56@@QAE@XZ ;	icu_56::Formattable::Formattable(void)
		mov	byte ptr [ebp+var_4], 5
		lea	eax, [ebp+var_284]
		push	eax		; struct icu_56::Formattable *
		sub	esp, 8
		fld	ds:__real@42b0000000000000
		fstp	[esp+38Ch+var_38C] ; double
		lea	ecx, [ebp+var_19C]
		push	ecx		; struct icu_56::ParsePosition *
		lea	edx, [ebp+var_60]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_188] ; this
		call	?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z	; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)
		mov	esi, esp
		lea	ecx, [ebp+var_19C] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		lea	ecx, [ebp+var_88] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jle	loc_7E55
		mov	esi, esp
		lea	eax, [ebp+var_19C]
		push	eax
		lea	ecx, [ebp+var_88]
		call	dword ptr ds:__imp_??4ParsePosition@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::ParsePosition::operator=(icu_56::ParsePosition const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	eax, [ebp+var_284]
		push	eax
		lea	ecx, [ebp+var_170]
		call	??4Formattable@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::Formattable::operator=(icu_56::Formattable const &)
		mov	esi, esp
		lea	ecx, [ebp+var_88] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jnz	short loc_7E55
		mov	byte ptr [ebp+var_4], 4
		lea	ecx, [ebp+var_284] ; this
		call	??1Formattable@icu_56@@UAE@XZ ;	icu_56::Formattable::~Formattable(void)
		mov	byte ptr [ebp+var_4], 3
		mov	esi, esp
		lea	ecx, [ebp+var_19C] ; this
		call	dword ptr ds:__imp_??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_7E82
; ---------------------------------------------------------------------------

loc_7E55:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+1C6j
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+225j
		mov	byte ptr [ebp+var_4], 4
		lea	ecx, [ebp+var_284] ; this
		call	??1Formattable@icu_56@@UAE@XZ ;	icu_56::Formattable::~Formattable(void)
		mov	byte ptr [ebp+var_4], 3
		mov	esi, esp
		lea	ecx, [ebp+var_19C] ; this
		call	dword ptr ds:__imp_??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7E7D:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+129j
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+13Fj
		jmp	loc_7CF1
; ---------------------------------------------------------------------------

loc_7E82:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+105j
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+24Fj
		mov	esi, esp
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_290], eax
		mov	esi, esp
		lea	ecx, [ebp+var_88] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, [ebp+var_290]
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?setIndex@ParsePosition@icu_56@@QAEXH@Z ; icu_56::ParsePosition::setIndex(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_88] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jle	short loc_7EF7
		mov	esi, esp
		push	0FFFFFFFFh	; int
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?setErrorIndex@ParsePosition@icu_56@@QAEXH@Z	; icu_56::ParsePosition::setErrorIndex(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_7F62
; ---------------------------------------------------------------------------

loc_7EF7:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+2DBj
		mov	esi, esp
		lea	ecx, [ebp+var_88] ; this
		call	dword ptr ds:__imp_?getErrorIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getErrorIndex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jle	short loc_7F2D
		mov	esi, esp
		lea	ecx, [ebp+var_88] ; this
		call	dword ptr ds:__imp_?getErrorIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getErrorIndex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	dword ptr [ebp+var_374+4], eax
		jmp	short loc_7F37
; ---------------------------------------------------------------------------

loc_7F2D:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+30Aj
		mov	dword ptr [ebp+var_374+4], 0

loc_7F37:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+327j
		mov	eax, dword ptr [ebp+var_374+4]
		mov	[ebp+var_29C], eax
		mov	eax, [ebp+var_290]
		add	eax, [ebp+var_29C]
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?setErrorIndex@ParsePosition@icu_56@@QAEXH@Z	; icu_56::ParsePosition::setErrorIndex(int)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7F62:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+2F1j
		lea	eax, [ebp+var_170]
		push	eax
		mov	ecx, [ebp+arg_4]
		call	??4Formattable@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::Formattable::operator=(icu_56::Formattable const &)
		mov	ecx, [ebp+arg_4]
		call	?getType@Formattable@icu_56@@QBE?AW4Type@12@XZ ; icu_56::Formattable::getType(void)
		cmp	eax, 1
		jnz	short loc_7FC3
		mov	ecx, [ebp+arg_4] ; this
		call	?getDouble@Formattable@icu_56@@QBENXZ ;	icu_56::Formattable::getDouble(void)
		call	__ftol2_sse
		mov	[ebp+var_2A8], eax
		fild	[ebp+var_2A8]
		mov	ecx, [ebp+arg_4] ; this
		fstp	[ebp+var_374]
		call	?getDouble@Formattable@icu_56@@QBENXZ ;	icu_56::Formattable::getDouble(void)
		fld	[ebp+var_374]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_7FC3
		mov	eax, [ebp+var_2A8]
		push	eax		; int
		mov	ecx, [ebp+arg_4] ; this
		call	?setLong@Formattable@icu_56@@QAEXH@Z ; icu_56::Formattable::setLong(int)

loc_7FC3:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+378j
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+3AEj
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_170] ; this
		call	??1Formattable@icu_56@@UAE@XZ ;	icu_56::Formattable::~Formattable(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_88] ; this
		call	dword ptr ds:__imp_??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_74] ; this
		call	dword ptr ds:__imp_??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		cmp	esi, esp

loc_7FFC:				; DATA XREF: .rdata:int	const icu_56::MessagePattern::Part::MAX_VALUEo
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_801A:				; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+65j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN30
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 374h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN30		dd 6			; DATA XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+41Ao
		dd offset $LN29
$LN29		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:0000805Co
		dd offset $LN22_2	; "workingText"
		dd 0FFFFFF8Ch, 0Ch
		dd offset $LN23_0	; "workingPos"
		dd 0FFFFFF78h, 0Ch
		dd offset $LN24_2	; "high_pp"
		db 90h
		db 0FEh, 2 dup(0FFh)
		dd offset ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B ;	std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreate
		dd offset $LN25_1	; "high_result"
		dd 0FFFFFE64h, 0Ch
		dd offset $LN26_0	; "working_pp"
		dd 0FFFFFD7Ch, 0E0h
		dd offset $LN27		; "working_result"
$LN27		db 'working_result',0   ; DATA XREF: .text:000080A4o
$LN26_0		db 'working_pp',0       ; DATA XREF: .text:00008098o
$LN25_1		db 'high_result',0      ; DATA XREF: .text:0000808Co
$LN24_2		db 'high_pp',0          ; DATA XREF: .text:00008080o
$LN23_0		db 'workingPos',0       ; DATA XREF: .text:00008074o
$LN22_2		db 'workingText',0      ; DATA XREF: .text:00008068o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 80F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$0 proc near
					; DATA XREF: .xdata$x:000081ACo
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$1 proc near
					; DATA XREF: .xdata$x:000081B4o
		mov	esi, esp
		lea	ecx, [ebp-74h]	; this
		call	dword ptr ds:__imp_??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$2 proc near
					; DATA XREF: .xdata$x:000081BCo
		mov	esi, esp
		lea	ecx, [ebp-88h]	; this
		call	dword ptr ds:__imp_??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$3 proc near
					; DATA XREF: .xdata$x:000081C4o
		lea	ecx, [ebp-170h]	; this
		jmp	??1Formattable@icu_56@@UAE@XZ ;	icu_56::Formattable::~Formattable(void)
__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$4 proc near
					; DATA XREF: .xdata$x:000081CCo
		mov	esi, esp
		lea	ecx, [ebp-19Ch]	; this
		call	dword ptr ds:__imp_??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$5 proc near
					; DATA XREF: .xdata$x:000081D4o
		lea	ecx, [ebp-284h]	; this
		jmp	??1Formattable@icu_56@@UAE@XZ ;	icu_56::Formattable::~Formattable(void)
__unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$5 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-378h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 817Ch
		public __real@42b0000000000000
__real@42b0000000000000	dq 1.7592186044416e13
					; DATA XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+179r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8184h
__ehfuncinfo$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z	dd 19930522h, 6
					; DATA XREF: __ehhandler$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z+1Eo
		dd offset __unwindtable$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000818Co
		dd offset __unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$0
		dd 0
		dd offset __unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$1
		dd 1
		dd offset __unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$2
		dd 2
		dd offset __unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$3
		dd 3
		dd offset __unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$4
		dd 4
		dd offset __unwindfunclet$?parse@RuleBasedNumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z$5
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 81D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NFRuleSet::isParseable(icu_56::NFRuleSet *__hidden this)
		public ?isParseable@NFRuleSet@icu_56@@QBECXZ
?isParseable@NFRuleSet@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+135p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+76h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isParseable@NFRuleSet@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8208h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedNumberFormat::setLenient(icu_56::RuleBasedNumberFormat *this, signed	__int8)
		public ?setLenient@RuleBasedNumberFormat@icu_56@@UAEXC@Z
?setLenient@RuleBasedNumberFormat@icu_56@@UAEXC@Z proc near ; DATA XREF: .rdata:000046ECo

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	cl, [ebp+arg_0]
		mov	[eax+250h], cl
		movsx	eax, [ebp+arg_0]
		test	eax, eax
		jnz	short loc_82AB
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+240h], 0
		jz	short loc_82AB
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+240h]
		mov	[ebp+var_D4], ecx
		mov	edx, [ebp+var_D4]
		mov	[ebp+var_E0], edx
		cmp	[ebp+var_E0], 0
		jz	short loc_8294
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_E0]
		mov	edx, [eax]
		mov	ecx, [ebp+var_E0]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E8], eax
		jmp	short loc_829E
; ---------------------------------------------------------------------------

loc_8294:				; CODE XREF: icu_56::RuleBasedNumberFormat::setLenient(signed char)+65j
		mov	[ebp+var_E8], 0

loc_829E:				; CODE XREF: icu_56::RuleBasedNumberFormat::setLenient(signed char)+8Aj
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+240h], 0

loc_82AB:				; CODE XREF: icu_56::RuleBasedNumberFormat::setLenient(signed char)+35j
					; icu_56::RuleBasedNumberFormat::setLenient(signed char)+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setLenient@RuleBasedNumberFormat@icu_56@@UAEXC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 82C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::RuleBasedNumberFormat *this,	const struct icu_56::UnicodeString *, enum UErrorCode *)
		public ?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z
?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z proc	near
					; DATA XREF: .rdata:00004740o

var_18C		= dword	ptr -18Ch
var_188		= dword	ptr -188h
var_180		= byte ptr -180h
var_135		= byte ptr -135h
var_6C		= dword	ptr -6Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 180h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_18C]
		mov	ecx, 60h ; '`'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax		; int
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_847D
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?isEmpty@UnicodeString@icu_56@@QBECXZ ; icu_56::UnicodeString::isEmpty(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	loc_83D0
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+258h], 0
		jz	short loc_83C3
		mov	esi, esp
		push	0FFFFFFFFh	; int
		mov	edi, esp
		push	0
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+258h]
		mov	edx, [ebp+var_18]
		mov	eax, [edx+258h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+0Ch]
		call	eax
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax		; wchar_t *
		push	1		; signed __int8
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_60]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?findRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)
		mov	edx, [ebp+var_18]
		mov	[edx+170h], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_83CB
; ---------------------------------------------------------------------------

loc_83C3:				; CODE XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+85j
		mov	ecx, [ebp+var_18] ; this
		call	?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ ; icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)

loc_83CB:				; CODE XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+FDj
		jmp	loc_847D
; ---------------------------------------------------------------------------

loc_83D0:				; CODE XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+75j
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_15IOLAJFNF@?$AA?$CF?$AA?$CF?$AA?$AA@ ; "%%"
		push	1		; signed __int8
		lea	ecx, [ebp+var_180] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_188], eax
		mov	eax, [ebp+var_188]
		mov	[ebp+var_18C], eax
		mov	[ebp+var_4], 1
		mov	esi, esp
		mov	ecx, [ebp+var_18C]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?startsWith@UnicodeString@icu_56@@QBECABV12@@Z ; icu_56::UnicodeString::startsWith(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_135], al
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_180] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	edx, [ebp+var_135]
		test	edx, edx
		jz	short loc_8458
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		jmp	short loc_847D
; ---------------------------------------------------------------------------

loc_8458:				; CODE XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+187j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?findRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)
		mov	[ebp+var_6C], eax
		cmp	[ebp+var_6C], 0
		jz	short loc_847D
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_6C]
		mov	[eax+170h], ecx

loc_847D:				; CODE XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+58j
					; icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &):loc_83CBj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN16_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN16_2		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+1BDo
		dd offset $LN15_0
$LN15_0		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:000084C0o
		dd offset $LN13_3	; "name"
$LN13_3		db 'name',0             ; DATA XREF: .text:000084CCo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 84D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00008534o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000853Co
		mov	esi, esp
		lea	ecx, [ebp-180h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-190h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8528h
		public ??_C@_15IOLAJFNF@?$AA?$CF?$AA?$CF?$AA?$AA@
; wchar_t `string'
??_C@_15IOLAJFNF@?$AA?$CF?$AA?$CF?$AA?$AA@:
					; DATA XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+110o
		unicode	0, <%%>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8530h
__unwindtable$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008548o
		dd offset __unwindfunclet$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z	dd 19930522h, 2
					; DATA XREF: __ehhandler$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?setDefaultRuleSet@RuleBasedNumberFormat@icu_56@@UAEXABVUnicodeString@2@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8564h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	icu_56::UnicodeString __thiscall icu_56::RuleBasedNumberFormat::getDefaultRuleSetName(void)const
		public ?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ
?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ proc near
					; DATA XREF: .rdata:00004744o

var_130		= byte ptr -130h
var_12C		= dword	ptr -12Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_130]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_12C], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+170h], 0
		jz	short loc_8601
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+170h]	; this
		call	?isPublic@NFRuleSet@icu_56@@QBECXZ ; icu_56::NFRuleSet::isPublic(void)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_8601
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+170h]	; this
		call	?getName@NFRuleSet@icu_56@@QBEXAAVUnicodeString@2@@Z ; icu_56::NFRuleSet::getName(icu_56::UnicodeString	&)
		jmp	short loc_8613
; ---------------------------------------------------------------------------

loc_8601:				; CODE XREF: icu_56::RuleBasedNumberFormat::getDefaultRuleSetName(void)+72j
					; icu_56::RuleBasedNumberFormat::getDefaultRuleSetName(void)+87j
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?setToBogus@UnicodeString@icu_56@@QAEXXZ ; icu_56::UnicodeString::setToBogus(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8613:				; CODE XREF: icu_56::RuleBasedNumberFormat::getDefaultRuleSetName(void)+9Bj
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_12C]
		or	ecx, 1
		mov	[ebp+var_12C], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 130h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
$LN11_1		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::getDefaultRuleSetName(void)+F1o
		dd offset $LN10_3
$LN10_3		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:00008694o
		dd offset $LN8_3	; "result"
$LN8_3		db 'result',0           ; DATA XREF: .text:000086A0o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 86ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$0	proc near
					; DATA XREF: .xdata$x:0000871Co
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$1	proc near
					; DATA XREF: .xdata$x:00008714o
		mov	eax, [ebp-12Ch]
		and	eax, 1
		jz	$LN7_2
		and	dword ptr [ebp-12Ch], 0FFFFFFFEh
		mov	esi, esp
		mov	ecx, [ebp+8]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN7_2:					; CODE XREF: __unwindfunclet$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$1+9j
		retn
__unwindfunclet$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$1	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::getDefaultRuleSetName(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-134h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8710h
__unwindtable$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008728o
		dd offset __unwindfunclet$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$1
		dd 0
		dd offset __unwindfunclet$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ$0
__ehfuncinfo$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ+1Eo
		dd offset __unwindtable$?getDefaultRuleSetName@RuleBasedNumberFormat@icu_56@@UBE?AVUnicodeString@2@XZ
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8744h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedNumberFormat::initDefaultRuleSet(icu_56::RuleBasedNumberFormat *__hidden this)
		public ?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ
?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+102p
					; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode	&)+845p

var_1C0		= byte ptr -1C0h
var_FC		= dword	ptr -0FCh
var_F0		= byte ptr -0F0h
var_A8		= byte ptr -0A8h
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 1B4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1C0]
		mov	ecx, 6Dh ; 'm'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+170h], 0
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+164h], 0
		jnz	short loc_87A7
		jmp	loc_89B9
; ---------------------------------------------------------------------------

loc_87A7:				; CODE XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+5Cj
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1CI@HAAAIMPO@?$AA?$CF?$AAs?$AAp?$AAe?$AAl?$AAl?$AAo?$AAu?$AAt?$AA?9?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ ; "%spellout-numbering"
		push	1		; signed __int8
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1CA@KPINKAKD@?$AA?$CF?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?9?$AAo?$AAr?$AAd?$AAi?$AAn?$AAa?$AAl?$AA?$AA@ ; "%digits-ordinal"
		push	1		; signed __int8
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1BE@CCKLGBHN@?$AA?$CF?$AAd?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; "%duration"
		push	1		; signed __int8
		lea	ecx, [ebp+var_F0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+164h]
		mov	[ebp+var_FC], ecx

loc_881C:				; CODE XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void):loc_88EBj
		mov	eax, [ebp+var_FC]
		cmp	dword ptr [eax], 0
		jz	loc_88F0
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_FC]
		mov	ecx, [ecx]	; this
		call	?isNamed@NFRuleSet@icu_56@@QBECABVUnicodeString@2@@Z ; icu_56::NFRuleSet::isNamed(icu_56::UnicodeString	const &)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_8879
		lea	eax, [ebp+var_A8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_FC]
		mov	ecx, [ecx]	; this
		call	?isNamed@NFRuleSet@icu_56@@QBECABVUnicodeString@2@@Z ; icu_56::NFRuleSet::isNamed(icu_56::UnicodeString	const &)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_8879
		lea	eax, [ebp+var_F0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_FC]
		mov	ecx, [ecx]	; this
		call	?isNamed@NFRuleSet@icu_56@@QBECABVUnicodeString@2@@Z ; icu_56::NFRuleSet::isNamed(icu_56::UnicodeString	const &)
		movsx	edx, al
		test	edx, edx
		jz	short loc_88DC

loc_8879:				; CODE XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+FDj
					; icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+118j
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_FC]
		mov	edx, [ecx]
		mov	[eax+170h], edx
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_F0] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_89B9
; ---------------------------------------------------------------------------
		jmp	short loc_88EB
; ---------------------------------------------------------------------------

loc_88DC:				; CODE XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+133j
		mov	eax, [ebp+var_FC]
		add	eax, 4
		mov	[ebp+var_FC], eax

loc_88EB:				; CODE XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+196j
		jmp	loc_881C
; ---------------------------------------------------------------------------

loc_88F0:				; CODE XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+E1j
		mov	eax, [ebp+var_FC]
		sub	eax, 4
		mov	[ebp+var_FC], eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ebp+var_FC]
		mov	eax, [edx]
		mov	[ecx+170h], eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+170h]	; this
		call	?isPublic@NFRuleSet@icu_56@@QBECXZ ; icu_56::NFRuleSet::isPublic(void)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_896E

loc_8925:				; CODE XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void):loc_896Cj
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_FC]
		cmp	ecx, [eax+164h]
		jz	short loc_896E
		mov	eax, [ebp+var_FC]
		sub	eax, 4
		mov	[ebp+var_FC], eax
		mov	ecx, [ebp+var_FC]
		mov	ecx, [ecx]	; this
		call	?isPublic@NFRuleSet@icu_56@@QBECXZ ; icu_56::NFRuleSet::isPublic(void)
		movsx	edx, al
		test	edx, edx
		jz	short loc_896C
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_FC]
		mov	edx, [ecx]
		mov	[eax+170h], edx
		jmp	short loc_896E
; ---------------------------------------------------------------------------

loc_896C:				; CODE XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+213j
		jmp	short loc_8925
; ---------------------------------------------------------------------------

loc_896E:				; CODE XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+1DFj
					; icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+1F0j	...
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_F0] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_89B9:				; CODE XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+5Ej
					; icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+191j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN21_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN21_4		dd 3			; DATA XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+279o
		dd offset $LN20_2
$LN20_2		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:000089F8o
		dd offset $LN16_3	; "spellout"
		dd 0FFFFFF58h, 40h
		dd offset $LN17_0	; "ordinal"
		dd 0FFFFFF10h, 40h
		dd offset $LN18_1	; "duration"
$LN18_1		db 'duration',0         ; DATA XREF: .text:00008A1Co
$LN17_0		db 'ordinal',0          ; DATA XREF: .text:00008A10o
$LN16_3		db 'spellout',0         ; DATA XREF: .text:00008A04o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8A3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ$0 proc	near
					; DATA XREF: .xdata$x:00008B00o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ$1 proc	near
					; DATA XREF: .xdata$x:00008B08o
		mov	esi, esp
		lea	ecx, [ebp-0A8h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ$2 proc	near
					; DATA XREF: .xdata$x:00008B10o
		mov	esi, esp
		lea	ecx, [ebp-0F0h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1C4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ
		jmp	___CxxFrameHandler3
__ehhandler$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8AA0h
		public ??_C@_1BE@CCKLGBHN@?$AA?$CF?$AAd?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
; wchar_t `string'
??_C@_1BE@CCKLGBHN@?$AA?$CF?$AAd?$AAu?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@:
					; DATA XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+ABo
		unicode	0, <%duration>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8AB4h
		public ??_C@_1CA@KPINKAKD@?$AA?$CF?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?9?$AAo?$AAr?$AAd?$AAi?$AAn?$AAa?$AAl?$AA?$AA@
; wchar_t `string'
??_C@_1CA@KPINKAKD@?$AA?$CF?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?9?$AAo?$AAr?$AAd?$AAi?$AAn?$AAa?$AAl?$AA?$AA@:
					; DATA XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+89o
		unicode	0, <%digits-ordinal>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8AD4h
		public ??_C@_1CI@HAAAIMPO@?$AA?$CF?$AAs?$AAp?$AAe?$AAl?$AAl?$AAo?$AAu?$AAt?$AA?9?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
; wchar_t `string'
??_C@_1CI@HAAAIMPO@?$AA?$CF?$AAs?$AAp?$AAe?$AAl?$AAl?$AAo?$AAu?$AAt?$AA?9?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAi?$AAn?$AAg?$AA?$AA@:
					; DATA XREF: icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)+67o
		unicode	0, <%spellout-numbering>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8AFCh
__unwindtable$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008B1Co
		dd offset __unwindfunclet$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ$0
		align 8
		dd offset __unwindfunclet$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ$1
		dd 1
		dd offset __unwindfunclet$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ$2
__ehfuncinfo$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ dd 19930522h, 3
					; DATA XREF: __ehhandler$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ+1Eo
		dd offset __unwindtable$?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8B38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedNumberFormat::init(icu_56::RuleBasedNumberFormat *this, const struct	icu_56::UnicodeString *, struct	icu_56::LocalizationInfo *, struct UParseError *Dst, enum UErrorCode *)
		public ?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z
?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString	const &,icu_56::UnicodeString const &,icu_56::Locale const &,UParseError &,UErrorCode &)+177p
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString const &,icu_56::UnicodeString const &,UParseError &,UErrorCode &)+183p ...

var_264		= dword	ptr -264h
var_260		= dword	ptr -260h
var_258		= dword	ptr -258h
var_24C		= dword	ptr -24Ch
var_240		= dword	ptr -240h
var_234		= dword	ptr -234h
var_228		= dword	ptr -228h
var_21C		= dword	ptr -21Ch
var_210		= dword	ptr -210h
var_204		= dword	ptr -204h
var_1F8		= dword	ptr -1F8h
var_12C		= dword	ptr -12Ch
var_120		= byte ptr -120h
var_D8		= dword	ptr -0D8h
var_CC		= dword	ptr -0CCh
var_C0		= dword	ptr -0C0h
var_B4		= dword	ptr -0B4h
var_A8		= dword	ptr -0A8h
var_9C		= dword	ptr -9Ch
var_90		= dword	ptr -90h
var_84		= dword	ptr -84h
var_78		= dword	ptr -78h
var_6C		= dword	ptr -6Ch
var_60		= dword	ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 258h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_264]
		mov	ecx, 96h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		push	48h ; 'H'       ; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8BA7
		jmp	loc_951B
; ---------------------------------------------------------------------------

loc_8BA7:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+68j
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_18] ; this
		call	?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z ;	icu_56::RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_18] ; this
		call	?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_18] ; this
		call	?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode &)
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8BE5
		jmp	loc_951B
; ---------------------------------------------------------------------------

loc_8BE5:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+A6j
		cmp	[ebp+arg_4], 0
		jnz	short loc_8BF7
		mov	[ebp+var_260], 0
		jmp	short loc_8C05
; ---------------------------------------------------------------------------

loc_8BF7:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+B1j
		mov	ecx, [ebp+arg_4] ; this
		call	?ref@LocalizationInfo@icu_56@@QAEPAV12@XZ ; icu_56::LocalizationInfo::ref(void)
		mov	[ebp+var_260], eax

loc_8C05:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+BDj
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_260]
		mov	[eax+258h], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_8C6E
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_951B
; ---------------------------------------------------------------------------

loc_8C6E:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+10Dj
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z ; icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString	&)
		mov	esi, esp
		push	0		; int
		push	0FFFFFFFFh	; int
		push	offset _gLenientParse ;	"%%lenient-parse:"
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z ; icu_56::UnicodeString::indexOf(wchar_t	const *,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_6C], eax
		cmp	[ebp+var_6C], 0FFFFFFFFh
		jz	loc_8E67
		cmp	[ebp+var_6C], 0
		jz	short loc_8CCD
		mov	eax, [ebp+var_6C]
		sub	eax, 1
		mov	esi, esp
		push	eax		; int
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	ecx, ax
		cmp	ecx, 3Bh ; ';'
		jnz	loc_8E67

loc_8CCD:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+16Ej
		mov	esi, esp
		mov	eax, [ebp+var_6C]
		push	eax		; int
		push	2		; int
		push	offset _gSemiPercent ; ";%"
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z ; icu_56::UnicodeString::indexOf(wchar_t	const *,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_78], eax
		cmp	[ebp+var_78], 0FFFFFFFFh
		jnz	short loc_8D0B
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, 1
		mov	[ebp+var_78], eax

loc_8D0B:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+1B9j
		push	offset _gLenientParse ;	"%%lenient-parse:"
		call	_u_strlen_56
		add	esp, 4
		add	eax, [ebp+var_6C]
		mov	[ebp+var_84], eax

loc_8D21:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+22Ej
		mov	esi, esp
		mov	eax, [ebp+var_84]
		push	eax		; int
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	ecx, ax
		mov	esi, esp
		push	ecx		; int
		call	dword ptr ds:__imp_?isWhiteSpace@PatternProps@icu_56@@SACH@Z ; icu_56::PatternProps::isWhiteSpace(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	edx, al
		test	edx, edx
		jz	short loc_8D68
		mov	eax, [ebp+var_84]
		add	eax, 1
		mov	[ebp+var_84], eax
		jmp	short loc_8D21
; ---------------------------------------------------------------------------

loc_8D68:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+21Dj
		mov	esi, esp
		push	40h ; '@'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_24C], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_24C], 0
		jz	short loc_8DBE
		mov	esi, esp
		mov	ecx, [ebp+var_24C] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_24C]
		mov	dword ptr [eax], offset	??_SUnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`local vftable'
		mov	ecx, [ebp+var_24C]
		mov	[ebp+var_260], ecx
		jmp	short loc_8DC8
; ---------------------------------------------------------------------------

loc_8DBE:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+255j
		mov	[ebp+var_260], 0

loc_8DC8:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+284j
		mov	edx, [ebp+var_260]
		mov	[ebp+var_258], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_258]
		mov	[eax+254h], ecx
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+254h], 0
		jnz	short loc_8E1A
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_951B
; ---------------------------------------------------------------------------

loc_8E1A:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+2B9j
		mov	eax, [ebp+var_78]
		sub	eax, [ebp+var_84]
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+var_84]
		push	ecx		; int
		lea	edx, [ebp+var_60]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+254h]	; this
		call	dword ptr ds:__imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_78]
		add	eax, 1
		sub	eax, [ebp+var_6C]
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+var_6C]
		push	ecx		; int
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z ; icu_56::UnicodeString::remove(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8E67:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+164j
					; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode	&)+18Fj
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+16Ch], 0
		mov	esi, esp
		push	0		; int
		push	2		; int
		push	offset _gSemiPercent ; ";%"
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z ; icu_56::UnicodeString::indexOf(wchar_t	const *,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_90], eax
		jmp	short loc_8EBD
; ---------------------------------------------------------------------------

loc_8E97:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+3B2j
		mov	esi, esp
		mov	eax, [ebp+var_90]
		push	eax		; int
		push	2		; int
		push	offset _gSemiPercent ; ";%"
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z ; icu_56::UnicodeString::indexOf(wchar_t	const *,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_90], eax

loc_8EBD:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+35Dj
		cmp	[ebp+var_90], 0FFFFFFFFh
		jz	short loc_8EEC
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+16Ch]
		add	ecx, 1
		mov	edx, [ebp+var_18]
		mov	[edx+16Ch], ecx
		mov	eax, [ebp+var_90]
		add	eax, 1
		mov	[ebp+var_90], eax
		jmp	short loc_8E97
; ---------------------------------------------------------------------------

loc_8EEC:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+38Cj
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+16Ch]
		add	ecx, 1
		mov	edx, [ebp+var_18]
		mov	[edx+16Ch], ecx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+16Ch]
		lea	edx, ds:4[ecx*4]
		push	edx
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_18]
		mov	[ecx+164h], eax
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+164h], 0
		jnz	short loc_8F56
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_951B
; ---------------------------------------------------------------------------

loc_8F56:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+3F5j
		mov	[ebp+var_9C], 0
		jmp	short loc_8F71
; ---------------------------------------------------------------------------

loc_8F62:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+460j
		mov	eax, [ebp+var_9C]
		add	eax, 1
		mov	[ebp+var_9C], eax

loc_8F71:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+428j
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_9C]
		cmp	ecx, [eax+16Ch]
		jg	short loc_8F9A
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+164h]
		mov	edx, [ebp+var_9C]
		mov	dword ptr [ecx+edx*4], 0
		jmp	short loc_8F62
; ---------------------------------------------------------------------------

loc_8F9A:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+448j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+16Ch], 0
		jnz	short loc_8FCD
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_951B
; ---------------------------------------------------------------------------

loc_8FCD:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+46Cj
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+16Ch]
		mov	[ebp+var_240], ecx
		cmp	[ebp+var_240], 0
		jnz	short loc_8FF7
		push	4		; unsigned int
		call	??_U@YAPAXI@Z	; operator new[](uint)
		add	esp, 4
		mov	[ebp+var_260], eax
		jmp	short loc_9032
; ---------------------------------------------------------------------------

loc_8FF7:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+4ABj
		xor	ecx, ecx
		mov	eax, [ebp+var_240]
		mov	edx, 40h ; '@'
		mul	edx
		seto	cl
		neg	ecx
		or	ecx, eax
		xor	eax, eax
		add	ecx, 4
		setb	al
		neg	eax
		or	eax, ecx
		mov	esi, esp
		push	eax		; unsigned int
		call	dword ptr ds:__imp_??_UUMemory@icu_56@@SAPAXI@Z	; icu_56::UMemory::operator new[](uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_260], eax

loc_9032:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+4BDj
		mov	ecx, [ebp+var_260] ; this
		mov	[ebp+var_228], ecx
		mov	byte ptr [ebp+var_4], 2
		cmp	[ebp+var_228], 0
		jz	short loc_908E
		mov	edx, [ebp+var_228]
		mov	eax, [ebp+var_240]
		mov	[edx], eax
		mov	ecx, dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		push	ecx
		push	offset ??_TUnicodeString@icu_56@@QAEXXZ	; icu_56::UnicodeString::`local	vftable	constructor closure'(void)
		mov	edx, [ebp+var_240]
		push	edx
		push	40h ; '@'
		mov	eax, [ebp+var_228]
		add	eax, 4
		push	eax
		call	??_L@YGXPAXIHP6EX0@Z1@Z	; `eh vector constructor iterator'(void *,uint,int,void (*)(void *),void (*)(void *))
		mov	ecx, [ebp+var_228]
		add	ecx, 4
		mov	[ebp+var_264], ecx
		jmp	short loc_9098
; ---------------------------------------------------------------------------

loc_908E:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+511j
		mov	[ebp+var_264], 0

loc_9098:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+554j
		mov	edx, [ebp+var_264]
		mov	[ebp+var_234], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_234]
		mov	[eax+168h], ecx
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+168h], 0
		jnz	short loc_90EA
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_951B
; ---------------------------------------------------------------------------

loc_90EA:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+589j
		mov	[ebp+var_A8], 0
		mov	[ebp+var_B4], 0
		mov	esi, esp
		push	0		; int
		push	2		; int
		push	offset _gSemiPercent ; ";%"
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z ; icu_56::UnicodeString::indexOf(wchar_t	const *,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_C0], eax
		jmp	short loc_9147
; ---------------------------------------------------------------------------

loc_9121:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+737j
		mov	esi, esp
		mov	eax, [ebp+var_B4]
		push	eax		; int
		push	2		; int
		push	offset _gSemiPercent ; ";%"
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z ; icu_56::UnicodeString::indexOf(wchar_t	const *,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_C0], eax

loc_9147:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+5E7j
		cmp	[ebp+var_C0], 0FFFFFFFFh
		jz	loc_9274
		mov	eax, [ebp+var_C0]
		add	eax, 1
		sub	eax, [ebp+var_B4]
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+var_B4]
		push	ecx		; int
		lea	edx, [ebp+var_60]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_A8]
		shl	ecx, 6
		mov	eax, [ebp+var_18]
		add	ecx, [eax+168h]	; this
		call	dword ptr ds:__imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	78h ; 'x'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_210], eax
		mov	byte ptr [ebp+var_4], 3
		cmp	[ebp+var_210], 0
		jz	short loc_91E3
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_A8]
		push	ecx		; int
		mov	edx, [ebp+var_18]
		mov	eax, [edx+168h]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		push	ecx		; struct icu_56::RuleBasedNumberFormat *
		mov	ecx, [ebp+var_210] ; this
		call	??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z ; icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)
		mov	[ebp+var_260], eax
		jmp	short loc_91ED
; ---------------------------------------------------------------------------

loc_91E3:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+67Dj
		mov	[ebp+var_260], 0

loc_91ED:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+6A9j
		mov	edx, [ebp+var_260]
		mov	[ebp+var_21C], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+164h]
		mov	edx, [ebp+var_A8]
		mov	eax, [ebp+var_21C]
		mov	[ecx+edx*4], eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+164h]
		mov	edx, [ebp+var_A8]
		cmp	dword ptr [ecx+edx*4], 0
		jnz	short loc_9251
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_951B
; ---------------------------------------------------------------------------

loc_9251:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+6F0j
		mov	eax, [ebp+var_A8]
		add	eax, 1
		mov	[ebp+var_A8], eax
		mov	eax, [ebp+var_C0]
		add	eax, 1
		mov	[ebp+var_B4], eax
		jmp	loc_9121
; ---------------------------------------------------------------------------

loc_9274:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+616j
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+var_B4]
		mov	esi, esp
		push	eax		; int
		mov	eax, [ebp+var_B4]
		push	eax		; int
		lea	ecx, [ebp+var_60]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_A8]
		shl	ecx, 6
		mov	edx, [ebp+var_18]
		add	ecx, [edx+168h]	; this
		call	dword ptr ds:__imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	78h ; 'x'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1F8], eax
		mov	byte ptr [ebp+var_4], 4
		cmp	[ebp+var_1F8], 0
		jz	short loc_930C
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_A8]
		push	ecx		; int
		mov	edx, [ebp+var_18]
		mov	eax, [edx+168h]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		push	ecx		; struct icu_56::RuleBasedNumberFormat *
		mov	ecx, [ebp+var_1F8] ; this
		call	??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z ; icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)
		mov	[ebp+var_260], eax
		jmp	short loc_9316
; ---------------------------------------------------------------------------

loc_930C:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+7A6j
		mov	[ebp+var_260], 0

loc_9316:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+7D2j
		mov	edx, [ebp+var_260]
		mov	[ebp+var_204], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+164h]
		mov	edx, [ebp+var_A8]
		mov	eax, [ebp+var_204]
		mov	[ecx+edx*4], eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+164h]
		mov	edx, [ebp+var_A8]
		cmp	dword ptr [ecx+edx*4], 0
		jnz	short loc_937A
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_951B
; ---------------------------------------------------------------------------

loc_937A:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+819j
		mov	ecx, [ebp+var_18] ; this
		call	?initDefaultRuleSet@RuleBasedNumberFormat@icu_56@@AAEXXZ ; icu_56::RuleBasedNumberFormat::initDefaultRuleSet(void)
		mov	[ebp+var_CC], 0
		jmp	short loc_939D
; ---------------------------------------------------------------------------

loc_938E:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+8A4j
		mov	eax, [ebp+var_CC]
		add	eax, 1
		mov	[ebp+var_CC], eax

loc_939D:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+854j
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_CC]
		cmp	ecx, [eax+16Ch]
		jge	short loc_93DE
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_CC]
		shl	ecx, 6
		mov	edx, [ebp+var_18]
		add	ecx, [edx+168h]
		push	ecx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+164h]
		mov	edx, [ebp+var_CC]
		mov	ecx, [ecx+edx*4] ; this
		call	?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z	; icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)
		jmp	short loc_938E
; ---------------------------------------------------------------------------

loc_93DE:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+874j
		cmp	[ebp+arg_4], 0
		jz	loc_94D5
		mov	[ebp+var_D8], 0
		jmp	short loc_9403
; ---------------------------------------------------------------------------

loc_93F4:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+996j
		mov	eax, [ebp+var_D8]
		add	eax, 1
		mov	[ebp+var_D8], eax

loc_9403:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+8BAj
		mov	eax, [ebp+arg_4]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_4]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_D8], eax
		jge	loc_94D3
		mov	esi, esp
		push	0FFFFFFFFh	; int
		mov	edi, esp
		mov	eax, [ebp+var_D8]
		push	eax
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_4]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax		; wchar_t *
		push	1		; signed __int8
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 5
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_120]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?findRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::findRuleSet(icu_56::UnicodeString const &,UErrorCode &)
		mov	[ebp+var_12C], eax
		cmp	[ebp+var_12C], 0
		jnz	short loc_949D
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_94D3
; ---------------------------------------------------------------------------

loc_949D:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+948j
		cmp	[ebp+var_D8], 0
		jnz	short loc_94B5
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_12C]
		mov	[eax+170h], ecx

loc_94B5:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+96Cj
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_93F4
; ---------------------------------------------------------------------------

loc_94D3:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+8E7j
					; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode	&)+963j
		jmp	short loc_94E6
; ---------------------------------------------------------------------------

loc_94D5:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+8AAj
		mov	ecx, [ebp+var_18] ; this
		call	?getDefaultRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@XZ ;	icu_56::RuleBasedNumberFormat::getDefaultRuleSet(void)
		mov	ecx, [ebp+var_18]
		mov	[ecx+170h], eax

loc_94E6:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &):loc_94D3j
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_18]
		add	ecx, 25Ch
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_951B:				; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+6Aj
					; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode	&)+A8j	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN59
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 264h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN59		dd 2			; DATA XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+9E7o
		dd offset $LN58
$LN58		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:0000955Co
		dd offset $LN55		; "description"
		dd 0FFFFFEE0h, 40h
		dd offset $LN56		; "name"
$LN56		db 'name',0             ; DATA XREF: .text:00009574o
$LN55		db 'description',0      ; DATA XREF: .text:00009568o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 958Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00009694o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000969Co
		mov	esi, esp
		mov	eax, [ebp-24Ch]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:000096A4o
		mov	esi, esp
		mov	eax, [ebp-228h]
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:000096ACo
		mov	esi, esp
		mov	eax, [ebp-210h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$4 proc near
					; DATA XREF: .xdata$x:000096B4o
		mov	esi, esp
		mov	eax, [ebp-1F8h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$5 proc near
					; DATA XREF: .xdata$x:000096BCo
		mov	esi, esp
		lea	ecx, [ebp-120h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$5 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-268h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9640h
		dd offset ??_R4UnicodeString@icu_56@@6B@ ; const icu_56::UnicodeString::`RTTI Complete Object Locator'
		public ??_SUnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`local vftable'
??_SUnicodeString@icu_56@@6B@ dd offset	??_EUnicodeString@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+272o
					; icu_56::UnicodeString::`local	vftable	constructor closure'(void)+38o
					; icu_56::UnicodeString::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ ; icu_56::UnicodeString::getDynamicClassID(void)
		dd offset ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z ; icu_56::UnicodeString::extractBetween(int,int,icu_56::UnicodeString &)
		dd offset ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z ; icu_56::UnicodeString::handleReplaceBetween(int,int,icu_56::UnicodeString const &)
		dd offset ?copy@UnicodeString@icu_56@@UAEXHHH@Z	; icu_56::UnicodeString::copy(int,int,int)
		dd offset ?hasMetaData@UnicodeString@icu_56@@UBECXZ ; icu_56::UnicodeString::hasMetaData(void)
		dd offset ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ ;	icu_56::UnicodeString::clone(void)
		dd offset ?getLength@UnicodeString@icu_56@@MBEHXZ ; icu_56::UnicodeString::getLength(void)
		dd offset ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z ; icu_56::UnicodeString::getCharAt(int)
		dd offset ?getChar32At@UnicodeString@icu_56@@MBEHH@Z ; icu_56::UnicodeString::getChar32At(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 966Ch
__ehfuncinfo$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z dd 19930522h, 6
					; DATA XREF: __ehhandler$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00009674o
		dd offset __unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$1
		dd 0
		dd offset __unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$2
		dd 0
		dd offset __unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$3
		dd 0
		dd offset __unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$4
		dd 0
		dd offset __unwindfunclet$?init@RuleBasedNumberFormat@icu_56@@AAEXABVUnicodeString@2@PAVLocalizationInfo@2@AAUUParseError@@AAW4UErrorCode@@@Z$5
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 96C0h
		public ??_R4UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`RTTI Complete Object Locator'
??_R4UnicodeString@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00009640o
		dd offset ??_R0?AVUnicodeString@icu_56@@@8 ; icu_56::UnicodeString `RTTI Type Descriptor'
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 96D4h
		public ??_R0?AVUnicodeString@icu_56@@@8
; class	icu_56::UnicodeString `RTTI Type Descriptor'
??_R0?AVUnicodeString@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000096CCo
					; .rdata$r:icu_56::UnicodeString::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodestr	db '.?AVUnicodeString@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 96F8h
		public ??_R3UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeString@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:000096D0o
					; .rdata$r:00009734o
		dd 4
		dd offset ??_R2UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9708h
		public ??_R2UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Array'
??_R2UnicodeString@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeString@icu_56@@8
					; DATA XREF: .rdata$r:00009704o
					; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8 ;	icu_56::Replaceable::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 971Ch
		public ??_R1A@?0A@EA@UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeString@icu_56@@8 dd offset	??_R0?AVUnicodeString@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeString::`RTTI Base	Class Array'o
					; icu_56::UnicodeString	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9738h
		public ??_R1A@?0A@EA@Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Replaceable@icu_56@@8 dd offset ??_R0?AVReplaceable@icu_56@@@8
					; DATA XREF: .rdata$r:0000970Co
					; .rdata$r:icu_56::Replaceable::`RTTI Base Class Array'o
					; icu_56::Replaceable `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 9754h
		public ??_R0?AVReplaceable@icu_56@@@8
; class	icu_56::Replaceable `RTTI Type Descriptor'
??_R0?AVReplaceable@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::Replaceable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avreplaceabl	db '.?AVReplaceable@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9778h
		public ??_R3Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Class Hierarchy Descriptor'
??_R3Replaceable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00009750o
		dd 3
		dd offset ??_R2Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9788h
		public ??_R2Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Array'
??_R2Replaceable@icu_56@@8 dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8
					; DATA XREF: .rdata$r:00009784o
					; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9798h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new[](unsigned	int)
		public ??_U@YAPAXI@Z
??_U@YAPAXI@Z	proc near		; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+4AFp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??_U@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 97D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeString@icu_56@@UAEPAXI@Z
??_EUnicodeString@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeString::`local	vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx		; this
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_983C
		mov	eax, dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx-4]
		push	edx
		push	40h ; '@'
		mov	eax, [ebp+var_8]
		push	eax
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_9834
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9834:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+49j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_986F
; ---------------------------------------------------------------------------

loc_983C:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+29j
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_986C
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_986C:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+84j
		mov	eax, [ebp+var_8]

loc_986F:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+6Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeString@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9888h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::UnicodeString::`local	vftable	constructor closure'(void)
		public ??_TUnicodeString@icu_56@@QAEXXZ
??_TUnicodeString@icu_56@@QAEXXZ proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+528o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_SUnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`local vftable'
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??_TUnicodeString@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 98DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void __thiscall icu_56::RuleBasedNumberFormat::setContext(enum  UDisplayContext, enum	 UErrorCode &)
		public ?setContext@RuleBasedNumberFormat@icu_56@@UAEXW4UDisplayContext@@AAW4UErrorCode@@@Z
?setContext@RuleBasedNumberFormat@icu_56@@UAEXW4UDisplayContext@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:0000470Co

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?setContext@NumberFormat@icu_56@@UAEXW4UDisplayContext@@AAW4UErrorCode@@@Z ; icu_56::NumberFormat::setContext(UDisplayContext,UErrorCode &)
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_9A55
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+29Ch]
		test	ecx, ecx
		jnz	short loc_9963
		cmp	[ebp+arg_0], 103h
		jz	short loc_9948
		cmp	[ebp+arg_0], 104h
		jnz	short loc_9963

loc_9948:				; CODE XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+61j
		mov	eax, [ebp+var_8]
		add	eax, 174h
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_8] ; this
		call	?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z	; icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+29Ch], 1

loc_9963:				; CODE XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+58j
					; icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+6Aj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+2A0h], 0
		jnz	loc_9A55
		cmp	[ebp+arg_0], 102h
		jz	short loc_99B2
		cmp	[ebp+arg_0], 103h
		jnz	short loc_9993
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+29Dh]
		test	ecx, ecx
		jnz	short loc_99B2

loc_9993:				; CODE XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+A7j
		cmp	[ebp+arg_0], 104h
		jnz	loc_9A55
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+29Eh]
		test	ecx, ecx
		jz	loc_9A55

loc_99B2:				; CODE XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+9Ej
					; icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+B5j
		mov	[ebp+var_14], 0
		mov	esi, esp
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		add	ecx, 174h
		push	ecx		; struct icu_56::Locale	*
		call	dword ptr ds:__imp_?createSentenceInstance@BreakIterator@icu_56@@SAPAV12@ABVLocale@2@AAW4UErrorCode@@@Z	; icu_56::BreakIterator::createSentenceInstance(icu_56::Locale const &,UErrorCode &)
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_8]
		mov	[edx+2A0h], eax
		mov	eax, [ebp+var_14]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_9A55
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2A0h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_9A3E
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_9A48
; ---------------------------------------------------------------------------

loc_9A3E:				; CODE XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+13Bj
		mov	[ebp+var_F4], 0

loc_9A48:				; CODE XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+160j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+2A0h], 0

loc_9A55:				; CODE XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+46j
					; icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+91j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setContext@RuleBasedNumberFormat@icu_56@@UAEXW4UDisplayContext@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN14_0		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+17Do
		dd offset $LN13_4
$LN13_4		dd 0FFFFFFECh, 4	; DATA XREF: .text:00009A80o
		dd offset $LN12_2	; "status"
$LN12_2		db 'status',0           ; DATA XREF: .text:00009A8Co
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9A98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::RuleBasedNumberFormat *this, const struct icu_56::Locale	*)
		public ?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z
?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z	proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+78p

var_1F0		= dword	ptr -1F0h
var_1E8		= byte ptr -1E8h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1F0]
		mov	ecx, 79h ; 'y'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	esi, esp
		push	0		; char *
		push	0		; char *
		push	0		; char *
		push	0		; char *
		lea	ecx, [ebp+var_1E8] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@PBD000@Z ; icu_56::Locale::Locale(char	const *,char const *,char const	*,char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		lea	eax, [ebp+var_1E8]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??9Locale@icu_56@@QBECABV01@@Z ; icu_56::Locale::operator!=(icu_56::Locale const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_9B3B
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?getBaseName@Locale@icu_56@@QBEPBDXZ	; icu_56::Locale::getBaseName(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1F0], eax
		jmp	short loc_9B45
; ---------------------------------------------------------------------------

loc_9B3B:				; CODE XREF: icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+87j
		mov	[ebp+var_1F0], 0

loc_9B45:				; CODE XREF: icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+A1j
		mov	edx, [ebp+var_1F0]
		mov	[ebp+var_24], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_1E8] ; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_30], 0
		lea	eax, [ebp+var_30]
		push	eax
		mov	ecx, [ebp+var_24]
		push	ecx
		push	0
		call	_ures_open_56
		add	esp, 0Ch
		mov	[ebp+var_3C], eax
		lea	eax, [ebp+var_30]
		push	eax
		mov	ecx, [ebp+var_3C]
		push	ecx
		push	offset ??_C@_0BC@FDCOHBMP@contextTransforms?$AA@ ; "contextTransforms"
		mov	edx, [ebp+var_3C]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	[ebp+var_3C], eax
		lea	eax, [ebp+var_30]
		push	eax
		mov	ecx, [ebp+var_3C]
		push	ecx
		push	offset ??_C@_0BA@CDOAOKDP@number?9spellout?$AA@	; "number-spellout"
		mov	edx, [ebp+var_3C]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	[ebp+var_3C], eax
		mov	eax, [ebp+var_30]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_9C31
		cmp	[ebp+var_3C], 0
		jz	short loc_9C31
		mov	[ebp+var_48], 0
		lea	eax, [ebp+var_30]
		push	eax
		lea	ecx, [ebp+var_48]
		push	ecx
		mov	edx, [ebp+var_3C]
		push	edx
		call	_ures_getIntVector_56
		add	esp, 0Ch
		mov	[ebp+var_54], eax
		mov	eax, [ebp+var_30]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_9C31
		cmp	[ebp+var_54], 0
		jz	short loc_9C31
		cmp	[ebp+var_48], 2
		jl	short loc_9C31
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_54]
		mov	dl, [ecx]
		mov	[eax+29Dh], dl
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_54]
		mov	dl, [ecx+4]
		mov	[eax+29Eh], dl

loc_9C31:				; CODE XREF: icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+137j
					; icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+13Dj ...
		mov	eax, [ebp+var_3C]
		push	eax
		call	_ures_close_56
		add	esp, 4
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN12_3		dd 2			; DATA XREF: icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+1A9o
		dd offset $LN11_2
$LN11_2		dd 0FFFFFFD0h, 4	; DATA XREF: .text:00009C80o
		dd offset $LN8_4	; "status"
		dd 0FFFFFFB8h, 4
		dd offset $LN9_5
$LN9_5		dd 6E656Ch		; DATA XREF: .text:00009C98o
$LN8_4		db 'status',0           ; DATA XREF: .text:00009C8Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 9CA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z$0 proc near
					; DATA XREF: .xdata$x:00009D10o
		mov	esi, esp
		lea	ecx, [ebp-1E8h]	; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1F4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9CE8h
		public ??_C@_0BA@CDOAOKDP@number?9spellout?$AA@
; `string'
??_C@_0BA@CDOAOKDP@number?9spellout?$AA@ db 'number-spellout',0
					; DATA XREF: icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+112o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9CF8h
		public ??_C@_0BC@FDCOHBMP@contextTransforms?$AA@
; `string'
??_C@_0BC@FDCOHBMP@contextTransforms?$AA@ db 'contextTransforms',0
					; DATA XREF: icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+F6o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 9D0Ch
__unwindtable$?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00009D1Co
		dd offset __unwindfunclet$?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z$0
__ehfuncinfo$?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z+1Eo
		dd offset __unwindtable$?initCapitalizationContextInfo@RuleBasedNumberFormat@icu_56@@AAEXABVLocale@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::RuleBasedNumberFormat *this, struct icu_56::UnicodeString *)
		public ?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z
?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+13Dp

var_13C		= byte ptr -13Ch
var_78		= dword	ptr -78h
var_6C		= dword	ptr -6Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 130h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Ch ; 'L'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	[ebp+var_6C], 0

loc_9D9D:				; CODE XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &):loc_9EBEj
		cmp	[ebp+var_6C], 0FFFFFFFFh
		jz	loc_9EC3
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_6C], eax
		jge	loc_9EC3

loc_9DC2:				; CODE XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+DDj
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_6C], eax
		jge	short loc_9E17
		mov	esi, esp
		mov	eax, [ebp+var_6C]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	ecx, ax
		mov	esi, esp
		push	ecx		; int
		call	dword ptr ds:__imp_?isWhiteSpace@PatternProps@icu_56@@SACH@Z ; icu_56::PatternProps::isWhiteSpace(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	edx, al
		test	edx, edx
		jz	short loc_9E17
		mov	eax, [ebp+var_6C]
		add	eax, 1
		mov	[ebp+var_6C], eax
		jmp	short loc_9DC2
; ---------------------------------------------------------------------------

loc_9E17:				; CODE XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+9Fj
					; icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+D2j
		mov	esi, esp
		mov	eax, [ebp+var_6C]
		push	eax		; int
		push	3Bh ; ';'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEH_WH@Z ; icu_56::UnicodeString::indexOf(wchar_t,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_78], eax
		cmp	[ebp+var_78], 0FFFFFFFFh
		jnz	short loc_9E71
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+var_6C]
		mov	esi, esp
		push	eax		; int
		mov	eax, [ebp+var_6C]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_6C], 0FFFFFFFFh
		jmp	short loc_9EBE
; ---------------------------------------------------------------------------

loc_9E71:				; CODE XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+FEj
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_78], eax
		jge	short loc_9EB7
		mov	eax, [ebp+var_78]
		add	eax, 1
		sub	eax, [ebp+var_6C]
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+var_6C]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_78]
		add	eax, 1
		mov	[ebp+var_6C], eax
		jmp	short loc_9EBE
; ---------------------------------------------------------------------------

loc_9EB7:				; CODE XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+14Ej
		mov	[ebp+var_6C], 0FFFFFFFFh

loc_9EBE:				; CODE XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+137j
					; icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+17Dj
		jmp	loc_9D9D
; ---------------------------------------------------------------------------

loc_9EC3:				; CODE XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+69j
					; icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+84j
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN15_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN15_1		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+1BEo
		dd offset $LN14_1
$LN14_1		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:00009F34o
		dd offset $LN12_4	; "result"
$LN12_4		db 'result',0           ; DATA XREF: .text:00009F40o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 9F4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z$0 proc	near
					; DATA XREF: .xdata$x:00009F8Co
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-140h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 9F88h
__unwindtable$?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00009F98o
		dd offset __unwindfunclet$?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z$0
__ehfuncinfo$?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z+1Eo
		dd offset __unwindtable$?stripWhitespace@RuleBasedNumberFormat@icu_56@@AAEXAAVUnicodeString@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9FB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedNumberFormat::dispose(icu_56::RuleBasedNumberFormat *__hidden this)
		public ?dispose@RuleBasedNumberFormat@icu_56@@AAEXXZ
?dispose@RuleBasedNumberFormat@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+6Bp
					; icu_56::RuleBasedNumberFormat::~RuleBasedNumberFormat(void)+55p

var_1AC		= dword	ptr -1ACh
var_1A8		= dword	ptr -1A8h
var_1A0		= dword	ptr -1A0h
var_194		= dword	ptr -194h
var_188		= dword	ptr -188h
var_17C		= dword	ptr -17Ch
var_170		= dword	ptr -170h
var_164		= dword	ptr -164h
var_158		= dword	ptr -158h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 1ACh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1AC]
		mov	ecx, 6Bh ; 'k'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+164h], 0
		jz	short loc_A062
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+164h]
		mov	[ebp+var_14], ecx
		jmp	short loc_9FFA
; ---------------------------------------------------------------------------

loc_9FF1:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void):loc_A041j
		mov	eax, [ebp+var_14]
		add	eax, 4
		mov	[ebp+var_14], eax

loc_9FFA:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+3Bj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax], 0
		jz	short loc_A043
		mov	eax, [ebp+var_14]
		mov	ecx, [eax]
		mov	[ebp+var_194], ecx
		mov	edx, [ebp+var_194]
		mov	[ebp+var_1A0], edx
		cmp	[ebp+var_1A0], 0
		jz	short loc_A037
		push	1
		mov	ecx, [ebp+var_1A0]
		call	??_GNFRuleSet@icu_56@@QAEPAXI@Z	; icu_56::NFRuleSet::`scalar deleting destructor'(uint)
		mov	[ebp+var_1A8], eax
		jmp	short loc_A041
; ---------------------------------------------------------------------------

loc_A037:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+6Cj
		mov	[ebp+var_1A8], 0

loc_A041:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+81j
		jmp	short loc_9FF1
; ---------------------------------------------------------------------------

loc_A043:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+4Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+164h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+164h], 0

loc_A062:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+2Dj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+168h], 0
		jz	loc_A114
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		mov	[ebp+var_170], ecx
		mov	edx, [ebp+var_170]
		mov	[ebp+var_17C], edx
		mov	eax, [ebp+var_17C]
		mov	[ebp+var_188], eax
		cmp	[ebp+var_188], 0
		jz	short loc_A0FD
		mov	ecx, [ebp+var_188]
		cmp	dword ptr [ecx-4], 0
		jz	short loc_A0D3
		mov	esi, esp
		push	3
		mov	edx, [ebp+var_17C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_17C]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1A8], eax
		jmp	short loc_A0EF
; ---------------------------------------------------------------------------

loc_A0D3:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+F8j
		mov	eax, [ebp+var_188]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4
		mov	[ebp+var_1A8], 0

loc_A0EF:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+11Dj
		mov	ecx, [ebp+var_1A8]
		mov	[ebp+var_1AC], ecx
		jmp	short loc_A107
; ---------------------------------------------------------------------------

loc_A0FD:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+ECj
		mov	[ebp+var_1AC], 0

loc_A107:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+147j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+168h], 0

loc_A114:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+B8j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+240h]
		mov	[ebp+var_158], ecx
		mov	edx, [ebp+var_158]
		mov	[ebp+var_164], edx
		cmp	[ebp+var_164], 0
		jz	short loc_A15D
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_164]
		mov	edx, [eax]
		mov	ecx, [ebp+var_164]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1A8], eax
		jmp	short loc_A167
; ---------------------------------------------------------------------------

loc_A15D:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+182j
		mov	[ebp+var_1A8], 0

loc_A167:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+1A7j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+240h], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+244h]
		mov	[ebp+var_140], ecx
		mov	edx, [ebp+var_140]
		mov	[ebp+var_14C], edx
		cmp	[ebp+var_14C], 0
		jz	short loc_A1BD
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_14C]
		mov	edx, [eax]
		mov	ecx, [ebp+var_14C]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1A8], eax
		jmp	short loc_A1C7
; ---------------------------------------------------------------------------

loc_A1BD:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+1E2j
		mov	[ebp+var_1A8], 0

loc_A1C7:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+207j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+244h], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+248h]
		mov	[ebp+var_128], ecx
		mov	edx, [ebp+var_128]
		mov	[ebp+var_134], edx
		cmp	[ebp+var_134], 0
		jz	short loc_A20D
		push	1
		mov	ecx, [ebp+var_134]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_1A8], eax
		jmp	short loc_A217
; ---------------------------------------------------------------------------

loc_A20D:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+242j
		mov	[ebp+var_1A8], 0

loc_A217:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+257j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+248h], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24Ch]
		mov	[ebp+var_110], ecx
		mov	edx, [ebp+var_110]
		mov	[ebp+var_11C], edx
		cmp	[ebp+var_11C], 0
		jz	short loc_A25D
		push	1
		mov	ecx, [ebp+var_11C]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_1A8], eax
		jmp	short loc_A267
; ---------------------------------------------------------------------------

loc_A25D:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+292j
		mov	[ebp+var_1A8], 0

loc_A267:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+2A7j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+24Ch], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+254h]
		mov	[ebp+var_F8], ecx
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_104], edx
		cmp	[ebp+var_104], 0
		jz	short loc_A2BD
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_104]
		mov	edx, [eax]
		mov	ecx, [ebp+var_104]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1A8], eax
		jmp	short loc_A2C7
; ---------------------------------------------------------------------------

loc_A2BD:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+2E2j
		mov	[ebp+var_1A8], 0

loc_A2C7:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+307j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+254h], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2A0h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_A31D
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1A8], eax
		jmp	short loc_A327
; ---------------------------------------------------------------------------

loc_A31D:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+342j
		mov	[ebp+var_1A8], 0

loc_A327:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+367j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+2A0h], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+258h], 0
		jz	short loc_A357
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+258h]	; this
		call	?unref@LocalizationInfo@icu_56@@QAEPAV12@XZ ; icu_56::LocalizationInfo::unref(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+258h], eax

loc_A357:				; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+38Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 1ACh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?dispose@RuleBasedNumberFormat@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A36Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete[](void *)
		public ??_V@YAXPAX@Z
??_V@YAXPAX@Z	proc near		; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+129p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??_V@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A3A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::NFRule::`scalar deleting destructor'(unsigned int)
		public ??_GNFRule@icu_56@@QAEPAXI@Z
??_GNFRule@icu_56@@QAEPAXI@Z proc near	; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+24Cp
					; icu_56::RuleBasedNumberFormat::dispose(void)+29Cp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1NFRule@icu_56@@QAE@XZ ; icu_56::NFRule::~NFRule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_A3E9
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A3E9:				; CODE XREF: icu_56::NFRule::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GNFRule@icu_56@@QAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A404h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::LocalizationInfo *__thiscall icu_56::LocalizationInfo::unref(icu_56::LocalizationInfo *__hidden this)
		public ?unref@LocalizationInfo@icu_56@@QAEPAV12@XZ
?unref@LocalizationInfo@icu_56@@QAEPAV12@XZ proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+395p

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		jz	short loc_A4A1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		mov	[ebp+var_E8], ecx
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+var_E8]
		mov	[edx+4], eax
		cmp	[ebp+var_E8], 0
		jnz	short loc_A4A1
		mov	eax, [ebp+var_8]
		mov	[ebp+var_D4], eax
		mov	ecx, [ebp+var_D4]
		mov	[ebp+var_E0], ecx
		cmp	[ebp+var_E0], 0
		jz	short loc_A497
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_E0]
		mov	eax, [edx]
		mov	ecx, [ebp+var_E0]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E8], eax
		jmp	short loc_A4A1
; ---------------------------------------------------------------------------

loc_A497:				; CODE XREF: icu_56::LocalizationInfo::unref(void)+6Cj
		mov	[ebp+var_E8], 0

loc_A4A1:				; CODE XREF: icu_56::LocalizationInfo::unref(void)+2Aj
					; icu_56::LocalizationInfo::unref(void)+4Ej ...
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?unref@LocalizationInfo@icu_56@@QAEPAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A4B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::NFRuleSet::`scalar deleting	destructor'(unsigned int)
		public ??_GNFRuleSet@icu_56@@QAEPAXI@Z
??_GNFRuleSet@icu_56@@QAEPAXI@Z	proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::dispose(void)+76p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1NFRuleSet@icu_56@@QAE@XZ ; icu_56::NFRuleSet::~NFRuleSet(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_A501
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A501:				; CODE XREF: icu_56::NFRuleSet::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GNFRuleSet@icu_56@@QAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A51Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::RuleBasedCollator *__thiscall icu_56::RuleBasedNumberFormat::getCollator(icu_56::RuleBasedNumberFormat *__hidden	this)
		public ?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ
?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ	proc near

var_1A0		= dword	ptr -1A0h
var_198		= dword	ptr -198h
var_18C		= dword	ptr -18Ch
var_180		= dword	ptr -180h
var_174		= dword	ptr -174h
var_168		= dword	ptr -168h
var_15C		= dword	ptr -15Ch
var_150		= dword	ptr -150h
var_84		= byte ptr -84h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 194h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1A0]
		mov	ecx, 65h ; 'e'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+164h], 0
		jnz	short loc_A574
		xor	eax, eax
		jmp	loc_A7F1
; ---------------------------------------------------------------------------

loc_A574:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+4Fj
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+240h], 0
		jnz	loc_A7E8
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+250h]
		test	ecx, ecx
		jz	loc_A7E8
		mov	[ebp+var_24], 0
		lea	eax, [ebp+var_24]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_18]
		add	ecx, 174h
		push	ecx		; struct icu_56::Locale	*
		call	?createInstance@Collator@icu_56@@SAPAV12@ABVLocale@2@AAW4UErrorCode@@@Z	; icu_56::Collator::createInstance(icu_56::Locale const	&,UErrorCode &)
		add	esp, 8
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_24]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_A79B
		push	0
		push	offset ??_R0?AVRuleBasedCollator@icu_56@@@8 ; icu_56::RuleBasedCollator	`RTTI Type Descriptor'
		push	offset ??_R0?AVCollator@icu_56@@@8 ; icu_56::Collator `RTTI Type Descriptor'
		push	0
		mov	eax, [ebp+var_30]
		push	eax
		call	___RTDynamicCast
		add	esp, 14h
		mov	[ebp+var_3C], eax
		cmp	[ebp+var_3C], 0
		jz	loc_A79B
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+254h], 0
		jz	loc_A708
		mov	ecx, [ebp+var_3C] ; this
		call	?getRules@RuleBasedCollator@icu_56@@QBEABVUnicodeString@2@XZ ; icu_56::RuleBasedCollator::getRules(void)
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_84] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+254h]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_84] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0E8h ; ''      ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_18C], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_18C], 0
		jz	short loc_A690
		lea	eax, [ebp+var_24]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_84]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18C] ; this
		call	??0RuleBasedCollator@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z ; icu_56::RuleBasedCollator::RuleBasedCollator(icu_56::UnicodeString const &,UErrorCode &)
		mov	[ebp+var_1A0], eax
		jmp	short loc_A69A
; ---------------------------------------------------------------------------

loc_A690:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+154j
		mov	[ebp+var_1A0], 0

loc_A69A:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+172j
		mov	edx, [ebp+var_1A0]
		mov	[ebp+var_198], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_198]
		mov	[ebp+var_3C], eax
		cmp	[ebp+var_3C], 0
		jnz	short loc_A6EA
		mov	[ebp+var_180], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_84] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_180]
		jmp	loc_A7F1
; ---------------------------------------------------------------------------

loc_A6EA:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+19Bj
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_84] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_A70F
; ---------------------------------------------------------------------------

loc_A708:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+E2j
		mov	[ebp+var_30], 0

loc_A70F:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+1EAj
		mov	eax, [ebp+var_24]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_A74E
		mov	esi, esp
		lea	eax, [ebp+var_24]
		push	eax
		push	11h
		push	4
		mov	ecx, [ebp+var_3C]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_3C]
		mov	eax, [edx+58h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_3C]
		mov	[eax+240h], ecx
		jmp	short loc_A79B
; ---------------------------------------------------------------------------

loc_A74E:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+204j
		mov	eax, [ebp+var_3C]
		mov	[ebp+var_168], eax
		mov	ecx, [ebp+var_168]
		mov	[ebp+var_174], ecx
		cmp	[ebp+var_174], 0
		jz	short loc_A791
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_174]
		mov	eax, [edx]
		mov	ecx, [ebp+var_174]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1A0], eax
		jmp	short loc_A79B
; ---------------------------------------------------------------------------

loc_A791:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+24Ej
		mov	[ebp+var_1A0], 0

loc_A79B:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+ABj
					; icu_56::RuleBasedNumberFormat::getCollator(void)+D2j	...
		mov	eax, [ebp+var_30]
		mov	[ebp+var_150], eax
		mov	ecx, [ebp+var_150]
		mov	[ebp+var_15C], ecx
		cmp	[ebp+var_15C], 0
		jz	short loc_A7DE
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_15C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_15C]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1A0], eax
		jmp	short loc_A7E8
; ---------------------------------------------------------------------------

loc_A7DE:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+29Bj
		mov	[ebp+var_1A0], 0

loc_A7E8:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+62j
					; icu_56::RuleBasedNumberFormat::getCollator(void)+74j	...
		mov	eax, [ebp+var_18]
		mov	eax, [eax+240h]

loc_A7F1:				; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+53j
					; icu_56::RuleBasedNumberFormat::getCollator(void)+1C9j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN23_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1A0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
$LN23_1		dd 2			; DATA XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+2D9o
		dd offset $LN22_3
$LN22_3		dd 0FFFFFFDCh, 4	; DATA XREF: .text:0000A830o
		dd offset $LN19_2	; "status"
		dd 0FFFFFF7Ch, 40h
		dd offset $LN20_3	; "rules"
$LN20_3		db 'rules',0            ; DATA XREF: .text:0000A848o
$LN19_2		db 'status',0           ; DATA XREF: .text:0000A83Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0A85Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ$0 proc near
					; DATA XREF: .xdata$x:0000A8B8o
		mov	esi, esp
		lea	ecx, [ebp-84h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ$1 proc near
					; DATA XREF: .xdata$x:0000A8C0o
		mov	esi, esp
		mov	eax, [ebp-18Ch]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1A4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0A8B4h
__unwindtable$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000A8CCo
		dd offset __unwindfunclet$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ$0
		align 10h
		dd offset __unwindfunclet$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ$1
__ehfuncinfo$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ dd	19930522h, 2
					; DATA XREF: __ehhandler$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ+1Eo
		dd offset __unwindtable$?getCollator@RuleBasedNumberFormat@icu_56@@ABEPBVRuleBasedCollator@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A8E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::DecimalFormatSymbols *__thiscall icu_56::RuleBasedNumberFormat::initializeDecimalFormatSymbols(icu_56::RuleBasedNumberFormat *this, enum UErrorCode *)
		public ?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z
?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+76p

var_118		= dword	ptr -118h
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+244h], 0
		jnz	loc_AA1E
		mov	esi, esp
		push	0AD4h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_104], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_104], 0
		jz	short loc_A988
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14]
		add	ecx, 174h
		push	ecx		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_104] ; this
		call	??0DecimalFormatSymbols@icu_56@@QAE@ABVLocale@1@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatSymbols::DecimalFormatSymbols(icu_56::Locale const &,UErrorCode &)
		mov	[ebp+var_118], eax
		jmp	short loc_A992
; ---------------------------------------------------------------------------

loc_A988:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &)+7Dj
		mov	[ebp+var_118], 0

loc_A992:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &)+9Ej
		mov	edx, [ebp+var_118]
		mov	[ebp+var_110], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_110]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A9D1
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_20]
		mov	[eax+244h], ecx
		jmp	short loc_AA1E
; ---------------------------------------------------------------------------

loc_A9D1:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &)+D9j
		mov	eax, [ebp+var_20]
		mov	[ebp+var_EC], eax
		mov	ecx, [ebp+var_EC]
		mov	[ebp+var_F8], ecx
		cmp	[ebp+var_F8], 0
		jz	short loc_AA14
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_F8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_F8]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_118], eax
		jmp	short loc_AA1E
; ---------------------------------------------------------------------------

loc_AA14:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &)+105j
		mov	[ebp+var_118], 0

loc_AA1E:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &)+4Cj
					; icu_56::RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &)+E7j ...
		mov	eax, [ebp+var_14]
		mov	eax, [eax+244h]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0AA48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:0000AA84o
		mov	esi, esp
		mov	eax, [ebp-104h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-11Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0AA80h
__unwindtable$?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000AA90o
		dd offset __unwindfunclet$?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?initializeDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@AAEPAVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AAACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::DecimalFormatSymbols *__thiscall	icu_56::RuleBasedNumberFormat::getDecimalFormatSymbols(icu_56::RuleBasedNumberFormat *__hidden this)
		public ?getDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@ABEPBVDecimalFormatSymbols@2@XZ
?getDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@ABEPBVDecimalFormatSymbols@2@XZ proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+A6p
					; icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+9Fp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+244h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@ABEPBVDecimalFormatSymbols@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AAE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::NFRule	*__thiscall icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(icu_56::RuleBasedNumberFormat *this, enum UErrorCode *)
		public ?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z
?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+82p
					; icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols	*)+F7p

var_1B0		= dword	ptr -1B0h
var_1AC		= dword	ptr -1ACh
var_1A4		= dword	ptr -1A4h
var_198		= dword	ptr -198h
var_18C		= dword	ptr -18Ch
var_180		= dword	ptr -180h
var_174		= byte ptr -174h
var_6C		= dword	ptr -6Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1A4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1B0]
		mov	ecx, 69h ; 'i'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_AB41
		xor	eax, eax
		jmp	loc_ACBE
; ---------------------------------------------------------------------------

loc_AB41:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+58j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+248h], 0
		jnz	loc_ACB5
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1M@PFJJKCPL@?$AAI?$AAn?$AAf?$AA?3?$AA?5?$AA?$AA@ ;	"Inf: "
		push	1		; signed __int8
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		push	0Eh
		lea	eax, [ebp+var_174]
		push	eax
		mov	ecx, [ebp+var_18] ; this
		call	?getDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@ABEPBVDecimalFormatSymbols@2@XZ ; icu_56::RuleBasedNumberFormat::getDecimalFormatSymbols(void)
		mov	ecx, eax
		call	?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z ; icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)
		mov	[ebp+var_1AC], eax
		mov	ecx, [ebp+var_1AC]
		mov	[ebp+var_1B0], ecx
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		mov	edx, [ebp+var_1B0]
		push	edx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_174] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	60h ; '`'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_198], eax
		mov	byte ptr [ebp+var_4], 2
		cmp	[ebp+var_198], 0
		jz	short loc_AC19
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_60]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+var_18]
		push	edx		; struct icu_56::RuleBasedNumberFormat *
		mov	ecx, [ebp+var_198] ; this
		call	??0NFRule@icu_56@@QAE@PBVRuleBasedNumberFormat@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z ; icu_56::NFRule::NFRule(icu_56::RuleBasedNumberFormat const *,icu_56::UnicodeString const &,UErrorCode &)
		mov	[ebp+var_1AC], eax
		jmp	short loc_AC23
; ---------------------------------------------------------------------------

loc_AC19:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+118j
		mov	[ebp+var_1AC], 0

loc_AC23:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+137j
		mov	eax, [ebp+var_1AC]
		mov	[ebp+var_1A4], eax
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_1A4]
		mov	[ebp+var_6C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_AC5F
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_6C]
		mov	[eax+248h], ecx
		jmp	short loc_AC9C
; ---------------------------------------------------------------------------

loc_AC5F:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+16Fj
		mov	eax, [ebp+var_6C]
		mov	[ebp+var_180], eax
		mov	ecx, [ebp+var_180]
		mov	[ebp+var_18C], ecx
		cmp	[ebp+var_18C], 0
		jz	short loc_AC92
		push	1
		mov	ecx, [ebp+var_18C]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_1AC], eax
		jmp	short loc_AC9C
; ---------------------------------------------------------------------------

loc_AC92:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+19Bj
		mov	[ebp+var_1AC], 0

loc_AC9C:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+17Dj
					; icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+1B0j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_ACB5:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+6Bj
		mov	eax, [ebp+var_18]
		mov	eax, [eax+248h]

loc_ACBE:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+5Cj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1B0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN17_1		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+1E2o
		dd offset $LN16_4
$LN16_4		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:0000AD00o
		dd offset $LN14_2	; "rule"
$LN14_2		db 'rule',0             ; DATA XREF: .text:0000AD0Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0AD18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000AD90o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000AD98o
		mov	esi, esp
		lea	ecx, [ebp-174h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:0000ADA0o
		mov	esi, esp
		mov	eax, [ebp-198h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z proc	near
					; DATA XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1B4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0AD80h
		public ??_C@_1M@PFJJKCPL@?$AAI?$AAn?$AAf?$AA?3?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_1M@PFJJKCPL@?$AAI?$AAn?$AAf?$AA?3?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+75o
		unicode	0, <Inf: >,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0AD8Ch
__unwindtable$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:0000ADACo
		dd offset __unwindfunclet$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$0
		align 8
		dd offset __unwindfunclet$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$1
		align 10h
		dd offset __unwindfunclet$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$2
__ehfuncinfo$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ADC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::NFRule *__thiscall icu_56::RuleBasedNumberFormat::getDefaultInfinityRule(icu_56::RuleBasedNumberFormat *__hidden	this)
		public ?getDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@ABEPBVNFRule@2@XZ
?getDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@ABEPBVNFRule@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+248h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@ABEPBVNFRule@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ADFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::NFRule	*__thiscall icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(icu_56::RuleBasedNumberFormat *this, enum UErrorCode *)
		public ?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z
?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+8Ep
					; icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols	*)+153p

var_1B0		= dword	ptr -1B0h
var_1AC		= dword	ptr -1ACh
var_1A4		= dword	ptr -1A4h
var_198		= dword	ptr -198h
var_18C		= dword	ptr -18Ch
var_180		= dword	ptr -180h
var_174		= byte ptr -174h
var_6C		= dword	ptr -6Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1A4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1B0]
		mov	ecx, 69h ; 'i'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_AE5D
		xor	eax, eax
		jmp	loc_AFDA
; ---------------------------------------------------------------------------

loc_AE5D:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode	&)+58j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+24Ch], 0
		jnz	loc_AFD1
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1M@FKJJGJBK@?$AAN?$AAa?$AAN?$AA?3?$AA?5?$AA?$AA@ ;	"NaN: "
		push	1		; signed __int8
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		push	0Fh
		lea	eax, [ebp+var_174]
		push	eax
		mov	ecx, [ebp+var_18] ; this
		call	?getDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@ABEPBVDecimalFormatSymbols@2@XZ ; icu_56::RuleBasedNumberFormat::getDecimalFormatSymbols(void)
		mov	ecx, eax
		call	?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z ; icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)
		mov	[ebp+var_1AC], eax
		mov	ecx, [ebp+var_1AC]
		mov	[ebp+var_1B0], ecx
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		mov	edx, [ebp+var_1B0]
		push	edx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_174] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	60h ; '`'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_198], eax
		mov	byte ptr [ebp+var_4], 2
		cmp	[ebp+var_198], 0
		jz	short loc_AF35
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_60]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+var_18]
		push	edx		; struct icu_56::RuleBasedNumberFormat *
		mov	ecx, [ebp+var_198] ; this
		call	??0NFRule@icu_56@@QAE@PBVRuleBasedNumberFormat@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z ; icu_56::NFRule::NFRule(icu_56::RuleBasedNumberFormat const *,icu_56::UnicodeString const &,UErrorCode &)
		mov	[ebp+var_1AC], eax
		jmp	short loc_AF3F
; ---------------------------------------------------------------------------

loc_AF35:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode	&)+118j
		mov	[ebp+var_1AC], 0

loc_AF3F:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode	&)+137j
		mov	eax, [ebp+var_1AC]
		mov	[ebp+var_1A4], eax
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_1A4]
		mov	[ebp+var_6C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_AF7B
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_6C]
		mov	[eax+24Ch], ecx
		jmp	short loc_AFB8
; ---------------------------------------------------------------------------

loc_AF7B:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode	&)+16Fj
		mov	eax, [ebp+var_6C]
		mov	[ebp+var_180], eax
		mov	ecx, [ebp+var_180]
		mov	[ebp+var_18C], ecx
		cmp	[ebp+var_18C], 0
		jz	short loc_AFAE
		push	1
		mov	ecx, [ebp+var_18C]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_1AC], eax
		jmp	short loc_AFB8
; ---------------------------------------------------------------------------

loc_AFAE:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode	&)+19Bj
		mov	[ebp+var_1AC], 0

loc_AFB8:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode	&)+17Dj
					; icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode &)+1B0j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_AFD1:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode	&)+6Bj
		mov	eax, [ebp+var_18]
		mov	eax, [eax+24Ch]

loc_AFDA:				; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode	&)+5Cj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1B0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN17_2		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode	&)+1E2o
		dd offset $LN16_5
$LN16_5		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:0000B01Co
		dd offset $LN14_3	; "rule"
$LN14_3		db 'rule',0             ; DATA XREF: .text:0000B028o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0B034h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000B0ACo
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000B0B4o
		mov	esi, esp
		lea	ecx, [ebp-174h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:0000B0BCo
		mov	esi, esp
		mov	eax, [ebp-198h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1B4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B09Ch
		public ??_C@_1M@FKJJGJBK@?$AAN?$AAa?$AAN?$AA?3?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_1M@FKJJGJBK@?$AAN?$AAa?$AAN?$AA?3?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode	&)+75o
		unicode	0, <NaN: >,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0B0A8h
__unwindtable$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000B0C8o
		dd offset __unwindfunclet$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$1
		dd 0
		dd offset __unwindfunclet$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z$2
__ehfuncinfo$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B0E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::NFRule *__thiscall icu_56::RuleBasedNumberFormat::getDefaultNaNRule(icu_56::RuleBasedNumberFormat *__hidden this)
		public ?getDefaultNaNRule@RuleBasedNumberFormat@icu_56@@ABEPBVNFRule@2@XZ
?getDefaultNaNRule@RuleBasedNumberFormat@icu_56@@ABEPBVNFRule@2@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+24Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDefaultNaNRule@RuleBasedNumberFormat@icu_56@@ABEPBVNFRule@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B118h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::RuleBasedNumberFormat *this,	struct icu_56::DecimalFormatSymbols *)
		public ?adoptDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXPAVDecimalFormatSymbols@2@@Z
?adoptDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXPAVDecimalFormatSymbols@2@@Z proc near
					; DATA XREF: .rdata:00004748o

var_130		= dword	ptr -130h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 130h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_130]
		mov	ecx, 4Ch ; 'L'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jnz	short loc_B146
		jmp	loc_B2BA
; ---------------------------------------------------------------------------

loc_B146:				; CODE XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+27j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+244h], 0
		jz	short loc_B1A5
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+244h]
		mov	[ebp+var_11C], ecx
		mov	edx, [ebp+var_11C]
		mov	[ebp+var_128], edx
		cmp	[ebp+var_128], 0
		jz	short loc_B19B
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_128]
		mov	edx, [eax]
		mov	ecx, [ebp+var_128]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_130], eax
		jmp	short loc_B1A5
; ---------------------------------------------------------------------------

loc_B19B:				; CODE XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+5Cj
		mov	[ebp+var_130], 0

loc_B1A5:				; CODE XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+38j
					; icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols	*)+81j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+244h], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+248h]
		mov	[ebp+var_104], ecx
		mov	edx, [ebp+var_104]
		mov	[ebp+var_110], edx
		cmp	[ebp+var_110], 0
		jz	short loc_B1F1
		push	1
		mov	ecx, [ebp+var_110]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_130], eax
		jmp	short loc_B1FB
; ---------------------------------------------------------------------------

loc_B1F1:				; CODE XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+C2j
		mov	[ebp+var_130], 0

loc_B1FB:				; CODE XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+D7j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+248h], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?initializeDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24Ch]
		mov	[ebp+var_EC], ecx
		mov	edx, [ebp+var_EC]
		mov	[ebp+var_F8], edx
		cmp	[ebp+var_F8], 0
		jz	short loc_B24D
		push	1
		mov	ecx, [ebp+var_F8]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_130], eax
		jmp	short loc_B257
; ---------------------------------------------------------------------------

loc_B24D:				; CODE XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+11Ej
		mov	[ebp+var_130], 0

loc_B257:				; CODE XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+133j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+24Ch], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?initializeDefaultNaNRule@RuleBasedNumberFormat@icu_56@@AAEPAVNFRule@2@AAW4UErrorCode@@@Z ; icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode &)
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+164h], 0
		jz	short loc_B2BA
		mov	[ebp+var_20], 0
		jmp	short loc_B28E
; ---------------------------------------------------------------------------

loc_B285:				; CODE XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+1A0j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_B28E:				; CODE XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+16Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+16Ch]
		jge	short loc_B2BA
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::DecimalFormatSymbols *
		mov	edx, [ebp+var_8]
		mov	eax, [edx+164h]
		mov	ecx, [ebp+var_20]
		mov	ecx, [eax+ecx*4] ; this
		call	?setDecimalFormatSymbols@NFRuleSet@icu_56@@QAEXABVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z ; icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode &)
		jmp	short loc_B285
; ---------------------------------------------------------------------------

loc_B2BA:				; CODE XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+29j
					; icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols	*)+162j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 130h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?adoptDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXPAVDecimalFormatSymbols@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN17_3		dd 1			; DATA XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+1A6o
		dd offset $LN16_6
$LN16_6		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000B2E8o
		dd offset $LN15_2	; "status"
$LN15_2		db 'status',0           ; DATA XREF: .text:0000B2F4o
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B300h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedNumberFormat::setDecimalFormatSymbols(icu_56::RuleBasedNumberFormat *this, const struct icu_56::DecimalFormatSymbols	*)
		public ?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z
?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z	proc near
					; DATA XREF: .rdata:0000474Co

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		push	0AD4h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_B386
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::DecimalFormatSymbols *
		mov	ecx, [ebp+var_E0] ; this
		call	??0DecimalFormatSymbols@icu_56@@QAE@ABV01@@Z ; icu_56::DecimalFormatSymbols::DecimalFormatSymbols(icu_56::DecimalFormatSymbols const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_B390
; ---------------------------------------------------------------------------

loc_B386:				; CODE XREF: icu_56::RuleBasedNumberFormat::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &)+6Dj
		mov	[ebp+var_F4], 0

loc_B390:				; CODE XREF: icu_56::RuleBasedNumberFormat::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &)+84j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	edx, [ebp+var_EC]
		push	edx
		mov	eax, [ebp+var_14]
		mov	edx, [eax]
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+0B8h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0B3E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z$0 proc near
					; DATA XREF: .xdata$x:0000B420o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0B41Ch
__unwindtable$?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000B42Co
		dd offset __unwindfunclet$?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z$0
__ehfuncinfo$?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z+14o
		dd offset __unwindtable$?setDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@UAEXABVDecimalFormatSymbols@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B448h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: class icu_56::PluralFormat *	__thiscall icu_56::RuleBasedNumberFormat::createPluralFormat(enum  UPluralType,	class icu_56::UnicodeString const &, enum  UErrorCode &)const
		public ?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z
?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		push	288h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_B4DF
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_14]
		add	eax, 174h
		push	eax
		mov	ecx, [ebp+var_E0]
		call	??0PluralFormat@icu_56@@QAE@ABVLocale@1@W4UPluralType@@ABVUnicodeString@1@AAW4UErrorCode@@@Z ; icu_56::PluralFormat::PluralFormat(icu_56::Locale const &,UPluralType,icu_56::UnicodeString const &,UErrorCode &)
		mov	[ebp+var_F4], eax
		jmp	short loc_B4E9
; ---------------------------------------------------------------------------

loc_B4DF:				; CODE XREF: icu_56::RuleBasedNumberFormat::createPluralFormat(UPluralType,icu_56::UnicodeString const &,UErrorCode &)+6Dj
		mov	[ebp+var_F4], 0

loc_B4E9:				; CODE XREF: icu_56::RuleBasedNumberFormat::createPluralFormat(UPluralType,icu_56::UnicodeString const &,UErrorCode &)+95j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_EC]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z endp ; sp-analysis failed

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0B524h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000B560o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::RuleBasedNumberFormat::createPluralFormat(UPluralType,icu_56::UnicodeString const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0B55Ch
__unwindtable$?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000B56Co
		dd offset __unwindfunclet$?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?createPluralFormat@RuleBasedNumberFormat@icu_56@@ABEPAVPluralFormat@2@W4UPluralType@@ABVUnicodeString@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; public: signed char __thiscall icu_56::DecimalFormatSymbols::operator==(class	icu_56::DecimalFormatSymbols const &)const
		extrn ??8DecimalFormatSymbols@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::operator!=(icu_56::DecimalFormatSymbols const &)+2Ap
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::DecimalFormatSymbols::operator!=(icu_56::DecimalFormatSymbols const &)+42p
					; icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+61p ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn __imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+59p
					; icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+79p ...
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+17Cp
					; __unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0+8p ...
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString &&)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+160p
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+160r
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@H@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+120p
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+120r
		extrn _u_charDigitValue_56:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+E0p
; int __thiscall icu_56::UnicodeString::char32At(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?char32At@UnicodeString@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+CCp
					; icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString &)+4Ep
					; DATA XREF: ...
; int __thiscall icu_56::UnicodeString::countChar32(icu_56::UnicodeString *__hidden this, int, int)
		extrn __imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+AFp
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+AFr
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString const &)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+80p
					; icu_56::Formattable::getString(icu_56::UnicodeString &)+2Fp ...
		extrn ___security_cookie:near
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+2Er
					; icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+23j
					; __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z+19j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+1A1p
					; __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+Fp ...
; _DWORD __thiscall icu_56::Locale::Locale(icu_56::Locale *__hidden this, const	struct icu_56::Locale *)
		extrn __imp_??0Locale@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::getLocale(void)+3Bp
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString const &,icu_56::UnicodeString const &,icu_56::Locale const	&,UParseError &,UErrorCode &)+9Dp ...
; public: signed char __thiscall icu_56::Formattable::operator==(class icu_56::Formattable const &)const
		extrn ??8Formattable@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::Formattable::operator!=(icu_56::Formattable const &)+2Ap
		extrn __fltused:near
; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *__hidden this, enum UErrorCode *)
		extrn ?getLong@Formattable@icu_56@@QBEHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::Formattable::getLong(UErrorCode *)+2Ap
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		extrn __imp_??0UObject@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::FieldPosition::FieldPosition(void)+28p
					; icu_56::FieldPosition::FieldPosition(int)+28p ...
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::FieldPosition `RTTI Type Descriptor'o
					; .data:icu_56::UObject	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::FieldPosition::getDynamicClassID(void)const
		extrn ?getDynamicClassID@FieldPosition@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000ABCo
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this, const struct icu_56::UObject *)
		extrn __imp_??0UObject@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition	const &)+2Cp
					; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)+2Cp ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+39p
					; icu_56::FieldPosition::`vector deleting destructor'(uint)+81p ...
; _DWORD __thiscall icu_56::FieldPosition::~FieldPosition(icu_56::FieldPosition	*__hidden this)
		extrn ??1FieldPosition@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+26p
					; icu_56::FieldPosition::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn __imp_??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+53p
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+53p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+3Dp
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+3Dp ...
; public: signed char __thiscall icu_56::FieldPositionIterator::operator==(class icu_56::FieldPositionIterator const &)const
		extrn ??8FieldPositionIterator@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::FieldPositionIterator::operator!=(icu_56::FieldPositionIterator const &)+2Ap
; __declspec(dllimport)	public:	class icu_56::UObject &	__thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		extrn __imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::FieldPositionIterator::operator=(icu_56::FieldPositionIterator const &)+2Cp
					; icu_56::NumberFormatFactory::operator=(icu_56::NumberFormatFactory const &)+2Cp ...
; public: virtual void * __thiscall icu_56::MeasureUnit::getDynamicClassID(void)const
		extrn ?getDynamicClassID@MeasureUnit@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:0000123Co
; public: virtual class	icu_56::UObject	* __thiscall icu_56::MeasureUnit::clone(void)const
		extrn ?clone@MeasureUnit@icu_56@@UBEPAVUObject@2@XZ:near
					; DATA XREF: .rdata:00001240o
; public: virtual signed char __thiscall icu_56::MeasureUnit::operator==(class icu_56::UObject const &)const
		extrn ??8MeasureUnit@icu_56@@UBECABVUObject@1@@Z:near
					; DATA XREF: .rdata:00001244o
; _DWORD __thiscall icu_56::MeasureUnit::~MeasureUnit(icu_56::MeasureUnit *__hidden this)
		extrn ??1MeasureUnit@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::MeasureUnit::`scalar deleting destructor'(uint)+26p
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+6Ep
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000015B0o
					; .rdata:000018E0o ...
		extrn __purecall:near	; DATA XREF: .rdata:000015B4o
					; .rdata:000015B8o ...
; _DWORD __thiscall icu_56::NumberFormatFactory::~NumberFormatFactory(icu_56::NumberFormatFactory *__hidden this)
		extrn ??1NumberFormatFactory@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::NumberFormatFactory::`scalar deleting destructor'(uint)+26p
					; icu_56::NumberFormatFactory::`vector deleting	destructor'(uint)+6Ep ...
; public: virtual signed char __thiscall icu_56::SimpleNumberFormatFactory::visible(void)const
		extrn ?visible@SimpleNumberFormatFactory@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:000018E4o
; public: virtual class	icu_56::UnicodeString const * __thiscall icu_56::SimpleNumberFormatFactory::getSupportedIDs(int	&, enum	 UErrorCode &)const
		extrn ?getSupportedIDs@SimpleNumberFormatFactory@icu_56@@UBEPBVUnicodeString@2@AAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000018E8o
; _DWORD __thiscall icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory *__hidden this)
		extrn ??1SimpleNumberFormatFactory@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::SimpleNumberFormatFactory::`scalar	deleting destructor'(uint)+26p
					; icu_56::SimpleNumberFormatFactory::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; public: virtual class	icu_56::UnicodeString __thiscall icu_56::PluralFormat::PluralSelectorAdapter::select(void *, double, enum  UErrorCode &)const
		extrn ?select@PluralSelectorAdapter@PluralFormat@icu_56@@UBE?AVUnicodeString@3@PAXNAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00001D50o
; _DWORD __thiscall icu_56::PluralFormat::PluralSelector::~PluralSelector(icu_56::PluralFormat::PluralSelector *__hidden this)
		extrn ??1PluralSelector@PluralFormat@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::PluralFormat::PluralSelector::`scalar deleting destructor'(uint)+26p
					; icu_56::PluralFormat::PluralSelector::`vector	deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; _DWORD __thiscall icu_56::PluralFormat::PluralSelectorAdapter::~PluralSelectorAdapter(icu_56::PluralFormat::PluralSelectorAdapter *__hidden this)
		extrn ??1PluralSelectorAdapter@PluralFormat@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::PluralFormat::PluralSelectorAdapter::`scalar deleting destructor'(uint)+26p
					; icu_56::PluralFormat::PluralSelectorAdapter::`vector deleting	destructor'(uint)+6Ep
					; DATA XREF: ...
; public: virtual signed char __thiscall icu_56::CollatorFactory::visible(void)const
		extrn ?visible@CollatorFactory@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00002310o
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::CollatorFactory::getDisplayName(class icu_56::Locale	const &, class icu_56::Locale const &, class icu_56::UnicodeString &)
		extrn ?getDisplayName@CollatorFactory@icu_56@@UAEAAVUnicodeString@2@ABVLocale@2@0AAV32@@Z:near
					; DATA XREF: .rdata:00002318o
; _DWORD __thiscall icu_56::CollatorFactory::~CollatorFactory(icu_56::CollatorFactory *__hidden	this)
		extrn ??1CollatorFactory@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::CollatorFactory::`scalar deleting destructor'(uint)+26p
					; icu_56::CollatorFactory::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
		extrn ___RTDynamicCast:near
					; CODE XREF: icu_56::RuleBasedCollator::rbcFromUCollator(UCollator *)+39p
					; icu_56::RuleBasedCollator::rbcFromUCollator(UCollator	const *)+39p ...
; protected: virtual void * __thiscall icu_56::LocalizationInfo::`scalar deleting destructor'(unsigned int)
		extrn ??_GLocalizationInfo@icu_56@@MAEPAXI@Z_0:near
; protected: virtual void * __thiscall icu_56::LocalizationInfo::`vector deleting destructor'(unsigned int)
		extrn ??_ELocalizationInfo@icu_56@@MAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::LocalizationInfo::`vftable'o
		extrn _u_strcmp_56:near	; CODE XREF: icu_56::streq(wchar_t const *,wchar_t const *)+3Ep
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::LocDataParser::parse(wchar_t *,int)+45p
					; icu_56::LocDataParser::parse(wchar_t *,int)+B1p ...
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn __imp_??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+244p
					; icu_56::RuleBasedNumberFormat::clone(void)+49p ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::LocDataParser::doParse(void)+2F1p
					; icu_56::LocDataParser::nextArray(int &)+2A5p	...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: icu_56::VArray::add(void *,UErrorCode &)+10Fp
					; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode	&)+4Dp
		extrn _uprv_realloc_56:near
					; CODE XREF: icu_56::VArray::add(void *,UErrorCode &)+C2p
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::VArray::add(void *,UErrorCode &)+A3p
					; icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const &,UParseError &,UErrorCode	&)+81p	...
; public: virtual void * __thiscall icu_56::StringLocalizationInfo::`scalar deleting destructor'(unsigned int)
		extrn ??_GStringLocalizationInfo@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::StringLocalizationInfo::`vector deleting destructor'(unsigned int)
		extrn ??_EStringLocalizationInfo@icu_56@@UAEPAXI@Z:near	; weak
					; DATA XREF: .rdata:const icu_56::StringLocalizationInfo::`vftable'o
; signed __int8	__cdecl	static icu_56::PatternProps::isWhiteSpace(int)
		extrn __imp_?isWhiteSpace@PatternProps@icu_56@@SACH@Z:near
					; CODE XREF: icu_56::LocDataParser::skipWhitespace(void)+6Ap
					; icu_56::LocDataParser::inList(wchar_t,wchar_t	const *)+35p ...
		extrn _u_strncpy_56:near
					; CODE XREF: icu_56::LocDataParser::parseError(char const *)+B9p
					; icu_56::LocDataParser::parseError(char const *)+F6p
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, wchar_t *, int, enum UErrorCode *)
		extrn __imp_?extract@UnicodeString@icu_56@@QBEHPA_WHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+B0p
					; DATA XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+B0r
; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		extrn __imp_?length@UnicodeString@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::StringLocalizationInfo::create(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+5Ep
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+12Fp ...
; _DWORD __thiscall icu_56::Locale::~Locale(icu_56::Locale *__hidden this)
		extrn __imp_??1Locale@icu_56@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$1+Bp
					; __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z$1+Bp ...
; _DWORD __thiscall icu_56::NumberFormat::~NumberFormat(icu_56::NumberFormat *__hidden this)
		extrn ??1NumberFormat@icu_56@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0ABVLocale@1@AAUUParseError@@AAW4UErrorCode@@@Z$0+3j
					; __unwindfunclet$??0RuleBasedNumberFormat@icu_56@@QAE@ABVUnicodeString@1@0AAUUParseError@@AAW4UErrorCode@@@Z$0+3j ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		extrn __imp_??0UnicodeString@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString	const &,icu_56::UnicodeString const &,icu_56::Locale const &,UParseError &,UErrorCode &)+111p
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString const &,icu_56::UnicodeString const &,UParseError &,UErrorCode &)+11Dp ...
; _DWORD __thiscall icu_56::NumberFormat::NumberFormat(icu_56::NumberFormat *__hidden this)
		extrn ??0NumberFormat@icu_56@@IAE@XZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString	const &,icu_56::UnicodeString const &,icu_56::Locale const &,UParseError &,UErrorCode &)+45p
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString const &,icu_56::UnicodeString const &,UParseError &,UErrorCode &)+45p ...
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::NumberFormat::format(class icu_56::Formattable const	&, class icu_56::UnicodeString &, class	icu_56::FieldPositionIterator *, enum  UErrorCode &)const
		extrn ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@ABVFormattable@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046A0o
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::NumberFormat::format(class icu_56::Formattable const	&, class icu_56::UnicodeString &, class	icu_56::FieldPosition &, enum  UErrorCode &)const
		extrn ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@ABVFormattable@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046A4o
; public: virtual void __thiscall icu_56::NumberFormat::parseObject(class icu_56::UnicodeString	const &, class icu_56::Formattable &, class icu_56::ParsePosition &)const
		extrn ?parseObject@NumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAVParsePosition@2@@Z:near
					; DATA XREF: .rdata:000046A8o
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::NumberFormat::format(class icu_56::DigitList	const &, class icu_56::UnicodeString &,	class icu_56::FieldPosition &, enum  UErrorCode	&)const
		extrn ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046ACo
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::NumberFormat::format(class icu_56::DigitList	const &, class icu_56::UnicodeString &,	class icu_56::FieldPositionIterator *, enum  UErrorCode	&)const
		extrn ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046B0o
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::NumberFormat::format(class icu_56::StringPiece const	&, class icu_56::UnicodeString &, class	icu_56::FieldPositionIterator *, enum  UErrorCode &)const
		extrn ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046B4o
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::NumberFormat::format(__int64, class icu_56::UnicodeString &,	class icu_56::FieldPositionIterator *, enum  UErrorCode	&)const
		extrn ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046B8o
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::NumberFormat::format(__int64, class icu_56::UnicodeString &,	class icu_56::FieldPosition &, enum  UErrorCode	&)const
		extrn ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046BCo
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::NumberFormat::format(int, class icu_56::UnicodeString &, class icu_56::FieldPositionIterator	*, enum	 UErrorCode &)const
		extrn ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046C4o
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::NumberFormat::format(int, class icu_56::UnicodeString &, class icu_56::FieldPosition	&, enum	 UErrorCode &)const
		extrn ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046C8o
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::NumberFormat::format(double,	class icu_56::UnicodeString &, class icu_56::FieldPositionIterator *, enum  UErrorCode &)const
		extrn ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046D0o
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::NumberFormat::format(double,	class icu_56::UnicodeString &, class icu_56::FieldPosition &, enum  UErrorCode &)const
		extrn ?format@NumberFormat@icu_56@@UBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046D4o
; public: virtual void __thiscall icu_56::NumberFormat::parse(class icu_56::UnicodeString const	&, class icu_56::Formattable &,	enum  UErrorCode &)const
		extrn ?parse@NumberFormat@icu_56@@UBEXABVUnicodeString@2@AAVFormattable@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000046DCo
; public: virtual class	icu_56::CurrencyAmount * __thiscall icu_56::NumberFormat::parseCurrency(class icu_56::UnicodeString const &, class icu_56::ParsePosition &)const
		extrn ?parseCurrency@NumberFormat@icu_56@@UBEPAVCurrencyAmount@2@ABVUnicodeString@2@AAVParsePosition@2@@Z:near
					; DATA XREF: .rdata:000046E4o
; public: virtual void __thiscall icu_56::NumberFormat::setParseIntegerOnly(signed char)
		extrn ?setParseIntegerOnly@NumberFormat@icu_56@@UAEXC@Z:near
					; DATA XREF: .rdata:000046E8o
; public: virtual void __thiscall icu_56::NumberFormat::setGroupingUsed(signed char)
		extrn ?setGroupingUsed@NumberFormat@icu_56@@UAEXC@Z:near
					; DATA XREF: .rdata:000046F4o
; public: virtual void __thiscall icu_56::NumberFormat::setMaximumIntegerDigits(int)
		extrn ?setMaximumIntegerDigits@NumberFormat@icu_56@@UAEXH@Z:near
					; DATA XREF: .rdata:000046F8o
; public: virtual void __thiscall icu_56::NumberFormat::setMinimumIntegerDigits(int)
		extrn ?setMinimumIntegerDigits@NumberFormat@icu_56@@UAEXH@Z:near
					; DATA XREF: .rdata:000046FCo
; public: virtual void __thiscall icu_56::NumberFormat::setMaximumFractionDigits(int)
		extrn ?setMaximumFractionDigits@NumberFormat@icu_56@@UAEXH@Z:near
					; DATA XREF: .rdata:00004700o
; public: virtual void __thiscall icu_56::NumberFormat::setMinimumFractionDigits(int)
		extrn ?setMinimumFractionDigits@NumberFormat@icu_56@@UAEXH@Z:near
					; DATA XREF: .rdata:00004704o
; public: virtual void __thiscall icu_56::NumberFormat::setCurrency(wchar_t const *, enum  UErrorCode &)
		extrn ?setCurrency@NumberFormat@icu_56@@UAEXPB_WAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00004708o
; public: virtual enum	UDisplayContext	__thiscall icu_56::NumberFormat::getContext(enum  UDisplayContextType, enum  UErrorCode	&)const
		extrn ?getContext@NumberFormat@icu_56@@UBE?AW4UDisplayContext@@W4UDisplayContextType@@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00004710o
; protected: virtual void __thiscall icu_56::NumberFormat::getEffectiveCurrency(wchar_t	*, enum	 UErrorCode &)const
		extrn ?getEffectiveCurrency@NumberFormat@icu_56@@MBEXPA_WAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00004714o
; const	struct icu_56::Locale *__cdecl static icu_56::Locale::getDefault()
		extrn __imp_?getDefault@Locale@icu_56@@SAABV12@XZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString	const &,icu_56::UnicodeString const &,UParseError &,UErrorCode &)+90p
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::UnicodeString const &,UParseError &,UErrorCode &)+90p
					; DATA XREF: ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+333p
					; icu_56::RuleBasedNumberFormat::getCollator(void)+11Fp ...
		extrn _ures_hasNext_56:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+2E6p
		extrn _ures_close_56:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+276p
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+2B0p ...
		extrn _ures_getByKeyWithFallback_56:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+252p
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+28Cp ...
; void __thiscall icu_56::Format::setLocaleIDs(icu_56::Format *__hidden	this, const char *, const char *)
		extrn ?setLocaleIDs@Format@icu_56@@IAEXPBD0@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+23Fp
		extrn _ures_getLocaleByType_56:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+220p
					; icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+233p
		extrn _ures_open_56:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+1F2p
					; icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+E3p
; const	char *__thiscall icu_56::Locale::getName(icu_56::Locale	*__hidden this)
		extrn __imp_?getName@Locale@icu_56@@QBEPBDXZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+1DFp
					; DATA XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::URBNFRuleSetTag,icu_56::Locale const &,UErrorCode &)+1DFr
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, signed __int8, const wchar_t *, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z:near
					; CODE XREF: icu_56::ures_getNextUnicodeString(UResourceBundle *,char const * *,UErrorCode *)+59p
					; icu_56::RuleBasedNumberFormat::getRuleSetName(int)+8Fp ...
		extrn _ures_getNextString_56:near
					; CODE XREF: icu_56::ures_getNextUnicodeString(UResourceBundle *,char const * *,UErrorCode *)+3Fp
; _DWORD __thiscall icu_56::NumberFormat::NumberFormat(icu_56::NumberFormat *__hidden this, const struct icu_56::NumberFormat *)
		extrn ??0NumberFormat@icu_56@@IAE@ABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::RuleBasedNumberFormat(icu_56::RuleBasedNumberFormat	const &)+49p
; __declspec(dllimport)	public:	class icu_56::Locale & __thiscall icu_56::Locale::operator=(class icu_56::Locale const &)
		extrn __imp_??4Locale@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+84p
					; DATA XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+84r
; protected: class icu_56::NumberFormat	& __thiscall icu_56::NumberFormat::operator=(class icu_56::NumberFormat	const &)
		extrn ??4NumberFormat@icu_56@@IAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::operator=(icu_56::RuleBasedNumberFormat const &)+5Cp
; public: signed char __thiscall icu_56::NFRuleSet::operator==(class icu_56::NFRuleSet const &)const
		extrn ??8NFRuleSet@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+18Ep
; __declspec(dllimport)	public:	signed char __thiscall icu_56::Locale::operator==(class	icu_56::Locale const &)const
		extrn __imp_??8Locale@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+81p
					; DATA XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+81r
; __declspec(dllimport)	public:	bool __thiscall	type_info::operator==(class type_info const &)const
		extrn __imp_??8type_info@@QBE_NABV0@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+4Fp
					; DATA XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+4Fr
		extrn ___RTtypeid:near	; CODE XREF: icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+36p
					; icu_56::RuleBasedNumberFormat::operator==(icu_56::Format const &)+45p
; __declspec(dllimport)	public:	__thiscall icu_56::UnicodeString::UnicodeString(class icu_56::UnicodeString &&)
		extrn __imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRules(void)+ACp
					; icu_56::RuleBasedNumberFormat::getRuleSetName(int)+ACp ...
; void __thiscall icu_56::NFRuleSet::appendRules(icu_56::NFRuleSet *__hidden this, struct icu_56::UnicodeString	*)
		extrn ?appendRules@NFRuleSet@icu_56@@QBEXAAVUnicodeString@2@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRules(void)+9Cp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *__hidden	this, const struct icu_56::UnicodeString *)
		extrn __imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z:near
					; CODE XREF: icu_56::NFRuleSet::getName(icu_56::UnicodeString &)+2Cp
					; icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+194p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::Locale::Locale(icu_56::Locale *__hidden this)
		extrn __imp_??0Locale@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+2B4p
					; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+2B4r
; int __thiscall __high	icu_56::UnicodeString::extract(int, int, char *, int, enum icu_56::UnicodeString::EInvariant)
		extrn __imp_?extract@UnicodeString@icu_56@@QBEHHHPADHW4EInvariant@12@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+1F5p
					; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+1F5r
; _DWORD __thiscall icu_56::Locale::Locale(icu_56::Locale *__hidden this, const	char *,	const char *, const char *, const char *)
		extrn __imp_??0Locale@icu_56@@QAE@PBD000@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+74p
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayNameLocale(int,UErrorCode &)+191p ...
; void __thiscall icu_56::UnicodeString::setToBogus(icu_56::UnicodeString *__hidden this)
		extrn __imp_?setToBogus@UnicodeString@icu_56@@QAEXXZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+2F8p
					; icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(icu_56::UnicodeString const &,icu_56::Locale const &)+129p ...
; wchar_t *__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?getBuffer@UnicodeString@icu_56@@QAEPA_WH@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+E7p
					; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+E7r
; _DWORD __thiscall __high icu_56::UnicodeString::UnicodeString(const char *, int, enum	icu_56::UnicodeString::EInvariant)
		extrn __imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+B2p
					; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+B2r
; const	char *__thiscall icu_56::Locale::getBaseName(icu_56::Locale *__hidden this)
		extrn __imp_?getBaseName@Locale@icu_56@@QBEPBDXZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(int,icu_56::Locale const &)+A1p
					; icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+8Ep
					; DATA XREF: ...
; const	wchar_t	*__thiscall icu_56::UnicodeString::getTerminatedBuffer(icu_56::UnicodeString *__hidden this)
		extrn __imp_?getTerminatedBuffer@UnicodeString@icu_56@@QAEPB_WXZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(icu_56::UnicodeString	const &,icu_56::Locale const &)+81p
					; DATA XREF: icu_56::RuleBasedNumberFormat::getRuleSetDisplayName(icu_56::UnicodeString	const &,icu_56::Locale const &)+81r
; __declspec(dllimport)	public:	signed char __thiscall icu_56::UnicodeString::operator==(class icu_56::UnicodeString const &)const
		extrn __imp_??8UnicodeString@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::NFRuleSet::isNamed(icu_56::UnicodeString const &)+2Cp
					; DATA XREF: icu_56::NFRuleSet::isNamed(icu_56::UnicodeString const &)+2Cr
; void __thiscall icu_56::NFRuleSet::format(icu_56::NFRuleSet *__hidden	this, __int64, struct icu_56::UnicodeString *, int, int, enum UErrorCode *)
		extrn ?format@NFRuleSet@icu_56@@QBEX_JAAVUnicodeString@2@HHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &)+77p
					; icu_56::RuleBasedNumberFormat::format(__int64,icu_56::UnicodeString &,icu_56::FieldPosition &)+79p ...
; void __thiscall icu_56::NFRuleSet::format(icu_56::NFRuleSet *__hidden	this, double, struct icu_56::UnicodeString *, int, int,	enum UErrorCode	*)
		extrn ?format@NFRuleSet@icu_56@@QBEXNAAVUnicodeString@2@HHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::format(double,icu_56::UnicodeString	&,icu_56::FieldPosition	&)+7Ap
					; icu_56::RuleBasedNumberFormat::format(double,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode	&)+BDp
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, const wchar_t *, int, int)
		extrn __imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::format(int,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode	&)+4Ap
					; icu_56::RuleBasedNumberFormat::format(__int64,icu_56::UnicodeString const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+4Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::toTitle(icu_56::UnicodeString	*__hidden this,	struct icu_56::BreakIterator *,	const struct icu_56::Locale *, unsigned	int)
		extrn __imp_?toTitle@UnicodeString@icu_56@@QAEAAV12@PAVBreakIterator@2@ABVLocale@2@I@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString &)+111p
					; DATA XREF: icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString &)+111r
		extrn _u_islower_56:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::adjustForCapitalizationContext(int,icu_56::UnicodeString &)+8Bp
; void __thiscall icu_56::Formattable::setLong(icu_56::Formattable *__hidden this, int)
		extrn ?setLong@Formattable@icu_56@@QAEXH@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+3BAp
; enum icu_56::Formattable::Type __thiscall __high icu_56::Formattable::getType()
		extrn ?getType@Formattable@icu_56@@QBE?AW4Type@12@XZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+370p
; int __thiscall icu_56::ParsePosition::getErrorIndex(icu_56::ParsePosition *__hidden this)
		extrn __imp_?getErrorIndex@ParsePosition@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+2FBp
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+314p
					; DATA XREF: ...
; void __thiscall icu_56::ParsePosition::setIndex(icu_56::ParsePosition	*__hidden this,	int)
		extrn __imp_?setIndex@ParsePosition@icu_56@@QAEXH@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+2B7p
					; DATA XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+2B7r
; _DWORD __thiscall icu_56::ParsePosition::~ParsePosition(icu_56::ParsePosition	*__hidden this)
		extrn __imp_??1ParsePosition@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+242p
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+26Cp ...
; _DWORD __thiscall icu_56::Formattable::~Formattable(icu_56::Formattable *__hidden this)
		extrn ??1Formattable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+231p
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+25Bp ...
; public: class	icu_56::Formattable & __thiscall icu_56::Formattable::operator=(class icu_56::Formattable const	&)
		extrn ??4Formattable@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+1F5p
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+368p
; __declspec(dllimport)	public:	class icu_56::ParsePosition & __thiscall icu_56::ParsePosition::operator=(class	icu_56::ParsePosition const &)
		extrn __imp_??4ParsePosition@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+1DBp
					; DATA XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+1DBr
; signed __int8	__thiscall icu_56::NFRuleSet::parse(icu_56::NFRuleSet *__hidden	this, const struct icu_56::UnicodeString *, struct icu_56::ParsePosition *, double, struct icu_56::Formattable *)
		extrn ?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+193p
; _DWORD __thiscall icu_56::Formattable::Formattable(icu_56::Formattable *__hidden this)
		extrn ??0Formattable@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+D3p
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+166p
; _DWORD __thiscall icu_56::ParsePosition::ParsePosition(icu_56::ParsePosition *__hidden this, int)
		extrn __imp_??0ParsePosition@icu_56@@QAE@H@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+A1p
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+BCp ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@ABV01@H@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+86p
					; DATA XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+86r
; int __thiscall icu_56::ParsePosition::getIndex(icu_56::ParsePosition *__hidden this)
		extrn __imp_?getIndex@ParsePosition@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+6Fp
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+1A0p ...
; void __thiscall icu_56::ParsePosition::setErrorIndex(icu_56::ParsePosition *__hidden this, int)
		extrn __imp_?setErrorIndex@ParsePosition@icu_56@@QAEXH@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+58p
					; icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString const &,icu_56::Formattable &,icu_56::ParsePosition &)+2E4p ...
		extrn __ftol2_sse:near	; CODE XREF: icu_56::RuleBasedNumberFormat::parse(icu_56::UnicodeString	const &,icu_56::Formattable &,icu_56::ParsePosition &)+382p
; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *__hidden this, const struct	icu_56::UnicodeString *)
		extrn __imp_?startsWith@UnicodeString@icu_56@@QBECABV12@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+14Fp
					; DATA XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+14Fr
; signed __int8	__thiscall icu_56::UnicodeString::isEmpty(icu_56::UnicodeString	*__hidden this)
		extrn __imp_?isEmpty@UnicodeString@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+63p
					; DATA XREF: icu_56::RuleBasedNumberFormat::setDefaultRuleSet(icu_56::UnicodeString const &,UErrorCode &)+63r
; void __thiscall icu_56::NFRuleSet::parseRules(icu_56::NFRuleSet *__hidden this, struct icu_56::UnicodeString *, enum UErrorCode *)
		extrn ?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+89Fp
; _DWORD __thiscall icu_56::NFRuleSet::NFRuleSet(icu_56::NFRuleSet *__hidden this, struct icu_56::RuleBasedNumberFormat	*, struct icu_56::UnicodeString	*, int,	enum UErrorCode	*)
		extrn ??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+69Ep
					; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode	&)+7C7p
; void __stdcall `eh vector constructor	iterator'(void *, unsigned int, int, void (__thiscall *)(void *), void (__thiscall *)(void *))
		extrn ??_L@YGXPAXIHP6EX0@Z1@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+540p
; void *__cdecl	static icu_56::UMemory::operator new[](unsigned	int)
		extrn __imp_??_UUMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+4E4p
					; DATA XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+4E4r
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this, int, int)
		extrn __imp_?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+322p
					; DATA XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+322r
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *__hidden	this, const struct icu_56::UnicodeString *, int, int)
		extrn __imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+302p
					; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode	&)+64Bp ...
		extrn _u_strlen_56:near	; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+1D8p
; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo	*,UParseError &,UErrorCode &)+17Cp
					; icu_56::RuleBasedNumberFormat::init(icu_56::UnicodeString const &,icu_56::LocalizationInfo *,UParseError &,UErrorCode	&)+1F5p ...
; public: virtual void * __thiscall icu_56::UnicodeString::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00009648o
; public: virtual void __thiscall icu_56::UnicodeString::extractBetween(int, int, class	icu_56::UnicodeString &)const
		extrn ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z:near
					; DATA XREF: .rdata:0000964Co
; public: virtual void __thiscall icu_56::UnicodeString::handleReplaceBetween(int, int,	class icu_56::UnicodeString const &)
		extrn ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z:near
					; DATA XREF: .rdata:00009650o
; public: virtual void __thiscall icu_56::UnicodeString::copy(int, int,	int)
		extrn ?copy@UnicodeString@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:00009654o
; public: virtual signed char __thiscall icu_56::UnicodeString::hasMetaData(void)const
		extrn ?hasMetaData@UnicodeString@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00009658o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::UnicodeString::clone(void)const
		extrn ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ:near
					; DATA XREF: .rdata:0000965Co
; protected: virtual int __thiscall icu_56::UnicodeString::getLength(void)const
		extrn ?getLength@UnicodeString@icu_56@@MBEHXZ:near
					; DATA XREF: .rdata:00009660o
; protected: virtual wchar_t __thiscall	icu_56::UnicodeString::getCharAt(int)const
		extrn ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z:near
					; DATA XREF: .rdata:00009664o
; protected: virtual int __thiscall icu_56::UnicodeString::getChar32At(int)const
		extrn ?getChar32At@UnicodeString@icu_56@@MBEHH@Z:near
					; DATA XREF: .rdata:00009668o
; struct icu_56::BreakIterator *__cdecl	static icu_56::BreakIterator::createSentenceInstance(const struct icu_56::Locale *, enum UErrorCode *)
		extrn __imp_?createSentenceInstance@BreakIterator@icu_56@@SAPAV12@ABVLocale@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+EDp
					; DATA XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+EDr
; void __thiscall __high icu_56::NumberFormat::setContext(enum UDisplayContext,	enum UErrorCode	*)
		extrn ?setContext@NumberFormat@icu_56@@UAEXW4UDisplayContext@@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::setContext(UDisplayContext,UErrorCode &)+2Ep
		extrn _ures_getIntVector_56:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+152p
; __declspec(dllimport)	public:	signed char __thiscall icu_56::Locale::operator!=(class	icu_56::Locale const &)const
		extrn __imp_??9Locale@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+75p
					; DATA XREF: icu_56::RuleBasedNumberFormat::initCapitalizationContextInfo(icu_56::Locale const &)+75r
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int, int)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+123p
					; icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+167p
					; DATA XREF: ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, wchar_t, int)
		extrn __imp_?indexOf@UnicodeString@icu_56@@QBEH_WH@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+EAp
					; DATA XREF: icu_56::RuleBasedNumberFormat::stripWhitespace(icu_56::UnicodeString &)+EAr
; _DWORD __thiscall icu_56::NFRule::~NFRule(icu_56::NFRule *__hidden this)
		extrn ??1NFRule@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::NFRule::`scalar deleting destructor'(uint)+26p
; _DWORD __thiscall icu_56::NFRuleSet::~NFRuleSet(icu_56::NFRuleSet *__hidden this)
		extrn ??1NFRuleSet@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::NFRuleSet::`scalar	deleting destructor'(uint)+26p
; _DWORD __thiscall icu_56::RuleBasedCollator::RuleBasedCollator(icu_56::RuleBasedCollator *__hidden this, const struct	icu_56::UnicodeString *, enum UErrorCode *)
		extrn ??0RuleBasedCollator@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+167p
; const	struct icu_56::UnicodeString *__thiscall icu_56::RuleBasedCollator::getRules(icu_56::RuleBasedCollator *__hidden this)
		extrn ?getRules@RuleBasedCollator@icu_56@@QBEABVUnicodeString@2@XZ:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+EBp
; struct icu_56::Collator *__cdecl static icu_56::Collator::createInstance(const struct	icu_56::Locale *, enum UErrorCode *)
		extrn ?createInstance@Collator@icu_56@@SAPAV12@ABVLocale@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::getCollator(void)+8Fp
; _DWORD __thiscall icu_56::DecimalFormatSymbols::DecimalFormatSymbols(icu_56::DecimalFormatSymbols *__hidden this, const struct icu_56::Locale	*, enum	UErrorCode *)
		extrn ??0DecimalFormatSymbols@icu_56@@QAE@ABVLocale@1@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDecimalFormatSymbols(UErrorCode &)+93p
; _DWORD __thiscall icu_56::NFRule::NFRule(icu_56::NFRule *__hidden this, const	struct icu_56::RuleBasedNumberFormat *,	const struct icu_56::UnicodeString *, enum UErrorCode *)
		extrn ??0NFRule@icu_56@@QAE@PBVRuleBasedNumberFormat@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::initializeDefaultInfinityRule(UErrorCode &)+12Cp
					; icu_56::RuleBasedNumberFormat::initializeDefaultNaNRule(UErrorCode &)+12Cp
; void __thiscall icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::NFRuleSet *__hidden this, const struct icu_56::DecimalFormatSymbols *, enum UErrorCode *)
		extrn ?setDecimalFormatSymbols@NFRuleSet@icu_56@@QAEXABVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+19Bp
; _DWORD __thiscall icu_56::DecimalFormatSymbols::DecimalFormatSymbols(icu_56::DecimalFormatSymbols *__hidden this, const struct icu_56::DecimalFormatSymbols *)
		extrn ??0DecimalFormatSymbols@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &)+79p
; _DWORD __thiscall __high icu_56::PluralFormat::PluralFormat(const struct icu_56::Locale *, enum UPluralType, const struct icu_56::UnicodeString *, enum UErrorCode *)
		extrn ??0PluralFormat@icu_56@@QAE@ABVLocale@1@W4UPluralType@@ABVUnicodeString@1@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedNumberFormat::createPluralFormat(UPluralType,icu_56::UnicodeString const &,UErrorCode &)+8Ap


		end
