;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	16E1184011679237EA9BCFB103B1F929
; Input	CRC32 :	3411B5CE

; File Name   :	D:\compspace\objfiles\firefox\i18n\uspoof_impl.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5 ; DATA XREF: .rdata:`string'o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
					; DATA XREF: .data:long	`icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)'::`2'::__LINE__Varo
_rdata		ends			; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_800
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_1000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B db	0
byte_ED		db 3 dup(0)		; DATA XREF: .data:long	`icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)'::`2'::__LINE__Varo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; char `public:	static void * __cdecl icu_56::SpoofImpl::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@SpoofImpl@icu_56@@SAPAXXZ@4DA db ?
					; DATA XREF: icu_56::SpoofImpl::getStaticClassID(void)+1Eo
		align 4
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_FF:					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 134h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 138h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 170h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::IdentifierInfo & __thiscall icu_56::IdentifierInfo::operator=(class icu_56::IdentifierInfo const &)
		public ??4IdentifierInfo@icu_56@@QAEAAV01@ABV01@@Z
??4IdentifierInfo@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]

loc_1C0:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4IdentifierInfo@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::SpoofImpl::getStaticClassID()
		public ?getStaticClassID@SpoofImpl@icu_56@@SAPAXXZ
?getStaticClassID@SpoofImpl@icu_56@@SAPAXXZ proc near
					; CODE XREF: icu_56::SpoofImpl::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'

loc_1FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@SpoofImpl@icu_56@@SAPAXXZ@4DA	; char `icu_56::SpoofImpl::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@SpoofImpl@icu_56@@SAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 214h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::SpoofImpl::getDynamicClassID(icu_56::SpoofImpl *__hidden this)
		public ?getDynamicClassID@SpoofImpl@icu_56@@UBEPAXXZ
?getDynamicClassID@SpoofImpl@icu_56@@UBEPAXXZ proc near	; DATA XREF: .rdata:00000504o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@SpoofImpl@icu_56@@SAPAXXZ ; icu_56::SpoofImpl::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@SpoofImpl@icu_56@@UBEPAXXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 250h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl *this, struct icu_56::SpoofData *, enum UErrorCode *)
		public ??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z
??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z proc	near

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7SpoofImpl@icu_56@@6B@ ; const icu_56::SpoofImpl::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0FFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_309
		jmp	loc_3F5
; ---------------------------------------------------------------------------

loc_309:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+B2j
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+18h], 30000000h
		mov	esi, esp
		push	34h ; '4'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_EC], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_EC], 0
		jz	short loc_37D
		mov	esi, esp
		push	10FFFFh		; int
		push	0		; int
		mov	ecx, [ebp+var_EC] ; this
		call	dword ptr ds:__imp_??0UnicodeSet@icu_56@@QAE@HH@Z ; icu_56::UnicodeSet::UnicodeSet(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_EC]
		mov	dword ptr [eax], offset	??_SUnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeFunctor'}
		mov	ecx, [ebp+var_EC]
		mov	dword ptr [ecx+4], offset ??_SUnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeMatcher'}
		mov	edx, [ebp+var_EC]
		mov	[ebp+var_100], edx
		jmp	short loc_387
; ---------------------------------------------------------------------------

loc_37D:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+E8j
		mov	[ebp+var_100], 0

loc_387:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+12Bj
		mov	eax, [ebp+var_100]
		mov	[ebp+var_F8], eax
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_F8]
		mov	[ebp+var_20], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_20] ; this
		call	dword ptr ds:__imp_?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ	; icu_56::UnicodeSet::freeze(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	`string'
		call	_uprv_strdup_56
		add	esp, 4
		mov	ecx, [ebp+var_14]
		mov	[ecx+14h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_3E0
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_3EB

loc_3E0:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+185j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		jmp	short loc_3F5
; ---------------------------------------------------------------------------

loc_3EB:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+18Ej
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 3845FDEFh

loc_3F5:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+B4j
					; icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+199j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]

loc_3FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 420h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000050Co
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00000514o
		mov	esi, esp
		mov	eax, [ebp-0ECh]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-104h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 46Ch
		public ??_C@_00CNPNBAHC@?$AA@
; `string'
??_C@_00CNPNBAHC@?$AA@ db 0		; DATA XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+16Bo
					; icu_56::SpoofImpl::SpoofImpl(void)+148o ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 470h
		dd offset ??_R4UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeMatcher'}
		public ??_SUnicodeSet@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeMatcher'}
??_SUnicodeSet@icu_56@@6BUnicodeMatcher@1@@ dd offset ??_EUnicodeSet@icu_56@@W3AEPAXI@Z
					; DATA XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+118o
					; icu_56::SpoofImpl::SpoofImpl(void)+F5o ...
					; [thunk]:icu_56::UnicodeSet::`vector deleting destructor'`adjustor{4}' (uint)
		dd offset ?matches@UnicodeSet@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z ; icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed	char)
		dd offset ?toPattern@UnicodeSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z	; icu_56::UnicodeSet::toPattern(icu_56::UnicodeString &,signed char)
		dd offset ?matchesIndexValue@UnicodeSet@icu_56@@EBECE@Z	; icu_56::UnicodeSet::matchesIndexValue(uchar)
		dd offset ?addMatchSetTo@UnicodeSet@icu_56@@UBEXAAV12@@Z ; icu_56::UnicodeSet::addMatchSetTo(icu_56::UnicodeSet	&)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 488h
		dd offset ??_R4UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeFunctor'}
		public ??_SUnicodeSet@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeFunctor'}
??_SUnicodeSet@icu_56@@6BUnicodeFunctor@1@@ dd offset ??_EUnicodeSet@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+10Co
					; icu_56::SpoofImpl::SpoofImpl(void)+E9o ...
					; icu_56::UnicodeSet::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeSet@icu_56@@UBEPAXXZ ; icu_56::UnicodeSet::getDynamicClassID(void)
		dd offset ?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ ;	icu_56::UnicodeSet::clone(void)
		dd offset ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ ; icu_56::UnicodeFilter::toMatcher(void)
		dd offset ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ	; icu_56::UnicodeFunctor::toReplacer(void)
		dd offset ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z ; icu_56::UnicodeFilter::setData(icu_56::TransliterationRuleData const *)
		dd offset ?contains@UnicodeSet@icu_56@@UBECH@Z ; icu_56::UnicodeSet::contains(int)
		dd offset ??8UnicodeSet@icu_56@@UBECABV01@@Z ; icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &)
		dd offset ?hashCode@UnicodeSet@icu_56@@UBEHXZ ;	icu_56::UnicodeSet::hashCode(void)
		dd offset ?size@UnicodeSet@icu_56@@UBEHXZ ; icu_56::UnicodeSet::size(void)
		dd offset ?isEmpty@UnicodeSet@icu_56@@UBECXZ ; icu_56::UnicodeSet::isEmpty(void)
		dd offset ?contains@UnicodeSet@icu_56@@UBECHH@Z	; icu_56::UnicodeSet::contains(int,int)
		dd offset ?containsAll@UnicodeSet@icu_56@@UBECABV12@@Z ; icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet const &)
		dd offset ?add@UnicodeSet@icu_56@@UAEAAV12@HH@Z	; icu_56::UnicodeSet::add(int,int)
		dd offset ?addAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ; icu_56::UnicodeSet::addAll(icu_56::UnicodeSet const &)
		dd offset ?retainAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ; icu_56::UnicodeSet::retainAll(icu_56::UnicodeSet const &)
		dd offset ?complementAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ;	icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet const &)
		dd offset ?removeAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ; icu_56::UnicodeSet::removeAll(icu_56::UnicodeSet const &)
		dd offset ?retain@UnicodeSet@icu_56@@UAEAAV12@HH@Z ; icu_56::UnicodeSet::retain(int,int)
		dd offset ?remove@UnicodeSet@icu_56@@UAEAAV12@HH@Z ; icu_56::UnicodeSet::remove(int,int)
		dd offset ?complement@UnicodeSet@icu_56@@UAEAAV12@HH@Z ; icu_56::UnicodeSet::complement(int,int)
		dd offset ?complement@UnicodeSet@icu_56@@UAEAAV12@XZ ; icu_56::UnicodeSet::complement(void)
		dd offset ?clear@UnicodeSet@icu_56@@UAEAAV12@XZ	; icu_56::UnicodeSet::clear(void)
		dd offset ?removeAllStrings@UnicodeSet@icu_56@@UAEAAV12@XZ ; icu_56::UnicodeSet::removeAllStrings(void)
		dd offset ?getRangeCount@UnicodeSet@icu_56@@UBEHXZ ; icu_56::UnicodeSet::getRangeCount(void)
		dd offset ?getRangeStart@UnicodeSet@icu_56@@UBEHH@Z ; icu_56::UnicodeSet::getRangeStart(int)
		dd offset ?getRangeEnd@UnicodeSet@icu_56@@UBEHH@Z ; icu_56::UnicodeSet::getRangeEnd(int)
		dd offset ?compact@UnicodeSet@icu_56@@UAEAAV12@XZ ; icu_56::UnicodeSet::compact(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4FCh
		dd offset ??_R4SpoofImpl@icu_56@@6B@ ; const icu_56::SpoofImpl::`RTTI Complete Object Locator'
		public ??_7SpoofImpl@icu_56@@6B@
; const	icu_56::SpoofImpl::`vftable'
??_7SpoofImpl@icu_56@@6B@ dd offset ??_ESpoofImpl@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+5Eo
					; icu_56::SpoofImpl::SpoofImpl(void)+5Eo ...
					; icu_56::SpoofImpl::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@SpoofImpl@icu_56@@UBEPAXXZ	; icu_56::SpoofImpl::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 508h
__unwindtable$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000520o
		dd offset __unwindfunclet$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z	dd 19930522h, 2
					; DATA XREF: __ehhandler$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 53Ch
		public ??_R4SpoofImpl@icu_56@@6B@
; const	icu_56::SpoofImpl::`RTTI Complete Object Locator'
??_R4SpoofImpl@icu_56@@6B@ dd 3	dup(0)	; DATA XREF: .rdata:000004FCo
		dd offset ??_R0?AVSpoofImpl@icu_56@@@8 ; icu_56::SpoofImpl `RTTI Type Descriptor'
		dd offset ??_R3SpoofImpl@icu_56@@8 ; icu_56::SpoofImpl::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 550h
		public ??_R0?AVSpoofImpl@icu_56@@@8
; class	icu_56::SpoofImpl `RTTI	Type Descriptor'
??_R0?AVSpoofImpl@icu_56@@@8 dd	offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000548o
					; .rdata$r:icu_56::SpoofImpl::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avspoofimpl@	db '.?AVSpoofImpl@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 570h
		public ??_R3SpoofImpl@icu_56@@8
; icu_56::SpoofImpl::`RTTI Class Hierarchy Descriptor'
??_R3SpoofImpl@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000054Co
					; .rdata$r:000005A8o
		dd 3
		dd offset ??_R2SpoofImpl@icu_56@@8 ; icu_56::SpoofImpl::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 580h
		public ??_R2SpoofImpl@icu_56@@8
; icu_56::SpoofImpl::`RTTI Base	Class Array'
??_R2SpoofImpl@icu_56@@8 dd offset ??_R1A@?0A@EA@SpoofImpl@icu_56@@8
					; DATA XREF: .rdata$r:0000057Co
					; icu_56::SpoofImpl::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 590h
		public ??_R1A@?0A@EA@SpoofImpl@icu_56@@8
; icu_56::SpoofImpl::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@SpoofImpl@icu_56@@8 dd offset ??_R0?AVSpoofImpl@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::SpoofImpl::`RTTI Base Class Array'o
					; icu_56::SpoofImpl `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3SpoofImpl@icu_56@@8 ; icu_56::SpoofImpl::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5ACh
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:00000584o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Array'o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 5C8h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5E8h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000005C4o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5F8h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:000005F4o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 604h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000588o
					; .rdata$r:000005FCo ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 620h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 640h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000061Co
					; .rdata$r:00000670o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 650h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:0000064Co
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 658h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 674h
		public ??_R4UnicodeSet@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeFunctor'}
??_R4UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ dd	3 dup(0) ; DATA	XREF: .rdata:00000488o
		dd offset ??_R0?AVUnicodeSet@icu_56@@@8	; icu_56::UnicodeSet `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 688h
		public ??_R0?AVUnicodeSet@icu_56@@@8
; class	icu_56::UnicodeSet `RTTI Type Descriptor'
??_R0?AVUnicodeSet@icu_56@@@8 dd offset	??_7type_info@@6B@ ; DATA XREF:	.rdata$r:00000680o
					; .rdata$r:icu_56::UnicodeSet::`RTTI Base Class	Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		align 10h
a_?avunicodeset	db '.?AVUnicodeSet@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6A8h
		public ??_R3UnicodeSet@icu_56@@8
; icu_56::UnicodeSet::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeSet@icu_56@@8 dd 0		; DATA XREF: .rdata$r:00000684o
					; .rdata$r:000006ECo ...
		dd 1, 6
		dd offset ??_R2UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6B8h
		public ??_R2UnicodeSet@icu_56@@8
; icu_56::UnicodeSet::`RTTI Base Class Array'
??_R2UnicodeSet@icu_56@@8 dd offset ??_R1A@?0A@EA@UnicodeSet@icu_56@@8
					; DATA XREF: .rdata$r:000006B4o
					; icu_56::UnicodeSet::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8	; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 ; icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6D4h
		public ??_R1A@?0A@EA@UnicodeSet@icu_56@@8
; icu_56::UnicodeSet::`RTTI Base Class Descriptor at (0, -1, 0,	64)'
??_R1A@?0A@EA@UnicodeSet@icu_56@@8 dd offset ??_R0?AVUnicodeSet@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeSet::`RTTI	Base Class Array'o
					; icu_56::UnicodeSet `RTTI Type	Descriptor'
		dd 5, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6F0h
		public ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeFilter@icu_56@@8 dd offset	??_R0?AVUnicodeFilter@icu_56@@@8
					; DATA XREF: .rdata$r:000006BCo
					; .rdata$r:icu_56::UnicodeFilter::`RTTI	Base Class Array'o
					; icu_56::UnicodeFilter	`RTTI Type Descriptor'
		dd 4, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 70Ch
		public ??_R0?AVUnicodeFilter@icu_56@@@8
; class	icu_56::UnicodeFilter `RTTI Type Descriptor'
??_R0?AVUnicodeFilter@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UnicodeFilter::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodefil	db '.?AVUnicodeFilter@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 730h
		public ??_R3UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeFilter@icu_56@@8 dd	0	; DATA XREF: .rdata$r:00000708o
		dd 1, 5
		dd offset ??_R2UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 740h
		public ??_R2UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Array'
??_R2UnicodeFilter@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
					; DATA XREF: .rdata$r:0000073Co
					; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 ; icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 758h
		public ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 dd offset ??_R0?AVUnicodeFunctor@icu_56@@@8
					; DATA XREF: .rdata$r:000006C0o
					; .rdata$r:00000744o ...
					; icu_56::UnicodeFunctor `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 774h
		public ??_R0?AVUnicodeFunctor@icu_56@@@8
; class	icu_56::UnicodeFunctor `RTTI Type Descriptor'
??_R0?AVUnicodeFunctor@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodefun	db '.?AVUnicodeFunctor@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 798h
		public ??_R3UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeFunctor@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00000770o
		dd 3
		dd offset ??_R2UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7A8h
		public ??_R2UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
??_R2UnicodeFunctor@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
					; DATA XREF: .rdata$r:000007A4o
					; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7B8h
		public ??_R13?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UnicodeMatcher@icu_56@@8 dd offset	??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:000006CCo
					; .rdata$r:00000750o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 7D4h
		public ??_R0?AVUnicodeMatcher@icu_56@@@8
; class	icu_56::UnicodeMatcher `RTTI Type Descriptor'
??_R0?AVUnicodeMatcher@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodemat	db '.?AVUnicodeMatcher@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7F8h
		public ??_R3UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeMatcher@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:000007D0o
					; .rdata$r:00000828o
dword_800	dd 1			; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		dd offset ??_R2UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 808h
		public ??_R2UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
??_R2UnicodeMatcher@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
					; DATA XREF: .rdata$r:00000804o
					; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 810h
		public ??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8 dd offset ??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Array'o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 82Ch
		public ??_R4UnicodeSet@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeMatcher'}
??_R4UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ dd	0 ; DATA XREF: .rdata:00000470o
		dd 4, 0
		dd offset ??_R0?AVUnicodeSet@icu_56@@@8	; icu_56::UnicodeSet `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 840h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+A5p
					; icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl const &,UErrorCode &)+A6p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 86Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SpoofImpl::`scalar deleting	destructor'(unsigned int)
		public ??_GSpoofImpl@icu_56@@UAEPAXI@Z
??_GSpoofImpl@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SpoofImpl@icu_56@@UAE@XZ ; icu_56::SpoofImpl::~SpoofImpl(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_8B5
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8B5:				; CODE XREF: icu_56::SpoofImpl::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSpoofImpl@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeSet::`scalar	deleting destructor'(unsigned int)
		public ??_GUnicodeSet@icu_56@@UAEPAXI@Z
??_GUnicodeSet@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_923
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_923:				; CODE XREF: icu_56::UnicodeSet::`scalar deleting destructor'(uint)+3Bj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeSet@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 93Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl *__hidden this)
		public ??0SpoofImpl@icu_56@@QAE@XZ
??0SpoofImpl@icu_56@@QAE@XZ proc near

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SpoofImpl@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7SpoofImpl@icu_56@@6B@ ; const icu_56::SpoofImpl::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 3845FDEFh
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0FFFFh
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+1Ch], 0
		mov	esi, esp
		push	34h ; '4'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_EC], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_EC], 0
		jz	short loc_A46
		mov	esi, esp
		push	10FFFFh		; int
		push	0		; int
		mov	ecx, [ebp+var_EC] ; this
		call	dword ptr ds:__imp_??0UnicodeSet@icu_56@@QAE@HH@Z ; icu_56::UnicodeSet::UnicodeSet(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_EC]
		mov	dword ptr [eax], offset	??_SUnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeFunctor'}
		mov	ecx, [ebp+var_EC]
		mov	dword ptr [ecx+4], offset ??_SUnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeMatcher'}
		mov	edx, [ebp+var_EC]
		mov	[ebp+var_100], edx
		jmp	short loc_A50
; ---------------------------------------------------------------------------

loc_A46:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(void)+C5j
		mov	[ebp+var_100], 0

loc_A50:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(void)+108j
		mov	eax, [ebp+var_100]
		mov	[ebp+var_F8], eax
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_F8]
		mov	[ebp+var_20], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_20] ; this
		call	dword ptr ds:__imp_?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ	; icu_56::UnicodeSet::freeze(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	`string'
		call	_uprv_strdup_56
		add	esp, 4
		mov	ecx, [ebp+var_14]
		mov	[ecx+14h], eax
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+18h], 30000000h
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0SpoofImpl@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0ACCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SpoofImpl@icu_56@@QAE@XZ$0 proc near	; DATA XREF: .xdata$x:00000B1Co
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0SpoofImpl@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SpoofImpl@icu_56@@QAE@XZ$1 proc near	; DATA XREF: .xdata$x:00000B24o
		mov	esi, esp
		mov	eax, [ebp-0ECh]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0SpoofImpl@icu_56@@QAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SpoofImpl@icu_56@@QAE@XZ	proc near
					; DATA XREF: icu_56::SpoofImpl::SpoofImpl(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-104h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SpoofImpl@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0SpoofImpl@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0B18h
__unwindtable$??0SpoofImpl@icu_56@@QAE@XZ dd 0FFFFFFFFh	; DATA XREF: .xdata$x:00000B30o
		dd offset __unwindfunclet$??0SpoofImpl@icu_56@@QAE@XZ$0
		dd 0
		dd offset __unwindfunclet$??0SpoofImpl@icu_56@@QAE@XZ$1
__ehfuncinfo$??0SpoofImpl@icu_56@@QAE@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$??0SpoofImpl@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0SpoofImpl@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl *this, const	struct icu_56::SpoofImpl *, enum UErrorCode *)
		public ??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7SpoofImpl@icu_56@@6B@ ; const icu_56::SpoofImpl::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0FFFFh
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_C06
		jmp	loc_C8F
; ---------------------------------------------------------------------------

loc_C06:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl const &,UErrorCode &)+B3j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_C38
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]	; this
		call	?addReference@SpoofData@icu_56@@QAEPAV12@XZ ; icu_56::SpoofData::addReference(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx+0Ch], eax

loc_C38:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl const &,UErrorCode &)+D9j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14]
		mov	[ecx+10h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+10h], 0
		jnz	short loc_C6E
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7

loc_C6E:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl const &,UErrorCode &)+117j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		push	ecx
		call	_uprv_strdup_56
		add	esp, 4
		mov	edx, [ebp+var_14]
		mov	[edx+14h], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx

loc_C8F:				; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl const &,UErrorCode &)+B5j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0CBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00000CF0o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0CECh
__unwindtable$??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000CFCo
		dd offset __unwindfunclet$??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SpoofImpl::~SpoofImpl(icu_56::SpoofImpl *__hidden this)
		public ??1SpoofImpl@icu_56@@UAE@XZ
??1SpoofImpl@icu_56@@UAE@XZ proc near	; CODE XREF: icu_56::SpoofImpl::`scalar	deleting destructor'(uint)+26p

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1SpoofImpl@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7SpoofImpl@icu_56@@6B@ ; const icu_56::SpoofImpl::`vftable'
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_D88
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+0Ch]	; this
		call	?removeReference@SpoofData@icu_56@@QAEXXZ ; icu_56::SpoofData::removeReference(void)

loc_D88:				; CODE XREF: icu_56::SpoofImpl::~SpoofImpl(void)+63j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+10h]
		mov	[ebp+var_F8], ecx
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_104], edx
		cmp	[ebp+var_104], 0
		jz	short loc_DCE
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_104]
		mov	edx, [eax]
		mov	ecx, [ebp+var_104]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_DD8
; ---------------------------------------------------------------------------

loc_DCE:				; CODE XREF: icu_56::SpoofImpl::~SpoofImpl(void)+8Fj
		mov	[ebp+var_10C], 0

loc_DD8:				; CODE XREF: icu_56::SpoofImpl::~SpoofImpl(void)+B4j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+1Ch]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx

loc_DFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		cmp	[ebp+var_EC], 0
		jz	short loc_E2D
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_E37
; ---------------------------------------------------------------------------

loc_E2D:				; CODE XREF: icu_56::SpoofImpl::~SpoofImpl(void)+EEj
		mov	[ebp+var_10C], 0

loc_E37:				; CODE XREF: icu_56::SpoofImpl::~SpoofImpl(void)+113j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1SpoofImpl@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0E70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1SpoofImpl@icu_56@@UAE@XZ$0 proc near	; DATA XREF: .xdata$x:00000EA4o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1SpoofImpl@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1SpoofImpl@icu_56@@UAE@XZ	proc near
					; DATA XREF: icu_56::SpoofImpl::~SpoofImpl(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1SpoofImpl@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1SpoofImpl@icu_56@@UAE@XZ	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0EA0h
__unwindtable$??1SpoofImpl@icu_56@@UAE@XZ dd 0FFFFFFFFh	; DATA XREF: .xdata$x:00000EB0o
		dd offset __unwindfunclet$??1SpoofImpl@icu_56@@UAE@XZ$0
__ehfuncinfo$??1SpoofImpl@icu_56@@UAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1SpoofImpl@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1SpoofImpl@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ECCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::SpoofImpl *__cdecl icu_56::SpoofImpl::validateThis(const	struct USpoofChecker *,	enum UErrorCode	*)
		public ?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z
?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::SpoofImpl::validateThis(USpoofChecker *,UErrorCode	&)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_F03
		xor	eax, eax
		jmp	short loc_F61
; ---------------------------------------------------------------------------

loc_F03:				; CODE XREF: icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode &)+31j
		cmp	[ebp+arg_0], 0
		jnz	short loc_F16
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_F61
; ---------------------------------------------------------------------------

loc_F16:				; CODE XREF: icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode &)+3Bj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 3845FDEFh
		jnz	short loc_F31
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jnz	short loc_F3E

loc_F31:				; CODE XREF: icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode &)+5Aj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 3
		xor	eax, eax
		jmp	short loc_F61
; ---------------------------------------------------------------------------

loc_F3E:				; CODE XREF: icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode &)+63j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	eax, [edx]
		push	eax		; struct icu_56::SpoofDataHeader *
		call	?validateDataVersion@SpoofData@icu_56@@SACPBUSpoofDataHeader@2@AAW4UErrorCode@@@Z ; icu_56::SpoofData::validateDataVersion(icu_56::SpoofDataHeader const *,UErrorCode &)
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_F5E
		xor	eax, eax
		jmp	short loc_F61
; ---------------------------------------------------------------------------

loc_F5E:				; CODE XREF: icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode &)+8Cj
		mov	eax, [ebp+var_8]

loc_F61:				; CODE XREF: icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode &)+35j
					; icu_56::SpoofImpl::validateThis(USpoofChecker	const *,UErrorCode &)+48j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::SpoofImpl *__cdecl icu_56::SpoofImpl::validateThis(struct USpoofChecker *, enum UErrorCode *)
		public ?validateThis@SpoofImpl@icu_56@@SAPAV12@PAUUSpoofChecker@@AAW4UErrorCode@@@Z
?validateThis@SpoofImpl@icu_56@@SAPAV12@PAUUSpoofChecker@@AAW4UErrorCode@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?validateThis@SpoofImpl@icu_56@@SAPAV12@PAUUSpoofChecker@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::SpoofImpl::confusableLookup(icu_56::SpoofImpl *this, int, int,	struct icu_56::UnicodeString *)
		public ?confusableLookup@SpoofImpl@icu_56@@QBEHHHAAVUnicodeString@2@@Z
?confusableLookup@SpoofImpl@icu_56@@QBEHHHAAVUnicodeString@2@@Z	proc near

var_180		= byte ptr -180h
var_BC		= dword	ptr -0BCh
var_B0		= dword	ptr -0B0h
var_A4		= dword	ptr -0A4h
var_98		= word ptr -98h
var_8C		= dword	ptr -8Ch
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 180h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_180]
		mov	ecx, 60h ; '`'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ecx+14h]
		mov	[ebp+var_14], edx
		mov	[ebp+var_20], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ecx]
		mov	eax, [edx+10h]
		mov	ecx, [ebp+var_14]

loc_1000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_2C], edx

loc_1006:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+A2j
		mov	eax, [ebp+var_2C]
		sub	eax, [ebp+var_14]
		sar	eax, 2
		cdq
		sub	eax, edx
		sar	eax, 1
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_20]
		mov	ecx, [eax]
		and	ecx, 1FFFFFh
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_38]
		jnz	short loc_103F
		jmp	short $foundChar$70705
; ---------------------------------------------------------------------------
		jmp	short $foundChar$70705
; ---------------------------------------------------------------------------
		jmp	short loc_1055
; ---------------------------------------------------------------------------

loc_103F:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+7Bj
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_38]
		jge	short loc_104F
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		jmp	short loc_1055
; ---------------------------------------------------------------------------

loc_104F:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+89j
		mov	eax, [ebp+var_20]
		mov	[ebp+var_14], eax

loc_1055:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+81j
					; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+91j
		mov	eax, [ebp+var_2C]
		sub	eax, 4
		cmp	[ebp+var_14], eax
		jb	short loc_1006
		mov	eax, [ebp+var_14]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		mov	ecx, [eax]
		and	ecx, 1FFFFFh
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_38]
		jz	short $foundChar$70705
		mov	[ebp+var_50], 0
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@H@Z ;	icu_56::UnicodeString::append(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_50]
		jmp	loc_1309
; ---------------------------------------------------------------------------

$foundChar$70705:			; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+7Dj
					; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+7Fj ...
		mov	eax, [ebp+var_20]
		mov	ecx, [eax]
		and	ecx, 0FF000000h
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_5C]
		and	eax, [ebp+arg_4]
		jnz	$foundKey$70720
		mov	eax, [ebp+var_5C]
		and	eax, 10000000h
		jz	loc_1155
		mov	eax, [ebp+var_20]
		sub	eax, 4
		mov	[ebp+var_68], eax
		jmp	short loc_10DD
; ---------------------------------------------------------------------------

loc_10D4:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &):loc_110Dj
		mov	eax, [ebp+var_68]
		sub	eax, 4
		mov	[ebp+var_68], eax

loc_10DD:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+116j
		mov	eax, [ebp+var_68]
		mov	ecx, [eax]
		and	ecx, 0FFFFFFh
		cmp	ecx, [ebp+arg_0]
		jnz	short loc_110F
		mov	eax, [ebp+var_68]
		mov	ecx, [eax]
		and	ecx, 0FF000000h
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_5C]
		and	eax, [ebp+arg_4]
		jz	short loc_110D
		mov	eax, [ebp+var_68]
		mov	[ebp+var_20], eax
		jmp	short $foundKey$70720
; ---------------------------------------------------------------------------
		jmp	short $foundKey$70720
; ---------------------------------------------------------------------------

loc_110D:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+145j
		jmp	short loc_10D4
; ---------------------------------------------------------------------------

loc_110F:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+12Fj
		mov	eax, [ebp+var_20]
		add	eax, 4
		mov	[ebp+var_68], eax
		jmp	short loc_1123
; ---------------------------------------------------------------------------

loc_111A:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &):loc_1153j
		mov	eax, [ebp+var_68]
		add	eax, 4
		mov	[ebp+var_68], eax

loc_1123:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+15Cj
		mov	eax, [ebp+var_68]
		mov	ecx, [eax]
		and	ecx, 0FFFFFFh
		cmp	ecx, [ebp+arg_0]
		jnz	short loc_1155
		mov	eax, [ebp+var_68]
		mov	ecx, [eax]
		and	ecx, 0FF000000h
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_5C]
		and	eax, [ebp+arg_4]
		jz	short loc_1153
		mov	eax, [ebp+var_68]
		mov	[ebp+var_20], eax
		jmp	short $foundKey$70720
; ---------------------------------------------------------------------------
		jmp	short $foundKey$70720
; ---------------------------------------------------------------------------

loc_1153:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+18Bj
		jmp	short loc_111A
; ---------------------------------------------------------------------------

loc_1155:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+107j
					; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+175j
		mov	[ebp+var_74], 0
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@H@Z ;	icu_56::UnicodeString::append(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_74]
		jmp	loc_1309
; ---------------------------------------------------------------------------

$foundKey$70720:			; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+F9j
					; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+14Dj ...
		mov	eax, [ebp+var_5C]
		sar	eax, 1Dh
		and	eax, 3
		add	eax, 1
		mov	[ebp+var_80], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_20]
		sub	edx, [ecx+14h]
		sar	edx, 2
		mov	[ebp+var_8C], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ecx+18h]
		mov	eax, [ebp+var_8C]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_98], cx
		cmp	[ebp+var_80], 1
		jnz	short loc_11E2
		mov	esi, esp
		movzx	eax, [ebp+var_98]
		push	eax		; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, 1
		jmp	loc_1309
; ---------------------------------------------------------------------------

loc_11E2:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+200j
		cmp	[ebp+var_80], 4
		jnz	loc_1293
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ecx]
		mov	eax, [edx+28h]
		mov	[ebp+var_B0], eax
		mov	[ebp+var_A4], 0
		jmp	short loc_1218
; ---------------------------------------------------------------------------

loc_1209:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &):loc_125Dj
		mov	eax, [ebp+var_A4]
		add	eax, 1
		mov	[ebp+var_A4], eax

loc_1218:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+24Bj
		mov	eax, [ebp+var_A4]
		cmp	eax, [ebp+var_B0]
		jge	short loc_125F
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ecx+1Ch]
		mov	eax, [ebp+var_A4]
		movzx	ecx, word ptr [edx+eax*4]
		movzx	edx, [ebp+var_98]
		cmp	ecx, edx
		jl	short loc_125D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ecx+1Ch]
		mov	eax, [ebp+var_A4]
		movzx	ecx, word ptr [edx+eax*4+2]
		mov	[ebp+var_80], ecx
		jmp	short loc_125F
; ---------------------------------------------------------------------------

loc_125D:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+286j
		jmp	short loc_1209
; ---------------------------------------------------------------------------

loc_125F:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+268j
					; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+29Fj
		mov	eax, [ebp+var_A4]
		cmp	eax, [ebp+var_B0]
		jl	short loc_1293
		mov	ecx, ds:?__LINE__Var@?1??confusableLookup@SpoofImpl@icu_56@@QBEHHHAAVUnicodeString@3@@Z@4JA ; long `icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)'::`2'::__LINE__Var
		add	ecx, 53h ; 'S'
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1GA@GIKCGJBN@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_1DA@KKAONOPC@?$AAi?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AAs?$AAL?$AAi?$AAm?$AAi?$AAt?$AA?$AA@ ; "ix < stringLengthsLimit"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1293:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+22Aj
					; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+2AFj
		movzx	eax, [ebp+var_98]
		add	eax, [ebp+var_80]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	ecx, [edx]
		cmp	eax, [ecx+20h]
		jle	short loc_12D0
		mov	edx, ds:?__LINE__Var@?1??confusableLookup@SpoofImpl@icu_56@@QBEHHHAAVUnicodeString@3@@Z@4JA ; long `icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)'::`2'::__LINE__Var
		add	edx, 56h ; 'V'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1GA@GIKCGJBN@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_1HM@IDMFLPP@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$CL?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAL?$AAe?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAf?$AAS?$AAp?$AAo?$AAo?$AAf?$AAD?$AAa?$AAt?$AAa?$AA?9@ ; "value + stringLen <= fSpoofData->fRawDa"...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_12D0:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+2ECj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		movzx	edx, [ebp+var_98]
		mov	eax, [ecx+20h]
		lea	ecx, [eax+edx*2]
		mov	[ebp+var_BC], ecx
		mov	esi, esp
		mov	eax, [ebp+var_80]
		push	eax		; int
		mov	ecx, [ebp+var_BC]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z ; icu_56::UnicodeString::append(wchar_t const	*,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_80]

loc_1309:				; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+E0j
					; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+1B9j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 180h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?confusableLookup@SpoofImpl@icu_56@@QBEHHHAAVUnicodeString@2@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 1320h
		public ??_C@_1HM@IDMFLPP@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$CL?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAL?$AAe?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAf?$AAS?$AAp?$AAo?$AAo?$AAf?$AAD?$AAa?$AAt?$AAa?$AA?9@
; wchar_t `string'
??_C@_1HM@IDMFLPP@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$CL?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAL?$AAe?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAf?$AAS?$AAp?$AAo?$AAo?$AAf?$AAD?$AAa?$AAt?$AAa?$AA?9@:
					; DATA XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+2FFo
		unicode	0, <value + stringLen >
		dw 3Ch
		unicode	0, <= fSpoofData->
		dw 3Eh
		unicode	0, <fRawData->
		dw 3Eh
		unicode	0, <fCFUStringTableLen>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 139Ch
		public ??_C@_1DA@KKAONOPC@?$AAi?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AAs?$AAL?$AAi?$AAm?$AAi?$AAt?$AA?$AA@
; wchar_t `string'
??_C@_1DA@KKAONOPC@?$AAi?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AAs?$AAL?$AAi?$AAm?$AAi?$AAt?$AA?$AA@:
					; DATA XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+2C2o
		unicode	0, <ix >
		dw 3Ch
		unicode	0, < stringLengthsLimit>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 13CCh
		public ??_C@_1GA@GIKCGJBN@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@
; wchar_t `string'
??_C@_1GA@GIKCGJBN@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@:
					; DATA XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+2BDo
					; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+2FAo ...
		unicode	0, <d:\mozilla\intl\icu\source\i18n\uspoof_impl.cpp>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 142Ch
		public ?__LINE__Var@?1??confusableLookup@SpoofImpl@icu_56@@QBEHHHAAVUnicodeString@3@@Z@4JA
; long `public:	int __thiscall icu_56::SpoofImpl::confusableLookup(int,	int, class icu_56::UnicodeString &)const'::`2'::__LINE__Var
?__LINE__Var@?1??confusableLookup@SpoofImpl@icu_56@@QBEHHHAAVUnicodeString@3@@Z@4JA dd offset ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
					; DATA XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+2B1r
					; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+2EEr
_data		ends			; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::right

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1430h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::SpoofImpl::wholeScriptCheck(icu_56::SpoofImpl	*this, const struct icu_56::UnicodeString *, struct icu_56::ScriptSet *, enum UErrorCode *)
		public ?wholeScriptCheck@SpoofImpl@icu_56@@QBEXABVUnicodeString@2@PAVScriptSet@2@AAW4UErrorCode@@@Z
?wholeScriptCheck@SpoofImpl@icu_56@@QBEXABVUnicodeString@2@PAVScriptSet@2@AAW4UErrorCode@@@Z proc near

var_118		= dword	ptr -118h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		and	ecx, 8
		jz	short loc_146F
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	ecx, [eax+24h]
		mov	[ebp+var_118], ecx
		jmp	short loc_147E
; ---------------------------------------------------------------------------

loc_146F:				; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+2Cj
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	ecx, [eax+28h]
		mov	[ebp+var_118], ecx

loc_147E:				; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+3Dj
		mov	edx, [ebp+var_118]
		mov	[ebp+var_14], edx
		mov	ecx, [ebp+arg_4] ; this
		call	?setAll@ScriptSet@icu_56@@QAEAAV12@XZ ;	icu_56::ScriptSet::setAll(void)
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	[ebp+var_2C], 0

loc_14AB:				; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &):loc_156Ej
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jge	loc_1573
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?char32At@UnicodeString@icu_56@@QBEHH@Z ; icu_56::UnicodeString::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_38], eax
		mov	eax, 0FFFFh
		cmp	eax, [ebp+var_38]
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		add	ecx, [ebp+var_2C]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		call	_utrie2_get32_56
		add	esp, 8
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 0
		jnz	short loc_154E
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		call	_uscript_getScript_56
		add	esp, 8
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], 1
		jg	short loc_153C
		mov	eax, ds:?__LINE__Var@?1??wholeScriptCheck@SpoofImpl@icu_56@@QBEXABVUnicodeString@3@PAVScriptSet@3@AAW4UErrorCode@@@Z@4JA ; long	`icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)'::`2'::__LINE__Var
		add	eax, 10h
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1GA@GIKCGJBN@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_1DK@FHBGJMNE@?$AAc?$AAp?$AAS?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AA?$DO?$AA?5?$AAU?$AAS?$AAC?$AAR?$AAI?$AAP?$AAT?$AA_?$AAI?$AAN?$AAH?$AAE?$AAR?$AAI?$AAT?$AAE?$AAD?$AA?$AA@ ; "cpScript > USCRIPT_INHERITED"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_153C:				; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+E5j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_50]
		push	ecx
		mov	ecx, [ebp+arg_4]
		call	?intersect@ScriptSet@icu_56@@QAEAAV12@W4UScriptCode@@AAW4UErrorCode@@@Z	; icu_56::ScriptSet::intersect(UScriptCode,UErrorCode &)
		jmp	short loc_156E
; ---------------------------------------------------------------------------

loc_154E:				; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+CCj
		cmp	[ebp+var_44], 1
		jnz	short loc_1556
		jmp	short loc_156E
; ---------------------------------------------------------------------------

loc_1556:				; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+122j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_44]
		imul	edx, 18h
		add	edx, [ecx+2Ch]
		push	edx		; struct icu_56::ScriptSet *
		mov	ecx, [ebp+arg_4] ; this
		call	?intersect@ScriptSet@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::ScriptSet::intersect(icu_56::ScriptSet	const &)

loc_156E:				; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+11Cj
					; icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+124j
		jmp	loc_14AB
; ---------------------------------------------------------------------------

loc_1573:				; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+81j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?wholeScriptCheck@SpoofImpl@icu_56@@QBEXABVUnicodeString@2@PAVScriptSet@2@AAW4UErrorCode@@@Z endp ; sp-analysis	failed

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 158Ch
		public ??_C@_1DK@FHBGJMNE@?$AAc?$AAp?$AAS?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AA?$DO?$AA?5?$AAU?$AAS?$AAC?$AAR?$AAI?$AAP?$AAT?$AA_?$AAI?$AAN?$AAH?$AAE?$AAR?$AAI?$AAT?$AAE?$AAD?$AA?$AA@
; wchar_t `string'
??_C@_1DK@FHBGJMNE@?$AAc?$AAp?$AAS?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AA?$DO?$AA?5?$AAU?$AAS?$AAC?$AAR?$AAI?$AAP?$AAT?$AA_?$AAI?$AAN?$AAH?$AAE?$AAR?$AAI?$AAT?$AAE?$AAD?$AA?$AA@:
					; DATA XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+F7o
		unicode	0, <cpScript >
		dw 3Eh
		unicode	0, < USCRIPT_INHERITED>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 15C8h
		public ?__LINE__Var@?1??wholeScriptCheck@SpoofImpl@icu_56@@QBEXABVUnicodeString@3@PAVScriptSet@3@AAW4UErrorCode@@@Z@4JA
; long `public:	void __thiscall	icu_56::SpoofImpl::wholeScriptCheck(class icu_56::UnicodeString	const &, class icu_56::ScriptSet *, enum  UErrorCode &)const'::`2'::__LINE__Var
?__LINE__Var@?1??wholeScriptCheck@SpoofImpl@icu_56@@QBEXABVUnicodeString@3@PAVScriptSet@3@AAW4UErrorCode@@@Z@4JA dd offset byte_ED
					; DATA XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+E7r
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::SpoofImpl::setAllowedLocales(icu_56::SpoofImpl *this,	const char *Str, enum UErrorCode *)
		public ?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z
?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z proc near

var_1FC		= dword	ptr -1FCh
var_1F4		= dword	ptr -1F4h
var_1E8		= dword	ptr -1E8h
var_1DC		= dword	ptr -1DCh
var_1D0		= dword	ptr -1D0h
var_1C4		= dword	ptr -1C4h
var_1B8		= dword	ptr -1B8h
var_EC		= dword	ptr -0ECh
var_E0		= byte ptr -0E0h
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_8C		= dword	ptr -8Ch
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= byte ptr -50h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
Str		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1FC]
		mov	ecx, 7Ch ; '|'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		lea	ecx, [ebp+var_50] ; this
		call	dword ptr ds:__imp_??0UnicodeSet@icu_56@@QAE@XZ	; icu_56::UnicodeSet::UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	[ebp+var_5C], 0
		mov	eax, [ebp+Str]
		mov	[ebp+var_68], eax
		mov	[ebp+var_74], 0
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		add	eax, [ebp+Str]
		mov	[ebp+var_80], eax
		mov	[ebp+var_8C], 0

loc_1657:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+188j
		mov	esi, esp
		push	2Ch ; ','       ; Val
		mov	eax, [ebp+var_68]
		push	eax		; Str
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_74], eax
		cmp	[ebp+var_74], 0
		jnz	short loc_167E
		mov	eax, [ebp+var_80]
		mov	[ebp+var_74], eax

loc_167E:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+AAj
					; icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+C6j
		mov	eax, [ebp+var_68]
		movsx	ecx, byte ptr [eax]
		cmp	ecx, 20h ; ' '
		jnz	short loc_1694
		mov	eax, [ebp+var_68]
		add	eax, 1
		mov	[ebp+var_68], eax
		jmp	short loc_167E
; ---------------------------------------------------------------------------

loc_1694:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+BBj
		mov	eax, [ebp+var_74]
		sub	eax, 1
		mov	[ebp+var_98], eax

loc_16A0:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+FCj
		mov	eax, [ebp+var_98]
		cmp	eax, [ebp+var_68]
		jbe	short loc_16CA
		mov	eax, [ebp+var_98]
		movsx	ecx, byte ptr [eax]
		cmp	ecx, 20h ; ' '
		jnz	short loc_16CA
		mov	eax, [ebp+var_98]
		sub	eax, 1
		mov	[ebp+var_98], eax
		jmp	short loc_16A0
; ---------------------------------------------------------------------------

loc_16CA:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+DDj
					; icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+EBj
		mov	eax, [ebp+var_98]
		cmp	eax, [ebp+var_68]
		ja	short loc_16DA
		jmp	loc_175A
; ---------------------------------------------------------------------------

loc_16DA:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+107j
		mov	eax, [ebp+var_98]
		add	eax, 1
		sub	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+var_68]
		push	ecx
		call	_uprv_strndup_56
		add	esp, 8
		mov	[ebp+var_A4], eax
		mov	eax, [ebp+var_8C]
		add	eax, 1
		mov	[ebp+var_8C], eax
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_50]
		push	ecx		; struct icu_56::UnicodeSet *
		mov	edx, [ebp+var_A4]
		push	edx		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet	*,UErrorCode &)
		mov	eax, [ebp+var_A4]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1745
		jmp	short loc_175A
; ---------------------------------------------------------------------------

loc_1745:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+175j
		mov	eax, [ebp+var_74]
		add	eax, 1
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_68]
		cmp	eax, [ebp+var_80]
		jb	loc_1657

loc_175A:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+109j
					; icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+177j
		cmp	[ebp+var_8C], 0
		jnz	loc_18E4
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	`string'
		call	_uprv_strdup_56
		add	esp, 4
		mov	ecx, [ebp+var_14]
		mov	[ecx+14h], eax
		mov	esi, esp
		push	34h ; '4'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1E8], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_1E8], 0
		jz	short loc_17F3
		mov	esi, esp
		push	10FFFFh		; int
		push	0		; int
		mov	ecx, [ebp+var_1E8] ; this
		call	dword ptr ds:__imp_??0UnicodeSet@icu_56@@QAE@HH@Z ; icu_56::UnicodeSet::UnicodeSet(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_1E8]
		mov	dword ptr [eax], offset	??_SUnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeFunctor'}
		mov	ecx, [ebp+var_1E8]
		mov	dword ptr [ecx+4], offset ??_SUnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeMatcher'}
		mov	edx, [ebp+var_1E8]
		mov	[ebp+var_1FC], edx
		jmp	short loc_17FD
; ---------------------------------------------------------------------------

loc_17F3:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+1E2j
		mov	[ebp+var_1FC], 0

loc_17FD:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+225j
		mov	eax, [ebp+var_1FC]
		mov	[ebp+var_1F4], eax
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_1F4]
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+14h], 0
		jz	short loc_1825
		cmp	[ebp+var_5C], 0
		jnz	short loc_184C

loc_1825:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+251j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_50] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_1AF8
; ---------------------------------------------------------------------------

loc_184C:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+257j
		mov	esi, esp
		mov	ecx, [ebp+var_5C] ; this
		call	dword ptr ds:__imp_?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ	; icu_56::UnicodeSet::freeze(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+10h]
		mov	[ebp+var_1D0], ecx
		mov	edx, [ebp+var_1D0]
		mov	[ebp+var_1DC], edx
		cmp	[ebp+var_1DC], 0
		jz	short loc_18A4
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_1DC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_1DC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1FC], eax
		jmp	short loc_18AE
; ---------------------------------------------------------------------------

loc_18A4:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+2B1j
		mov	[ebp+var_1FC], 0

loc_18AE:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+2D6j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_5C]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFBFh
		mov	edx, [ebp+var_14]
		mov	[edx+8], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_50] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_1AF8
; ---------------------------------------------------------------------------

loc_18E4:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+195j
		mov	esi, esp
		lea	ecx, [ebp+var_E0] ; this
		call	dword ptr ds:__imp_??0UnicodeSet@icu_56@@QAE@XZ	; icu_56::UnicodeSet::UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		push	100Ah
		lea	ecx, [ebp+var_E0]
		call	dword ptr ds:__imp_?applyIntPropertyValue@UnicodeSet@icu_56@@QAEAAV12@W4UProperty@@HAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::applyIntPropertyValue(UProperty,int,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	eax, [ebp+var_E0]
		push	eax		; struct icu_56::UnicodeSet *
		lea	ecx, [ebp+var_50] ; this
		call	dword ptr ds:__imp_?addAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z	; icu_56::UnicodeSet::addAll(icu_56::UnicodeSet	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		push	1
		push	100Ah
		lea	ecx, [ebp+var_E0]
		call	dword ptr ds:__imp_?applyIntPropertyValue@UnicodeSet@icu_56@@QAEAAV12@W4UProperty@@HAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::applyIntPropertyValue(UProperty,int,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	eax, [ebp+var_E0]
		push	eax		; struct icu_56::UnicodeSet *
		lea	ecx, [ebp+var_50] ; this
		call	dword ptr ds:__imp_?addAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z	; icu_56::UnicodeSet::addAll(icu_56::UnicodeSet	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_19BB
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_E0] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_50] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_1AF8
; ---------------------------------------------------------------------------

loc_19BB:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+3B6j
		mov	esi, esp
		lea	ecx, [ebp+var_50] ; this
		call	dword ptr ds:__imp_?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ ; icu_56::UnicodeSet::clone(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+Str]
		push	eax
		call	_uprv_strdup_56
		add	esp, 4
		mov	[ebp+var_EC], eax
		cmp	[ebp+var_5C], 0
		jz	short loc_19F1
		cmp	[ebp+var_EC], 0
		jnz	short loc_1A31

loc_19F1:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+41Aj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_E0] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_50] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_1AF8
; ---------------------------------------------------------------------------

loc_1A31:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+423j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_EC]
		mov	[eax+14h], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_5C] ; this
		call	dword ptr ds:__imp_?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ	; icu_56::UnicodeSet::freeze(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+10h]
		mov	[ebp+var_1B8], ecx
		mov	edx, [ebp+var_1B8]
		mov	[ebp+var_1C4], edx
		cmp	[ebp+var_1C4], 0
		jz	short loc_1AA4
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_1C4]
		mov	edx, [eax]
		mov	ecx, [ebp+var_1C4]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1FC], eax
		jmp	short loc_1AAE
; ---------------------------------------------------------------------------

loc_1AA4:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+4B1j
		mov	[ebp+var_1FC], 0

loc_1AAE:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+4D6j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_5C]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		or	ecx, 40h
		mov	edx, [ebp+var_14]
		mov	[edx+8], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_E0] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_50] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1AF8:				; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+27Bj
					; icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+313j	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN32
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 1FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN32		dd 2			; DATA XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+530o
		dd offset $LN31
$LN31		dd 0FFFFFFB0h, 34h	; DATA XREF: .text:00001B30o
		dd offset $LN28		; "allowedChars"
		dd 0FFFFFF20h, 34h
		dd offset $LN29		; "tempSet"
$LN29		db 'tempSet',0          ; DATA XREF: .text:00001B48o
$LN28		db 'allowedChars',0     ; DATA XREF: .text:00001B3Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1B64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00001BC8o
		mov	esi, esp
		lea	ecx, [ebp-50h]	; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00001BD0o
		mov	esi, esp
		mov	eax, [ebp-1E8h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00001BD8o
		mov	esi, esp
		lea	ecx, [ebp-0E0h]	; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z proc	near
					; DATA XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-200h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1BC4h
__unwindtable$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00001BE4o
		dd offset __unwindfunclet$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z$0
		align 10h
		dd offset __unwindfunclet$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z$1
		align 8
		dd offset __unwindfunclet$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z$2
__ehfuncinfo$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::SpoofImpl::getAllowedLocales(icu_56::SpoofImpl	*this, enum UErrorCode *)
		public ?getAllowedLocales@SpoofImpl@icu_56@@QAEPBDAAW4UErrorCode@@@Z
?getAllowedLocales@SpoofImpl@icu_56@@QAEPBDAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getAllowedLocales@SpoofImpl@icu_56@@QAEPBDAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::SpoofImpl::addScriptChars(icu_56::SpoofImpl *this, const char	*, struct icu_56::UnicodeSet *,	enum UErrorCode	*)
		public ?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z
?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+14Ep

var_1B0		= byte ptr -1B0h
var_EC		= dword	ptr -0ECh
var_E0		= byte ptr -0E0h
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1A4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1B0]
		mov	ecx, 69h ; 'i'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_8]
		push	eax
		push	1Eh
		lea	ecx, [ebp+var_98]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_uscript_getCode_56
		add	esp, 10h
		mov	[ebp+var_A4], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1CB2
		jmp	loc_1D74
; ---------------------------------------------------------------------------

loc_1CB2:				; CODE XREF: icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet *,UErrorCode &)+77j
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax], 0FFFFFF81h
		jnz	short loc_1CC8
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	loc_1D74
; ---------------------------------------------------------------------------

loc_1CC8:				; CODE XREF: icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet *,UErrorCode &)+84j
		mov	esi, esp
		lea	ecx, [ebp+var_E0] ; this
		call	dword ptr ds:__imp_??0UnicodeSet@icu_56@@QAE@XZ	; icu_56::UnicodeSet::UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	[ebp+var_EC], 0
		jmp	short loc_1CFF
; ---------------------------------------------------------------------------

loc_1CF0:				; CODE XREF: icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet *,UErrorCode &)+122j
		mov	eax, [ebp+var_EC]
		add	eax, 1
		mov	[ebp+var_EC], eax

loc_1CFF:				; CODE XREF: icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet *,UErrorCode &)+BAj
		mov	eax, [ebp+var_EC]
		cmp	eax, [ebp+var_A4]
		jge	short loc_1D58
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_EC]
		mov	edx, [ebp+ecx*4+var_98]
		push	edx
		push	100Ah
		lea	ecx, [ebp+var_E0]
		call	dword ptr ds:__imp_?applyIntPropertyValue@UnicodeSet@icu_56@@QAEAAV12@W4UProperty@@HAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::applyIntPropertyValue(UProperty,int,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	eax, [ebp+var_E0]
		push	eax
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_4]
		mov	eax, [edx+38h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_1CF0
; ---------------------------------------------------------------------------

loc_1D58:				; CODE XREF: icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet *,UErrorCode &)+D7j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_E0] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1D74:				; CODE XREF: icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet *,UErrorCode &)+79j
					; icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet *,UErrorCode &)+8Fj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1B0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN13		dd 2			; DATA XREF: icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet *,UErrorCode &)+144o
		dd offset $LN12
$LN12		dd 0FFFFFF68h, 78h	; DATA XREF: .text:00001DB4o
		dd offset $LN9		; "scripts"
		dd 0FFFFFF20h, 34h
		dd offset $LN10		; "tmpSet"
$LN10		db 'tmpSet',0           ; DATA XREF: .text:00001DCCo
$LN9		db 'scripts',0          ; DATA XREF: .text:00001DC0o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1DE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00001E24o
		mov	esi, esp
		lea	ecx, [ebp-0E0h]	; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1B4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1E20h
__unwindtable$?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001E30o
		dd offset __unwindfunclet$?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?addScriptChars@SpoofImpl@icu_56@@QAEXPBDPAVUnicodeSet@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::SpoofImpl::ScanHex(const wchar_t *, int, int, enum UErrorCode *)
		public ?ScanHex@SpoofImpl@icu_56@@SAHPB_WHHAAW4UErrorCode@@@Z
?ScanHex@SpoofImpl@icu_56@@SAHPB_WHHAAW4UErrorCode@@@Z proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1E86
		xor	eax, eax
		jmp	loc_1F70
; ---------------------------------------------------------------------------

loc_1E86:				; CODE XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+31j
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		test	eax, eax
		jg	short loc_1EB6
		mov	ecx, ds:?__LINE__Var@?1??ScanHex@SpoofImpl@icu_56@@SAHPB_WHHAAW4UErrorCode@@@Z@4JA@c90339c1
		add	ecx, 4
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1GA@GIKCGJBN@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_1CA@OLOFFFKJ@?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?9?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; "limit-start > 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1EB6:				; CODE XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+42j
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		jmp	short loc_1ECE
; ---------------------------------------------------------------------------

loc_1EC5:				; CODE XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+103j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_1ECE:				; CODE XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+77j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_8]
		jge	short loc_1F54
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		sub	edx, 30h ; '0'
		mov	[ebp+var_20], edx
		cmp	[ebp+var_20], 9
		jle	short loc_1EFC
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		sub	edx, 37h ; '7'
		mov	[ebp+var_20], edx

loc_1EFC:				; CODE XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+9Ej
		cmp	[ebp+var_20], 0Fh
		jle	short loc_1F12
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		sub	edx, 57h ; 'W'
		mov	[ebp+var_20], edx

loc_1F12:				; CODE XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+B4j
		cmp	[ebp+var_20], 0Fh
		jle	short loc_1F3D
		mov	eax, ds:?__LINE__Var@?1??ScanHex@SpoofImpl@icu_56@@SAHPB_WHHAAW4UErrorCode@@@Z@4JA@c90339c1
		add	eax, 0Fh
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1GA@GIKCGJBN@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_1CA@MCBNKMDK@?$AAd?$AAi?$AAg?$AAi?$AAt?$AAV?$AAa?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AAf?$AA?$AA@ ; "digitVal <= 0xf"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1F3D:				; CODE XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+CAj
		mov	eax, [ebp+var_8]
		shl	eax, 4
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_20]
		mov	[ebp+var_8], eax
		jmp	loc_1EC5
; ---------------------------------------------------------------------------

loc_1F54:				; CODE XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+88j
		cmp	[ebp+var_8], 10FFFFh
		jbe	short loc_1F6D
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 9
		mov	[ebp+var_8], 0

loc_1F6D:				; CODE XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+10Fj
		mov	eax, [ebp+var_8]

loc_1F70:				; CODE XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+35j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ScanHex@SpoofImpl@icu_56@@SAHPB_WHHAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1F84h
		public ??_C@_1CA@MCBNKMDK@?$AAd?$AAi?$AAg?$AAi?$AAt?$AAV?$AAa?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AAf?$AA?$AA@
; wchar_t `string'
??_C@_1CA@MCBNKMDK@?$AAd?$AAi?$AAg?$AAi?$AAt?$AAV?$AAa?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AAf?$AA?$AA@:
					; DATA XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+DCo
		unicode	0, <digitVal >
		dw 3Ch
		unicode	0, <= 0xf>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1FA4h
		public ??_C@_1CA@OLOFFFKJ@?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?9?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1CA@OLOFFFKJ@?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?9?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+55o
		unicode	0, <limit-start	>
		dw 3Eh
		unicode	0, < 0>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1FC4h
		public ?__LINE__Var@?1??ScanHex@SpoofImpl@icu_56@@SAHPB_WHHAAW4UErrorCode@@@Z@4JA@c90339c1
?__LINE__Var@?1??ScanHex@SpoofImpl@icu_56@@SAHPB_WHHAAW4UErrorCode@@@Z@4JA@c90339c1 dd 17Dh
					; DATA XREF: icu_56::SpoofImpl::ScanHex(wchar_t	const *,int,int,UErrorCode &)+44r
					; icu_56::SpoofImpl::ScanHex(wchar_t const *,int,int,UErrorCode	&)+CCr
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::IdentifierInfo	*__thiscall icu_56::SpoofImpl::getIdentifierInfo(icu_56::SpoofImpl *this, enum UErrorCode *)
		public ?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z
?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z proc near

var_130		= dword	ptr -130h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_38		= byte ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_130]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax

loc_1FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_202E
		mov	eax, [ebp+var_20]
		jmp	loc_2174
; ---------------------------------------------------------------------------

loc_202E:				; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+5Cj
		mov	eax, [ebp+var_14]
		mov	[ebp+var_2C], eax
		mov	esi, esp
		push	0		; struct UMutex	*
		lea	ecx, [ebp+var_38] ; this
		call	dword ptr ds:__imp_??0Mutex@icu_56@@QAE@PAUUMutex@@@Z ;	icu_56::Mutex::Mutex(UMutex *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+1Ch]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_2C]
		mov	dword ptr [eax+1Ch], 0
		mov	esi, esp
		lea	ecx, [ebp+var_38] ; this
		call	dword ptr ds:__imp_??1Mutex@icu_56@@QAE@XZ ; icu_56::Mutex::~Mutex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_20], 0
		jnz	loc_2171
		mov	esi, esp
		push	1Ch		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11C], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_11C], 0
		jz	short loc_20B8
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_11C] ; this
		call	??0IdentifierInfo@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::IdentifierInfo::IdentifierInfo(UErrorCode &)
		mov	[ebp+var_130], eax
		jmp	short loc_20C2
; ---------------------------------------------------------------------------

loc_20B8:				; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+D7j
		mov	[ebp+var_130], 0

loc_20C2:				; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+EEj
		mov	ecx, [ebp+var_130]
		mov	[ebp+var_128], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_128]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2102
		cmp	[ebp+var_20], 0
		jnz	short loc_2102
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7

loc_2102:				; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+129j
					; icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+12Fj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2171
		cmp	[ebp+var_20], 0
		jz	short loc_2171
		mov	eax, [ebp+var_20]
		mov	[ebp+var_104], eax
		mov	ecx, [ebp+var_104]
		mov	[ebp+var_110], ecx
		cmp	[ebp+var_110], 0
		jz	short loc_2160
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_110]
		mov	eax, [edx]
		mov	ecx, [ebp+var_110]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_130], eax
		jmp	short loc_216A
; ---------------------------------------------------------------------------

loc_2160:				; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+171j
		mov	[ebp+var_130], 0

loc_216A:				; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+196j
		mov	[ebp+var_20], 0

loc_2171:				; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+A9j
					; icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+14Dj ...
		mov	eax, [ebp+var_20]

loc_2174:				; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+61j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN16
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 130h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN16		dd 1			; DATA XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+1B0o
		dd offset $LN15
$LN15		dd 0FFFFFFC8h, 4	; DATA XREF: .text:000021ACo
		dd offset $LN13_0
$LN13_0		db 6Dh,	0		; DATA XREF: .text:000021B8o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 21C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:000021FCo
		mov	esi, esp
		mov	eax, [ebp-11Ch]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z proc	near
					; DATA XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-134h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 21F8h
__unwindtable$?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00002208o
		dd offset __unwindfunclet$?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2224h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+11Cp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2250h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::SpoofImpl::releaseIdentifierInfo(icu_56::SpoofImpl *this, struct icu_56::IdentifierInfo *)
		public ?releaseIdentifierInfo@SpoofImpl@icu_56@@QBEXPAVIdentifierInfo@2@@Z
?releaseIdentifierInfo@SpoofImpl@icu_56@@QBEXPAVIdentifierInfo@2@@Z proc near

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= byte ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	loc_230F
		mov	eax, [ebp+var_8]
		mov	[ebp+var_14], eax
		mov	esi, esp
		push	0		; struct UMutex	*
		lea	ecx, [ebp+var_20] ; this
		call	dword ptr ds:__imp_??0Mutex@icu_56@@QAE@PAUUMutex@@@Z ;	icu_56::Mutex::Mutex(UMutex *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+1Ch], 0
		jnz	short loc_22B0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax+1Ch], ecx
		mov	[ebp+arg_0], 0

loc_22B0:				; CODE XREF: icu_56::SpoofImpl::releaseIdentifierInfo(icu_56::IdentifierInfo *)+4Ej
		mov	esi, esp
		lea	ecx, [ebp+var_20] ; this
		call	dword ptr ds:__imp_??1Mutex@icu_56@@QAE@XZ ; icu_56::Mutex::~Mutex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_EC], eax
		mov	ecx, [ebp+var_EC]
		mov	[ebp+var_F8], ecx
		cmp	[ebp+var_F8], 0
		jz	short loc_2305
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_F8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_F8]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_100], eax
		jmp	short loc_230F
; ---------------------------------------------------------------------------

loc_2305:				; CODE XREF: icu_56::SpoofImpl::releaseIdentifierInfo(icu_56::IdentifierInfo *)+8Ej
		mov	[ebp+var_100], 0

loc_230F:				; CODE XREF: icu_56::SpoofImpl::releaseIdentifierInfo(icu_56::IdentifierInfo *)+27j
					; icu_56::SpoofImpl::releaseIdentifierInfo(icu_56::IdentifierInfo *)+B3j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?releaseIdentifierInfo@SpoofImpl@icu_56@@QBEXPAVIdentifierInfo@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN10_0		dd 1			; DATA XREF: icu_56::SpoofImpl::releaseIdentifierInfo(icu_56::IdentifierInfo *)+C3o
		dd offset $LN9_0
$LN9_0		dd 0FFFFFFE0h, 4	; DATA XREF: .text:0000233Co
		dd offset $LN8
$LN8		db 6Dh,	0		; DATA XREF: .text:00002348o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2350h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__cdecl	icu_56::SpoofData::validateDataVersion(const struct icu_56::SpoofDataHeader *, enum UErrorCode *)
		public ?validateDataVersion@SpoofData@icu_56@@SACPBUSpoofDataHeader@2@AAW4UErrorCode@@@Z
?validateDataVersion@SpoofData@icu_56@@SACPBUSpoofDataHeader@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode &)+7Fp
					; icu_56::SpoofData::SpoofData(UDataMemory *,UErrorCode	&)+66p	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	short loc_23AB
		cmp	[ebp+arg_0], 0
		jz	short loc_23AB
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 3845FDEFh
		jnz	short loc_23AB
		mov	eax, [ebp+arg_0]
		movzx	ecx, byte ptr [eax+4]
		cmp	ecx, 1
		jg	short loc_23AB
		mov	eax, [ebp+arg_0]
		movzx	ecx, byte ptr [eax+5]
		test	ecx, ecx
		jle	short loc_23B8

loc_23AB:				; CODE XREF: icu_56::SpoofData::validateDataVersion(icu_56::SpoofDataHeader const *,UErrorCode &)+31j
					; icu_56::SpoofData::validateDataVersion(icu_56::SpoofDataHeader const *,UErrorCode &)+37j ...
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 3
		xor	al, al
		jmp	short loc_23BA
; ---------------------------------------------------------------------------

loc_23B8:				; CODE XREF: icu_56::SpoofData::validateDataVersion(icu_56::SpoofDataHeader const *,UErrorCode &)+59j
		mov	al, 1

loc_23BA:				; CODE XREF: icu_56::SpoofData::validateDataVersion(icu_56::SpoofDataHeader const *,UErrorCode &)+66j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?validateDataVersion@SpoofData@icu_56@@SACPBUSpoofDataHeader@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::SpoofData *__cdecl icu_56::SpoofData::getDefault(enum UErrorCode *)
		public ?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z
?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z proc near

var_118		= dword	ptr -118h
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_118]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_0]
		push	eax
		push	0
		push	offset ?spoofDataIsAcceptable@icu_56@@YACPAXPBD1PBUUDataInfo@@@Z ; icu_56::spoofDataIsAcceptable(void *,char const *,char const	*,UDataInfo const *)
		push	offset ??_C@_0M@NKAJOPKO@confusables?$AA@ ; "confusables"
		push	offset ??_C@_03OJDKECCP@cfu?$AA@ ; `string'
		push	0
		call	_udata_openChoice_56
		add	esp, 18h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_244B
		xor	eax, eax
		jmp	loc_251E
; ---------------------------------------------------------------------------

loc_244B:				; CODE XREF: icu_56::SpoofData::getDefault(UErrorCode &)+72j
		mov	esi, esp
		push	30h ; '0'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_104], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_104], 0
		jz	short loc_2490
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14]
		push	ecx		; struct UDataMemory *
		mov	ecx, [ebp+var_104] ; this
		call	??0SpoofData@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z ; icu_56::SpoofData::SpoofData(UDataMemory *,UErrorCode &)
		mov	[ebp+var_118], eax
		jmp	short loc_249A
; ---------------------------------------------------------------------------

loc_2490:				; CODE XREF: icu_56::SpoofData::getDefault(UErrorCode &)+A3j
		mov	[ebp+var_118], 0

loc_249A:				; CODE XREF: icu_56::SpoofData::getDefault(UErrorCode &)+BEj
		mov	edx, [ebp+var_118]
		mov	[ebp+var_110], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_110]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_250C
		mov	eax, [ebp+var_20]
		mov	[ebp+var_EC], eax
		mov	ecx, [ebp+var_EC]
		mov	[ebp+var_F8], ecx
		cmp	[ebp+var_F8], 0
		jz	short loc_24FE
		push	1
		mov	ecx, [ebp+var_F8]
		call	??_GSpoofData@icu_56@@QAEPAXI@Z	; icu_56::SpoofData::`scalar deleting destructor'(uint)
		mov	[ebp+var_118], eax
		jmp	short loc_2508
; ---------------------------------------------------------------------------

loc_24FE:				; CODE XREF: icu_56::SpoofData::getDefault(UErrorCode &)+117j
		mov	[ebp+var_118], 0

loc_2508:				; CODE XREF: icu_56::SpoofData::getDefault(UErrorCode &)+12Cj
		xor	eax, eax
		jmp	short loc_251E
; ---------------------------------------------------------------------------

loc_250C:				; CODE XREF: icu_56::SpoofData::getDefault(UErrorCode &)+F9j
		cmp	[ebp+var_20], 0
		jnz	short loc_251B
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7

loc_251B:				; CODE XREF: icu_56::SpoofData::getDefault(UErrorCode &)+140j
		mov	eax, [ebp+var_20]

loc_251E:				; CODE XREF: icu_56::SpoofData::getDefault(UErrorCode &)+76j
					; icu_56::SpoofData::getDefault(UErrorCode &)+13Aj
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2540h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:0000258Co
		mov	esi, esp
		mov	eax, [ebp-104h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::SpoofData::getDefault(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-11Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2578h
		public ??_C@_03OJDKECCP@cfu?$AA@
; `string'
??_C@_03OJDKECCP@cfu?$AA@ dd 756663h	; DATA XREF: icu_56::SpoofData::getDefault(UErrorCode &)+4Do
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 257Ch
		public ??_C@_0M@NKAJOPKO@confusables?$AA@
; `string'
??_C@_0M@NKAJOPKO@confusables?$AA@ db 'confusables',0
					; DATA XREF: icu_56::SpoofData::getDefault(UErrorCode &)+48o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2588h
__unwindtable$?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002598o
		dd offset __unwindfunclet$?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl icu_56::spoofDataIsAcceptable(void *, char const *, char const *,	struct UDataInfo const *)
?spoofDataIsAcceptable@icu_56@@YACPAXPBD1PBUUDataInfo@@@Z proc near
					; DATA XREF: icu_56::SpoofData::getDefault(UErrorCode &)+43o

var_CC		= byte ptr -0CCh
Dst		= dword	ptr -8
arg_0		= dword	ptr  8
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		movzx	ecx, word ptr [eax]
		cmp	ecx, 14h
		jl	loc_266B
		mov	eax, [ebp+arg_C]
		movzx	ecx, byte ptr [eax+4]
		test	ecx, ecx
		jnz	short loc_266B
		mov	eax, [ebp+arg_C]
		movzx	ecx, byte ptr [eax+5]
		test	ecx, ecx
		jnz	short loc_266B
		mov	eax, [ebp+arg_C]
		movzx	ecx, byte ptr [eax+8]
		cmp	ecx, 43h ; 'C'
		jnz	short loc_266B
		mov	eax, [ebp+arg_C]
		movzx	ecx, byte ptr [eax+9]
		cmp	ecx, 66h ; 'f'
		jnz	short loc_266B
		mov	eax, [ebp+arg_C]
		movzx	ecx, byte ptr [eax+0Ah]
		cmp	ecx, 75h ; 'u'
		jnz	short loc_266B
		mov	eax, [ebp+arg_C]
		movzx	ecx, byte ptr [eax+0Bh]
		cmp	ecx, 20h ; ' '
		jnz	short loc_266B
		mov	eax, [ebp+arg_C]
		movzx	ecx, byte ptr [eax+0Ch]
		cmp	ecx, 1
		jnz	short loc_266B
		mov	eax, [ebp+arg_0]
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jz	short loc_2665
		push	1
		mov	eax, [ebp+arg_C]
		add	eax, 10h
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	4		; Size
		mov	ecx, [ebp+arg_C]
		add	ecx, 10h
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_2665:				; CODE XREF: icu_56::spoofDataIsAcceptable(void	*,char const *,char const *,UDataInfo const *)+89j
		mov	al, 1
		jmp	short loc_266D
; ---------------------------------------------------------------------------
		jmp	short loc_266D
; ---------------------------------------------------------------------------

loc_266B:				; CODE XREF: icu_56::spoofDataIsAcceptable(void	*,char const *,char const *,UDataInfo const *)+27j
					; icu_56::spoofDataIsAcceptable(void *,char const *,char const *,UDataInfo const *)+36j ...
		xor	al, al

loc_266D:				; CODE XREF: icu_56::spoofDataIsAcceptable(void	*,char const *,char const *,UDataInfo const *)+B3j
					; icu_56::spoofDataIsAcceptable(void *,char const *,char const *,UDataInfo const *)+B5j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?spoofDataIsAcceptable@icu_56@@YACPAXPBD1PBUUDataInfo@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2684h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::SpoofData::`scalar deleting	destructor'(unsigned int)
		public ??_GSpoofData@icu_56@@QAEPAXI@Z
??_GSpoofData@icu_56@@QAEPAXI@Z	proc near
					; CODE XREF: icu_56::SpoofData::getDefault(UErrorCode &)+121p
					; icu_56::SpoofData::removeReference(void)+5Cp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SpoofData@icu_56@@QAE@XZ ; icu_56::SpoofData::~SpoofData(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_26CD
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_26CD:				; CODE XREF: icu_56::SpoofData::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSpoofData@icu_56@@QAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SpoofData::SpoofData(icu_56::SpoofData *this, struct UDataMemory *,	enum UErrorCode	*)
		public ??0SpoofData@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z
??0SpoofData@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::SpoofData::getDefault(UErrorCode &)+B3p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?reset@SpoofData@icu_56@@QAEXXZ	; icu_56::SpoofData::reset(void)
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_272A
		jmp	short loc_2762
; ---------------------------------------------------------------------------

loc_272A:				; CODE XREF: icu_56::SpoofData::SpoofData(UDataMemory *,UErrorCode &)+3Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_udata_getMemory_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx		; struct icu_56::SpoofDataHeader *
		call	?validateDataVersion@SpoofData@icu_56@@SACPBUSpoofDataHeader@2@AAW4UErrorCode@@@Z ; icu_56::SpoofData::validateDataVersion(icu_56::SpoofDataHeader const *,UErrorCode &)
		add	esp, 8
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?initPtrs@SpoofData@icu_56@@QAEXAAW4UErrorCode@@@Z ; icu_56::SpoofData::initPtrs(UErrorCode &)

loc_2762:				; CODE XREF: icu_56::SpoofData::SpoofData(UDataMemory *,UErrorCode &)+40j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0SpoofData@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 277Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SpoofData::SpoofData(icu_56::SpoofData *this, const	void *,	int, enum UErrorCode *)
		public ??0SpoofData@icu_56@@QAE@PBXHAAW4UErrorCode@@@Z
??0SpoofData@icu_56@@QAE@PBXHAAW4UErrorCode@@@Z	proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?reset@SpoofData@icu_56@@QAEXXZ	; icu_56::SpoofData::reset(void)
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_27BE
		jmp	short loc_2816
; ---------------------------------------------------------------------------

loc_27BE:				; CODE XREF: icu_56::SpoofData::SpoofData(void const *,int,UErrorCode &)+3Ej
		cmp	[ebp+arg_4], 80h ; ''
		jnb	short loc_27D2
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 3
		jmp	short loc_2816
; ---------------------------------------------------------------------------

loc_27D2:				; CODE XREF: icu_56::SpoofData::SpoofData(void const *,int,UErrorCode &)+49j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+8]
		jge	short loc_27F8
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 3
		jmp	short loc_2816
; ---------------------------------------------------------------------------

loc_27F8:				; CODE XREF: icu_56::SpoofData::SpoofData(void const *,int,UErrorCode &)+6Fj
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx		; struct icu_56::SpoofDataHeader *
		call	?validateDataVersion@SpoofData@icu_56@@SACPBUSpoofDataHeader@2@AAW4UErrorCode@@@Z ; icu_56::SpoofData::validateDataVersion(icu_56::SpoofDataHeader const *,UErrorCode &)
		add	esp, 8
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?initPtrs@SpoofData@icu_56@@QAEXAAW4UErrorCode@@@Z ; icu_56::SpoofData::initPtrs(UErrorCode &)

loc_2816:				; CODE XREF: icu_56::SpoofData::SpoofData(void const *,int,UErrorCode &)+40j
					; icu_56::SpoofData::SpoofData(void const *,int,UErrorCode &)+54j ...
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0SpoofData@icu_56@@QAE@PBXHAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2830h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SpoofData::SpoofData(icu_56::SpoofData *this, enum UErrorCode *)
		public ??0SpoofData@icu_56@@QAE@AAW4UErrorCode@@@Z
??0SpoofData@icu_56@@QAE@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
Size		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?reset@SpoofData@icu_56@@QAEXXZ	; icu_56::SpoofData::reset(void)
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2875
		jmp	loc_292D
; ---------------------------------------------------------------------------

loc_2875:				; CODE XREF: icu_56::SpoofData::SpoofData(UErrorCode &)+3Ej
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+4], 1
		mov	[ebp+Size], 80h	; ''
		cmp	[ebp+Size], 80h	; ''
		jz	short loc_28B1
		mov	eax, ds:?__LINE__Var@?1???0SpoofData@icu_56@@QAE@AAW4UErrorCode@@@Z@4JA	; long `icu_56::SpoofData::SpoofData(UErrorCode	&)'::`2'::__LINE__Var
		add	eax, 0Ah
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1GA@GIKCGJBN@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_1EO@KDBEJCDP@?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAS?$AAp?$AAo?$AAo?$AAf?$AAD?$AAa?$AAt?$AAa?$AAH@ ; "initialSize == sizeof(SpoofDataHeader)"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_28B1:				; CODE XREF: icu_56::SpoofData::SpoofData(UErrorCode &)+5Aj
		mov	eax, [ebp+Size]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Size]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		jnz	short loc_28DE
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7
		jmp	short loc_292D
; ---------------------------------------------------------------------------

loc_28DE:				; CODE XREF: icu_56::SpoofData::SpoofData(UErrorCode &)+A1j
		mov	eax, [ebp+Size]
		push	eax		; Size
		push	0		; Val
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	dword ptr [ecx], 3845FDEFh
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	byte ptr [ecx+4], 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	byte ptr [ecx+5], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	byte ptr [ecx+6], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	byte ptr [ecx+7], 0
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?initPtrs@SpoofData@icu_56@@QAEXAAW4UErrorCode@@@Z ; icu_56::SpoofData::initPtrs(UErrorCode &)

loc_292D:				; CODE XREF: icu_56::SpoofData::SpoofData(UErrorCode &)+40j
					; icu_56::SpoofData::SpoofData(UErrorCode &)+ACj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0SpoofData@icu_56@@QAE@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2948h
		public ??_C@_1EO@KDBEJCDP@?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAS?$AAp?$AAo?$AAo?$AAf?$AAD?$AAa?$AAt?$AAa?$AAH@
; wchar_t `string'
??_C@_1EO@KDBEJCDP@?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAS?$AAp?$AAo?$AAo?$AAf?$AAD?$AAa?$AAt?$AAa?$AAH@:
					; DATA XREF: icu_56::SpoofData::SpoofData(UErrorCode &)+6Co
		unicode	0, <initialSize	== sizeof(SpoofDataHeader)>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2998h
		public ?__LINE__Var@?1???0SpoofData@icu_56@@QAE@AAW4UErrorCode@@@Z@4JA
; long `public:	__thiscall icu_56::SpoofData::SpoofData(enum  UErrorCode &)'::`2'::__LINE__Var
?__LINE__Var@?1???0SpoofData@icu_56@@QAE@AAW4UErrorCode@@@Z@4JA	dd 234h
					; DATA XREF: icu_56::SpoofData::SpoofData(UErrorCode &)+5Cr
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 299Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::SpoofData::reset(icu_56::SpoofData *__hidden this)
		public ?reset@SpoofData@icu_56@@QAEXXZ
?reset@SpoofData@icu_56@@QAEXXZ	proc near
					; CODE XREF: icu_56::SpoofData::SpoofData(UDataMemory *,UErrorCode &)+26p
					; icu_56::SpoofData::SpoofData(void const *,int,UErrorCode &)+26p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+10h], 1
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+2Ch], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?reset@SpoofData@icu_56@@QAEXXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::SpoofData::initPtrs(icu_56::SpoofData	*this, enum UErrorCode *)
		public ?initPtrs@SpoofData@icu_56@@QAEXAAW4UErrorCode@@@Z
?initPtrs@SpoofData@icu_56@@QAEXAAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::SpoofData::SpoofData(UDataMemory *,UErrorCode &)+75p
					; icu_56::SpoofData::SpoofData(void const *,int,UErrorCode &)+95p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2AA1
		jmp	loc_2BB9
; ---------------------------------------------------------------------------

loc_2AA1:				; CODE XREF: icu_56::SpoofData::initPtrs(UErrorCode &)+5Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+0Ch], 0
		jz	short loc_2ABF
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		add	eax, [ecx+0Ch]
		mov	ecx, [ebp+var_8]
		mov	[ecx+14h], eax

loc_2ABF:				; CODE XREF: icu_56::SpoofData::initPtrs(UErrorCode &)+6Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+14h], 0
		jz	short loc_2ADD
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		add	eax, [ecx+14h]
		mov	ecx, [ebp+var_8]
		mov	[ecx+18h], eax

loc_2ADD:				; CODE XREF: icu_56::SpoofData::initPtrs(UErrorCode &)+8Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+24h], 0
		jz	short loc_2AFB
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		add	eax, [ecx+24h]
		mov	ecx, [ebp+var_8]
		mov	[ecx+1Ch], eax

loc_2AFB:				; CODE XREF: icu_56::SpoofData::initPtrs(UErrorCode &)+AAj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+1Ch], 0
		jz	short loc_2B19
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		add	eax, [ecx+1Ch]
		mov	ecx, [ebp+var_8]
		mov	[ecx+20h], eax

loc_2B19:				; CODE XREF: icu_56::SpoofData::initPtrs(UErrorCode &)+C8j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+24h], 0
		jnz	short loc_2B5A
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+2Ch], 0
		jz	short loc_2B5A
		mov	eax, [ebp+arg_0]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	eax, [edx+30h]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, [edx+2Ch]
		push	ecx
		push	0
		call	_utrie2_openFromSerialized_56
		add	esp, 14h
		mov	edx, [ebp+var_8]
		mov	[edx+24h], eax

loc_2B5A:				; CODE XREF: icu_56::SpoofData::initPtrs(UErrorCode &)+E4j
					; icu_56::SpoofData::initPtrs(UErrorCode &)+EFj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+28h], 0
		jnz	short loc_2B9B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+34h], 0
		jz	short loc_2B9B
		mov	eax, [ebp+arg_0]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	eax, [edx+38h]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, [edx+34h]
		push	ecx
		push	0
		call	_utrie2_openFromSerialized_56
		add	esp, 14h
		mov	edx, [ebp+var_8]
		mov	[edx+28h], eax

loc_2B9B:				; CODE XREF: icu_56::SpoofData::initPtrs(UErrorCode &)+125j
					; icu_56::SpoofData::initPtrs(UErrorCode &)+130j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+3Ch], 0
		jz	short loc_2BB9
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		add	eax, [ecx+3Ch]
		mov	ecx, [ebp+var_8]
		mov	[ecx+2Ch], eax

loc_2BB9:				; CODE XREF: icu_56::SpoofData::initPtrs(UErrorCode &)+60j
					; icu_56::SpoofData::initPtrs(UErrorCode &)+168j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?initPtrs@SpoofData@icu_56@@QAEXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SpoofData::~SpoofData(icu_56::SpoofData *__hidden this)
		public ??1SpoofData@icu_56@@QAE@XZ
??1SpoofData@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::SpoofData::`scalar	deleting destructor'(uint)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24h]
		push	ecx
		call	_utrie2_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+28h]
		push	ecx
		call	_utrie2_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+4]
		test	ecx, ecx
		jz	short loc_2C3E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_2C3E:				; CODE XREF: icu_56::SpoofData::~SpoofData(void)+5Ej
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	short loc_2C5F
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx
		call	_udata_close_56
		add	esp, 4

loc_2C5F:				; CODE XREF: icu_56::SpoofData::~SpoofData(void)+7Ej
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1SpoofData@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::SpoofData::removeReference(icu_56::SpoofData *__hidden this)
		public ?removeReference@SpoofData@icu_56@@QAEXXZ
?removeReference@SpoofData@icu_56@@QAEXXZ proc near
					; CODE XREF: icu_56::SpoofImpl::~SpoofImpl(void)+6Bp

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi		; volatile __int32 *
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 10h
		push	eax		; lpAddend
		call	?umtx_atomic_dec@icu_56@@YAHPCJ@Z ; icu_56::umtx_atomic_dec(long volatile *)
		add	esp, 4
		test	eax, eax
		jnz	short loc_2CF3
		mov	eax, [ebp+var_8]
		mov	[ebp+var_D4], eax
		mov	ecx, [ebp+var_D4]
		mov	[ebp+var_E0], ecx
		cmp	[ebp+var_E0], 0
		jz	short loc_2CE9
		push	1
		mov	ecx, [ebp+var_E0]
		call	??_GSpoofData@icu_56@@QAEPAXI@Z	; icu_56::SpoofData::`scalar deleting destructor'(uint)
		mov	[ebp+var_E8], eax
		jmp	short loc_2CF3
; ---------------------------------------------------------------------------

loc_2CE9:				; CODE XREF: icu_56::SpoofData::removeReference(void)+52j
		mov	[ebp+var_E8], 0

loc_2CF3:				; CODE XREF: icu_56::SpoofData::removeReference(void)+34j
					; icu_56::SpoofData::removeReference(void)+67j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?removeReference@SpoofData@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::umtx_atomic_dec(volatile LONG *lpAddend, volatile	__int32	*)
		public ?umtx_atomic_dec@icu_56@@YAHPCJ@Z
?umtx_atomic_dec@icu_56@@YAHPCJ@Z proc near
					; CODE XREF: icu_56::SpoofData::removeReference(void)+2Ap

var_C0		= byte ptr -0C0h
lpAddend	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+lpAddend]
		push	eax		; lpAddend
		call	dword ptr ds:__imp__InterlockedDecrement@4 ; InterlockedDecrement(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?umtx_atomic_dec@icu_56@@YAHPCJ@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::SpoofData *__thiscall icu_56::SpoofData::addReference(icu_56::SpoofData *__hidden this)
		public ?addReference@SpoofData@icu_56@@QAEPAV12@XZ
?addReference@SpoofData@icu_56@@QAEPAV12@XZ proc near
					; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl const &,UErrorCode &)+E1p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi		; volatile __int32 *
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 10h
		push	eax		; lpAddend
		call	?umtx_atomic_inc@icu_56@@YAHPCJ@Z ; icu_56::umtx_atomic_inc(long volatile *)
		add	esp, 4
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?addReference@SpoofData@icu_56@@QAEPAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::umtx_atomic_inc(volatile LONG *lpAddend, volatile	__int32	*)
		public ?umtx_atomic_inc@icu_56@@YAHPCJ@Z
?umtx_atomic_inc@icu_56@@YAHPCJ@Z proc near
					; CODE XREF: icu_56::SpoofData::addReference(void)+2Ap

var_C0		= byte ptr -0C0h
lpAddend	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+lpAddend]
		push	eax		; lpAddend
		call	dword ptr ds:__imp__InterlockedIncrement@4 ; InterlockedIncrement(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?umtx_atomic_inc@icu_56@@YAHPCJ@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::SpoofData::reserveSpace(icu_56::SpoofData *this, size_t Size, enum UErrorCode *)
		public ?reserveSpace@SpoofData@icu_56@@QAEPAXHAAW4UErrorCode@@@Z
?reserveSpace@SpoofData@icu_56@@QAEPAXHAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
Size		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2E23
		xor	eax, eax
		jmp	loc_2EDC
; ---------------------------------------------------------------------------

loc_2E23:				; CODE XREF: icu_56::SpoofData::reserveSpace(int,UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+4]
		test	ecx, ecx
		jnz	short loc_2E65
		xor	eax, eax
		jnz	short loc_2E58
		mov	ecx, ds:?__LINE__Var@?1??reserveSpace@SpoofData@icu_56@@QAEPAXHAAW4UErrorCode@@@Z@4JA ;	long `icu_56::SpoofData::reserveSpace(int,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 5
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1GA@GIKCGJBN@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_13COJANIEC@?$AA0?$AA?$AA@ ; Message
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2E58:				; CODE XREF: icu_56::SpoofData::reserveSpace(int,UErrorCode &)+4Cj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 5
		xor	eax, eax
		jmp	short loc_2EDC
; ---------------------------------------------------------------------------

loc_2E65:				; CODE XREF: icu_56::SpoofData::reserveSpace(int,UErrorCode &)+48j
		mov	eax, [ebp+Size]
		add	eax, 0Fh
		and	eax, 0FFFFFFF0h
		mov	[ebp+Size], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		add	ecx, [ebp+Size]
		mov	edx, [ebp+var_8]
		mov	[edx+0Ch], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		push	eax
		call	_uprv_realloc_56
		add	esp, 8
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	[ecx+8], eax
		mov	eax, [ebp+Size]
		push	eax		; Size
		push	0		; Val
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		add	edx, [ebp+var_14]
		push	edx		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?initPtrs@SpoofData@icu_56@@QAEXAAW4UErrorCode@@@Z ; icu_56::SpoofData::initPtrs(UErrorCode &)
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		add	eax, [ebp+var_14]

loc_2EDC:				; CODE XREF: icu_56::SpoofData::reserveSpace(int,UErrorCode &)+3Aj
					; icu_56::SpoofData::reserveSpace(int,UErrorCode &)+7Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reserveSpace@SpoofData@icu_56@@QAEPAXHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2EF4h
		public ??_C@_13COJANIEC@?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_13COJANIEC@?$AA0?$AA?$AA@	dd offset ?_Rank@?$_Arithmetic_traits@K@std@@2HB
					; DATA XREF: icu_56::SpoofData::reserveSpace(int,UErrorCode &)+5Fo
_rdata		ends			; int const std::_Arithmetic_traits<ulong>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2EF8h
		public ?__LINE__Var@?1??reserveSpace@SpoofData@icu_56@@QAEPAXHAAW4UErrorCode@@@Z@4JA
; long `public:	void * __thiscall icu_56::SpoofData::reserveSpace(int, enum  UErrorCode	&)'::`2'::__LINE__Var
?__LINE__Var@?1??reserveSpace@SpoofData@icu_56@@QAEPAXHAAW4UErrorCode@@@Z@4JA dd 2B3h
					; DATA XREF: icu_56::SpoofData::reserveSpace(int,UErrorCode &)+4Er
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2EFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uspoof_swap_56
_uspoof_swap_56	proc near

var_144		= byte ptr -144h
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
Dst		= dword	ptr -50h
var_44		= dword	ptr -44h
Size		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 144h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_144]
		mov	ecx, 51h ; 'Q'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_2F35
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2F3C

loc_2F35:				; CODE XREF: _uspoof_swap_56+22j
		xor	eax, eax
		jmp	loc_34A9
; ---------------------------------------------------------------------------

loc_2F3C:				; CODE XREF: _uspoof_swap_56+37j
		cmp	[ebp+arg_0], 0
		jz	short loc_2F5A
		cmp	[ebp+arg_4], 0
		jz	short loc_2F5A
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jl	short loc_2F5A
		cmp	[ebp+arg_8], 0
		jle	short loc_2F6A
		cmp	[ebp+arg_C], 0
		jnz	short loc_2F6A

loc_2F5A:				; CODE XREF: _uspoof_swap_56+44j
					; _uspoof_swap_56+4Aj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_34A9
; ---------------------------------------------------------------------------

loc_2F6A:				; CODE XREF: _uspoof_swap_56+56j
					; _uspoof_swap_56+5Cj
		mov	eax, [ebp+arg_4]
		add	eax, 4
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+8]
		cmp	ecx, 43h ; 'C'
		jnz	short loc_2FAF
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+9]
		cmp	ecx, 66h ; 'f'
		jnz	short loc_2FAF
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+0Ah]
		cmp	ecx, 75h ; 'u'
		jnz	short loc_2FAF
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+0Bh]
		cmp	ecx, 20h ; ' '
		jnz	short loc_2FAF
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+0Ch]
		cmp	ecx, 1
		jz	short loc_3010

loc_2FAF:				; CODE XREF: _uspoof_swap_56+81j
					; _uspoof_swap_56+8Dj ...
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+0Fh]
		push	ecx
		mov	edx, [ebp+var_8]
		movzx	eax, byte ptr [edx+0Eh]
		push	eax
		mov	ecx, [ebp+var_8]
		movzx	edx, byte ptr [ecx+0Dh]
		push	edx
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+0Ch]
		push	ecx
		mov	edx, [ebp+var_8]
		movzx	eax, byte ptr [edx+0Bh]
		push	eax
		mov	ecx, [ebp+var_8]
		movzx	edx, byte ptr [ecx+0Ah]
		push	edx
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+9]
		push	ecx
		mov	edx, [ebp+var_8]
		movzx	eax, byte ptr [edx+8]
		push	eax
		push	offset ??_C@_0GH@HLOIAILC@uspoof_swap?$CI?$CJ?3?5data?5format?5?$CF02x?4@ ; "uspoof_swap(): data format	%02x.%02x.%0"...
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_udata_printError_56
		add	esp, 28h

loc_3000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10h
		xor	eax, eax
		jmp	loc_34A9
; ---------------------------------------------------------------------------

loc_3010:				; CODE XREF: _uspoof_swap_56+B1j
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_udata_swapDataHeader_56
		add	esp, 14h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+var_14]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 3845FDEFh
		jnz	short loc_3081
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 80h ; ''
		jnb	short loc_30A2

loc_3081:				; CODE XREF: _uspoof_swap_56+161j
		push	offset ??_C@_0CO@HCMJHHPB@uspoof_swap?$CI?$CJ?3?5Spoof?5Data?5header@ ;	"uspoof_swap():	Spoof Data header is inv"...
		mov	eax, [ebp+arg_0]
		push	eax
		call	_udata_printError_56
		add	esp, 8
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10h
		xor	eax, eax
		jmp	loc_34A9
; ---------------------------------------------------------------------------

loc_30A2:				; CODE XREF: _uspoof_swap_56+183j
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Size], eax
		mov	eax, [ebp+var_14]
		add	eax, [ebp+Size]
		mov	[ebp+var_44], eax
		cmp	[ebp+arg_8], 0
		jge	short loc_30D7
		mov	eax, [ebp+var_44]
		jmp	loc_34A9
; ---------------------------------------------------------------------------

loc_30D7:				; CODE XREF: _uspoof_swap_56+1D1j
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_44]
		jge	short loc_3104
		mov	eax, [ebp+Size]
		push	eax
		push	offset ??_C@_0EJ@JCDCNMPF@uspoof_swap?$CI?$CJ?3?5too?5few?5bytes?5?$CI?$CFd@ ; "uspoof_swap(): too few bytes (%d after "...
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_udata_printError_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_34A9
; ---------------------------------------------------------------------------

loc_3104:				; CODE XREF: _uspoof_swap_56+1E1j
		mov	eax, [ebp+arg_C]
		add	eax, [ebp+var_14]
		mov	[ebp+Dst], eax
		mov	eax, [ebp+Dst]
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+Dst]
		jz	short loc_312D
		mov	eax, [ebp+Size]
		push	eax		; Size
		push	0		; Val
		mov	ecx, [ebp+Dst]
		push	ecx		; Dst
		call	_memset
		add	esp, 0Ch

loc_312D:				; CODE XREF: _uspoof_swap_56+21Dj
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+0Ch]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_68], eax
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+10h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		shl	eax, 2
		mov	[ebp+var_74], eax
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+var_68]
		push	ecx
		mov	edx, [ebp+var_74]
		push	edx
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		call	eax
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+14h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_68], eax
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+18h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		shl	eax, 1
		mov	[ebp+var_74], eax
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+var_68]
		push	ecx
		mov	edx, [ebp+var_74]
		push	edx
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+1Ch]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_68], eax
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+20h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		shl	eax, 1
		mov	[ebp+var_74], eax
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+var_68]
		push	ecx
		mov	edx, [ebp+var_74]
		push	edx
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+24h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_68], eax
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+28h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		shl	eax, 2
		mov	[ebp+var_74], eax
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+var_68]
		push	ecx
		mov	edx, [ebp+var_74]
		push	edx
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+18h]
		call	eax
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+2Ch]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_68], eax
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+30h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_74], eax
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+var_68]
		push	ecx
		mov	edx, [ebp+var_74]
		push	edx
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_utrie2_swap_56
		add	esp, 14h
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+34h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_68], eax
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+38h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_74], eax
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+var_68]
		push	ecx
		mov	edx, [ebp+var_74]
		push	edx
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_utrie2_swap_56
		add	esp, 14h
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+3Ch]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_68], eax
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+40h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		imul	eax, 18h
		mov	[ebp+var_74], eax
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+var_68]
		push	ecx
		mov	edx, [ebp+var_74]
		push	edx
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		call	eax
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_80], eax
		mov	esi, esp
		mov	eax, [ebp+var_80]
		push	eax
		mov	ecx, [ebp+var_5C]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+14h]
		call	eax
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_5C]
		add	eax, 4
		mov	ecx, [ebp+var_2C]
		add	ecx, 4
		cmp	eax, ecx
		jz	short loc_347A
		push	1
		mov	eax, [ebp+var_2C]
		add	eax, 4
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	4		; Size
		mov	ecx, [ebp+var_2C]
		add	ecx, 4
		push	ecx		; Src
		mov	edx, [ebp+var_5C]
		add	edx, 4
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_347A:				; CODE XREF: _uspoof_swap_56+553j
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_5C]
		add	ecx, 8
		push	ecx
		push	78h ; 'x'
		mov	edx, [ebp+var_2C]
		add	edx, 8
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1Ch]
		call	edx
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_44]

loc_34A9:				; CODE XREF: _uspoof_swap_56+3Bj
					; _uspoof_swap_56+69j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_swap_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 34C0h
		public ??_C@_0EJ@JCDCNMPF@uspoof_swap?$CI?$CJ?3?5too?5few?5bytes?5?$CI?$CFd@
; `string'
??_C@_0EJ@JCDCNMPF@uspoof_swap?$CI?$CJ?3?5too?5few?5bytes?5?$CI?$CFd@ db 'uspoof_swap(): too few bytes (%d after ICU Data header) for spoof'
					; DATA XREF: _uspoof_swap_56+1E7o
		db ' data.',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 350Ch
		public ??_C@_0CO@HCMJHHPB@uspoof_swap?$CI?$CJ?3?5Spoof?5Data?5header@
; `string'
??_C@_0CO@HCMJHHPB@uspoof_swap?$CI?$CJ?3?5Spoof?5Data?5header@ db 'uspoof_swap(): Spoof Data header is invalid.',0Ah,0
					; DATA XREF: _uspoof_swap_56:loc_3081o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 353Ch
		public ??_C@_0GH@HLOIAILC@uspoof_swap?$CI?$CJ?3?5data?5format?5?$CF02x?4@
; `string'
??_C@_0GH@HLOIAILC@uspoof_swap?$CI?$CJ?3?5data?5format?5?$CF02x?4@ db 'uspoof_swap(): data format %02x.%02x.%02x.%02x (format version %0'
					; DATA XREF: _uspoof_swap_56+F3o
		db '2x %02x %02x %02x) is not recognized',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; [thunk]:public: virtual void * __thiscall icu_56::UnicodeSet::`vector	deleting destructor'`adjustor{4}' (unsigned int)
		public ??_EUnicodeSet@icu_56@@W3AEPAXI@Z
??_EUnicodeSet@icu_56@@W3AEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeMatcher'}o
		sub	ecx, 4
		jmp	??_EUnicodeSet@icu_56@@UAEPAXI@Z ; icu_56::UnicodeSet::`vector deleting	destructor'(uint)
??_EUnicodeSet@icu_56@@W3AEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::SpoofImpl::getDynamicClassID(void)+33p
					; icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+4Fp ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: __unwindfunclet$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z$1+9p
					; icu_56::SpoofImpl::`scalar deleting destructor'(uint)+39p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn __imp_??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z$0+5p
					; __unwindfunclet$??0SpoofImpl@icu_56@@QAE@XZ$0+5p ...
		extrn _uprv_strdup_56:near
					; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+170p
					; icu_56::SpoofImpl::SpoofImpl(void)+14Dp ...
; struct icu_56::UnicodeFunctor	*__thiscall icu_56::UnicodeSet::freeze(icu_56::UnicodeSet *__hidden this)
		extrn __imp_?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ:near
					; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+155p
					; icu_56::SpoofImpl::SpoofImpl(void)+132p ...
; _DWORD __thiscall icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet *__hidden	this, int, int)
		extrn __imp_??0UnicodeSet@icu_56@@QAE@HH@Z:near
					; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+F9p
					; icu_56::SpoofImpl::SpoofImpl(void)+D6p ...
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn __imp_??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+C7p
					; icu_56::SpoofImpl::SpoofImpl(void)+A4p ...
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		extrn __imp_??0UObject@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+47p
					; icu_56::SpoofImpl::SpoofImpl(void)+47p ...
		extrn ___security_cookie:near
					; DATA XREF: icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)+2Er
					; icu_56::SpoofImpl::SpoofImpl(void)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z+19j
					; __ehhandler$??0SpoofImpl@icu_56@@QAE@XZ+19j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z+Fp
					; __ehhandler$??0SpoofImpl@icu_56@@QAE@XZ+Fp ...
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::SpoofImpl `RTTI Type	Descriptor'o
					; .data:icu_56::UObject	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::SpoofImpl::`scalar deleting	destructor'(unsigned int)
		extrn ??_GSpoofImpl@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::SpoofImpl::`vector deleting	destructor'(unsigned int)
		extrn ??_ESpoofImpl@icu_56@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::SpoofImpl::`vftable'o
; public: virtual void * __thiscall icu_56::UnicodeSet::`scalar	deleting destructor'(unsigned int)
		extrn ??_GUnicodeSet@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::UnicodeSet::`vector	deleting destructor'(unsigned int)
		extrn ??_EUnicodeSet@icu_56@@UAEPAXI@Z:near ; weak
					; CODE XREF: [thunk]:icu_56::UnicodeSet::`vector deleting destructor'`adjustor{4}' (uint)+3j
					; DATA XREF: .rdata:const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeFunctor'}o
; public: virtual void * __thiscall icu_56::UnicodeSet::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeSet@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000490o
; public: virtual class	icu_56::UnicodeFunctor * __thiscall icu_56::UnicodeSet::clone(void)const
		extrn ?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ:near
					; DATA XREF: .rdata:00000494o
; public: virtual class	icu_56::UnicodeMatcher * __thiscall icu_56::UnicodeFilter::toMatcher(void)const
		extrn ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ:near
					; DATA XREF: .rdata:00000498o
; public: virtual class	icu_56::UnicodeReplacer	* __thiscall icu_56::UnicodeFunctor::toReplacer(void)const
		extrn ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ:near
					; DATA XREF: .rdata:0000049Co
; public: virtual void __thiscall icu_56::UnicodeFilter::setData(class icu_56::TransliterationRuleData const *)
		extrn ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z:near
					; DATA XREF: .rdata:000004A0o
; public: virtual signed char __thiscall icu_56::UnicodeSet::contains(int)const
		extrn ?contains@UnicodeSet@icu_56@@UBECH@Z:near
					; DATA XREF: .rdata:000004A4o
; public: virtual signed char __thiscall icu_56::UnicodeSet::operator==(class icu_56::UnicodeSet const &)const
		extrn ??8UnicodeSet@icu_56@@UBECABV01@@Z:near ;	DATA XREF: .rdata:000004A8o
; public: virtual int __thiscall icu_56::UnicodeSet::hashCode(void)const
		extrn ?hashCode@UnicodeSet@icu_56@@UBEHXZ:near ; DATA XREF: .rdata:000004ACo
; public: virtual int __thiscall icu_56::UnicodeSet::size(void)const
		extrn ?size@UnicodeSet@icu_56@@UBEHXZ:near ; DATA XREF:	.rdata:000004B0o
; public: virtual signed char __thiscall icu_56::UnicodeSet::isEmpty(void)const
		extrn ?isEmpty@UnicodeSet@icu_56@@UBECXZ:near ;	DATA XREF: .rdata:000004B4o
; public: virtual signed char __thiscall icu_56::UnicodeSet::contains(int, int)const
		extrn ?contains@UnicodeSet@icu_56@@UBECHH@Z:near
					; DATA XREF: .rdata:000004B8o
; public: virtual signed char __thiscall icu_56::UnicodeSet::containsAll(class icu_56::UnicodeSet const	&)const
		extrn ?containsAll@UnicodeSet@icu_56@@UBECABV12@@Z:near
					; DATA XREF: .rdata:000004BCo
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::add(int, int)
		extrn ?add@UnicodeSet@icu_56@@UAEAAV12@HH@Z:near
					; DATA XREF: .rdata:000004C0o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::addAll(class icu_56::UnicodeSet const &)
		extrn ?addAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z:near
					; DATA XREF: .rdata:000004C4o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::retainAll(class icu_56::UnicodeSet const &)
		extrn ?retainAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z:near
					; DATA XREF: .rdata:000004C8o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::complementAll(class	icu_56::UnicodeSet const &)
		extrn ?complementAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z:near
					; DATA XREF: .rdata:000004CCo
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::removeAll(class icu_56::UnicodeSet const &)
		extrn ?removeAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z:near
					; DATA XREF: .rdata:000004D0o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::retain(int,	int)
		extrn ?retain@UnicodeSet@icu_56@@UAEAAV12@HH@Z:near
					; DATA XREF: .rdata:000004D4o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::remove(int,	int)
		extrn ?remove@UnicodeSet@icu_56@@UAEAAV12@HH@Z:near
					; DATA XREF: .rdata:000004D8o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::complement(int, int)
		extrn ?complement@UnicodeSet@icu_56@@UAEAAV12@HH@Z:near
					; DATA XREF: .rdata:000004DCo
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::complement(void)
		extrn ?complement@UnicodeSet@icu_56@@UAEAAV12@XZ:near
					; DATA XREF: .rdata:000004E0o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::clear(void)
		extrn ?clear@UnicodeSet@icu_56@@UAEAAV12@XZ:near
					; DATA XREF: .rdata:000004E4o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::removeAllStrings(void)
		extrn ?removeAllStrings@UnicodeSet@icu_56@@UAEAAV12@XZ:near
					; DATA XREF: .rdata:000004E8o
; public: virtual int __thiscall icu_56::UnicodeSet::getRangeCount(void)const
		extrn ?getRangeCount@UnicodeSet@icu_56@@UBEHXZ:near
					; DATA XREF: .rdata:000004ECo
; public: virtual int __thiscall icu_56::UnicodeSet::getRangeStart(int)const
		extrn ?getRangeStart@UnicodeSet@icu_56@@UBEHH@Z:near
					; DATA XREF: .rdata:000004F0o
; public: virtual int __thiscall icu_56::UnicodeSet::getRangeEnd(int)const
		extrn ?getRangeEnd@UnicodeSet@icu_56@@UBEHH@Z:near
					; DATA XREF: .rdata:000004F4o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::compact(void)
		extrn ?compact@UnicodeSet@icu_56@@UAEAAV12@XZ:near
					; DATA XREF: .rdata:000004F8o
; public: virtual enum	icu_56::UMatchDegree __thiscall	icu_56::UnicodeSet::matches(class icu_56::Replaceable const &, int &, int, signed char)
		extrn ?matches@UnicodeSet@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z:near
					; DATA XREF: .rdata:00000478o
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeSet::toPattern(class icu_56::UnicodeString &,	signed char)const
		extrn ?toPattern@UnicodeSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z:near
					; DATA XREF: .rdata:0000047Co
; private: virtual signed char __thiscall icu_56::UnicodeSet::matchesIndexValue(unsigned char)const
		extrn ?matchesIndexValue@UnicodeSet@icu_56@@EBECE@Z:near
					; DATA XREF: .rdata:00000480o
; public: virtual void __thiscall icu_56::UnicodeSet::addMatchSetTo(class icu_56::UnicodeSet &)const
		extrn ?addMatchSetTo@UnicodeSet@icu_56@@UBEXAAV12@@Z:near
					; DATA XREF: .rdata:00000484o
; _DWORD __thiscall icu_56::UnicodeSet::~UnicodeSet(icu_56::UnicodeSet *__hidden this)
		extrn __imp_??1UnicodeSet@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeSet::`scalar deleting destructor'(uint)+28p
					; icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+26Ep	...
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::SpoofImpl::~SpoofImpl(void)+C7p
					; icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+15Ap	...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, const wchar_t *,	int)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z:near
					; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+33Dp
					; DATA XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+33Dr
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near
					; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+2C7p
					; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+304p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, wchar_t)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z:near
					; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+20Fp
					; DATA XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+20Fr
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+D0p
					; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)+1A9p
					; DATA XREF: ...
; struct icu_56::ScriptSet *__thiscall icu_56::ScriptSet::intersect(icu_56::ScriptSet *__hidden	this, const struct icu_56::ScriptSet *)
		extrn ?intersect@ScriptSet@icu_56@@QAEAAV12@ABV12@@Z:near
					; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+139p
; struct icu_56::ScriptSet *__thiscall __high icu_56::ScriptSet::intersect(enum	UScriptCode, enum UErrorCode *)
		extrn ?intersect@ScriptSet@icu_56@@QAEAAV12@W4UScriptCode@@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+117p
		extrn _uscript_getScript_56:near
					; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+D6p
		extrn _utrie2_get32_56:near
					; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+BDp
; int __thiscall icu_56::UnicodeString::char32At(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?char32At@UnicodeString@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+90p
					; DATA XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+90r
; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		extrn __imp_?length@UnicodeString@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+64p
					; DATA XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+64r
; struct icu_56::ScriptSet *__thiscall icu_56::ScriptSet::setAll(icu_56::ScriptSet *__hidden this)
		extrn ?setAll@ScriptSet@icu_56@@QAEAAV12@XZ:near
					; CODE XREF: icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode &)+5Ap
; struct icu_56::UnicodeFunctor	*__thiscall icu_56::UnicodeSet::clone(icu_56::UnicodeSet *__hidden this)
		extrn __imp_?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ:near
					; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+3F4p
					; DATA XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+3F4r
; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::addAll(icu_56::UnicodeSet *__hidden	this, const struct icu_56::UnicodeSet *)
		extrn __imp_?addAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z:near
					; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+35Dp
					; icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+396p
					; DATA XREF: ...
; struct icu_56::UnicodeSet *__thiscall	__high icu_56::UnicodeSet::applyIntPropertyValue(enum UProperty, int, enum UErrorCode *)
		extrn __imp_?applyIntPropertyValue@UnicodeSet@icu_56@@QAEAAV12@W4UProperty@@HAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+344p
					; icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+37Dp	...
		extrn _uprv_strndup_56:near
					; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+11Fp
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near
					; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+93p
					; DATA XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+93r
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+73p
; _DWORD __thiscall icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet *__hidden	this)
		extrn __imp_??0UnicodeSet@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+47p
					; icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+320p	...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)+536p
					; icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet *,UErrorCode &)+14Ap ...
		extrn _uscript_getCode_56:near
					; CODE XREF: icu_56::SpoofImpl::addScriptChars(char const *,icu_56::UnicodeSet *,UErrorCode &)+56p
; _DWORD __thiscall icu_56::IdentifierInfo::IdentifierInfo(icu_56::IdentifierInfo *__hidden this, enum UErrorCode *)
		extrn ??0IdentifierInfo@icu_56@@QAE@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+E3p
; _DWORD __thiscall icu_56::Mutex::~Mutex(icu_56::Mutex	*__hidden this)
		extrn __imp_??1Mutex@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+98p
					; icu_56::SpoofImpl::releaseIdentifierInfo(icu_56::IdentifierInfo *)+65p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::Mutex::Mutex(icu_56::Mutex *__hidden this, struct UMutex *)
		extrn __imp_??0Mutex@icu_56@@QAE@PAUUMutex@@@Z:near
					; CODE XREF: icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)+73p
					; icu_56::SpoofImpl::releaseIdentifierInfo(icu_56::IdentifierInfo *)+3Ap
					; DATA XREF: ...
		extrn _udata_openChoice_56:near
					; CODE XREF: icu_56::SpoofData::getDefault(UErrorCode &)+54p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: icu_56::spoofDataIsAcceptable(void	*,char const *,char const *,UDataInfo const *)+A9p
					; _uspoof_swap_56+576p
		extrn _uprv_checkValidMemory:near
					; CODE XREF: icu_56::spoofDataIsAcceptable(void	*,char const *,char const *,UDataInfo const *)+94p
					; _uspoof_swap_56+55Ep
		extrn _udata_getMemory_56:near
					; CODE XREF: icu_56::SpoofData::SpoofData(UDataMemory *,UErrorCode &)+4Fp
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: icu_56::SpoofData::SpoofData(UErrorCode &)+BAp
					; icu_56::SpoofData::reserveSpace(int,UErrorCode &)+DCp ...
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::SpoofData::SpoofData(UErrorCode &)+85p
		extrn _utrie2_openFromSerialized_56:near
					; CODE XREF: icu_56::SpoofData::initPtrs(UErrorCode &)+110p
					; icu_56::SpoofData::initPtrs(UErrorCode &)+151p
		extrn _udata_close_56:near
					; CODE XREF: icu_56::SpoofData::~SpoofData(void)+87p
		extrn _utrie2_close_56:near
					; CODE XREF: icu_56::SpoofData::~SpoofData(void)+2Ap
					; icu_56::SpoofData::~SpoofData(void)+43p
; LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend)
		extrn __imp__InterlockedDecrement@4:near
					; CODE XREF: icu_56::umtx_atomic_dec(long volatile *)+24p
					; DATA XREF: icu_56::umtx_atomic_dec(long volatile *)+24r
; LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend)
		extrn __imp__InterlockedIncrement@4:near
					; CODE XREF: icu_56::umtx_atomic_inc(long volatile *)+24p
					; DATA XREF: icu_56::umtx_atomic_inc(long volatile *)+24r
		extrn _uprv_realloc_56:near
					; CODE XREF: icu_56::SpoofData::reserveSpace(int,UErrorCode &)+B2p
		extrn _utrie2_swap_56:near ; CODE XREF:	_uspoof_swap_56+439p
					; _uspoof_swap_56+497p
		extrn _udata_swapDataHeader_56:near ; CODE XREF: _uspoof_swap_56+128p
		extrn _udata_printError_56:near	; CODE XREF: _uspoof_swap_56+FCp
					; _uspoof_swap_56+18Ep	...


		end
