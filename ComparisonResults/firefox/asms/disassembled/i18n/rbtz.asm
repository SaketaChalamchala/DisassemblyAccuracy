;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	6AE001992C883FB20E432AEB21EB742F
; Input	CRC32 :	AC875AE8

; File Name   :	D:\compspace\objfiles\firefox\i18n\rbtz.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset dword_100
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1BE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; char `public:	static void * __cdecl icu_56::RuleBasedTimeZone::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@RuleBasedTimeZone@icu_56@@SAPAXXZ@4DA dd ?
					; DATA XREF: icu_56::RuleBasedTimeZone::getStaticClassID(void)+1Eo
_gLock		dd ?			; DATA XREF: icu_56::RuleBasedTimeZone::completeConst(UErrorCode &):loc_161Eo
					; icu_56::RuleBasedTimeZone::completeConst(UErrorCode &):loc_1648o
dword_100	dd 7 dup(?)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 154h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 158h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 190h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::TimeZone::operator!=(class icu_56::TimeZone const &)const
		public ??9TimeZone@icu_56@@QBECABV01@@Z
??9TimeZone@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]

loc_1BE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9TimeZone@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::TimeZone::getID(icu_56::TimeZone *this, struct icu_56::UnicodeString	*)
		public ?getID@TimeZone@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?getID@TimeZone@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]

loc_1FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getID@TimeZone@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 244h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::TimeZone::setID(icu_56::TimeZone *this, const	struct icu_56::UnicodeString *)
		public ?setID@TimeZone@icu_56@@QAEXABVUnicodeString@2@@Z
?setID@TimeZone@icu_56@@QAEXABVUnicodeString@2@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 4
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setID@TimeZone@icu_56@@QAEXABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 298h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::BasicTimeZone &	__thiscall icu_56::BasicTimeZone::operator=(class icu_56::BasicTimeZone	const &)
		public ??4BasicTimeZone@icu_56@@QAEAAV01@ABV01@@Z
??4BasicTimeZone@icu_56@@QAEAAV01@ABV01@@Z proc	near
					; CODE XREF: icu_56::RuleBasedTimeZone::operator=(icu_56::RuleBasedTimeZone const &)+4Bp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4TimeZone@icu_56@@IAEAAV01@ABV01@@Z ;	icu_56::TimeZone::operator=(icu_56::TimeZone const &)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4BasicTimeZone@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::RuleBasedTimeZone::`scalar deleting	destructor'(unsigned int)
		public ??_GRuleBasedTimeZone@icu_56@@UAEPAXI@Z
??_GRuleBasedTimeZone@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1RuleBasedTimeZone@icu_56@@UAE@XZ ; icu_56::RuleBasedTimeZone::~RuleBasedTimeZone(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_329
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_329:				; CODE XREF: icu_56::RuleBasedTimeZone::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRuleBasedTimeZone@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 344h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::RuleBasedTimeZone::`vector deleting	destructor'(unsigned int)
		public ??_ERuleBasedTimeZone@icu_56@@UAEPAXI@Z
??_ERuleBasedTimeZone@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::RuleBasedTimeZone::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_3AF
		push	offset ??1RuleBasedTimeZone@icu_56@@UAE@XZ ; icu_56::RuleBasedTimeZone::~RuleBasedTimeZone(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	58h ; 'X'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3A7
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3A7:				; CODE XREF: icu_56::RuleBasedTimeZone::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_3D8
; ---------------------------------------------------------------------------

loc_3AF:				; CODE XREF: icu_56::RuleBasedTimeZone::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1RuleBasedTimeZone@icu_56@@UAE@XZ ; icu_56::RuleBasedTimeZone::~RuleBasedTimeZone(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3D5
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3D5:				; CODE XREF: icu_56::RuleBasedTimeZone::`vector	deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_3D8:				; CODE XREF: icu_56::RuleBasedTimeZone::`vector	deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ERuleBasedTimeZone@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Calendar::getTime(icu_56::Calendar *this, enum UErrorCode *)
		public ?getTime@Calendar@icu_56@@QBENAAW4UErrorCode@@@Z
?getTime@Calendar@icu_56@@QBENAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx

loc_3FD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?getTimeInMillis@Calendar@icu_56@@IBENAAW4UErrorCode@@@Z ; icu_56::Calendar::getTimeInMillis(UErrorCode	&)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getTime@Calendar@icu_56@@QBENAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 438h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::Calendar::setTime(icu_56::Calendar *this, double, enum UErrorCode *)
		public ?setTime@Calendar@icu_56@@QAEXNAAW4UErrorCode@@@Z
?setTime@Calendar@icu_56@@QAEXNAAW4UErrorCode@@@Z proc near

var_E4		= qword	ptr -0E4h
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0E4h+var_E4] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?setTimeInMillis@Calendar@icu_56@@IAEXNAAW4UErrorCode@@@Z ; icu_56::Calendar::setTimeInMillis(double,UErrorCode	&)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setTime@Calendar@icu_56@@QAEXNAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 488h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Calendar::operator!=(class icu_56::Calendar const &)const
		public ??9Calendar@icu_56@@QBECABV01@@Z
??9Calendar@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Calendar@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: int __thiscall icu_56::Calendar::internalGet(enum	icu_56::Calendar::EDateFields)const
		public ?internalGet@Calendar@icu_56@@IBEHW4EDateFields@12@@Z
?internalGet@Calendar@icu_56@@IBEHW4EDateFields@12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx+eax*4+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?internalGet@Calendar@icu_56@@IBEHW4EDateFields@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 51Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: int __thiscall icu_56::Calendar::internalGet(enum	UCalendarDateFields, int)const
		public ?internalGet@Calendar@icu_56@@IBEHW4UCalendarDateFields@@H@Z
?internalGet@Calendar@icu_56@@IBEHW4UCalendarDateFields@@H@Z proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx+eax*4+7Ch], 0
		jle	short loc_55E
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+edx*4+8]
		mov	[ebp+var_D0], ecx
		jmp	short loc_567
; ---------------------------------------------------------------------------

loc_55E:				; CODE XREF: icu_56::Calendar::internalGet(UCalendarDateFields,int)+2Ej
		mov	edx, [ebp+arg_4]
		mov	[ebp+var_D0], edx

loc_567:				; CODE XREF: icu_56::Calendar::internalGet(UCalendarDateFields,int)+40j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?internalGet@Calendar@icu_56@@IBEHW4UCalendarDateFields@@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 578h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: int __thiscall icu_56::Calendar::internalGet(enum	UCalendarDateFields)const
		public ?internalGet@Calendar@icu_56@@IBEHW4UCalendarDateFields@@@Z
?internalGet@Calendar@icu_56@@IBEHW4UCalendarDateFields@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx+eax*4+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?internalGet@Calendar@icu_56@@IBEHW4UCalendarDateFields@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Calendar::internalGetTime(icu_56::Calendar *__hidden this)
		public ?internalGetTime@Calendar@icu_56@@IBENXZ
?internalGetTime@Calendar@icu_56@@IBENXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+0E0h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?internalGetTime@Calendar@icu_56@@IBENXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::Calendar::internalSetTime(icu_56::Calendar *this, double)
		public ?internalSetTime@Calendar@icu_56@@IAEXN@Z
?internalSetTime@Calendar@icu_56@@IAEXN@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	[ebp+arg_0]
		fstp	qword ptr [eax+0E0h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?internalSetTime@Calendar@icu_56@@IAEXN@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 61Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Calendar::getGregorianYear(icu_56::Calendar *__hidden this)
		public ?getGregorianYear@Calendar@icu_56@@IBEHXZ
?getGregorianYear@Calendar@icu_56@@IBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+110h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getGregorianYear@Calendar@icu_56@@IBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 650h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Calendar::getGregorianMonth(icu_56::Calendar *__hidden	this)
		public ?getGregorianMonth@Calendar@icu_56@@IBEHXZ
?getGregorianMonth@Calendar@icu_56@@IBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+114h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getGregorianMonth@Calendar@icu_56@@IBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 684h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Calendar::getGregorianDayOfYear(icu_56::Calendar *__hidden this)
		public ?getGregorianDayOfYear@Calendar@icu_56@@IBEHXZ
?getGregorianDayOfYear@Calendar@icu_56@@IBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+118h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getGregorianDayOfYear@Calendar@icu_56@@IBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Calendar::getGregorianDayOfMonth(icu_56::Calendar *__hidden this)
		public ?getGregorianDayOfMonth@Calendar@icu_56@@IBEHXZ
?getGregorianDayOfMonth@Calendar@icu_56@@IBEHXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+11Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getGregorianDayOfMonth@Calendar@icu_56@@IBEHXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::Calendar *__cdecl icu_56::Calendar::createInstance(struct icu_56::TimeZone *, enum UErrorCode *)
		public ?createInstance@Calendar@icu_56@@SAPAV12@PAVTimeZone@2@AAW4UErrorCode@@@Z
?createInstance@Calendar@icu_56@@SAPAV12@PAVTimeZone@2@AAW4UErrorCode@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	esi, esp
		call	dword ptr ds:__imp_?getDefault@Locale@icu_56@@SAABV12@XZ ; icu_56::Locale::getDefault(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::TimeZone *
		call	?createInstance@Calendar@icu_56@@SAPAV12@PAVTimeZone@2@ABVLocale@2@AAW4UErrorCode@@@Z ;	icu_56::Calendar::createInstance(icu_56::TimeZone *,icu_56::Locale const &,UErrorCode &)
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?createInstance@Calendar@icu_56@@SAPAV12@PAVTimeZone@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 740h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::Calendar::roll(enum  UCalendarDateFields, signed char, enum  UErrorCode &)
		public ?roll@Calendar@icu_56@@QAEXW4UCalendarDateFields@@CAAW4UErrorCode@@@Z
?roll@Calendar@icu_56@@QAEXW4UCalendarDateFields@@CAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::Calendar::roll(icu_56::Calendar::EDateFields,signed char,UErrorCode &)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		movsx	ecx, [ebp+arg_4]
		neg	ecx
		sbb	ecx, ecx
		and	ecx, 2
		add	ecx, 0FFFFFFFFh
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?roll@Calendar@icu_56@@QAEXW4UCalendarDateFields@@CAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::Calendar::roll(enum  icu_56::Calendar::EDateFields, signed char, enum	 UErrorCode &)
		public ?roll@Calendar@icu_56@@QAEXW4EDateFields@12@CAAW4UErrorCode@@@Z
?roll@Calendar@icu_56@@QAEXW4EDateFields@12@CAAW4UErrorCode@@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax
		movzx	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?roll@Calendar@icu_56@@QAEXW4UCalendarDateFields@@CAAW4UErrorCode@@@Z ;	icu_56::Calendar::roll(UCalendarDateFields,signed char,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?roll@Calendar@icu_56@@QAEXW4EDateFields@12@CAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall icu_56::Calendar::internalSet(enum	 UCalendarDateFields, int)
		public ?internalSet@Calendar@icu_56@@IAEXW4UCalendarDateFields@@H@Z
?internalSet@Calendar@icu_56@@IAEXW4UCalendarDateFields@@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp

loc_7FB:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+arg_4]
		mov	[ecx+eax*4+8], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	dword ptr [ecx+eax*4+7Ch], 1
		mov	eax, [ebp+var_8]
		add	eax, [ebp+arg_0]
		mov	byte ptr [eax+64h], 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?internalSet@Calendar@icu_56@@IAEXW4UCalendarDateFields@@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 84Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Calendar::weekNumber(icu_56::Calendar *this, int, int)
		public ?weekNumber@Calendar@icu_56@@IAEHHH@Z
?weekNumber@Calendar@icu_56@@IAEHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?weekNumber@Calendar@icu_56@@IAEHHHH@Z ; icu_56::Calendar::weekNumber(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?weekNumber@Calendar@icu_56@@IAEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 89Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::RuleBasedTimeZone::getStaticClassID()
		public ?getStaticClassID@RuleBasedTimeZone@icu_56@@SAPAXXZ
?getStaticClassID@RuleBasedTimeZone@icu_56@@SAPAXXZ proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@RuleBasedTimeZone@icu_56@@SAPAXXZ@4DA	; char `icu_56::RuleBasedTimeZone::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@RuleBasedTimeZone@icu_56@@SAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::RuleBasedTimeZone::getDynamicClassID(icu_56::RuleBasedTimeZone *__hidden this)
		public ?getDynamicClassID@RuleBasedTimeZone@icu_56@@UBEPAXXZ
?getDynamicClassID@RuleBasedTimeZone@icu_56@@UBEPAXXZ proc near
					; DATA XREF: .rdata:0000098Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@RuleBasedTimeZone@icu_56@@SAPAXXZ ; icu_56::RuleBasedTimeZone::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@RuleBasedTimeZone@icu_56@@UBEPAXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 904h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone *this, const	struct icu_56::UnicodeString *,	struct icu_56::InitialTimeZoneRule *)
		public ??0RuleBasedTimeZone@icu_56@@QAE@ABVUnicodeString@1@PAVInitialTimeZoneRule@1@@Z
??0RuleBasedTimeZone@icu_56@@QAE@ABVUnicodeString@1@PAVInitialTimeZoneRule@1@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	??0BasicTimeZone@icu_56@@IAE@ABVUnicodeString@1@@Z ; icu_56::BasicTimeZone::BasicTimeZone(icu_56::UnicodeString	const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7RuleBasedTimeZone@icu_56@@6B@ ; const icu_56::RuleBasedTimeZone::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+44h], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+54h], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0RuleBasedTimeZone@icu_56@@QAE@ABVUnicodeString@1@PAVInitialTimeZoneRule@1@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 984h
		dd offset ??_R4RuleBasedTimeZone@icu_56@@6B@ ; const icu_56::RuleBasedTimeZone::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7RuleBasedTimeZone@icu_56@@6B@
; const	icu_56::RuleBasedTimeZone::`vftable'
??_7RuleBasedTimeZone@icu_56@@6B@ dd offset ??_ERuleBasedTimeZone@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::UnicodeString	const &,icu_56::InitialTimeZoneRule *)+32o
					; icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone const &)+58o ...
					; icu_56::RuleBasedTimeZone::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@RuleBasedTimeZone@icu_56@@UBEPAXXZ	; icu_56::RuleBasedTimeZone::getDynamicClassID(void)
		dd offset ??8RuleBasedTimeZone@icu_56@@UBECABVTimeZone@1@@Z ; icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)
		dd offset ?getOffset@RuleBasedTimeZone@icu_56@@UBEXNCAAH0AAW4UErrorCode@@@Z ; icu_56::RuleBasedTimeZone::getOffset(double,signed char,int &,int	&,UErrorCode &)
		dd offset ?getOffset@RuleBasedTimeZone@icu_56@@UBEHEHHHEHHAAW4UErrorCode@@@Z ; icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,int,UErrorCode &)
		dd offset ?getOffset@RuleBasedTimeZone@icu_56@@UBEHEHHHEHAAW4UErrorCode@@@Z ; icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,UErrorCode &)
		dd offset ?setRawOffset@RuleBasedTimeZone@icu_56@@UAEXH@Z ; icu_56::RuleBasedTimeZone::setRawOffset(int)
		dd offset ?getRawOffset@RuleBasedTimeZone@icu_56@@UBEHXZ ; icu_56::RuleBasedTimeZone::getRawOffset(void)
		dd offset ?useDaylightTime@RuleBasedTimeZone@icu_56@@UBECXZ ; icu_56::RuleBasedTimeZone::useDaylightTime(void)
		dd offset ?inDaylightTime@RuleBasedTimeZone@icu_56@@UBECNAAW4UErrorCode@@@Z ; icu_56::RuleBasedTimeZone::inDaylightTime(double,UErrorCode &)
		dd offset ?hasSameRules@RuleBasedTimeZone@icu_56@@UBECABVTimeZone@2@@Z ; icu_56::RuleBasedTimeZone::hasSameRules(icu_56::TimeZone const	&)
		dd offset ?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ ; icu_56::RuleBasedTimeZone::clone(void)
		dd offset ?getDSTSavings@TimeZone@icu_56@@UBEHXZ ; icu_56::TimeZone::getDSTSavings(void)
		dd offset ?getNextTransition@RuleBasedTimeZone@icu_56@@UBECNCAAVTimeZoneTransition@2@@Z	; icu_56::RuleBasedTimeZone::getNextTransition(double,signed char,icu_56::TimeZoneTransition &)
		dd offset ?getPreviousTransition@RuleBasedTimeZone@icu_56@@UBECNCAAVTimeZoneTransition@2@@Z ; icu_56::RuleBasedTimeZone::getPreviousTransition(double,signed char,icu_56::TimeZoneTransition &)
		dd offset ?hasEquivalentTransitions@BasicTimeZone@icu_56@@UBECABV12@NNCAAW4UErrorCode@@@Z ; icu_56::BasicTimeZone::hasEquivalentTransitions(icu_56::BasicTimeZone const	&,double,double,signed char,UErrorCode &)
		dd offset ?countTransitionRules@RuleBasedTimeZone@icu_56@@UBEHAAW4UErrorCode@@@Z ; icu_56::RuleBasedTimeZone::countTransitionRules(UErrorCode &)
		dd offset ?getTimeZoneRules@RuleBasedTimeZone@icu_56@@UBEXAAPBVInitialTimeZoneRule@2@QAPBVTimeZoneRule@2@AAHAAW4UErrorCode@@@Z ; icu_56::RuleBasedTimeZone::getTimeZoneRules(icu_56::InitialTimeZoneRule const * &,icu_56::TimeZoneRule	const *	* const,int &,UErrorCode &)
		dd offset ?getSimpleRulesNear@BasicTimeZone@icu_56@@UBEXNAAPAVInitialTimeZoneRule@2@AAPAVAnnualTimeZoneRule@2@1AAW4UErrorCode@@@Z ; icu_56::BasicTimeZone::getSimpleRulesNear(double,icu_56::InitialTimeZoneRule * &,icu_56::AnnualTimeZoneRule	* &,icu_56::AnnualTimeZoneRule * &,UErrorCode &)
		dd offset ?getOffsetFromLocal@RuleBasedTimeZone@icu_56@@UBEXNHHAAH0AAW4UErrorCode@@@Z ;	icu_56::RuleBasedTimeZone::getOffsetFromLocal(double,int,int,int &,int &,UErrorCode &)
		dd offset ??9RuleBasedTimeZone@icu_56@@UBECABVTimeZone@1@@Z ; icu_56::RuleBasedTimeZone::operator!=(icu_56::TimeZone const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9DCh
		public ??_R4RuleBasedTimeZone@icu_56@@6B@
; const	icu_56::RuleBasedTimeZone::`RTTI Complete Object Locator'
??_R4RuleBasedTimeZone@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:00000984o
		dd offset ??_R0?AVRuleBasedTimeZone@icu_56@@@8 ; icu_56::RuleBasedTimeZone `RTTI Type Descriptor'
		dd offset ??_R3RuleBasedTimeZone@icu_56@@8 ; icu_56::RuleBasedTimeZone::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 9F0h
		public ??_R0?AVRuleBasedTimeZone@icu_56@@@8
; class	icu_56::RuleBasedTimeZone `RTTI	Type Descriptor'
??_R0?AVRuleBasedTimeZone@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000009E8o
					; .rdata$r:icu_56::RuleBasedTimeZone::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avrulebasedt	db '.?AVRuleBasedTimeZone@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A18h
		public ??_R3RuleBasedTimeZone@icu_56@@8
; icu_56::RuleBasedTimeZone::`RTTI Class Hierarchy Descriptor'
??_R3RuleBasedTimeZone@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:000009ECo
					; .rdata$r:00000A58o
		dd 5
		dd offset ??_R2RuleBasedTimeZone@icu_56@@8 ; icu_56::RuleBasedTimeZone::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A28h
		public ??_R2RuleBasedTimeZone@icu_56@@8
; icu_56::RuleBasedTimeZone::`RTTI Base	Class Array'
??_R2RuleBasedTimeZone@icu_56@@8 dd offset ??_R1A@?0A@EA@RuleBasedTimeZone@icu_56@@8
					; DATA XREF: .rdata$r:00000A24o
					; icu_56::RuleBasedTimeZone::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@BasicTimeZone@icu_56@@8	; icu_56::BasicTimeZone::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@TimeZone@icu_56@@8 ; icu_56::TimeZone::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A40h
		public ??_R1A@?0A@EA@RuleBasedTimeZone@icu_56@@8
; icu_56::RuleBasedTimeZone::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@RuleBasedTimeZone@icu_56@@8 dd offset ??_R0?AVRuleBasedTimeZone@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::RuleBasedTimeZone::`RTTI Base Class Array'o
					; icu_56::RuleBasedTimeZone `RTTI Type Descriptor'
		dd 4, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3RuleBasedTimeZone@icu_56@@8 ; icu_56::RuleBasedTimeZone::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A5Ch
		public ??_R1A@?0A@EA@BasicTimeZone@icu_56@@8
; icu_56::BasicTimeZone::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@BasicTimeZone@icu_56@@8 dd offset	??_R0?AVBasicTimeZone@icu_56@@@8
					; DATA XREF: .rdata$r:00000A2Co
					; .rdata$r:icu_56::BasicTimeZone::`RTTI	Base Class Array'o
					; icu_56::BasicTimeZone	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3BasicTimeZone@icu_56@@8 ; icu_56::BasicTimeZone::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0A78h
		public ??_R0?AVBasicTimeZone@icu_56@@@8
; class	icu_56::BasicTimeZone `RTTI Type Descriptor'
??_R0?AVBasicTimeZone@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::BasicTimeZone::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avbasictimez	db '.?AVBasicTimeZone@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A9Ch
		public ??_R3BasicTimeZone@icu_56@@8
; icu_56::BasicTimeZone::`RTTI Class Hierarchy Descriptor'
??_R3BasicTimeZone@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00000A74o
		dd 4
		dd offset ??_R2BasicTimeZone@icu_56@@8 ; icu_56::BasicTimeZone::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AACh
		public ??_R2BasicTimeZone@icu_56@@8
; icu_56::BasicTimeZone::`RTTI Base Class Array'
??_R2BasicTimeZone@icu_56@@8 dd	offset ??_R1A@?0A@EA@BasicTimeZone@icu_56@@8
					; DATA XREF: .rdata$r:00000AA8o
					; icu_56::BasicTimeZone::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@TimeZone@icu_56@@8 ; icu_56::TimeZone::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AC0h
		public ??_R1A@?0A@EA@TimeZone@icu_56@@8
; icu_56::TimeZone::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@TimeZone@icu_56@@8 dd offset ??_R0?AVTimeZone@icu_56@@@8
					; DATA XREF: .rdata$r:00000A30o
					; .rdata$r:00000AB0o ...
					; icu_56::TimeZone `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3TimeZone@icu_56@@8 ; icu_56::TimeZone::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0ADCh
		public ??_R0?AVTimeZone@icu_56@@@8
; class	icu_56::TimeZone `RTTI Type Descriptor'
??_R0?AVTimeZone@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::TimeZone::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avtimezone@i	db '.?AVTimeZone@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AFCh
		public ??_R3TimeZone@icu_56@@8
; icu_56::TimeZone::`RTTI Class	Hierarchy Descriptor'
??_R3TimeZone@icu_56@@8	dd 2 dup(0)	; DATA XREF: .rdata$r:00000AD8o
		dd 3
		dd offset ??_R2TimeZone@icu_56@@8 ; icu_56::TimeZone::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B0Ch
		public ??_R2TimeZone@icu_56@@8
; icu_56::TimeZone::`RTTI Base Class Array'
??_R2TimeZone@icu_56@@8	dd offset ??_R1A@?0A@EA@TimeZone@icu_56@@8
					; DATA XREF: .rdata$r:00000B08o
					; icu_56::TimeZone::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B1Ch
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:00000A34o
					; .rdata$r:00000AB4o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0B38h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B58h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000B34o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B68h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000B64o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B74h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000A38o
					; .rdata$r:00000AB8o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0B90h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BB0h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000B8Co
					; .rdata$r:00000BE0o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BC0h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00000BBCo
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BC8h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone *this, const	struct icu_56::RuleBasedTimeZone *)
		public ??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z
??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::clone(void)+76p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::BasicTimeZone *
		mov	ecx, [ebp+var_14] ; this
		call	??0BasicTimeZone@icu_56@@IAE@ABV01@@Z ;	icu_56::BasicTimeZone::BasicTimeZone(icu_56::BasicTimeZone const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedTimeZone@icu_56@@6B@ ; const icu_56::RuleBasedTimeZone::`vftable'
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+44h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14]
		mov	[ecx+44h], eax
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+54h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+48h]
		push	ecx		; struct icu_56::UVector *
		mov	ecx, [ebp+var_14] ; this
		call	?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z ;	icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)
		mov	edx, [ebp+var_14]
		mov	[edx+48h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4Ch]
		push	ecx		; struct icu_56::UVector *
		mov	ecx, [ebp+var_14] ; this
		call	?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z ;	icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)
		mov	edx, [ebp+var_14]
		mov	[edx+4Ch], eax
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_CBF
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z ; icu_56::RuleBasedTimeZone::complete(UErrorCode &)

loc_CBF:				; CODE XREF: icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone const &)+C6j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN8		dd 1			; DATA XREF: icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone const &)+E9o
		dd offset $LN7
$LN7		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00000D00o
		dd offset $LN5		; "status"
$LN5		db 'status',0           ; DATA XREF: .text:00000D0Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0D18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00000D44o
		mov	ecx, [ebp-14h]	; this
		jmp	??1BasicTimeZone@icu_56@@UAE@XZ	; icu_56::BasicTimeZone::~BasicTimeZone(void)
__unwindfunclet$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0D40h
__unwindtable$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000D50o
		dd offset __unwindfunclet$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedTimeZone::~RuleBasedTimeZone(icu_56::RuleBasedTimeZone *__hidden this)
		public ??1RuleBasedTimeZone@icu_56@@UAE@XZ
??1RuleBasedTimeZone@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::`scalar	deleting destructor'(uint)+26p
					; icu_56::RuleBasedTimeZone::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1RuleBasedTimeZone@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedTimeZone@icu_56@@6B@ ; const icu_56::RuleBasedTimeZone::`vftable'
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14] ; this
		call	?deleteTransitions@RuleBasedTimeZone@icu_56@@AAEXXZ ; icu_56::RuleBasedTimeZone::deleteTransitions(void)
		mov	ecx, [ebp+var_14] ; this
		call	?deleteRules@RuleBasedTimeZone@icu_56@@AAEXXZ ;	icu_56::RuleBasedTimeZone::deleteRules(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1BasicTimeZone@icu_56@@UAE@XZ	; icu_56::BasicTimeZone::~BasicTimeZone(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1RuleBasedTimeZone@icu_56@@UAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0DFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1RuleBasedTimeZone@icu_56@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00000E28o
		mov	ecx, [ebp-14h]	; this

loc_DFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		jmp	??1BasicTimeZone@icu_56@@UAE@XZ	; icu_56::BasicTimeZone::~BasicTimeZone(void)
__unwindfunclet$??1RuleBasedTimeZone@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1RuleBasedTimeZone@icu_56@@UAE@XZ	proc near
					; DATA XREF: icu_56::RuleBasedTimeZone::~RuleBasedTimeZone(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1RuleBasedTimeZone@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1RuleBasedTimeZone@icu_56@@UAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0E24h
__unwindtable$??1RuleBasedTimeZone@icu_56@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000E34o
		dd offset __unwindfunclet$??1RuleBasedTimeZone@icu_56@@UAE@XZ$0
__ehfuncinfo$??1RuleBasedTimeZone@icu_56@@UAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1RuleBasedTimeZone@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1RuleBasedTimeZone@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::RuleBasedTimeZone & __thiscall icu_56::RuleBasedTimeZone::operator=(class icu_56::RuleBasedTimeZone const &)
		public ??4RuleBasedTimeZone@icu_56@@QAEAAV01@ABV01@@Z
??4RuleBasedTimeZone@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+50h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_F05
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4BasicTimeZone@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::BasicTimeZone::operator=(icu_56::BasicTimeZone const &)
		mov	ecx, [ebp+var_8] ; this
		call	?deleteRules@RuleBasedTimeZone@icu_56@@AAEXXZ ;	icu_56::RuleBasedTimeZone::deleteRules(void)
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+44h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_8]
		mov	[ecx+44h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+48h]
		push	ecx		; struct icu_56::UVector *
		mov	ecx, [ebp+var_8] ; this
		call	?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z ;	icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)
		mov	edx, [ebp+var_8]
		mov	[edx+48h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4Ch]
		push	ecx		; struct icu_56::UVector *
		mov	ecx, [ebp+var_8] ; this
		call	?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z ;	icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)
		mov	edx, [ebp+var_8]
		mov	[edx+4Ch], eax
		mov	ecx, [ebp+var_8] ; this
		call	?deleteTransitions@RuleBasedTimeZone@icu_56@@AAEXXZ ; icu_56::RuleBasedTimeZone::deleteTransitions(void)
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+54h], 0

loc_F05:				; CODE XREF: icu_56::RuleBasedTimeZone::operator=(icu_56::RuleBasedTimeZone const &)+42j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4RuleBasedTimeZone@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::RuleBasedTimeZone::operator==(class icu_56::TimeZone const &)const
		public ??8RuleBasedTimeZone@icu_56@@UBECABVTimeZone@1@@Z
??8RuleBasedTimeZone@icu_56@@UBECABVTimeZone@1@@Z proc near ; DATA XREF: .rdata:00000990o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_F52
		mov	al, 1
		jmp	loc_100E
; ---------------------------------------------------------------------------

loc_F52:				; CODE XREF: icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+29j
		mov	eax, [ebp+arg_0]
		push	eax
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??9type_info@@QBE_NABV0@@Z ;	type_info::operator!=(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, al
		test	edx, edx
		jnz	short loc_F96
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8TimeZone@icu_56@@UBECABV01@@Z ; icu_56::TimeZone::operator==(icu_56::TimeZone const &)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_F9A

loc_F96:				; CODE XREF: icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+61j
		xor	al, al
		jmp	short loc_100E
; ---------------------------------------------------------------------------

loc_F9A:				; CODE XREF: icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+74j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+44h]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+44h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+44h]
		mov	edx, [eax]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_FCE
		xor	al, al
		jmp	short loc_100E
; ---------------------------------------------------------------------------

loc_FCE:				; CODE XREF: icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+A8j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		push	ecx		; icu_56::UVector *
		mov	edx, [ebp+var_8]
		mov	eax, [edx+48h]
		push	eax		; icu_56::UVector *
		call	?compareRules@icu_56@@YACPAVUVector@1@0@Z ; icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_100C
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4Ch]
		push	ecx		; icu_56::UVector *
		mov	edx, [ebp+var_8]
		mov	eax, [edx+4Ch]
		push	eax		; icu_56::UVector *
		call	?compareRules@icu_56@@YACPAVUVector@1@0@Z ; icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)

loc_FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_100C
		mov	al, 1
		jmp	short loc_100E
; ---------------------------------------------------------------------------

loc_100C:				; CODE XREF: icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+C9j
					; icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+E6j
		xor	al, al

loc_100E:				; CODE XREF: icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+2Dj
					; icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+78j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8RuleBasedTimeZone@icu_56@@UBECABVTimeZone@1@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1024h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::compareRules(icu_56::UVector *, icu_56::UVector *)
?compareRules@icu_56@@YACPAVUVector@1@0@Z proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+BCp
					; icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+D9p ...

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jnz	short loc_1057
		cmp	[ebp+arg_4], 0
		jnz	short loc_1057
		mov	al, 1
		jmp	loc_110F
; ---------------------------------------------------------------------------
		jmp	short loc_106A
; ---------------------------------------------------------------------------

loc_1057:				; CODE XREF: icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+22j
					; icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+28j
		cmp	[ebp+arg_0], 0
		jz	short loc_1063
		cmp	[ebp+arg_4], 0
		jnz	short loc_106A

loc_1063:				; CODE XREF: icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+37j
		xor	al, al
		jmp	loc_110F
; ---------------------------------------------------------------------------

loc_106A:				; CODE XREF: icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+31j
					; icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+3Dj
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		mov	esi, esp
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_8], eax
		jz	short loc_109A
		xor	al, al
		jmp	short loc_110F
; ---------------------------------------------------------------------------

loc_109A:				; CODE XREF: icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+70j
		mov	[ebp+var_14], 0
		jmp	short loc_10AC
; ---------------------------------------------------------------------------

loc_10A3:				; CODE XREF: icu_56::compareRules(icu_56::UVector *,icu_56::UVector *):loc_110Bj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_10AC:				; CODE XREF: icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+7Dj
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_8]
		jge	short loc_110D
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_20]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_20]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_110B
		xor	al, al
		jmp	short loc_110F
; ---------------------------------------------------------------------------

loc_110B:				; CODE XREF: icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+E1j
		jmp	short loc_10A3
; ---------------------------------------------------------------------------

loc_110D:				; CODE XREF: icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+8Ej
		mov	al, 1

loc_110F:				; CODE XREF: icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+2Cj
					; icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+41j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?compareRules@icu_56@@YACPAVUVector@1@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1124h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::RuleBasedTimeZone::operator!=(class icu_56::TimeZone const &)const
		public ??9RuleBasedTimeZone@icu_56@@UBECABVTimeZone@1@@Z
??9RuleBasedTimeZone@icu_56@@UBECABVTimeZone@1@@Z proc near ; DATA XREF: .rdata:000009D8o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9RuleBasedTimeZone@icu_56@@UBECABVTimeZone@1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1180h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::RuleBasedTimeZone *this,	struct icu_56::TimeZoneRule *, enum UErrorCode *)
		public ?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z
?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z proc near

var_118		= dword	ptr -118h
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_11DC
		jmp	loc_13DE
; ---------------------------------------------------------------------------

loc_11DC:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+55j
		push	0
		push	offset ??_R0?AVAnnualTimeZoneRule@icu_56@@@8 ; icu_56::AnnualTimeZoneRule `RTTI	Type Descriptor'
		push	offset ??_R0?AVTimeZoneRule@icu_56@@@8 ; icu_56::TimeZoneRule `RTTI Type Descriptor'
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	___RTDynamicCast
		add	esp, 14h
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jz	loc_1310
		mov	ecx, [ebp+var_20] ; this
		call	?getEndYear@AnnualTimeZoneRule@icu_56@@QBEHXZ ;	icu_56::AnnualTimeZoneRule::getEndYear(void)
		cmp	eax, dword ptr ds:?MAX_YEAR@AnnualTimeZoneRule@icu_56@@2HB ; int const icu_56::AnnualTimeZoneRule::MAX_YEAR
		jnz	loc_1310
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+4Ch], 0
		jnz	loc_12C6
		mov	esi, esp
		push	18h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_104], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_104], 0
		jz	short loc_1281
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_104] ; this
		call	dword ptr ds:__imp_??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::UVector::UVector(UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_104]
		mov	dword ptr [ecx], offset	??_SUVector@icu_56@@6B@	; const	icu_56::UVector::`local	vftable'
		mov	edx, [ebp+var_104]
		mov	[ebp+var_118], edx
		jmp	short loc_128B
; ---------------------------------------------------------------------------

loc_1281:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+CCj
		mov	[ebp+var_118], 0

loc_128B:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+FFj
		mov	eax, [ebp+var_118]
		mov	[ebp+var_110], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_110]
		mov	[ecx+4Ch], edx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_12C4
		jmp	loc_13DE
; ---------------------------------------------------------------------------

loc_12C4:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+13Dj
		jmp	short loc_12EE
; ---------------------------------------------------------------------------

loc_12C6:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+9Ej
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 2
		jl	short loc_12EE
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1Bh
		jmp	loc_13DE
; ---------------------------------------------------------------------------

loc_12EE:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &):loc_12C4j
					; icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+15Ej
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+4Ch]	; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_13D7
; ---------------------------------------------------------------------------

loc_1310:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+7Dj
					; icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+91j
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+48h], 0
		jnz	loc_13BA
		mov	esi, esp
		push	18h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_EC], 0
		jz	short loc_137A
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_EC] ; this
		call	dword ptr ds:__imp_??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::UVector::UVector(UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_EC]
		mov	dword ptr [ecx], offset	??_SUVector@icu_56@@6B@	; const	icu_56::UVector::`local	vftable'
		mov	edx, [ebp+var_EC]
		mov	[ebp+var_118], edx
		jmp	short loc_1384
; ---------------------------------------------------------------------------

loc_137A:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+1C5j
		mov	[ebp+var_118], 0

loc_1384:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+1F8j
		mov	eax, [ebp+var_118]
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_F8]
		mov	[ecx+48h], edx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_13BA
		jmp	short loc_13DE
; ---------------------------------------------------------------------------

loc_13BA:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+197j
					; icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+236j
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+48h]	; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_13D7:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+18Bj
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+54h], 0

loc_13DE:				; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+57j
					; icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+13Fj ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1400h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:000014ACo
		mov	esi, esp
		mov	eax, [ebp-104h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z$1	proc near
					; DATA XREF: .xdata$x:000014B4o
		mov	esi, esp
		mov	eax, [ebp-0ECh]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z$1	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-11Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1450h
		dd offset ??_R4UVector@icu_56@@6B@ ; const icu_56::UVector::`RTTI Complete Object Locator'
		public ??_SUVector@icu_56@@6B@
; const	icu_56::UVector::`local	vftable'
??_SUVector@icu_56@@6B@	dd offset ??_EUVector@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+EDo
					; icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+1E6o ...
					; icu_56::UVector::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UVector@icu_56@@UBEPAXXZ ;	icu_56::UVector::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 145Ch
		public ??_R0?AVTimeZoneRule@icu_56@@@8
; class	icu_56::TimeZoneRule `RTTI Type	Descriptor'
??_R0?AVTimeZoneRule@icu_56@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+63o
					; const	type_info::`vftable'
		dd 0
a_?avtimezoneru	db '.?AVTimeZoneRule@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1480h
		public ??_R0?AVAnnualTimeZoneRule@icu_56@@@8
; class	icu_56::AnnualTimeZoneRule `RTTI Type Descriptor'
??_R0?AVAnnualTimeZoneRule@icu_56@@@8 dd offset	??_7type_info@@6B@
					; DATA XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+5Eo
					; const	type_info::`vftable'
		align 8
a_?avannualtime	db '.?AVAnnualTimeZoneRule@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 14A8h
__unwindtable$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000014C0o
		dd offset __unwindfunclet$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?addTransitionRule@RuleBasedTimeZone@icu_56@@QAEXPAVTimeZoneRule@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 14DCh
		public ??_R4UVector@icu_56@@6B@
; const	icu_56::UVector::`RTTI Complete	Object Locator'
??_R4UVector@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00001450o
		dd offset ??_R0?AVUVector@icu_56@@@8 ; icu_56::UVector `RTTI Type Descriptor'
		dd offset ??_R3UVector@icu_56@@8 ; icu_56::UVector::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 14F0h
		public ??_R0?AVUVector@icu_56@@@8
; class	icu_56::UVector	`RTTI Type Descriptor'
??_R0?AVUVector@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:000014E8o
					; .rdata$r:icu_56::UVector::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avuvector@ic	db '.?AVUVector@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1510h
		public ??_R3UVector@icu_56@@8
; icu_56::UVector::`RTTI Class Hierarchy Descriptor'
??_R3UVector@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000014ECo
					; .rdata$r:00001548o
		dd 3
		dd offset ??_R2UVector@icu_56@@8 ; icu_56::UVector::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1520h
		public ??_R2UVector@icu_56@@8
; icu_56::UVector::`RTTI Base Class Array'
??_R2UVector@icu_56@@8 dd offset ??_R1A@?0A@EA@UVector@icu_56@@8
					; DATA XREF: .rdata$r:0000151Co
					; icu_56::UVector::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1530h
		public ??_R1A@?0A@EA@UVector@icu_56@@8
; icu_56::UVector::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UVector@icu_56@@8	dd offset ??_R0?AVUVector@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UVector::`RTTI Base Class	Array'o
					; icu_56::UVector `RTTI	Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UVector@icu_56@@8 ; icu_56::UVector::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 154Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+48p
					; icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+130p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1578h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UVector::`scalar deleting destructor'(unsigned int)
		public ??_GUVector@icu_56@@UAEPAXI@Z
??_GUVector@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_15CB
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_15CB:				; CODE XREF: icu_56::UVector::`scalar deleting destructor'(uint)+3Bj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUVector@icu_56@@UAEPAXI@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedTimeZone::completeConst(icu_56::RuleBasedTimeZone *this, enum UErrorCode *)
		public ?completeConst@RuleBasedTimeZone@icu_56@@ABEXAAW4UErrorCode@@@Z
?completeConst@RuleBasedTimeZone@icu_56@@ABEXAAW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::getNextTransition(double,signed	char,icu_56::TimeZoneTransition	&)+31p
					; icu_56::RuleBasedTimeZone::getPreviousTransition(double,signed char,icu_56::TimeZoneTransition &)+31p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_161E
		jmp	short loc_1655
; ---------------------------------------------------------------------------

loc_161E:				; CODE XREF: icu_56::RuleBasedTimeZone::completeConst(UErrorCode &)+36j
		push	offset _gLock
		call	_umtx_lock_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jnz	short loc_1648
		mov	eax, [ebp+var_8]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z ; icu_56::RuleBasedTimeZone::complete(UErrorCode &)

loc_1648:				; CODE XREF: icu_56::RuleBasedTimeZone::completeConst(UErrorCode &)+50j
		push	offset _gLock
		call	_umtx_unlock_56
		add	esp, 4

loc_1655:				; CODE XREF: icu_56::RuleBasedTimeZone::completeConst(UErrorCode &)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?completeConst@RuleBasedTimeZone@icu_56@@ABEXAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 166Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedTimeZone::complete(icu_56::RuleBasedTimeZone	*this, enum UErrorCode *)
		public ?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z
?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone const &)+D6p
					; icu_56::RuleBasedTimeZone::completeConst(UErrorCode &)+5Fp

var_2FC		= qword	ptr -2FCh
var_2D4		= dword	ptr -2D4h
var_2CC		= dword	ptr -2CCh
var_2C0		= dword	ptr -2C0h
var_2B4		= dword	ptr -2B4h
var_2A8		= dword	ptr -2A8h
var_1DC		= dword	ptr -1DCh
var_1D0		= dword	ptr -1D0h
var_1C1		= byte ptr -1C1h
var_1B5		= byte ptr -1B5h
var_1AC		= qword	ptr -1ACh
var_19C		= qword	ptr -19Ch
var_18C		= dword	ptr -18Ch
var_180		= dword	ptr -180h
var_174		= dword	ptr -174h
var_168		= dword	ptr -168h
var_15C		= dword	ptr -15Ch
var_14D		= byte ptr -14Dh
var_144		= byte ptr -144h
var_FC		= byte ptr -0FCh
var_B4		= qword	ptr -0B4h
var_A1		= byte ptr -0A1h
var_98		= dword	ptr -98h
var_8C		= dword	ptr -8Ch
var_80		= qword	ptr -80h
var_70		= dword	ptr -70h
var_64		= dword	ptr -64h
var_58		= dword	ptr -58h
var_4C		= dword	ptr -4Ch
var_40		= qword	ptr -40h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 2C8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_2D4]
		mov	ecx, 0B2h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_16CB
		jmp	loc_2182
; ---------------------------------------------------------------------------

loc_16CB:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+58j
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jz	short loc_16DB
		jmp	loc_2182
; ---------------------------------------------------------------------------

loc_16DB:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+68j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+4Ch], 0
		jz	short loc_170C
		mov	esi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 2
		jz	short loc_170C
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 1Bh
		jmp	loc_2182
; ---------------------------------------------------------------------------

loc_170C:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+76j
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+90j
		mov	[ebp+var_24], 0
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+48h], 0
		jnz	short loc_1729
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+4Ch], 0
		jz	loc_2146

loc_1729:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+AEj
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+44h]
		mov	[ebp+var_30], ecx
		fld	ds:__real@c384763b62073280
		fstp	[ebp+var_40]
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+48h], 0
		jz	loc_1D9B
		mov	esi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+48h]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jle	loc_1D9B
		mov	esi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+48h]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_58], eax
		mov	eax, [ebp+var_58]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_24], eax
		cmp	[ebp+var_24], 0
		jnz	short loc_17A0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7
		jmp	$cleanup$70654
; ---------------------------------------------------------------------------

loc_17A0:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+124j
		mov	[ebp+var_4C], 0
		jmp	short loc_17B2
; ---------------------------------------------------------------------------

loc_17A9:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+157j
		mov	eax, [ebp+var_4C]
		add	eax, 1
		mov	[ebp+var_4C], eax

loc_17B2:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+13Bj
		mov	eax, [ebp+var_4C]
		cmp	eax, [ebp+var_58]
		jge	short loc_17C5
		mov	eax, [ebp+var_24]
		add	eax, [ebp+var_4C]
		mov	byte ptr [eax],	0
		jmp	short loc_17A9
; ---------------------------------------------------------------------------

loc_17C5:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+14Cj
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+72Aj
		mov	eax, 1
		test	eax, eax
		jz	loc_1D9B
		mov	ecx, [ebp+var_30] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		mov	[ebp+var_64], eax
		mov	ecx, [ebp+var_30] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		mov	[ebp+var_70], eax
		fld	ds:__real@43846a3eddf8cd80
		fstp	[ebp+var_80]
		mov	[ebp+var_8C], 0
		mov	[ebp+var_98], 0
		mov	esi, esp
		lea	ecx, [ebp+var_FC] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		lea	eax, [ebp+var_FC]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_30] ; this
		call	?getName@TimeZoneRule@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z ; icu_56::TimeZoneRule::getName(icu_56::UnicodeString &)
		mov	[ebp+var_4C], 0
		jmp	short loc_185B
; ---------------------------------------------------------------------------

loc_1852:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+208j
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &):loc_1978j ...
		mov	eax, [ebp+var_4C]
		add	eax, 1
		mov	[ebp+var_4C], eax

loc_185B:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+1E4j
		mov	eax, [ebp+var_4C]
		cmp	eax, [ebp+var_58]
		jge	loc_19A7
		mov	eax, [ebp+var_24]
		add	eax, [ebp+var_4C]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_1876
		jmp	short loc_1852
; ---------------------------------------------------------------------------

loc_1876:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+206j
		mov	esi, esp
		mov	eax, [ebp+var_4C]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+48h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_98], eax
		mov	esi, esp
		lea	eax, [ebp+var_B4]
		push	eax
		push	0
		mov	ecx, [ebp+var_70]
		push	ecx
		mov	edx, [ebp+var_64]
		push	edx
		sub	esp, 8
		fld	[ebp+var_40]
		fstp	[esp+2FCh+var_2FC]
		mov	eax, [ebp+var_98]
		mov	edx, [eax]
		mov	ecx, [ebp+var_98]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_A1], al
		movsx	eax, [ebp+var_A1]
		test	eax, eax
		jnz	short loc_18EA
		mov	eax, [ebp+var_24]
		add	eax, [ebp+var_4C]
		mov	byte ptr [eax],	1
		jmp	loc_19A2
; ---------------------------------------------------------------------------

loc_18EA:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+26Ej
		lea	eax, [ebp+var_144]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_98] ; this
		call	?getName@TimeZoneRule@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z ; icu_56::TimeZoneRule::getName(icu_56::UnicodeString &)
		mov	esi, esp
		mov	eax, [ebp+var_30]
		push	eax
		mov	ecx, [ebp+var_98]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_98]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_1978
		mov	esi, esp
		lea	eax, [ebp+var_FC]
		push	eax
		lea	ecx, [ebp+var_144]
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_197D
		mov	ecx, [ebp+var_98] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		mov	esi, eax
		mov	ecx, [ebp+var_30] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		cmp	esi, eax
		jnz	short loc_197D
		mov	ecx, [ebp+var_98] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		mov	esi, eax
		mov	ecx, [ebp+var_30] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		cmp	esi, eax
		jnz	short loc_197D

loc_1978:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+2B5j
		jmp	loc_1852
; ---------------------------------------------------------------------------

loc_197D:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+2D8j
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+2F1j ...
		fld	[ebp+var_80]
		fcomp	[ebp+var_B4]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_19A2
		fld	[ebp+var_B4]
		fstp	[ebp+var_80]
		mov	eax, [ebp+var_98]
		mov	[ebp+var_8C], eax

loc_19A2:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+279j
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+31Fj
		jmp	loc_1852
; ---------------------------------------------------------------------------

loc_19A7:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+1F5j
		cmp	[ebp+var_8C], 0
		jnz	loc_1A41
		mov	[ebp+var_14D], 1
		mov	[ebp+var_15C], 0
		jmp	short loc_19D6
; ---------------------------------------------------------------------------

loc_19C7:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &):loc_19FAj
		mov	eax, [ebp+var_15C]
		add	eax, 1
		mov	[ebp+var_15C], eax

loc_19D6:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+359j
		mov	eax, [ebp+var_15C]
		cmp	eax, [ebp+var_58]
		jge	short loc_19FC
		mov	eax, [ebp+var_24]
		add	eax, [ebp+var_15C]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_19FA
		mov	[ebp+var_14D], 0
		jmp	short loc_19FC
; ---------------------------------------------------------------------------

loc_19FA:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+383j
		jmp	short loc_19C7
; ---------------------------------------------------------------------------

loc_19FC:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+373j
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+38Cj
		movsx	eax, [ebp+var_14D]
		test	eax, eax
		jz	short loc_1A41
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_FC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_1D9B
; ---------------------------------------------------------------------------

loc_1A41:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+342j
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+399j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+4Ch], 0
		jz	loc_1B42
		mov	[ebp+var_4C], 0
		jmp	short loc_1A60
; ---------------------------------------------------------------------------

loc_1A57:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+444j
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &):loc_1B3Dj
		mov	eax, [ebp+var_4C]
		add	eax, 1
		mov	[ebp+var_4C], eax

loc_1A60:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+3E9j
		cmp	[ebp+var_4C], 2
		jge	loc_1B42
		mov	esi, esp
		mov	eax, [ebp+var_4C]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4Ch]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_168], eax
		mov	esi, esp
		mov	eax, [ebp+var_30]
		push	eax
		mov	ecx, [ebp+var_168]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_168]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_1AB2
		jmp	short loc_1A57
; ---------------------------------------------------------------------------

loc_1AB2:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+442j
		mov	esi, esp
		mov	eax, [ebp+var_4C]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4Ch]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_98], eax
		mov	esi, esp
		lea	eax, [ebp+var_B4]
		push	eax
		push	0
		mov	ecx, [ebp+var_70]
		push	ecx
		mov	edx, [ebp+var_64]
		push	edx
		sub	esp, 8
		fld	[ebp+var_40]
		fstp	[esp+2FCh+var_2FC]
		mov	eax, [ebp+var_98]
		mov	edx, [eax]
		mov	ecx, [ebp+var_98]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_A1], al
		movsx	eax, [ebp+var_A1]
		test	eax, eax
		jz	short loc_1B3D
		fld	[ebp+var_80]
		fcomp	[ebp+var_B4]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_1B3D
		fld	[ebp+var_B4]
		fstp	[ebp+var_80]
		mov	eax, [ebp+var_98]
		mov	[ebp+var_8C], eax

loc_1B3D:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+4AAj
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+4BAj
		jmp	loc_1A57
; ---------------------------------------------------------------------------

loc_1B42:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+3DCj
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+3F8j
		cmp	[ebp+var_8C], 0
		jnz	short loc_1B85
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_FC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_1D9B
; ---------------------------------------------------------------------------

loc_1B85:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+4DDj
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+50h], 0
		jnz	loc_1C61
		mov	esi, esp
		push	18h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C0], eax
		mov	byte ptr [ebp+var_4], 2
		cmp	[ebp+var_2C0], 0
		jz	short loc_1BEC
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_2C0] ; this
		call	dword ptr ds:__imp_??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::UVector::UVector(UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_2C0]
		mov	dword ptr [ecx], offset	??_SUVector@icu_56@@6B@	; const	icu_56::UVector::`local	vftable'
		mov	edx, [ebp+var_2C0]
		mov	[ebp+var_2D4], edx
		jmp	short loc_1BF6
; ---------------------------------------------------------------------------

loc_1BEC:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+54Bj
		mov	[ebp+var_2D4], 0

loc_1BF6:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+57Ej
		mov	eax, [ebp+var_2D4]
		mov	[ebp+var_2CC], eax
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_18]
		mov	edx, [ebp+var_2CC]
		mov	[ecx+50h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1C61
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_FC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	$cleanup$70654
; ---------------------------------------------------------------------------

loc_1C61:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+520j
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+5B9j
		push	10h
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_174], eax
		cmp	[ebp+var_174], 0
		jnz	short loc_1CBD
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_FC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	$cleanup$70654
; ---------------------------------------------------------------------------

loc_1CBD:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+60Cj
		mov	eax, [ebp+var_174]
		fld	[ebp+var_80]
		fstp	qword ptr [eax]
		mov	eax, [ebp+var_174]
		mov	ecx, [ebp+var_30]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_174]
		mov	ecx, [ebp+var_8C]
		mov	[eax+0Ch], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_174]
		push	ecx		; void *
		mov	edx, [ebp+var_18]
		mov	ecx, [edx+50h]	; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1D52
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_FC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	$cleanup$70654
; ---------------------------------------------------------------------------

loc_1D52:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+6AAj
		fld	[ebp+var_80]
		fstp	[ebp+var_40]
		mov	eax, [ebp+var_8C]
		mov	[ebp+var_30], eax
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_FC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_17C5
; ---------------------------------------------------------------------------

loc_1D9B:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+D6j
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+F3j ...
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+4Ch], 0
		jz	loc_2146
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+50h], 0
		jnz	loc_1E55
		mov	esi, esp
		push	18h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2A8], eax
		mov	[ebp+var_4], 3
		cmp	[ebp+var_2A8], 0
		jz	short loc_1E12
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_2A8] ; this
		call	dword ptr ds:__imp_??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::UVector::UVector(UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_2A8]
		mov	dword ptr [ecx], offset	??_SUVector@icu_56@@6B@	; const	icu_56::UVector::`local	vftable'
		mov	edx, [ebp+var_2A8]
		mov	[ebp+var_2D4], edx
		jmp	short loc_1E1C
; ---------------------------------------------------------------------------

loc_1E12:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+771j
		mov	[ebp+var_2D4], 0

loc_1E1C:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+7A4j
		mov	eax, [ebp+var_2D4]
		mov	[ebp+var_2B4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_18]
		mov	edx, [ebp+var_2B4]
		mov	[ecx+50h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1E55
		jmp	$cleanup$70654
; ---------------------------------------------------------------------------

loc_1E55:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+743j
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+7E2j
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_180], eax
		mov	esi, esp
		push	1		; int
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_18C], eax
		mov	esi, esp
		lea	eax, [ebp+var_19C]
		push	eax
		push	0
		mov	ecx, [ebp+var_30] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax
		mov	ecx, [ebp+var_30] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax
		sub	esp, 8
		fld	[ebp+var_40]
		fstp	[esp+2FCh+var_2FC]
		mov	ecx, [ebp+var_180]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_180]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1B5], al
		mov	esi, esp
		lea	eax, [ebp+var_1AC]
		push	eax
		push	0
		mov	ecx, [ebp+var_30] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax
		mov	ecx, [ebp+var_30] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax
		sub	esp, 8
		fld	[ebp+var_40]
		fstp	[esp+2FCh+var_2FC]
		mov	ecx, [ebp+var_18C]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_18C]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1C1], al
		movsx	eax, [ebp+var_1B5]
		test	eax, eax
		jz	short loc_1F31
		movsx	eax, [ebp+var_1C1]
		test	eax, eax
		jnz	short loc_1F3F

loc_1F31:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+8B8j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 1Bh
		jmp	$cleanup$70654
; ---------------------------------------------------------------------------

loc_1F3F:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+8C3j
		push	10h
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_1D0], eax
		cmp	[ebp+var_1D0], 0
		jnz	short loc_1F66
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7
		jmp	$cleanup$70654
; ---------------------------------------------------------------------------

loc_1F66:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+8EAj
		push	10h
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_1DC], eax
		cmp	[ebp+var_1DC], 0
		jnz	short loc_1F9C
		mov	eax, [ebp+var_1D0]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7
		jmp	$cleanup$70654
; ---------------------------------------------------------------------------

loc_1F9C:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+911j
		fld	[ebp+var_1AC]
		fcomp	[ebp+var_19C]
		fnstsw	ax
		test	ah, 41h
		jnz	loc_2048
		mov	eax, [ebp+var_1D0]
		fld	[ebp+var_19C]
		fstp	qword ptr [eax]
		mov	eax, [ebp+var_1D0]
		mov	ecx, [ebp+var_30]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_1D0]
		mov	ecx, [ebp+var_180]
		mov	[eax+0Ch], ecx
		mov	esi, esp
		mov	eax, [ebp+var_1DC]
		push	eax
		push	0
		mov	ecx, [ebp+var_180] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax
		mov	ecx, [ebp+var_180] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax

loc_1FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		sub	esp, 8
		fld	[ebp+var_19C]
		fstp	[esp+2FCh+var_2FC]
		mov	ecx, [ebp+var_18C]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_18C]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_1DC]
		mov	ecx, [ebp+var_180]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_1DC]
		mov	ecx, [ebp+var_18C]
		mov	[eax+0Ch], ecx
		jmp	loc_20D8
; ---------------------------------------------------------------------------

loc_2048:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+941j
		mov	eax, [ebp+var_1D0]
		fld	[ebp+var_1AC]
		fstp	qword ptr [eax]
		mov	eax, [ebp+var_1D0]
		mov	ecx, [ebp+var_30]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_1D0]
		mov	ecx, [ebp+var_18C]
		mov	[eax+0Ch], ecx
		mov	esi, esp
		mov	eax, [ebp+var_1DC]
		push	eax
		push	0
		mov	ecx, [ebp+var_18C] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax
		mov	ecx, [ebp+var_18C] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax
		sub	esp, 8
		fld	[ebp+var_1AC]
		fstp	[esp+2FCh+var_2FC]
		mov	ecx, [ebp+var_180]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_180]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_1DC]
		mov	ecx, [ebp+var_18C]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_1DC]
		mov	ecx, [ebp+var_180]
		mov	[eax+0Ch], ecx

loc_20D8:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+9D7j
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_1D0]
		push	ecx		; void *
		mov	edx, [ebp+var_18]
		mov	ecx, [edx+50h]	; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_210F
		jmp	short $cleanup$70654
; ---------------------------------------------------------------------------

loc_210F:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+A9Fj
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_1DC]
		push	ecx		; void *
		mov	edx, [ebp+var_18]
		mov	ecx, [edx+50h]	; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2146
		jmp	short $cleanup$70654
; ---------------------------------------------------------------------------

loc_2146:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+B7j
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+736j ...
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+54h], 1
		cmp	[ebp+var_24], 0
		jz	short loc_215F
		mov	eax, [ebp+var_24]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_215F:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+AE5j
		jmp	short loc_2182
; ---------------------------------------------------------------------------

$cleanup$70654:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+12Fj
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+5F0j ...
		mov	ecx, [ebp+var_18] ; this
		call	?deleteTransitions@RuleBasedTimeZone@icu_56@@AAEXXZ ; icu_56::RuleBasedTimeZone::deleteTransitions(void)
		cmp	[ebp+var_24], 0
		jz	short loc_217B
		mov	eax, [ebp+var_24]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_217B:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+B01j
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+54h], 0

loc_2182:				; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+5Aj
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+6Aj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN80
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 2D4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN80		dd 5			; DATA XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+B1Ao
		dd offset $LN79
$LN79		dd 0FFFFFF4Ch, 8	; DATA XREF: .text:000021C4o
		dd offset $LN73		; "tt"
		dd 0FFFFFF04h, 40h
		dd offset $LN74		; "curName"
		dd 0FFFFFEBCh, 40h
		dd offset $LN75		; "name"
		dd 0FFFFFE64h, 8
		dd offset $LN76
		dd 0FFFFFE54h, 8
		dd offset $LN77
$LN77		dd 317474h		; DATA XREF: .text:00002200o
$LN76		dd 307474h		; DATA XREF: .text:000021F4o
$LN75		db 'name',0             ; DATA XREF: .text:000021E8o
$LN74		db 'curName',0          ; DATA XREF: .text:000021DCo
$LN73		db 'tt',0               ; DATA XREF: .text:000021D0o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 221Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$10 proc near
					; DATA XREF: .xdata$x:000022B4o
		mov	esi, esp
		lea	ecx, [ebp-0FCh]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$10 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$11 proc near
					; DATA XREF: .xdata$x:000022BCo
		mov	esi, esp
		lea	ecx, [ebp-144h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$11 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$12 proc near
					; DATA XREF: .xdata$x:000022C4o
		mov	esi, esp
		mov	eax, [ebp-2C0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$12 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$13 proc near
					; DATA XREF: .xdata$x:000022CCo
		mov	esi, esp
		mov	eax, [ebp-2A8h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$13 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-2D8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 22A0h
		public __real@43846a3eddf8cd80
__real@43846a3eddf8cd80	dq 1.838821689216e17
					; DATA XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+17Cr
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 22A8h
		public __real@c384763b62073280
__real@c384763b62073280	dq -1.84303902528e17
					; DATA XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+C6r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 22B0h
__unwindtable$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000022D8o
		dd offset __unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$10
		dd 0
		dd offset __unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$11
		dd 1
		dd offset __unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$12
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z$13
__ehfuncinfo$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z	dd 19930522h, 4
					; DATA XREF: __ehhandler$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?complete@RuleBasedTimeZone@icu_56@@QAEXAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::TimeZone *__thiscall icu_56::RuleBasedTimeZone::clone(icu_56::RuleBasedTimeZone *__hidden this)
		public ?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ
?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ proc near ; DATA XREF: .rdata:000009B4o

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		push	58h ; 'X'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_2377
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::RuleBasedTimeZone *
		mov	ecx, [ebp+var_E0] ; this
		call	??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z ; icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_2381
; ---------------------------------------------------------------------------

loc_2377:				; CODE XREF: icu_56::RuleBasedTimeZone::clone(void)+6Aj
		mov	[ebp+var_F4], 0

loc_2381:				; CODE XREF: icu_56::RuleBasedTimeZone::clone(void)+81j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_EC]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 23BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ$0 proc near
					; DATA XREF: .xdata$x:000023F8o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ proc near
					; DATA XREF: icu_56::RuleBasedTimeZone::clone(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 23F4h
__unwindtable$?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002404o
		dd offset __unwindfunclet$?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ$0
__ehfuncinfo$?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ+14o
		dd offset __unwindtable$?clone@RuleBasedTimeZone@icu_56@@UBEPAVTimeZone@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2420h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedTimeZone::getOffset(icu_56::RuleBasedTimeZone	*this, char, int, int, int, char, int, enum UErrorCode *)
		public ?getOffset@RuleBasedTimeZone@icu_56@@UBEHEHHHEHAAW4UErrorCode@@@Z
?getOffset@RuleBasedTimeZone@icu_56@@UBEHEHHHEHAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:0000099Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= byte ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_245C
		xor	eax, eax
		jmp	short loc_24BF
; ---------------------------------------------------------------------------

loc_245C:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,UErrorCode &)+36j
		cmp	[ebp+arg_8], 0
		jl	short loc_2468
		cmp	[ebp+arg_8], 0Bh
		jle	short loc_2477

loc_2468:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,UErrorCode &)+40j
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_24BF
; ---------------------------------------------------------------------------
		jmp	short loc_24BF
; ---------------------------------------------------------------------------

loc_2477:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,UErrorCode &)+46j
		mov	esi, esp
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		call	?monthLength@Grego@icu_56@@SACHH@Z ; icu_56::Grego::monthLength(int,int)
		add	esp, 8
		movsx	eax, al
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		movzx	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		movzx	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_24BF:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,UErrorCode &)+3Aj
					; icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,UErrorCode &)+53j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	1Ch
?getOffset@RuleBasedTimeZone@icu_56@@UBEHEHHHEHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__cdecl	icu_56::Grego::monthLength(int,	int)
		public ?monthLength@Grego@icu_56@@SACHH@Z
?monthLength@Grego@icu_56@@SACHH@Z proc	near
					; CODE XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,UErrorCode &)+65p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	?isLeapYear@Grego@icu_56@@SACH@Z ; icu_56::Grego::isLeapYear(int)
		add	esp, 4
		movsx	ecx, al
		neg	ecx
		sbb	ecx, ecx
		and	ecx, 0Ch
		mov	edx, [ebp+arg_4]
		mov	al, byte ptr ds:?MONTH_LENGTH@Grego@icu_56@@0QBCB[edx+ecx] ; signed char const * const icu_56::Grego::MONTH_LENGTH
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?monthLength@Grego@icu_56@@SACHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 252Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__cdecl	icu_56::Grego::isLeapYear(int)
		public ?isLeapYear@Grego@icu_56@@SACH@Z
?isLeapYear@Grego@icu_56@@SACH@Z proc near
					; CODE XREF: icu_56::Grego::monthLength(int,int)+22p

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		and	eax, 3
		jnz	short loc_2579
		mov	eax, [ebp+arg_0]
		cdq
		mov	ecx, 64h ; 'd'
		idiv	ecx
		test	edx, edx
		jnz	short loc_2570
		mov	eax, [ebp+arg_0]
		cdq
		mov	ecx, 190h
		idiv	ecx
		test	edx, edx
		jnz	short loc_2579

loc_2570:				; CODE XREF: icu_56::Grego::isLeapYear(int)+33j
		mov	[ebp+var_C1], 1
		jmp	short loc_2580
; ---------------------------------------------------------------------------

loc_2579:				; CODE XREF: icu_56::Grego::isLeapYear(int)+24j
					; icu_56::Grego::isLeapYear(int)+42j
		mov	[ebp+var_C1], 0

loc_2580:				; CODE XREF: icu_56::Grego::isLeapYear(int)+4Bj
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLeapYear@Grego@icu_56@@SACH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2590h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedTimeZone::getOffset(icu_56::RuleBasedTimeZone	*this, char, int, int, int, unsigned __int8, int, int, enum UErrorCode *)
		public ?getOffset@RuleBasedTimeZone@icu_56@@UBEHEHHHEHHAAW4UErrorCode@@@Z
?getOffset@RuleBasedTimeZone@icu_56@@UBEHEHHHEHHAAW4UErrorCode@@@Z proc	near
					; DATA XREF: .rdata:00000998o

var_120		= qword	ptr -120h
var_F4		= byte ptr -0F4h
var_30		= qword	ptr -30h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= byte ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_14		= dword	ptr  1Ch
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_25CC
		xor	eax, eax
		jmp	short loc_2641
; ---------------------------------------------------------------------------

loc_25CC:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,int,UErrorCode &)+36j
		movzx	eax, [ebp+arg_0]
		test	eax, eax
		jnz	short loc_25DF
		mov	eax, 1
		sub	eax, [ebp+arg_4]
		mov	[ebp+arg_4], eax

loc_25DF:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,int,UErrorCode &)+42j
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		call	?fieldsToDay@Grego@icu_56@@SANHHH@Z ; icu_56::Grego::fieldsToDay(int,int,int)
		add	esp, 0Ch
		fmul	ds:__real@4194997000000000
		fiadd	[ebp+arg_14]
		fstp	[ebp+var_30]
		mov	eax, [ebp+arg_1C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_20]
		push	ecx		; int *
		lea	edx, [ebp+var_14]
		push	edx		; int *
		push	1		; int
		push	3		; int
		push	1		; char
		sub	esp, 8
		fld	[ebp+var_30]
		fstp	[esp+120h+var_120] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?getOffsetInternal@RuleBasedTimeZone@icu_56@@ABEXNCHHAAH0AAW4UErrorCode@@@Z ; icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed char,int,int,int &,int	&,UErrorCode &)
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_263B
		xor	eax, eax
		jmp	short loc_2641
; ---------------------------------------------------------------------------

loc_263B:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,int,UErrorCode &)+A5j
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_20]

loc_2641:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,int,UErrorCode &)+3Aj
					; icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,int,UErrorCode &)+A9j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	20h
?getOffset@RuleBasedTimeZone@icu_56@@UBEHEHHHEHHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN9		dd 2			; DATA XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,int,UErrorCode &)+B5o
		dd offset $LN8_0
$LN8_0		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000266Co
		dd offset $LN6		; "rawOffset"
		dd 0FFFFFFE0h, 4
		dd offset $LN7_0	; "dstOffset"
$LN7_0		db 'dstOffset',0        ; DATA XREF: .text:00002684o
$LN6		db 'rawOffset',0        ; DATA XREF: .text:00002678o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 269Ch
		public __real@4194997000000000
__real@4194997000000000	dq 8.64e7	; DATA XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,int,UErrorCode &)+63r
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedTimeZone::getOffset(icu_56::RuleBasedTimeZone *this,	double,	char, int *, int *, enum UErrorCode *)
		public ?getOffset@RuleBasedTimeZone@icu_56@@UBEXNCAAH0AAW4UErrorCode@@@Z
?getOffset@RuleBasedTimeZone@icu_56@@UBEXNCAAH0AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00000994o

var_F8		= qword	ptr -0F8h
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; int *
		mov	edx, [ebp+arg_C]
		push	edx		; int *
		push	0Ch		; int
		push	4		; int
		movzx	eax, [ebp+arg_8]
		push	eax		; char
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0F8h+var_F8] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?getOffsetInternal@RuleBasedTimeZone@icu_56@@ABEXNCHHAAH0AAW4UErrorCode@@@Z ; icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed char,int,int,int &,int	&,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?getOffset@RuleBasedTimeZone@icu_56@@UBEXNCAAH0AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2704h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedTimeZone::getOffsetFromLocal(icu_56::RuleBasedTimeZone *this, double, int, int, int *, int *, enum UErrorCode *)
		public ?getOffsetFromLocal@RuleBasedTimeZone@icu_56@@UBEXNHHAAH0AAW4UErrorCode@@@Z
?getOffsetFromLocal@RuleBasedTimeZone@icu_56@@UBEXNHHAAH0AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:000009D4o

var_F8		= qword	ptr -0F8h
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_14]
		push	ecx		; int *
		mov	edx, [ebp+arg_10]
		push	edx		; int *
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		push	1		; char
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0F8h+var_F8] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?getOffsetInternal@RuleBasedTimeZone@icu_56@@ABEXNCHHAAH0AAW4UErrorCode@@@Z ; icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed char,int,int,int &,int	&,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	1Ch
?getOffsetFromLocal@RuleBasedTimeZone@icu_56@@UBEXNHHAAH0AAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2764h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedTimeZone::getOffsetInternal(icu_56::RuleBasedTimeZone *this,	double,	char, int, int,	int *, int *, enum UErrorCode *)
		public ?getOffsetInternal@RuleBasedTimeZone@icu_56@@ABEXNCHHAAH0AAW4UErrorCode@@@Z
?getOffsetInternal@RuleBasedTimeZone@icu_56@@ABEXNCHHAAH0AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,int,UErrorCode &)+8Dp
					; icu_56::RuleBasedTimeZone::getOffset(double,signed char,int &,int &,UErrorCode &)+44p ...

var_124		= qword	ptr -124h
var_104		= byte ptr -104h
var_40		= qword	ptr -40h
var_30		= byte ptr -30h
var_24		= qword	ptr -24h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 104h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_104]
		mov	ecx, 41h ; 'A'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_27B3
		jmp	loc_296B
; ---------------------------------------------------------------------------

loc_27B3:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+48j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+54h]
		test	ecx, ecx
		jnz	short loc_27CC
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 1Bh
		jmp	loc_296B
; ---------------------------------------------------------------------------

loc_27CC:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+58j
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+50h], 0
		jnz	short loc_27EA
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+44h]
		mov	[ebp+var_14], ecx
		jmp	loc_294B
; ---------------------------------------------------------------------------

loc_27EA:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+76j
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		movzx	edx, [ebp+arg_8]
		push	edx		; char
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; struct icu_56::Transition *
		mov	ecx, [ebp+var_8] ; this
		call	?getTransitionTime@RuleBasedTimeZone@icu_56@@ABENPAUTransition@2@CHH@Z ; icu_56::RuleBasedTimeZone::getTransitionTime(icu_56::Transition *,signed char,int,int)
		fstp	[ebp+var_24]
		fld	[ebp+var_24]
		fcomp	[ebp+arg_0]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_2835
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+44h]
		mov	[ebp+var_14], ecx
		jmp	loc_294B
; ---------------------------------------------------------------------------

loc_2835:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+C1j
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, 1
		mov	dword ptr [ebp+var_30],	eax
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		movzx	edx, [ebp+arg_8]
		push	edx		; char
		mov	esi, esp
		mov	eax, dword ptr [ebp+var_30]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+50h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; struct icu_56::Transition *
		mov	ecx, [ebp+var_8] ; this
		call	?getTransitionTime@RuleBasedTimeZone@icu_56@@ABENPAUTransition@2@CHH@Z ; icu_56::RuleBasedTimeZone::getTransitionTime(icu_56::Transition *,signed char,int,int)
		fstp	[ebp+var_40]
		fld	[ebp+var_40]
		fcomp	[ebp+arg_0]
		fnstsw	ax
		test	ah, 5
		jp	short loc_28E0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0
		jz	short loc_28B9
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		movzx	edx, [ebp+arg_8]
		push	edx		; char
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+124h+var_124] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?findRuleInFinal@RuleBasedTimeZone@icu_56@@ABEPAVTimeZoneRule@2@NCHH@Z ; icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)
		mov	[ebp+var_14], eax

loc_28B9:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+132j
		cmp	[ebp+var_14], 0
		jnz	short loc_28DE
		mov	esi, esp
		mov	eax, dword ptr [ebp+var_30]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+50h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [eax+0Ch]
		mov	[ebp+var_14], edx

loc_28DE:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+159j
		jmp	short loc_294B
; ---------------------------------------------------------------------------

loc_28E0:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+129j
					; icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed char,int,int,int &,int &,UErrorCode &)+1C6j
		cmp	dword ptr [ebp+var_30],	0
		jl	short loc_292C
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		movzx	edx, [ebp+arg_8]
		push	edx		; char
		mov	esi, esp
		mov	eax, dword ptr [ebp+var_30]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+50h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; struct icu_56::Transition *
		mov	ecx, [ebp+var_8] ; this
		call	?getTransitionTime@RuleBasedTimeZone@icu_56@@ABENPAUTransition@2@CHH@Z ; icu_56::RuleBasedTimeZone::getTransitionTime(icu_56::Transition *,signed char,int,int)
		fcomp	[ebp+arg_0]
		fnstsw	ax
		test	ah, 41h
		jp	short loc_2921
		jmp	short loc_292C
; ---------------------------------------------------------------------------

loc_2921:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+1B9j
		mov	eax, dword ptr [ebp+var_30]
		sub	eax, 1
		mov	dword ptr [ebp+var_30],	eax
		jmp	short loc_28E0
; ---------------------------------------------------------------------------

loc_292C:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+180j
					; icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed char,int,int,int &,int &,UErrorCode &)+1BBj
		mov	esi, esp
		mov	eax, dword ptr [ebp+var_30]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+50h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [eax+0Ch]
		mov	[ebp+var_14], edx

loc_294B:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+81j
					; icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed char,int,int,int &,int &,UErrorCode &)+CCj ...
		cmp	[ebp+var_14], 0
		jz	short loc_296B
		mov	ecx, [ebp+var_14] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		mov	ecx, [ebp+arg_14]
		mov	[ecx], eax
		mov	ecx, [ebp+var_14] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		mov	ecx, [ebp+arg_18]
		mov	[ecx], eax

loc_296B:				; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+4Aj
					; icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed char,int,int,int &,int &,UErrorCode &)+63j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 104h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	20h
?getOffsetInternal@RuleBasedTimeZone@icu_56@@ABEXNCHHAAH0AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2984h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedTimeZone::setRawOffset(icu_56::RuleBasedTimeZone *this, int)
		public ?setRawOffset@RuleBasedTimeZone@icu_56@@UAEXH@Z
?setRawOffset@RuleBasedTimeZone@icu_56@@UAEXH@Z	proc near ; DATA XREF: .rdata:000009A0o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setRawOffset@RuleBasedTimeZone@icu_56@@UAEXH@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedTimeZone::getRawOffset(icu_56::RuleBasedTimeZone *__hidden this)
		public ?getRawOffset@RuleBasedTimeZone@icu_56@@UBEHXZ
?getRawOffset@RuleBasedTimeZone@icu_56@@UBEHXZ proc near ; DATA	XREF: .rdata:000009A4o

var_104		= qword	ptr -104h
var_F0		= byte ptr -0F0h
var_2C		= byte ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	esi, esp
		lea	eax, [ebp+var_14]
		push	eax
		lea	ecx, [ebp+var_2C]
		push	ecx
		lea	edx, [ebp+var_20]
		push	edx
		push	0
		call	_uprv_getUTCtime_56
		fmul	ds:__real@408f400000000000
		sub	esp, 8
		fstp	[esp+104h+var_104]
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_20]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getRawOffset@RuleBasedTimeZone@icu_56@@UBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN7_1		dd 3			; DATA XREF: icu_56::RuleBasedTimeZone::getRawOffset(void)+66o
		dd offset $LN6_0
$LN6_0		dd 0FFFFFFECh, 4	; DATA XREF: .text:00002A3Co
		dd offset $LN3		; "status"
		dd 0FFFFFFE0h, 4
		dd offset $LN4
		dd 0FFFFFFD4h, 4
		dd offset $LN5_0
$LN5_0		dd 747364h		; DATA XREF: .text:00002A60o
$LN4		dd 776172h		; DATA XREF: .text:00002A54o
$LN3		db 'status',0           ; DATA XREF: .text:00002A48o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2A74h
		public __real@408f400000000000
__real@408f400000000000	dq 1000.0	; DATA XREF: icu_56::RuleBasedTimeZone::getRawOffset(void)+3Fr
					; icu_56::RuleBasedTimeZone::useDaylightTime(void)+2Fr
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleBasedTimeZone::useDaylightTime(icu_56::RuleBasedTimeZone	*__hidden this)
		public ?useDaylightTime@RuleBasedTimeZone@icu_56@@UBECXZ
?useDaylightTime@RuleBasedTimeZone@icu_56@@UBECXZ proc near ; DATA XREF: .rdata:000009A8o

var_158		= qword	ptr -158h
var_134		= byte ptr -134h
var_6D		= byte ptr -6Dh
var_64		= dword	ptr -64h
var_58		= dword	ptr -58h
var_4C		= qword	ptr -4Ch
var_3C		= dword	ptr -3Ch
var_30		= byte ptr -30h
var_24		= qword	ptr -24h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 134h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_134]
		mov	ecx, 4Dh ; 'M'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		call	_uprv_getUTCtime_56
		fmul	ds:__real@408f400000000000
		fstp	[ebp+var_24]
		mov	esi, esp
		lea	eax, [ebp+var_14]
		push	eax
		lea	ecx, [ebp+var_3C]
		push	ecx
		lea	edx, [ebp+var_30]
		push	edx
		push	0
		sub	esp, 8
		fld	[ebp+var_24]
		fstp	[esp+158h+var_158]
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_3C], 0
		jz	short loc_2AEB
		mov	al, 1
		jmp	short loc_2B27
; ---------------------------------------------------------------------------

loc_2AEB:				; CODE XREF: icu_56::RuleBasedTimeZone::useDaylightTime(void)+69j
		lea	eax, [ebp+var_64]
		push	eax		; struct icu_56::TimeZoneRule **
		lea	ecx, [ebp+var_58]
		push	ecx		; struct icu_56::TimeZoneRule **
		lea	edx, [ebp+var_4C]
		push	edx		; double *
		push	0		; char
		sub	esp, 8
		fld	[ebp+var_24]
		fstp	[esp+158h+var_158] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?findNext@RuleBasedTimeZone@icu_56@@ABECNCAANAAPAVTimeZoneRule@2@1@Z ; icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)
		mov	[ebp+var_6D], al
		movsx	eax, [ebp+var_6D]
		test	eax, eax
		jz	short loc_2B25
		mov	ecx, [ebp+var_64] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		test	eax, eax
		jz	short loc_2B25
		mov	al, 1
		jmp	short loc_2B27
; ---------------------------------------------------------------------------

loc_2B25:				; CODE XREF: icu_56::RuleBasedTimeZone::useDaylightTime(void)+97j
					; icu_56::RuleBasedTimeZone::useDaylightTime(void)+A3j
		xor	al, al

loc_2B27:				; CODE XREF: icu_56::RuleBasedTimeZone::useDaylightTime(void)+6Dj
					; icu_56::RuleBasedTimeZone::useDaylightTime(void)+A7j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 134h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?useDaylightTime@RuleBasedTimeZone@icu_56@@UBECXZ endp

; ---------------------------------------------------------------------------
$LN12		dd 6			; DATA XREF: icu_56::RuleBasedTimeZone::useDaylightTime(void)+AFo
		dd offset $LN11
$LN11		dd 0FFFFFFECh, 4	; DATA XREF: .text:00002B50o
		dd offset $LN5_1	; "status"
		dd 0FFFFFFD0h, 4
		dd offset $LN6_1	; "raw"
		dd 0FFFFFFC4h, 4
		dd offset $LN7_2	; "dst"
		dd 0FFFFFFB4h, 8
		dd offset $LN8_1	; "time"
		dd 0FFFFFFA8h, 4
		dd offset $LN9_0	; "from"
		dd 0FFFFFF9Ch, 4
		dd offset $LN10
$LN10		db 74h,	6Fh, 0		; DATA XREF: .text:00002B98o
$LN9_0		db 'from',0             ; DATA XREF: .text:00002B8Co
$LN8_1		db 'time',0             ; DATA XREF: .text:00002B80o
$LN7_2		db 'dst',0              ; DATA XREF: .text:00002B74o
$LN6_1		db 'raw',0              ; DATA XREF: .text:00002B68o
$LN5_1		db 'status',0           ; DATA XREF: .text:00002B5Co
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleBasedTimeZone::inDaylightTime(icu_56::RuleBasedTimeZone *this, double, enum UErrorCode *)
		public ?inDaylightTime@RuleBasedTimeZone@icu_56@@UBECNAAW4UErrorCode@@@Z
?inDaylightTime@RuleBasedTimeZone@icu_56@@UBECNAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:000009ACo

var_108		= qword	ptr -108h
var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2BF4
		xor	al, al
		jmp	short loc_2C2D
; ---------------------------------------------------------------------------

loc_2BF4:				; CODE XREF: icu_56::RuleBasedTimeZone::inDaylightTime(double,UErrorCode &)+36j
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_20]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		push	0
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+108h+var_108]
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_20], 0
		jz	short loc_2C2B
		mov	al, 1
		jmp	short loc_2C2D
; ---------------------------------------------------------------------------

loc_2C2B:				; CODE XREF: icu_56::RuleBasedTimeZone::inDaylightTime(double,UErrorCode &)+6Dj
		xor	al, al

loc_2C2D:				; CODE XREF: icu_56::RuleBasedTimeZone::inDaylightTime(double,UErrorCode &)+3Aj
					; icu_56::RuleBasedTimeZone::inDaylightTime(double,UErrorCode &)+71j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?inDaylightTime@RuleBasedTimeZone@icu_56@@UBECNAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN8_2		dd 2			; DATA XREF: icu_56::RuleBasedTimeZone::inDaylightTime(double,UErrorCode &)+79o
		dd offset $LN7_3
$LN7_3		dd 0FFFFFFECh, 4	; DATA XREF: .text:00002C58o
		dd offset $LN5_2
		dd 0FFFFFFE0h, 4
		dd offset $LN6_2
$LN6_2		dd 747364h		; DATA XREF: .text:00002C70o
; ---------------------------------------------------------------------------

$LN5_2:					; DATA XREF: .text:00002C64o
		jb	short loc_2CDB
		ja	short $+2	; icu_56::RuleBasedTimeZone::hasSameRules(icu_56::TimeZone const &)
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleBasedTimeZone::hasSameRules(icu_56::RuleBasedTimeZone *this, const struct icu_56::TimeZone *)
		public ?hasSameRules@RuleBasedTimeZone@icu_56@@UBECABVTimeZone@2@@Z
?hasSameRules@RuleBasedTimeZone@icu_56@@UBECABVTimeZone@2@@Z proc near
					; CODE XREF: .text:00002C7Aj
					; DATA XREF: .rdata:000009B0o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_2CAE
		mov	al, 1
		jmp	loc_2D57
; ---------------------------------------------------------------------------

loc_2CAE:				; CODE XREF: icu_56::RuleBasedTimeZone::hasSameRules(icu_56::TimeZone const &)+29j
		mov	eax, [ebp+arg_0]
		push	eax
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??9type_info@@QBE_NABV0@@Z ;	type_info::operator!=(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, al

loc_2CDB:				; CODE XREF: .text:$LN5_2j
		test	edx, edx
		jz	short loc_2CE3
		xor	al, al
		jmp	short loc_2D57
; ---------------------------------------------------------------------------

loc_2CE3:				; CODE XREF: icu_56::RuleBasedTimeZone::hasSameRules(icu_56::TimeZone const &)+61j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+44h]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+44h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+44h]
		mov	edx, [eax]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_2D17
		xor	al, al
		jmp	short loc_2D57
; ---------------------------------------------------------------------------

loc_2D17:				; CODE XREF: icu_56::RuleBasedTimeZone::hasSameRules(icu_56::TimeZone const &)+95j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		push	ecx		; icu_56::UVector *
		mov	edx, [ebp+var_8]
		mov	eax, [edx+48h]
		push	eax		; icu_56::UVector *
		call	?compareRules@icu_56@@YACPAVUVector@1@0@Z ; icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_2D55
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4Ch]
		push	ecx		; icu_56::UVector *
		mov	edx, [ebp+var_8]
		mov	eax, [edx+4Ch]
		push	eax		; icu_56::UVector *
		call	?compareRules@icu_56@@YACPAVUVector@1@0@Z ; icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_2D55
		mov	al, 1
		jmp	short loc_2D57
; ---------------------------------------------------------------------------

loc_2D55:				; CODE XREF: icu_56::RuleBasedTimeZone::hasSameRules(icu_56::TimeZone const &)+B6j
					; icu_56::RuleBasedTimeZone::hasSameRules(icu_56::TimeZone const &)+D3j
		xor	al, al

loc_2D57:				; CODE XREF: icu_56::RuleBasedTimeZone::hasSameRules(icu_56::TimeZone const &)+2Dj
					; icu_56::RuleBasedTimeZone::hasSameRules(icu_56::TimeZone const &)+65j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?hasSameRules@RuleBasedTimeZone@icu_56@@UBECABVTimeZone@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleBasedTimeZone::getNextTransition(icu_56::RuleBasedTimeZone *this, double, char, struct icu_56::TimeZoneTransition *)
		public ?getNextTransition@RuleBasedTimeZone@icu_56@@UBECNCAAVTimeZoneTransition@2@@Z
?getNextTransition@RuleBasedTimeZone@icu_56@@UBECNCAAVTimeZoneTransition@2@@Z proc near
					; DATA XREF: .rdata:000009BCo

var_130		= qword	ptr -130h
var_120		= qword	ptr -120h
var_10C		= byte ptr -10Ch
var_45		= byte ptr -45h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= qword	ptr -24h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?completeConst@RuleBasedTimeZone@icu_56@@ABEXAAW4UErrorCode@@@Z	; icu_56::RuleBasedTimeZone::completeConst(UErrorCode &)
		mov	eax, [ebp+var_14]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_2DBD
		xor	al, al
		jmp	short loc_2E19
; ---------------------------------------------------------------------------

loc_2DBD:				; CODE XREF: icu_56::RuleBasedTimeZone::getNextTransition(double,signed	char,icu_56::TimeZoneTransition	&)+47j
		lea	eax, [ebp+var_3C]
		push	eax		; struct icu_56::TimeZoneRule **
		lea	ecx, [ebp+var_30]
		push	ecx		; struct icu_56::TimeZoneRule **
		lea	edx, [ebp+var_24]
		push	edx		; double *
		movzx	eax, [ebp+arg_8]
		push	eax		; char
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+130h+var_130] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?findNext@RuleBasedTimeZone@icu_56@@ABECNCAANAAPAVTimeZoneRule@2@1@Z ; icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)
		mov	[ebp+var_45], al
		movsx	eax, [ebp+var_45]
		test	eax, eax
		jz	short loc_2E17
		sub	esp, 8
		fld	[ebp+var_24]
		fstp	[esp+120h+var_120] ; double
		mov	ecx, [ebp+arg_C] ; this
		call	?setTime@TimeZoneTransition@icu_56@@QAEXN@Z ; icu_56::TimeZoneTransition::setTime(double)
		mov	eax, [ebp+var_30]
		push	eax		; struct icu_56::TimeZoneRule *
		mov	ecx, [ebp+arg_C] ; this
		call	?setFrom@TimeZoneTransition@icu_56@@QAEXABVTimeZoneRule@2@@Z ; icu_56::TimeZoneTransition::setFrom(icu_56::TimeZoneRule	const &)
		mov	eax, [ebp+var_3C]
		push	eax		; struct icu_56::TimeZoneRule *
		mov	ecx, [ebp+arg_C] ; this
		call	?setTo@TimeZoneTransition@icu_56@@QAEXABVTimeZoneRule@2@@Z ; icu_56::TimeZoneTransition::setTo(icu_56::TimeZoneRule const &)
		mov	al, 1
		jmp	short loc_2E19
; ---------------------------------------------------------------------------

loc_2E17:				; CODE XREF: icu_56::RuleBasedTimeZone::getNextTransition(double,signed	char,icu_56::TimeZoneTransition	&)+78j
		xor	al, al

loc_2E19:				; CODE XREF: icu_56::RuleBasedTimeZone::getNextTransition(double,signed	char,icu_56::TimeZoneTransition	&)+4Bj
					; icu_56::RuleBasedTimeZone::getNextTransition(double,signed char,icu_56::TimeZoneTransition &)+A5j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?getNextTransition@RuleBasedTimeZone@icu_56@@UBECNCAAVTimeZoneTransition@2@@Z endp

; ---------------------------------------------------------------------------
$LN10_0		dd 4			; DATA XREF: icu_56::RuleBasedTimeZone::getNextTransition(double,signed	char,icu_56::TimeZoneTransition	&)+ADo
		dd offset $LN9_1
$LN9_1		dd 0FFFFFFECh, 4	; DATA XREF: .text:00002E44o
		dd offset $LN5_3	; "status"
		dd 0FFFFFFDCh, 8
		dd offset $LN6_3	; "transitionTime"
		dd 0FFFFFFD0h, 4
		dd offset $LN7_4	; "fromRule"
		dd 0FFFFFFC4h, 4
		dd offset $LN8_3	; "toRule"
$LN8_3		db 'toRule',0           ; DATA XREF: .text:00002E74o
$LN7_4		db 'fromRule',0         ; DATA XREF: .text:00002E68o
$LN6_3		db 'transitionTime',0   ; DATA XREF: .text:00002E5Co
$LN5_3		db 'status',0           ; DATA XREF: .text:00002E50o
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2EA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleBasedTimeZone::getPreviousTransition(icu_56::RuleBasedTimeZone *this, double, char, struct icu_56::TimeZoneTransition *)
		public ?getPreviousTransition@RuleBasedTimeZone@icu_56@@UBECNCAAVTimeZoneTransition@2@@Z
?getPreviousTransition@RuleBasedTimeZone@icu_56@@UBECNCAAVTimeZoneTransition@2@@Z proc near
					; DATA XREF: .rdata:000009C0o

var_130		= qword	ptr -130h
var_120		= qword	ptr -120h
var_10C		= byte ptr -10Ch
var_45		= byte ptr -45h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= qword	ptr -24h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?completeConst@RuleBasedTimeZone@icu_56@@ABEXAAW4UErrorCode@@@Z	; icu_56::RuleBasedTimeZone::completeConst(UErrorCode &)
		mov	eax, [ebp+var_14]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_2EED
		xor	al, al
		jmp	short loc_2F49
; ---------------------------------------------------------------------------

loc_2EED:				; CODE XREF: icu_56::RuleBasedTimeZone::getPreviousTransition(double,signed char,icu_56::TimeZoneTransition &)+47j
		lea	eax, [ebp+var_3C]
		push	eax		; struct icu_56::TimeZoneRule **
		lea	ecx, [ebp+var_30]
		push	ecx		; struct icu_56::TimeZoneRule **
		lea	edx, [ebp+var_24]
		push	edx		; double *
		movzx	eax, [ebp+arg_8]
		push	eax		; char
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+130h+var_130] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?findPrev@RuleBasedTimeZone@icu_56@@ABECNCAANAAPAVTimeZoneRule@2@1@Z ; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)
		mov	[ebp+var_45], al
		movsx	eax, [ebp+var_45]
		test	eax, eax
		jz	short loc_2F47
		sub	esp, 8
		fld	[ebp+var_24]
		fstp	[esp+120h+var_120] ; double
		mov	ecx, [ebp+arg_C] ; this
		call	?setTime@TimeZoneTransition@icu_56@@QAEXN@Z ; icu_56::TimeZoneTransition::setTime(double)
		mov	eax, [ebp+var_30]
		push	eax		; struct icu_56::TimeZoneRule *
		mov	ecx, [ebp+arg_C] ; this
		call	?setFrom@TimeZoneTransition@icu_56@@QAEXABVTimeZoneRule@2@@Z ; icu_56::TimeZoneTransition::setFrom(icu_56::TimeZoneRule	const &)
		mov	eax, [ebp+var_3C]
		push	eax		; struct icu_56::TimeZoneRule *
		mov	ecx, [ebp+arg_C] ; this
		call	?setTo@TimeZoneTransition@icu_56@@QAEXABVTimeZoneRule@2@@Z ; icu_56::TimeZoneTransition::setTo(icu_56::TimeZoneRule const &)
		mov	al, 1
		jmp	short loc_2F49
; ---------------------------------------------------------------------------

loc_2F47:				; CODE XREF: icu_56::RuleBasedTimeZone::getPreviousTransition(double,signed char,icu_56::TimeZoneTransition &)+78j
		xor	al, al

loc_2F49:				; CODE XREF: icu_56::RuleBasedTimeZone::getPreviousTransition(double,signed char,icu_56::TimeZoneTransition &)+4Bj
					; icu_56::RuleBasedTimeZone::getPreviousTransition(double,signed char,icu_56::TimeZoneTransition &)+A5j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?getPreviousTransition@RuleBasedTimeZone@icu_56@@UBECNCAAVTimeZoneTransition@2@@Z endp

; ---------------------------------------------------------------------------
$LN10_1		dd 4			; DATA XREF: icu_56::RuleBasedTimeZone::getPreviousTransition(double,signed char,icu_56::TimeZoneTransition &)+ADo
		dd offset $LN9_2
$LN9_2		dd 0FFFFFFECh, 4	; DATA XREF: .text:00002F74o
		dd offset $LN5_4	; "status"
		dd 0FFFFFFDCh, 8
		dd offset $LN6_4	; "transitionTime"
		dd 0FFFFFFD0h, 4
		dd offset $LN7_5	; "fromRule"
		dd 0FFFFFFC4h, 4
		dd offset $LN8_4	; "toRule"
$LN8_4		db 'toRule',0           ; DATA XREF: .text:00002FA4o
$LN7_5		db 'fromRule',0         ; DATA XREF: .text:00002F98o
$LN6_4		db 'transitionTime',0   ; DATA XREF: .text:00002F8Co
$LN5_4		db 'status',0           ; DATA XREF: .text:00002F80o
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedTimeZone::countTransitionRules(icu_56::RuleBasedTimeZone *this, enum UErrorCode *)
		public ?countTransitionRules@RuleBasedTimeZone@icu_56@@UBEHAAW4UErrorCode@@@Z
?countTransitionRules@RuleBasedTimeZone@icu_56@@UBEHAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:000009C8o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]

loc_2FFD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		cmp	dword ptr [eax+48h], 0
		jz	short loc_301E
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, [ebp+var_14]
		mov	[ebp+var_14], eax

loc_301E:				; CODE XREF: icu_56::RuleBasedTimeZone::countTransitionRules(UErrorCode	&)+31j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0
		jz	short loc_3042
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, [ebp+var_14]
		mov	[ebp+var_14], eax

loc_3042:				; CODE XREF: icu_56::RuleBasedTimeZone::countTransitionRules(UErrorCode	&)+55j
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?countTransitionRules@RuleBasedTimeZone@icu_56@@UBEHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 305Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedTimeZone::getTimeZoneRules(icu_56::RuleBasedTimeZone	*this, const struct icu_56::InitialTimeZoneRule	**, const struct icu_56::TimeZoneRule **const ,	int *, enum UErrorCode *)
		public ?getTimeZoneRules@RuleBasedTimeZone@icu_56@@UBEXAAPBVInitialTimeZoneRule@2@QAPBVTimeZoneRule@2@AAHAAW4UErrorCode@@@Z
?getTimeZoneRules@RuleBasedTimeZone@icu_56@@UBEXAAPBVInitialTimeZoneRule@2@QAPBVTimeZoneRule@2@AAHAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:000009CCo

var_100		= dword	ptr -100h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3099
		jmp	loc_31BF
; ---------------------------------------------------------------------------

loc_3099:				; CODE XREF: icu_56::RuleBasedTimeZone::getTimeZoneRules(icu_56::InitialTimeZoneRule const * &,icu_56::TimeZoneRule const * * const,int	&,UErrorCode &)+36j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+44h]
		mov	[eax], edx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+48h], 0
		jz	short loc_3131
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax]
		jge	short loc_3131
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax
		mov	[ebp+var_20], 0

loc_30DD:				; CODE XREF: icu_56::RuleBasedTimeZone::getTimeZoneRules(icu_56::InitialTimeZoneRule const * &,icu_56::TimeZoneRule const * * const,int	&,UErrorCode &)+D3j
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax]
		jge	short loc_3131
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jge	short loc_3131
		mov	eax, [ebp+var_20]
		mov	[ebp+var_100], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	esi, esp
		mov	edx, [ebp+var_100]
		push	edx		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+arg_4]
		mov	[edx+ecx*4], eax
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_30DD
; ---------------------------------------------------------------------------

loc_3131:				; CODE XREF: icu_56::RuleBasedTimeZone::getTimeZoneRules(icu_56::InitialTimeZoneRule const * &,icu_56::TimeZoneRule const * * const,int	&,UErrorCode &)+56j
					; icu_56::RuleBasedTimeZone::getTimeZoneRules(icu_56::InitialTimeZoneRule const	* &,icu_56::TimeZoneRule const * * const,int &,UErrorCode &)+60j ...
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0
		jz	short loc_31B7
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax]
		jge	short loc_31B7
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_38], eax
		mov	[ebp+var_20], 0

loc_3163:				; CODE XREF: icu_56::RuleBasedTimeZone::getTimeZoneRules(icu_56::InitialTimeZoneRule const * &,icu_56::TimeZoneRule const * * const,int	&,UErrorCode &)+159j
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax]
		jge	short loc_31B7
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_38]
		jge	short loc_31B7
		mov	eax, [ebp+var_20]
		mov	[ebp+var_100], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	esi, esp
		mov	edx, [ebp+var_100]
		push	edx		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+arg_4]
		mov	[edx+ecx*4], eax
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_3163
; ---------------------------------------------------------------------------

loc_31B7:				; CODE XREF: icu_56::RuleBasedTimeZone::getTimeZoneRules(icu_56::InitialTimeZoneRule const * &,icu_56::TimeZoneRule const * * const,int	&,UErrorCode &)+DCj
					; icu_56::RuleBasedTimeZone::getTimeZoneRules(icu_56::InitialTimeZoneRule const	* &,icu_56::TimeZoneRule const * * const,int &,UErrorCode &)+E6j ...
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_31BF:				; CODE XREF: icu_56::RuleBasedTimeZone::getTimeZoneRules(icu_56::InitialTimeZoneRule const * &,icu_56::TimeZoneRule const * * const,int	&,UErrorCode &)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?getTimeZoneRules@RuleBasedTimeZone@icu_56@@UBEXAAPBVInitialTimeZoneRule@2@QAPBVTimeZoneRule@2@AAHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedTimeZone::deleteRules(icu_56::RuleBasedTimeZone *__hidden this)
		public ?deleteRules@RuleBasedTimeZone@icu_56@@AAEXXZ
?deleteRules@RuleBasedTimeZone@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::~RuleBasedTimeZone(void)+5Dp
					; icu_56::RuleBasedTimeZone::operator=(icu_56::RuleBasedTimeZone const &)+53p

var_148		= dword	ptr -148h
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 148h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_148]
		mov	ecx, 52h ; 'R'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+44h]
		mov	[ebp+var_134], ecx
		mov	edx, [ebp+var_134]
		mov	[ebp+var_140], edx
		cmp	[ebp+var_140], 0
		jz	short loc_3241
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_140]
		mov	edx, [eax]
		mov	ecx, [ebp+var_140]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_148], eax
		jmp	short loc_324B
; ---------------------------------------------------------------------------

loc_3241:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+42j
		mov	[ebp+var_148], 0

loc_324B:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+67j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+44h], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+48h], 0
		jz	loc_333B

loc_3262:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void):loc_32DFj
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]	; this
		call	dword ptr ds:__imp_?isEmpty@UVector@icu_56@@QBECXZ ; icu_56::UVector::isEmpty(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_32E1
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]	; this
		call	dword ptr ds:__imp_?orphanElementAt@UVector@icu_56@@QAEPAXH@Z ;	icu_56::UVector::orphanElementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11C], eax
		mov	ecx, [ebp+var_11C]
		mov	[ebp+var_128], ecx
		cmp	[ebp+var_128], 0
		jz	short loc_32D5
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_128]
		mov	eax, [edx]
		mov	ecx, [ebp+var_128]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_148], eax
		jmp	short loc_32DF
; ---------------------------------------------------------------------------

loc_32D5:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+D6j
		mov	[ebp+var_148], 0

loc_32DF:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+FBj
		jmp	short loc_3262
; ---------------------------------------------------------------------------

loc_32E1:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+A4j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]
		mov	[ebp+var_104], ecx
		mov	edx, [ebp+var_104]
		mov	[ebp+var_110], edx
		cmp	[ebp+var_110], 0
		jz	short loc_3327
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_110]
		mov	edx, [eax]
		mov	ecx, [ebp+var_110]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_148], eax
		jmp	short loc_3331
; ---------------------------------------------------------------------------

loc_3327:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+128j
		mov	[ebp+var_148], 0

loc_3331:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+14Dj
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+48h], 0

loc_333B:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+84j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0
		jz	loc_3421

loc_3348:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void):loc_33C5j
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?isEmpty@UVector@icu_56@@QBECXZ ; icu_56::UVector::isEmpty(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_33C7
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?orphanElementAt@UVector@icu_56@@QAEPAXH@Z ;	icu_56::UVector::orphanElementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_EC], eax
		mov	ecx, [ebp+var_EC]
		mov	[ebp+var_F8], ecx
		cmp	[ebp+var_F8], 0
		jz	short loc_33BB
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_F8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_F8]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_148], eax
		jmp	short loc_33C5
; ---------------------------------------------------------------------------

loc_33BB:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+1BCj
		mov	[ebp+var_148], 0

loc_33C5:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+1E1j
		jmp	short loc_3348
; ---------------------------------------------------------------------------

loc_33C7:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+18Aj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]
		mov	[ebp+var_D4], ecx
		mov	edx, [ebp+var_D4]
		mov	[ebp+var_E0], edx
		cmp	[ebp+var_E0], 0
		jz	short loc_340D
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_E0]
		mov	edx, [eax]
		mov	ecx, [ebp+var_E0]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_148], eax
		jmp	short loc_3417
; ---------------------------------------------------------------------------

loc_340D:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+20Ej
		mov	[ebp+var_148], 0

loc_3417:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+233j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4Ch], 0

loc_3421:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+16Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 148h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?deleteRules@RuleBasedTimeZone@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3438h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedTimeZone::deleteTransitions(icu_56::RuleBasedTimeZone *__hidden this)
		public ?deleteTransitions@RuleBasedTimeZone@icu_56@@AAEXXZ
?deleteTransitions@RuleBasedTimeZone@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::~RuleBasedTimeZone(void)+55p
					; icu_56::RuleBasedTimeZone::operator=(icu_56::RuleBasedTimeZone const &)+A9p ...

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+50h], 0
		jz	loc_34FC

loc_3468:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteTransitions(void)+72j
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]	; this
		call	dword ptr ds:__imp_?isEmpty@UVector@icu_56@@QBECXZ ; icu_56::UVector::isEmpty(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_34AC
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]	; this
		call	dword ptr ds:__imp_?orphanElementAt@UVector@icu_56@@QAEPAXH@Z ;	icu_56::UVector::orphanElementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		jmp	short loc_3468
; ---------------------------------------------------------------------------

loc_34AC:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteTransitions(void)+4Aj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_34F2
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_34FC
; ---------------------------------------------------------------------------

loc_34F2:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteTransitions(void)+93j
		mov	[ebp+var_F4], 0

loc_34FC:				; CODE XREF: icu_56::RuleBasedTimeZone::deleteTransitions(void)+2Aj
					; icu_56::RuleBasedTimeZone::deleteTransitions(void)+B8j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+50h], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?deleteTransitions@RuleBasedTimeZone@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 351Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UVector *__thiscall icu_56::RuleBasedTimeZone::copyRules(icu_56::RuleBasedTimeZone *this, struct icu_56::UVector *)
		public ?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z
?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone const &)+9Dp
					; icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone const &)+B2p ...

var_160		= dword	ptr -160h
var_158		= dword	ptr -158h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 154h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_160]
		mov	ecx, 55h ; 'U'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax		; enum UErrorCode *
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		cmp	[ebp+arg_0], 0
		jnz	short loc_356B
		xor	eax, eax
		jmp	loc_37A7
; ---------------------------------------------------------------------------

loc_356B:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+46j
		mov	[ebp+var_20], 0
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax
		mov	esi, esp
		push	18h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14C], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_14C], 0
		jz	short loc_35E8
		mov	esi, esp
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_2C]
		push	ecx		; int
		mov	ecx, [ebp+var_14C] ; this
		call	dword ptr ds:__imp_??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z ;	icu_56::UVector::UVector(int,UErrorCode	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_14C]
		mov	dword ptr [edx], offset	??_SUVector@icu_56@@6B@	; const	icu_56::UVector::`local	vftable'
		mov	eax, [ebp+var_14C]
		mov	[ebp+var_160], eax
		jmp	short loc_35F2
; ---------------------------------------------------------------------------

loc_35E8:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+93j
		mov	[ebp+var_160], 0

loc_35F2:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+CAj
		mov	ecx, [ebp+var_160]
		mov	[ebp+var_158], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_158]
		mov	[ebp+var_38], edx
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_3628
		xor	eax, eax
		jmp	loc_37A7
; ---------------------------------------------------------------------------

loc_3628:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+103j
		mov	[ebp+var_44], 0
		jmp	short loc_363A
; ---------------------------------------------------------------------------

loc_3631:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *):loc_36A6j
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax

loc_363A:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+113j
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_2C]
		jge	short loc_36A8
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_160], eax
		mov	esi, esp
		lea	ecx, [ebp+var_20]
		push	ecx		; enum UErrorCode *
		mov	edi, esp
		mov	edx, [ebp+var_160]
		mov	eax, [edx]
		mov	ecx, [ebp+var_160]
		mov	edx, [eax+8]
		call	edx
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax		; void *
		mov	ecx, [ebp+var_38] ; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_36A6
		jmp	short loc_36A8
; ---------------------------------------------------------------------------

loc_36A6:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+186j
		jmp	short loc_3631
; ---------------------------------------------------------------------------

loc_36A8:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+124j
					; icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+188j
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_37A4
		mov	[ebp+var_44], 0
		jmp	short loc_36D1
; ---------------------------------------------------------------------------

loc_36C8:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *):loc_374Ej
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax

loc_36D1:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+1AAj
		mov	esi, esp
		mov	ecx, [ebp+var_38] ; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_44], eax
		jge	short loc_3753
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax		; int
		mov	ecx, [ebp+var_38] ; this
		call	dword ptr ds:__imp_?orphanElementAt@UVector@icu_56@@QAEPAXH@Z ;	icu_56::UVector::orphanElementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_50]
		mov	[ebp+var_134], eax
		mov	ecx, [ebp+var_134]
		mov	[ebp+var_140], ecx
		cmp	[ebp+var_140], 0
		jz	short loc_3744
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_140]
		mov	eax, [edx]
		mov	ecx, [ebp+var_140]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_160], eax
		jmp	short loc_374E
; ---------------------------------------------------------------------------

loc_3744:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+201j
		mov	[ebp+var_160], 0

loc_374E:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+226j
		jmp	loc_36C8
; ---------------------------------------------------------------------------

loc_3753:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+1CAj
		mov	eax, [ebp+var_38]
		mov	[ebp+var_11C], eax
		mov	ecx, [ebp+var_11C]
		mov	[ebp+var_128], ecx
		cmp	[ebp+var_128], 0
		jz	short loc_3796
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_128]
		mov	eax, [edx]
		mov	ecx, [ebp+var_128]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_160], eax
		jmp	short loc_37A0
; ---------------------------------------------------------------------------

loc_3796:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+253j
		mov	[ebp+var_160], 0

loc_37A0:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+278j
		xor	eax, eax
		jmp	short loc_37A7
; ---------------------------------------------------------------------------

loc_37A4:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+19Dj
		mov	eax, [ebp+var_38]

loc_37A7:				; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+4Aj
					; icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+107j	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN23
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 160h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN23		dd 1			; DATA XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+28Fo
		dd offset $LN22
$LN22		dd 0FFFFFFE0h, 4	; DATA XREF: .text:000037E0o
		dd offset $LN20
$LN20		db 65h,	63h, 0		; DATA XREF: .text:000037ECo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 37F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z$0	proc near
					; DATA XREF: .xdata$x:00003830o
		mov	esi, esp
		mov	eax, [ebp-14Ch]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z proc near
					; DATA XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-164h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 382Ch
__unwindtable$?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000383Co
		dd offset __unwindfunclet$?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z$0
__ehfuncinfo$?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z+14o
		dd offset __unwindtable$?copyRules@RuleBasedTimeZone@icu_56@@AAEPAVUVector@2@PAV32@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3858h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::TimeZoneRule *__thiscall icu_56::RuleBasedTimeZone::findRuleInFinal(icu_56::RuleBasedTimeZone *this, double, char, int, int)
		public ?findRuleInFinal@RuleBasedTimeZone@icu_56@@ABEPAVTimeZoneRule@2@NCHH@Z
?findRuleInFinal@RuleBasedTimeZone@icu_56@@ABEPAVTimeZoneRule@2@NCHH@Z proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+14Dp

var_160		= qword	ptr -160h
var_13C		= dword	ptr -13Ch
var_71		= byte ptr -71h
var_65		= byte ptr -65h
var_5C		= dword	ptr -5Ch
var_50		= qword	ptr -50h
var_40		= qword	ptr -40h
var_30		= qword	ptr -30h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 13Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Fh ; 'O'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0
		jnz	short loc_388B
		xor	eax, eax
		jmp	loc_3A39
; ---------------------------------------------------------------------------

loc_388B:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+2Aj
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	esi, esp
		push	1		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		cmp	[ebp+var_14], 0
		jz	short loc_38CB
		cmp	[ebp+var_20], 0
		jnz	short loc_38D2

loc_38CB:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+6Bj
		xor	eax, eax
		jmp	loc_3A39
; ---------------------------------------------------------------------------

loc_38D2:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+71j
		fld	[ebp+arg_0]
		fstp	[ebp+var_50]
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_3920
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+var_14] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax		; int
		mov	ecx, [ebp+var_14] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax		; int
		mov	ecx, [ebp+var_20] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax		; int
		mov	ecx, [ebp+var_20] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getLocalDelta@RuleBasedTimeZone@icu_56@@ABEHHHHHHH@Z ;	icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)
		mov	[ebp+var_5C], eax
		fild	[ebp+var_5C]
		fsubr	[ebp+var_50]
		fstp	[ebp+var_50]

loc_3920:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+86j
		mov	esi, esp
		lea	eax, [ebp+var_30]
		push	eax
		push	1
		mov	ecx, [ebp+var_20] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax
		mov	ecx, [ebp+var_20] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax
		sub	esp, 8
		fld	[ebp+var_50]
		fstp	[esp+160h+var_160]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_65], al
		fld	[ebp+arg_0]
		fstp	[ebp+var_50]
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_39A8
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+var_20] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax		; int
		mov	ecx, [ebp+var_20] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax		; int
		mov	ecx, [ebp+var_14] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax		; int
		mov	ecx, [ebp+var_14] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getLocalDelta@RuleBasedTimeZone@icu_56@@ABEHHHHHHH@Z ;	icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)
		mov	[ebp+var_5C], eax
		fild	[ebp+var_5C]
		fsubr	[ebp+var_50]
		fstp	[ebp+var_50]

loc_39A8:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+10Ej
		mov	esi, esp
		lea	eax, [ebp+var_40]
		push	eax
		push	1
		mov	ecx, [ebp+var_14] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax
		mov	ecx, [ebp+var_14] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax
		sub	esp, 8
		fld	[ebp+var_50]
		fstp	[esp+160h+var_160]
		mov	ecx, [ebp+var_20]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_20]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_71], al
		movsx	eax, [ebp+var_65]
		test	eax, eax
		jz	short loc_39F2
		movsx	eax, [ebp+var_71]
		test	eax, eax
		jnz	short loc_3A12

loc_39F2:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+190j
		movsx	eax, [ebp+var_65]
		test	eax, eax
		jz	short loc_3A01
		mov	eax, [ebp+var_14]
		jmp	short loc_3A39
; ---------------------------------------------------------------------------
		jmp	short loc_3A0E
; ---------------------------------------------------------------------------

loc_3A01:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+1A0j
		movsx	eax, [ebp+var_71]
		test	eax, eax
		jz	short loc_3A0E
		mov	eax, [ebp+var_20]
		jmp	short loc_3A39
; ---------------------------------------------------------------------------

loc_3A0E:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+1A7j
					; icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+1AFj
		xor	eax, eax
		jmp	short loc_3A39
; ---------------------------------------------------------------------------

loc_3A12:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+198j
		fld	[ebp+var_40]
		fcomp	[ebp+var_30]
		fnstsw	ax
		test	ah, 5
		jp	short loc_3A2A
		mov	eax, [ebp+var_14]
		mov	[ebp+var_13C], eax
		jmp	short loc_3A33
; ---------------------------------------------------------------------------

loc_3A2A:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+1C5j
		mov	ecx, [ebp+var_20]
		mov	[ebp+var_13C], ecx

loc_3A33:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+1D0j
		mov	eax, [ebp+var_13C]

loc_3A39:				; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+2Ej
					; icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+75j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN18
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?findRuleInFinal@RuleBasedTimeZone@icu_56@@ABEPAVTimeZoneRule@2@NCHH@Z endp

; ---------------------------------------------------------------------------
$LN18		dd 2			; DATA XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+1E5o
		dd offset $LN17
$LN17		dd 0FFFFFFD0h, 8	; DATA XREF: .text:00003A64o
		dd offset $LN15		; "start0"
		dd 0FFFFFFC0h, 8
		dd offset $LN16		; "start1"
$LN16		db 'start1',0           ; DATA XREF: .text:00003A7Co
$LN15		db 'start0',0           ; DATA XREF: .text:00003A70o
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleBasedTimeZone::findNext(icu_56::RuleBasedTimeZone *this,	double,	char, double *,	struct icu_56::TimeZoneRule **,	struct icu_56::TimeZoneRule **)
		public ?findNext@RuleBasedTimeZone@icu_56@@ABECNCAANAAPAVTimeZoneRule@2@1@Z
?findNext@RuleBasedTimeZone@icu_56@@ABECNCAANAAPAVTimeZoneRule@2@1@Z proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::useDaylightTime(void)+89p
					; icu_56::RuleBasedTimeZone::getNextTransition(double,signed char,icu_56::TimeZoneTransition &)+6Ap ...

var_1B0		= qword	ptr -1B0h
var_18C		= byte ptr -18Ch
var_185		= byte ptr -185h
var_BC		= dword	ptr -0BCh
var_AD		= byte ptr -0ADh
var_A1		= byte ptr -0A1h
var_98		= qword	ptr -98h
var_88		= qword	ptr -88h
var_78		= dword	ptr -78h
var_6C		= dword	ptr -6Ch
var_60		= dword	ptr -60h
var_54		= qword	ptr -54h
var_44		= dword	ptr -44h
var_38		= qword	ptr -38h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_1D		= byte ptr -1Dh
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_18C]
		mov	ecx, 63h ; 'c'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_185], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+50h], 0
		jnz	short loc_3ACA
		xor	al, al
		jmp	loc_3E71
; ---------------------------------------------------------------------------

loc_3ACA:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+31j
		mov	[ebp+var_11], 0
		mov	[ebp+var_1D], 0
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_44]
		fld	qword ptr [eax]
		fstp	[ebp+var_54]
		fld	[ebp+arg_0]
		fcomp	[ebp+var_54]
		fnstsw	ax
		test	ah, 5
		jnp	short loc_3B18
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_3B42
		fld	[ebp+var_54]
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_3B42

loc_3B18:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+6Fj
		mov	eax, [ebp+var_44]
		mov	[ebp+var_185], 1
		mov	ecx, [eax]
		mov	dword ptr [ebp+var_38],	ecx
		mov	edx, [eax+4]
		mov	dword ptr [ebp+var_38+4], edx
		mov	ecx, [eax+8]
		mov	[ebp+var_30], ecx
		mov	edx, [eax+0Ch]
		mov	[ebp+var_2C], edx
		mov	[ebp+var_1D], 1
		jmp	loc_3DC0
; ---------------------------------------------------------------------------

loc_3B42:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+77j
					; icu_56::RuleBasedTimeZone::findNext(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+86j
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, 1
		mov	[ebp+var_60], eax
		mov	esi, esp
		mov	eax, [ebp+var_60]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+50h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_44]
		fld	qword ptr [eax]
		fstp	[ebp+var_54]
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_3BC2
		fld	[ebp+var_54]
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_3BC2
		mov	eax, [ebp+var_44]
		mov	[ebp+var_185], 1
		mov	ecx, [eax]
		mov	dword ptr [ebp+var_38],	ecx
		mov	edx, [eax+4]
		mov	dword ptr [ebp+var_38+4], edx
		mov	ecx, [eax+8]
		mov	[ebp+var_30], ecx
		mov	edx, [eax+0Ch]
		mov	[ebp+var_2C], edx
		mov	[ebp+var_1D], 1
		jmp	loc_3DC0
; ---------------------------------------------------------------------------

loc_3BC2:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+F7j
					; icu_56::RuleBasedTimeZone::findNext(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+106j
		fld	[ebp+arg_0]
		fcomp	[ebp+var_54]
		fnstsw	ax
		test	ah, 1
		jnz	loc_3D1C
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0
		jz	loc_3D17
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_6C], eax
		mov	esi, esp
		push	1		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_78], eax
		mov	esi, esp
		lea	eax, [ebp+var_88]
		push	eax
		movzx	ecx, [ebp+arg_8]
		push	ecx
		mov	ecx, [ebp+var_78] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax
		mov	ecx, [ebp+var_78] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+1B0h+var_1B0]
		mov	edx, [ebp+var_6C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_6C]
		mov	edx, [eax+20h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_A1], al
		mov	esi, esp
		lea	eax, [ebp+var_98]
		push	eax
		movzx	ecx, [ebp+arg_8]
		push	ecx
		mov	ecx, [ebp+var_6C] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax
		mov	ecx, [ebp+var_6C] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+1B0h+var_1B0]
		mov	edx, [ebp+var_78]
		mov	eax, [edx]
		mov	ecx, [ebp+var_78]
		mov	edx, [eax+20h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_AD], al
		movsx	eax, [ebp+var_A1]
		test	eax, eax
		jnz	short loc_3CB7
		movsx	eax, [ebp+var_AD]
		test	eax, eax
		jnz	short loc_3CB7
		xor	al, al
		jmp	loc_3E71
; ---------------------------------------------------------------------------

loc_3CB7:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+213j
					; icu_56::RuleBasedTimeZone::findNext(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+21Ej
		movsx	eax, [ebp+var_AD]
		test	eax, eax
		jz	short loc_3CD5
		fld	[ebp+var_98]
		fcomp	[ebp+var_88]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_3CF3

loc_3CD5:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+230j
		mov	[ebp+var_185], 1
		fld	[ebp+var_88]
		fstp	[ebp+var_38]
		mov	eax, [ebp+var_78]
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_6C]
		mov	[ebp+var_2C], eax
		jmp	short loc_3D0F
; ---------------------------------------------------------------------------

loc_3CF3:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+243j
		mov	[ebp+var_185], 1
		fld	[ebp+var_98]
		fstp	[ebp+var_38]
		mov	eax, [ebp+var_6C]
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_78]
		mov	[ebp+var_2C], eax

loc_3D0F:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+261j
		mov	[ebp+var_11], 1
		mov	[ebp+var_1D], 1

loc_3D17:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+14Aj
		jmp	loc_3DC0
; ---------------------------------------------------------------------------

loc_3D1C:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+13Dj
		mov	eax, [ebp+var_60]
		sub	eax, 1
		mov	[ebp+var_60], eax
		mov	eax, [ebp+var_44]
		mov	[ebp+var_BC], eax

loc_3D2E:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+300j
		cmp	[ebp+var_60], 0
		jle	short loc_3D92
		mov	esi, esp
		mov	eax, [ebp+var_60]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+50h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_44]
		fld	qword ptr [eax]
		fstp	[ebp+var_54]
		fld	[ebp+arg_0]
		fcomp	[ebp+var_54]
		fnstsw	ax
		test	ah, 41h
		jz	short loc_3D7C
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jnz	short loc_3D7E
		fld	[ebp+var_54]
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_3D7E

loc_3D7C:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+2D3j
		jmp	short loc_3D92
; ---------------------------------------------------------------------------

loc_3D7E:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+2DBj
					; icu_56::RuleBasedTimeZone::findNext(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+2EAj
		mov	eax, [ebp+var_60]
		sub	eax, 1
		mov	[ebp+var_60], eax
		mov	eax, [ebp+var_44]
		mov	[ebp+var_BC], eax
		jmp	short loc_3D2E
; ---------------------------------------------------------------------------

loc_3D92:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+2A2j
					; icu_56::RuleBasedTimeZone::findNext(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &):loc_3D7Cj
		mov	[ebp+var_185], 1
		mov	eax, [ebp+var_BC]
		fld	qword ptr [eax]
		fstp	[ebp+var_38]
		mov	eax, [ebp+var_BC]
		mov	ecx, [eax+8]
		mov	[ebp+var_30], ecx
		mov	eax, [ebp+var_BC]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_2C], ecx
		mov	[ebp+var_1D], 1

loc_3DC0:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+ADj
					; icu_56::RuleBasedTimeZone::findNext(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+12Dj ...
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jz	loc_3E6F
		mov	ecx, [ebp+var_30] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		mov	esi, eax
		mov	ecx, [ebp+var_2C] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		cmp	esi, eax
		jnz	short loc_3E3D
		mov	ecx, [ebp+var_30] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		mov	esi, eax
		mov	ecx, [ebp+var_2C] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		cmp	esi, eax
		jnz	short loc_3E3D
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jz	short loc_3E06
		xor	al, al
		jmp	short loc_3E71
; ---------------------------------------------------------------------------
		jmp	short loc_3E3D
; ---------------------------------------------------------------------------

loc_3E06:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+36Ej
		cmp	[ebp+var_185], 0
		jnz	short loc_3E1C
		push	offset $LN25	; "result"
		call	__RTC_UninitUse
		add	esp, 4

loc_3E1C:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+37Dj
		mov	eax, [ebp+arg_14]
		push	eax		; struct icu_56::TimeZoneRule **
		mov	ecx, [ebp+arg_10]
		push	ecx		; struct icu_56::TimeZoneRule **
		mov	edx, [ebp+arg_C]
		push	edx		; double *
		push	0		; char
		sub	esp, 8
		fld	[ebp+var_38]
		fstp	[esp+1B0h+var_1B0] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?findNext@RuleBasedTimeZone@icu_56@@ABECNCAANAAPAVTimeZoneRule@2@1@Z ; icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)
		jmp	short loc_3E71
; ---------------------------------------------------------------------------

loc_3E3D:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+350j
					; icu_56::RuleBasedTimeZone::findNext(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+366j ...
		cmp	[ebp+var_185], 0
		jnz	short loc_3E53
		push	offset $LN25	; "result"
		call	__RTC_UninitUse
		add	esp, 4

loc_3E53:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+3B4j
		mov	eax, [ebp+arg_C]
		fld	[ebp+var_38]
		fstp	qword ptr [eax]
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+var_30]
		mov	[eax], ecx
		mov	eax, [ebp+arg_14]
		mov	ecx, [ebp+var_2C]
		mov	[eax], ecx
		mov	al, 1
		jmp	short loc_3E71
; ---------------------------------------------------------------------------

loc_3E6F:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+336j
		xor	al, al

loc_3E71:				; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+35j
					; icu_56::RuleBasedTimeZone::findNext(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+222j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN30
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 18Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?findNext@RuleBasedTimeZone@icu_56@@ABECNCAANAAPAVTimeZoneRule@2@1@Z endp

; ---------------------------------------------------------------------------
$LN30		dd 3			; DATA XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+3E5o
		dd offset $LN29
$LN29		dd 0FFFFFFC8h, 10h	; DATA XREF: .text:00003E9Co
		dd offset $LN25		; "result"
		dd 0FFFFFF78h, 8
		dd offset $LN27		; "start0"
		dd 0FFFFFF68h, 8
		dd offset $LN28		; "start1"
$LN28		db 'start1',0           ; DATA XREF: .text:00003EC0o
$LN27		db 'start0',0           ; DATA XREF: .text:00003EB4o
$LN25		db 'result',0           ; DATA XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+37Fo
					; icu_56::RuleBasedTimeZone::findNext(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+3B6o ...
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3EDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleBasedTimeZone::findPrev(icu_56::RuleBasedTimeZone *this,	double,	char, double *,	struct icu_56::TimeZoneRule **,	struct icu_56::TimeZoneRule **)
		public ?findPrev@RuleBasedTimeZone@icu_56@@ABECNCAANAAPAVTimeZoneRule@2@1@Z
?findPrev@RuleBasedTimeZone@icu_56@@ABECNCAANAAPAVTimeZoneRule@2@1@Z proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::getPreviousTransition(double,signed char,icu_56::TimeZoneTransition &)+6Ap
					; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+393p

var_198		= qword	ptr -198h
var_174		= byte ptr -174h
var_16D		= byte ptr -16Dh
var_A1		= byte ptr -0A1h
var_95		= byte ptr -95h
var_8C		= qword	ptr -8Ch
var_7C		= qword	ptr -7Ch
var_6C		= dword	ptr -6Ch
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= qword	ptr -48h
var_38		= dword	ptr -38h
var_2C		= qword	ptr -2Ch
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 174h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_174]
		mov	ecx, 5Dh ; ']'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_16D], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+50h], 0
		jnz	short loc_3F16
		xor	al, al
		jmp	loc_42AA
; ---------------------------------------------------------------------------

loc_3F16:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+31j
		mov	[ebp+var_11], 0
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		fld	qword ptr [eax]
		fstp	[ebp+var_48]
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_3F7D
		fld	[ebp+var_48]
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_3F7D
		mov	eax, [ebp+var_38]
		mov	[ebp+var_16D], 1
		mov	ecx, [eax]
		mov	dword ptr [ebp+var_2C],	ecx
		mov	edx, [eax+4]
		mov	dword ptr [ebp+var_2C+4], edx
		mov	ecx, [eax+8]
		mov	[ebp+var_24], ecx
		mov	edx, [eax+0Ch]
		mov	[ebp+var_20], edx
		mov	[ebp+var_11], 1
		jmp	loc_4207
; ---------------------------------------------------------------------------

loc_3F7D:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+66j
					; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+75j
		fld	[ebp+arg_0]
		fcomp	[ebp+var_48]
		fnstsw	ax
		test	ah, 41h
		jnz	loc_4207
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, 1
		mov	[ebp+var_54], eax
		mov	esi, esp
		mov	eax, [ebp+var_54]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+50h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		fld	qword ptr [eax]
		fstp	[ebp+var_48]
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_400E
		fld	[ebp+var_48]
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_400E
		mov	eax, [ebp+var_38]
		mov	[ebp+var_16D], 1
		mov	ecx, [eax]
		mov	dword ptr [ebp+var_2C],	ecx
		mov	edx, [eax+4]
		mov	dword ptr [ebp+var_2C+4], edx
		mov	ecx, [eax+8]
		mov	[ebp+var_24], ecx

loc_3FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		mov	edx, [eax+0Ch]
		mov	[ebp+var_20], edx
		mov	[ebp+var_11], 1
		jmp	loc_4207
; ---------------------------------------------------------------------------

loc_400E:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+F7j
					; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+106j
		fld	[ebp+arg_0]
		fcomp	[ebp+var_48]
		fnstsw	ax
		test	ah, 41h
		jnz	loc_417E
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0
		jz	loc_4154
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_60], eax
		mov	esi, esp
		push	1		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_6C], eax
		mov	esi, esp
		lea	eax, [ebp+var_7C]
		push	eax
		movzx	ecx, [ebp+arg_8]
		push	ecx
		mov	ecx, [ebp+var_6C] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax
		mov	ecx, [ebp+var_6C] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+198h+var_198]
		mov	edx, [ebp+var_60]
		mov	eax, [edx]
		mov	ecx, [ebp+var_60]
		mov	edx, [eax+24h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_95], al
		mov	esi, esp
		lea	eax, [ebp+var_8C]
		push	eax
		movzx	ecx, [ebp+arg_8]
		push	ecx
		mov	ecx, [ebp+var_60] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax
		mov	ecx, [ebp+var_60] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+198h+var_198]
		mov	edx, [ebp+var_6C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_6C]
		mov	edx, [eax+24h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_A1], al
		movsx	eax, [ebp+var_95]
		test	eax, eax
		jnz	short loc_4100
		movsx	eax, [ebp+var_A1]
		test	eax, eax
		jnz	short loc_4100
		xor	al, al
		jmp	loc_42AA
; ---------------------------------------------------------------------------

loc_4100:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+210j
					; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+21Bj
		movsx	eax, [ebp+var_A1]
		test	eax, eax
		jz	short loc_411B
		fld	[ebp+var_8C]
		fcomp	[ebp+var_7C]
		fnstsw	ax
		test	ah, 5
		jp	short loc_4136

loc_411B:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+22Dj
		mov	[ebp+var_16D], 1
		fld	[ebp+var_7C]
		fstp	[ebp+var_2C]
		mov	eax, [ebp+var_6C]
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_60]
		mov	[ebp+var_20], eax
		jmp	short loc_4152
; ---------------------------------------------------------------------------

loc_4136:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+23Dj
		mov	[ebp+var_16D], 1
		fld	[ebp+var_8C]
		fstp	[ebp+var_2C]
		mov	eax, [ebp+var_60]
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_6C]
		mov	[ebp+var_20], eax

loc_4152:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+258j
		jmp	short loc_4175
; ---------------------------------------------------------------------------

loc_4154:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+14Aj
		mov	eax, [ebp+var_38]
		mov	[ebp+var_16D], 1
		mov	ecx, [eax]
		mov	dword ptr [ebp+var_2C],	ecx
		mov	edx, [eax+4]
		mov	dword ptr [ebp+var_2C+4], edx
		mov	ecx, [eax+8]
		mov	[ebp+var_24], ecx
		mov	edx, [eax+0Ch]
		mov	[ebp+var_20], edx

loc_4175:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &):loc_4152j
		mov	[ebp+var_11], 1
		jmp	loc_4207
; ---------------------------------------------------------------------------

loc_417E:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+13Dj
		mov	eax, [ebp+var_54]
		sub	eax, 1
		mov	[ebp+var_54], eax

loc_4187:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+304j
		cmp	[ebp+var_54], 0
		jl	short loc_41E2
		mov	esi, esp
		mov	eax, [ebp+var_54]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+50h]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		fld	qword ptr [eax]
		fstp	[ebp+var_48]
		fld	[ebp+arg_0]
		fcomp	[ebp+var_48]
		fnstsw	ax
		test	ah, 41h
		jz	short loc_41D5
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_41D7
		fld	[ebp+var_48]
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_41D7

loc_41D5:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+2E0j
		jmp	short loc_41E2
; ---------------------------------------------------------------------------

loc_41D7:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+2E8j
					; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+2F7j
		mov	eax, [ebp+var_54]
		sub	eax, 1
		mov	[ebp+var_54], eax
		jmp	short loc_4187
; ---------------------------------------------------------------------------

loc_41E2:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+2AFj
					; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &):loc_41D5j
		mov	eax, [ebp+var_38]
		mov	[ebp+var_16D], 1
		mov	ecx, [eax]
		mov	dword ptr [ebp+var_2C],	ecx
		mov	edx, [eax+4]
		mov	dword ptr [ebp+var_2C+4], edx
		mov	ecx, [eax+8]
		mov	[ebp+var_24], ecx
		mov	edx, [eax+0Ch]
		mov	[ebp+var_20], edx
		mov	[ebp+var_11], 1

loc_4207:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+9Cj
					; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+ACj ...
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jz	loc_42A8
		mov	ecx, [ebp+var_24] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		mov	esi, eax
		mov	ecx, [ebp+var_20] ; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		cmp	esi, eax
		jnz	short loc_4276
		mov	ecx, [ebp+var_24] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		mov	esi, eax
		mov	ecx, [ebp+var_20] ; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		cmp	esi, eax
		jnz	short loc_4276
		cmp	[ebp+var_16D], 0
		jnz	short loc_4255
		push	offset $LN24	; "result"
		call	__RTC_UninitUse
		add	esp, 4

loc_4255:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+36Aj
		mov	eax, [ebp+arg_14]
		push	eax		; struct icu_56::TimeZoneRule **
		mov	ecx, [ebp+arg_10]
		push	ecx		; struct icu_56::TimeZoneRule **
		mov	edx, [ebp+arg_C]
		push	edx		; double *
		push	0		; char
		sub	esp, 8
		fld	[ebp+var_2C]
		fstp	[esp+198h+var_198] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?findPrev@RuleBasedTimeZone@icu_56@@ABECNCAANAAPAVTimeZoneRule@2@1@Z ; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)
		jmp	short loc_42AA
; ---------------------------------------------------------------------------

loc_4276:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+34Bj
					; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+361j
		cmp	[ebp+var_16D], 0
		jnz	short loc_428C
		push	offset $LN24	; "result"
		call	__RTC_UninitUse
		add	esp, 4

loc_428C:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+3A1j
		mov	eax, [ebp+arg_C]
		fld	[ebp+var_2C]
		fstp	qword ptr [eax]
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+var_24]
		mov	[eax], ecx
		mov	eax, [ebp+arg_14]
		mov	ecx, [ebp+var_20]
		mov	[eax], ecx
		mov	al, 1
		jmp	short loc_42AA
; ---------------------------------------------------------------------------

loc_42A8:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+331j
		xor	al, al

loc_42AA:				; CODE XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+35j
					; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+21Fj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN29_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 174h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?findPrev@RuleBasedTimeZone@icu_56@@ABECNCAANAAPAVTimeZoneRule@2@1@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN29_0		dd 3			; DATA XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+3D2o
		dd offset $LN28_0
$LN28_0		dd 0FFFFFFD4h, 10h	; DATA XREF: .text:000042D8o
		dd offset $LN24		; "result"
		dd 0FFFFFF84h, 8
		dd offset $LN26		; "start0"
		dd 0FFFFFF74h, 8
		dd offset $LN27_0	; "start1"
$LN27_0		db 'start1',0           ; DATA XREF: .text:000042FCo
$LN26		db 'start0',0           ; DATA XREF: .text:000042F0o
$LN24		db 'result',0           ; DATA XREF: icu_56::RuleBasedTimeZone::findPrev(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+36Co
					; icu_56::RuleBasedTimeZone::findPrev(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+3A3o ...
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4318h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::RuleBasedTimeZone::getTransitionTime(icu_56::RuleBasedTimeZone *this, struct icu_56::Transition *, char, int, int)
		public ?getTransitionTime@RuleBasedTimeZone@icu_56@@ABENPAUTransition@2@CHH@Z
?getTransitionTime@RuleBasedTimeZone@icu_56@@ABENPAUTransition@2@CHH@Z proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed	char,int,int,int &,int &,UErrorCode &)+AEp
					; icu_56::RuleBasedTimeZone::getOffsetInternal(double,signed char,int,int,int &,int &,UErrorCode &)+116p ...

var_E0		= dword	ptr -0E0h
var_18		= qword	ptr -18h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E0]
		mov	ecx, 38h ; '8'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		fld	qword ptr [eax]
		fstp	[ebp+var_18]
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_439D
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+0Ch]	; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]	; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+8]	; this
		call	?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getDSTSavings(void)
		push	eax		; int
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+8]	; this
		call	?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ ; icu_56::TimeZoneRule::getRawOffset(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getLocalDelta@RuleBasedTimeZone@icu_56@@ABEHHHHHHH@Z ;	icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)
		mov	[ebp+var_E0], eax
		fild	[ebp+var_E0]
		fadd	[ebp+var_18]
		fstp	[ebp+var_18]

loc_439D:				; CODE XREF: icu_56::RuleBasedTimeZone::getTransitionTime(icu_56::Transition *,signed char,int,int)+31j
		fld	[ebp+var_18]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?getTransitionTime@RuleBasedTimeZone@icu_56@@ABENPAUTransition@2@CHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedTimeZone::getLocalDelta(icu_56::RuleBasedTimeZone *this, int,	int, int, int, int, int)
		public ?getLocalDelta@RuleBasedTimeZone@icu_56@@ABEHHHHHHH@Z
?getLocalDelta@RuleBasedTimeZone@icu_56@@ABEHHHHHHH@Z proc near
					; CODE XREF: icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+B7p
					; icu_56::RuleBasedTimeZone::findRuleInFinal(double,signed char,int,int)+13Fp ...

var_10C		= byte ptr -10Ch
var_109		= byte ptr -109h
var_41		= byte ptr -41h
var_35		= byte ptr -35h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_0]
		add	eax, [ebp+arg_4]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_8]
		add	eax, [ebp+arg_C]
		mov	[ebp+var_2C], eax
		cmp	[ebp+arg_4], 0
		jz	short loc_4409
		cmp	[ebp+arg_C], 0
		jnz	short loc_4409
		mov	[ebp+var_109], 1
		jmp	short loc_4410
; ---------------------------------------------------------------------------

loc_4409:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+40j
					; icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+46j
		mov	[ebp+var_109], 0

loc_4410:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+4Fj
		mov	al, [ebp+var_109]
		mov	[ebp+var_35], al
		cmp	[ebp+arg_4], 0
		jnz	short loc_442E
		cmp	[ebp+arg_C], 0
		jz	short loc_442E
		mov	[ebp+var_109], 1
		jmp	short loc_4435
; ---------------------------------------------------------------------------

loc_442E:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+65j
					; icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+6Bj
		mov	[ebp+var_109], 0

loc_4435:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+74j
		mov	al, [ebp+var_109]
		mov	[ebp+var_41], al
		mov	eax, [ebp+var_2C]
		sub	eax, [ebp+var_20]
		js	short loc_44BD
		mov	eax, [ebp+arg_10]
		and	eax, 3
		cmp	eax, 1
		jnz	short loc_4459
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jnz	short loc_446C

loc_4459:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+97j
		mov	eax, [ebp+arg_10]
		and	eax, 3
		cmp	eax, 3
		jnz	short loc_4474
		movsx	eax, [ebp+var_41]
		test	eax, eax
		jz	short loc_4474

loc_446C:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+9Fj
		mov	eax, [ebp+var_20]
		mov	[ebp+var_14], eax
		jmp	short loc_44BB
; ---------------------------------------------------------------------------

loc_4474:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+AAj
					; icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+B2j
		mov	eax, [ebp+arg_10]
		and	eax, 3
		cmp	eax, 1
		jnz	short loc_4487
		movsx	eax, [ebp+var_41]
		test	eax, eax
		jnz	short loc_449A

loc_4487:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+C5j
		mov	eax, [ebp+arg_10]
		and	eax, 3
		cmp	eax, 3
		jnz	short loc_44A2
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jz	short loc_44A2

loc_449A:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+CDj
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_14], eax
		jmp	short loc_44BB
; ---------------------------------------------------------------------------

loc_44A2:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+D8j
					; icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+E0j
		mov	eax, [ebp+arg_10]
		and	eax, 0Ch
		cmp	eax, 0Ch
		jnz	short loc_44B5
		mov	eax, [ebp+var_20]
		mov	[ebp+var_14], eax
		jmp	short loc_44BB
; ---------------------------------------------------------------------------

loc_44B5:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+F3j
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_14], eax

loc_44BB:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+BAj
					; icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+E8j ...
		jmp	short loc_4532
; ---------------------------------------------------------------------------

loc_44BD:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+8Cj
		mov	eax, [ebp+arg_14]
		and	eax, 3
		cmp	eax, 1
		jnz	short loc_44D0
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jnz	short loc_44E3

loc_44D0:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+10Ej
		mov	eax, [ebp+arg_14]
		and	eax, 3
		cmp	eax, 3
		jnz	short loc_44EB
		movsx	eax, [ebp+var_41]
		test	eax, eax
		jz	short loc_44EB

loc_44E3:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+116j
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_14], eax
		jmp	short loc_4532
; ---------------------------------------------------------------------------

loc_44EB:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+121j
					; icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+129j
		mov	eax, [ebp+arg_14]
		and	eax, 3
		cmp	eax, 1
		jnz	short loc_44FE
		movsx	eax, [ebp+var_41]
		test	eax, eax
		jnz	short loc_4511

loc_44FE:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+13Cj
		mov	eax, [ebp+arg_14]
		and	eax, 3
		cmp	eax, 3
		jnz	short loc_4519
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jz	short loc_4519

loc_4511:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+144j
		mov	eax, [ebp+var_20]
		mov	[ebp+var_14], eax
		jmp	short loc_4532
; ---------------------------------------------------------------------------

loc_4519:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+14Fj
					; icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+157j
		mov	eax, [ebp+arg_14]
		and	eax, 0Ch
		cmp	eax, 4
		jnz	short loc_452C
		mov	eax, [ebp+var_20]
		mov	[ebp+var_14], eax
		jmp	short loc_4532
; ---------------------------------------------------------------------------

loc_452C:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+16Aj
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_14], eax

loc_4532:				; CODE XREF: icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int):loc_44BBj
					; icu_56::RuleBasedTimeZone::getLocalDelta(int,int,int,int,int,int)+131j ...
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	18h
?getLocalDelta@RuleBasedTimeZone@icu_56@@ABEHHHHHHH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::TimeZone::operator!=(icu_56::TimeZone const &)+38p
					; icu_56::TimeZone::operator!=(icu_56::TimeZone	const &)+50p ...
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString const &)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::TimeZone::getID(icu_56::UnicodeString &)+2Fp
					; icu_56::TimeZone::setID(icu_56::UnicodeString	const &)+2Fp
					; DATA XREF: ...
; protected: class icu_56::TimeZone & __thiscall icu_56::TimeZone::operator=(class icu_56::TimeZone const &)
		extrn ??4TimeZone@icu_56@@IAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::BasicTimeZone::operator=(icu_56::BasicTimeZone const &)+2Ap
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::`scalar	deleting destructor'(uint)+39p
					; icu_56::RuleBasedTimeZone::`vector deleting destructor'(uint)+81p ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn __imp_??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::`vector	deleting destructor'(uint)+53p
					; DATA XREF: icu_56::RuleBasedTimeZone::`vector	deleting destructor'(uint)+53r
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::`vector	deleting destructor'(uint)+3Dp
; double __thiscall icu_56::Calendar::getTimeInMillis(icu_56::Calendar *__hidden this, enum UErrorCode *)
		extrn ?getTimeInMillis@Calendar@icu_56@@IBENAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::Calendar::getTime(UErrorCode &)+2Ap
		extrn __fltused:near
; void __thiscall icu_56::Calendar::setTimeInMillis(icu_56::Calendar *__hidden this, double, enum UErrorCode *)
		extrn ?setTimeInMillis@Calendar@icu_56@@IAEXNAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::Calendar::setTime(double,UErrorCode &)+33p
; struct icu_56::Calendar *__cdecl static icu_56::Calendar::createInstance(struct icu_56::TimeZone *, const struct icu_56::Locale *, enum UErrorCode *)
		extrn ?createInstance@Calendar@icu_56@@SAPAV12@PAVTimeZone@2@ABVLocale@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::Calendar::createInstance(icu_56::TimeZone *,UErrorCode &)+36p
; const	struct icu_56::Locale *__cdecl static icu_56::Locale::getDefault()
		extrn __imp_?getDefault@Locale@icu_56@@SAABV12@XZ:near
					; CODE XREF: icu_56::Calendar::createInstance(icu_56::TimeZone *,UErrorCode &)+24p
					; DATA XREF: icu_56::Calendar::createInstance(icu_56::TimeZone *,UErrorCode &)+24r
; int __thiscall icu_56::Calendar::weekNumber(icu_56::Calendar *__hidden this, int, int, int)
		extrn ?weekNumber@Calendar@icu_56@@IAEHHHH@Z:near
					; CODE XREF: icu_56::Calendar::weekNumber(int,int)+32p
; _DWORD __thiscall icu_56::BasicTimeZone::BasicTimeZone(icu_56::BasicTimeZone *__hidden this, const struct icu_56::UnicodeString *)
		extrn ??0BasicTimeZone@icu_56@@IAE@ABVUnicodeString@1@@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::UnicodeString	const &,icu_56::InitialTimeZoneRule *)+2Ap
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::RuleBasedTimeZone `RTTI Type	Descriptor'o
					; .data:icu_56::BasicTimeZone `RTTI Type Descriptor'o ...
; public: virtual int __thiscall icu_56::TimeZone::getDSTSavings(void)const
		extrn ?getDSTSavings@TimeZone@icu_56@@UBEHXZ:near
					; DATA XREF: .rdata:000009B8o
; public: virtual signed char __thiscall icu_56::BasicTimeZone::hasEquivalentTransitions(class icu_56::BasicTimeZone const &, double, double, signed char, enum	 UErrorCode &)const
		extrn ?hasEquivalentTransitions@BasicTimeZone@icu_56@@UBECABV12@NNCAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000009C4o
; public: virtual void __thiscall icu_56::BasicTimeZone::getSimpleRulesNear(double, class icu_56::InitialTimeZoneRule *	&, class icu_56::AnnualTimeZoneRule * &, class icu_56::AnnualTimeZoneRule * &, enum  UErrorCode	&)const
		extrn ?getSimpleRulesNear@BasicTimeZone@icu_56@@UBEXNAAPAVInitialTimeZoneRule@2@AAPAVAnnualTimeZoneRule@2@1AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000009D0o
; _DWORD __thiscall icu_56::BasicTimeZone::~BasicTimeZone(icu_56::BasicTimeZone	*__hidden this)
		extrn ??1BasicTimeZone@icu_56@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z$0+3j
					; icu_56::RuleBasedTimeZone::~RuleBasedTimeZone(void)+6Cp ...
; _DWORD __thiscall icu_56::BasicTimeZone::BasicTimeZone(icu_56::BasicTimeZone *__hidden this, const struct icu_56::BasicTimeZone *)
		extrn ??0BasicTimeZone@icu_56@@IAE@ABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone const &)+49p
		extrn ___security_cookie:near
					; DATA XREF: icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone const &)+2Er
					; icu_56::RuleBasedTimeZone::~RuleBasedTimeZone(void)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z+19j
					; __ehhandler$??1RuleBasedTimeZone@icu_56@@UAE@XZ+19j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0RuleBasedTimeZone@icu_56@@QAE@ABV01@@Z+Fp
					; __ehhandler$??1RuleBasedTimeZone@icu_56@@UAE@XZ+Fp ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::RuleBasedTimeZone::RuleBasedTimeZone(icu_56::RuleBasedTimeZone const &)+EFp
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+B20p ...
; public: virtual signed char __thiscall icu_56::TimeZone::operator==(class icu_56::TimeZone const &)const
		extrn ??8TimeZone@icu_56@@UBECABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+6Ap
; __declspec(dllimport)	public:	bool __thiscall	type_info::operator!=(class type_info const &)const
		extrn __imp_??9type_info@@QBE_NABV0@@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+4Fp
					; icu_56::RuleBasedTimeZone::hasSameRules(icu_56::TimeZone const &)+4Fp
					; DATA XREF: ...
		extrn ___RTtypeid:near	; CODE XREF: icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+36p
					; icu_56::RuleBasedTimeZone::operator==(icu_56::TimeZone const &)+45p ...
; void *__thiscall icu_56::UVector::elementAt(icu_56::UVector *__hidden	this, int)
		extrn __imp_?elementAt@UVector@icu_56@@QBEPAXH@Z:near
					; CODE XREF: icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+99p
					; icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+B2p ...
; int __thiscall icu_56::UVector::size(icu_56::UVector *__hidden this)
		extrn __imp_?size@UVector@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+4Bp
					; icu_56::compareRules(icu_56::UVector *,icu_56::UVector *)+60p ...
; void __thiscall icu_56::UVector::addElement(icu_56::UVector *__hidden	this, void *, enum UErrorCode *)
		extrn __imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+17Ep
					; icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+24Ap ...
; _DWORD __thiscall icu_56::UVector::UVector(icu_56::UVector *__hidden this, enum UErrorCode *)
		extrn __imp_??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+DAp
					; icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+1D3p ...
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn __imp_??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+A8p
					; icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+1A1p ...
; public: static int const icu_56::AnnualTimeZoneRule::MAX_YEAR
		extrn ?MAX_YEAR@AnnualTimeZoneRule@icu_56@@2HB:near
					; DATA XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+8Br
; int __thiscall icu_56::AnnualTimeZoneRule::getEndYear(icu_56::AnnualTimeZoneRule *__hidden this)
		extrn ?getEndYear@AnnualTimeZoneRule@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+86p
		extrn ___RTDynamicCast:near
					; CODE XREF: icu_56::RuleBasedTimeZone::addTransitionRule(icu_56::TimeZoneRule *,UErrorCode &)+6Ep
; public: virtual void * __thiscall icu_56::UVector::`scalar deleting destructor'(unsigned int)
		extrn ??_GUVector@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::UVector::`vector deleting destructor'(unsigned int)
		extrn ??_EUVector@icu_56@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::UVector::`local vftable'o
; public: virtual void * __thiscall icu_56::UVector::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UVector@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001458o
; _DWORD __thiscall icu_56::UVector::~UVector(icu_56::UVector *__hidden	this)
		extrn __imp_??1UVector@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UVector::`scalar deleting destructor'(uint)+28p
					; DATA XREF: icu_56::UVector::`scalar deleting destructor'(uint)+28r
		extrn _umtx_unlock_56:near
					; CODE XREF: icu_56::RuleBasedTimeZone::completeConst(UErrorCode &)+69p
		extrn _umtx_lock_56:near
					; CODE XREF: icu_56::RuleBasedTimeZone::completeConst(UErrorCode &)+3Fp
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+91Ap
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+AEBp ...
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+3A7p
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+3C3p ...
; __declspec(dllimport)	public:	signed char __thiscall icu_56::UnicodeString::operator==(class icu_56::UnicodeString const &)const
		extrn __imp_??8UnicodeString@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+2C6p
					; DATA XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+2C6r
; struct icu_56::UnicodeString *__thiscall icu_56::TimeZoneRule::getName(icu_56::TimeZoneRule *__hidden	this, struct icu_56::UnicodeString *)
		extrn ?getName@TimeZoneRule@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+1D8p
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+28Bp
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		extrn __imp_??0UnicodeString@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+1A1p
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+1BDp
					; DATA XREF: ...
; int __thiscall icu_56::TimeZoneRule::getDSTSavings(icu_56::TimeZoneRule *__hidden this)
		extrn ?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+174p
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+2F9p ...
; int __thiscall icu_56::TimeZoneRule::getRawOffset(icu_56::TimeZoneRule *__hidden this)
		extrn ?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+169p
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+2E0p ...
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::RuleBasedTimeZone::complete(UErrorCode &)+115p
					; icu_56::RuleBasedTimeZone::complete(UErrorCode &)+5F7p ...
; private: static signed char const * const icu_56::Grego::MONTH_LENGTH
		extrn ?MONTH_LENGTH@Grego@icu_56@@0QBCB:near
					; DATA XREF: icu_56::Grego::monthLength(int,int)+37r
; double __cdecl static	icu_56::Grego::fieldsToDay(int,	int, int)
		extrn ?fieldsToDay@Grego@icu_56@@SANHHH@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::getOffset(uchar,int,int,int,uchar,int,int,UErrorCode &)+5Bp
		extrn _uprv_getUTCtime_56:near
					; CODE XREF: icu_56::RuleBasedTimeZone::getRawOffset(void)+3Ap
					; icu_56::RuleBasedTimeZone::useDaylightTime(void)+2Ap
; void __thiscall icu_56::TimeZoneTransition::setTo(icu_56::TimeZoneTransition *__hidden this, const struct icu_56::TimeZoneRule *)
		extrn ?setTo@TimeZoneTransition@icu_56@@QAEXABVTimeZoneRule@2@@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::getNextTransition(double,signed	char,icu_56::TimeZoneTransition	&)+9Ep
					; icu_56::RuleBasedTimeZone::getPreviousTransition(double,signed char,icu_56::TimeZoneTransition &)+9Ep
; void __thiscall icu_56::TimeZoneTransition::setFrom(icu_56::TimeZoneTransition *__hidden this, const struct icu_56::TimeZoneRule *)
		extrn ?setFrom@TimeZoneTransition@icu_56@@QAEXABVTimeZoneRule@2@@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::getNextTransition(double,signed	char,icu_56::TimeZoneTransition	&)+92p
					; icu_56::RuleBasedTimeZone::getPreviousTransition(double,signed char,icu_56::TimeZoneTransition &)+92p
; void __thiscall icu_56::TimeZoneTransition::setTime(icu_56::TimeZoneTransition *__hidden this, double)
		extrn ?setTime@TimeZoneTransition@icu_56@@QAEXN@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::getNextTransition(double,signed	char,icu_56::TimeZoneTransition	&)+86p
					; icu_56::RuleBasedTimeZone::getPreviousTransition(double,signed char,icu_56::TimeZoneTransition &)+86p
; void *__thiscall icu_56::UVector::orphanElementAt(icu_56::UVector *__hidden this, int)
		extrn __imp_?orphanElementAt@UVector@icu_56@@QAEPAXH@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+B0p
					; icu_56::RuleBasedTimeZone::deleteRules(void)+196p ...
; signed __int8	__thiscall icu_56::UVector::isEmpty(icu_56::UVector *__hidden this)
		extrn __imp_?isEmpty@UVector@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::RuleBasedTimeZone::deleteRules(void)+92p
					; icu_56::RuleBasedTimeZone::deleteRules(void)+178p ...
; _DWORD __thiscall icu_56::UVector::UVector(icu_56::UVector *__hidden this, int, enum UErrorCode *)
		extrn __imp_??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+A5p
					; DATA XREF: icu_56::RuleBasedTimeZone::copyRules(icu_56::UVector *)+A5r
		extrn __RTC_UninitUse:near
					; CODE XREF: icu_56::RuleBasedTimeZone::findNext(double,signed char,double &,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule * &)+384p
					; icu_56::RuleBasedTimeZone::findNext(double,signed char,double	&,icu_56::TimeZoneRule * &,icu_56::TimeZoneRule	* &)+3BBp ...


		end
