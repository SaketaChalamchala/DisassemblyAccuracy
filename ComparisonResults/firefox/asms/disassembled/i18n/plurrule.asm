;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	2B0831AAF2272A21719CF18411B1F246
; Input	CRC32 :	5021EA80

; File Name   :	D:\compspace\objfiles\firefox\i18n\plurrule.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5 ; DATA XREF: .rdata:`string'o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB db 2 dup(0)	; DATA XREF: .text:00003944o
word_66		dw 0			; DATA XREF: .rdata:_PK_VAR_Fo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B db 1
byte_69		db 3 dup(0)		; DATA XREF: .rdata:_PK_VAR_Io
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B db 2,	0
word_6E		dw 0			; DATA XREF: .rdata:_PK_VAR_No
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B db 8, 0 ; DATA XREF:	.rdata:_PK_VAR_To
word_76		dw 0			; DATA XREF: .rdata:_PK_VAR_Vo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset _PLURAL_KEYWORD_OTHER+8 ; "r"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ ; icu_56::Formattable::getDigitList(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_800
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset ?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z ;	icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_7FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F8h
; wchar_t PLURAL_KEYWORD_OTHER
_PLURAL_KEYWORD_OTHER:			; DATA XREF: icu_56::PluralRules::isKeyword(icu_56::UnicodeString const	&)+27o
					; icu_56::PluralRules::getKeywordOther(void)+31o ...
		unicode	0, <other>,0
; wchar_t PLURAL_DEFAULT_RULE
_PLURAL_DEFAULT_RULE:			; DATA XREF: icu_56::PluralRules::createDefaultRules(UErrorCode	&)+48o
					; icu_56::PluralRules::internalForLocale(icu_56::Locale	const &,UPluralType,UErrorCode &)+17Fo	...
		unicode	0, <other: n>,0
		align 4
; wchar_t PK_IN
_PK_IN:					; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+164o
		unicode	0, <in>,0
		align 10h
; wchar_t PK_NOT
_PK_NOT:				; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+1BCo
		unicode	0, <not>,0
; wchar_t PK_IS
_PK_IS:					; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+10Co
		unicode	0, <is>,0
		align 10h
; wchar_t PK_MOD
_PK_MOD:				; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+1E8o
		unicode	0, <mod>,0
; wchar_t PK_AND
_PK_AND:				; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+138o
		unicode	0, <and>,0
; wchar_t PK_OR
_PK_OR:					; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+211o
		unicode	0, <or>,0
		align 4
; wchar_t PK_VAR_N
_PK_VAR_N	dd offset word_6E	; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+30o
; wchar_t PK_VAR_I
_PK_VAR_I	dd offset byte_69	; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+5Co
; wchar_t PK_VAR_F
_PK_VAR_F	dd offset word_66	; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+88o
; wchar_t PK_VAR_T
_PK_VAR_T	dd offset ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
					; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+B4o
					; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showbase
; wchar_t PK_VAR_V
_PK_VAR_V	dd offset word_76	; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+E0o
; wchar_t PK_WITHIN
_PK_WITHIN:				; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+190o
		unicode	0, <within>,0
		align 4
; wchar_t PK_DECIMAL
_PK_DECIMAL:				; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+23Ao
		unicode	0, <decimal>,0
; wchar_t PK_INTEGER
_PK_INTEGER:				; DATA XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+263o
		unicode	0, <integer>,0
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 18Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; char `public:	static void * __cdecl icu_56::PluralRules::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@PluralRules@icu_56@@SAPAXXZ@4DA db ?
					; DATA XREF: icu_56::PluralRules::getStaticClassID(void)+1Eo
; char `public:	static void * __cdecl icu_56::PluralKeywordEnumeration::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@PluralKeywordEnumeration@icu_56@@SAPAXXZ@4DA db ?
					; DATA XREF: icu_56::PluralKeywordEnumeration::getStaticClassID(void)+1Eo
		align 10h
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 190h
_p10		dd 1			; DATA XREF: icu_56::FixedDecimal::quickInit(double)+56r
					; icu_56::FixedDecimal::decimals(double)+57r
		dd 0Ah,	64h, 3E8h, 2710h
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh

loc_1C0:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 1DCh
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 1E0h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh

loc_200:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 218h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Formattable::operator!=(class icu_56::Formattable const &)const
		public ??9Formattable@icu_56@@QBECABV01@@Z
??9Formattable@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8Formattable@icu_56@@QBECABV01@@Z ; icu_56::Formattable::operator==(icu_56::Formattable const	&)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Formattable@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 268h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDouble(icu_56::Formattable *__hidden this)
		public ?getDouble@Formattable@icu_56@@QBENXZ
?getDouble@Formattable@icu_56@@QBENXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDouble@Formattable@icu_56@@QBENXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 298h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *__hidden this)
		public ?getLong@Formattable@icu_56@@QBEHXZ
?getLong@Formattable@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLong@Formattable@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __thiscall icu_56::Formattable::getInt64(icu_56::Formattable *__hidden this)
		public ?getInt64@Formattable@icu_56@@QBE_JXZ
?getInt64@Formattable@icu_56@@QBE_JXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx+8]
		mov	edx, [ecx+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getInt64@Formattable@icu_56@@QBE_JXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDate(icu_56::Formattable *__hidden this)
		public ?getDate@Formattable@icu_56@@QBENXZ
?getDate@Formattable@icu_56@@QBENXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDate@Formattable@icu_56@@QBENXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *this, struct icu_56::UnicodeString *)
		public ?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 384h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__thiscall icu_56::Formattable::getArray(icu_56::Formattable *this,	int *)
		public ?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z
?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Formattable & __thiscall icu_56::Formattable::operator[](int)
		public ??AFormattable@icu_56@@QAEAAV01@H@Z
??AFormattable@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		imul	eax, 0E0h
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??AFormattable@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 400h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::DigitList *__thiscall icu_56::Formattable::getDigitList(icu_56::Formattable *__hidden this)
		public ?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ
?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ proc near
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 430h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDate(icu_56::Formattable *this, enum UErrorCode *)
		public ?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z
?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+98h], 0
		jz	short loc_481
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_47D
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 3

loc_47D:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+42j
		fldz
		jmp	short loc_487
; ---------------------------------------------------------------------------

loc_481:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+2Dj
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]

loc_487:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+4Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 4A0h
		public __real@0000000000000000
__real@0000000000000000	dd 2 dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+35p
					; icu_56::PluralRules::getAvailableLocales(UErrorCode &)+B0p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *__hidden this)
		public ?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ
?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 504h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *__hidden	this)
		public ?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ
?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 534h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *this, enum UErrorCode *)
		public ?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z
?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?getLong@Formattable@icu_56@@QBEHAAW4UErrorCode@@@Z ; icu_56::Formattable::getLong(UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 57Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void **__thiscall icu_56::Formattable::toUFormattable(icu_56::Formattable *__hidden this)
		public ?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ
?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *const *__thiscall icu_56::Formattable::toUFormattable(icu_56::Formattable *__hidden this)
		public ?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ
?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::Formattable *__cdecl icu_56::Formattable::fromUFormattable(void **)
		public ?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z
?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 604h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__cdecl icu_56::Formattable::fromUFormattable(void *const *)
		public ?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z
?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 62Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *__hidden this)
		public ??0FieldPosition@icu_56@@QAE@XZ
??0FieldPosition@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0FieldPosition@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6A0h
		dd offset ??_R4FieldPosition@icu_56@@6B@ ; const icu_56::FieldPosition::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7FieldPosition@icu_56@@6B@
; const	icu_56::FieldPosition::`vftable'
??_7FieldPosition@icu_56@@6B@ dd offset	??_EFieldPosition@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::FieldPosition::FieldPosition(void)+38o
					; icu_56::FieldPosition::FieldPosition(int)+38o ...
					; icu_56::FieldPosition::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@FieldPosition@icu_56@@UBEPAXXZ ; icu_56::FieldPosition::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6ACh
		public ??_R4FieldPosition@icu_56@@6B@
; const	icu_56::FieldPosition::`RTTI Complete Object Locator'
??_R4FieldPosition@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:000006A0o
		dd offset ??_R0?AVFieldPosition@icu_56@@@8 ; icu_56::FieldPosition `RTTI Type Descriptor'
		dd offset ??_R3FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 6C0h
		public ??_R0?AVFieldPosition@icu_56@@@8
; class	icu_56::FieldPosition `RTTI Type Descriptor'
??_R0?AVFieldPosition@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000006B8o
					; .rdata$r:icu_56::FieldPosition::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avfieldposit	db '.?AVFieldPosition@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6E4h
		public ??_R3FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
??_R3FieldPosition@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:000006BCo
					; .rdata$r:0000071Co
		dd 3
		dd offset ??_R2FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6F4h
		public ??_R2FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Base Class Array'
??_R2FieldPosition@icu_56@@8 dd	offset ??_R1A@?0A@EA@FieldPosition@icu_56@@8
					; DATA XREF: .rdata$r:000006F0o
					; icu_56::FieldPosition::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 704h
		public ??_R1A@?0A@EA@FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@FieldPosition@icu_56@@8 dd offset	??_R0?AVFieldPosition@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::FieldPosition::`RTTI Base	Class Array'o
					; icu_56::FieldPosition	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 720h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:000006F8o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Array'o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 73Ch
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 75Ch
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000738o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 76Ch
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000768o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 778h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:000006FCo
					; .rdata$r:00000770o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 794h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7B4h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000790o
					; .rdata$r:000007E4o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7C4h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000007C0o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7CCh
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *this, int)
		public ??0FieldPosition@icu_56@@QAE@H@Z
??0FieldPosition@icu_56@@QAE@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'

loc_800:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FieldPosition@icu_56@@QAE@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 85Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *this, const struct icu_56::FieldPosition *)
		public ??0FieldPosition@icu_56@@QAE@ABV01@@Z
??0FieldPosition@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FieldPosition@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getField(icu_56::FieldPosition *__hidden this)
		public ?getField@FieldPosition@icu_56@@QBEHXZ
?getField@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getField@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 90Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getBeginIndex(icu_56::FieldPosition *__hidden this)
		public ?getBeginIndex@FieldPosition@icu_56@@QBEHXZ
?getBeginIndex@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBeginIndex@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 93Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getEndIndex(icu_56::FieldPosition *__hidden this)
		public ?getEndIndex@FieldPosition@icu_56@@QBEHXZ
?getEndIndex@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getEndIndex@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 96Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setField(icu_56::FieldPosition	*this, int)
		public ?setField@FieldPosition@icu_56@@QAEXH@Z
?setField@FieldPosition@icu_56@@QAEXH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setField@FieldPosition@icu_56@@QAEXH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setBeginIndex(icu_56::FieldPosition *this, int)
		public ?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z
?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setEndIndex(icu_56::FieldPosition *this, int)
		public ?setEndIndex@FieldPosition@icu_56@@QAEXH@Z
?setEndIndex@FieldPosition@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setEndIndex@FieldPosition@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPosition::`scalar deleting destructor'(unsigned int)
		public ??_GFieldPosition@icu_56@@UAEPAXI@Z
??_GFieldPosition@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPosition@icu_56@@UAE@XZ	; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_A5D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A5D:				; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GFieldPosition@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPosition::`vector deleting destructor'(unsigned int)
		public ??_EFieldPosition@icu_56@@UAEPAXI@Z
??_EFieldPosition@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::FieldPosition::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_AE3
		push	offset ??1FieldPosition@icu_56@@UAE@XZ ; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_ADB
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_ADB:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_B0C
; ---------------------------------------------------------------------------

loc_AE3:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPosition@icu_56@@UAE@XZ	; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_B09
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_B09:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_B0C:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EFieldPosition@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FieldPosition &	__thiscall icu_56::FieldPosition::operator=(class icu_56::FieldPosition	const &)
		public ??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z
??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPosition::operator==(class icu_56::FieldPosition const &)const
		public ??8FieldPosition@icu_56@@QBECABV01@@Z
??8FieldPosition@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::FieldPosition::operator!=(icu_56::FieldPosition const &)+2Ap

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_BCE
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+0Ch]
		cmp	edx, [ecx+0Ch]
		jnz	short loc_BCE
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+8]
		cmp	edx, [ecx+8]
		jnz	short loc_BCE
		mov	[ebp+var_CD], 1
		jmp	short loc_BD5
; ---------------------------------------------------------------------------

loc_BCE:				; CODE XREF: icu_56::FieldPosition::operator==(icu_56::FieldPosition const &)+2Fj
					; icu_56::FieldPosition::operator==(icu_56::FieldPosition const	&)+3Dj	...
		mov	[ebp+var_CD], 0

loc_BD5:				; CODE XREF: icu_56::FieldPosition::operator==(icu_56::FieldPosition const &)+54j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8FieldPosition@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPosition::operator!=(class icu_56::FieldPosition const &)const
		public ??9FieldPosition@icu_56@@QBECABV01@@Z
??9FieldPosition@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8FieldPosition@icu_56@@QBECABV01@@Z ;	icu_56::FieldPosition::operator==(icu_56::FieldPosition	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9FieldPosition@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPositionIterator::operator!=(class icu_56::FieldPositionIterator const &)const
		public ??9FieldPositionIterator@icu_56@@QBECABV01@@Z
??9FieldPositionIterator@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8FieldPositionIterator@icu_56@@QBECABV01@@Z ;	icu_56::FieldPositionIterator::operator==(icu_56::FieldPositionIterator	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9FieldPositionIterator@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FieldPositionIterator &	__thiscall icu_56::FieldPositionIterator::operator=(class icu_56::FieldPositionIterator	const &)
		public ??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z
??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Format::operator!=(class icu_56::Format const &)const
		public ??9Format@icu_56@@QBECABV01@@Z
??9Format@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Format@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::PluralRules::operator!=(class icu_56::PluralRules const &)const
		public ??9PluralRules@icu_56@@QBECABV01@@Z
??9PluralRules@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9PluralRules@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralRules::`scalar deleting destructor'(unsigned int)
		public ??_GPluralRules@icu_56@@UAEPAXI@Z
??_GPluralRules@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralRules@icu_56@@UAE@XZ ;	icu_56::PluralRules::~PluralRules(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_DF1
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_DF1:				; CODE XREF: icu_56::PluralRules::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp

loc_DFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GPluralRules@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralRules::`vector deleting destructor'(unsigned int)
		public ??_EPluralRules@icu_56@@UAEPAXI@Z
??_EPluralRules@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::PluralRules::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_E77
		push	offset ??1PluralRules@icu_56@@UAE@XZ ; icu_56::PluralRules::~PluralRules(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	8
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E6F
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_E6F:				; CODE XREF: icu_56::PluralRules::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_EA0
; ---------------------------------------------------------------------------

loc_E77:				; CODE XREF: icu_56::PluralRules::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralRules@icu_56@@UAE@XZ ;	icu_56::PluralRules::~PluralRules(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E9D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_E9D:				; CODE XREF: icu_56::PluralRules::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_EA0:				; CODE XREF: icu_56::PluralRules::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EPluralRules@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::DecimalFormatSymbols::operator!=(class	icu_56::DecimalFormatSymbols const &)const
		public ??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z
??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8DecimalFormatSymbols@icu_56@@QBECABV01@@Z ; icu_56::DecimalFormatSymbols::operator==(icu_56::DecimalFormatSymbols const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DecimalFormatSymbols::isCustomCurrencySymbol(icu_56::DecimalFormatSymbols *__hidden this)
		public ?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ
?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+0AD0h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DecimalFormatSymbols::isCustomIntlCurrencySymbol(icu_56::DecimalFormatSymbols *__hidden this)
		public ?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ
?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+0AD1h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::DecimalFormatSymbols::getSymbol(enum  icu_56::DecimalFormatSymbols::ENumberFormatSymbol)const
		public ?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z
?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z proc near

var_E4		= byte ptr -0E4h
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_E0], 0
		cmp	[ebp+arg_4], 1Ch
		jge	short loc_FB5
		mov	eax, [ebp+arg_4]
		shl	eax, 6
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax+4]
		mov	[ebp+var_14], edx
		jmp	short loc_FC0
; ---------------------------------------------------------------------------

loc_FB5:				; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+31j
		mov	eax, [ebp+var_8]
		add	eax, 704h
		mov	[ebp+var_14], eax

loc_FC0:				; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+43j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_E0]
		or	ecx, 1
		mov	[ebp+var_E0], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1000h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString const & __thiscall icu_56::DecimalFormatSymbols::getConstSymbol(enum  icu_56::DecimalFormatSymbols::ENumberFormatSymbol)const
		public ?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z
?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z proc near
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 1Ch
		jge	short loc_103B
		mov	eax, [ebp+arg_0]
		shl	eax, 6
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax+4]
		mov	[ebp+var_14], edx
		jmp	short loc_1046
; ---------------------------------------------------------------------------

loc_103B:				; CODE XREF: icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+27j
		mov	eax, [ebp+var_8]
		add	eax, 704h
		mov	[ebp+var_14], eax

loc_1046:				; CODE XREF: icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+39j
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1054h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::DecimalFormatSymbols::setSymbol(enum	icu_56::DecimalFormatSymbols::ENumberFormatSymbol, class icu_56::UnicodeString const &,	signed char)
		public ?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z proc near

var_144		= dword	ptr -144h
var_140		= dword	ptr -140h
var_138		= byte ptr -138h
var_2D		= byte ptr -2Dh
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_144]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_0], 8
		jnz	short loc_10AB
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+0AD0h], 1
		jmp	short loc_10BB
; ---------------------------------------------------------------------------

loc_10AB:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+49j
		cmp	[ebp+arg_0], 9
		jnz	short loc_10BB
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+0AD1h], 1

loc_10BB:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+55j
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+5Bj
		cmp	[ebp+arg_0], 1Ch
		jge	short loc_10E1
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		shl	ecx, 6
		mov	edx, [ebp+var_18]
		lea	ecx, [edx+ecx+4]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_10E1:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+6Bj
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_11E2
		cmp	[ebp+arg_0], 4
		jnz	loc_11E2
		mov	esi, esp
		push	7FFFFFFFh	; int
		push	0		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z ; icu_56::UnicodeString::countChar32(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	loc_11E2
		mov	esi, esp
		push	0		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?char32At@UnicodeString@icu_56@@QBEHH@Z ; icu_56::UnicodeString::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		push	eax
		call	_u_charDigitValue_56
		add	esp, 4
		test	eax, eax
		jnz	loc_11E2
		mov	[ebp+var_2D], 1
		jmp	short loc_1152
; ---------------------------------------------------------------------------

loc_114A:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+189j
		mov	al, [ebp+var_2D]
		add	al, 1
		mov	[ebp+var_2D], al

loc_1152:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+F4j
		movsx	eax, [ebp+var_2D]
		cmp	eax, 9
		jg	loc_11E2
		mov	eax, [ebp+var_24]
		add	eax, 1
		mov	[ebp+var_24], eax
		mov	esi, esp
		mov	eax, [ebp+var_24]
		push	eax		; int
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@H@Z ; icu_56::UnicodeString::UnicodeString(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_140], eax
		mov	ecx, [ebp+var_140]
		mov	[ebp+var_144], ecx
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	edx, [ebp+var_144]
		push	edx
		movsx	eax, [ebp+var_2D]
		add	eax, 11h
		shl	eax, 6
		mov	ecx, [ebp+var_18]
		lea	ecx, [ecx+eax+4]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z	; icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_114A
; ---------------------------------------------------------------------------

loc_11E2:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+93j
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+9Dj ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1210h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0 proc near
					; DATA XREF: .xdata$x:00001254o
		mov	esi, esp
		lea	ecx, [ebp-138h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z	proc near
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-148h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		jmp	___CxxFrameHandler3
__ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1250h
__unwindtable$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001260o
		dd offset __unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0
__ehfuncinfo$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+1Eo
		dd offset __unwindtable$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 127Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Locale __thiscall icu_56::DecimalFormatSymbols::getLocale(void)const
		public ?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ
?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+var_8]
		add	eax, 744h
		mov	esi, esp
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_D4]
		or	ecx, 1
		mov	[ebp+var_D4], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::DecimalFormatSymbols::getCurrencyPattern(icu_56::DecimalFormatSymbols *__hidden this)
		public ?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ
?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+94Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1320h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__thiscall icu_56::Measure::getNumber(icu_56::Measure *__hidden this)
		public ?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ
?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 8
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1350h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::MeasureUnit *__thiscall icu_56::Measure::getUnit(icu_56::Measure	*__hidden this)
		public ?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ
?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	proc near
					; CODE XREF: icu_56::CurrencyAmount::getCurrency(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0E8h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1384h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MeasureUnit::MeasureUnit(icu_56::MeasureUnit *__hidden this)
		public ??0MeasureUnit@icu_56@@QAE@XZ
??0MeasureUnit@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0MeasureUnit@icu_56@@QAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 13F4h
		dd offset ??_R4MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7MeasureUnit@icu_56@@6B@
; const	icu_56::MeasureUnit::`vftable'
??_7MeasureUnit@icu_56@@6B@ dd offset ??_EMeasureUnit@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::MeasureUnit::MeasureUnit(void)+38o
					; icu_56::MeasureUnit::MeasureUnit(int,int)+38o
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@MeasureUnit@icu_56@@UBEPAXXZ ; icu_56::MeasureUnit::getDynamicClassID(void)
		dd offset ?clone@MeasureUnit@icu_56@@UBEPAVUObject@2@XZ	; icu_56::MeasureUnit::clone(void)
		dd offset ??8MeasureUnit@icu_56@@UBECABVUObject@1@@Z ; icu_56::MeasureUnit::operator==(icu_56::UObject const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1408h
		public ??_R4MeasureUnit@icu_56@@6B@
; const	icu_56::MeasureUnit::`RTTI Complete Object Locator'
??_R4MeasureUnit@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:000013F4o
		dd offset ??_R0?AVMeasureUnit@icu_56@@@8 ; icu_56::MeasureUnit `RTTI Type Descriptor'
		dd offset ??_R3MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 141Ch
		public ??_R0?AVMeasureUnit@icu_56@@@8
; class	icu_56::MeasureUnit `RTTI Type Descriptor'
??_R0?AVMeasureUnit@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00001414o
					; .rdata$r:icu_56::MeasureUnit::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avmeasureuni	db '.?AVMeasureUnit@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1440h
		public ??_R3MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Class Hierarchy Descriptor'
??_R3MeasureUnit@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00001418o
					; .rdata$r:00001478o
		dd 3
		dd offset ??_R2MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1450h
		public ??_R2MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Base Class	Array'
??_R2MeasureUnit@icu_56@@8 dd offset ??_R1A@?0A@EA@MeasureUnit@icu_56@@8
					; DATA XREF: .rdata$r:0000144Co
					; icu_56::MeasureUnit::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1460h
		public ??_R1A@?0A@EA@MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@MeasureUnit@icu_56@@8 dd offset ??_R0?AVMeasureUnit@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::MeasureUnit::`RTTI Base Class Array'o
					; icu_56::MeasureUnit `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 147Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MeasureUnit::operator!=(class icu_56::UObject const &)const
		public ??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z
??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MeasureUnit::MeasureUnit(icu_56::MeasureUnit *this,	int, int)
		public ??0MeasureUnit@icu_56@@AAE@HH@Z
??0MeasureUnit@icu_56@@AAE@HH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0MeasureUnit@icu_56@@AAE@HH@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1548h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MeasureUnit::`scalar deleting destructor'(unsigned int)
		public ??_GMeasureUnit@icu_56@@UAEPAXI@Z
??_GMeasureUnit@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1MeasureUnit@icu_56@@UAE@XZ ;	icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1591
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1591:				; CODE XREF: icu_56::MeasureUnit::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GMeasureUnit@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MeasureUnit::`vector deleting destructor'(unsigned int)
		public ??_EMeasureUnit@icu_56@@UAEPAXI@Z
??_EMeasureUnit@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::MeasureUnit::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1617
		push	offset ??1MeasureUnit@icu_56@@UAE@XZ ; icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_160F
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_160F:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1640
; ---------------------------------------------------------------------------

loc_1617:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1MeasureUnit@icu_56@@UAE@XZ ;	icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_163D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_163D:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_1640:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EMeasureUnit@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1658h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::CurrencyUnit::getISOCurrency(icu_56::CurrencyUnit *__hidden	this)
		public ?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ
?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ proc near
					; CODE XREF: icu_56::CurrencyAmount::getISOCurrency(void)+2Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 10h
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1688h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::CurrencyUnit *__thiscall	icu_56::CurrencyAmount::getCurrency(icu_56::CurrencyAmount *__hidden this)
		public ?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ
?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ proc near
					; CODE XREF: icu_56::CurrencyAmount::getISOCurrency(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	; icu_56::Measure::getUnit(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::CurrencyAmount::getISOCurrency(icu_56::CurrencyAmount *__hidden this)
		public ?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ
?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ ; icu_56::CurrencyAmount::getCurrency(void)
		mov	ecx, eax	; this
		call	?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ ; icu_56::CurrencyUnit::getISOCurrency(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1710h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory *__hidden this)
		public ??0NumberFormatFactory@icu_56@@QAE@XZ
??0NumberFormatFactory@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0NumberFormatFactory@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1768h
		dd offset ??_R4NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7NumberFormatFactory@icu_56@@6B@
; const	icu_56::NumberFormatFactory::`vftable'
??_7NumberFormatFactory@icu_56@@6B@ dd offset ??_ENumberFormatFactory@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::NumberFormatFactory::NumberFormatFactory(void)+38o
					; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)+3Co
					; icu_56::NumberFormatFactory::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1780h
		public ??_R4NumberFormatFactory@icu_56@@6B@
; const	icu_56::NumberFormatFactory::`RTTI Complete Object Locator'
??_R4NumberFormatFactory@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00001768o
		dd offset ??_R0?AVNumberFormatFactory@icu_56@@@8 ; icu_56::NumberFormatFactory `RTTI Type Descriptor'
		dd offset ??_R3NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1794h
		public ??_R0?AVNumberFormatFactory@icu_56@@@8
; class	icu_56::NumberFormatFactory `RTTI Type Descriptor'
??_R0?AVNumberFormatFactory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000178Co
					; .rdata$r:icu_56::NumberFormatFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avnumberform	db '.?AVNumberFormatFactory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 17C0h
		public ??_R3NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Class Hierarchy Descriptor'
??_R3NumberFormatFactory@icu_56@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:00001790o
					; .rdata$r:000017F8o
		dd 3
		dd offset ??_R2NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 17D0h
		public ??_R2NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Base Class	Array'
??_R2NumberFormatFactory@icu_56@@8 dd offset ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8
					; DATA XREF: .rdata$r:000017CCo
					; icu_56::NumberFormatFactory::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 17E0h
		public ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8 dd offset ??_R0?AVNumberFormatFactory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::NumberFormatFactory::`RTTI Base Class Array'o
					; .rdata$r:00001B34o
					; icu_56::NumberFormatFactory `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory *this,	const struct icu_56::NumberFormatFactory *)
		public ??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z
??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+49p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1858h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::NumberFormatFactory & __thiscall icu_56::NumberFormatFactory::operator=(class icu_56::NumberFormatFactory const	&)
		public ??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z
??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::NumberFormatFactory::`scalar deleting destructor'(unsigned int)
		public ??_GNumberFormatFactory@icu_56@@UAEPAXI@Z
??_GNumberFormatFactory@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_18F5
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_18F5:				; CODE XREF: icu_56::NumberFormatFactory::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GNumberFormatFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1910h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::NumberFormatFactory::`vector deleting destructor'(unsigned int)
		public ??_ENumberFormatFactory@icu_56@@UAEPAXI@Z
??_ENumberFormatFactory@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::NumberFormatFactory::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_197B
		push	offset ??1NumberFormatFactory@icu_56@@UAE@XZ ; icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1973
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1973:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_19A4
; ---------------------------------------------------------------------------

loc_197B:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_19A1
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_19A1:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_19A4:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ENumberFormatFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory *this, const	struct icu_56::SimpleNumberFormatFactory *)
		public ??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::NumberFormatFactory *
		mov	ecx, [ebp+var_14] ; this
		call	??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z ; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7SimpleNumberFormatFactory@icu_56@@6B@ ; const icu_56::SimpleNumberFormatFactory::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+4]
		mov	[eax+4], dl
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1A70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00001AB4o
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
__unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1A98h
		dd offset ??_R4SimpleNumberFormatFactory@icu_56@@6B@ ; const icu_56::SimpleNumberFormatFactory::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7SimpleNumberFormatFactory@icu_56@@6B@
; const	icu_56::SimpleNumberFormatFactory::`vftable'
??_7SimpleNumberFormatFactory@icu_56@@6B@ dd offset ??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+58o
					; icu_56::SimpleNumberFormatFactory::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?visible@SimpleNumberFormatFactory@icu_56@@UBECXZ ; icu_56::SimpleNumberFormatFactory::visible(void)
		dd offset ?getSupportedIDs@SimpleNumberFormatFactory@icu_56@@UBEPBVUnicodeString@2@AAHAAW4UErrorCode@@@Z ; icu_56::SimpleNumberFormatFactory::getSupportedIDs(int &,UErrorCode &)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1AB0h
__unwindtable$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001AC0o
		dd offset __unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1ADCh
		public ??_R4SimpleNumberFormatFactory@icu_56@@6B@
; const	icu_56::SimpleNumberFormatFactory::`RTTI Complete Object Locator'
??_R4SimpleNumberFormatFactory@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:00001A98o
		dd offset ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8 ; icu_56::SimpleNumberFormatFactory `RTTI Type Descriptor'
		dd offset ??_R3SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1AF0h
		public ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8
; class	icu_56::SimpleNumberFormatFactory `RTTI	Type Descriptor'
??_R0?AVSimpleNumberFormatFactory@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001AE8o
					; .rdata$r:icu_56::SimpleNumberFormatFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avsimplenumb	db '.?AVSimpleNumberFormatFactory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1B20h
		public ??_R3SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
??_R3SimpleNumberFormatFactory@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00001AECo
					; .rdata$r:00001B5Co
		dd 4
		dd offset ??_R2SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1B30h
		public ??_R2SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Array'
??_R2SimpleNumberFormatFactory@icu_56@@8 dd offset ??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8
					; DATA XREF: .rdata$r:00001B2Co
					; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8 ;	icu_56::NumberFormatFactory::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1B44h
		public ??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8 dd offset ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::SimpleNumberFormatFactory::`RTTI Base Class Array'o
					; icu_56::SimpleNumberFormatFactory `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SimpleNumberFormatFactory::`scalar deleting	destructor'(unsigned int)
		public ??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1BA9
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1BA9:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SimpleNumberFormatFactory::`vector deleting	destructor'(unsigned int)
		public ??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::SimpleNumberFormatFactory::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1C2F
		push	offset ??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	48h ; 'H'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1C27
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1C27:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1C58
; ---------------------------------------------------------------------------

loc_1C2F:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1C55
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1C55:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_1C58:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NumberFormat::isParseIntegerOnly(icu_56::NumberFormat *__hidden this)
		public ?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ
?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+154h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NumberFormat::isLenient(icu_56::NumberFormat	*__hidden this)
		public ?isLenient@NumberFormat@icu_56@@UBECXZ
?isLenient@NumberFormat@icu_56@@UBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+155h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLenient@NumberFormat@icu_56@@UBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::DigitList::operator!=(class icu_56::DigitList const &)const
		public ??9DigitList@icu_56@@QBECABV01@@Z
??9DigitList@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8DigitList@icu_56@@QBECABV01@@Z ; icu_56::DigitList::operator==(icu_56::DigitList const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9DigitList@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::isNaN(icu_56::DigitList *__hidden	this)
		public ?isNaN@DigitList@icu_56@@QBECXZ
?isNaN@DigitList@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 30h
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isNaN@DigitList@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::isInfinite(icu_56::DigitList *__hidden this)
		public ?isInfinite@DigitList@icu_56@@QBECXZ
?isInfinite@DigitList@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 40h
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isInfinite@DigitList@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::setToZero(icu_56::DigitList *__hidden this)
		public ?setToZero@DigitList@icu_56@@QAEXXZ
?setToZero@DigitList@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberZero_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setToZero@DigitList@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::digits(icu_56::DigitList *__hidden this)
		public ?digits@DigitList@icu_56@@QBEHXZ
?digits@DigitList@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	eax, [ecx]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?digits@DigitList@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::isPositive(icu_56::DigitList *__hidden this)
		public ?isPositive@DigitList@icu_56@@QBECXZ
?isPositive@DigitList@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 80h
		neg	edx
		sbb	edx, edx
		neg	edx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isPositive@DigitList@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::getLowerExponent(icu_56::DigitList *__hidden this)
		public ?getLowerExponent@DigitList@icu_56@@QBEHXZ
?getLowerExponent@DigitList@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLowerExponent@DigitList@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void *	__cdecl	icu_56::DigitList::operator new(unsigned int, void *, enum  icu_56::EStackMode)
		public ??2DigitList@icu_56@@SAPAXIPAXW4EStackMode@1@@Z
??2DigitList@icu_56@@SAPAXIPAXW4EStackMode@1@@Z	proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2DigitList@icu_56@@SAPAXIPAXW4EStackMode@1@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::DigitList::operator delete(void *)
		public ??3DigitList@icu_56@@SAXPAX0W4EStackMode@1@@Z
??3DigitList@icu_56@@SAXPAX0W4EStackMode@1@@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3DigitList@icu_56@@SAXPAX0W4EStackMode@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::internalSetDouble(icu_56::DigitList *this,	double)
		public ?internalSetDouble@DigitList@icu_56@@AAEXN@Z
?internalSetDouble@DigitList@icu_56@@AAEXN@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+68h], 1
		mov	eax, [ebp+var_8]
		fld	[ebp+arg_0]
		fstp	qword ptr [eax+60h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?internalSetDouble@DigitList@icu_56@@AAEXN@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::internalSetInt64(icu_56::DigitList	*this, __int64)
		public ?internalSetInt64@DigitList@icu_56@@AAEX_J@Z
?internalSetInt64@DigitList@icu_56@@AAEX_J@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+68h], 2
		mov	eax, [ebp+var_8]
		mov	ecx, dword ptr [ebp+arg_0]
		mov	[eax+60h], ecx
		mov	edx, dword ptr [ebp+arg_0+4]
		mov	[eax+64h], edx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?internalSetInt64@DigitList@icu_56@@AAEX_J@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::internalClear(icu_56::DigitList *__hidden this)
		public ?internalClear@DigitList@icu_56@@AAEXXZ
?internalClear@DigitList@icu_56@@AAEXXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+68h], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?internalClear@DigitList@icu_56@@AAEXXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FixedDecimal & __thiscall icu_56::FixedDecimal::operator=(class	icu_56::FixedDecimal const &)
		public ??4FixedDecimal@icu_56@@QAEAAV01@ABV01@@Z
??4FixedDecimal@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, [ebp+arg_0]
		mov	ecx, 0Ch
		mov	edi, [ebp+var_8]
		rep movsd
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4FixedDecimal@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(icu_56::PluralAvailableLocalesEnumeration *this, const	struct icu_56::PluralAvailableLocalesEnumeration *)
		public ??0PluralAvailableLocalesEnumeration@icu_56@@QAE@ABV01@@Z
??0PluralAvailableLocalesEnumeration@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx

loc_1FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::StringEnumeration *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0StringEnumeration@icu_56@@QAE@ABV01@@Z ; icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7PluralAvailableLocalesEnumeration@icu_56@@6B@ ; const icu_56::PluralAvailableLocalesEnumeration::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+6Ch]
		mov	[eax+6Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+70h]
		mov	[eax+70h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+74h]
		mov	[eax+74h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0PluralAvailableLocalesEnumeration@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 205Ch
		dd offset ??_R4PluralAvailableLocalesEnumeration@icu_56@@6B@ ; const icu_56::PluralAvailableLocalesEnumeration::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7PluralAvailableLocalesEnumeration@icu_56@@6B@
; const	icu_56::PluralAvailableLocalesEnumeration::`vftable'
??_7PluralAvailableLocalesEnumeration@icu_56@@6B@ dd offset ??_EPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(icu_56::PluralAvailableLocalesEnumeration const &)+3Co
					; icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &)+5Eo ...
					; icu_56::PluralAvailableLocalesEnumeration::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?clone@StringEnumeration@icu_56@@UBEPAV12@XZ ; icu_56::StringEnumeration::clone(void)
		dd offset ?count@PluralAvailableLocalesEnumeration@icu_56@@UBEHAAW4UErrorCode@@@Z ; icu_56::PluralAvailableLocalesEnumeration::count(UErrorCode	&)
		dd offset ?next@PluralAvailableLocalesEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z ;	icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)
		dd offset ?unext@StringEnumeration@icu_56@@UAEPB_WPAHAAW4UErrorCode@@@Z	; icu_56::StringEnumeration::unext(int *,UErrorCode &)
		dd offset ?snext@StringEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::StringEnumeration::snext(UErrorCode &)
		dd offset ?reset@PluralAvailableLocalesEnumeration@icu_56@@UAEXAAW4UErrorCode@@@Z ; icu_56::PluralAvailableLocalesEnumeration::reset(UErrorCode	&)
		dd offset ??8StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator==(icu_56::StringEnumeration const &)
		dd offset ??9StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator!=(icu_56::StringEnumeration const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2088h
		public ??_R4PluralAvailableLocalesEnumeration@icu_56@@6B@
; const	icu_56::PluralAvailableLocalesEnumeration::`RTTI Complete Object Locator'
??_R4PluralAvailableLocalesEnumeration@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:0000205Co
		dd offset ??_R0?AVPluralAvailableLocalesEnumeration@icu_56@@@8 ; icu_56::PluralAvailableLocalesEnumeration `RTTI Type Descriptor'
		dd offset ??_R3PluralAvailableLocalesEnumeration@icu_56@@8 ; icu_56::PluralAvailableLocalesEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 209Ch
		public ??_R0?AVPluralAvailableLocalesEnumeration@icu_56@@@8
; class	icu_56::PluralAvailableLocalesEnumeration `RTTI	Type Descriptor'
??_R0?AVPluralAvailableLocalesEnumeration@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00002094o
					; .rdata$r:icu_56::PluralAvailableLocalesEnumeration::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avpluralavai	db '.?AVPluralAvailableLocalesEnumeration@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 20D4h
		public ??_R3PluralAvailableLocalesEnumeration@icu_56@@8
; icu_56::PluralAvailableLocalesEnumeration::`RTTI Class Hierarchy Descriptor'
??_R3PluralAvailableLocalesEnumeration@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00002098o
					; .rdata$r:00002110o
		dd 4
		dd offset ??_R2PluralAvailableLocalesEnumeration@icu_56@@8 ; icu_56::PluralAvailableLocalesEnumeration::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 20E4h
		public ??_R2PluralAvailableLocalesEnumeration@icu_56@@8
; icu_56::PluralAvailableLocalesEnumeration::`RTTI Base	Class Array'
??_R2PluralAvailableLocalesEnumeration@icu_56@@8 dd offset ??_R1A@?0A@EA@PluralAvailableLocalesEnumeration@icu_56@@8
					; DATA XREF: .rdata$r:000020E0o
					; icu_56::PluralAvailableLocalesEnumeration::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 20F8h
		public ??_R1A@?0A@EA@PluralAvailableLocalesEnumeration@icu_56@@8
; icu_56::PluralAvailableLocalesEnumeration::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@PluralAvailableLocalesEnumeration@icu_56@@8 dd offset ??_R0?AVPluralAvailableLocalesEnumeration@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::PluralAvailableLocalesEnumeration::`RTTI Base Class Array'o
					; icu_56::PluralAvailableLocalesEnumeration `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3PluralAvailableLocalesEnumeration@icu_56@@8 ; icu_56::PluralAvailableLocalesEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2114h
		public ??_R1A@?0A@EA@StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@StringEnumeration@icu_56@@8 dd offset ??_R0?AVStringEnumeration@icu_56@@@8
					; DATA XREF: .rdata$r:000020E8o
					; .rdata$r:icu_56::StringEnumeration::`RTTI Base Class Array'o ...
					; icu_56::StringEnumeration `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2130h
		public ??_R0?AVStringEnumeration@icu_56@@@8
; class	icu_56::StringEnumeration `RTTI	Type Descriptor'
??_R0?AVStringEnumeration@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::StringEnumeration::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avstringenum	db '.?AVStringEnumeration@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2158h
		public ??_R3StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
??_R3StringEnumeration@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:0000212Co
		dd 3
		dd offset ??_R2StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2168h
		public ??_R2StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Base	Class Array'
??_R2StringEnumeration@icu_56@@8 dd offset ??_R1A@?0A@EA@StringEnumeration@icu_56@@8
					; DATA XREF: .rdata$r:00002164o
					; icu_56::StringEnumeration::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2178h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::PluralAvailableLocalesEnumeration & __thiscall icu_56::PluralAvailableLocalesEnumeration::operator=(class icu_56::PluralAvailableLocalesEnumeration const &)
		public ??4PluralAvailableLocalesEnumeration@icu_56@@QAEAAV01@ABV01@@Z
??4PluralAvailableLocalesEnumeration@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+6Ch]
		mov	[eax+6Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+70h]
		mov	[eax+70h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+74h]
		mov	[eax+74h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4PluralAvailableLocalesEnumeration@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralAvailableLocalesEnumeration::`scalar deleting	destructor'(unsigned int)
		public ??_GPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z
??_GPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralAvailableLocalesEnumeration@icu_56@@UAE@XZ ; icu_56::PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_2239
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2239:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2254h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralAvailableLocalesEnumeration::`vector deleting	destructor'(unsigned int)
		public ??_EPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z
??_EPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::PluralAvailableLocalesEnumeration::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_22BF
		push	offset ??1PluralAvailableLocalesEnumeration@icu_56@@UAE@XZ ; icu_56::PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	78h ; 'x'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_22B7
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_22B7:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_22E8
; ---------------------------------------------------------------------------

loc_22BF:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralAvailableLocalesEnumeration@icu_56@@UAE@XZ ; icu_56::PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_22E5
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_22E5:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`vector	deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_22E8:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`vector	deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2300h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SharedPluralRules::SharedPluralRules(icu_56::SharedPluralRules *this, struct icu_56::PluralRules *)
		public ??0SharedPluralRules@icu_56@@QAE@PAVPluralRules@1@@Z
??0SharedPluralRules@icu_56@@QAE@PAVPluralRules@1@@Z proc near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+107p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0SharedObject@icu_56@@QAE@XZ ; icu_56::SharedObject::SharedObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7SharedPluralRules@icu_56@@6B@ ; const icu_56::SharedPluralRules::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+14h], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0SharedPluralRules@icu_56@@QAE@PAVPluralRules@1@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2360h
		dd offset ??_R4SharedPluralRules@icu_56@@6B@ ; const icu_56::SharedPluralRules::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7SharedPluralRules@icu_56@@6B@
; const	icu_56::SharedPluralRules::`vftable'
??_7SharedPluralRules@icu_56@@6B@ dd offset ??_ESharedPluralRules@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::SharedPluralRules::SharedPluralRules(icu_56::PluralRules *)+38o
					; icu_56::SharedPluralRules::~SharedPluralRules(void)+45o
					; icu_56::SharedPluralRules::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 236Ch
		public ??_R4SharedPluralRules@icu_56@@6B@
; const	icu_56::SharedPluralRules::`RTTI Complete Object Locator'
??_R4SharedPluralRules@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:00002360o
		dd offset ??_R0?AVSharedPluralRules@icu_56@@@8 ; icu_56::SharedPluralRules `RTTI Type Descriptor'
		dd offset ??_R3SharedPluralRules@icu_56@@8 ; icu_56::SharedPluralRules::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2380h
		public ??_R0?AVSharedPluralRules@icu_56@@@8
; type_info icu_56::SharedPluralRules `RTTI Type Descriptor'
??_R0?AVSharedPluralRules@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00002378o
					; .rdata$r:icu_56::SharedPluralRules::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		align 8
a_?avsharedplur	db '.?AVSharedPluralRules@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 23A8h
		public ??_R3SharedPluralRules@icu_56@@8
; icu_56::SharedPluralRules::`RTTI Class Hierarchy Descriptor'
??_R3SharedPluralRules@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:0000237Co
					; .rdata$r:000023E4o
		dd 4
		dd offset ??_R2SharedPluralRules@icu_56@@8 ; icu_56::SharedPluralRules::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 23B8h
		public ??_R2SharedPluralRules@icu_56@@8
; icu_56::SharedPluralRules::`RTTI Base	Class Array'
??_R2SharedPluralRules@icu_56@@8 dd offset ??_R1A@?0A@EA@SharedPluralRules@icu_56@@8
					; DATA XREF: .rdata$r:000023B4o
					; icu_56::SharedPluralRules::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@SharedObject@icu_56@@8 ; icu_56::SharedObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 23CCh
		public ??_R1A@?0A@EA@SharedPluralRules@icu_56@@8
; icu_56::SharedPluralRules::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@SharedPluralRules@icu_56@@8 dd offset ??_R0?AVSharedPluralRules@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::SharedPluralRules::`RTTI Base Class Array'o
					; icu_56::SharedPluralRules `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3SharedPluralRules@icu_56@@8 ; icu_56::SharedPluralRules::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 23E8h
		public ??_R1A@?0A@EA@SharedObject@icu_56@@8
; icu_56::SharedObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@SharedObject@icu_56@@8 dd	offset ??_R0?AVSharedObject@icu_56@@@8
					; DATA XREF: .rdata$r:000023BCo
					; .rdata$r:icu_56::SharedObject::`RTTI Base Class Array'o
					; icu_56::SharedObject `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3SharedObject@icu_56@@8 ;	icu_56::SharedObject::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2404h
		public ??_R0?AVSharedObject@icu_56@@@8
; class	icu_56::SharedObject `RTTI Type	Descriptor'
??_R0?AVSharedObject@icu_56@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::SharedObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avsharedobje	db '.?AVSharedObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2428h
		public ??_R3SharedObject@icu_56@@8
; icu_56::SharedObject::`RTTI Class Hierarchy Descriptor'
??_R3SharedObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00002400o
		dd 3
		dd offset ??_R2SharedObject@icu_56@@8 ;	icu_56::SharedObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2438h
		public ??_R2SharedObject@icu_56@@8
; icu_56::SharedObject::`RTTI Base Class Array'
??_R2SharedObject@icu_56@@8 dd offset ??_R1A@?0A@EA@SharedObject@icu_56@@8
					; DATA XREF: .rdata$r:00002434o
					; icu_56::SharedObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2448h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::PluralRules const * __thiscall icu_56::SharedPluralRules::operator->(void)const
		public ??CSharedPluralRules@icu_56@@QBEPBVPluralRules@1@XZ
??CSharedPluralRules@icu_56@@QBEPBVPluralRules@1@XZ proc near
					; CODE XREF: icu_56::PluralRules::forLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+6Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??CSharedPluralRules@icu_56@@QBEPBVPluralRules@1@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2478h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::PluralRules const & __thiscall icu_56::SharedPluralRules::operator*(void)const
		public ??DSharedPluralRules@icu_56@@QBEABVPluralRules@1@XZ
??DSharedPluralRules@icu_56@@QBEABVPluralRules@1@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??DSharedPluralRules@icu_56@@QBEABVPluralRules@1@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SharedPluralRules::`scalar deleting	destructor'(unsigned int)
		public ??_GSharedPluralRules@icu_56@@UAEPAXI@Z
??_GSharedPluralRules@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SharedPluralRules@icu_56@@UAE@XZ ; icu_56::SharedPluralRules::~SharedPluralRules(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_24F1
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_24F1:				; CODE XREF: icu_56::SharedPluralRules::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSharedPluralRules@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 250Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SharedPluralRules::`vector deleting	destructor'(unsigned int)
		public ??_ESharedPluralRules@icu_56@@UAEPAXI@Z
??_ESharedPluralRules@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::SharedPluralRules::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_2577
		push	offset ??1SharedPluralRules@icu_56@@UAE@XZ ; icu_56::SharedPluralRules::~SharedPluralRules(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	18h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_256F
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_256F:				; CODE XREF: icu_56::SharedPluralRules::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_25A0
; ---------------------------------------------------------------------------

loc_2577:				; CODE XREF: icu_56::SharedPluralRules::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1SharedPluralRules@icu_56@@UAE@XZ ; icu_56::SharedPluralRules::~SharedPluralRules(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_259D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_259D:				; CODE XREF: icu_56::SharedPluralRules::`vector	deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_25A0:				; CODE XREF: icu_56::SharedPluralRules::`vector	deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ESharedPluralRules@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitInterval::DigitInterval(icu_56::DigitInterval *__hidden this)
		public ??0DigitInterval@icu_56@@QAE@XZ
??0DigitInterval@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::VisibleDigits::VisibleDigits(void)+61p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 7FFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 80000000h
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0DigitInterval@icu_56@@QAE@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitInterval::clear(icu_56::DigitInterval *__hidden this)
		public ?clear@DigitInterval@icu_56@@QAEXXZ
?clear@DigitInterval@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 7FFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 80000000h
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@DigitInterval@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2638h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitInterval::equals(icu_56::DigitInterval *this, const struct icu_56::DigitInterval *)
		public ?equals@DigitInterval@icu_56@@QBECABV12@@Z
?equals@DigitInterval@icu_56@@QBECABV12@@Z proc	near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jnz	short loc_267E
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_267E
		mov	[ebp+var_CD], 1
		jmp	short loc_2685
; ---------------------------------------------------------------------------

loc_267E:				; CODE XREF: icu_56::DigitInterval::equals(icu_56::DigitInterval const &)+2Dj
					; icu_56::DigitInterval::equals(icu_56::DigitInterval const &)+3Bj
		mov	[ebp+var_CD], 0

loc_2685:				; CODE XREF: icu_56::DigitInterval::equals(icu_56::DigitInterval const &)+44j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@DigitInterval@icu_56@@QBECABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2694h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitInterval::setLeastSignificantInclusive(icu_56::DigitInterval *this, int)
		public ?setLeastSignificantInclusive@DigitInterval@icu_56@@QAEXH@Z
?setLeastSignificantInclusive@DigitInterval@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	eax, eax
		cmp	[ebp+arg_0], 0
		setnl	al
		sub	eax, 1
		and	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setLeastSignificantInclusive@DigitInterval@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitInterval::setMostSignificantExclusive(icu_56::DigitInterval *this, int)
		public ?setMostSignificantExclusive@DigitInterval@icu_56@@QAEXH@Z
?setMostSignificantExclusive@DigitInterval@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	eax, eax
		cmp	[ebp+arg_0], 0
		setle	al
		sub	eax, 1
		and	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setMostSignificantExclusive@DigitInterval@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2718h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getMostSignificantExclusive(icu_56::DigitInterval *__hidden this)
		public ?getMostSignificantExclusive@DigitInterval@icu_56@@QBEHXZ
?getMostSignificantExclusive@DigitInterval@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getMostSignificantExclusive@DigitInterval@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2748h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getIntDigitCount(icu_56::DigitInterval *__hidden this)
		public ?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ
?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2778h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getFracDigitCount(icu_56::DigitInterval	*__hidden this)
		public ?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ
?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ	proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 80000000h
		jnz	short loc_27B3
		mov	[ebp+var_D0], 7FFFFFFFh
		jmp	short loc_27C1
; ---------------------------------------------------------------------------

loc_27B3:				; CODE XREF: icu_56::DigitInterval::getFracDigitCount(void)+2Dj
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		neg	edx
		mov	[ebp+var_D0], edx

loc_27C1:				; CODE XREF: icu_56::DigitInterval::getFracDigitCount(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::length(icu_56::DigitInterval *__hidden this)
		public ?length@DigitInterval@icu_56@@QBEHXZ
?length@DigitInterval@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	eax, [eax]
		sub	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@DigitInterval@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2808h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getLeastSignificantInclusive(icu_56::DigitInterval *__hidden this)
		public ?getLeastSignificantInclusive@DigitInterval@icu_56@@QBEHXZ
?getLeastSignificantInclusive@DigitInterval@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLeastSignificantInclusive@DigitInterval@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2838h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitInterval &	__thiscall icu_56::DigitInterval::operator=(class icu_56::DigitInterval	const &)
		public ??4DigitInterval@icu_56@@QAEAAV01@ABV01@@Z
??4DigitInterval@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4DigitInterval@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2878h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::VisibleDigits::VisibleDigits(icu_56::VisibleDigits *__hidden this)
		public ??0VisibleDigits@icu_56@@QAE@XZ
??0VisibleDigits@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::VisibleDigitsWithExponent::VisibleDigitsWithExponent(void)+45p
					; icu_56::VisibleDigitsWithExponent::VisibleDigitsWithExponent(void)+57p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0VisibleDigits@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0CharString@icu_56@@QAE@XZ	; icu_56::CharString::CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 38h ; '8'  ; this
		call	??0DigitInterval@icu_56@@QAE@XZ	; icu_56::DigitInterval::DigitInterval(void)
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+40h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+44h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+48h], 0
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+50h], 0
		mov	eax, [ebp+var_14]
		fldz
		fstp	qword ptr [eax+58h]
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+60h], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0VisibleDigits@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2944h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0VisibleDigits@icu_56@@QAE@XZ$0 proc near ; DATA XREF: .xdata$x:00002978o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0VisibleDigits@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0VisibleDigits@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::VisibleDigits::VisibleDigits(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0VisibleDigits@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0VisibleDigits@icu_56@@QAE@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2974h
__unwindtable$??0VisibleDigits@icu_56@@QAE@XZ dd 0FFFFFFFFh ; DATA XREF: .xdata$x:00002984o
		dd offset __unwindfunclet$??0VisibleDigits@icu_56@@QAE@XZ$0
__ehfuncinfo$??0VisibleDigits@icu_56@@QAE@XZ dd	19930522h, 1
					; DATA XREF: __ehhandler$??0VisibleDigits@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0VisibleDigits@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::DigitInterval *__thiscall icu_56::VisibleDigits::getInterval(icu_56::VisibleDigits *__hidden this)
		public ?getInterval@VisibleDigits@icu_56@@QBEABVDigitInterval@2@XZ
?getInterval@VisibleDigits@icu_56@@QBEABVDigitInterval@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 38h ; '8'
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getInterval@VisibleDigits@icu_56@@QBEABVDigitInterval@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::VisibleDigits::~VisibleDigits(icu_56::VisibleDigits	*__hidden this)
		public ??1VisibleDigits@icu_56@@QAE@XZ
??1VisibleDigits@icu_56@@QAE@XZ	proc near
					; CODE XREF: __unwindfunclet$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ$0+3j
					; icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(void)+4Fp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1VisibleDigits@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::VisibleDigitsWithExponent::VisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ??0VisibleDigitsWithExponent@icu_56@@QAE@XZ
??0VisibleDigitsWithExponent@icu_56@@QAE@XZ proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::VisibleDigits(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 68h ; 'h'  ; this
		call	??0VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::VisibleDigits(void)
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+0D0h], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0VisibleDigitsWithExponent@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2AACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00002AD8o
		mov	ecx, [ebp-14h]	; this
		jmp	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
__unwindfunclet$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ	proc near
					; DATA XREF: icu_56::VisibleDigitsWithExponent::VisibleDigitsWithExponent(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2AD4h
__unwindtable$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002AE4o
		dd offset __unwindfunclet$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ$0
__ehfuncinfo$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::VisibleDigits *__thiscall icu_56::VisibleDigitsWithExponent::getMantissa(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ?getMantissa@VisibleDigitsWithExponent@icu_56@@QBEABVVisibleDigits@2@XZ
?getMantissa@VisibleDigitsWithExponent@icu_56@@QBEABVVisibleDigits@2@XZ	proc near
					; CODE XREF: icu_56::PluralRules::select(icu_56::VisibleDigitsWithExponent const &)+6Bp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getMantissa@VisibleDigitsWithExponent@icu_56@@QBEABVVisibleDigits@2@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::VisibleDigits *__thiscall icu_56::VisibleDigitsWithExponent::getExponent(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ?getExponent@VisibleDigitsWithExponent@icu_56@@QBEPBVVisibleDigits@2@XZ
?getExponent@VisibleDigitsWithExponent@icu_56@@QBEPBVVisibleDigits@2@XZ	proc near
					; CODE XREF: icu_56::PluralRules::select(icu_56::VisibleDigitsWithExponent const &)+30p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+0D0h]
		test	ecx, ecx
		jz	short loc_2B6F
		mov	edx, [ebp+var_8]
		add	edx, 68h ; 'h'
		mov	[ebp+var_D0], edx
		jmp	short loc_2B79
; ---------------------------------------------------------------------------

loc_2B6F:				; CODE XREF: icu_56::VisibleDigitsWithExponent::getExponent(void)+2Fj
		mov	[ebp+var_D0], 0

loc_2B79:				; CODE XREF: icu_56::VisibleDigitsWithExponent::getExponent(void)+3Dj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getExponent@VisibleDigitsWithExponent@icu_56@@QBEPBVVisibleDigits@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::VisibleDigitsWithExponent::clear(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ?clear@VisibleDigitsWithExponent@icu_56@@QAEXXZ
?clear@VisibleDigitsWithExponent@icu_56@@QAEXXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?clear@VisibleDigits@icu_56@@AAEXXZ ; icu_56::VisibleDigits::clear(void)
		mov	ecx, [ebp+var_8]
		add	ecx, 68h ; 'h'  ; this
		call	?clear@VisibleDigits@icu_56@@AAEXXZ ; icu_56::VisibleDigits::clear(void)
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0D0h], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clear@VisibleDigitsWithExponent@icu_56@@QAEXXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::VisibleDigitsWithExponent::isNegative(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ?isNegative@VisibleDigitsWithExponent@icu_56@@QBECXZ
?isNegative@VisibleDigitsWithExponent@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isNegative@VisibleDigits@icu_56@@QBECXZ ; icu_56::VisibleDigits::isNegative(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isNegative@VisibleDigitsWithExponent@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::VisibleDigitsWithExponent::isNaN(icu_56::VisibleDigitsWithExponent *__hidden	this)
		public ?isNaN@VisibleDigitsWithExponent@icu_56@@QBECXZ
?isNaN@VisibleDigitsWithExponent@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isNaN@VisibleDigits@icu_56@@QBECXZ ; icu_56::VisibleDigits::isNaN(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isNaN@VisibleDigitsWithExponent@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::VisibleDigitsWithExponent::isInfinite(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ?isInfinite@VisibleDigitsWithExponent@icu_56@@QBECXZ
?isInfinite@VisibleDigitsWithExponent@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isInfinite@VisibleDigits@icu_56@@QBECXZ ; icu_56::VisibleDigits::isInfinite(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isInfinite@VisibleDigitsWithExponent@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ??1VisibleDigitsWithExponent@icu_56@@QAE@XZ
??1VisibleDigitsWithExponent@icu_56@@QAE@XZ proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 68h ; 'h'  ; this
		call	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1VisibleDigitsWithExponent@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2D20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00002D4Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
__unwindfunclet$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ	proc near
					; DATA XREF: icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2D48h
__unwindtable$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002D58o
		dd offset __unwindfunclet$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ$0
__ehfuncinfo$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::PluralRules::getStaticClassID()
		public ?getStaticClassID@PluralRules@icu_56@@SAPAXXZ
?getStaticClassID@PluralRules@icu_56@@SAPAXXZ proc near
					; CODE XREF: icu_56::PluralRules::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@PluralRules@icu_56@@SAPAXXZ@4DA ; char `icu_56::PluralRules::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@PluralRules@icu_56@@SAPAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::PluralRules::getDynamicClassID(icu_56::PluralRules *__hidden	this)
		public ?getDynamicClassID@PluralRules@icu_56@@UBEPAXXZ
?getDynamicClassID@PluralRules@icu_56@@UBEPAXXZ	proc near ; DATA XREF: .rdata:00002EB0o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@PluralRules@icu_56@@SAPAXXZ ;	icu_56::PluralRules::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@PluralRules@icu_56@@UBEPAXXZ	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::PluralKeywordEnumeration::getStaticClassID()
		public ?getStaticClassID@PluralKeywordEnumeration@icu_56@@SAPAXXZ
?getStaticClassID@PluralKeywordEnumeration@icu_56@@SAPAXXZ proc	near
					; CODE XREF: icu_56::PluralKeywordEnumeration::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@PluralKeywordEnumeration@icu_56@@SAPAXXZ@4DA ; char `icu_56::PluralKeywordEnumeration::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@PluralKeywordEnumeration@icu_56@@SAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::PluralKeywordEnumeration::getDynamicClassID(icu_56::PluralKeywordEnumeration	*__hidden this)
		public ?getDynamicClassID@PluralKeywordEnumeration@icu_56@@UBEPAXXZ
?getDynamicClassID@PluralKeywordEnumeration@icu_56@@UBEPAXXZ proc near
					; DATA XREF: .rdata:0000AA10o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@PluralKeywordEnumeration@icu_56@@SAPAXXZ ; icu_56::PluralKeywordEnumeration::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@PluralKeywordEnumeration@icu_56@@UBEPAXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralRules::PluralRules(icu_56::PluralRules *this,	enum UErrorCode	*)
		public ??0PluralRules@icu_56@@QAE@AAW4UErrorCode@@@Z
??0PluralRules@icu_56@@QAE@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+9Cp
					; icu_56::PluralRules::internalForLocale(icu_56::Locale	const &,UPluralType,UErrorCode &)+A6p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7PluralRules@icu_56@@6B@ ; const icu_56::PluralRules::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0PluralRules@icu_56@@QAE@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2EA8h
		dd offset ??_R4PluralRules@icu_56@@6B@ ; const icu_56::PluralRules::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7PluralRules@icu_56@@6B@
; const	icu_56::PluralRules::`vftable'
??_7PluralRules@icu_56@@6B@ dd offset ??_EPluralRules@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::PluralRules::PluralRules(UErrorCode &)+38o
					; icu_56::PluralRules::PluralRules(icu_56::PluralRules const &)+62o ...
					; icu_56::PluralRules::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@PluralRules@icu_56@@UBEPAXXZ ; icu_56::PluralRules::getDynamicClassID(void)
		dd offset ??8PluralRules@icu_56@@UBECABV01@@Z ;	icu_56::PluralRules::operator==(icu_56::PluralRules const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2EB8h
		public ??_R4PluralRules@icu_56@@6B@
; const	icu_56::PluralRules::`RTTI Complete Object Locator'
??_R4PluralRules@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00002EA8o
		dd offset ??_R0?AVPluralRules@icu_56@@@8 ; icu_56::PluralRules `RTTI Type Descriptor'
		dd offset ??_R3PluralRules@icu_56@@8 ; icu_56::PluralRules::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2ECCh
		public ??_R0?AVPluralRules@icu_56@@@8
; class	icu_56::PluralRules `RTTI Type Descriptor'
??_R0?AVPluralRules@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00002EC4o
					; .rdata$r:icu_56::PluralRules::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avpluralrule	db '.?AVPluralRules@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2EF0h
		public ??_R3PluralRules@icu_56@@8
; icu_56::PluralRules::`RTTI Class Hierarchy Descriptor'
??_R3PluralRules@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00002EC8o
					; .rdata$r:00002F28o
		dd 3
		dd offset ??_R2PluralRules@icu_56@@8 ; icu_56::PluralRules::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2F00h
		public ??_R2PluralRules@icu_56@@8
; icu_56::PluralRules::`RTTI Base Class	Array'
??_R2PluralRules@icu_56@@8 dd offset ??_R1A@?0A@EA@PluralRules@icu_56@@8
					; DATA XREF: .rdata$r:00002EFCo
					; icu_56::PluralRules::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2F10h
		public ??_R1A@?0A@EA@PluralRules@icu_56@@8
; icu_56::PluralRules::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@PluralRules@icu_56@@8 dd offset ??_R0?AVPluralRules@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::PluralRules::`RTTI Base Class Array'o
					; icu_56::PluralRules `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3PluralRules@icu_56@@8 ; icu_56::PluralRules::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralRules::PluralRules(icu_56::PluralRules *this,	const struct icu_56::PluralRules *)
		public ??0PluralRules@icu_56@@QAE@ABV01@@Z
??0PluralRules@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::PluralRules::clone(void)+76p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0PluralRules@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7PluralRules@icu_56@@6B@ ; const icu_56::PluralRules::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_14]
		call	??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::PluralRules::operator=(icu_56::PluralRules const &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0PluralRules@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2FD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0PluralRules@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:0000300Co
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0PluralRules@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0PluralRules@icu_56@@QAE@ABV01@@Z	proc near
					; DATA XREF: icu_56::PluralRules::PluralRules(icu_56::PluralRules const	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)

loc_2FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		mov	eax, offset __ehfuncinfo$??0PluralRules@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0PluralRules@icu_56@@QAE@ABV01@@Z	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3008h
__unwindtable$??0PluralRules@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003018o
		dd offset __unwindfunclet$??0PluralRules@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0PluralRules@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0PluralRules@icu_56@@QAE@ABV01@@Z:loc_2FFEo
		dd offset __unwindtable$??0PluralRules@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3034h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralRules::~PluralRules(icu_56::PluralRules *__hidden this)
		public ??1PluralRules@icu_56@@UAE@XZ
??1PluralRules@icu_56@@UAE@XZ proc near	; CODE XREF: icu_56::PluralRules::`scalar deleting destructor'(uint)+26p
					; icu_56::PluralRules::`vector deleting	destructor'(uint)+6Ep
					; DATA XREF: ...

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1PluralRules@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7PluralRules@icu_56@@6B@ ; const icu_56::PluralRules::`vftable'
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_30CC
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_30D6
; ---------------------------------------------------------------------------

loc_30CC:				; CODE XREF: icu_56::PluralRules::~PluralRules(void)+71j
		mov	[ebp+var_F4], 0

loc_30D6:				; CODE XREF: icu_56::PluralRules::~PluralRules(void)+96j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1PluralRules@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3110h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1PluralRules@icu_56@@UAE@XZ$0	proc near ; DATA XREF: .xdata$x:00003144o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1PluralRules@icu_56@@UAE@XZ$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1PluralRules@icu_56@@UAE@XZ proc near
					; DATA XREF: icu_56::PluralRules::~PluralRules(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1PluralRules@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1PluralRules@icu_56@@UAE@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3140h
__unwindtable$??1PluralRules@icu_56@@UAE@XZ dd 0FFFFFFFFh ; DATA XREF: .xdata$x:00003150o
		dd offset __unwindfunclet$??1PluralRules@icu_56@@UAE@XZ$0
__ehfuncinfo$??1PluralRules@icu_56@@UAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1PluralRules@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1PluralRules@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 316Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SharedPluralRules::~SharedPluralRules(icu_56::SharedPluralRules *__hidden this)
		public ??1SharedPluralRules@icu_56@@UAE@XZ
??1SharedPluralRules@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::SharedPluralRules::`scalar	deleting destructor'(uint)+26p
					; icu_56::SharedPluralRules::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1SharedPluralRules@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7SharedPluralRules@icu_56@@6B@ ; const icu_56::SharedPluralRules::`vftable'
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_3204
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_320E
; ---------------------------------------------------------------------------

loc_3204:				; CODE XREF: icu_56::SharedPluralRules::~SharedPluralRules(void)+71j
		mov	[ebp+var_F4], 0

loc_320E:				; CODE XREF: icu_56::SharedPluralRules::~SharedPluralRules(void)+96j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1SharedObject@icu_56@@UAE@XZ ; icu_56::SharedObject::~SharedObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1SharedPluralRules@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3248h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1SharedPluralRules@icu_56@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:0000327Co
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1SharedObject@icu_56@@UAE@XZ ; icu_56::SharedObject::~SharedObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1SharedPluralRules@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1SharedPluralRules@icu_56@@UAE@XZ	proc near
					; DATA XREF: icu_56::SharedPluralRules::~SharedPluralRules(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1SharedPluralRules@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1SharedPluralRules@icu_56@@UAE@XZ	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3278h
__unwindtable$??1SharedPluralRules@icu_56@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003288o
		dd offset __unwindfunclet$??1SharedPluralRules@icu_56@@UAE@XZ$0
__ehfuncinfo$??1SharedPluralRules@icu_56@@UAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1SharedPluralRules@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1SharedPluralRules@icu_56@@UAE@XZ
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::PluralRules *__thiscall icu_56::PluralRules::clone(icu_56::PluralRules	*__hidden this)
		public ?clone@PluralRules@icu_56@@QBEPAV12@XZ
?clone@PluralRules@icu_56@@QBEPAV12@XZ proc near
					; CODE XREF: icu_56::PluralRules::forLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+74p

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?clone@PluralRules@icu_56@@QBEPAV12@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		push	8		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_3327
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::PluralRules *
		mov	ecx, [ebp+var_E0] ; this
		call	??0PluralRules@icu_56@@QAE@ABV01@@Z ; icu_56::PluralRules::PluralRules(icu_56::PluralRules const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_3331
; ---------------------------------------------------------------------------

loc_3327:				; CODE XREF: icu_56::PluralRules::clone(void)+6Aj
		mov	[ebp+var_F4], 0

loc_3331:				; CODE XREF: icu_56::PluralRules::clone(void)+81j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_EC]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clone@PluralRules@icu_56@@QBEPAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 336Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?clone@PluralRules@icu_56@@QBEPAV12@XZ$0 proc near
					; DATA XREF: .xdata$x:000033A8o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?clone@PluralRules@icu_56@@QBEPAV12@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?clone@PluralRules@icu_56@@QBEPAV12@XZ proc	near
					; DATA XREF: icu_56::PluralRules::clone(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?clone@PluralRules@icu_56@@QBEPAV12@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?clone@PluralRules@icu_56@@QBEPAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 33A4h
__unwindtable$?clone@PluralRules@icu_56@@QBEPAV12@XZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:000033B4o
		dd offset __unwindfunclet$?clone@PluralRules@icu_56@@QBEPAV12@XZ$0
__ehfuncinfo$?clone@PluralRules@icu_56@@QBEPAV12@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?clone@PluralRules@icu_56@@QBEPAV12@XZ+14o
		dd offset __unwindtable$?clone@PluralRules@icu_56@@QBEPAV12@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 33D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::PluralRules & __thiscall icu_56::PluralRules::operator=(class icu_56::PluralRules const	&)
		public ??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z
??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::PluralRules::PluralRules(icu_56::PluralRules const	&)+79p

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jz	loc_34F3
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]
		mov	[ebp+var_F8], ecx
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_104], edx
		cmp	[ebp+var_104], 0
		jz	short loc_3464
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_104]
		mov	edx, [eax]
		mov	ecx, [ebp+var_104]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_346E
; ---------------------------------------------------------------------------

loc_3464:				; CODE XREF: icu_56::PluralRules::operator=(icu_56::PluralRules	const &)+6Dj
		mov	[ebp+var_10C], 0

loc_346E:				; CODE XREF: icu_56::PluralRules::operator=(icu_56::PluralRules	const &)+92j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_3483
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		jmp	short loc_34F3
; ---------------------------------------------------------------------------

loc_3483:				; CODE XREF: icu_56::PluralRules::operator=(icu_56::PluralRules	const &)+A5j
		mov	esi, esp
		push	0D0h ; ''      ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_34CA
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx		; struct icu_56::RuleChain *
		mov	ecx, [ebp+var_E0] ; this
		call	??0RuleChain@icu_56@@QAE@ABV01@@Z ; icu_56::RuleChain::RuleChain(icu_56::RuleChain const &)
		mov	[ebp+var_10C], eax
		jmp	short loc_34D4
; ---------------------------------------------------------------------------

loc_34CA:				; CODE XREF: icu_56::PluralRules::operator=(icu_56::PluralRules	const &)+DEj
		mov	[ebp+var_10C], 0

loc_34D4:				; CODE XREF: icu_56::PluralRules::operator=(icu_56::PluralRules	const &)+F8j
		mov	edx, [ebp+var_10C]
		mov	[ebp+var_EC], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_EC]
		mov	[eax+4], ecx

loc_34F3:				; CODE XREF: icu_56::PluralRules::operator=(icu_56::PluralRules	const &)+48j
					; icu_56::PluralRules::operator=(icu_56::PluralRules const &)+B1j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3518h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z$0 proc	near
					; DATA XREF: .xdata$x:00003554o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z proc near
					; DATA XREF: icu_56::PluralRules::operator=(icu_56::PluralRules	const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3550h
__unwindtable$??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003560o
		dd offset __unwindfunclet$??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z+14o
		dd offset __unwindtable$??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 357Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::StringEnumeration *__cdecl icu_56::PluralRules::getAvailableLocales(enum UErrorCode *)
		public ?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z
?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z proc near

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	esi, esp
		push	78h ; 'x'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_F8], 0
		jz	short loc_35FA
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_F8] ; this
		call	??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &)
		mov	[ebp+var_10C], eax
		jmp	short loc_3604
; ---------------------------------------------------------------------------

loc_35FA:				; CODE XREF: icu_56::PluralRules::getAvailableLocales(UErrorCode &)+65j
		mov	[ebp+var_10C], 0

loc_3604:				; CODE XREF: icu_56::PluralRules::getAvailableLocales(UErrorCode &)+7Cj
		mov	ecx, [ebp+var_10C]
		mov	[ebp+var_104], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_104]
		mov	[ebp+var_14], edx
		cmp	[ebp+var_14], 0
		jnz	short loc_3644
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3644
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7

loc_3644:				; CODE XREF: icu_56::PluralRules::getAvailableLocales(UErrorCode &)+A8j
					; icu_56::PluralRules::getAvailableLocales(UErrorCode &)+BDj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_36AD
		mov	eax, [ebp+var_14]
		mov	[ebp+var_E0], eax
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_EC], ecx
		cmp	[ebp+var_EC], 0
		jz	short loc_369C
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_EC]
		mov	eax, [edx]
		mov	ecx, [ebp+var_EC]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_36A6
; ---------------------------------------------------------------------------

loc_369C:				; CODE XREF: icu_56::PluralRules::getAvailableLocales(UErrorCode &)+F9j
		mov	[ebp+var_10C], 0

loc_36A6:				; CODE XREF: icu_56::PluralRules::getAvailableLocales(UErrorCode &)+11Ej
		mov	[ebp+var_14], 0

loc_36AD:				; CODE XREF: icu_56::PluralRules::getAvailableLocales(UErrorCode &)+DBj
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 36D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000370Co
		mov	esi, esp
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::PluralRules::getAvailableLocales(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3708h
__unwindtable$?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003718o
		dd offset __unwindfunclet$?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?getAvailableLocales@PluralRules@icu_56@@SAPAVStringEnumeration@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3734h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::PluralRules::getAvailableLocales(UErrorCode &)+CEp
					; icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+46p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3760h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::PluralRules *__cdecl icu_56::PluralRules::createRules(const struct icu_56::UnicodeString *, enum UErrorCode *)
		public ?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z
?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralRules::createDefaultRules(UErrorCode	&)+82p

var_188		= dword	ptr -188h
var_180		= dword	ptr -180h
var_174		= dword	ptr -174h
var_168		= dword	ptr -168h
var_15C		= dword	ptr -15Ch
var_150		= dword	ptr -150h
var_84		= dword	ptr -84h
var_78		= byte ptr -78h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 17Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_188]
		mov	ecx, 5Fh ; '_'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_37BC
		xor	eax, eax
		jmp	loc_38FD
; ---------------------------------------------------------------------------

loc_37BC:				; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+53j
		lea	ecx, [ebp+var_78] ; this
		call	??0PluralRuleParser@icu_56@@QAE@XZ ; icu_56::PluralRuleParser::PluralRuleParser(void)
		mov	[ebp+var_4], 0
		mov	esi, esp
		push	8		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_174], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_174], 0
		jz	short loc_3809
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_174] ; this
		call	??0PluralRules@icu_56@@QAE@AAW4UErrorCode@@@Z ;	icu_56::PluralRules::PluralRules(UErrorCode &)
		mov	[ebp+var_188], eax
		jmp	short loc_3813
; ---------------------------------------------------------------------------

loc_3809:				; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+90j
		mov	[ebp+var_188], 0

loc_3813:				; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+A7j
		mov	ecx, [ebp+var_188]
		mov	[ebp+var_180], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	edx, [ebp+var_180]
		mov	[ebp+var_84], edx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3856
		cmp	[ebp+var_84], 0
		jnz	short loc_3856
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7

loc_3856:				; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+E2j
					; icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+EBj
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_84]
		push	ecx		; struct icu_56::PluralRules *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_78] ; this
		call	?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z ; icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_38DC
		mov	eax, [ebp+var_84]
		mov	[ebp+var_15C], eax
		mov	ecx, [ebp+var_15C]
		mov	[ebp+var_168], ecx
		cmp	[ebp+var_168], 0
		jz	short loc_38C8
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_168]
		mov	eax, [edx]
		mov	ecx, [ebp+var_168]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_188], eax
		jmp	short loc_38D2
; ---------------------------------------------------------------------------

loc_38C8:				; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+141j
		mov	[ebp+var_188], 0

loc_38D2:				; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+166j
		mov	[ebp+var_84], 0

loc_38DC:				; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+120j
		mov	eax, [ebp+var_84]
		mov	[ebp+var_150], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_78] ; this
		call	??1PluralRuleParser@icu_56@@UAE@XZ ; icu_56::PluralRuleParser::~PluralRuleParser(void)
		mov	eax, [ebp+var_150]

loc_38FD:				; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+57j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN15
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 188h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN15		dd 1			; DATA XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+1A1o
		dd offset $LN14
$LN14		db 88h,	0FFh		; DATA XREF: .text:0000393Co
		dw 0FFFFh
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd offset $LN12		; "parser"
$LN12		db 'parser',0           ; DATA XREF: .text:00003948o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3954h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000039A4o
		lea	ecx, [ebp-78h]	; this
		jmp	??1PluralRuleParser@icu_56@@UAE@XZ ; icu_56::PluralRuleParser::~PluralRuleParser(void)
__unwindfunclet$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:000039ACo
		mov	esi, esp
		mov	eax, [ebp-174h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z proc	near
					; DATA XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-18Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 39A0h
__unwindtable$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:000039B8o
		dd offset __unwindfunclet$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::PluralRules *__cdecl icu_56::PluralRules::createDefaultRules(enum UErrorCode *)
		public ?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z
?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z proc	near

var_12C		= dword	ptr -12Ch
var_128		= dword	ptr -128h
var_120		= dword	ptr -120h
var_114		= byte ptr -114h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_12C]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset _PLURAL_DEFAULT_RULE ; "other: n"
		push	1		; signed __int8
		lea	ecx, [ebp+var_114] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_128], eax
		mov	ecx, [ebp+var_128]
		mov	[ebp+var_12C], ecx
		mov	[ebp+var_4], 0
		mov	edx, [ebp+var_12C]
		push	edx		; struct icu_56::UnicodeString *
		call	?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::PluralRules::createRules(icu_56::UnicodeString	const &,UErrorCode &)
		add	esp, 8
		mov	[ebp+var_120], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_114] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_120]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 12Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3AB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00003AF4o
		mov	esi, esp
		lea	ecx, [ebp-114h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::PluralRules::createDefaultRules(UErrorCode	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-130h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3AF0h
__unwindtable$?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003B00o
		dd offset __unwindfunclet$?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?createDefaultRules@PluralRules@icu_56@@SAPAV12@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	icu_56::SharedPluralRules const	* __thiscall icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::createObject(void	const *, enum  UErrorCode &)const
		public ?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z
?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z proc	near
					; DATA XREF: .rdata:0000CE3Co

var_208		= dword	ptr -208h
var_200		= dword	ptr -200h
var_1F4		= dword	ptr -1F4h
var_1E8		= dword	ptr -1E8h
var_1DC		= dword	ptr -1DCh
var_1D0		= byte ptr -1D0h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1FCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_208]
		mov	ecx, 7Fh ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	ecx, [ebp+var_18]
		add	ecx, 0Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_?getName@Locale@icu_56@@QBEPBDXZ ; icu_56::Locale::getName(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_24], eax
		mov	esi, esp
		push	0		; char *
		push	0		; char *
		push	0		; char *
		mov	eax, [ebp+var_24]
		push	eax		; char *
		lea	ecx, [ebp+var_1D0] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@PBD000@Z ; icu_56::Locale::Locale(char	const *,char const *,char const	*,char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+arg_4]
		push	ecx
		push	0
		lea	edx, [ebp+var_1D0]
		push	edx
		call	?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z ; icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)
		add	esp, 0Ch
		mov	[ebp+var_30], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_1D0] ; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3BEF
		xor	eax, eax
		jmp	loc_3CCB
; ---------------------------------------------------------------------------

loc_3BEF:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+CAj
		mov	esi, esp
		push	18h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1F4], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_1F4], 0
		jz	short loc_3C30
		mov	eax, [ebp+var_30]
		push	eax		; struct icu_56::PluralRules *
		mov	ecx, [ebp+var_1F4] ; this
		call	??0SharedPluralRules@icu_56@@QAE@PAVPluralRules@1@@Z ; icu_56::SharedPluralRules::SharedPluralRules(icu_56::PluralRules	*)
		mov	[ebp+var_208], eax
		jmp	short loc_3C3A
; ---------------------------------------------------------------------------

loc_3C30:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+FBj
		mov	[ebp+var_208], 0

loc_3C3A:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+112j
		mov	ecx, [ebp+var_208]
		mov	[ebp+var_200], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_200]
		mov	[ebp+var_3C], edx
		cmp	[ebp+var_3C], 0
		jnz	short loc_3CB6
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_30]
		mov	[ebp+var_1DC], eax
		mov	ecx, [ebp+var_1DC]
		mov	[ebp+var_1E8], ecx
		cmp	[ebp+var_1E8], 0
		jz	short loc_3CA8
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_1E8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_1E8]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_208], eax
		jmp	short loc_3CB2
; ---------------------------------------------------------------------------

loc_3CA8:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+165j
		mov	[ebp+var_208], 0

loc_3CB2:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+18Aj
		xor	eax, eax
		jmp	short loc_3CCB
; ---------------------------------------------------------------------------

loc_3CB6:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+13Ej
		mov	esi, esp
		mov	ecx, [ebp+var_3C] ; this
		call	dword ptr ds:__imp_?addRef@SharedObject@icu_56@@QBEXXZ ; icu_56::SharedObject::addRef(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_3C]

loc_3CCB:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+CEj
					; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const *,UErrorCode &)+198j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 208h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3CF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00003D54o
		mov	esi, esp
		lea	ecx, [ebp-1D0h]	; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00003D5Co
		mov	esi, esp
		mov	eax, [ebp-1F4h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-20Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3D50h
__unwindtable$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003D68o
		dd offset __unwindfunclet$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z$1
__ehfuncinfo$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z	dd 19930522h, 2
					; DATA XREF: __ehhandler$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static class icu_56::SharedPluralRules const * __cdecl icu_56::PluralRules::createSharedInstance(class icu_56::Locale	const &, enum  UPluralType, enum  UErrorCode &)
		public ?createSharedInstance@PluralRules@icu_56@@SAPBVSharedPluralRules@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z
?createSharedInstance@PluralRules@icu_56@@SAPBVSharedPluralRules@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralRules::forLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3DBB
		xor	eax, eax
		jmp	short loc_3DEC
; ---------------------------------------------------------------------------

loc_3DBB:				; CODE XREF: icu_56::PluralRules::createSharedInstance(icu_56::Locale const &,UPluralType,UErrorCode &)+31j
		cmp	[ebp+arg_4], 0
		jz	short loc_3DCE
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 10h
		xor	eax, eax
		jmp	short loc_3DEC
; ---------------------------------------------------------------------------

loc_3DCE:				; CODE XREF: icu_56::PluralRules::createSharedInstance(icu_56::Locale const &,UPluralType,UErrorCode &)+3Bj
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_8]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::Locale	*
		call	??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z ; icu_56::UnifiedCache::getByLocale<icu_56::SharedPluralRules>(icu_56::Locale const &,icu_56::SharedPluralRules const * &,UErrorCode	&)
		add	esp, 0Ch
		mov	eax, [ebp+var_8]

loc_3DEC:				; CODE XREF: icu_56::PluralRules::createSharedInstance(icu_56::Locale const &,UPluralType,UErrorCode &)+35j
					; icu_56::PluralRules::createSharedInstance(icu_56::Locale const &,UPluralType,UErrorCode &)+48j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?createSharedInstance@PluralRules@icu_56@@SAPBVSharedPluralRules@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7		dd 1			; DATA XREF: icu_56::PluralRules::createSharedInstance(icu_56::Locale const &,UPluralType,UErrorCode &)+6Co
		dd offset $LN6
$LN6		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00003E18o
		dd offset $LN5		; "result"
$LN5		db 'result',0           ; DATA XREF: .text:00003E24o
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::PluralRules *__cdecl icu_56::PluralRules::forLocale(const struct icu_56::Locale *, enum UErrorCode *)
		public ?forLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@AAW4UErrorCode@@@Z
?forLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@AAW4UErrorCode@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?forLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z ; icu_56::PluralRules::forLocale(icu_56::Locale const &,UPluralType,UErrorCode &)
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?forLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@AAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static class icu_56::PluralRules * __cdecl icu_56::PluralRules::forLocale(class icu_56::Locale const &, enum	UPluralType, enum  UErrorCode &)
		public ?forLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z
?forLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralRules::forLocale(icu_56::Locale const &,UErrorCode &)+28p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jz	short loc_3EAE
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z ; icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)
		add	esp, 0Ch
		jmp	short loc_3F14
; ---------------------------------------------------------------------------

loc_3EAE:				; CODE XREF: icu_56::PluralRules::forLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+22j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?createSharedInstance@PluralRules@icu_56@@SAPBVSharedPluralRules@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z ; icu_56::PluralRules::createSharedInstance(icu_56::Locale const &,UPluralType,UErrorCode &)
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3EDE
		xor	eax, eax
		jmp	short loc_3F14
; ---------------------------------------------------------------------------

loc_3EDE:				; CODE XREF: icu_56::PluralRules::forLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+64j
		mov	ecx, [ebp+var_8]
		call	??CSharedPluralRules@icu_56@@QBEPBVPluralRules@1@XZ ; icu_56::SharedPluralRules::operator->(void)
		mov	ecx, eax	; this
		call	?clone@PluralRules@icu_56@@QBEPAV12@XZ ; icu_56::PluralRules::clone(void)
		mov	[ebp+var_14], eax
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_?removeRef@SharedObject@icu_56@@QBEXXZ ; icu_56::SharedObject::removeRef(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_14], 0
		jnz	short loc_3F11
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7

loc_3F11:				; CODE XREF: icu_56::PluralRules::forLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+92j
		mov	eax, [ebp+var_14]

loc_3F14:				; CODE XREF: icu_56::PluralRules::forLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+38j
					; icu_56::PluralRules::forLocale(icu_56::Locale	const &,UPluralType,UErrorCode &)+68j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?forLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static class icu_56::PluralRules * __cdecl icu_56::PluralRules::internalForLocale(class icu_56::Locale const &, enum	UPluralType, enum  UErrorCode &)
		public ?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z
?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+90p
					; icu_56::PluralRules::forLocale(icu_56::Locale	const &,UPluralType,UErrorCode &)+30p

var_21C		= dword	ptr -21Ch
var_218		= dword	ptr -218h
var_210		= dword	ptr -210h
var_204		= dword	ptr -204h
var_1F8		= dword	ptr -1F8h
var_1EC		= dword	ptr -1ECh
var_1E0		= dword	ptr -1E0h
var_1D4		= byte ptr -1D4h
var_CC		= byte ptr -0CCh
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 210h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_21C]
		mov	ecx, 84h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3F84
		xor	eax, eax
		jmp	loc_416D
; ---------------------------------------------------------------------------

loc_3F84:				; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+53j
		cmp	[ebp+arg_4], 2
		jl	short loc_3F9A
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_416D
; ---------------------------------------------------------------------------

loc_3F9A:				; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+60j
		mov	esi, esp
		push	8		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_204], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_204], 0
		jz	short loc_3FDB
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_204] ; this
		call	??0PluralRules@icu_56@@QAE@AAW4UErrorCode@@@Z ;	icu_56::PluralRules::PluralRules(UErrorCode &)
		mov	[ebp+var_218], eax
		jmp	short loc_3FE5
; ---------------------------------------------------------------------------

loc_3FDB:				; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+9Aj
		mov	[ebp+var_218], 0

loc_3FE5:				; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+B1j
		mov	ecx, [ebp+var_218]
		mov	[ebp+var_210], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_210]

loc_3FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		mov	[ebp+var_18], edx
		cmp	[ebp+var_18], 0
		jz	short loc_401C
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4070

loc_401C:				; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+DDj
		mov	eax, [ebp+var_18]
		mov	[ebp+var_1EC], eax
		mov	ecx, [ebp+var_1EC]
		mov	[ebp+var_1F8], ecx
		cmp	[ebp+var_1F8], 0
		jz	short loc_405F
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_1F8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_1F8]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_218], eax
		jmp	short loc_4069
; ---------------------------------------------------------------------------

loc_405F:				; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+110j
		mov	[ebp+var_218], 0

loc_4069:				; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+135j
		xor	eax, eax
		jmp	loc_416D
; ---------------------------------------------------------------------------

loc_4070:				; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+F2j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+var_18]
		call	?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z ; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)
		mov	[ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_4110
		mov	esi, esp
		push	offset _PLURAL_DEFAULT_RULE ; "other: n"
		lea	ecx, [ebp+var_1D4] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PB_W@Z ; icu_56::UnicodeString::UnicodeString(wchar_t const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_218], eax
		mov	eax, [ebp+var_218]
		mov	[ebp+var_21C], eax
		mov	byte ptr [ebp+var_4], 2
		mov	esi, esp
		mov	ecx, [ebp+var_21C]
		push	ecx
		lea	ecx, [ebp+var_60]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z	; icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_1D4] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0

loc_4110:				; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+17Bj
		lea	ecx, [ebp+var_CC] ; this
		call	??0PluralRuleParser@icu_56@@QAE@XZ ; icu_56::PluralRuleParser::PluralRuleParser(void)
		mov	byte ptr [ebp+var_4], 3
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_18]
		push	ecx		; struct icu_56::PluralRules *
		lea	edx, [ebp+var_60]
		push	edx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_CC] ; this
		call	?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z ; icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)
		mov	eax, [ebp+var_18]
		mov	[ebp+var_1E0], eax
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_CC] ; this
		call	??1PluralRuleParser@icu_56@@UAE@XZ ; icu_56::PluralRuleParser::~PluralRuleParser(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_1E0]

loc_416D:				; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+57j
					; icu_56::PluralRules::internalForLocale(icu_56::Locale	const &,UPluralType,UErrorCode &)+6Dj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN20
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 21Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN20		dd 2			; DATA XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+249o
		dd offset $LN19
$LN19		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:000041ACo
		dd offset $LN16		; "locRule"
		dd 0FFFFFF34h, 64h
		dd offset $LN17		; "parser"
$LN17		db 'parser',0           ; DATA XREF: .text:000041C4o
$LN16		db 'locRule',0          ; DATA XREF: .text:000041B8o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 41D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00004250o
		mov	esi, esp
		mov	eax, [ebp-204h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00004258o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00004260o
		mov	esi, esp
		lea	ecx, [ebp-1D4h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:00004268o
		lea	ecx, [ebp-0CCh]	; this
		jmp	??1PluralRuleParser@icu_56@@UAE@XZ ; icu_56::PluralRuleParser::~PluralRuleParser(void)
__unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-220h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 424Ch
__unwindtable$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004274o
		dd offset __unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$2
		dd 1
		dd offset __unwindfunclet$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$3
__ehfuncinfo$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z dd 19930522h,	4
					; DATA XREF: __ehhandler$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?internalForLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4290h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::PluralRules::select(int)const
		public ?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@H@Z
?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@H@Z proc near

var_124		= qword	ptr -124h
var_110		= byte ptr -110h
var_10C		= byte ptr -10Ch
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 110h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_110]
		mov	ecx, 44h ; 'D'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		fild	[ebp+arg_4]
		sub	esp, 8
		fstp	[esp+124h+var_124] ; double
		lea	ecx, [ebp+var_10C] ; this
		call	??0FixedDecimal@icu_56@@QAE@N@Z	; icu_56::FixedDecimal::FixedDecimal(double)
		push	eax
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@ABVFixedDecimal@2@@Z ; icu_56::PluralRules::select(icu_56::FixedDecimal const	&)
		mov	ecx, [ebp+var_D4]
		or	ecx, 1
		mov	[ebp+var_D4], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 110h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4308h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::PluralRules::select(double)const
		public ?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@N@Z
?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@N@Z proc near

var_124		= qword	ptr -124h
var_110		= byte ptr -110h
var_10C		= byte ptr -10Ch
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= qword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 110h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_110]
		mov	ecx, 44h ; 'D'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		sub	esp, 8
		fld	[ebp+arg_4]
		fstp	[esp+124h+var_124] ; double
		lea	ecx, [ebp+var_10C] ; this
		call	??0FixedDecimal@icu_56@@QAE@N@Z	; icu_56::FixedDecimal::FixedDecimal(double)
		push	eax
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@ABVFixedDecimal@2@@Z ; icu_56::PluralRules::select(icu_56::FixedDecimal const	&)
		mov	ecx, [ebp+var_D4]
		or	ecx, 1
		mov	[ebp+var_D4], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 110h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@N@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4380h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::PluralRules::select(class icu_56::FixedDecimal	const &)const
		public ?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@ABVFixedDecimal@2@@Z
?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@ABVFixedDecimal@2@@Z proc near
					; CODE XREF: icu_56::PluralRules::select(int)+49p
					; icu_56::PluralRules::select(double)+49p ...

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_43E7
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset _PLURAL_DEFAULT_RULE ; "other: n"
		push	1		; signed __int8
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]
		jmp	short loc_440C
; ---------------------------------------------------------------------------
		jmp	short loc_440C
; ---------------------------------------------------------------------------

loc_43E7:				; CODE XREF: icu_56::PluralRules::select(icu_56::FixedDecimal const &)+34j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+4]
		call	?select@RuleChain@icu_56@@QBE?AVUnicodeString@2@ABVFixedDecimal@2@@Z ; icu_56::RuleChain::select(icu_56::FixedDecimal const &)
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]

loc_440C:				; CODE XREF: icu_56::PluralRules::select(icu_56::FixedDecimal const &)+63j
					; icu_56::PluralRules::select(icu_56::FixedDecimal const &)+65j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@ABVFixedDecimal@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4424h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::PluralRules::select(class icu_56::VisibleDigitsWithExponent const &)const
		public ?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@ABVVisibleDigitsWithExponent@2@@Z
?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@ABVVisibleDigitsWithExponent@2@@Z proc near

var_110		= byte ptr -110h
var_10C		= byte ptr -10Ch
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 110h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_110]
		mov	ecx, 44h ; 'D'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	ecx, [ebp+arg_4] ; this
		call	?getExponent@VisibleDigitsWithExponent@icu_56@@QBEPBVVisibleDigits@2@XZ	; icu_56::VisibleDigitsWithExponent::getExponent(void)
		test	eax, eax
		jz	short loc_448C
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset _PLURAL_DEFAULT_RULE ; "other: n"
		push	1		; signed __int8
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]
		jmp	short loc_44BF
; ---------------------------------------------------------------------------

loc_448C:				; CODE XREF: icu_56::PluralRules::select(icu_56::VisibleDigitsWithExponent const &)+37j
		mov	ecx, [ebp+arg_4] ; this
		call	?getMantissa@VisibleDigitsWithExponent@icu_56@@QBEABVVisibleDigits@2@XZ	; icu_56::VisibleDigitsWithExponent::getMantissa(void)
		push	eax		; struct icu_56::VisibleDigits *
		lea	ecx, [ebp+var_10C] ; this
		call	??0FixedDecimal@icu_56@@QAE@ABVVisibleDigits@1@@Z ; icu_56::FixedDecimal::FixedDecimal(icu_56::VisibleDigits const &)
		push	eax
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@ABVFixedDecimal@2@@Z ; icu_56::PluralRules::select(icu_56::FixedDecimal const	&)
		mov	ecx, [ebp+var_D4]
		or	ecx, 1
		mov	[ebp+var_D4], ecx
		mov	eax, [ebp+arg_0]

loc_44BF:				; CODE XREF: icu_56::PluralRules::select(icu_56::VisibleDigitsWithExponent const &)+66j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 110h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?select@PluralRules@icu_56@@QBE?AVUnicodeString@2@ABVVisibleDigitsWithExponent@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::StringEnumeration *__thiscall icu_56::PluralRules::getKeywords(icu_56::PluralRules *this, enum	UErrorCode *)
		public ?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z
?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+5Fp
					; icu_56::PluralRules::operator==(icu_56::PluralRules const &)+7Bp

var_118		= dword	ptr -118h
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4536
		xor	eax, eax
		jmp	loc_4610
; ---------------------------------------------------------------------------

loc_4536:				; CODE XREF: icu_56::PluralRules::getKeywords(UErrorCode &)+55j
		mov	esi, esp
		push	88h ; ''       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_104], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_104], 0
		jz	short loc_4581
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+4]
		push	edx		; struct icu_56::RuleChain *
		mov	ecx, [ebp+var_104] ; this
		call	??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z ; icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)
		mov	[ebp+var_118], eax
		jmp	short loc_458B
; ---------------------------------------------------------------------------

loc_4581:				; CODE XREF: icu_56::PluralRules::getKeywords(UErrorCode &)+89j
		mov	[ebp+var_118], 0

loc_458B:				; CODE XREF: icu_56::PluralRules::getKeywords(UErrorCode &)+A7j
		mov	eax, [ebp+var_118]
		mov	[ebp+var_110], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_110]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_460D
		mov	eax, [ebp+var_20]
		mov	[ebp+var_EC], eax
		mov	ecx, [ebp+var_EC]
		mov	[ebp+var_F8], ecx
		cmp	[ebp+var_F8], 0
		jz	short loc_45FF
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_F8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_F8]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_118], eax
		jmp	short loc_4609
; ---------------------------------------------------------------------------

loc_45FF:				; CODE XREF: icu_56::PluralRules::getKeywords(UErrorCode &)+100j
		mov	[ebp+var_118], 0

loc_4609:				; CODE XREF: icu_56::PluralRules::getKeywords(UErrorCode &)+125j
		xor	eax, eax
		jmp	short loc_4610
; ---------------------------------------------------------------------------

loc_460D:				; CODE XREF: icu_56::PluralRules::getKeywords(UErrorCode &)+E2j
		mov	eax, [ebp+var_20]

loc_4610:				; CODE XREF: icu_56::PluralRules::getKeywords(UErrorCode &)+59j
					; icu_56::PluralRules::getKeywords(UErrorCode &)+133j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4634h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:00004670o
		mov	esi, esp
		mov	eax, [ebp-104h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::PluralRules::getKeywords(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-11Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 466Ch
__unwindtable$?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000467Co
		dd offset __unwindfunclet$?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4698h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::PluralRules::getUniqueKeywordValue(icu_56::PluralRules *this, const	struct icu_56::UnicodeString *)
		public ?getUniqueKeywordValue@PluralRules@icu_56@@QAENABVUnicodeString@2@@Z
?getUniqueKeywordValue@PluralRules@icu_56@@QAENABVUnicodeString@2@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		fld	ds:__real@bf543a270c991e7f
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getUniqueKeywordValue@PluralRules@icu_56@@QAENABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 46CCh
		public __real@bf543a270c991e7f
__real@bf543a270c991e7f	dq -0.00123456777
					; DATA XREF: icu_56::PluralRules::getUniqueKeywordValue(icu_56::UnicodeString const &)+23r
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 46D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::PluralRules::getAllKeywordValues(icu_56::PluralRules *this, const struct icu_56::UnicodeString	*, double *, int, enum UErrorCode *)
		public ?getAllKeywordValues@PluralRules@icu_56@@QAEHABVUnicodeString@2@PANHAAW4UErrorCode@@@Z
?getAllKeywordValues@PluralRules@icu_56@@QAEHABVUnicodeString@2@PANHAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 10h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	10h
?getAllKeywordValues@PluralRules@icu_56@@QAEHABVUnicodeString@2@PANHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 470Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::PluralRules::getSamples(icu_56::PluralRules *this, const struct icu_56::UnicodeString *, double *, int, enum UErrorCode *)
		public ?getSamples@PluralRules@icu_56@@QAEHABVUnicodeString@2@PANHAAW4UErrorCode@@@Z
?getSamples@PluralRules@icu_56@@QAEHABVUnicodeString@2@PANHAAW4UErrorCode@@@Z proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?rulesForKeyword@PluralRules@icu_56@@ABEPAVRuleChain@2@ABVUnicodeString@2@@Z ; icu_56::PluralRules::rulesForKeyword(icu_56::UnicodeString const	&)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_475F
		cmp	[ebp+arg_8], 0
		jz	short loc_475F
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4763

loc_475F:				; CODE XREF: icu_56::PluralRules::getSamples(icu_56::UnicodeString const &,double *,int,UErrorCode &)+36j
					; icu_56::PluralRules::getSamples(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+3Cj
		xor	eax, eax
		jmp	short loc_47AA
; ---------------------------------------------------------------------------

loc_4763:				; CODE XREF: icu_56::PluralRules::getSamples(icu_56::UnicodeString const &,double *,int,UErrorCode &)+51j
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+var_14]
		add	eax, 8Ch ; ''
		push	eax		; icu_56::UnicodeString	*
		call	?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z ; icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)
		add	esp, 10h
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jnz	short loc_47A7
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+var_14]
		add	eax, 4Ch ; 'L'
		push	eax		; icu_56::UnicodeString	*
		call	?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z ; icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)
		add	esp, 10h
		mov	[ebp+var_20], eax

loc_47A7:				; CODE XREF: icu_56::PluralRules::getSamples(icu_56::UnicodeString const &,double *,int,UErrorCode &)+7Bj
		mov	eax, [ebp+var_20]

loc_47AA:				; CODE XREF: icu_56::PluralRules::getSamples(icu_56::UnicodeString const &,double *,int,UErrorCode &)+55j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?getSamples@PluralRules@icu_56@@QAEHABVUnicodeString@2@PANHAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 47C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::getSamplesFromString(icu_56::UnicodeString *, int, int, enum UErrorCode *)
?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::PluralRules::getSamples(icu_56::UnicodeString const &,double *,int,UErrorCode &)+6Cp
					; icu_56::PluralRules::getSamples(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+90p

var_31C		= qword	ptr -31Ch
var_304		= dword	ptr -304h
var_300		= dword	ptr -300h
var_2F8		= byte ptr -2F8h
var_2B0		= byte ptr -2B0h
var_1A8		= qword	ptr -1A8h
var_198		= qword	ptr -198h
var_188		= qword	ptr -188h
var_178		= qword	ptr -178h
var_168		= qword	ptr -168h
var_158		= qword	ptr -158h
var_148		= qword	ptr -148h
var_110		= qword	ptr -110h
var_108		= dword	ptr -108h
var_D8		= qword	ptr -0D8h
var_C8		= qword	ptr -0C8h
var_C0		= dword	ptr -0C0h
var_90		= dword	ptr -90h
var_84		= byte ptr -84h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 2F8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_304]
		mov	ecx, 0BEh ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], 0
		mov	[ebp+var_24], 0
		mov	[ebp+var_30], 0
		mov	[ebp+var_18], 0

loc_481C:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+41Cj
		mov	eax, [ebp+var_18]
		cmp	eax, [ebp+arg_8]
		jge	loc_4BE1
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_24], eax
		jge	loc_4BE1
		mov	esi, esp
		mov	eax, [ebp+var_24]
		push	eax		; int
		push	2Ch ; ','       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEH_WH@Z ; icu_56::UnicodeString::indexOf(wchar_t,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_30], eax
		cmp	[ebp+var_30], 0FFFFFFFFh
		jnz	short loc_4879
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_30], eax

loc_4879:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+A2j
		mov	esi, esp
		mov	eax, [ebp+var_30]
		push	eax
		mov	ecx, [ebp+var_24]
		push	ecx
		lea	edx, [ebp+var_84]
		push	edx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubStringBetween(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		lea	eax, [ebp+var_84]
		mov	[ebp+var_3C], eax
		mov	esi, esp
		push	7Eh ; '~'       ; wchar_t
		mov	ecx, [ebp+var_3C] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEH_W@Z ; icu_56::UnicodeString::indexOf(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_90], eax
		cmp	[ebp+var_90], 0
		jge	short loc_493F
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_3C]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_C8] ; this
		call	??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z ; icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode	&)
		fld	[ebp+var_C8]
		fstp	[ebp+var_D8]
		cmp	[ebp+var_C0], 0
		jz	short loc_4922
		mov	esi, esp
		sub	esp, 8
		fld	[ebp+var_D8]
		fstp	[esp+31Ch+var_31C]
		call	dword ptr ds:__imp__floor
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+var_D8]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jnp	short loc_493A

loc_4922:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+133j
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+arg_4]
		fld	[ebp+var_D8]
		fstp	qword ptr [ecx+eax*8]
		mov	edx, [ebp+var_18]
		add	edx, 1
		mov	[ebp+var_18], edx

loc_493A:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+160j
		jmp	loc_4BB7
; ---------------------------------------------------------------------------

loc_493F:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+10Bj
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	esi, esp
		mov	ecx, [ebp+var_90]
		push	ecx		; enum UErrorCode *
		push	0
		lea	edx, [ebp+var_2F8]
		push	edx
		mov	ecx, [ebp+var_3C]
		call	dword ptr ds:__imp_?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubStringBetween(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_300], eax
		mov	eax, [ebp+var_300]
		mov	[ebp+var_304], eax
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_304]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_110] ; this
		call	??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z ; icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode	&)
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_2F8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	esi, esp
		push	7FFFFFFFh
		mov	ecx, [ebp+var_90]
		add	ecx, 1
		push	ecx
		lea	edx, [ebp+var_2B0]
		push	edx
		mov	ecx, [ebp+var_3C]
		call	dword ptr ds:__imp_?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubStringBetween(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_300], eax
		mov	eax, [ebp+var_300]
		mov	[ebp+var_304], eax
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_304]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_148] ; this
		call	??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z ; icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode	&)
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_2B0] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+var_110]
		fstp	[ebp+var_158]
		fld	[ebp+var_148]
		fstp	[ebp+var_168]
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4A61
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_84] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_4BE1
; ---------------------------------------------------------------------------

loc_4A61:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+27Ej
		fld	[ebp+var_158]
		fcomp	[ebp+var_168]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_4A9E
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 3
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_84] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_4BE1
; ---------------------------------------------------------------------------

loc_4A9E:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+2B2j
		sub	esp, 8
		fld	[ebp+var_158]
		fstp	[esp+31Ch+var_31C] ; double
		call	?scaleForInt@icu_56@@YANN@Z ; icu_56::scaleForInt(double)
		add	esp, 8
		fstp	[ebp+var_178]
		sub	esp, 8
		fld	[ebp+var_168]
		fstp	[esp+31Ch+var_31C] ; double
		call	?scaleForInt@icu_56@@YANN@Z ; icu_56::scaleForInt(double)
		add	esp, 8
		fstp	[ebp+var_188]
		fld	[ebp+var_178]
		fcomp	[ebp+var_188]
		fnstsw	ax
		test	ah, 5
		jp	short loc_4AF1
		fld	[ebp+var_188]
		fstp	[ebp+var_178]

loc_4AF1:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+323j
		fld	[ebp+var_158]
		fmul	[ebp+var_178]
		fstp	[ebp+var_158]
		fld	[ebp+var_168]
		fmul	[ebp+var_178]
		fstp	[ebp+var_168]
		fld	[ebp+var_158]
		fstp	[ebp+var_198]
		jmp	short loc_4B35
; ---------------------------------------------------------------------------

loc_4B23:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&):loc_4BB2j
		fld	[ebp+var_198]
		fadd	ds:__real@3ff0000000000000
		fstp	[ebp+var_198]

loc_4B35:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+361j
		fld	[ebp+var_168]
		fcomp	[ebp+var_198]
		fnstsw	ax
		test	ah, 1
		jnz	short loc_4BB7
		fld	[ebp+var_198]
		fdiv	[ebp+var_178]
		fstp	[ebp+var_1A8]
		mov	esi, esp
		sub	esp, 8
		fld	[ebp+var_1A8]
		fstp	[esp+31Ch+var_31C]
		call	dword ptr ds:__imp__floor
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+var_1A8]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_4B90
		cmp	[ebp+var_108], 0
		jg	short loc_4BA8

loc_4B90:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+3C5j
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+arg_4]
		fld	[ebp+var_1A8]
		fstp	qword ptr [ecx+eax*8]
		mov	edx, [ebp+var_18]
		add	edx, 1
		mov	[ebp+var_18], edx

loc_4BA8:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+3CEj
		mov	eax, [ebp+var_18]
		cmp	eax, [ebp+arg_8]
		jl	short loc_4BB2
		jmp	short loc_4BB7
; ---------------------------------------------------------------------------

loc_4BB2:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+3EEj
		jmp	loc_4B23
; ---------------------------------------------------------------------------

loc_4BB7:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&):loc_493Aj
					; icu_56::getSamplesFromString(icu_56::UnicodeString const &,double *,int,UErrorCode &)+386j ...
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_24], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_84] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_481C
; ---------------------------------------------------------------------------

loc_4BE1:				; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+62j
					; icu_56::getSamplesFromString(icu_56::UnicodeString const &,double *,int,UErrorCode &)+7Dj ...
		mov	eax, [ebp+var_18]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN28
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 304h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN28		dd 4			; DATA XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+428o
		dd offset $LN27
$LN27		dd 0FFFFFF7Ch, 40h	; DATA XREF: .text:00004C24o
		dd offset $LN22		; "$S2"
		dd 0FFFFFF38h, 30h
		dd offset $LN23		; "fixed"
		dd 0FFFFFEF0h, 30h
		dd offset $LN24		; "fixedLo"
		dd 0FFFFFEB8h, 30h
		dd offset $LN25		; "fixedHi"
$LN25		db 'fixedHi',0          ; DATA XREF: .text:00004C54o
$LN24		db 'fixedLo',0          ; DATA XREF: .text:00004C48o
$LN23		db 'fixed',0            ; DATA XREF: .text:00004C3Co
$LN22		db '$S2',0              ; DATA XREF: .text:00004C30o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4C74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00004CE8o
		mov	esi, esp
		lea	ecx, [ebp-84h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00004CF0o
		mov	esi, esp
		lea	ecx, [ebp-2F8h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00004CF8o
		mov	esi, esp
		lea	ecx, [ebp-2B0h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-308h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 4CDCh
		public __real@3ff0000000000000
__real@3ff0000000000000	dq 1.0		; DATA XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+369r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4CE4h
__unwindtable$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004D04o
		dd offset __unwindfunclet$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z$0
		align 10h
		dd offset __unwindfunclet$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z$1
		align 8
		dd offset __unwindfunclet$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z$2
__ehfuncinfo$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z	dd 19930522h, 3
					; DATA XREF: __ehhandler$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?getSamplesFromString@icu_56@@YAHABVUnicodeString@1@PANHAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::scaleForInt(double)
?scaleForInt@icu_56@@YANN@Z proc near	; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+2EAp
					; icu_56::getSamplesFromString(icu_56::UnicodeString const &,double *,int,UErrorCode &)+304p

var_E4		= qword	ptr -0E4h
var_D0		= byte ptr -0D0h
var_C		= qword	ptr -0Ch
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		fld1
		fstp	[ebp+var_C]

loc_4D43:				; CODE XREF: icu_56::scaleForInt(double)+62j
		mov	esi, esp
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0E4h+var_E4]
		call	dword ptr ds:__imp__floor
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jnp	short loc_4D84
		fld	[ebp+arg_0]
		fmul	ds:__real@4024000000000000
		fstp	[ebp+arg_0]
		fld	[ebp+var_C]
		fmul	ds:__real@4024000000000000
		fstp	[ebp+var_C]
		jmp	short loc_4D43
; ---------------------------------------------------------------------------

loc_4D84:				; CODE XREF: icu_56::scaleForInt(double)+48j
		fld	[ebp+var_C]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?scaleForInt@icu_56@@YANN@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 4D9Ch
		public __real@4024000000000000
__real@4024000000000000	dq 10.0		; DATA XREF: icu_56::scaleForInt(double)+4Dr
					; icu_56::scaleForInt(double)+59r ...
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4DA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::RuleChain *__thiscall icu_56::PluralRules::rulesForKeyword(icu_56::PluralRules	*this, const struct icu_56::UnicodeString *)
		public ?rulesForKeyword@PluralRules@icu_56@@ABEPAVRuleChain@2@ABVUnicodeString@2@@Z
?rulesForKeyword@PluralRules@icu_56@@ABEPAVRuleChain@2@ABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::PluralRules::getSamples(icu_56::UnicodeString const &,double *,int,UErrorCode &)+2Ap
					; icu_56::PluralRules::isKeyword(icu_56::UnicodeString const &)+4Ep

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_14], ecx
		jmp	short loc_4DDB
; ---------------------------------------------------------------------------

loc_4DD2:				; CODE XREF: icu_56::PluralRules::rulesForKeyword(icu_56::UnicodeString	const &):loc_4E03j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+44h]
		mov	[ebp+var_14], ecx

loc_4DDB:				; CODE XREF: icu_56::PluralRules::rulesForKeyword(icu_56::UnicodeString	const &)+2Cj
		cmp	[ebp+var_14], 0
		jz	short loc_4E05
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_4E03
		jmp	short loc_4E05
; ---------------------------------------------------------------------------

loc_4E03:				; CODE XREF: icu_56::PluralRules::rulesForKeyword(icu_56::UnicodeString	const &)+5Bj
		jmp	short loc_4DD2
; ---------------------------------------------------------------------------

loc_4E05:				; CODE XREF: icu_56::PluralRules::rulesForKeyword(icu_56::UnicodeString	const &)+3Bj
					; icu_56::PluralRules::rulesForKeyword(icu_56::UnicodeString const &)+5Dj
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?rulesForKeyword@PluralRules@icu_56@@ABEPAVRuleChain@2@ABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::PluralRules::isKeyword(icu_56::PluralRules *this, const struct icu_56::UnicodeString	*)
		public ?isKeyword@PluralRules@icu_56@@QBECABVUnicodeString@2@@Z
?isKeyword@PluralRules@icu_56@@QBECABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+1C8p
					; icu_56::PluralRules::operator==(icu_56::PluralRules const &)+26Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	5		; int
		push	offset _PLURAL_KEYWORD_OTHER ; "other"
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_4E67
		mov	al, 1
		jmp	short loc_4E78
; ---------------------------------------------------------------------------

loc_4E67:				; CODE XREF: icu_56::PluralRules::isKeyword(icu_56::UnicodeString const	&)+41j
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?rulesForKeyword@PluralRules@icu_56@@ABEPAVRuleChain@2@ABVUnicodeString@2@@Z ; icu_56::PluralRules::rulesForKeyword(icu_56::UnicodeString const	&)
		test	eax, eax
		setnz	al

loc_4E78:				; CODE XREF: icu_56::PluralRules::isKeyword(icu_56::UnicodeString const	&)+45j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isKeyword@PluralRules@icu_56@@QBECABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::PluralRules::getKeywordOther(void)const
		public ?getKeywordOther@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ
?getKeywordOther@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	esi, esp
		push	5		; int
		push	offset _PLURAL_KEYWORD_OTHER ; "other"
		push	1		; signed __int8
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getKeywordOther@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::PluralRules::operator==(icu_56::PluralRules *)
		public ??8PluralRules@icu_56@@UBECABV01@@Z
??8PluralRules@icu_56@@UBECABV01@@Z proc near ;	DATA XREF: .rdata:00002EB4o

var_158		= dword	ptr -158h
var_154		= dword	ptr -154h
var_149		= byte ptr -149h
var_13D		= byte ptr -13Dh
var_131		= byte ptr -131h
var_125		= byte ptr -125h
var_119		= byte ptr -119h
var_10D		= byte ptr -10Dh
var_44		= byte ptr -44h
var_38		= byte ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??8PluralRules@icu_56@@UBECABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 14Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_158]
		mov	ecx, 53h ; 'S'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_2C], 0
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_4F58
		mov	al, 1
		jmp	loc_520C
; ---------------------------------------------------------------------------

loc_4F58:				; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+4Fj
		lea	eax, [ebp+var_2C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z ;	icu_56::PluralRules::getKeywords(UErrorCode &)
		push	eax
		lea	ecx, [ebp+var_38]
		call	??0?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@PAVStringEnumeration@1@@Z ; icu_56::LocalPointer<icu_56::StringEnumeration>::LocalPointer<icu_56::StringEnumeration>(icu_56::StringEnumeration *)
		mov	[ebp+var_4], 0
		lea	eax, [ebp+var_2C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0] ; this
		call	?getKeywords@PluralRules@icu_56@@QBEPAVStringEnumeration@2@AAW4UErrorCode@@@Z ;	icu_56::PluralRules::getKeywords(UErrorCode &)
		push	eax
		lea	ecx, [ebp+var_44]
		call	??0?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@PAVStringEnumeration@1@@Z ; icu_56::LocalPointer<icu_56::StringEnumeration>::LocalPointer<icu_56::StringEnumeration>(icu_56::StringEnumeration *)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_2C]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_4FCD
		mov	[ebp+var_149], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_44]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_38]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	al, [ebp+var_149]
		jmp	loc_520C
; ---------------------------------------------------------------------------

loc_4FCD:				; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+9Ej
		lea	ecx, [ebp+var_38]
		call	??C?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QBEPAVStringEnumeration@1@XZ ; icu_56::LocalPointerBase<icu_56::StringEnumeration>::operator->(void)
		mov	[ebp+var_154], eax
		lea	ecx, [ebp+var_44]
		call	??C?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QBEPAVStringEnumeration@1@XZ ; icu_56::LocalPointerBase<icu_56::StringEnumeration>::operator->(void)
		mov	[ebp+var_158], eax
		mov	esi, esp
		lea	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_158]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_158]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		lea	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_154]
		mov	eax, [edx]
		mov	ecx, [ebp+var_154]
		mov	edx, [eax+0Ch]
		call	edx
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	eax, esi
		jz	short loc_505C
		mov	[ebp+var_13D], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_44]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_38]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	al, [ebp+var_13D]
		jmp	loc_520C
; ---------------------------------------------------------------------------

loc_505C:				; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+12Dj
		lea	ecx, [ebp+var_38]
		call	??C?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QBEPAVStringEnumeration@1@XZ ; icu_56::LocalPointerBase<icu_56::StringEnumeration>::operator->(void)
		mov	[ebp+var_154], eax
		mov	esi, esp
		lea	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_154]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_154]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_508A:				; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &):loc_5101j
		lea	ecx, [ebp+var_38]
		call	??C?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QBEPAVStringEnumeration@1@XZ ; icu_56::LocalPointerBase<icu_56::StringEnumeration>::operator->(void)
		mov	[ebp+var_154], eax
		mov	esi, esp
		lea	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_154]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_154]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jz	short loc_5103
		mov	eax, [ebp+var_20]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?isKeyword@PluralRules@icu_56@@QBECABVUnicodeString@2@@Z ; icu_56::PluralRules::isKeyword(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_5101
		mov	[ebp+var_131], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_44]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_38]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	al, [ebp+var_131]
		jmp	loc_520C
; ---------------------------------------------------------------------------

loc_5101:				; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+1D2j
		jmp	short loc_508A
; ---------------------------------------------------------------------------

loc_5103:				; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+1BFj
		lea	ecx, [ebp+var_44]
		call	??C?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QBEPAVStringEnumeration@1@XZ ; icu_56::LocalPointerBase<icu_56::StringEnumeration>::operator->(void)
		mov	[ebp+var_154], eax
		mov	esi, esp
		lea	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_154]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_154]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5131:				; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &):loc_51A5j
		lea	ecx, [ebp+var_44]
		call	??C?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QBEPAVStringEnumeration@1@XZ ; icu_56::LocalPointerBase<icu_56::StringEnumeration>::operator->(void)
		mov	[ebp+var_154], eax
		mov	esi, esp
		lea	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_154]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_154]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jz	short loc_51A7
		mov	eax, [ebp+var_20]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	?isKeyword@PluralRules@icu_56@@QBECABVUnicodeString@2@@Z ; icu_56::PluralRules::isKeyword(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_51A5
		mov	[ebp+var_125], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_44]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_38]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	al, [ebp+var_125]
		jmp	short loc_520C
; ---------------------------------------------------------------------------

loc_51A5:				; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+279j
		jmp	short loc_5131
; ---------------------------------------------------------------------------

loc_51A7:				; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+266j
		mov	eax, [ebp+var_2C]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_51E4
		mov	[ebp+var_119], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_44]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_38]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	al, [ebp+var_119]
		jmp	short loc_520C
; ---------------------------------------------------------------------------

loc_51E4:				; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+2B8j
		mov	[ebp+var_10D], 1
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_44]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_38]
		call	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
		mov	al, [ebp+var_10D]

loc_520C:				; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+53j
					; icu_56::PluralRules::operator==(icu_56::PluralRules const &)+C8j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN20_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 158h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8PluralRules@icu_56@@UBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN20_0		dd 3			; DATA XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+310o
		dd offset $LN19_0
$LN19_0		dd 0FFFFFFD4h, 4	; DATA XREF: .text:00005244o
		dd offset $LN15_0	; "status"
		dd 0FFFFFFC8h, 4
		dd offset $LN16_0	; "myKeywordList"
		dd 0FFFFFFBCh, 4
		dd offset $LN17_0	; "otherKeywordList"
$LN17_0		db 'otherKeywordList',0 ; DATA XREF: .text:00005268o
$LN16_0		db 'myKeywordList',0    ; DATA XREF: .text:0000525Co
$LN15_0		db 'status',0           ; DATA XREF: .text:00005250o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5294h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??8PluralRules@icu_56@@UBECABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:000052C8o
		lea	ecx, [ebp-38h]
		jmp	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
__unwindfunclet$??8PluralRules@icu_56@@UBECABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??8PluralRules@icu_56@@UBECABV01@@Z$1 proc near
					; DATA XREF: .xdata$x:000052D0o
		lea	ecx, [ebp-44h]
		jmp	??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)
__unwindfunclet$??8PluralRules@icu_56@@UBECABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??8PluralRules@icu_56@@UBECABV01@@Z	proc near
					; DATA XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-15Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??8PluralRules@icu_56@@UBECABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??8PluralRules@icu_56@@UBECABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 52C4h
__unwindtable$??8PluralRules@icu_56@@UBECABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000052DCo
		dd offset __unwindfunclet$??8PluralRules@icu_56@@UBECABV01@@Z$0
		align 10h
		dd offset __unwindfunclet$??8PluralRules@icu_56@@UBECABV01@@Z$1
__ehfuncinfo$??8PluralRules@icu_56@@UBECABV01@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??8PluralRules@icu_56@@UBECABV01@@Z+14o
		dd offset __unwindtable$??8PluralRules@icu_56@@UBECABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 52F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::PluralRuleParser::parse(icu_56::PluralRuleParser *this, const	struct icu_56::UnicodeString *,	struct icu_56::PluralRules *, enum UErrorCode *)
		public ?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z
?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+108p
					; icu_56::PluralRules::internalForLocale(icu_56::Locale	const &,UPluralType,UErrorCode &)+209p

var_16C		= dword	ptr -16Ch
var_164		= dword	ptr -164h
var_158		= dword	ptr -158h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 160h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_16C]
		mov	ecx, 58h ; 'X'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5354
		jmp	loc_5D08
; ---------------------------------------------------------------------------

loc_5354:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+55j
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+8], 0
		jz	short loc_5383
		mov	ecx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 4
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1BO@FEOELIJ@?$AAr?$AAu?$AAl?$AAe?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; "ruleIndex == 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5383:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+63j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx

loc_538C:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &):loc_5D03j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]	; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14]
		cmp	[ecx+8], eax
		jge	loc_5D08
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z ;	icu_56::PluralRuleParser::getNextToken(UErrorCode &)
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_53D3
		jmp	loc_5D08
; ---------------------------------------------------------------------------

loc_53D3:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+D4j
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?checkSyntax@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z ; icu_56::PluralRuleParser::checkSyntax(UErrorCode	&)
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_53F9
		jmp	loc_5D08
; ---------------------------------------------------------------------------

loc_53F9:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+FAj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4Ch]
		mov	[ebp+var_16C], ecx
		mov	edx, [ebp+var_16C]
		sub	edx, 1
		mov	[ebp+var_16C], edx
		cmp	[ebp+var_16C], 1Ah ; switch 27 cases
		ja	$LN42		; jumptable 0000542E default case
		mov	eax, [ebp+var_16C]
		movzx	ecx, ds:$LN77[eax]
		jmp	ds:$LN79[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN41:					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; DATA XREF: .text:$LN79o
		mov	eax, [ebp+var_14] ; jumptable 0000542E case 10
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_5464
		mov	ecx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 12h
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1CM@FNOOBBBB@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; "curAndConstraint != 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5464:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+144j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]	; this
		call	?add@AndConstraint@icu_56@@QAEPAV12@XZ ; icu_56::AndConstraint::add(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx+54h], eax
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

$LN40:					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; DATA XREF: .text:$LN79o
		mov	eax, [ebp+var_14] ; jumptable 0000542E case 11
		cmp	dword ptr [eax+58h], 0
		jnz	short loc_54A9
		mov	ecx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 17h
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1CE@GJLPBHC@?$AAc?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC?$AAh?$AAa?$AAi?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@	; "currentChain	!= 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_54A9:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+189j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+58h]
		mov	edx, [ecx+48h]
		mov	[ebp+var_20], edx

loc_54B5:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+1CFj
		mov	eax, [ebp+var_20]
		cmp	dword ptr [eax+8], 0
		jz	short loc_54C9
		mov	eax, [ebp+var_20]
		mov	ecx, [eax+8]
		mov	[ebp+var_20], ecx
		jmp	short loc_54B5
; ---------------------------------------------------------------------------

loc_54C9:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+1C4j
		mov	esi, esp
		push	0Ch		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_158], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_158], 0
		jz	short loc_5506
		mov	ecx, [ebp+var_158] ; this
		call	??0OrConstraint@icu_56@@QAE@XZ ; icu_56::OrConstraint::OrConstraint(void)
		mov	[ebp+var_16C], eax
		jmp	short loc_5510
; ---------------------------------------------------------------------------

loc_5506:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+1F9j
		mov	[ebp+var_16C], 0

loc_5510:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+20Cj
		mov	eax, [ebp+var_16C]
		mov	[ebp+var_164], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_20]
		mov	edx, [ebp+var_164]
		mov	[ecx+8], edx
		mov	eax, [ebp+var_20]
		mov	ecx, [eax+8]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_20]
		mov	dword ptr [eax+8], 0
		mov	ecx, [ebp+var_20] ; this
		call	?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ ; icu_56::OrConstraint::add(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx+54h], eax
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

$LN37:					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; DATA XREF: .text:$LN79o
		mov	eax, [ebp+var_14] ; jumptable 0000542E case 19
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_5584
		mov	ecx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 23h ; '#'
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1CM@FNOOBBBB@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; "curAndConstraint != 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5584:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+264j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		cmp	dword ptr [ecx+0Ch], 0FFFFFFFFh
		jz	short loc_55B6
		mov	edx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	edx, 24h ; '$'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1DM@NLCHHDIN@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; "curAndConstraint->value ==	-1"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_55B6:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+296j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		cmp	dword ptr [ecx+10h], 0
		jz	short loc_55E8
		mov	edx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	edx, 25h ; '%'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1EC@NMMPIMDG@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAr?$AAa?$AAn?$AAg?$AAe?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@	; "curAndConstraint->rangeList == 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_55E8:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+2C8j
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

$LN36:					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; DATA XREF: .text:$LN79o
		mov	eax, [ebp+var_14] ; jumptable 0000542E case 13
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_561C
		mov	ecx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 28h ; '('
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1CM@FNOOBBBB@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; "curAndConstraint != 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_561C:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+2FCj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	byte ptr [ecx+14h], 1
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

$LN35:					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; DATA XREF: .text:$LN79o
		mov	eax, [ebp+var_14] ; jumptable 0000542E case 16
		mov	ecx, [eax+54h]
		mov	byte ptr [ecx+14h], 1

$LN34:					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; DATA XREF: .text:$LN79o
		mov	eax, [ebp+var_14] ; jumptable 0000542E cases 14,15,18
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_5664
		mov	ecx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 31h ; '1'
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1CM@FNOOBBBB@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; "curAndConstraint != 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5664:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+344j
		mov	esi, esp
		push	14h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_140], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_140], 0
		jz	short loc_56C1
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_140] ; this
		call	dword ptr ds:__imp_??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::UVector32::UVector32(UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_140]
		mov	dword ptr [ecx], offset	??_SUVector32@icu_56@@6B@ ; const icu_56::UVector32::`local vftable'
		mov	edx, [ebp+var_140]
		mov	[ebp+var_16C], edx
		jmp	short loc_56CB
; ---------------------------------------------------------------------------

loc_56C1:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+394j
		mov	[ebp+var_16C], 0

loc_56CB:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+3C7j
		mov	eax, [ebp+var_16C]
		mov	[ebp+var_14C], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+54h]
		mov	eax, [ebp+var_14C]
		mov	[edx+10h], eax
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		push	0FFFFFFFFh	; int
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+54h]
		mov	ecx, [edx+10h]	; this
		call	dword ptr ds:__imp_?addElement@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z ; icu_56::UVector32::addElement(int,UErrorCode	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		push	0FFFFFFFFh	; int
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+54h]
		mov	ecx, [edx+10h]	; this
		call	dword ptr ds:__imp_?addElement@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z ; icu_56::UVector32::addElement(int,UErrorCode	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+5Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+60h], 1
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	dword ptr [ecx+0Ch], 7FFFFFFFh
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+4Ch], 13h
		setnz	cl
		mov	edx, [ebp+var_14]
		mov	eax, [edx+54h]
		mov	[eax+15h], cl
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

$LN33:					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; DATA XREF: .text:$LN79o
		mov	eax, [ebp+var_14] ; jumptable 0000542E case 0
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_5791
		mov	ecx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 3Bh ; ';'
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1CM@FNOOBBBB@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; "curAndConstraint != 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5791:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+471j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		cmp	dword ptr [ecx+4], 1
		jnz	short loc_57C6
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		cmp	dword ptr [ecx+8], 0FFFFFFFFh
		jnz	short loc_57C6
		mov	eax, [ebp+var_14]
		add	eax, 0Ch
		push	eax		; struct icu_56::UnicodeString *
		call	?getNumberValue@PluralRuleParser@icu_56@@SAHABVUnicodeString@2@@Z ; icu_56::PluralRuleParser::getNumberValue(icu_56::UnicodeString const &)
		add	esp, 4
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+54h]
		mov	[edx+8], eax
		jmp	loc_58F7
; ---------------------------------------------------------------------------

loc_57C6:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+4A3j
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+4AFj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		cmp	dword ptr [ecx+10h], 0
		jnz	short loc_57EF
		mov	eax, [ebp+var_14]
		add	eax, 0Ch
		push	eax		; struct icu_56::UnicodeString *
		call	?getNumberValue@PluralRuleParser@icu_56@@SAHABVUnicodeString@2@@Z ; icu_56::PluralRuleParser::getNumberValue(icu_56::UnicodeString const &)
		add	esp, 4
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+54h]
		mov	[edx+0Ch], eax
		jmp	loc_58F7
; ---------------------------------------------------------------------------

loc_57EF:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+4D8j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+5Ch]
		push	ecx		; int
		mov	edx, [ebp+var_14]
		mov	eax, [edx+54h]
		mov	ecx, [eax+10h]	; this
		call	dword ptr ds:__imp_?elementAti@UVector32@icu_56@@QBEHH@Z ; icu_56::UVector32::elementAti(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_5876
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+5Ch]
		push	ecx		; int
		mov	edx, [ebp+var_14]
		add	edx, 0Ch
		push	edx		; struct icu_56::UnicodeString *
		call	?getNumberValue@PluralRuleParser@icu_56@@SAHABVUnicodeString@2@@Z ; icu_56::PluralRuleParser::getNumberValue(icu_56::UnicodeString const &)
		add	esp, 4
		push	eax		; int
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	ecx, [ecx+10h]	; this
		call	dword ptr ds:__imp_?setElementAt@UVector32@icu_56@@QAEXHH@Z ; icu_56::UVector32::setElementAt(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+60h]
		push	ecx		; int
		mov	edx, [ebp+var_14]
		add	edx, 0Ch
		push	edx		; struct icu_56::UnicodeString *
		call	?getNumberValue@PluralRuleParser@icu_56@@SAHABVUnicodeString@2@@Z ; icu_56::PluralRuleParser::getNumberValue(icu_56::UnicodeString const &)
		add	esp, 4
		push	eax		; int
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	ecx, [ecx+10h]	; this
		call	dword ptr ds:__imp_?setElementAt@UVector32@icu_56@@QAEXHH@Z ; icu_56::UVector32::setElementAt(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_58F7
; ---------------------------------------------------------------------------

loc_5876:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+519j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+60h]
		push	ecx		; int
		mov	edx, [ebp+var_14]
		add	edx, 0Ch
		push	edx		; struct icu_56::UnicodeString *
		call	?getNumberValue@PluralRuleParser@icu_56@@SAHABVUnicodeString@2@@Z ; icu_56::PluralRuleParser::getNumberValue(icu_56::UnicodeString const &)
		add	esp, 4
		push	eax		; int
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	ecx, [ecx+10h]	; this
		call	dword ptr ds:__imp_?setElementAt@UVector32@icu_56@@QAEXHH@Z ; icu_56::UVector32::setElementAt(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+5Ch]
		push	ecx		; int
		mov	edx, [ebp+var_14]
		mov	eax, [edx+54h]
		mov	ecx, [eax+10h]	; this
		call	dword ptr ds:__imp_?elementAti@UVector32@icu_56@@QBEHH@Z ; icu_56::UVector32::elementAti(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+60h]
		push	edx		; int
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	ecx, [ecx+10h]	; this
		call	dword ptr ds:__imp_?elementAti@UVector32@icu_56@@QBEHH@Z ; icu_56::UVector32::elementAti(int)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jle	short loc_58F7
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 10100h
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

loc_58F7:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+4C9j
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+4F2j ...
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

$LN25_0:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; DATA XREF: .text:$LN79o
		mov	eax, [ebp+var_14] ; jumptable 0000542E case 1
		cmp	dword ptr [eax+54h], 0
		jz	short loc_5911
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		cmp	dword ptr [ecx+10h], 0
		jnz	short loc_591F

loc_5911:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+60Bj
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 10100h
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

loc_591F:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+617j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	esi, esp
		mov	ecx, [ecx+10h]	; this
		call	dword ptr ds:__imp_?size@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 2
		jge	short loc_5962
		mov	edx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	edx, 5Fh ; '_'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1FC@JNCDFLPD@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAr?$AAa?$AAn?$AAg?$AAe?$AAL?$AAi?$AAs?$AAt?$AA?9?$AA?$DO?$AAs?$AAi?$AAz@ ; "curAndConstraint->rangeList->size() >= "...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5962:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+642j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	esi, esp
		mov	ecx, [ecx+10h]	; this
		call	dword ptr ds:__imp_?size@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_14]
		mov	[edx+5Ch], eax
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		push	0FFFFFFFFh	; int
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+54h]
		mov	ecx, [edx+10h]	; this
		call	dword ptr ds:__imp_?addElement@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z ; icu_56::UVector32::addElement(int,UErrorCode	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	esi, esp
		mov	ecx, [ecx+10h]	; this
		call	dword ptr ds:__imp_?size@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_14]
		mov	[edx+60h], eax
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		push	0FFFFFFFFh	; int
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+54h]
		mov	ecx, [edx+10h]	; this
		call	dword ptr ds:__imp_?addElement@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z ; icu_56::UVector32::addElement(int,UErrorCode	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

$LN22_0:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; DATA XREF: .text:$LN79o
		mov	eax, [ebp+var_14] ; jumptable 0000542E case 12
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_5A0E
		mov	ecx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 66h ; 'f'
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1CM@FNOOBBBB@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; "curAndConstraint != 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5A0E:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+6EEj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	dword ptr [ecx+4], 1
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; DATA XREF: .text:$LN79o
		mov	eax, [ebp+var_14] ; jumptable 0000542E cases 20-24
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_5A4F
		mov	ecx, ds:?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 6Eh ; 'n'
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1CM@FNOOBBBB@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; "curAndConstraint != 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5A4F:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+72Fj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+4Ch]
		mov	[ecx+18h], eax
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

$LN20_1:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; DATA XREF: .text:$LN79o
		mov	esi, esp	; jumptable 0000542E case 9
		push	0D0h ; ''      ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_128], eax
		mov	[ebp+var_4], 2
		cmp	[ebp+var_128], 0
		jz	short loc_5AA3
		mov	ecx, [ebp+var_128] ; this
		call	??0RuleChain@icu_56@@QAE@XZ ; icu_56::RuleChain::RuleChain(void)
		mov	[ebp+var_16C], eax
		jmp	short loc_5AAD
; ---------------------------------------------------------------------------

loc_5AA3:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+796j
		mov	[ebp+var_16C], 0

loc_5AAD:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+7A9j
		mov	eax, [ebp+var_16C]
		mov	[ebp+var_134], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_134]
		mov	[ebp+var_2C], ecx
		cmp	[ebp+var_2C], 0
		jnz	short loc_5ADD
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

loc_5ADD:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+7D5j
		mov	eax, [ebp+var_14]
		add	eax, 0Ch
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_2C]
		add	ecx, 4
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_5B0D
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_2C]
		mov	[eax+4], ecx
		jmp	short loc_5B65
; ---------------------------------------------------------------------------

loc_5B0D:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+808j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax+4]
		mov	[ebp+var_38], ecx

loc_5B16:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+856j
		mov	eax, [ebp+var_38]
		cmp	dword ptr [eax+44h], 0
		jz	short loc_5B50
		mov	esi, esp
		push	5		; int
		push	offset _PLURAL_KEYWORD_OTHER ; "other"
		mov	eax, [ebp+var_38]
		mov	ecx, [eax+44h]
		add	ecx, 4		; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_5B50
		mov	eax, [ebp+var_38]
		mov	ecx, [eax+44h]
		mov	[ebp+var_38], ecx
		jmp	short loc_5B16
; ---------------------------------------------------------------------------

loc_5B50:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+825j
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+84Bj
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_38]
		mov	edx, [ecx+44h]
		mov	[eax+44h], edx
		mov	eax, [ebp+var_38]
		mov	ecx, [ebp+var_2C]
		mov	[eax+44h], ecx

loc_5B65:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+813j
		mov	esi, esp
		push	0Ch		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_110], eax
		mov	[ebp+var_4], 3
		cmp	[ebp+var_110], 0
		jz	short loc_5BA2
		mov	ecx, [ebp+var_110] ; this
		call	??0OrConstraint@icu_56@@QAE@XZ ; icu_56::OrConstraint::OrConstraint(void)
		mov	[ebp+var_16C], eax
		jmp	short loc_5BAC
; ---------------------------------------------------------------------------

loc_5BA2:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+895j
		mov	[ebp+var_16C], 0

loc_5BAC:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+8A8j
		mov	eax, [ebp+var_16C]
		mov	[ebp+var_11C], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_11C]
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_44]
		mov	[eax+48h], ecx
		mov	ecx, [ebp+var_44] ; this
		call	?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ ; icu_56::OrConstraint::add(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx+54h], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		mov	[eax+58h], ecx
		jmp	$LN42		; jumptable 0000542E default case
; ---------------------------------------------------------------------------

$LN13:					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+949j ...
		mov	eax, [ebp+arg_8] ; jumptable 0000542E case 26
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z ;	icu_56::PluralRuleParser::getNextToken(UErrorCode &)
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	short loc_5C29
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+4Ch], 3
		jz	short loc_5C29
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+4Ch], 1Ch
		jz	short loc_5C29
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+4Ch], 6
		jnz	short loc_5C2B

loc_5C29:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+914j
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+91Dj ...
		jmp	short loc_5C67
; ---------------------------------------------------------------------------

loc_5C2B:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+92Fj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+4Ch], 9
		jnz	short loc_5C43
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+58h]
		mov	byte ptr [ecx+0CDh], 1
		jmp	short $LN13	; jumptable 0000542E case 26
; ---------------------------------------------------------------------------

loc_5C43:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+93Aj
		mov	eax, [ebp+var_14]
		add	eax, 0Ch
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		mov	ecx, [ecx+58h]
		add	ecx, 8Ch ; ''  ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short $LN13	; jumptable 0000542E case 26
; ---------------------------------------------------------------------------

loc_5C67:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &):loc_5C29j
		jmp	short $LN42	; jumptable 0000542E default case
; ---------------------------------------------------------------------------

$LN7_0:					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136j
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+9C5j ...
		mov	eax, [ebp+arg_8] ; jumptable 0000542E case 25
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z ;	icu_56::PluralRuleParser::getNextToken(UErrorCode &)
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	short loc_5CA5
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+4Ch], 3
		jz	short loc_5CA5
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+4Ch], 1Ch
		jz	short loc_5CA5
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+4Ch], 6
		jnz	short loc_5CA7

loc_5CA5:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+990j
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+999j ...
		jmp	short $LN42	; jumptable 0000542E default case
; ---------------------------------------------------------------------------

loc_5CA7:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+9ABj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+4Ch], 9
		jnz	short loc_5CBF
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+58h]
		mov	byte ptr [ecx+0CCh], 1
		jmp	short $LN7_0	; jumptable 0000542E case 25
; ---------------------------------------------------------------------------

loc_5CBF:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+9B6j
		mov	eax, [ebp+var_14]
		add	eax, 0Ch
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		mov	ecx, [ecx+58h]
		add	ecx, 4Ch ; 'L'  ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short $LN7_0	; jumptable 0000542E case 25
; ---------------------------------------------------------------------------

$LN42:					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+123j
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+136j ...
		mov	eax, [ebp+var_14] ; jumptable 0000542E default case
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+4Ch]
		mov	[eax+50h], edx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5D03
		jmp	short loc_5D08
; ---------------------------------------------------------------------------

loc_5D03:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+A07j
		jmp	loc_538C
; ---------------------------------------------------------------------------

loc_5D08:				; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+57j
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+AFj ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 16Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN79		dd offset $LN33		; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+136r
		dd offset $LN25_0	; jump table for switch	statement
		dd offset $LN20_1
		dd offset $LN41
		dd offset $LN40
		dd offset $LN22_0
		dd offset $LN36
		dd offset $LN34
		dd offset $LN35
		dd offset $LN37
		dd offset $LN21
		dd offset $LN7_0
		dd offset $LN13
		dd offset $LN42
$LN77		db	0,     1,   0Dh,   0Dh
					; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+12Fr
		db    0Dh,   0Dh,   0Dh,   0Dh ; indirect table	for switch statement
		db    0Dh,     2,     3,     4
		db	5,     6,     7,     7
		db	8,   0Dh,     7,     9
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Bh,   0Ch
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5D80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00005FB8o
		mov	esi, esp
		mov	eax, [ebp-158h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00005FC0o
		mov	esi, esp
		mov	eax, [ebp-140h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00005FC8o
		mov	esi, esp
		mov	eax, [ebp-128h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:00005FD0o
		mov	esi, esp
		mov	eax, [ebp-110h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-170h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 5E04h
		public ??_C@_1FC@JNCDFLPD@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAr?$AAa?$AAn?$AAg?$AAe?$AAL?$AAi?$AAs?$AAt?$AA?9?$AA?$DO?$AAs?$AAi?$AAz@
; wchar_t `string'
??_C@_1FC@JNCDFLPD@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAr?$AAa?$AAn?$AAg?$AAe?$AAL?$AAi?$AAs?$AAt?$AA?9?$AA?$DO?$AAs?$AAi?$AAz@:
					; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+655o
		unicode	0, <curAndConstraint->
		dw 3Eh
		unicode	0, <rangeList->
		dw 3Eh
		unicode	0, <size() >
		dw 3Eh
		unicode	0, <= 2>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5E58h
		dd offset ??_R4UVector32@icu_56@@6B@ ; const icu_56::UVector32::`RTTI Complete Object Locator'
		public ??_SUVector32@icu_56@@6B@
; const	icu_56::UVector32::`local vftable'
??_SUVector32@icu_56@@6B@ dd offset ??_EUVector32@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+3B5o
					; icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint const &)+D6o
					; icu_56::UVector32::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UVector32@icu_56@@UBEPAXXZ	; icu_56::UVector32::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 5E64h
		public ??_C@_1EC@NMMPIMDG@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAr?$AAa?$AAn?$AAg?$AAe?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
; wchar_t `string'
??_C@_1EC@NMMPIMDG@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAr?$AAa?$AAn?$AAg?$AAe?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@:
					; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+2DBo
		unicode	0, <curAndConstraint->
		dw 3Eh
		unicode	0, <rangeList == 0>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5EA8h
		public ??_C@_1DM@NLCHHDIN@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
; wchar_t `string'
??_C@_1DM@NLCHHDIN@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@:
					; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+2A9o
		unicode	0, <curAndConstraint->
		dw 3Eh
		unicode	0, <value == -1>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5EE4h
		public ??_C@_1CE@GJLPBHC@?$AAc?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC?$AAh?$AAa?$AAi?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1CE@GJLPBHC@?$AAc?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC?$AAh?$AAa?$AAi?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+19Co
		unicode	0, <currentChain != 0>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5F08h
		public ??_C@_1CM@FNOOBBBB@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1CM@FNOOBBBB@?$AAc?$AAu?$AAr?$AAA?$AAn?$AAd?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+157o
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+277o ...
		unicode	0, <curAndConstraint !=	0>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5F34h
		public ??_C@_1BO@FEOELIJ@?$AAr?$AAu?$AAl?$AAe?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1BO@FEOELIJ@?$AAr?$AAu?$AAl?$AAe?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+76o
		unicode	0, <ruleIndex == 0>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 5F54h
		public ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@
; wchar_t `string'
??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@:
					; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+71o
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+152o ...
		unicode	0, <d:\mozilla\intl\icu\source\i18n\plurrule.cpp>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 5FB0h
		public ?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA
; long `public:	void __thiscall	icu_56::PluralRuleParser::parse(class icu_56::UnicodeString const &, class icu_56::PluralRules *, enum	UErrorCode &)'::`2'::__LINE__Var
?__LINE__Var@?1??parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@3@PAVPluralRules@3@AAW4UErrorCode@@@Z@4JA dd 1C3h
					; DATA XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+65r
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+146r ...
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5FB4h
__unwindtable$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005FDCo
		dd offset __unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$1
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$2
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z$3
__ehfuncinfo$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z	dd 19930522h, 4
					; DATA XREF: __ehhandler$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?parse@PluralRuleParser@icu_56@@QAEXABVUnicodeString@2@PAVPluralRules@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5FF8h
		public ??_R4UVector32@icu_56@@6B@
; const	icu_56::UVector32::`RTTI Complete Object Locator'
??_R4UVector32@icu_56@@6B@ dd 3	dup(0)	; DATA XREF: .rdata:00005E58o
		dd offset ??_R0?AVUVector32@icu_56@@@8 ; icu_56::UVector32 `RTTI Type Descriptor'
		dd offset ??_R3UVector32@icu_56@@8 ; icu_56::UVector32::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 600Ch
		public ??_R0?AVUVector32@icu_56@@@8
; class	icu_56::UVector32 `RTTI	Type Descriptor'
??_R0?AVUVector32@icu_56@@@8 dd	offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00006004o
					; .rdata$r:icu_56::UVector32::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuvector32@	db '.?AVUVector32@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 602Ch
		public ??_R3UVector32@icu_56@@8
; icu_56::UVector32::`RTTI Class Hierarchy Descriptor'
??_R3UVector32@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00006008o
					; .rdata$r:00006064o
		dd 3
		dd offset ??_R2UVector32@icu_56@@8 ; icu_56::UVector32::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 603Ch
		public ??_R2UVector32@icu_56@@8
; icu_56::UVector32::`RTTI Base	Class Array'
??_R2UVector32@icu_56@@8 dd offset ??_R1A@?0A@EA@UVector32@icu_56@@8
					; DATA XREF: .rdata$r:00006038o
					; icu_56::UVector32::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 604Ch
		public ??_R1A@?0A@EA@UVector32@icu_56@@8
; icu_56::UVector32::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@UVector32@icu_56@@8 dd offset ??_R0?AVUVector32@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UVector32::`RTTI Base Class Array'o
					; icu_56::UVector32 `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UVector32@icu_56@@8 ; icu_56::UVector32::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6068h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UVector32::`scalar deleting	destructor'(unsigned int)
		public ??_GUVector32@icu_56@@UAEPAXI@Z
??_GUVector32@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1UVector32@icu_56@@UAE@XZ ; icu_56::UVector32::~UVector32(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_60BB
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_60BB:				; CODE XREF: icu_56::UVector32::`scalar	deleting destructor'(uint)+3Bj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUVector32@icu_56@@UAEPAXI@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 60D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: class icu_56::UnicodeString __thiscall icu_56::PluralRules::getRuleFromResource(class icu_56::Locale	const &, enum  UPluralType, enum  UErrorCode &)
		public ?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z
?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+15Bp

var_458		= dword	ptr -458h
var_450		= dword	ptr -450h
var_384		= byte ptr -384h
var_33C		= byte ptr -33Ch
var_2F4		= dword	ptr -2F4h
var_2E8		= dword	ptr -2E8h
var_2DC		= byte ptr -2DCh
var_294		= dword	ptr -294h
var_288		= byte ptr -288h
var_27C		= byte ptr -27Ch
var_270		= byte ptr -270h
Source		= dword	ptr -168h
Dest		= byte ptr -15Ch
var_B4		= dword	ptr -0B4h
var_A8		= dword	ptr -0A8h
var_9C		= dword	ptr -9Ch
var_90		= dword	ptr -90h
var_84		= byte ptr -84h
var_78		= dword	ptr -78h
var_6C		= byte ptr -6Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 44Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_458]
		mov	ecx, 113h
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_450], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6194
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_450]
		or	ecx, 1
		mov	[ebp+var_450], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	loc_682E
; ---------------------------------------------------------------------------

loc_6194:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+7Bj
		mov	eax, [ebp+arg_C]
		push	eax
		push	offset ??_C@_07GECDDAFN@plurals?$AA@ ; "plurals"
		push	0
		call	_ures_openDirect_56
		add	esp, 0Ch
		push	eax		; struct UResourceBundle *
		lea	ecx, [ebp+var_6C] ; this
		call	??0LocalUResourceBundlePointer@icu_56@@QAE@PAUUResourceBundle@@@Z ; icu_56::LocalUResourceBundlePointer::LocalUResourceBundlePointer(UResourceBundle *)
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6218
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_450]
		or	ecx, 1
		mov	[ebp+var_450], ecx
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_6C] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	loc_682E
; ---------------------------------------------------------------------------

loc_6218:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+F3j
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_458], eax
		cmp	[ebp+var_458], 0
		jz	short loc_6235
		cmp	[ebp+var_458], 1
		jz	short loc_623E
		jmp	short loc_6247
; ---------------------------------------------------------------------------

loc_6235:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+154j
		mov	[ebp+var_78], offset ??_C@_07HBKLOBCC@locales?$AA@ ; "locales"
		jmp	short loc_629F
; ---------------------------------------------------------------------------

loc_623E:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+15Dj
		mov	[ebp+var_78], offset ??_C@_0BB@PDFKKECI@locales_ordinals?$AA@ ;	"locales_ordinals"
		jmp	short loc_629F
; ---------------------------------------------------------------------------

loc_6247:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+15Fj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_450]
		or	ecx, 1
		mov	[ebp+var_450], ecx
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_6C] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	loc_682E
; ---------------------------------------------------------------------------

loc_629F:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+168j
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+171j
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+var_78]
		push	ecx
		lea	ecx, [ebp+var_6C]
		call	?getAlias@?$LocalPointerBase@UUResourceBundle@@@icu_56@@QBEPAUUResourceBundle@@XZ ; icu_56::LocalPointerBase<UResourceBundle>::getAlias(void)
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		push	eax		; struct UResourceBundle *
		lea	ecx, [ebp+var_84] ; this
		call	??0LocalUResourceBundlePointer@icu_56@@QAE@PAUUResourceBundle@@@Z ; icu_56::LocalUResourceBundlePointer::LocalUResourceBundlePointer(UResourceBundle *)
		mov	byte ptr [ebp+var_4], 3
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_633D
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_450]
		or	ecx, 1
		mov	[ebp+var_450], ecx
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_84] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_6C] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	loc_682E
; ---------------------------------------------------------------------------

loc_633D:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+209j
		mov	[ebp+var_90], 0
		mov	esi, esp
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?getName@Locale@icu_56@@QBEPBDXZ ; icu_56::Locale::getName(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_9C], eax
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_90]
		push	ecx
		mov	edx, [ebp+var_9C]
		push	edx
		lea	ecx, [ebp+var_84]
		call	?getAlias@?$LocalPointerBase@UUResourceBundle@@@icu_56@@QBEPAUUResourceBundle@@XZ ; icu_56::LocalPointerBase<UResourceBundle>::getAlias(void)
		push	eax
		call	_ures_getStringByKey_56
		add	esp, 10h
		mov	[ebp+var_A8], eax
		cmp	[ebp+var_A8], 0
		jnz	loc_644F
		mov	[ebp+var_B4], 0
		mov	esi, esp
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?getName@Locale@icu_56@@QBEPBDXZ ; icu_56::Locale::getName(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Source], eax
		mov	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8

loc_63D0:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+379j
		lea	eax, [ebp+var_B4]
		push	eax
		push	9Dh ; ''
		lea	ecx, [ebp+Dest]
		push	ecx
		lea	edx, [ebp+Dest]
		push	edx
		call	_uloc_getParent_56
		add	esp, 10h
		test	eax, eax
		jle	short loc_644F
		mov	[ebp+var_90], 0
		lea	eax, [ebp+var_B4]
		push	eax
		lea	ecx, [ebp+var_90]
		push	ecx
		lea	edx, [ebp+Dest]
		push	edx
		lea	ecx, [ebp+var_84]
		call	?getAlias@?$LocalPointerBase@UUResourceBundle@@@icu_56@@QBEPAUUResourceBundle@@XZ ; icu_56::LocalPointerBase<UResourceBundle>::getAlias(void)
		push	eax
		call	_ures_getStringByKey_56
		add	esp, 10h
		mov	[ebp+var_A8], eax
		cmp	[ebp+var_A8], 0
		jz	short loc_6443
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0
		jmp	short loc_644F
; ---------------------------------------------------------------------------

loc_6443:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+362j
		mov	[ebp+var_B4], 0
		jmp	short loc_63D0
; ---------------------------------------------------------------------------

loc_644F:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+2BEj
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+320j ...
		cmp	[ebp+var_A8], 0
		jnz	short loc_64B6
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_450]
		or	ecx, 1
		mov	[ebp+var_450], ecx
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_84] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_6C] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	loc_682E
; ---------------------------------------------------------------------------

loc_64B6:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+382j
		mov	eax, [ebp+var_90]
		add	eax, 1
		push	eax
		lea	ecx, [ebp+var_270]
		push	ecx
		mov	edx, [ebp+var_A8]
		push	edx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		push	offset ??_C@_05CBLPGGM@rules?$AA@ ; "rules"
		lea	ecx, [ebp+var_6C]
		call	?getAlias@?$LocalPointerBase@UUResourceBundle@@@icu_56@@QBEPAUUResourceBundle@@XZ ; icu_56::LocalPointerBase<UResourceBundle>::getAlias(void)
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		push	eax		; struct UResourceBundle *
		lea	ecx, [ebp+var_27C] ; this
		call	??0LocalUResourceBundlePointer@icu_56@@QAE@PAUUResourceBundle@@@Z ; icu_56::LocalUResourceBundlePointer::LocalUResourceBundlePointer(UResourceBundle *)
		mov	byte ptr [ebp+var_4], 4
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6584
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_450]
		or	ecx, 1
		mov	[ebp+var_450], ecx
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_27C] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_84] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_6C] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	loc_682E
; ---------------------------------------------------------------------------

loc_6584:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+441j
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		lea	ecx, [ebp+var_270]
		push	ecx
		lea	ecx, [ebp+var_27C]
		call	?getAlias@?$LocalPointerBase@UUResourceBundle@@@icu_56@@QBEPAUUResourceBundle@@XZ ; icu_56::LocalPointerBase<UResourceBundle>::getAlias(void)
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		push	eax		; struct UResourceBundle *
		lea	ecx, [ebp+var_288] ; this
		call	??0LocalUResourceBundlePointer@icu_56@@QAE@PAUUResourceBundle@@@Z ; icu_56::LocalUResourceBundlePointer::LocalUResourceBundlePointer(UResourceBundle *)
		mov	byte ptr [ebp+var_4], 5
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6646
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_450]
		or	ecx, 1
		mov	[ebp+var_450], ecx
		mov	byte ptr [ebp+var_4], 4
		lea	ecx, [ebp+var_288] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_27C] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_84] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_6C] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		jmp	loc_682E
; ---------------------------------------------------------------------------

loc_6646:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+4F4j
		lea	ecx, [ebp+var_288]
		call	?getAlias@?$LocalPointerBase@UUResourceBundle@@@icu_56@@QBEPAUUResourceBundle@@XZ ; icu_56::LocalPointerBase<UResourceBundle>::getAlias(void)
		push	eax
		call	_ures_getSize_56
		add	esp, 4
		mov	[ebp+var_294], eax
		mov	esi, esp
		lea	ecx, [ebp+var_2DC] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 6
		mov	[ebp+var_2E8], 0
		mov	[ebp+var_2F4], 0
		jmp	short loc_669E
; ---------------------------------------------------------------------------

loc_668F:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+6C2j
		mov	eax, [ebp+var_2F4]
		add	eax, 1
		mov	[ebp+var_2F4], eax

loc_669E:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+5B9j
		mov	eax, [ebp+var_2F4]
		cmp	eax, [ebp+var_294]
		jge	loc_679B
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_2E8]
		push	ecx
		lea	ecx, [ebp+var_288]
		call	?getAlias@?$LocalPointerBase@UUResourceBundle@@@icu_56@@QBEPAUUResourceBundle@@XZ ; icu_56::LocalPointerBase<UResourceBundle>::getAlias(void)
		push	eax
		lea	edx, [ebp+var_33C]
		push	edx
		call	?ures_getNextUnicodeString@icu_56@@YA?AVUnicodeString@1@PAUUResourceBundle@@PAPBDPAW4UErrorCode@@@Z ; icu_56::ures_getNextUnicodeString(UResourceBundle	*,char const * *,UErrorCode *)
		add	esp, 10h
		mov	byte ptr [ebp+var_4], 7
		mov	esi, esp
		push	0
		push	0FFFFFFFFh
		mov	eax, [ebp+var_2E8]
		push	eax
		lea	ecx, [ebp+var_384]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 8
		mov	esi, esp
		lea	eax, [ebp+var_384]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_2DC] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	3Ah ; ':'       ; wchar_t
		lea	ecx, [ebp+var_2DC] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	eax, [ebp+var_33C]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_2DC] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	3Bh ; ';'       ; wchar_t
		lea	ecx, [ebp+var_2DC] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 7
		mov	esi, esp
		lea	ecx, [ebp+var_384] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 6
		mov	esi, esp
		lea	ecx, [ebp+var_33C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_668F
; ---------------------------------------------------------------------------

loc_679B:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+5D6j
		mov	esi, esp
		lea	eax, [ebp+var_2DC]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_450]
		or	ecx, 1
		mov	[ebp+var_450], ecx
		mov	byte ptr [ebp+var_4], 5
		mov	esi, esp
		lea	ecx, [ebp+var_2DC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 4
		lea	ecx, [ebp+var_288] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_27C] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_84] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_6C] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]

loc_682E:				; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+BBj
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+13Fj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN46
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 458h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN46		dd 0Dh			; DATA XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+75Eo
		dd offset $LN45
$LN45		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:00006870o
		dd offset $LN31		; "emptyStr"
		dd 0FFFFFF94h, 4
		dd offset $LN32		; "rb"
		dd 0FFFFFF7Ch, 4
		dd offset $LN33_0	; "locRes"
		dd 0FFFFFF70h, 4
		dd offset $LN34_0	; "resLen"
		dd 0FFFFFF4Ch, 4
		dd offset $LN35_0	; "status"
		dd 0FFFFFEA4h, 9Dh
		dd offset $LN36_0	; "parentLocaleName"
		db 90h
		db 0FDh, 2 dup(0FFh)
		dd offset _PLURAL_KEYWORD_OTHER+8 ; "r"
		dd offset $LN37_0	; "setKey"
		dd 0FFFFFD84h, 4
		dd offset $LN38		; "ruleRes"
		dd 0FFFFFD78h, 4
		dd offset $LN39		; "setRes"
		dd 0FFFFFD24h, 40h
		dd offset $LN40_0	; "result"
		dd 0FFFFFD18h, 4
		dd offset $LN41_0	; "key"
		dd 0FFFFFCC4h, 40h
		dd offset $LN42_0	; "rules"
		dd 0FFFFFC7Ch, 40h
		dd offset $LN43		; "uKey"
$LN43		db 'uKey',0             ; DATA XREF: .text:0000690Co
$LN42_0		db 'rules',0            ; DATA XREF: .text:00006900o
$LN41_0		db 'key',0              ; DATA XREF: .text:000068F4o
$LN40_0		db 'result',0           ; DATA XREF: .text:000068E8o
$LN39		db 'setRes',0           ; DATA XREF: .text:000068DCo
$LN38		db 'ruleRes',0          ; DATA XREF: .text:000068D0o
$LN37_0		db 'setKey',0           ; DATA XREF: .text:000068C4o
$LN36_0		db 'parentLocaleName',0 ; DATA XREF: .text:000068B8o
$LN35_0		db 'status',0           ; DATA XREF: .text:000068ACo
$LN34_0		db 'resLen',0           ; DATA XREF: .text:000068A0o
$LN33_0		db 'locRes',0           ; DATA XREF: .text:00006894o
$LN32		db 'rb',0               ; DATA XREF: .text:00006888o
$LN31		db 'emptyStr',0         ; DATA XREF: .text:0000687Co
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6970h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00006A98o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00006A90o
		mov	eax, [ebp-450h]
		and	eax, 1
		jz	$LN23_0
		and	dword ptr [ebp-450h], 0FFFFFFFEh
		mov	esi, esp
		mov	ecx, [ebp+8]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN23_0:				; CODE XREF: __unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$1+9j
		retn
__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00006AA0o
		lea	ecx, [ebp-6Ch]	; this
		jmp	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:00006AA8o
		lea	ecx, [ebp-84h]	; this
		jmp	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$4 proc near
					; DATA XREF: .xdata$x:00006AB0o
		lea	ecx, [ebp-27Ch]	; this
		jmp	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$5 proc near
					; DATA XREF: .xdata$x:00006AB8o
		lea	ecx, [ebp-288h]	; this
		jmp	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$5 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$6 proc near
					; DATA XREF: .xdata$x:00006AC0o
		mov	esi, esp
		lea	ecx, [ebp-2DCh]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$6 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$7 proc near
					; DATA XREF: .xdata$x:00006AC8o
		mov	esi, esp
		lea	ecx, [ebp-33Ch]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$7 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$8 proc near
					; DATA XREF: .xdata$x:00006AD0o
		mov	esi, esp
		lea	ecx, [ebp-384h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$8 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-45Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6A3Ch
		public ??_C@_05CBLPGGM@rules?$AA@
; `string'
??_C@_05CBLPGGM@rules?$AA@ db 'rules',0 ; DATA XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+408o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6A44h
		public ??_C@_0BB@PDFKKECI@locales_ordinals?$AA@
; `string'
??_C@_0BB@PDFKKECI@locales_ordinals?$AA@ db 'locales_ordinals',0
					; DATA XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &):loc_623Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6A58h
		public ??_C@_07HBKLOBCC@locales?$AA@
; `string'
??_C@_07HBKLOBCC@locales?$AA@ db 'locales',0
					; DATA XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &):loc_6235o
					; icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &)+D0o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6A60h
		public ??_C@_07GECDDAFN@plurals?$AA@
; `string'
??_C@_07GECDDAFN@plurals?$AA@ db 'plurals',0
					; DATA XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+C4o
					; icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &)+ABo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6A68h
__ehfuncinfo$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z dd 19930522h,	9
					; DATA XREF: __ehhandler$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006A70o
		dd offset __unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$1
		align 8
		dd offset __unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$0
		dd 1
		dd offset __unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$2
		dd 2
		dd offset __unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$3
		dd 3
		dd offset __unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$4
		dd 4
		dd offset __unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$5
		dd 5
		dd offset __unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$6
		dd 6
		dd offset __unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$7
		dd 7
		dd offset __unwindfunclet$?getRuleFromResource@PluralRules@icu_56@@AAE?AVUnicodeString@2@ABVLocale@2@W4UPluralType@@AAW4UErrorCode@@@Z$8
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6AD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::LocalUResourceBundlePointer::LocalUResourceBundlePointer(icu_56::LocalUResourceBundlePointer *this,	struct UResourceBundle *)
		public ??0LocalUResourceBundlePointer@icu_56@@QAE@PAUUResourceBundle@@@Z
??0LocalUResourceBundlePointer@icu_56@@QAE@PAUUResourceBundle@@@Z proc near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+D7p
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+1EDp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??0?$LocalPointerBase@UUResourceBundle@@@icu_56@@QAE@PAUUResourceBundle@@@Z ; icu_56::LocalPointerBase<UResourceBundle>::LocalPointerBase<UResourceBundle>(UResourceBundle *)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0LocalUResourceBundlePointer@icu_56@@QAE@PAUUResourceBundle@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6B1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(icu_56::LocalUResourceBundlePointer *__hidden this)
		public ??1LocalUResourceBundlePointer@icu_56@@QAE@XZ
??1LocalUResourceBundlePointer@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+121p
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+1A8p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		call	??1?$LocalPointerBase@UUResourceBundle@@@icu_56@@QAE@XZ	; icu_56::LocalPointerBase<UResourceBundle>::~LocalPointerBase<UResourceBundle>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1LocalUResourceBundlePointer@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6B6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	icu_56::UnicodeString __cdecl icu_56::ures_getNextUnicodeString(struct UResourceBundle *, char const * *, enum	UErrorCode *)
		public ?ures_getNextUnicodeString@icu_56@@YA?AVUnicodeString@1@PAUUResourceBundle@@PAPBDPAW4UErrorCode@@@Z
?ures_getNextUnicodeString@icu_56@@YA?AVUnicodeString@1@PAUUResourceBundle@@PAPBDPAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+5FAp

var_E4		= byte ptr -0E4h
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_E0], 0
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		lea	edx, [ebp+var_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		call	_ures_getNextString_56
		add	esp, 10h
		mov	[ebp+var_14], eax
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		push	ecx		; wchar_t *
		push	1		; signed __int8
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_E0]
		or	edx, 1
		mov	[ebp+var_E0], edx
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?ures_getNextUnicodeString@icu_56@@YA?AVUnicodeString@1@PAUUResourceBundle@@PAPBDPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_1		dd 1			; DATA XREF: icu_56::ures_getNextUnicodeString(UResourceBundle *,char const * *,UErrorCode *)+7Co
		dd offset $LN6_0
$LN6_0		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00006C10o
		dd offset $LN5_0
$LN5_0		dd 6E656Ch		; DATA XREF: .text:00006C1Co
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6C24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::PluralRules::getRules(void)const
		public ?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ
?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ proc near

var_130		= byte ptr -130h
var_12C		= dword	ptr -12Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_130]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_12C], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+4], 0
		jz	short loc_6CA4
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z ; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)

loc_6CA4:				; CODE XREF: icu_56::PluralRules::getRules(void)+6Fj
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_12C]
		or	ecx, 1
		mov	[ebp+var_12C], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 130h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
$LN10		dd 1			; DATA XREF: icu_56::PluralRules::getRules(void)+C2o
		dd offset $LN9
$LN9		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:00006D24o
		dd offset $LN7_2	; "rules"
$LN7_2		db 'rules',0            ; DATA XREF: .text:00006D30o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6D3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ$0 proc near
					; DATA XREF: .xdata$x:00006DACo
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ$1 proc near
					; DATA XREF: .xdata$x:00006DA4o
		mov	eax, [ebp-12Ch]
		and	eax, 1
		jz	$LN6_1
		and	dword ptr [ebp-12Ch], 0FFFFFFFEh
		mov	esi, esp
		mov	ecx, [ebp+8]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN6_1:					; CODE XREF: __unwindfunclet$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ$1+9j
		retn
__unwindfunclet$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ proc	near
					; DATA XREF: icu_56::PluralRules::getRules(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-134h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6DA0h
__unwindtable$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00006DB8o
		dd offset __unwindfunclet$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ$1
		dd 0
		dd offset __unwindfunclet$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ$0
__ehfuncinfo$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ+1Eo
		dd offset __unwindtable$?getRules@PluralRules@icu_56@@QBE?AVUnicodeString@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6DD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint *__hidden this)
		public ??0AndConstraint@icu_56@@QAE@XZ
??0AndConstraint@icu_56@@QAE@XZ	proc near ; CODE XREF: icu_56::AndConstraint::add(void)+72p
					; icu_56::OrConstraint::add(void)+BBp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7AndConstraint@icu_56@@6B@ ;	const icu_56::AndConstraint::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+14h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+15h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0AndConstraint@icu_56@@QAE@XZ	endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6E54h
		dd offset ??_R4AndConstraint@icu_56@@6B@ ; const icu_56::AndConstraint::`RTTI Complete Object Locator'
		public ??_7AndConstraint@icu_56@@6B@
; const	icu_56::AndConstraint::`vftable'
??_7AndConstraint@icu_56@@6B@ dd offset	??_EAndConstraint@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::AndConstraint::AndConstraint(void)+26o
					; icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint const &)+45o ...
_rdata		ends			; icu_56::AndConstraint::`vector deleting destructor'(uint)

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6E5Ch
		public ??_R4AndConstraint@icu_56@@6B@
; const	icu_56::AndConstraint::`RTTI Complete Object Locator'
??_R4AndConstraint@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00006E54o
		dd offset ??_R0?AVAndConstraint@icu_56@@@8 ; icu_56::AndConstraint `RTTI Type Descriptor'
		dd offset ??_R3AndConstraint@icu_56@@8 ; icu_56::AndConstraint::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 6E70h
		public ??_R0?AVAndConstraint@icu_56@@@8
; class	icu_56::AndConstraint `RTTI Type Descriptor'
??_R0?AVAndConstraint@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00006E68o
					; .rdata$r:icu_56::AndConstraint::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avandconstra	db '.?AVAndConstraint@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6E94h
		public ??_R3AndConstraint@icu_56@@8
; icu_56::AndConstraint::`RTTI Class Hierarchy Descriptor'
??_R3AndConstraint@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00006E6Co
					; .rdata$r:00006EC8o
		dd 2
		dd offset ??_R2AndConstraint@icu_56@@8 ; icu_56::AndConstraint::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6EA4h
		public ??_R2AndConstraint@icu_56@@8
; icu_56::AndConstraint::`RTTI Base Class Array'
??_R2AndConstraint@icu_56@@8 dd	offset ??_R1A@?0A@EA@AndConstraint@icu_56@@8
					; DATA XREF: .rdata$r:00006EA0o
					; icu_56::AndConstraint::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6EB0h
		public ??_R1A@?0A@EA@AndConstraint@icu_56@@8
; icu_56::AndConstraint::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@AndConstraint@icu_56@@8 dd offset	??_R0?AVAndConstraint@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::AndConstraint::`RTTI Base	Class Array'o
					; icu_56::AndConstraint	`RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3AndConstraint@icu_56@@8 ; icu_56::AndConstraint::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6ECCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::AndConstraint::`scalar deleting destructor'(unsigned int)
		public ??_GAndConstraint@icu_56@@UAEPAXI@Z
??_GAndConstraint@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1AndConstraint@icu_56@@UAE@XZ	; icu_56::AndConstraint::~AndConstraint(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6F15
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6F15:				; CODE XREF: icu_56::AndConstraint::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GAndConstraint@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint *this, const struct icu_56::AndConstraint *)
		public ??0AndConstraint@icu_56@@QAE@ABV01@@Z
??0AndConstraint@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+1A3p
					; icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const	&)+97p

var_118		= dword	ptr -118h
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0AndConstraint@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7AndConstraint@icu_56@@6B@ ;	const icu_56::AndConstraint::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+10h], 0
		jz	loc_7063
		mov	[ebp+var_20], 0
		mov	esi, esp
		push	14h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_104], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_104], 0
		jz	short loc_701A
		mov	esi, esp
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_104] ; this
		call	dword ptr ds:__imp_??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::UVector32::UVector32(UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_104]
		mov	dword ptr [ecx], offset	??_SUVector32@icu_56@@6B@ ; const icu_56::UVector32::`local vftable'
		mov	edx, [ebp+var_104]
		mov	[ebp+var_118], edx
		jmp	short loc_7024
; ---------------------------------------------------------------------------

loc_701A:				; CODE XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+B5j
		mov	[ebp+var_118], 0

loc_7024:				; CODE XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+E8j
		mov	eax, [ebp+var_118]
		mov	[ebp+var_110], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_110]
		mov	[ecx+10h], edx
		mov	esi, esp
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		push	edx		; struct icu_56::UVector32 *
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+10h]	; this
		call	dword ptr ds:__imp_?assign@UVector32@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z ; icu_56::UVector32::assign(icu_56::UVector32	const &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7063:				; CODE XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+80j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+15h]
		mov	[eax+15h], dl
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+14h]
		mov	[eax+14h], dl
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1Ch], 0
		jnz	short loc_709C
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+1Ch], 0
		jmp	short loc_7109
; ---------------------------------------------------------------------------

loc_709C:				; CODE XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+15Ej
		mov	esi, esp
		push	20h ; ' '       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_EC], 0
		jz	short loc_70E0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1Ch]
		push	ecx		; struct icu_56::AndConstraint *
		mov	ecx, [ebp+var_EC] ; this
		call	??0AndConstraint@icu_56@@QAE@ABV01@@Z ;	icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint const &)
		mov	[ebp+var_118], eax
		jmp	short loc_70EA
; ---------------------------------------------------------------------------

loc_70E0:				; CODE XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+194j
		mov	[ebp+var_118], 0

loc_70EA:				; CODE XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+1AEj
		mov	edx, [ebp+var_118]
		mov	[ebp+var_F8], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_F8]
		mov	[eax+1Ch], ecx

loc_7109:				; CODE XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+16Aj
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN15_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0AndConstraint@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN15_1		dd 1			; DATA XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+1E0o
		dd offset $LN14_0
$LN14_0		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00007144o
		dd offset $LN12_0	; "status"
$LN12_0		db 'status',0           ; DATA XREF: .text:00007150o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 715Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0AndConstraint@icu_56@@QAE@ABV01@@Z$0	proc near
					; DATA XREF: .xdata$x:000071B0o
		mov	esi, esp
		mov	eax, [ebp-104h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0AndConstraint@icu_56@@QAE@ABV01@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0AndConstraint@icu_56@@QAE@ABV01@@Z$1	proc near
					; DATA XREF: .xdata$x:000071B8o
		mov	esi, esp
		mov	eax, [ebp-0ECh]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0AndConstraint@icu_56@@QAE@ABV01@@Z$1	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0AndConstraint@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-11Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0AndConstraint@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0AndConstraint@icu_56@@QAE@ABV01@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 71ACh
__unwindtable$??0AndConstraint@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000071C4o
		dd offset __unwindfunclet$??0AndConstraint@icu_56@@QAE@ABV01@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$??0AndConstraint@icu_56@@QAE@ABV01@@Z$1
__ehfuncinfo$??0AndConstraint@icu_56@@QAE@ABV01@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0AndConstraint@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0AndConstraint@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 71E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AndConstraint::~AndConstraint(icu_56::AndConstraint	*__hidden this)
		public ??1AndConstraint@icu_56@@UAE@XZ
??1AndConstraint@icu_56@@UAE@XZ	proc near
					; CODE XREF: icu_56::AndConstraint::`scalar deleting destructor'(uint)+26p

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7AndConstraint@icu_56@@6B@ ;	const icu_56::AndConstraint::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_EC], ecx
		mov	edx, [ebp+var_EC]
		mov	[ebp+var_F8], edx
		cmp	[ebp+var_F8], 0
		jz	short loc_7252
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_F8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_F8]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_100], eax
		jmp	short loc_725C
; ---------------------------------------------------------------------------

loc_7252:				; CODE XREF: icu_56::AndConstraint::~AndConstraint(void)+4Bj
		mov	[ebp+var_100], 0

loc_725C:				; CODE XREF: icu_56::AndConstraint::~AndConstraint(void)+70j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+1Ch], 0
		jz	short loc_72B5
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	[ebp+var_D4], ecx
		mov	edx, [ebp+var_D4]
		mov	[ebp+var_E0], edx
		cmp	[ebp+var_E0], 0
		jz	short loc_72AB
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_E0]
		mov	edx, [eax]
		mov	ecx, [ebp+var_E0]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_100], eax
		jmp	short loc_72B5
; ---------------------------------------------------------------------------

loc_72AB:				; CODE XREF: icu_56::AndConstraint::~AndConstraint(void)+A4j
		mov	[ebp+var_100], 0

loc_72B5:				; CODE XREF: icu_56::AndConstraint::~AndConstraint(void)+83j
					; icu_56::AndConstraint::~AndConstraint(void)+C9j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1AndConstraint@icu_56@@UAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AndConstraint::isFulfilled(icu_56::AndConstraint *this, const struct	icu_56::FixedDecimal *)
		public ?isFulfilled@AndConstraint@icu_56@@QAECABVFixedDecimal@2@@Z
?isFulfilled@AndConstraint@icu_56@@QAECABVFixedDecimal@2@@Z proc near
					; CODE XREF: icu_56::OrConstraint::isFulfilled(icu_56::FixedDecimal const &)+5Dp

var_114		= qword	ptr -114h
var_10C		= qword	ptr -10Ch
var_F8		= dword	ptr -0F8h
var_30		= dword	ptr -30h
var_24		= qword	ptr -24h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F8]
		mov	ecx, 3Eh ; '>'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_11], 1
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 0
		jnz	short loc_7303
		mov	al, 1
		jmp	loc_746F
; ---------------------------------------------------------------------------

loc_7303:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+2Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	?get@FixedDecimal@icu_56@@QBENW4tokenType@2@@Z ; icu_56::FixedDecimal::get(icu_56::tokenType)
		fstp	[ebp+var_24]

loc_7315:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+183j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+15h]
		test	ecx, ecx
		jz	short loc_7346
		sub	esp, 8
		fld	[ebp+var_24]
		fstp	[esp+10Ch+var_10C]
		call	_uprv_floor_56
		add	esp, 8
		fld	[ebp+var_24]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jnp	short loc_7346
		mov	[ebp+var_11], 0
		jmp	loc_7455
; ---------------------------------------------------------------------------

loc_7346:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+52j
					; icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const	&)+6Fj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 1
		jnz	short loc_736F
		mov	eax, [ebp+var_8]
		fild	dword ptr [eax+8]
		sub	esp, 8
		fstp	[esp+10Ch+var_10C]
		sub	esp, 8
		fld	[ebp+var_24]
		fstp	[esp+114h+var_114]
		call	_fmod
		add	esp, 10h
		fstp	[ebp+var_24]

loc_736F:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+81j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jnz	short loc_73B1
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0FFFFFFFFh
		jz	short loc_739C
		mov	ecx, [ebp+var_8]
		fild	dword ptr [ecx+0Ch]
		fld	[ebp+var_24]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jnp	short loc_739C
		mov	byte ptr [ebp+var_F8+3], 0
		jmp	short loc_73A3
; ---------------------------------------------------------------------------

loc_739C:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+B3j
					; icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const	&)+C5j
		mov	byte ptr [ebp+var_F8+3], 1

loc_73A3:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+CEj
		mov	dl, byte ptr [ebp+var_F8+3]
		mov	[ebp+var_11], dl
		jmp	loc_7455
; ---------------------------------------------------------------------------

loc_73B1:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+AAj
		mov	[ebp+var_11], 0
		mov	[ebp+var_30], 0
		jmp	short loc_73C7
; ---------------------------------------------------------------------------

loc_73BE:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &):loc_7448j
		mov	eax, [ebp+var_30]
		add	eax, 2
		mov	[ebp+var_30], eax

loc_73C7:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+F0j
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]	; this
		call	dword ptr ds:__imp_?size@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_30], eax
		jge	short loc_744D
		mov	esi, esp
		mov	eax, [ebp+var_30]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+10h]	; this
		call	dword ptr ds:__imp_?elementAti@UVector32@icu_56@@QBEHH@Z ; icu_56::UVector32::elementAti(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F8], eax
		fild	[ebp+var_F8]
		fcomp	[ebp+var_24]
		fnstsw	ax
		test	ah, 41h
		jp	short loc_7448
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+10h]	; this
		call	dword ptr ds:__imp_?elementAti@UVector32@icu_56@@QBEHH@Z ; icu_56::UVector32::elementAti(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F8], eax
		fild	[ebp+var_F8]
		fcomp	[ebp+var_24]
		fnstsw	ax
		test	ah, 1
		jnz	short loc_7448
		mov	[ebp+var_11], 1
		jmp	short loc_744D
; ---------------------------------------------------------------------------

loc_7448:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+142j
					; icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const	&)+174j
		jmp	loc_73BE
; ---------------------------------------------------------------------------

loc_744D:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+113j
					; icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const	&)+17Aj
		xor	eax, eax
		jnz	loc_7315

loc_7455:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+75j
					; icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const	&)+E0j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+14h]
		test	ecx, ecx
		jz	short loc_746C
		movsx	eax, [ebp+var_11]
		test	eax, eax
		setz	cl
		mov	[ebp+var_11], cl

loc_746C:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+192j
		mov	al, [ebp+var_11]

loc_746F:				; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+32j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isFulfilled@AndConstraint@icu_56@@QAECABVFixedDecimal@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7488h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::AndConstraint *__thiscall icu_56::AndConstraint::add(icu_56::AndConstraint *__hidden this)
		public ?add@AndConstraint@icu_56@@QAEPAV12@XZ
?add@AndConstraint@icu_56@@QAEPAV12@XZ proc near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+172p

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?add@AndConstraint@icu_56@@QAEPAV12@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		push	20h ; ' '       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_7507
		mov	ecx, [ebp+var_E0] ; this
		call	??0AndConstraint@icu_56@@QAE@XZ	; icu_56::AndConstraint::AndConstraint(void)
		mov	[ebp+var_F4], eax
		jmp	short loc_7511
; ---------------------------------------------------------------------------

loc_7507:				; CODE XREF: icu_56::AndConstraint::add(void)+6Aj
		mov	[ebp+var_F4], 0

loc_7511:				; CODE XREF: icu_56::AndConstraint::add(void)+7Dj
		mov	eax, [ebp+var_F4]
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_EC]
		mov	[ecx+1Ch], edx
		mov	eax, [ebp+var_14]
		mov	eax, [eax+1Ch]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?add@AndConstraint@icu_56@@QAEPAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7558h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?add@AndConstraint@icu_56@@QAEPAV12@XZ$0 proc near
					; DATA XREF: .xdata$x:00007594o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?add@AndConstraint@icu_56@@QAEPAV12@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?add@AndConstraint@icu_56@@QAEPAV12@XZ proc	near
					; DATA XREF: icu_56::AndConstraint::add(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?add@AndConstraint@icu_56@@QAEPAV12@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?add@AndConstraint@icu_56@@QAEPAV12@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7590h
__unwindtable$?add@AndConstraint@icu_56@@QAEPAV12@XZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:000075A0o
		dd offset __unwindfunclet$?add@AndConstraint@icu_56@@QAEPAV12@XZ$0
__ehfuncinfo$?add@AndConstraint@icu_56@@QAEPAV12@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?add@AndConstraint@icu_56@@QAEPAV12@XZ+14o
		dd offset __unwindtable$?add@AndConstraint@icu_56@@QAEPAV12@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 75BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint *__hidden this)
		public ??0OrConstraint@icu_56@@QAE@XZ
??0OrConstraint@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+201p
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+89Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7OrConstraint@icu_56@@6B@ ; const icu_56::OrConstraint::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0OrConstraint@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7608h
		dd offset ??_R4OrConstraint@icu_56@@6B@	; const	icu_56::OrConstraint::`RTTI Complete Object Locator'
		public ??_7OrConstraint@icu_56@@6B@
; const	icu_56::OrConstraint::`vftable'
??_7OrConstraint@icu_56@@6B@ dd	offset ??_EOrConstraint@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::OrConstraint::OrConstraint(void)+26o
					; icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const	&)+45o	...
_rdata		ends			; icu_56::OrConstraint::`vector	deleting destructor'(uint)

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7610h
		public ??_R4OrConstraint@icu_56@@6B@
; const	icu_56::OrConstraint::`RTTI Complete Object Locator'
??_R4OrConstraint@icu_56@@6B@ dd 3 dup(0) ; DATA XREF: .rdata:00007608o
		dd offset ??_R0?AVOrConstraint@icu_56@@@8 ; icu_56::OrConstraint `RTTI Type Descriptor'
		dd offset ??_R3OrConstraint@icu_56@@8 ;	icu_56::OrConstraint::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 7624h
		public ??_R0?AVOrConstraint@icu_56@@@8
; class	icu_56::OrConstraint `RTTI Type	Descriptor'
??_R0?AVOrConstraint@icu_56@@@8	dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:0000761Co
					; .rdata$r:icu_56::OrConstraint::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avorconstrai	db '.?AVOrConstraint@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7648h
		public ??_R3OrConstraint@icu_56@@8
; icu_56::OrConstraint::`RTTI Class Hierarchy Descriptor'
??_R3OrConstraint@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00007620o
					; .rdata$r:0000767Co
		dd 2
		dd offset ??_R2OrConstraint@icu_56@@8 ;	icu_56::OrConstraint::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7658h
		public ??_R2OrConstraint@icu_56@@8
; icu_56::OrConstraint::`RTTI Base Class Array'
??_R2OrConstraint@icu_56@@8 dd offset ??_R1A@?0A@EA@OrConstraint@icu_56@@8
					; DATA XREF: .rdata$r:00007654o
					; icu_56::OrConstraint::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7664h
		public ??_R1A@?0A@EA@OrConstraint@icu_56@@8
; icu_56::OrConstraint::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@OrConstraint@icu_56@@8 dd	offset ??_R0?AVOrConstraint@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::OrConstraint::`RTTI Base Class Array'o
					; icu_56::OrConstraint `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3OrConstraint@icu_56@@8 ;	icu_56::OrConstraint::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7680h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::OrConstraint::`scalar deleting destructor'(unsigned int)
		public ??_GOrConstraint@icu_56@@UAEPAXI@Z
??_GOrConstraint@icu_56@@UAEPAXI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1OrConstraint@icu_56@@UAE@XZ ; icu_56::OrConstraint::~OrConstraint(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_76C9
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_76C9:				; CODE XREF: icu_56::OrConstraint::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GOrConstraint@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 76E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint *this, const struct	icu_56::OrConstraint *)
		public ??0OrConstraint@icu_56@@QAE@ABV01@@Z
??0OrConstraint@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)+119p
					; icu_56::RuleChain::RuleChain(icu_56::RuleChain const &)+128p

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0OrConstraint@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7OrConstraint@icu_56@@6B@ ; const icu_56::OrConstraint::`vftable'
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_7744
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		jmp	short loc_77B1
; ---------------------------------------------------------------------------

loc_7744:				; CODE XREF: icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)+52j
		mov	esi, esp
		push	20h ; ' '       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_F8], 0
		jz	short loc_7788
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx		; struct icu_56::AndConstraint *
		mov	ecx, [ebp+var_F8] ; this
		call	??0AndConstraint@icu_56@@QAE@ABV01@@Z ;	icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint const &)
		mov	[ebp+var_10C], eax
		jmp	short loc_7792
; ---------------------------------------------------------------------------

loc_7788:				; CODE XREF: icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)+88j
		mov	[ebp+var_10C], 0

loc_7792:				; CODE XREF: icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)+A2j
		mov	edx, [ebp+var_10C]
		mov	[ebp+var_104], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_104]
		mov	[eax+4], ecx

loc_77B1:				; CODE XREF: icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)+5Ej
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jnz	short loc_77C6
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		jmp	short loc_7833
; ---------------------------------------------------------------------------

loc_77C6:				; CODE XREF: icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)+D4j
		mov	esi, esp
		push	0Ch		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_E0], 0
		jz	short loc_780A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx		; struct icu_56::OrConstraint *
		mov	ecx, [ebp+var_E0] ; this
		call	??0OrConstraint@icu_56@@QAE@ABV01@@Z ; icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)
		mov	[ebp+var_10C], eax
		jmp	short loc_7814
; ---------------------------------------------------------------------------

loc_780A:				; CODE XREF: icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)+10Aj
		mov	[ebp+var_10C], 0

loc_7814:				; CODE XREF: icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)+124j
		mov	edx, [ebp+var_10C]
		mov	[ebp+var_EC], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_EC]
		mov	[eax+8], ecx

loc_7833:				; CODE XREF: icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)+E0j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0OrConstraint@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7858h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0OrConstraint@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:000078ACo
		mov	esi, esp
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0OrConstraint@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0OrConstraint@icu_56@@QAE@ABV01@@Z$1 proc near
					; DATA XREF: .xdata$x:000078B4o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0OrConstraint@icu_56@@QAE@ABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0OrConstraint@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0OrConstraint@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0OrConstraint@icu_56@@QAE@ABV01@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 78A8h
__unwindtable$??0OrConstraint@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000078C0o
		dd offset __unwindfunclet$??0OrConstraint@icu_56@@QAE@ABV01@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$??0OrConstraint@icu_56@@QAE@ABV01@@Z$1
__ehfuncinfo$??0OrConstraint@icu_56@@QAE@ABV01@@Z dd 19930522h,	2
					; DATA XREF: __ehhandler$??0OrConstraint@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0OrConstraint@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 78DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::OrConstraint::~OrConstraint(icu_56::OrConstraint *__hidden this)
		public ??1OrConstraint@icu_56@@UAE@XZ
??1OrConstraint@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::OrConstraint::`scalar deleting destructor'(uint)+26p

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7OrConstraint@icu_56@@6B@ ; const icu_56::OrConstraint::`vftable'
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		jz	short loc_7961
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_EC], ecx
		mov	edx, [ebp+var_EC]
		mov	[ebp+var_F8], edx
		cmp	[ebp+var_F8], 0
		jz	short loc_7957
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_F8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_F8]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_100], eax
		jmp	short loc_7961
; ---------------------------------------------------------------------------

loc_7957:				; CODE XREF: icu_56::OrConstraint::~OrConstraint(void)+54j
		mov	[ebp+var_100], 0

loc_7961:				; CODE XREF: icu_56::OrConstraint::~OrConstraint(void)+33j
					; icu_56::OrConstraint::~OrConstraint(void)+79j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	short loc_79BA
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	[ebp+var_D4], ecx
		mov	edx, [ebp+var_D4]
		mov	[ebp+var_E0], edx
		cmp	[ebp+var_E0], 0
		jz	short loc_79B0
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_E0]
		mov	edx, [eax]
		mov	ecx, [ebp+var_E0]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_100], eax
		jmp	short loc_79BA
; ---------------------------------------------------------------------------

loc_79B0:				; CODE XREF: icu_56::OrConstraint::~OrConstraint(void)+ADj
		mov	[ebp+var_100], 0

loc_79BA:				; CODE XREF: icu_56::OrConstraint::~OrConstraint(void)+8Cj
					; icu_56::OrConstraint::~OrConstraint(void)+D2j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1OrConstraint@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 79D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::AndConstraint *__thiscall icu_56::OrConstraint::add(icu_56::OrConstraint *__hidden this)
		public ?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ
?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ proc	near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+24Dp
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+8DCp

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	[ebp+var_20], eax

loc_7A18:				; CODE XREF: icu_56::OrConstraint::add(void)+5Aj
		mov	eax, [ebp+var_20]
		cmp	dword ptr [eax+8], 0
		jz	short loc_7A2C
		mov	eax, [ebp+var_20]
		mov	ecx, [eax+8]
		mov	[ebp+var_20], ecx
		jmp	short loc_7A18
; ---------------------------------------------------------------------------

loc_7A2C:				; CODE XREF: icu_56::OrConstraint::add(void)+4Fj
		mov	eax, [ebp+var_20]
		cmp	dword ptr [eax+4], 0
		jz	short loc_7A5B
		mov	ecx, ds:?__LINE__Var@?1??add@OrConstraint@icu_56@@QAEPAVAndConstraint@3@XZ@4JA ; long `icu_56::OrConstraint::add(void)'::`2'::__LINE__Var
		add	ecx, 6
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1EA@PEIFAIFE@?$AAc?$AAu?$AAr?$AAO?$AAr?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAi?$AAl?$AAd?$AAN?$AAo?$AAd?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; "curOrConstraint->childNode == 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7A5B:				; CODE XREF: icu_56::OrConstraint::add(void)+63j
		mov	esi, esp
		push	20h ; ' '       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_EC], 0
		jz	short loc_7A98
		mov	ecx, [ebp+var_EC] ; this
		call	??0AndConstraint@icu_56@@QAE@XZ	; icu_56::AndConstraint::AndConstraint(void)
		mov	[ebp+var_100], eax
		jmp	short loc_7AA2
; ---------------------------------------------------------------------------

loc_7A98:				; CODE XREF: icu_56::OrConstraint::add(void)+B3j
		mov	[ebp+var_100], 0

loc_7AA2:				; CODE XREF: icu_56::OrConstraint::add(void)+C6j
		mov	eax, [ebp+var_100]
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_20]
		mov	edx, [ebp+var_F8]
		mov	[ecx+4], edx
		mov	eax, [ebp+var_20]
		mov	eax, [eax+4]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7AE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ$0 proc near
					; DATA XREF: .xdata$x:00007B68o
		mov	esi, esp
		mov	eax, [ebp-0ECh]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ proc near
					; DATA XREF: icu_56::OrConstraint::add(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-104h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7B20h
		public ??_C@_1EA@PEIFAIFE@?$AAc?$AAu?$AAr?$AAO?$AAr?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAi?$AAl?$AAd?$AAN?$AAo?$AAd?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1EA@PEIFAIFE@?$AAc?$AAu?$AAr?$AAO?$AAr?$AAC?$AAo?$AAn?$AAs?$AAt?$AAr?$AAa?$AAi?$AAn?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAi?$AAl?$AAd?$AAN?$AAo?$AAd?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: icu_56::OrConstraint::add(void)+76o
		unicode	0, <curOrConstraint->
		dw 3Eh
		unicode	0, <childNode == 0>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 7B60h
		public ?__LINE__Var@?1??add@OrConstraint@icu_56@@QAEPAVAndConstraint@3@XZ@4JA
; long `public:	class icu_56::AndConstraint * __thiscall icu_56::OrConstraint::add(void)'::`2'::__LINE__Var
?__LINE__Var@?1??add@OrConstraint@icu_56@@QAEPAVAndConstraint@3@XZ@4JA dd 349h
					; DATA XREF: icu_56::OrConstraint::add(void)+65r
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7B64h
__unwindtable$?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007B74o
		dd offset __unwindfunclet$?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ$0
__ehfuncinfo$?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ	dd 19930522h, 1
					; DATA XREF: __ehhandler$?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ+14o
		dd offset __unwindtable$?add@OrConstraint@icu_56@@QAEPAVAndConstraint@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::OrConstraint::isFulfilled(icu_56::OrConstraint *this, const struct icu_56::FixedDecimal *)
		public ?isFulfilled@OrConstraint@icu_56@@QAECABVFixedDecimal@2@@Z
?isFulfilled@OrConstraint@icu_56@@QAECABVFixedDecimal@2@@Z proc	near
					; CODE XREF: icu_56::RuleChain::select(icu_56::FixedDecimal const &)+59p

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	[ebp+var_14], eax
		mov	[ebp+var_1D], 0

loc_7BBD:				; CODE XREF: icu_56::OrConstraint::isFulfilled(icu_56::FixedDecimal const &)+79j
		cmp	[ebp+var_14], 0
		jz	short loc_7C0B
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jnz	short loc_7C0B
		mov	[ebp+var_1D], 1
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]
		mov	[ebp+var_2C], ecx

loc_7BD8:				; CODE XREF: icu_56::OrConstraint::isFulfilled(icu_56::FixedDecimal const &)+6Ej
		cmp	[ebp+var_2C], 0
		jz	short loc_7C00
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jz	short loc_7C00
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::FixedDecimal *
		mov	ecx, [ebp+var_2C] ; this
		call	?isFulfilled@AndConstraint@icu_56@@QAECABVFixedDecimal@2@@Z ; icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)
		mov	[ebp+var_1D], al
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+1Ch]
		mov	[ebp+var_2C], ecx
		jmp	short loc_7BD8
; ---------------------------------------------------------------------------

loc_7C00:				; CODE XREF: icu_56::OrConstraint::isFulfilled(icu_56::FixedDecimal const &)+4Cj
					; icu_56::OrConstraint::isFulfilled(icu_56::FixedDecimal const &)+54j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		jmp	short loc_7BBD
; ---------------------------------------------------------------------------

loc_7C0B:				; CODE XREF: icu_56::OrConstraint::isFulfilled(icu_56::FixedDecimal const &)+31j
					; icu_56::OrConstraint::isFulfilled(icu_56::FixedDecimal const &)+39j
		mov	al, [ebp+var_1D]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isFulfilled@OrConstraint@icu_56@@QAECABVFixedDecimal@2@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleChain::RuleChain(icu_56::RuleChain *__hidden this)
		public ??0RuleChain@icu_56@@QAE@XZ
??0RuleChain@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+79Ep

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleChain@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleChain@icu_56@@6B@ ; const icu_56::RuleChain::`vftable'
		mov	ecx, [ebp+var_14]
		add	ecx, 4		; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+44h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+48h], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 4Ch ; 'L'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 8Ch ; ''  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+0CCh], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+0CDh], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0RuleChain@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7D10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleChain@icu_56@@QAE@XZ$0 proc near	; DATA XREF: .xdata$x:00007D64o
		mov	ecx, [ebp-14h]
		add	ecx, 4		; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleChain@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleChain@icu_56@@QAE@XZ$1 proc near	; DATA XREF: .xdata$x:00007D6Co
		mov	ecx, [ebp-14h]
		add	ecx, 4Ch ; 'L'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleChain@icu_56@@QAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleChain@icu_56@@QAE@XZ	proc near
					; DATA XREF: icu_56::RuleChain::RuleChain(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleChain@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleChain@icu_56@@QAE@XZ	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7D58h
		dd offset ??_R4RuleChain@icu_56@@6B@ ; const icu_56::RuleChain::`RTTI Complete Object Locator'
		public ??_7RuleChain@icu_56@@6B@
; const	icu_56::RuleChain::`vftable'
??_7RuleChain@icu_56@@6B@ dd offset ??_ERuleChain@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::RuleChain::RuleChain(void)+45o
					; icu_56::RuleChain::RuleChain(icu_56::RuleChain const &)+45o ...
_rdata		ends			; icu_56::RuleChain::`vector deleting destructor'(uint)

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7D60h
__unwindtable$??0RuleChain@icu_56@@QAE@XZ dd 0FFFFFFFFh	; DATA XREF: .xdata$x:00007D78o
		dd offset __unwindfunclet$??0RuleChain@icu_56@@QAE@XZ$0
		dd 0
		dd offset __unwindfunclet$??0RuleChain@icu_56@@QAE@XZ$1
__ehfuncinfo$??0RuleChain@icu_56@@QAE@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$??0RuleChain@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0RuleChain@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7D94h
		public ??_R4RuleChain@icu_56@@6B@
; const	icu_56::RuleChain::`RTTI Complete Object Locator'
??_R4RuleChain@icu_56@@6B@ dd 3	dup(0)	; DATA XREF: .rdata:00007D58o
		dd offset ??_R0?AVRuleChain@icu_56@@@8 ; icu_56::RuleChain `RTTI Type Descriptor'
		dd offset ??_R3RuleChain@icu_56@@8 ; icu_56::RuleChain::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 7DA8h
		public ??_R0?AVRuleChain@icu_56@@@8
; class	icu_56::RuleChain `RTTI	Type Descriptor'
??_R0?AVRuleChain@icu_56@@@8 dd	offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00007DA0o
					; .rdata$r:icu_56::RuleChain::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avrulechain@	db '.?AVRuleChain@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7DC8h
		public ??_R3RuleChain@icu_56@@8
; icu_56::RuleChain::`RTTI Class Hierarchy Descriptor'
??_R3RuleChain@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00007DA4o
					; .rdata$r:00007DFCo
		dd 2
		dd offset ??_R2RuleChain@icu_56@@8 ; icu_56::RuleChain::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7DD8h
		public ??_R2RuleChain@icu_56@@8
; icu_56::RuleChain::`RTTI Base	Class Array'
??_R2RuleChain@icu_56@@8 dd offset ??_R1A@?0A@EA@RuleChain@icu_56@@8
					; DATA XREF: .rdata$r:00007DD4o
					; icu_56::RuleChain::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7DE4h
		public ??_R1A@?0A@EA@RuleChain@icu_56@@8
; icu_56::RuleChain::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@RuleChain@icu_56@@8 dd offset ??_R0?AVRuleChain@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::RuleChain::`RTTI Base Class Array'o
					; icu_56::RuleChain `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3RuleChain@icu_56@@8 ; icu_56::RuleChain::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::RuleChain::`scalar deleting	destructor'(unsigned int)
		public ??_GRuleChain@icu_56@@UAEPAXI@Z
??_GRuleChain@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1RuleChain@icu_56@@UAE@XZ ; icu_56::RuleChain::~RuleChain(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_7E49
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7E49:				; CODE XREF: icu_56::RuleChain::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRuleChain@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleChain::RuleChain(icu_56::RuleChain *this, const	struct icu_56::RuleChain *)
		public ??0RuleChain@icu_56@@QAE@ABV01@@Z
??0RuleChain@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::PluralRules::operator=(icu_56::PluralRules	const &)+EDp
					; icu_56::RuleChain::RuleChain(icu_56::RuleChain const &):loc_7FFFp

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleChain@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleChain@icu_56@@6B@ ; const icu_56::RuleChain::`vftable'
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 4		; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+44h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+arg_0]
		add	eax, 4Ch ; 'L'
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 4Ch ; 'L'  ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_0]
		add	eax, 8Ch ; ''
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 8Ch ; ''  ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+0CCh]
		mov	[eax+0CCh], dl
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+0CDh]
		mov	[eax+0CDh], dl
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+48h], 0
		jz	short loc_7FBF
		mov	esi, esp
		push	0Ch		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F8], eax
		mov	byte ptr [ebp+var_4], 3
		cmp	[ebp+var_F8], 0
		jz	short loc_7F99
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+48h]
		push	ecx		; struct icu_56::OrConstraint *
		mov	ecx, [ebp+var_F8] ; this
		call	??0OrConstraint@icu_56@@QAE@ABV01@@Z ; icu_56::OrConstraint::OrConstraint(icu_56::OrConstraint const &)
		mov	[ebp+var_10C], eax
		jmp	short loc_7FA3
; ---------------------------------------------------------------------------

loc_7F99:				; CODE XREF: icu_56::RuleChain::RuleChain(icu_56::RuleChain const &)+119j
		mov	[ebp+var_10C], 0

loc_7FA3:				; CODE XREF: icu_56::RuleChain::RuleChain(icu_56::RuleChain const &)+133j
		mov	edx, [ebp+var_10C]
		mov	[ebp+var_104], edx
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_104]
		mov	[eax+48h], ecx

loc_7FBF:				; CODE XREF: icu_56::RuleChain::RuleChain(icu_56::RuleChain const &)+F2j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+44h], 0
		jz	short loc_8032
		mov	esi, esp
		push	0D0h ; ''      ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	byte ptr [ebp+var_4], 4
		cmp	[ebp+var_E0], 0
		jz	short loc_800C
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		push	ecx		; struct icu_56::RuleChain *
		mov	ecx, [ebp+var_E0] ; this

loc_7FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo
		call	??0RuleChain@icu_56@@QAE@ABV01@@Z ; icu_56::RuleChain::RuleChain(icu_56::RuleChain const &)
		mov	[ebp+var_10C], eax
		jmp	short loc_8016
; ---------------------------------------------------------------------------

loc_800C:				; CODE XREF: icu_56::RuleChain::RuleChain(icu_56::RuleChain const &)+18Cj
		mov	[ebp+var_10C], 0

loc_8016:				; CODE XREF: icu_56::RuleChain::RuleChain(icu_56::RuleChain const &)+1A6j
		mov	edx, [ebp+var_10C]
		mov	[ebp+var_EC], edx
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_EC]
		mov	[eax+44h], ecx

loc_8032:				; CODE XREF: icu_56::RuleChain::RuleChain(icu_56::RuleChain const &)+162j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0RuleChain@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8060h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:0000811Co
		mov	ecx, [ebp-14h]
		add	ecx, 4		; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$1 proc near
					; DATA XREF: .xdata$x:00008124o
		mov	ecx, [ebp-14h]
		add	ecx, 4Ch ; 'L'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$2 proc near
					; DATA XREF: .xdata$x:0000812Co
		mov	ecx, [ebp-14h]
		add	ecx, 8Ch ; ''  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$3 proc near
					; DATA XREF: .xdata$x:00008134o
		mov	esi, esp
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$4 proc near
					; DATA XREF: .xdata$x:0000813Co
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleChain@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::RuleChain::RuleChain(icu_56::RuleChain const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleChain@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleChain@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 80F4h
__ehfuncinfo$??0RuleChain@icu_56@@QAE@ABV01@@Z dd 19930522h, 5
					; DATA XREF: __ehhandler$??0RuleChain@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0RuleChain@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$??0RuleChain@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000080FCo
		dd offset __unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$0
		dd 0
		dd offset __unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$1
		dd 1
		dd offset __unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$2
		dd 2
		dd offset __unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$3
		dd 2
		dd offset __unwindfunclet$??0RuleChain@icu_56@@QAE@ABV01@@Z$4
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8140h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleChain::~RuleChain(icu_56::RuleChain *__hidden this)
		public ??1RuleChain@icu_56@@UAE@XZ
??1RuleChain@icu_56@@UAE@XZ proc near	; CODE XREF: icu_56::RuleChain::`scalar	deleting destructor'(uint)+26p

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1RuleChain@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleChain@icu_56@@6B@ ; const icu_56::RuleChain::`vftable'
		mov	[ebp+var_4], 2
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+44h]
		mov	[ebp+var_F8], ecx
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_104], edx
		cmp	[ebp+var_104], 0
		jz	short loc_81D8
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_104]
		mov	edx, [eax]
		mov	ecx, [ebp+var_104]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_81E2
; ---------------------------------------------------------------------------

loc_81D8:				; CODE XREF: icu_56::RuleChain::~RuleChain(void)+71j
		mov	[ebp+var_10C], 0

loc_81E2:				; CODE XREF: icu_56::RuleChain::~RuleChain(void)+96j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_8228
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_8232
; ---------------------------------------------------------------------------

loc_8228:				; CODE XREF: icu_56::RuleChain::~RuleChain(void)+C1j
		mov	[ebp+var_10C], 0

loc_8232:				; CODE XREF: icu_56::RuleChain::~RuleChain(void)+E6j
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 8Ch ; ''  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 4Ch ; 'L'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		add	ecx, 4		; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1RuleChain@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 82A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1RuleChain@icu_56@@UAE@XZ$0 proc near	; DATA XREF: .xdata$x:00008308o
		mov	ecx, [ebp-14h]
		add	ecx, 4		; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1RuleChain@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1RuleChain@icu_56@@UAE@XZ$1 proc near	; DATA XREF: .xdata$x:00008310o
		mov	ecx, [ebp-14h]
		add	ecx, 4Ch ; 'L'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1RuleChain@icu_56@@UAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1RuleChain@icu_56@@UAE@XZ$2 proc near	; DATA XREF: .xdata$x:00008318o
		mov	ecx, [ebp-14h]
		add	ecx, 8Ch ; ''  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1RuleChain@icu_56@@UAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1RuleChain@icu_56@@UAE@XZ	proc near
					; DATA XREF: icu_56::RuleChain::~RuleChain(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1RuleChain@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1RuleChain@icu_56@@UAE@XZ	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8304h
__unwindtable$??1RuleChain@icu_56@@UAE@XZ dd 0FFFFFFFFh	; DATA XREF: .xdata$x:00008324o
		dd offset __unwindfunclet$??1RuleChain@icu_56@@UAE@XZ$0
		align 10h
		dd offset __unwindfunclet$??1RuleChain@icu_56@@UAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??1RuleChain@icu_56@@UAE@XZ$2
__ehfuncinfo$??1RuleChain@icu_56@@UAE@XZ dd 19930522h, 3
					; DATA XREF: __ehhandler$??1RuleChain@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1RuleChain@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8340h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::RuleChain::select(class icu_56::FixedDecimal const &)const
		public ?select@RuleChain@icu_56@@QBE?AVUnicodeString@2@ABVFixedDecimal@2@@Z
?select@RuleChain@icu_56@@QBE?AVUnicodeString@2@ABVFixedDecimal@2@@Z proc near
					; CODE XREF: icu_56::PluralRules::select(icu_56::FixedDecimal const &)+75p

var_E4		= byte ptr -0E4h
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_E0], 0
		mov	eax, [ebp+arg_4]
		movsx	ecx, byte ptr [eax+2Ah]
		test	ecx, ecx
		jnz	short loc_83D4
		mov	eax, [ebp+var_8]
		mov	[ebp+var_14], eax
		jmp	short loc_8389
; ---------------------------------------------------------------------------

loc_8380:				; CODE XREF: icu_56::RuleChain::select(icu_56::FixedDecimal const &):loc_83D2j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+44h]
		mov	[ebp+var_14], ecx

loc_8389:				; CODE XREF: icu_56::RuleChain::select(icu_56::FixedDecimal const &)+3Ej
		cmp	[ebp+var_14], 0
		jz	short loc_83D4
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::FixedDecimal *
		mov	ecx, [ebp+var_14]
		mov	ecx, [ecx+48h]	; this
		call	?isFulfilled@OrConstraint@icu_56@@QAECABVFixedDecimal@2@@Z ; icu_56::OrConstraint::isFulfilled(icu_56::FixedDecimal const &)
		movsx	edx, al
		test	edx, edx
		jz	short loc_83D2
		mov	eax, [ebp+var_14]
		add	eax, 4
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_E0]
		or	ecx, 1
		mov	[ebp+var_E0], ecx
		mov	eax, [ebp+arg_0]
		jmp	short loc_8401
; ---------------------------------------------------------------------------

loc_83D2:				; CODE XREF: icu_56::RuleChain::select(icu_56::FixedDecimal const &)+63j
		jmp	short loc_8380
; ---------------------------------------------------------------------------

loc_83D4:				; CODE XREF: icu_56::RuleChain::select(icu_56::FixedDecimal const &)+36j
					; icu_56::RuleChain::select(icu_56::FixedDecimal const &)+4Dj
		mov	esi, esp
		push	5		; int
		push	offset _PLURAL_KEYWORD_OTHER ; "other"
		push	1		; signed __int8
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_E0]
		or	eax, 1
		mov	[ebp+var_E0], eax
		mov	eax, [ebp+arg_0]

loc_8401:				; CODE XREF: icu_56::RuleChain::select(icu_56::FixedDecimal const &)+90j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?select@RuleChain@icu_56@@QBE?AVUnicodeString@2@ABVFixedDecimal@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8418h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleChain::dumpRules(icu_56::RuleChain *this,	struct icu_56::UnicodeString *)
		public ?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z
?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::PluralRules::getRules(void)+7Bp
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+BECp

var_778		= dword	ptr -778h
var_774		= dword	ptr -774h
var_76C		= byte ptr -76Ch
var_724		= byte ptr -724h
var_6DC		= byte ptr -6DCh
var_694		= byte ptr -694h
var_64C		= byte ptr -64Ch
var_604		= byte ptr -604h
var_5BC		= byte ptr -5BCh
var_574		= byte ptr -574h
var_52C		= byte ptr -52Ch
var_4E4		= byte ptr -4E4h
var_49C		= byte ptr -49Ch
var_454		= byte ptr -454h
var_40C		= byte ptr -40Ch
var_3C4		= byte ptr -3C4h
var_37C		= byte ptr -37Ch
var_334		= byte ptr -334h
var_2EC		= byte ptr -2ECh
var_2A4		= byte ptr -2A4h
var_25C		= byte ptr -25Ch
var_214		= byte ptr -214h
var_1CC		= byte ptr -1CCh
var_184		= byte ptr -184h
var_7C		= dword	ptr -7Ch
var_70		= dword	ptr -70h
var_64		= dword	ptr -64h
var_58		= dword	ptr -58h
var_4C		= dword	ptr -4Ch
var_40		= word ptr -40h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 76Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_778]
		mov	ecx, 1DBh
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+48h], 0
		jz	loc_8F85
		mov	eax, [ebp+var_18]
		add	eax, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	3Ah ; ':'
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@_W@Z ; icu_56::UnicodeString::operator+=(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	20h ; ' '
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@_W@Z ; icu_56::UnicodeString::operator+=(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+48h]
		mov	[ebp+var_4C], ecx

loc_84B4:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&):loc_8F80j
		cmp	[ebp+var_4C], 0
		jz	loc_8F85
		mov	eax, [ebp+var_4C]
		mov	ecx, [eax+4]
		mov	[ebp+var_58], ecx

loc_84C7:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&):loc_8F00j
		cmp	[ebp+var_58], 0
		jz	loc_8F05
		mov	eax, [ebp+var_58]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_84F1
		mov	eax, [ebp+var_58]
		cmp	dword ptr [eax+10h], 0
		jnz	short loc_84F1
		mov	eax, [ebp+var_58]
		cmp	dword ptr [eax+0Ch], 0FFFFFFFFh
		jnz	short loc_84F1
		jmp	loc_8E85
; ---------------------------------------------------------------------------

loc_84F1:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+C0j
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+C9j ...
		mov	eax, [ebp+var_58]
		cmp	dword ptr [eax+4], 0
		jnz	loc_86D7
		mov	eax, [ebp+var_58]
		cmp	dword ptr [eax+10h], 0
		jnz	loc_86D7
		mov	eax, [ebp+var_58]
		mov	ecx, [eax+18h]
		push	ecx
		lea	edx, [ebp+var_76C]
		push	edx
		call	?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z ; icu_56::tokenString(icu_56::tokenType)
		add	esp, 8
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_76C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_19LBAIPPJI@?$AA?5?$AAi?$AAs?$AA?5?$AA?$AA@	; " is "
		push	1		; signed __int8
		lea	ecx, [ebp+var_724] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 1
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_724] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_58]
		movsx	ecx, byte ptr [eax+14h]
		test	ecx, ecx
		jz	short loc_8652
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_19OKBBPBLE@?$AAn?$AAo?$AAt?$AA?5?$AA?$AA@ ; "not "
		push	1		; signed __int8
		lea	ecx, [ebp+var_6DC] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 2
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_6DC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8652:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+1CCj
		push	0
		push	0Ah
		mov	eax, [ebp+var_58]
		mov	ecx, [eax+0Ch]
		push	ecx
		push	10h
		lea	edx, [ebp+var_40]
		push	edx
		call	_uprv_itou_56
		add	esp, 14h
		mov	esi, esp
		lea	eax, [ebp+var_40]
		push	eax		; wchar_t *
		lea	ecx, [ebp+var_694] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PB_W@Z ; icu_56::UnicodeString::UnicodeString(wchar_t const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	ecx, [ebp+var_774]
		mov	[ebp+var_778], ecx
		mov	[ebp+var_4], 3
		mov	esi, esp
		mov	edx, [ebp+var_778]
		push	edx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_694] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_8E85
; ---------------------------------------------------------------------------

loc_86D7:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+E0j
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+EDj
		mov	eax, [ebp+var_58]
		mov	ecx, [eax+18h]
		push	ecx
		lea	edx, [ebp+var_64C]
		push	edx
		call	?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z ; icu_56::tokenString(icu_56::tokenType)
		add	esp, 8
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 4
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_64C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	20h ; ' '
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@_W@Z ; icu_56::UnicodeString::operator+=(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_58]
		cmp	dword ptr [eax+4], 1
		jnz	loc_8848
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_19CPAEICM@?$AAm?$AAo?$AAd?$AA?5?$AA?$AA@ ;	"mod "
		push	1		; signed __int8
		lea	ecx, [ebp+var_604] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 5
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_604] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0
		push	0Ah
		mov	eax, [ebp+var_58]
		mov	ecx, [eax+8]
		push	ecx
		push	10h
		lea	edx, [ebp+var_40]
		push	edx
		call	_uprv_itou_56
		add	esp, 14h
		mov	esi, esp
		lea	eax, [ebp+var_40]
		push	eax		; wchar_t *
		lea	ecx, [ebp+var_5BC] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PB_W@Z ; icu_56::UnicodeString::UnicodeString(wchar_t const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	ecx, [ebp+var_774]
		mov	[ebp+var_778], ecx
		mov	[ebp+var_4], 6
		mov	esi, esp
		mov	edx, [ebp+var_778]
		push	edx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_5BC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8848:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+33Ej
		mov	eax, [ebp+var_58]
		cmp	dword ptr [eax+10h], 0
		jnz	loc_8A46
		mov	eax, [ebp+var_58]
		movsx	ecx, byte ptr [eax+14h]
		test	ecx, ecx
		jz	loc_8955
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1BC@FJMDCAIA@?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AA?$AA@ ; " is not "
		push	1		; signed __int8
		lea	ecx, [ebp+var_574] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 7
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_574] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0
		push	0Ah
		mov	eax, [ebp+var_58]
		mov	ecx, [eax+0Ch]
		push	ecx
		push	10h
		lea	edx, [ebp+var_40]
		push	edx
		call	_uprv_itou_56
		add	esp, 14h
		mov	esi, esp
		lea	eax, [ebp+var_40]
		push	eax		; wchar_t *
		lea	ecx, [ebp+var_52C] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PB_W@Z ; icu_56::UnicodeString::UnicodeString(wchar_t const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	ecx, [ebp+var_774]
		mov	[ebp+var_778], ecx
		mov	[ebp+var_4], 8
		mov	esi, esp
		mov	edx, [ebp+var_778]
		push	edx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_52C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_8A41
; ---------------------------------------------------------------------------

loc_8955:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+446j
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_19LBAIPPJI@?$AA?5?$AAi?$AAs?$AA?5?$AA?$AA@	; " is "
		push	1		; signed __int8
		lea	ecx, [ebp+var_4E4] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 9
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_4E4] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0
		push	0Ah
		mov	eax, [ebp+var_58]
		mov	ecx, [eax+0Ch]
		push	ecx
		push	10h
		lea	edx, [ebp+var_40]
		push	edx
		call	_uprv_itou_56
		add	esp, 14h
		mov	esi, esp
		lea	eax, [ebp+var_40]
		push	eax		; wchar_t *
		lea	ecx, [ebp+var_49C] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PB_W@Z ; icu_56::UnicodeString::UnicodeString(wchar_t const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	ecx, [ebp+var_774]
		mov	[ebp+var_778], ecx
		mov	[ebp+var_4], 0Ah
		mov	esi, esp
		mov	edx, [ebp+var_778]
		push	edx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_49C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8A41:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+538j
		jmp	loc_8E85
; ---------------------------------------------------------------------------

loc_8A46:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+437j
		mov	eax, [ebp+var_58]
		movsx	ecx, byte ptr [eax+14h]
		test	ecx, ecx
		jz	loc_8B3F
		mov	eax, [ebp+var_58]
		movsx	ecx, byte ptr [eax+15h]
		test	ecx, ecx
		jz	short loc_8ACE
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1BC@DDFBALKO@?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AA?5?$AA?$AA@ ; " not in "
		push	1		; signed __int8
		lea	ecx, [ebp+var_454] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 0Bh
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_454] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_8B3A
; ---------------------------------------------------------------------------

loc_8ACE:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+646j
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1BK@JPNOIFMG@?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAw?$AAi?$AAt?$AAh?$AAi?$AAn?$AA?5?$AA?$AA@ ; " not within "
		push	1		; signed __int8
		lea	ecx, [ebp+var_40C] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 0Ch
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_40C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8B3A:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+6B4j
		jmp	loc_8C24
; ---------------------------------------------------------------------------

loc_8B3F:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+637j
		mov	eax, [ebp+var_58]
		movsx	ecx, byte ptr [eax+15h]
		test	ecx, ecx
		jz	short loc_8BB8
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_19OEAOONN@?$AA?5?$AAi?$AAn?$AA?5?$AA?$AA@ ; " in "
		push	1		; signed __int8
		lea	ecx, [ebp+var_3C4] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 0Dh
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_3C4] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_8C24
; ---------------------------------------------------------------------------

loc_8BB8:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+730j
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1BC@HNKCDHAM@?$AA?5?$AAw?$AAi?$AAt?$AAh?$AAi?$AAn?$AA?5?$AA?$AA@ ;	" within "
		push	1		; signed __int8
		lea	ecx, [ebp+var_37C] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 0Eh
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_37C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8C24:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&):loc_8B3Aj
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+79Ej
		mov	[ebp+var_64], 0
		jmp	short loc_8C36
; ---------------------------------------------------------------------------

loc_8C2D:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&):loc_8E80j
		mov	eax, [ebp+var_64]
		add	eax, 2
		mov	[ebp+var_64], eax

loc_8C36:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+813j
		mov	esi, esp
		mov	eax, [ebp+var_58]
		mov	ecx, [eax+10h]	; this
		call	dword ptr ds:__imp_?size@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_64], eax
		jge	loc_8E85
		mov	esi, esp
		mov	eax, [ebp+var_64]
		push	eax		; int
		mov	ecx, [ebp+var_58]
		mov	ecx, [ecx+10h]	; this
		call	dword ptr ds:__imp_?elementAti@UVector32@icu_56@@QBEHH@Z ; icu_56::UVector32::elementAti(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_70], eax
		mov	eax, [ebp+var_64]
		add	eax, 1
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+var_58]
		mov	ecx, [ecx+10h]	; this
		call	dword ptr ds:__imp_?elementAti@UVector32@icu_56@@QBEHH@Z ; icu_56::UVector32::elementAti(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_7C], eax
		push	0
		push	0Ah
		mov	eax, [ebp+var_70]
		push	eax
		push	10h
		lea	ecx, [ebp+var_40]
		push	ecx
		call	_uprv_itou_56
		add	esp, 14h
		mov	esi, esp
		lea	eax, [ebp+var_40]
		push	eax		; wchar_t *
		lea	ecx, [ebp+var_334] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PB_W@Z ; icu_56::UnicodeString::UnicodeString(wchar_t const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	ecx, [ebp+var_774]
		mov	[ebp+var_778], ecx
		mov	[ebp+var_4], 0Fh
		mov	esi, esp
		mov	edx, [ebp+var_778]
		push	edx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_334] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@ ;	".."
		push	1		; signed __int8
		lea	ecx, [ebp+var_2EC] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 10h
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_2EC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0
		push	0Ah
		mov	eax, [ebp+var_7C]
		push	eax
		push	10h
		lea	ecx, [ebp+var_40]
		push	ecx
		call	_uprv_itou_56
		add	esp, 14h
		mov	esi, esp
		lea	eax, [ebp+var_40]
		push	eax		; wchar_t *
		lea	ecx, [ebp+var_2A4] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PB_W@Z ; icu_56::UnicodeString::UnicodeString(wchar_t const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	ecx, [ebp+var_774]
		mov	[ebp+var_778], ecx
		mov	[ebp+var_4], 11h
		mov	esi, esp
		mov	edx, [ebp+var_778]
		push	edx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_2A4] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, [ebp+var_64]
		add	esi, 2
		mov	edi, esp
		mov	eax, [ebp+var_58]
		mov	ecx, [eax+10h]	; this
		call	dword ptr ds:__imp_?size@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::size(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jge	short loc_8E80
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_15JOGBDECP@?$AA?0?$AA?5?$AA?$AA@ ;	", "
		push	1		; signed __int8
		lea	ecx, [ebp+var_25C] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 12h
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_25C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8E80:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+9FAj
		jmp	loc_8C2D
; ---------------------------------------------------------------------------

loc_8E85:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+D4j
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+2BAj ...
		mov	eax, [ebp+var_58]
		mov	ecx, [eax+1Ch]
		mov	[ebp+var_58], ecx
		cmp	[ebp+var_58], 0
		jz	short loc_8F00
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1M@FEAINNNN@?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AA?$AA@ ;	" and "
		push	1		; signed __int8
		lea	ecx, [ebp+var_214] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 13h
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_214] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8F00:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+A7Aj
		jmp	loc_84C7
; ---------------------------------------------------------------------------

loc_8F05:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+B3j
		mov	eax, [ebp+var_4C]
		mov	ecx, [eax+8]
		mov	[ebp+var_4C], ecx
		cmp	[ebp+var_4C], 0
		jz	short loc_8F80
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_19LMDLCFLK@?$AA?5?$AAo?$AAr?$AA?5?$AA?$AA@	; " or "
		push	1		; signed __int8
		lea	ecx, [ebp+var_1CC] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 14h
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_1CC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8F80:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+AFAj
		jmp	loc_84B4
; ---------------------------------------------------------------------------

loc_8F85:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+4Cj
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+A0j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+44h], 0
		jz	short loc_9009
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_15IALCAGAM@?$AA?$DL?$AA?5?$AA?$AA@	; "; "
		push	1		; signed __int8
		lea	ecx, [ebp+var_184] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_774], eax
		mov	eax, [ebp+var_774]
		mov	[ebp+var_778], eax
		mov	[ebp+var_4], 15h
		mov	esi, esp
		mov	ecx, [ebp+var_778]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator+=(icu_56::UnicodeString	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_184] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+44h]	; this
		call	?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z ; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)

loc_9009:				; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+B74j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN56
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 778h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN56		dd 1			; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+BF5o
		dd offset $LN55
; ---------------------------------------------------------------------------

$LN55:					; DATA XREF: .text:0000904Co
		sar	bh, 0FFh
		jmp	dword ptr [eax]
; ---------------------------------------------------------------------------
		align 4
		dd offset $LN53		; "digitString"
$LN53		db 'digitString',0      ; DATA XREF: .text:00009058o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 9068h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$0 proc near
					; DATA XREF: .xdata$x:00009340o
		mov	esi, esp
		lea	ecx, [ebp-76Ch]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$1 proc near
					; DATA XREF: .xdata$x:00009348o
		mov	esi, esp
		lea	ecx, [ebp-724h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$2 proc near
					; DATA XREF: .xdata$x:00009350o
		mov	esi, esp
		lea	ecx, [ebp-6DCh]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$3 proc near
					; DATA XREF: .xdata$x:00009358o
		mov	esi, esp
		lea	ecx, [ebp-694h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$4 proc near
					; DATA XREF: .xdata$x:00009360o
		mov	esi, esp
		lea	ecx, [ebp-64Ch]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$5 proc near
					; DATA XREF: .xdata$x:00009368o
		mov	esi, esp
		lea	ecx, [ebp-604h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$5 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$6 proc near
					; DATA XREF: .xdata$x:00009370o
		mov	esi, esp
		lea	ecx, [ebp-5BCh]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$6 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$7 proc near
					; DATA XREF: .xdata$x:00009378o
		mov	esi, esp
		lea	ecx, [ebp-574h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$7 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$8 proc near
					; DATA XREF: .xdata$x:00009380o
		mov	esi, esp
		lea	ecx, [ebp-52Ch]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$8 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$9 proc near
					; DATA XREF: .xdata$x:00009388o
		mov	esi, esp
		lea	ecx, [ebp-4E4h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$9 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$10 proc near
					; DATA XREF: .xdata$x:00009390o
		mov	esi, esp
		lea	ecx, [ebp-49Ch]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$10 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$11 proc near
					; DATA XREF: .xdata$x:00009398o
		mov	esi, esp
		lea	ecx, [ebp-454h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$11 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$12 proc near
					; DATA XREF: .xdata$x:000093A0o
		mov	esi, esp
		lea	ecx, [ebp-40Ch]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$12 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$13 proc near
					; DATA XREF: .xdata$x:000093A8o
		mov	esi, esp
		lea	ecx, [ebp-3C4h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$13 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$14 proc near
					; DATA XREF: .xdata$x:000093B0o
		mov	esi, esp
		lea	ecx, [ebp-37Ch]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$14 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$15 proc near
					; DATA XREF: .xdata$x:000093B8o
		mov	esi, esp
		lea	ecx, [ebp-334h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$15 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$16 proc near
					; DATA XREF: .xdata$x:000093C0o
		mov	esi, esp
		lea	ecx, [ebp-2ECh]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$16 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$17 proc near
					; DATA XREF: .xdata$x:000093C8o
		mov	esi, esp
		lea	ecx, [ebp-2A4h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$17 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$18 proc near
					; DATA XREF: .xdata$x:000093D0o
		mov	esi, esp
		lea	ecx, [ebp-25Ch]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$18 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$19 proc near
					; DATA XREF: .xdata$x:000093D8o
		mov	esi, esp
		lea	ecx, [ebp-214h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$19 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$20 proc near
					; DATA XREF: .xdata$x:000093E0o
		mov	esi, esp
		lea	ecx, [ebp-1CCh]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$20 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$21 proc near
					; DATA XREF: .xdata$x:000093E8o
		mov	esi, esp
		lea	ecx, [ebp-184h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$21 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z proc	near
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-77Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9260h
		public ??_C@_15IALCAGAM@?$AA?$DL?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_15IALCAGAM@?$AA?$DL?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+B7Ao
		unicode	0, <; >,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9268h
		public ??_C@_19LMDLCFLK@?$AA?5?$AAo?$AAr?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_19LMDLCFLK@?$AA?5?$AAo?$AAr?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+B00o
		unicode	0, < or	>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9274h
		public ??_C@_1M@FEAINNNN@?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_1M@FEAINNNN@?$AA?5?$AAa?$AAn?$AAd?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+A80o
		unicode	0, < and >,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9280h
		public ??_C@_15JOGBDECP@?$AA?0?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_15JOGBDECP@?$AA?0?$AA?5?$AA?$AA@:	; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+A00o
		unicode	0, <, >,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9288h
		public ??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@
; wchar_t `string'
??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@:	; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+8F8o
		unicode	0, <..>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9290h
		public ??_C@_1BC@HNKCDHAM@?$AA?5?$AAw?$AAi?$AAt?$AAh?$AAi?$AAn?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_1BC@HNKCDHAM@?$AA?5?$AAw?$AAi?$AAt?$AAh?$AAi?$AAn?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+7A4o
		unicode	0, < within >,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 92A4h
		public ??_C@_19OEAOONN@?$AA?5?$AAi?$AAn?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_19OEAOONN@?$AA?5?$AAi?$AAn?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+736o
		unicode	0, < in	>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 92B0h
		public ??_C@_1BK@JPNOIFMG@?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAw?$AAi?$AAt?$AAh?$AAi?$AAn?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_1BK@JPNOIFMG@?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAw?$AAi?$AAt?$AAh?$AAi?$AAn?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+6BAo
		unicode	0, < not within	>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 92CCh
		public ??_C@_1BC@DDFBALKO@?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_1BC@DDFBALKO@?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+64Co
		unicode	0, < not in >,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 92E0h
		public ??_C@_1BC@FJMDCAIA@?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_1BC@FJMDCAIA@?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+450o
		unicode	0, < is	not >,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 92F4h
		public ??_C@_19CPAEICM@?$AAm?$AAo?$AAd?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_19CPAEICM@?$AAm?$AAo?$AAd?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+348o
		unicode	0, <mod	>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9300h
		public ??_C@_19OKBBPBLE@?$AAn?$AAo?$AAt?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_19OKBBPBLE@?$AAn?$AAo?$AAt?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+1D2o
		unicode	0, <not	>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 930Ch
		public ??_C@_19LBAIPPJI@?$AA?5?$AAi?$AAs?$AA?5?$AA?$AA@
; wchar_t `string'
??_C@_19LBAIPPJI@?$AA?5?$AAi?$AAs?$AA?5?$AA?$AA@:
					; DATA XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+15Bo
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+541o
		unicode	0, < is	>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 9318h
__ehfuncinfo$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z dd 19930522h, 16h
					; DATA XREF: __ehhandler$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z+1Eo
		dd offset __unwindtable$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00009320o
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$1
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$2
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$3
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$4
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$5
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$6
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$7
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$8
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$9
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$10
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$11
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$12
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$13
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$14
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$15
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$16
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$17
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$18
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$19
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$20
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?dumpRules@RuleChain@icu_56@@QAEXAAVUnicodeString@2@@Z$21
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 93ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	icu_56::UnicodeString __cdecl icu_56::tokenString(enum	icu_56::tokenType)
?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z proc	near
					; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+101p
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+2CDp

var_128		= dword	ptr -128h
var_120		= dword	ptr -120h
var_54		= byte ptr -54h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 11Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_128]
		mov	ecx, 47h ; 'G'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_120], 0
		mov	esi, esp
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_128], eax
		mov	ecx, [ebp+var_128]
		sub	ecx, 15h
		mov	[ebp+var_128], ecx
		cmp	[ebp+var_128], 4 ; switch 5 cases
		ja	short loc_94EB	; jumptable 00009476 default case
		mov	edx, [ebp+var_128]
		jmp	ds:$LN18[edx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN6_2:					; CODE XREF: icu_56::tokenString(icu_56::tokenType)+8Aj
					; DATA XREF: .text:$LN18o
		mov	esi, esp	; jumptable 00009476 case 0
		push	6Eh ; 'n'       ; wchar_t
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_94FF
; ---------------------------------------------------------------------------

$LN5_1:					; CODE XREF: icu_56::tokenString(icu_56::tokenType)+8Aj
					; DATA XREF: .text:$LN18o
		mov	esi, esp	; jumptable 00009476 case 1
		push	69h ; 'i'       ; wchar_t
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_94FF
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: icu_56::tokenString(icu_56::tokenType)+8Aj
					; DATA XREF: .text:$LN18o
		mov	esi, esp	; jumptable 00009476 case 2
		push	66h ; 'f'       ; wchar_t
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_94FF
; ---------------------------------------------------------------------------

$LN3:					; CODE XREF: icu_56::tokenString(icu_56::tokenType)+8Aj
					; DATA XREF: .text:$LN18o
		mov	esi, esp	; jumptable 00009476 case 3
		push	76h ; 'v'       ; wchar_t
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_94FF
; ---------------------------------------------------------------------------

$LN2:					; CODE XREF: icu_56::tokenString(icu_56::tokenType)+8Aj
					; DATA XREF: .text:$LN18o
		mov	esi, esp	; jumptable 00009476 case 4
		push	74h ; 't'       ; wchar_t
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_94FF
; ---------------------------------------------------------------------------

loc_94EB:				; CODE XREF: icu_56::tokenString(icu_56::tokenType)+82j
		mov	esi, esp	; jumptable 00009476 default case
		push	7Eh ; '~'       ; wchar_t
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_94FF:				; CODE XREF: icu_56::tokenString(icu_56::tokenType)+A5j
					; icu_56::tokenString(icu_56::tokenType)+BBj ...
		mov	esi, esp
		lea	eax, [ebp+var_54]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	&&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_120]
		or	ecx, 1
		mov	[ebp+var_120], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 128h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN17_1		dd 1			; DATA XREF: icu_56::tokenString(icu_56::tokenType)+155o
		dd offset $LN16_1
$LN16_1		dd 0FFFFFFACh, 40h	; DATA XREF: .text:0000957Co
		dd offset $LN14_1
$LN14_1		dd 0FF8B0073h		; DATA XREF: .text:00009588o
$LN18		dd offset $LN6_2	; DATA XREF: icu_56::tokenString(icu_56::tokenType)+8Ar
		dd offset $LN5_1	; jump table for switch	statement
		dd offset $LN4
		dd offset $LN3
		dd offset $LN2
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 95A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z$0 proc near
					; DATA XREF: .xdata$x:00009614o
		mov	esi, esp
		lea	ecx, [ebp-54h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z$1 proc near
					; DATA XREF: .xdata$x:0000960Co
		mov	eax, [ebp-120h]
		and	eax, 1
		jz	$LN13_0
		and	dword ptr [ebp-120h], 0FFFFFFFEh
		mov	esi, esp
		mov	ecx, [ebp+8]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN13_0:				; CODE XREF: __unwindfunclet$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z$1+9j
		retn
__unwindfunclet$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z proc near
					; DATA XREF: icu_56::tokenString(icu_56::tokenType)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-12Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 9608h
__unwindtable$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00009620o
		dd offset __unwindfunclet$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z$1
		dd 0
		dd offset __unwindfunclet$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z$0
__ehfuncinfo$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z	dd 19930522h, 2
					; DATA XREF: __ehhandler$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z+1Eo
		dd offset __unwindtable$?tokenString@icu_56@@YA?AVUnicodeString@1@W4tokenType@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 963Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: enum	UErrorCode __thiscall icu_56::RuleChain::getKeywords(int, class	icu_56::UnicodeString *, int &)const
		public ?getKeywords@RuleChain@icu_56@@QBE?AW4UErrorCode@@HPAVUnicodeString@2@AAH@Z
?getKeywords@RuleChain@icu_56@@QBE?AW4UErrorCode@@HPAVUnicodeString@2@AAH@Z proc near
					; CODE XREF: icu_56::RuleChain::getKeywords(int,icu_56::UnicodeString *,int &)+8Ep

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		sub	eax, 1
		mov	ecx, [ebp+arg_8]
		cmp	[ecx], eax
		jge	short loc_96A8
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		shl	ecx, 6
		add	ecx, [ebp+arg_4]
		mov	[ebp+var_D0], ecx
		mov	edx, [ebp+arg_8]
		mov	eax, [edx]
		add	eax, 1
		mov	ecx, [ebp+arg_8]
		mov	[ecx], eax
		mov	edx, [ebp+var_8]
		add	edx, 4
		mov	esi, esp
		push	edx
		mov	ecx, [ebp+var_D0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_96AF
; ---------------------------------------------------------------------------

loc_96A8:				; CODE XREF: icu_56::RuleChain::getKeywords(int,icu_56::UnicodeString *,int &)+2Ej
		mov	eax, 0Fh
		jmp	short loc_96D5
; ---------------------------------------------------------------------------

loc_96AF:				; CODE XREF: icu_56::RuleChain::getKeywords(int,icu_56::UnicodeString *,int &)+6Aj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+44h], 0
		jz	short loc_96D3
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+44h]
		call	?getKeywords@RuleChain@icu_56@@QBE?AW4UErrorCode@@HPAVUnicodeString@2@AAH@Z ; icu_56::RuleChain::getKeywords(int,icu_56::UnicodeString *,int &)
		jmp	short loc_96D5
; ---------------------------------------------------------------------------
		jmp	short loc_96D5
; ---------------------------------------------------------------------------

loc_96D3:				; CODE XREF: icu_56::RuleChain::getKeywords(int,icu_56::UnicodeString *,int &)+7Aj
		xor	eax, eax

loc_96D5:				; CODE XREF: icu_56::RuleChain::getKeywords(int,icu_56::UnicodeString *,int &)+71j
					; icu_56::RuleChain::getKeywords(int,icu_56::UnicodeString *,int &)+93j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getKeywords@RuleChain@icu_56@@QBE?AW4UErrorCode@@HPAVUnicodeString@2@AAH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 96ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleChain::isKeyword(icu_56::RuleChain *this, const struct icu_56::UnicodeString *)
		public ?isKeyword@RuleChain@icu_56@@QBECABVUnicodeString@2@@Z
?isKeyword@RuleChain@icu_56@@QBECABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::RuleChain::isKeyword(icu_56::UnicodeString	const &)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 4
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_9733
		mov	al, 1
		jmp	short loc_9751
; ---------------------------------------------------------------------------

loc_9733:				; CODE XREF: icu_56::RuleChain::isKeyword(icu_56::UnicodeString	const &)+41j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+44h], 0
		jz	short loc_974F
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+44h]	; this
		call	?isKeyword@RuleChain@icu_56@@QBECABVUnicodeString@2@@Z ; icu_56::RuleChain::isKeyword(icu_56::UnicodeString const &)
		jmp	short loc_9751
; ---------------------------------------------------------------------------
		jmp	short loc_9751
; ---------------------------------------------------------------------------

loc_974F:				; CODE XREF: icu_56::RuleChain::isKeyword(icu_56::UnicodeString	const &)+4Ej
		xor	al, al

loc_9751:				; CODE XREF: icu_56::RuleChain::isKeyword(icu_56::UnicodeString	const &)+45j
					; icu_56::RuleChain::isKeyword(icu_56::UnicodeString const &)+5Fj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isKeyword@RuleChain@icu_56@@QBECABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9768h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralRuleParser::PluralRuleParser(icu_56::PluralRuleParser	*__hidden this)
		public ??0PluralRuleParser@icu_56@@QAE@XZ
??0PluralRuleParser@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+5Fp
					; icu_56::PluralRules::internalForLocale(icu_56::Locale	const &,UPluralType,UErrorCode &)+1EEp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7PluralRuleParser@icu_56@@6B@ ; const icu_56::PluralRuleParser::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	ecx, [ebp+var_8]
		add	ecx, 0Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+54h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+58h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+5Ch], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+60h], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0PluralRuleParser@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9808h
		dd offset ??_R4PluralRuleParser@icu_56@@6B@ ; const icu_56::PluralRuleParser::`RTTI Complete Object Locator'
		public ??_7PluralRuleParser@icu_56@@6B@
; const	icu_56::PluralRuleParser::`vftable'
??_7PluralRuleParser@icu_56@@6B@ dd offset ??_EPluralRuleParser@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::PluralRuleParser::PluralRuleParser(void)+26o
					; icu_56::PluralRuleParser::~PluralRuleParser(void)+26o
_rdata		ends			; icu_56::PluralRuleParser::`vector deleting destructor'(uint)

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9810h
		public ??_R4PluralRuleParser@icu_56@@6B@
; const	icu_56::PluralRuleParser::`RTTI	Complete Object	Locator'
??_R4PluralRuleParser@icu_56@@6B@ dd 3 dup(0) ;	DATA XREF: .rdata:00009808o
		dd offset ??_R0?AVPluralRuleParser@icu_56@@@8 ;	icu_56::PluralRuleParser `RTTI Type Descriptor'
		dd offset ??_R3PluralRuleParser@icu_56@@8 ; icu_56::PluralRuleParser::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 9824h
		public ??_R0?AVPluralRuleParser@icu_56@@@8
; class	icu_56::PluralRuleParser `RTTI Type Descriptor'
??_R0?AVPluralRuleParser@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000981Co
					; .rdata$r:icu_56::PluralRuleParser::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avpluralru_0	db '.?AVPluralRuleParser@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 984Ch
		public ??_R3PluralRuleParser@icu_56@@8
; icu_56::PluralRuleParser::`RTTI Class	Hierarchy Descriptor'
??_R3PluralRuleParser@icu_56@@8	dd 2 dup(0) ; DATA XREF: .rdata$r:00009820o
					; .rdata$r:00009880o
		dd 2
		dd offset ??_R2PluralRuleParser@icu_56@@8 ; icu_56::PluralRuleParser::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 985Ch
		public ??_R2PluralRuleParser@icu_56@@8
; icu_56::PluralRuleParser::`RTTI Base Class Array'
??_R2PluralRuleParser@icu_56@@8	dd offset ??_R1A@?0A@EA@PluralRuleParser@icu_56@@8
					; DATA XREF: .rdata$r:00009858o
					; icu_56::PluralRuleParser::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9868h
		public ??_R1A@?0A@EA@PluralRuleParser@icu_56@@8
; icu_56::PluralRuleParser::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@PluralRuleParser@icu_56@@8 dd offset ??_R0?AVPluralRuleParser@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::PluralRuleParser::`RTTI Base Class Array'o
					; icu_56::PluralRuleParser `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3PluralRuleParser@icu_56@@8 ; icu_56::PluralRuleParser::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9884h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralRuleParser::`scalar deleting destructor'(unsigned int)
		public ??_GPluralRuleParser@icu_56@@UAEPAXI@Z
??_GPluralRuleParser@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralRuleParser@icu_56@@UAE@XZ ; icu_56::PluralRuleParser::~PluralRuleParser(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_98CD
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_98CD:				; CODE XREF: icu_56::PluralRuleParser::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GPluralRuleParser@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 98E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralRuleParser::~PluralRuleParser(icu_56::PluralRuleParser *__hidden this)
		public ??1PluralRuleParser@icu_56@@UAE@XZ
??1PluralRuleParser@icu_56@@UAE@XZ proc	near
					; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+192p
					; __unwindfunclet$?createRules@PluralRules@icu_56@@SAPAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z$0+3j ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7PluralRuleParser@icu_56@@6B@ ; const icu_56::PluralRuleParser::`vftable'
		mov	ecx, [ebp+var_8]
		add	ecx, 0Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1PluralRuleParser@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9940h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::PluralRuleParser::getNumberValue(const struct icu_56::UnicodeString *)
		public ?getNumberValue@PluralRuleParser@icu_56@@SAHABVUnicodeString@2@@Z
?getNumberValue@PluralRuleParser@icu_56@@SAHABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+4B8p
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+4E1p ...

var_158		= byte ptr -158h
Str		= byte ptr -94h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 158h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_158]
		mov	ecx, 56h ; 'V'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	esi, esp
		push	0
		push	80h ; ''
		lea	eax, [ebp+Str]
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_?extract@UnicodeString@icu_56@@QBEHHHPADHW4EInvariant@12@@Z ; icu_56::UnicodeString::extract(int,int,char *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_C], eax
		mov	eax, [ebp+var_C]
		mov	[ebp+eax+Str], 0
		mov	esi, esp
		lea	eax, [ebp+Str]
		push	eax		; Str
		call	dword ptr ds:__imp__atoi
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 158h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getNumberValue@PluralRuleParser@icu_56@@SAHABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_2		dd 1			; DATA XREF: icu_56::PluralRuleParser::getNumberValue(icu_56::UnicodeString const &)+88o
		dd offset $LN4_0
$LN4_0		dd 0FFFFFF6Ch, 80h	; DATA XREF: .text:000099F8o
		dd offset $LN3_0	; "digits"
$LN3_0		db 'digits',0           ; DATA XREF: .text:00009A04o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9A10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::PluralRuleParser::checkSyntax(icu_56::PluralRuleParser *this,	enum UErrorCode	*)
		public ?checkSyntax@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z
?checkSyntax@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+E2p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9A4D
		jmp	loc_9CC8
; ---------------------------------------------------------------------------

loc_9A4D:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+50h], 0
		jz	short loc_9A7B
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+50h], 3
		jz	short loc_9A7B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]
		push	ecx
		mov	edx, [ebp+var_8]
		add	edx, 0Ch
		push	edx
		call	?getKeyType@PluralRuleParser@icu_56@@CA?AW4tokenType@2@ABVUnicodeString@2@W432@@Z ; icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString const &,icu_56::tokenType)
		add	esp, 8
		mov	ecx, [ebp+var_8]
		mov	[ecx+4Ch], eax

loc_9A7B:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+44j
					; icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+4Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]
		mov	[ebp+var_D0], ecx
		cmp	[ebp+var_D0], 19h ; switch 26 cases
		ja	$LN1		; jumptable 00009AA1 default case
		mov	edx, [ebp+var_D0]
		movzx	eax, ds:$LN30[edx]
		jmp	ds:$LN31_0[eax*4] ; switch jump
; ---------------------------------------------------------------------------

$LN23_1:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: .text:$LN31_0o
		mov	eax, [ebp+var_8] ; jumptable 00009AA1 cases 0,3
		cmp	dword ptr [eax+4Ch], 0Ah
		jz	short loc_9AC3
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 1Ch
		jz	short loc_9AC3
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10100h

loc_9AC3:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+9Fj
					; icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+A8j
		jmp	loc_9CC8
; ---------------------------------------------------------------------------

$LN21_0:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: .text:$LN31_0o
		mov	eax, [ebp+var_8] ; jumptable 00009AA1 cases 21-25
		cmp	dword ptr [eax+4Ch], 14h
		jz	short loc_9B10
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0Dh
		jz	short loc_9B10
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0Fh
		jz	short loc_9B10
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0Eh
		jz	short loc_9B10
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 13h
		jz	short loc_9B10
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 10h
		jz	short loc_9B10
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 11h
		jz	short loc_9B10
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10100h

loc_9B10:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+BFj
					; icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+C8j ...
		jmp	loc_9CC8
; ---------------------------------------------------------------------------

$LN19_1:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: .text:$LN31_0o
		mov	eax, [ebp+var_8] ; jumptable 00009AA1 case 10
		cmp	dword ptr [eax+4Ch], 5
		jz	short loc_9B27
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10100h

loc_9B27:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+10Cj
		jmp	loc_9CC8
; ---------------------------------------------------------------------------

$LN17_2:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: .text:$LN31_0o
		mov	eax, [ebp+var_8] ; jumptable 00009AA1 case 5
		cmp	dword ptr [eax+4Ch], 15h
		jz	short loc_9B6B
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 16h
		jz	short loc_9B6B
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 17h
		jz	short loc_9B6B
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 19h
		jz	short loc_9B6B
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 18h
		jz	short loc_9B6B
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 6
		jz	short loc_9B6B
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10100h

loc_9B6B:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+123j
					; icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+12Cj ...
		jmp	loc_9CC8
; ---------------------------------------------------------------------------

$LN15_2:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: .text:$LN31_0o
		mov	eax, [ebp+var_8] ; jumptable 00009AA1 case 20
		cmp	dword ptr [eax+4Ch], 1
		jz	short loc_9B8B
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0Eh
		jz	short loc_9B8B
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10100h

loc_9B8B:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+167j
					; icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+170j
		jmp	loc_9CC8
; ---------------------------------------------------------------------------

$LN13_1:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: .text:$LN31_0o
		mov	eax, [ebp+var_8] ; jumptable 00009AA1 case 14
		cmp	dword ptr [eax+4Ch], 1
		jz	short loc_9BB4
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0Fh
		jz	short loc_9BB4
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 13h
		jz	short loc_9BB4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10100h

loc_9BB4:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+187j
					; icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+190j ...
		jmp	loc_9CC8
; ---------------------------------------------------------------------------

$LN11:					; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: .text:$LN31_0o
		mov	eax, [ebp+var_8] ; jumptable 00009AA1 cases 8,13,15-17,19
		cmp	dword ptr [eax+4Ch], 1
		jz	short loc_9BCB
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10100h

loc_9BCB:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+1B0j
		jmp	loc_9CC8
; ---------------------------------------------------------------------------

$LN9_0:					; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: .text:$LN31_0o
		mov	eax, [ebp+var_8] ; jumptable 00009AA1 cases 11,12
		cmp	dword ptr [eax+4Ch], 15h
		jz	short loc_9C06
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 16h
		jz	short loc_9C06
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 17h
		jz	short loc_9C06
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 19h
		jz	short loc_9C06
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 18h
		jz	short loc_9C06
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10100h

loc_9C06:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+1C7j
					; icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+1D0j ...
		jmp	loc_9CC8
; ---------------------------------------------------------------------------

$LN7_3:					; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: .text:$LN31_0o
		mov	eax, [ebp+var_8] ; jumptable 00009AA1 case 2
		cmp	dword ptr [eax+4Ch], 1
		jz	short loc_9C1D
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10100h

loc_9C1D:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+202j
		jmp	loc_9CC8
; ---------------------------------------------------------------------------

$LN5_3:					; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: .text:$LN31_0o
		mov	eax, [ebp+var_8] ; jumptable 00009AA1 case 1
		cmp	dword ptr [eax+4Ch], 8
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 3
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 14h
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0Eh
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0Fh
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 10h
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 11h
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 13h
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0Bh
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0Ch
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 2
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 6
		jz	short loc_9CA0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 1Ch
		jz	short loc_9CA0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10100h

loc_9CA0:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+219j
					; icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+222j ...
		jmp	short loc_9CC8
; ---------------------------------------------------------------------------

$LN3_1:					; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: .text:$LN31_0o
		mov	eax, [ebp+var_8] ; jumptable 00009AA1 case 6
		cmp	dword ptr [eax+4Ch], 1Ah
		jz	short loc_9CBD
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 1Bh
		jz	short loc_9CBD
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10100h

loc_9CBD:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+299j
					; icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+2A2j
		jmp	short loc_9CC8
; ---------------------------------------------------------------------------

$LN1:					; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+7Ej
					; icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91j
					; DATA XREF: ...
		mov	eax, [ebp+arg_0] ; jumptable 00009AA1 default case
		mov	dword ptr [eax], 10100h

loc_9CC8:				; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+38j
					; icu_56::PluralRuleParser::checkSyntax(UErrorCode &):loc_9AC3j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?checkSyntax@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN31_0		dd offset $LN23_1	; DATA XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+91r
		dd offset $LN5_3	; jump table for switch	statement
		dd offset $LN7_3
		dd offset $LN17_2
		dd offset $LN3_1
		dd offset $LN11
		dd offset $LN19_1
		dd offset $LN9_0
		dd offset $LN13_1
		dd offset $LN15_2
		dd offset $LN21_0
		dd offset $LN1
$LN30		db	0,     1,     2,     0
					; DATA XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+8Ar
		db    0Bh,     3,     4,   0Bh ; indirect table	for switch statement
		db	5,   0Bh,     6,     7
		db	7,     5,     8,     5
		db	5,     5,   0Bh,     5
		db	9,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::PluralRuleParser::getNextToken(icu_56::PluralRuleParser *this, enum UErrorCode *)
		public ?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z
?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+BCp
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+8FCp ...

var_144		= dword	ptr -144h
var_140		= dword	ptr -140h
var_138		= byte ptr -138h
var_30		= dword	ptr -30h
var_24		= word ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_144]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9D8B
		jmp	loc_A16E
; ---------------------------------------------------------------------------

loc_9D8B:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+58j
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &)+C9j
		mov	esi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]	; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_18]
		cmp	[ecx+8], eax
		jge	short loc_9DF7
		mov	esi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		push	ecx		; int
		mov	edx, [ebp+var_18]
		mov	ecx, [edx+4]	; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_24], ax
		movzx	eax, [ebp+var_24]
		push	eax
		call	?charType@PluralRuleParser@icu_56@@CA?AW4tokenType@2@_W@Z ; icu_56::PluralRuleParser::charType(wchar_t)
		add	esp, 4
		mov	ecx, [ebp+var_18]
		mov	[ecx+4Ch], eax
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+4Ch], 4
		jz	short loc_9DE6
		jmp	short loc_9DF7
; ---------------------------------------------------------------------------

loc_9DE6:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+B6j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		add	ecx, 1
		mov	edx, [ebp+var_18]
		mov	[edx+8], ecx
		jmp	short loc_9D8B
; ---------------------------------------------------------------------------

loc_9DF7:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+7Aj
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &)+B8j
		mov	esi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]	; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_18]
		cmp	[ecx+8], eax
		jl	short loc_9E23
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+4Ch], 1Ch
		jmp	loc_A16E
; ---------------------------------------------------------------------------

loc_9E23:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+E6j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		mov	[ebp+var_30], ecx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4Ch]
		mov	[ebp+var_140], ecx
		mov	edx, [ebp+var_140]
		sub	edx, 1
		mov	[ebp+var_140], edx
		cmp	[ebp+var_140], 11h ; switch 18 cases
		ja	$LN1_0		; jumptable 00009E61 default case
		mov	eax, [ebp+var_140]
		movzx	ecx, ds:$LN29[eax]
		jmp	ds:$LN31_1[ecx*4] ; switch jump
; ---------------------------------------------------------------------------

$LN16_2:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+135j
					; DATA XREF: .text:$LN31_1o
		mov	eax, [ebp+var_30] ; jumptable 00009E61 cases 1,2,4,5,8,12,15,17
		add	eax, 1
		mov	[ebp+var_30], eax
		jmp	loc_A064
; ---------------------------------------------------------------------------

$LN15_3:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+135j
					; DATA XREF: .text:$LN31_1o
		mov	eax, [ebp+var_30] ; jumptable 00009E61 case 16
		add	eax, 1
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, ax
		cmp	edx, 3Dh ; '='
		jnz	short loc_9EA5
		mov	eax, [ebp+var_30]
		add	eax, 2
		mov	[ebp+var_30], eax
		jmp	short loc_9EB8
; ---------------------------------------------------------------------------

loc_9EA5:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+16Cj
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax

loc_9EB8:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+177j
		jmp	loc_A064
; ---------------------------------------------------------------------------

$LN11_0:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+135j
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &)+1EDj
					; DATA XREF: ...
		mov	eax, [ebp+var_18] ; jumptable 00009E61 case 9
		cmp	dword ptr [eax+4Ch], 0Ah
		jnz	short loc_9F1B
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax
		mov	esi, esp
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_30], eax
		jge	short loc_9F1B
		mov	esi, esp
		mov	eax, [ebp+var_30]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_24], ax
		movzx	eax, [ebp+var_24]
		push	eax
		call	?charType@PluralRuleParser@icu_56@@CA?AW4tokenType@2@_W@Z ; icu_56::PluralRuleParser::charType(wchar_t)
		add	esp, 4
		mov	ecx, [ebp+var_18]
		mov	[ecx+4Ch], eax
		jmp	short $LN11_0	; jumptable 00009E61 case 9
; ---------------------------------------------------------------------------

loc_9F1B:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+198j
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &)+1BBj
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+4Ch], 0Ah
		jmp	loc_A064
; ---------------------------------------------------------------------------

$LN8:					; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+135j
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &)+25Aj
					; DATA XREF: ...
		mov	eax, [ebp+var_18] ; jumptable 00009E61 case 0
		cmp	dword ptr [eax+4Ch], 1
		jnz	short loc_9F88
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax
		mov	esi, esp
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_30], eax
		jge	short loc_9F88
		mov	esi, esp
		mov	eax, [ebp+var_30]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_24], ax
		movzx	eax, [ebp+var_24]
		push	eax
		call	?charType@PluralRuleParser@icu_56@@CA?AW4tokenType@2@_W@Z ; icu_56::PluralRuleParser::charType(wchar_t)
		add	esp, 4
		mov	ecx, [ebp+var_18]
		mov	[ecx+4Ch], eax
		jmp	short $LN8	; jumptable 00009E61 case 0
; ---------------------------------------------------------------------------

loc_9F88:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+205j
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &)+228j
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+4Ch], 1
		jmp	loc_A064
; ---------------------------------------------------------------------------

$LN6_3:					; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+135j
					; DATA XREF: .text:$LN31_1o
		mov	esi, [ebp+var_30] ; jumptable 00009E61 case 6
		add	esi, 1
		mov	edi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]	; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jge	short loc_9FDA
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, ax
		cmp	edx, 2Eh ; '.'
		jz	short loc_9FE5

loc_9FDA:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+288j
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax
		jmp	short loc_A064
; ---------------------------------------------------------------------------

loc_9FE5:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+2ACj
		mov	esi, [ebp+var_30]
		add	esi, 2
		mov	edi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]	; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jge	short loc_A028
		mov	eax, [ebp+var_30]
		add	eax, 2
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, ax
		cmp	edx, 2Eh ; '.'
		jz	short loc_A03D

loc_A028:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+2D6j
		mov	eax, [ebp+var_30]
		add	eax, 2
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+4Ch], 8
		jmp	short loc_A064
; ---------------------------------------------------------------------------

loc_A03D:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+2FAj
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+4Ch], 9
		mov	eax, [ebp+var_30]
		add	eax, 3
		mov	[ebp+var_30], eax
		jmp	short loc_A064
; ---------------------------------------------------------------------------

$LN1_0:					; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+122j
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &)+135j
					; DATA XREF: ...
		mov	eax, [ebp+arg_0] ; jumptable 00009E61 default case
		mov	dword ptr [eax], 10100h
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax

loc_A064:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+145j
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &):loc_9EB8j ...
		mov	esi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]	; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_18]
		cmp	[ecx+8], eax
		jle	short loc_A0A7
		mov	edx, ds:?__LINE__Var@?1??getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::getNextToken(UErrorCode &)'::`2'::__LINE__Var
		add	edx, 4Fh ; 'O'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1DO@DKEHAJOG@?$AAr?$AAu?$AAl?$AAe?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAr?$AAu?$AAl?$AAe?$AAS?$AAr?$AAc?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@ ; "ruleIndex <= ruleSrc->length()"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A0A7:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+353j
		mov	esi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]	; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_30], eax
		jle	short loc_A0E7
		mov	ecx, ds:?__LINE__Var@?1??getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z@4JA ; long `icu_56::PluralRuleParser::getNextToken(UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 50h ; 'P'
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_1DM@JJBKDFHB@?$AAc?$AAu?$AAr?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAr?$AAu?$AAl?$AAe?$AAS?$AAr?$AAc?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@ ; "curIndex <= ruleSrc->length()"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A0E7:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+393j
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_30]
		sub	ecx, [eax+8]
		mov	esi, esp
		push	ecx		; int
		mov	edx, [ebp+var_18]
		mov	eax, [edx+8]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+4]
		push	edx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@HH@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString	const &,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_140], eax
		mov	eax, [ebp+var_140]
		mov	[ebp+var_144], eax
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	ecx, [ebp+var_144]
		push	ecx
		mov	ecx, [ebp+var_18]
		add	ecx, 0Ch
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z	; icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_30]
		mov	[eax+8], ecx

loc_A16E:				; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+5Aj
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &)+F2j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN31_1		dd offset $LN8		; DATA XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+135r
		dd offset $LN16_2	; jump table for switch	statement
		dd offset $LN6_3
		dd offset $LN11_0
		dd offset $LN15_3
		dd offset $LN1_0
$LN29		db	0,     1,     1,     5
					; DATA XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+12Er
		db	1,     1,     2,     5 ; indirect table	for switch statement
		db	1,     3,     5,     5
		db	1,     5,     5,     1
		db	4,     1
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0A1C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:0000A28Co
		mov	esi, esp
		lea	ecx, [ebp-138h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-148h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A208h
		public ??_C@_1DM@JJBKDFHB@?$AAc?$AAu?$AAr?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAr?$AAu?$AAl?$AAe?$AAS?$AAr?$AAc?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@
; wchar_t `string'
??_C@_1DM@JJBKDFHB@?$AAc?$AAu?$AAr?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAr?$AAu?$AAl?$AAe?$AAS?$AAr?$AAc?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@:
					; DATA XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+3A6o
		unicode	0, <curIndex >
		dw 3Ch
		unicode	0, <= ruleSrc->
		dw 3Eh
		unicode	0, <length()>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A244h
		public ??_C@_1DO@DKEHAJOG@?$AAr?$AAu?$AAl?$AAe?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAr?$AAu?$AAl?$AAe?$AAS?$AAr?$AAc?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@
; wchar_t `string'
??_C@_1DO@DKEHAJOG@?$AAr?$AAu?$AAl?$AAe?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAr?$AAu?$AAl?$AAe?$AAS?$AAr?$AAc?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@:
					; DATA XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+366o
		unicode	0, <ruleIndex >
		dw 3Ch
		unicode	0, <= ruleSrc->
		dw 3Eh
		unicode	0, <length()>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0A284h
		public ?__LINE__Var@?1??getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z@4JA
; long `public:	void __thiscall	icu_56::PluralRuleParser::getNextToken(enum  UErrorCode	&)'::`2'::__LINE__Var
?__LINE__Var@?1??getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z@4JA dd 499h
					; DATA XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+355r
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &)+395r
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0A288h
__unwindtable$?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000A298o
		dd offset __unwindfunclet$?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z$0
__ehfuncinfo$?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?getNextToken@PluralRuleParser@icu_56@@QAEXAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A2B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static enum	icu_56::tokenType __cdecl icu_56::PluralRuleParser::charType(wchar_t)
		public ?charType@PluralRuleParser@icu_56@@CA?AW4tokenType@2@_W@Z
?charType@PluralRuleParser@icu_56@@CA?AW4tokenType@2@_W@Z proc near
					; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+A1p
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &)+1DFp ...

var_C4		= dword	ptr -0C4h
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movzx	eax, [ebp+arg_0]
		cmp	eax, 30h ; '0'
		jl	short loc_A2EE
		movzx	eax, [ebp+arg_0]
		cmp	eax, 39h ; '9'
		jg	short loc_A2EE
		mov	eax, 1
		jmp	loc_A3A9
; ---------------------------------------------------------------------------

loc_A2EE:				; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+25j
					; icu_56::PluralRuleParser::charType(wchar_t)+2Ej
		movzx	eax, [ebp+arg_0]
		cmp	eax, 61h ; 'a'
		jl	short loc_A30A
		movzx	eax, [ebp+arg_0]
		cmp	eax, 7Ah ; 'z'
		jg	short loc_A30A
		mov	eax, 0Ah
		jmp	loc_A3A9
; ---------------------------------------------------------------------------

loc_A30A:				; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+41j
					; icu_56::PluralRuleParser::charType(wchar_t)+4Aj
		movzx	eax, [ebp+arg_0]
		mov	[ebp+var_C4], eax
		cmp	[ebp+var_C4], 2026h
		jg	short loc_A358
		cmp	[ebp+var_C4], 2026h
		jz	short loc_A399
		mov	ecx, [ebp+var_C4]
		sub	ecx, 20h ; ' '
		mov	[ebp+var_C4], ecx
		cmp	[ebp+var_C4], 5Eh ; '^' ; switch 95 cases
		ja	short $LN1_1	; jumptable 0000A351 default case
		mov	edx, [ebp+var_C4]
		movzx	eax, ds:$LN20_2[edx]
		jmp	ds:$LN21_1[eax*4] ; switch jump
; ---------------------------------------------------------------------------

loc_A358:				; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+6Aj
		jmp	short $LN1_1	; jumptable 0000A351 default case
; ---------------------------------------------------------------------------

$LN12_1:				; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+9Dj
					; DATA XREF: .text:$LN21_1o
		mov	eax, 5		; jumptable 0000A351 case 26
		jmp	short loc_A3A9
; ---------------------------------------------------------------------------

$LN11_1:				; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+9Dj
					; DATA XREF: .text:$LN21_1o
		mov	eax, 4		; jumptable 0000A351 case 0
		jmp	short loc_A3A9
; ---------------------------------------------------------------------------

$LN10_0:				; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+9Dj
					; DATA XREF: .text:$LN21_1o
		mov	eax, 3		; jumptable 0000A351 case 27
		jmp	short loc_A3A9
; ---------------------------------------------------------------------------

$LN9_1:					; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+9Dj
					; DATA XREF: .text:$LN21_1o
		mov	eax, 7		; jumptable 0000A351 case 14
		jmp	short loc_A3A9
; ---------------------------------------------------------------------------

$LN8_0:					; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+9Dj
					; DATA XREF: .text:$LN21_1o
		mov	eax, 2		; jumptable 0000A351 case 12
		jmp	short loc_A3A9
; ---------------------------------------------------------------------------

$LN7_4:					; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+9Dj
					; DATA XREF: .text:$LN21_1o
		mov	eax, 11h	; jumptable 0000A351 case 1
		jmp	short loc_A3A9
; ---------------------------------------------------------------------------

$LN6_4:					; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+9Dj
					; DATA XREF: .text:$LN21_1o
		mov	eax, 10h	; jumptable 0000A351 case 29
		jmp	short loc_A3A9
; ---------------------------------------------------------------------------

$LN5_4:					; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+9Dj
					; DATA XREF: .text:$LN21_1o
		mov	eax, 0Dh	; jumptable 0000A351 case 5
		jmp	short loc_A3A9
; ---------------------------------------------------------------------------

$LN4_1:					; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+9Dj
					; DATA XREF: .text:$LN21_1o
		mov	eax, 6		; jumptable 0000A351 case 32
		jmp	short loc_A3A9
; ---------------------------------------------------------------------------

loc_A399:				; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+76j
		mov	eax, 9
		jmp	short loc_A3A9
; ---------------------------------------------------------------------------

$LN2_0:					; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+9Dj
					; DATA XREF: .text:$LN21_1o
		mov	eax, 12h	; jumptable 0000A351 case 94
		jmp	short loc_A3A9
; ---------------------------------------------------------------------------

$LN1_1:					; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+8Ej
					; icu_56::PluralRuleParser::charType(wchar_t)+9Dj ...
		xor	eax, eax	; jumptable 0000A351 default case

loc_A3A9:				; CODE XREF: icu_56::PluralRuleParser::charType(wchar_t)+35j
					; icu_56::PluralRuleParser::charType(wchar_t)+51j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?charType@PluralRuleParser@icu_56@@CA?AW4tokenType@2@_W@Z endp

; ---------------------------------------------------------------------------
$LN21_1		dd offset $LN11_1, offset $LN7_4, offset $LN5_4, offset	$LN8_0
					; DATA XREF: icu_56::PluralRuleParser::charType(wchar_t)+9Dr
		dd offset $LN9_1, offset $LN12_1, offset $LN10_0, offset $LN6_4	; jump table for switch	statement
		dd offset $LN4_1, offset $LN2_0, offset	$LN1_1
$LN20_2		db	0,     1,   0Ah,   0Ah
					; DATA XREF: icu_56::PluralRuleParser::charType(wchar_t)+96r
		db    0Ah,     2,   0Ah,   0Ah ; indirect table	for switch statement
		db    0Ah,   0Ah,   0Ah,   0Ah
		db	3,   0Ah,     4,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,     5,     6
		db    0Ah,     7,   0Ah,   0Ah
		db	8,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,     9
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A43Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static enum	icu_56::tokenType __cdecl icu_56::PluralRuleParser::getKeyType(class icu_56::UnicodeString const &, enum  icu_56::tokenType)
		public ?getKeyType@PluralRuleParser@icu_56@@CA?AW4tokenType@2@ABVUnicodeString@2@W432@@Z
?getKeyType@PluralRuleParser@icu_56@@CA?AW4tokenType@2@ABVUnicodeString@2@W432@@Z proc near
					; CODE XREF: icu_56::PluralRuleParser::checkSyntax(UErrorCode &)+5Dp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0Ah
		jz	short loc_A468
		mov	eax, [ebp+arg_4]
		jmp	loc_A6C5
; ---------------------------------------------------------------------------

loc_A468:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+22j
		mov	esi, esp
		push	1		; int
		push	offset _PK_VAR_N ; wchar_t *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A494
		mov	[ebp+arg_4], 15h
		jmp	loc_A6C2
; ---------------------------------------------------------------------------

loc_A494:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+4Aj
		mov	esi, esp
		push	1		; int
		push	offset _PK_VAR_I ; wchar_t *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A4C0
		mov	[ebp+arg_4], 16h
		jmp	loc_A6C2
; ---------------------------------------------------------------------------

loc_A4C0:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+76j
		mov	esi, esp
		push	1		; int
		push	offset _PK_VAR_F ; wchar_t *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A4EC
		mov	[ebp+arg_4], 17h
		jmp	loc_A6C2
; ---------------------------------------------------------------------------

loc_A4EC:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+A2j
		mov	esi, esp
		push	1		; int
		push	offset _PK_VAR_T ; wchar_t *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A518
		mov	[ebp+arg_4], 19h
		jmp	loc_A6C2
; ---------------------------------------------------------------------------

loc_A518:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+CEj
		mov	esi, esp
		push	1		; int
		push	offset _PK_VAR_V ; wchar_t *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A544
		mov	[ebp+arg_4], 18h
		jmp	loc_A6C2
; ---------------------------------------------------------------------------

loc_A544:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+FAj
		mov	esi, esp
		push	2		; int
		push	offset _PK_IS	; "is"
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A570
		mov	[ebp+arg_4], 14h
		jmp	loc_A6C2
; ---------------------------------------------------------------------------

loc_A570:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+126j
		mov	esi, esp
		push	3		; int
		push	offset _PK_AND	; "and"
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A59C
		mov	[ebp+arg_4], 0Bh
		jmp	loc_A6C2
; ---------------------------------------------------------------------------

loc_A59C:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+152j
		mov	esi, esp
		push	2		; int
		push	offset _PK_IN	; "in"
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A5C8
		mov	[ebp+arg_4], 0Fh
		jmp	loc_A6C2
; ---------------------------------------------------------------------------

loc_A5C8:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+17Ej
		mov	esi, esp
		push	6		; int
		push	offset _PK_WITHIN ; "within"
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A5F4
		mov	[ebp+arg_4], 13h
		jmp	loc_A6C2
; ---------------------------------------------------------------------------

loc_A5F4:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+1AAj
		mov	esi, esp
		push	3		; int
		push	offset _PK_NOT	; "not"
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A620
		mov	[ebp+arg_4], 0Eh
		jmp	loc_A6C2
; ---------------------------------------------------------------------------

loc_A620:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+1D6j
		mov	esi, esp
		push	3		; int
		push	offset _PK_MOD	; "mod"
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A649
		mov	[ebp+arg_4], 0Dh
		jmp	short loc_A6C2
; ---------------------------------------------------------------------------

loc_A649:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+202j
		mov	esi, esp
		push	2		; int
		push	offset _PK_OR	; "or"
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A672
		mov	[ebp+arg_4], 0Ch
		jmp	short loc_A6C2
; ---------------------------------------------------------------------------

loc_A672:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+22Bj
		mov	esi, esp
		push	7		; int
		push	offset _PK_DECIMAL ; "decimal"
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A69B
		mov	[ebp+arg_4], 1Ah
		jmp	short loc_A6C2
; ---------------------------------------------------------------------------

loc_A69B:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+254j
		mov	esi, esp
		push	7		; int
		push	offset _PK_INTEGER ; "integer"
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A6C2
		mov	[ebp+arg_4], 1Bh

loc_A6C2:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+53j
					; icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString const &,icu_56::tokenType)+7Fj ...
		mov	eax, [ebp+arg_4]

loc_A6C5:				; CODE XREF: icu_56::PluralRuleParser::getKeyType(icu_56::UnicodeString	const &,icu_56::tokenType)+27j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getKeyType@PluralRuleParser@icu_56@@CA?AW4tokenType@2@ABVUnicodeString@2@W432@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A6DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::PluralKeywordEnumeration	*this, struct icu_56::RuleChain	*, enum	UErrorCode *)
		public ??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z
??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralRules::getKeywords(UErrorCode &)+9Cp

var_124		= dword	ptr -124h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_2C		= dword	ptr -2Ch
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_124]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0StringEnumeration@icu_56@@IAE@XZ ; icu_56::StringEnumeration::StringEnumeration(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7PluralKeywordEnumeration@icu_56@@6B@ ; const icu_56::PluralKeywordEnumeration::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+6Ch], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14]
		add	ecx, 70h ; 'p'  ; this
		call	dword ptr ds:__imp_??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::UVector::UVector(UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A781
		jmp	loc_A936
; ---------------------------------------------------------------------------

loc_A781:				; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+9Ej
		mov	esi, esp
		push	offset _uprv_deleteUObject_56 ;	void (__cdecl *)(void *)
		mov	ecx, [ebp+var_14]
		add	ecx, 70h ; 'p'  ; this
		call	dword ptr ds:__imp_?setDeleter@UVector@icu_56@@QAEP6AXPAX@ZP6AX0@Z@Z ; icu_56::UVector::setDeleter(void	(*)(void *))
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1D], 1
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_2C], eax

loc_A7A5:				; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+1B4j
		cmp	[ebp+var_2C], 0
		jz	loc_A895
		mov	esi, esp
		push	40h ; '@'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_110], eax
		mov	byte ptr [ebp+var_4], 2
		cmp	[ebp+var_110], 0
		jz	short loc_A80C
		mov	eax, [ebp+var_2C]
		add	eax, 4
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_110] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_110]
		mov	dword ptr [ecx], offset	??_SUnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`local vftable'
		mov	edx, [ebp+var_110]
		mov	[ebp+var_124], edx
		jmp	short loc_A816
; ---------------------------------------------------------------------------

loc_A80C:				; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+F8j
		mov	[ebp+var_124], 0

loc_A816:				; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+12Ej
		mov	eax, [ebp+var_124]
		mov	[ebp+var_11C], eax
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		mov	ecx, [ebp+arg_4]
		push	ecx		; enum UErrorCode *
		mov	edx, [ebp+var_11C]
		push	edx		; void *
		mov	ecx, [ebp+var_14]
		add	ecx, 70h ; 'p'  ; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A860
		jmp	loc_A936
; ---------------------------------------------------------------------------

loc_A860:				; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+17Dj
		mov	esi, esp
		push	5		; int
		push	offset _PLURAL_KEYWORD_OTHER ; "other"
		mov	ecx, [ebp+var_2C]
		add	ecx, 4		; this
		call	dword ptr ds:__imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z ;	icu_56::UnicodeString::compare(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A887
		mov	[ebp+var_1D], 0

loc_A887:				; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+1A5j
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax+44h]
		mov	[ebp+var_2C], ecx
		jmp	loc_A7A5
; ---------------------------------------------------------------------------

loc_A895:				; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+CDj
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jz	loc_A936
		mov	esi, esp
		push	40h ; '@'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F8], eax
		mov	byte ptr [ebp+var_4], 3
		cmp	[ebp+var_F8], 0
		jz	short loc_A8FC
		mov	esi, esp
		push	offset _PLURAL_KEYWORD_OTHER ; "other"
		mov	ecx, [ebp+var_F8] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PB_W@Z ; icu_56::UnicodeString::UnicodeString(wchar_t const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_F8]
		mov	dword ptr [eax], offset	??_SUnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`local vftable'
		mov	ecx, [ebp+var_F8]
		mov	[ebp+var_124], ecx
		jmp	short loc_A906
; ---------------------------------------------------------------------------

loc_A8FC:				; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+1EAj
		mov	[ebp+var_124], 0

loc_A906:				; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+21Ej
		mov	edx, [ebp+var_124]
		mov	[ebp+var_104], edx
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_104]
		push	ecx		; void *
		mov	ecx, [ebp+var_14]
		add	ecx, 70h ; 'p'  ; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A936:				; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+A0j
					; icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+17Fj ...
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0A964h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000AA38o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000AA40o
		mov	ecx, [ebp-14h]
		add	ecx, 70h ; 'p'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:0000AA48o
		mov	esi, esp
		mov	eax, [ebp-110h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:0000AA50o
		mov	esi, esp
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-128h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A9DCh
		dd offset ??_R4UnicodeString@icu_56@@6B@ ; const icu_56::UnicodeString::`RTTI Complete Object Locator'
		public ??_SUnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`local vftable'
??_SUnicodeString@icu_56@@6B@ dd offset	??_EUnicodeString@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+11Co
					; icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+20Co
					; icu_56::UnicodeString::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ ; icu_56::UnicodeString::getDynamicClassID(void)
		dd offset ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z ; icu_56::UnicodeString::extractBetween(int,int,icu_56::UnicodeString &)
		dd offset ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z ; icu_56::UnicodeString::handleReplaceBetween(int,int,icu_56::UnicodeString const &)
		dd offset ?copy@UnicodeString@icu_56@@UAEXHHH@Z	; icu_56::UnicodeString::copy(int,int,int)
		dd offset ?hasMetaData@UnicodeString@icu_56@@UBECXZ ; icu_56::UnicodeString::hasMetaData(void)
		dd offset ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ ;	icu_56::UnicodeString::clone(void)
		dd offset ?getLength@UnicodeString@icu_56@@MBEHXZ ; icu_56::UnicodeString::getLength(void)
		dd offset ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z ; icu_56::UnicodeString::getCharAt(int)
		dd offset ?getChar32At@UnicodeString@icu_56@@MBEHH@Z ; icu_56::UnicodeString::getChar32At(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0AA08h
		dd offset ??_R4PluralKeywordEnumeration@icu_56@@6B@ ; const icu_56::PluralKeywordEnumeration::`RTTI Complete Object Locator'
		public ??_7PluralKeywordEnumeration@icu_56@@6B@
; const	icu_56::PluralKeywordEnumeration::`vftable'
??_7PluralKeywordEnumeration@icu_56@@6B@ dd offset ??_EPluralKeywordEnumeration@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+5Eo
					; icu_56::PluralKeywordEnumeration::~PluralKeywordEnumeration(void)+45o
					; icu_56::PluralKeywordEnumeration::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@PluralKeywordEnumeration@icu_56@@UBEPAXXZ ; icu_56::PluralKeywordEnumeration::getDynamicClassID(void)
		dd offset ?clone@StringEnumeration@icu_56@@UBEPAV12@XZ ; icu_56::StringEnumeration::clone(void)
		dd offset ?count@PluralKeywordEnumeration@icu_56@@UBEHAAW4UErrorCode@@@Z ; icu_56::PluralKeywordEnumeration::count(UErrorCode &)
		dd offset ?next@StringEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z ;	icu_56::StringEnumeration::next(int *,UErrorCode &)
		dd offset ?unext@StringEnumeration@icu_56@@UAEPB_WPAHAAW4UErrorCode@@@Z	; icu_56::StringEnumeration::unext(int *,UErrorCode &)
		dd offset ?snext@PluralKeywordEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::PluralKeywordEnumeration::snext(UErrorCode	&)
		dd offset ?reset@PluralKeywordEnumeration@icu_56@@UAEXAAW4UErrorCode@@@Z ; icu_56::PluralKeywordEnumeration::reset(UErrorCode &)
		dd offset ??8StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator==(icu_56::StringEnumeration const &)
		dd offset ??9StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator!=(icu_56::StringEnumeration const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0AA34h
__unwindtable$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000AA5Co
		dd offset __unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$0
		align 10h
		dd offset __unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$2
		dd 1
		dd offset __unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$3
__ehfuncinfo$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z dd 19930522h, 4
					; DATA XREF: __ehhandler$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AA78h
		public ??_R4PluralKeywordEnumeration@icu_56@@6B@
; const	icu_56::PluralKeywordEnumeration::`RTTI	Complete Object	Locator'
??_R4PluralKeywordEnumeration@icu_56@@6B@ dd 3 dup(0) ;	DATA XREF: .rdata:0000AA08o
		dd offset ??_R0?AVPluralKeywordEnumeration@icu_56@@@8 ;	icu_56::PluralKeywordEnumeration `RTTI Type Descriptor'
		dd offset ??_R3PluralKeywordEnumeration@icu_56@@8 ; icu_56::PluralKeywordEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0AA8Ch
		public ??_R0?AVPluralKeywordEnumeration@icu_56@@@8
; class	icu_56::PluralKeywordEnumeration `RTTI Type Descriptor'
??_R0?AVPluralKeywordEnumeration@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000AA84o
					; .rdata$r:icu_56::PluralKeywordEnumeration::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avpluralkeyw	db '.?AVPluralKeywordEnumeration@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AABCh
		public ??_R3PluralKeywordEnumeration@icu_56@@8
; icu_56::PluralKeywordEnumeration::`RTTI Class	Hierarchy Descriptor'
??_R3PluralKeywordEnumeration@icu_56@@8	dd 2 dup(0) ; DATA XREF: .rdata$r:0000AA88o
					; .rdata$r:0000AAF8o
		dd 4
		dd offset ??_R2PluralKeywordEnumeration@icu_56@@8 ; icu_56::PluralKeywordEnumeration::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AACCh
		public ??_R2PluralKeywordEnumeration@icu_56@@8
; icu_56::PluralKeywordEnumeration::`RTTI Base Class Array'
??_R2PluralKeywordEnumeration@icu_56@@8	dd offset ??_R1A@?0A@EA@PluralKeywordEnumeration@icu_56@@8
					; DATA XREF: .rdata$r:0000AAC8o
					; icu_56::PluralKeywordEnumeration::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AAE0h
		public ??_R1A@?0A@EA@PluralKeywordEnumeration@icu_56@@8
; icu_56::PluralKeywordEnumeration::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@PluralKeywordEnumeration@icu_56@@8 dd offset ??_R0?AVPluralKeywordEnumeration@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::PluralKeywordEnumeration::`RTTI Base Class Array'o
					; icu_56::PluralKeywordEnumeration `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3PluralKeywordEnumeration@icu_56@@8 ; icu_56::PluralKeywordEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AAFCh
		public ??_R4UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`RTTI Complete Object Locator'
??_R4UnicodeString@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:0000A9DCo
		dd offset ??_R0?AVUnicodeString@icu_56@@@8 ; icu_56::UnicodeString `RTTI Type Descriptor'
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0AB10h
		public ??_R0?AVUnicodeString@icu_56@@@8
; class	icu_56::UnicodeString `RTTI Type Descriptor'
??_R0?AVUnicodeString@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000AB08o
					; .rdata$r:icu_56::UnicodeString::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avunicodestr	db '.?AVUnicodeString@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AB34h
		public ??_R3UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeString@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:0000AB0Co
					; .rdata$r:0000AB70o
		dd 4
		dd offset ??_R2UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AB44h
		public ??_R2UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Array'
??_R2UnicodeString@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeString@icu_56@@8
					; DATA XREF: .rdata$r:0000AB40o
					; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8 ;	icu_56::Replaceable::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AB58h
		public ??_R1A@?0A@EA@UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeString@icu_56@@8 dd offset	??_R0?AVUnicodeString@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeString::`RTTI Base	Class Array'o
					; icu_56::UnicodeString	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AB74h
		public ??_R1A@?0A@EA@Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Replaceable@icu_56@@8 dd offset ??_R0?AVReplaceable@icu_56@@@8
					; DATA XREF: .rdata$r:0000AB48o
					; .rdata$r:icu_56::Replaceable::`RTTI Base Class Array'o
					; icu_56::Replaceable `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0AB90h
		public ??_R0?AVReplaceable@icu_56@@@8
; class	icu_56::Replaceable `RTTI Type Descriptor'
??_R0?AVReplaceable@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::Replaceable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avreplaceabl	db '.?AVReplaceable@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0ABB4h
		public ??_R3Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Class Hierarchy Descriptor'
??_R3Replaceable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:0000AB8Co
		dd 3
		dd offset ??_R2Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0ABC4h
		public ??_R2Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Array'
??_R2Replaceable@icu_56@@8 dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8
					; DATA XREF: .rdata$r:0000ABC0o
					; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ABD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeString@icu_56@@UAEPAXI@Z
??_GUnicodeString@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_AC27
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_AC27:				; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+3Bj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeString@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AC40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralKeywordEnumeration::`scalar deleting destructor'(unsigned int)
		public ??_GPluralKeywordEnumeration@icu_56@@UAEPAXI@Z
??_GPluralKeywordEnumeration@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralKeywordEnumeration@icu_56@@UAE@XZ ; icu_56::PluralKeywordEnumeration::~PluralKeywordEnumeration(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_AC89
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_AC89:				; CODE XREF: icu_56::PluralKeywordEnumeration::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GPluralKeywordEnumeration@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ACA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::PluralKeywordEnumeration::snext(icu_56::PluralKeywordEnumeration *this, enum UErrorCode *)
		public ?snext@PluralKeywordEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z
?snext@PluralKeywordEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:0000AA24o

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_AD32
		mov	ecx, [ebp+var_8]
		add	ecx, 70h ; 'p'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_8]
		cmp	[ecx+6Ch], eax
		jge	short loc_AD32
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+6Ch]
		mov	[ebp+var_D0], ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+6Ch]
		add	eax, 1
		mov	ecx, [ebp+var_8]
		mov	[ecx+6Ch], eax
		mov	esi, esp
		mov	edx, [ebp+var_D0]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 70h ; 'p'  ; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_AD34
; ---------------------------------------------------------------------------

loc_AD32:				; CODE XREF: icu_56::PluralKeywordEnumeration::snext(UErrorCode	&)+36j
					; icu_56::PluralKeywordEnumeration::snext(UErrorCode &)+53j
		xor	eax, eax

loc_AD34:				; CODE XREF: icu_56::PluralKeywordEnumeration::snext(UErrorCode	&)+8Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?snext@PluralKeywordEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AD4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::PluralKeywordEnumeration::reset(icu_56::PluralKeywordEnumeration *this, enum UErrorCode *)
		public ?reset@PluralKeywordEnumeration@icu_56@@UAEXAAW4UErrorCode@@@Z
?reset@PluralKeywordEnumeration@icu_56@@UAEXAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:0000AA28o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+6Ch], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?reset@PluralKeywordEnumeration@icu_56@@UAEXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AD84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::PluralKeywordEnumeration::count(icu_56::PluralKeywordEnumeration *this, enum UErrorCode *)
		public ?count@PluralKeywordEnumeration@icu_56@@UBEHAAW4UErrorCode@@@Z
?count@PluralKeywordEnumeration@icu_56@@UBEHAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:0000AA18o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 70h ; 'p'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?count@PluralKeywordEnumeration@icu_56@@UBEHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ADD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralKeywordEnumeration::~PluralKeywordEnumeration(icu_56::PluralKeywordEnumeration *__hidden this)
		public ??1PluralKeywordEnumeration@icu_56@@UAE@XZ
??1PluralKeywordEnumeration@icu_56@@UAE@XZ proc	near
					; CODE XREF: icu_56::PluralKeywordEnumeration::`scalar deleting	destructor'(uint)+26p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1PluralKeywordEnumeration@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7PluralKeywordEnumeration@icu_56@@6B@ ; const icu_56::PluralKeywordEnumeration::`vftable'
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 70h ; 'p'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1PluralKeywordEnumeration@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0AE74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1PluralKeywordEnumeration@icu_56@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:0000AEA8o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1PluralKeywordEnumeration@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1PluralKeywordEnumeration@icu_56@@UAE@XZ proc near
					; DATA XREF: icu_56::PluralKeywordEnumeration::~PluralKeywordEnumeration(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1PluralKeywordEnumeration@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1PluralKeywordEnumeration@icu_56@@UAE@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0AEA4h
__unwindtable$??1PluralKeywordEnumeration@icu_56@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000AEB4o
		dd offset __unwindfunclet$??1PluralKeywordEnumeration@icu_56@@UAE@XZ$0
__ehfuncinfo$??1PluralKeywordEnumeration@icu_56@@UAE@XZ	dd 19930522h, 1
					; DATA XREF: __ehhandler$??1PluralKeywordEnumeration@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1PluralKeywordEnumeration@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AED0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FixedDecimal::FixedDecimal(icu_56::FixedDecimal *this, const struct	icu_56::VisibleDigits *)
		public ??0FixedDecimal@icu_56@@QAE@ABVVisibleDigits@1@@Z
??0FixedDecimal@icu_56@@QAE@ABVVisibleDigits@1@@Z proc near
					; CODE XREF: icu_56::PluralRules::select(icu_56::VisibleDigitsWithExponent const &)+77p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 28h ; '('
		push	eax		; signed __int8	*
		mov	ecx, [ebp+var_8]
		add	ecx, 8
		push	ecx		; int *
		mov	edx, [ebp+var_8]
		add	edx, 18h
		push	edx		; __int64 *
		mov	eax, [ebp+var_8]
		add	eax, 10h
		push	eax		; __int64 *
		mov	ecx, [ebp+var_8]
		add	ecx, 20h ; ' '
		push	ecx		; __int64 *
		mov	edx, [ebp+var_8]
		push	edx		; double *
		mov	ecx, [ebp+arg_0] ; this
		call	?getFixedDecimal@VisibleDigits@icu_56@@QBEXAANAA_J11AAHAAC@Z ; icu_56::VisibleDigits::getFixedDecimal(double &,__int64 &,__int64 &,__int64 &,int &,signed char &)
		mov	ecx, [ebp+arg_0] ; this
		call	?isNegative@VisibleDigits@icu_56@@QBECXZ ; icu_56::VisibleDigits::isNegative(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+29h], al
		mov	ecx, [ebp+arg_0] ; this
		call	?isNaNOrInfinity@VisibleDigits@icu_56@@QBECXZ ;	icu_56::VisibleDigits::isNaNOrInfinity(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+2Ah], al
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FixedDecimal@icu_56@@QAE@ABVVisibleDigits@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AF58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FixedDecimal::FixedDecimal(icu_56::FixedDecimal *this, double, int,	__int64)
		public ??0FixedDecimal@icu_56@@QAE@NH_J@Z
??0FixedDecimal@icu_56@@QAE@NH_J@Z proc	near

var_EC		= qword	ptr -0ECh
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= qword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, dword ptr [ebp+arg_C+4]
		push	eax
		mov	ecx, dword ptr [ebp+arg_C]
		push	ecx		; __int64
		mov	edx, [ebp+arg_8]
		push	edx		; int
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0ECh+var_EC] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?init@FixedDecimal@icu_56@@QAEXNH_J@Z ;	icu_56::FixedDecimal::init(double,int,__int64)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
??0FixedDecimal@icu_56@@QAE@NH_J@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AFB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FixedDecimal::FixedDecimal(icu_56::FixedDecimal *this, double, int)
		public ??0FixedDecimal@icu_56@@QAE@NH@Z
??0FixedDecimal@icu_56@@QAE@NH@Z proc near

var_EC		= qword	ptr -0ECh
var_E4		= qword	ptr -0E4h
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0E4h+var_E4] ; double
		call	?getFractionalDigits@FixedDecimal@icu_56@@SA_JNH@Z ; icu_56::FixedDecimal::getFractionalDigits(double,int)
		add	esp, 0Ch
		push	edx
		push	eax		; __int64
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0ECh+var_EC] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?init@FixedDecimal@icu_56@@QAEXNH_J@Z ;	icu_56::FixedDecimal::init(double,int,__int64)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0FixedDecimal@icu_56@@QAE@NH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B01Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FixedDecimal::FixedDecimal(icu_56::FixedDecimal *this, double)
		public ??0FixedDecimal@icu_56@@QAE@N@Z
??0FixedDecimal@icu_56@@QAE@N@Z	proc near ; CODE XREF: icu_56::PluralRules::select(int)+3Cp
					; icu_56::PluralRules::select(double)+3Cp

var_E0		= qword	ptr -0E0h
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0E0h+var_E0] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?init@FixedDecimal@icu_56@@QAEXN@Z ; icu_56::FixedDecimal::init(double)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0FixedDecimal@icu_56@@QAE@N@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B06Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FixedDecimal::FixedDecimal(icu_56::FixedDecimal *__hidden this)
		public ??0FixedDecimal@icu_56@@QAE@XZ
??0FixedDecimal@icu_56@@QAE@XZ proc near

var_EC		= qword	ptr -0ECh
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0
		push	0		; __int64
		push	0		; int
		sub	esp, 8
		fldz
		fstp	[esp+0ECh+var_EC] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?init@FixedDecimal@icu_56@@QAEXNH_J@Z ;	icu_56::FixedDecimal::init(double,int,__int64)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0FixedDecimal@icu_56@@QAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B0BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FixedDecimal::FixedDecimal(icu_56::FixedDecimal *__hidden this, const struct icu_56::UnicodeString *, enum UErrorCode *)
		public ??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z
??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+11Bp
					; icu_56::getSamplesFromString(icu_56::UnicodeString const &,double *,int,UErrorCode &)+1C8p ...

var_1F0		= qword	ptr -1F0h
var_1E8		= qword	ptr -1E8h
var_1CC		= byte ptr -1CCh
var_1C8		= byte ptr -1C8h
var_F8		= dword	ptr -0F8h
var_EC		= qword	ptr -0ECh
var_DC		= dword	ptr -0DCh
var_D0		= byte ptr -0D0h
var_58		= byte ptr -58h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1C0h
		push	ebx
		push	esi
		push	edi		; unsigned int
		push	ecx
		lea	edi, [ebp+var_1CC]
		mov	ecx, 70h ; 'p'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax		; enum UErrorCode *
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??0CharString@icu_56@@QAE@XZ	; icu_56::CharString::CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?appendInvariantChars@CharString@icu_56@@QAEAAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::CharString::appendInvariantChars(icu_56::UnicodeString const &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	ecx, [ebp+var_D0] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	byte ptr [ebp+var_4], 1
		push	0
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	esi, esp
		lea	ecx, [ebp+var_1C8]
		push	ecx		; enum UErrorCode *
		lea	ecx, [ebp+var_58]
		call	dword ptr ds:__imp_?toStringPiece@CharString@icu_56@@QBE?AVStringPiece@2@XZ ; icu_56::CharString::toStringPiece(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_D0] ; this
		call	?set@DigitList@icu_56@@QAEXABVStringPiece@2@AAW4UErrorCode@@I@Z	; icu_56::DigitList::set(icu_56::StringPiece const &,UErrorCode	&,uint)
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B1C6
		push	0
		push	0		; __int64
		push	0		; int
		sub	esp, 8
		fldz
		fstp	[esp+1F0h+var_1F0] ; double
		mov	ecx, [ebp+var_18] ; this
		call	?init@FixedDecimal@icu_56@@QAEXNH_J@Z ;	icu_56::FixedDecimal::init(double,int,__int64)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_D0] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_B297
; ---------------------------------------------------------------------------

loc_B1C6:				; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+C5j
		mov	esi, esp
		push	2Eh ; '.'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEH_W@Z ; icu_56::UnicodeString::indexOf(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_DC], eax
		lea	ecx, [ebp+var_D0] ; this
		call	?getDouble@DigitList@icu_56@@QBENXZ ; icu_56::DigitList::getDouble(void)
		fstp	[ebp+var_EC]
		cmp	[ebp+var_DC], 0FFFFFFFFh
		jnz	short loc_B216
		push	0
		push	0		; __int64
		push	0		; int
		sub	esp, 8
		fld	[ebp+var_EC]
		fstp	[esp+1F0h+var_1F0] ; double
		mov	ecx, [ebp+var_18] ; this
		call	?init@FixedDecimal@icu_56@@QAEXNH_J@Z ;	icu_56::FixedDecimal::init(double,int,__int64)
		jmp	short loc_B26F
; ---------------------------------------------------------------------------

loc_B216:				; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+13Cj
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+var_DC]
		sub	eax, 1
		mov	[ebp+var_F8], eax
		mov	eax, [ebp+var_F8]
		push	eax		; int
		sub	esp, 8
		fld	[ebp+var_EC]
		fstp	[esp+1E8h+var_1E8] ; double
		call	?getFractionalDigits@FixedDecimal@icu_56@@SA_JNH@Z ; icu_56::FixedDecimal::getFractionalDigits(double,int)
		add	esp, 0Ch
		push	edx
		push	eax		; __int64
		mov	ecx, [ebp+var_F8]
		push	ecx		; int
		sub	esp, 8
		fld	[ebp+var_EC]
		fstp	[esp+1F0h+var_1F0] ; double
		mov	ecx, [ebp+var_18] ; this
		call	?init@FixedDecimal@icu_56@@QAEXNH_J@Z ;	icu_56::FixedDecimal::init(double,int,__int64)

loc_B26F:				; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+158j
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_D0] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_B297:				; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+105j
		mov	eax, [ebp+var_18]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN12_2		dd 2			; DATA XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+1E2o
		dd offset $LN11_2
$LN11_2		dd 0FFFFFFA8h, 38h	; DATA XREF: .text:0000B2DCo
		dd offset $LN8_1
		dd 0FFFFFF30h, 70h
		dd offset $LN9_2
$LN9_2		db 64h,	6Ch, 0		; DATA XREF: .text:0000B2F4o
$LN8_1		db 63h			; DATA XREF: .text:0000B2E8o
		db 73h,	0
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0B300h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000B34Co
		mov	esi, esp
		lea	ecx, [ebp-58h]	; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000B354o
		lea	ecx, [ebp-0D0h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1D0h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0B348h
__unwindtable$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000B360o
		dd offset __unwindfunclet$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$??0FixedDecimal@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B37Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FixedDecimal::FixedDecimal(icu_56::FixedDecimal *this, const struct	icu_56::FixedDecimal *)
		public ??0FixedDecimal@icu_56@@QAE@ABV01@@Z
??0FixedDecimal@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		fld	qword ptr [ecx]
		fstp	qword ptr [eax]
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	[eax+10h], edx
		mov	ecx, [ecx+14h]
		mov	[eax+14h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	ecx, [ecx+1Ch]
		mov	[eax+1Ch], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+20h]
		mov	[eax+20h], edx
		mov	ecx, [ecx+24h]
		mov	[eax+24h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+28h]
		mov	[eax+28h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+29h]
		mov	[eax+29h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+2Ah]
		mov	[eax+2Ah], dl
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0FixedDecimal@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B41Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FixedDecimal::init(icu_56::FixedDecimal *this, double)
		public ?init@FixedDecimal@icu_56@@QAEXN@Z
?init@FixedDecimal@icu_56@@QAEXN@Z proc	near
					; CODE XREF: icu_56::FixedDecimal::FixedDecimal(double)+2Fp

var_F8		= qword	ptr -0F8h
var_EC		= qword	ptr -0ECh
var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0ECh+var_EC] ; double
		call	?decimals@FixedDecimal@icu_56@@SAHN@Z ;	icu_56::FixedDecimal::decimals(double)
		add	esp, 8
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		push	eax		; int
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	qword ptr [esp]	; double
		call	?getFractionalDigits@FixedDecimal@icu_56@@SA_JNH@Z ; icu_56::FixedDecimal::getFractionalDigits(double,int)
		add	esp, 0Ch
		push	edx
		push	eax		; __int64
		mov	ecx, [ebp+var_14]
		push	ecx		; int
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0F8h+var_F8] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?init@FixedDecimal@icu_56@@QAEXNH_J@Z ;	icu_56::FixedDecimal::init(double,int,__int64)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?init@FixedDecimal@icu_56@@QAEXN@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B498h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FixedDecimal::init(icu_56::FixedDecimal *this, double, int, __int64)
		public ?init@FixedDecimal@icu_56@@QAEXNH_J@Z
?init@FixedDecimal@icu_56@@QAEXNH_J@Z proc near
					; CODE XREF: icu_56::FixedDecimal::FixedDecimal(double,int,__int64)+3Bp
					; icu_56::FixedDecimal::FixedDecimal(double,int)+4Ap ...

var_F8		= qword	ptr -0F8h
var_E4		= dword	ptr -0E4h
var_DD		= byte ptr -0DDh
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= qword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		fldz
		fcomp	[ebp+arg_0]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_B4D0
		mov	[ebp+var_DD], 1
		jmp	short loc_B4D7
; ---------------------------------------------------------------------------

loc_B4D0:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+2Dj
		mov	[ebp+var_DD], 0

loc_B4D7:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+36j
		mov	eax, [ebp+var_8]
		mov	cl, [ebp+var_DD]
		mov	[eax+29h], cl
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0F8h+var_F8]
		call	_fabs
		add	esp, 8
		mov	eax, [ebp+var_8]
		fstp	qword ptr [eax]
		mov	eax, [ebp+var_8]
		sub	esp, 8
		fld	qword ptr [eax]
		fstp	[esp+0F8h+var_F8]
		call	_uprv_isNaN_56
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_B536
		mov	edx, [ebp+var_8]
		sub	esp, 8
		fld	qword ptr [edx]
		fstp	[esp+0F8h+var_F8]
		call	_uprv_isPositiveInfinity_56
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jnz	short loc_B536
		mov	[ebp+var_DD], 0
		jmp	short loc_B53D
; ---------------------------------------------------------------------------

loc_B536:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+79j
					; icu_56::FixedDecimal::init(double,int,__int64)+93j
		mov	[ebp+var_DD], 1

loc_B53D:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+9Cj
		mov	ecx, [ebp+var_8]
		mov	dl, [ebp+var_DD]
		mov	[ecx+2Ah], dl
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+2Ah]
		test	ecx, ecx
		jz	short loc_B583
		mov	[ebp+arg_8], 0
		mov	dword ptr [ebp+arg_C], 0
		mov	dword ptr [ebp+arg_C+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+20h], 0
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+28h], 0
		jmp	short loc_B5C6
; ---------------------------------------------------------------------------

loc_B583:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+BAj
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax]
		call	__ftol2
		mov	ecx, [ebp+var_8]
		mov	[ecx+20h], eax
		mov	[ecx+24h], edx
		mov	eax, [ebp+var_8]
		fild	qword ptr [eax+20h]
		mov	ecx, [ebp+var_8]
		fld	qword ptr [ecx]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_B5B3
		mov	[ebp+var_DD], 1
		jmp	short loc_B5BA
; ---------------------------------------------------------------------------

loc_B5B3:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+110j
		mov	[ebp+var_DD], 0

loc_B5BA:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+119j
		mov	edx, [ebp+var_8]
		mov	al, [ebp+var_DD]
		mov	[edx+28h], al

loc_B5C6:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+E9j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, dword ptr [ebp+arg_C]
		mov	[eax+10h], ecx
		mov	edx, dword ptr [ebp+arg_C+4]
		mov	[eax+14h], edx
		mov	eax, dword ptr [ebp+arg_C]
		or	eax, dword ptr [ebp+arg_C+4]
		jnz	short loc_B5F9
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+18h], 0
		mov	dword ptr [eax+1Ch], 0
		jmp	short loc_B658
; ---------------------------------------------------------------------------

loc_B5F9:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+14Cj
		mov	eax, dword ptr [ebp+arg_C]
		mov	[ebp+var_18], eax
		mov	ecx, dword ptr [ebp+arg_C+4]
		mov	[ebp+var_14], ecx

loc_B605:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+1AFj
		push	0
		push	0Ah
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_18]
		push	ecx
		call	__allrem
		mov	[ebp+var_E4], eax
		mov	[ebp-0E0h], edx
		mov	edx, [ebp+var_E4]
		or	edx, [ebp-0E0h]
		jnz	short loc_B649
		push	0
		push	0Ah
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_18]
		push	ecx
		call	__alldiv
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], edx
		jmp	short loc_B605
; ---------------------------------------------------------------------------

loc_B649:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+196j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_18]
		mov	[eax+18h], ecx
		mov	edx, [ebp+var_14]
		mov	[eax+1Ch], edx

loc_B658:				; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+15Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?init@FixedDecimal@icu_56@@QAEXNH_J@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B670h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::FixedDecimal::quickInit(icu_56::FixedDecimal	*this, double)
		public ?quickInit@FixedDecimal@icu_56@@QAECN@Z
?quickInit@FixedDecimal@icu_56@@QAECN@Z	proc near

var_114		= qword	ptr -114h
var_108		= qword	ptr -108h
var_F4		= byte ptr -0F4h
var_30		= qword	ptr -30h
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_11], 0
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+108h+var_108]
		call	_fabs
		add	esp, 8
		fstp	[ebp+arg_0]
		mov	[ebp+var_20], 0
		jmp	short loc_B6BD
; ---------------------------------------------------------------------------

loc_B6B4:				; CODE XREF: icu_56::FixedDecimal::quickInit(double):loc_B700j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_B6BD:				; CODE XREF: icu_56::FixedDecimal::quickInit(double)+42j
		cmp	[ebp+var_20], 3
		jg	short loc_B702
		mov	eax, [ebp+var_20]
		fild	ds:_p10[eax*4]
		fmul	[ebp+arg_0]
		fstp	[ebp+var_30]
		mov	esi, esp
		sub	esp, 8
		fld	[ebp+var_30]
		fstp	[esp+108h+var_108]
		call	dword ptr ds:__imp__floor
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+var_30]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_B700
		mov	[ebp+var_11], 1
		jmp	short loc_B702
; ---------------------------------------------------------------------------

loc_B700:				; CODE XREF: icu_56::FixedDecimal::quickInit(double)+88j
		jmp	short loc_B6B4
; ---------------------------------------------------------------------------

loc_B702:				; CODE XREF: icu_56::FixedDecimal::quickInit(double)+51j
					; icu_56::FixedDecimal::quickInit(double)+8Ej
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jz	short loc_B736
		mov	eax, [ebp+var_20]
		push	eax		; int
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	qword ptr [esp]	; double
		call	?getFractionalDigits@FixedDecimal@icu_56@@SA_JNH@Z ; icu_56::FixedDecimal::getFractionalDigits(double,int)
		add	esp, 0Ch
		push	edx
		push	eax		; __int64
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+114h+var_114] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?init@FixedDecimal@icu_56@@QAEXNH_J@Z ;	icu_56::FixedDecimal::init(double,int,__int64)

loc_B736:				; CODE XREF: icu_56::FixedDecimal::quickInit(double)+98j
		mov	al, [ebp+var_11]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?quickInit@FixedDecimal@icu_56@@QAECN@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B750h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::FixedDecimal::decimals(double)
		public ?decimals@FixedDecimal@icu_56@@SAHN@Z
?decimals@FixedDecimal@icu_56@@SAHN@Z proc near
					; CODE XREF: icu_56::FixedDecimal::init(double)+2Cp

var_140		= qword	ptr -140h
var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
Dest		= byte ptr -44h
var_43		= dword	ptr -43h
var_3F		= dword	ptr -3Fh
var_3B		= dword	ptr -3Bh
var_37		= dword	ptr -37h
Str		= byte ptr -33h
var_2F		= dword	ptr -2Fh
var_2B		= dword	ptr -2Bh
var_27		= byte ptr -27h
var_1C		= qword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+140h+var_140]
		call	_fabs
		add	esp, 8
		fstp	[ebp+arg_0]
		mov	[ebp+var_C], 0
		jmp	short loc_B79E
; ---------------------------------------------------------------------------

loc_B795:				; CODE XREF: icu_56::FixedDecimal::decimals(double):loc_B7E3j
		mov	eax, [ebp+var_C]
		add	eax, 1
		mov	[ebp+var_C], eax

loc_B79E:				; CODE XREF: icu_56::FixedDecimal::decimals(double)+43j
		cmp	[ebp+var_C], 3
		jg	short loc_B7E5
		mov	eax, [ebp+var_C]
		fild	ds:_p10[eax*4]
		fmul	[ebp+arg_0]
		fstp	[ebp+var_1C]
		mov	esi, esp
		sub	esp, 8
		fld	[ebp+var_1C]
		fstp	[esp+140h+var_140]
		call	dword ptr ds:__imp__floor
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+var_1C]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_B7E3
		mov	eax, [ebp+var_C]
		jmp	loc_B87F
; ---------------------------------------------------------------------------

loc_B7E3:				; CODE XREF: icu_56::FixedDecimal::decimals(double)+89j
		jmp	short loc_B795
; ---------------------------------------------------------------------------

loc_B7E5:				; CODE XREF: icu_56::FixedDecimal::decimals(double)+52j
		mov	[ebp+Dest], 0
		xor	eax, eax
		mov	[ebp+var_43], eax
		mov	[ebp+var_3F], eax
		mov	[ebp+var_3B], eax
		mov	[ebp+var_37], eax
		mov	dword ptr [ebp+Str], eax
		mov	[ebp+var_2F], eax
		mov	[ebp+var_2B], eax
		mov	[ebp+var_27], al
		mov	esi, esp
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+140h+var_140]
		push	offset ??_C@_06DMHMFEIK@?$CF1?415e?$AA@	; "%1.15e"
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	dword ptr ds:__imp__sprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	eax, [ebp+Str+1]
		mov	esi, esp
		push	eax		; Str
		call	dword ptr ds:__imp__atoi
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_50], eax
		mov	[ebp+var_5C], 0Fh
		mov	[ebp+var_68], 10h
		jmp	short loc_B859
; ---------------------------------------------------------------------------

loc_B850:				; CODE XREF: icu_56::FixedDecimal::decimals(double)+121j
		mov	eax, [ebp+var_68]
		sub	eax, 1
		mov	[ebp+var_68], eax

loc_B859:				; CODE XREF: icu_56::FixedDecimal::decimals(double)+FEj
		mov	eax, [ebp+var_68]
		movsx	ecx, [ebp+eax+Dest]
		cmp	ecx, 30h ; '0'
		jz	short loc_B868
		jmp	short loc_B873
; ---------------------------------------------------------------------------

loc_B868:				; CODE XREF: icu_56::FixedDecimal::decimals(double)+114j
		mov	eax, [ebp+var_5C]
		sub	eax, 1
		mov	[ebp+var_5C], eax
		jmp	short loc_B850
; ---------------------------------------------------------------------------

loc_B873:				; CODE XREF: icu_56::FixedDecimal::decimals(double)+116j
		mov	eax, [ebp+var_5C]
		sub	eax, [ebp+var_50]
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_5C]

loc_B87F:				; CODE XREF: icu_56::FixedDecimal::decimals(double)+8Ej
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 12Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?decimals@FixedDecimal@icu_56@@SAHN@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN13_2		dd 1			; DATA XREF: icu_56::FixedDecimal::decimals(double)+133o
		dd offset $LN12_3
$LN12_3		dd 0FFFFFFBCh, 1Eh	; DATA XREF: .text:0000B8B4o
		dd offset $LN11_3
$LN11_3		dd 667562h		; DATA XREF: .text:0000B8C0o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8C8h
		public ??_C@_06DMHMFEIK@?$CF1?415e?$AA@
; char `string'[]
??_C@_06DMHMFEIK@?$CF1?415e?$AA@ db '%1.15e',0
					; DATA XREF: icu_56::FixedDecimal::decimals(double)+BEo
		align 10h
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B8D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __cdecl icu_56::FixedDecimal::getFractionalDigits(double, int)
		public ?getFractionalDigits@FixedDecimal@icu_56@@SA_JNH@Z
?getFractionalDigits@FixedDecimal@icu_56@@SA_JNH@Z proc	near
					; CODE XREF: icu_56::FixedDecimal::FixedDecimal(double,int)+30p
					; icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+18Ep ...

var_100		= qword	ptr -100h
var_F8		= qword	ptr -0F8h
var_E4		= dword	ptr -0E4h
var_1C		= qword	ptr -1Ch
var_C		= qword	ptr -0Ch
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_8], 0
		jz	short loc_B94B
		mov	esi, esp
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0F8h+var_F8]
		call	dword ptr ds:__imp__floor
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jnp	short loc_B94B
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0F8h+var_F8]
		call	_uprv_isNaN_56
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jnz	short loc_B94B
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0F8h+var_F8]
		call	_uprv_isPositiveInfinity_56
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jz	short loc_B954

loc_B94B:				; CODE XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+22j
					; icu_56::FixedDecimal::getFractionalDigits(double,int)+49j ...
		xor	eax, eax
		xor	edx, edx
		jmp	loc_BA5B
; ---------------------------------------------------------------------------

loc_B954:				; CODE XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+79j
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0F8h+var_F8]
		call	_fabs
		add	esp, 8
		fstp	[ebp+arg_0]
		mov	esi, esp
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0F8h+var_F8]
		call	dword ptr ds:__imp__floor
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		fsubr	[ebp+arg_0]
		fstp	[ebp+var_C]
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_E4], eax
		cmp	[ebp+var_E4], 1
		jz	short loc_B9AF
		cmp	[ebp+var_E4], 2
		jz	short loc_B9C8
		cmp	[ebp+var_E4], 3
		jz	short loc_B9DE
		jmp	short loc_B9F4
; ---------------------------------------------------------------------------

loc_B9AF:				; CODE XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+C9j
		fld	[ebp+var_C]
		fmul	ds:__real@4024000000000000
		fadd	ds:__real@3fe0000000000000
		call	__ftol2
		jmp	loc_BA5B
; ---------------------------------------------------------------------------

loc_B9C8:				; CODE XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+D2j
		fld	[ebp+var_C]
		fmul	ds:__real@4059000000000000
		fadd	ds:__real@3fe0000000000000
		call	__ftol2
		jmp	short loc_BA5B
; ---------------------------------------------------------------------------

loc_B9DE:				; CODE XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+DBj
		fld	[ebp+var_C]
		fmul	ds:__real@408f400000000000
		fadd	ds:__real@3fe0000000000000
		call	__ftol2
		jmp	short loc_BA5B
; ---------------------------------------------------------------------------

loc_B9F4:				; CODE XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+DDj
		fild	[ebp+arg_8]
		sub	esp, 8
		fstp	[esp+0F8h+var_F8]
		sub	esp, 8
		fld	ds:__real@4024000000000000
		fstp	[esp+100h+var_100]
		call	_pow
		add	esp, 10h
		fmul	[ebp+var_C]
		fadd	ds:__real@3fe0000000000000
		mov	esi, esp
		sub	esp, 8
		fstp	[esp+0F8h+var_F8]
		call	dword ptr ds:__imp__floor
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		fstp	[ebp+var_1C]
		fld	ds:__real@43e0000000000000
		fcomp	[ebp+var_1C]
		fnstsw	ax
		test	ah, 5
		jp	short loc_BA53
		mov	eax, 0FFFFFFFFh
		mov	edx, 7FFFFFFFh
		jmp	short loc_BA5B
; ---------------------------------------------------------------------------
		jmp	short loc_BA5B
; ---------------------------------------------------------------------------

loc_BA53:				; CODE XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+173j
		fld	[ebp+var_1C]
		call	__ftol2

loc_BA5B:				; CODE XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+7Fj
					; icu_56::FixedDecimal::getFractionalDigits(double,int)+F3j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getFractionalDigits@FixedDecimal@icu_56@@SA_JNH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0BA70h
		public __real@43e0000000000000
__real@43e0000000000000	dq 9.223372036854776e18
					; DATA XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+165r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0BA78h
		public __real@408f400000000000
__real@408f400000000000	dq 1000.0	; DATA XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+111r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0BA80h
		public __real@4059000000000000
__real@4059000000000000	dq 100.0	; DATA XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+FBr
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0BA88h
		public __real@3fe0000000000000
__real@3fe0000000000000	dq 0.5		; DATA XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+E8r
					; icu_56::FixedDecimal::getFractionalDigits(double,int)+101r ...
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BA90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FixedDecimal::adjustForMinFractionDigits(icu_56::FixedDecimal	*this, int)
		public ?adjustForMinFractionDigits@FixedDecimal@icu_56@@QAEXH@Z
?adjustForMinFractionDigits@FixedDecimal@icu_56@@QAEXH@Z proc near

var_E8		= dword	ptr -0E8h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		sub	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		cmp	[ebp+var_14], 0
		jle	short loc_BB38
		mov	[ebp+var_20], 0
		jmp	short loc_BAD7
; ---------------------------------------------------------------------------

loc_BACE:				; CODE XREF: icu_56::FixedDecimal::adjustForMinFractionDigits(int)+97j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_BAD7:				; CODE XREF: icu_56::FixedDecimal::adjustForMinFractionDigits(int)+3Cj
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	short loc_BB29
		mov	eax, [ebp+var_8]
		mov	[ebp+var_E8], eax
		mov	ecx, [ebp+var_E8]
		cmp	dword ptr [ecx+14h], 1634578h
		jl	short loc_BB0A
		jg	short loc_BB08
		mov	edx, [ebp+var_E8]
		cmp	dword ptr [edx+10h], 5D8A0000h
		jb	short loc_BB0A

loc_BB08:				; CODE XREF: icu_56::FixedDecimal::adjustForMinFractionDigits(int)+67j
		jmp	short loc_BB29
; ---------------------------------------------------------------------------

loc_BB0A:				; CODE XREF: icu_56::FixedDecimal::adjustForMinFractionDigits(int)+65j
					; icu_56::FixedDecimal::adjustForMinFractionDigits(int)+76j
		mov	eax, [ebp+var_8]
		push	0
		push	0Ah
		mov	ecx, [eax+14h]
		push	ecx
		mov	edx, [eax+10h]
		push	edx
		call	__allmul
		mov	ecx, [ebp+var_8]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		jmp	short loc_BACE
; ---------------------------------------------------------------------------

loc_BB29:				; CODE XREF: icu_56::FixedDecimal::adjustForMinFractionDigits(int)+4Dj
					; icu_56::FixedDecimal::adjustForMinFractionDigits(int):loc_BB08j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		add	ecx, [ebp+var_14]
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx

loc_BB38:				; CODE XREF: icu_56::FixedDecimal::adjustForMinFractionDigits(int)+33j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?adjustForMinFractionDigits@FixedDecimal@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BB50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: double __thiscall icu_56::FixedDecimal::get(enum  icu_56::tokenType)const
		public ?get@FixedDecimal@icu_56@@QBENW4tokenType@2@@Z
?get@FixedDecimal@icu_56@@QBENW4tokenType@2@@Z proc near
					; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+41p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_D0], eax
		mov	ecx, [ebp+var_D0]
		sub	ecx, 15h
		mov	[ebp+var_D0], ecx
		cmp	[ebp+var_D0], 4	; switch 5 cases
		ja	short loc_BBC8	; jumptable 0000BB9A default case
		mov	edx, [ebp+var_D0]
		jmp	ds:$LN12_4[edx*4] ; switch jump
; ---------------------------------------------------------------------------

$LN6_5:					; CODE XREF: icu_56::FixedDecimal::get(icu_56::tokenType)+4Aj
					; DATA XREF: .text:$LN12_4o
		mov	eax, [ebp+var_8] ; jumptable 0000BB9A case 0
		fld	qword ptr [eax]
		jmp	short loc_BBF7
; ---------------------------------------------------------------------------

$LN5_5:					; CODE XREF: icu_56::FixedDecimal::get(icu_56::tokenType)+4Aj
					; DATA XREF: .text:$LN12_4o
		mov	eax, [ebp+var_8] ; jumptable 0000BB9A case 1
		fild	qword ptr [eax+20h]
		jmp	short loc_BBF7
; ---------------------------------------------------------------------------

$LN4_2:					; CODE XREF: icu_56::FixedDecimal::get(icu_56::tokenType)+4Aj
					; DATA XREF: .text:$LN12_4o
		mov	eax, [ebp+var_8] ; jumptable 0000BB9A case 2
		fild	qword ptr [eax+10h]
		jmp	short loc_BBF7
; ---------------------------------------------------------------------------

$LN3_2:					; CODE XREF: icu_56::FixedDecimal::get(icu_56::tokenType)+4Aj
					; DATA XREF: .text:$LN12_4o
		mov	eax, [ebp+var_8] ; jumptable 0000BB9A case 4
		fild	qword ptr [eax+18h]
		jmp	short loc_BBF7
; ---------------------------------------------------------------------------

$LN2_1:					; CODE XREF: icu_56::FixedDecimal::get(icu_56::tokenType)+4Aj
					; DATA XREF: .text:$LN12_4o
		mov	eax, [ebp+var_8] ; jumptable 0000BB9A case 3
		fild	dword ptr [eax+8]
		jmp	short loc_BBF7
; ---------------------------------------------------------------------------

loc_BBC8:				; CODE XREF: icu_56::FixedDecimal::get(icu_56::tokenType)+42j
		xor	eax, eax	; jumptable 0000BB9A default case
		jnz	short loc_BBF2
		mov	ecx, ds:?__LINE__Var@?1??get@FixedDecimal@icu_56@@QBENW4tokenType@3@@Z@4JA ; long `icu_56::FixedDecimal::get(icu_56::tokenType)'::`2'::__LINE__Var
		add	ecx, 8
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HPFMGEI@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\p"...
		push	offset ??_C@_13COJANIEC@?$AA0?$AA?$AA@ ; Message
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_BBF2:				; CODE XREF: icu_56::FixedDecimal::get(icu_56::tokenType)+7Aj
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax]

loc_BBF7:				; CODE XREF: icu_56::FixedDecimal::get(icu_56::tokenType)+56j
					; icu_56::FixedDecimal::get(icu_56::tokenType)+5Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?get@FixedDecimal@icu_56@@QBENW4tokenType@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN12_4		dd offset $LN6_5	; DATA XREF: icu_56::FixedDecimal::get(icu_56::tokenType)+4Ar
		dd offset $LN5_5	; jump table for switch	statement
		dd offset $LN4_2
		dd offset $LN2_1
		dd offset $LN3_2
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BC24h
		public ??_C@_13COJANIEC@?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_13COJANIEC@?$AA0?$AA?$AA@	dd offset ?_Rank@?$_Arithmetic_traits@K@std@@2HB
					; DATA XREF: icu_56::FixedDecimal::get(icu_56::tokenType)+8Do
_rdata		ends			; int const std::_Arithmetic_traits<ulong>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0BC28h
		public ?__LINE__Var@?1??get@FixedDecimal@icu_56@@QBENW4tokenType@3@@Z@4JA
; long `public:	double __thiscall icu_56::FixedDecimal::get(enum  icu_56::tokenType)const'::`2'::__LINE__Var
?__LINE__Var@?1??get@FixedDecimal@icu_56@@QBENW4tokenType@3@@Z@4JA dd 637h
					; DATA XREF: icu_56::FixedDecimal::get(icu_56::tokenType)+7Cr
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BC2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FixedDecimal::getVisibleFractionDigitCount(icu_56::FixedDecimal *__hidden this)
		public ?getVisibleFractionDigitCount@FixedDecimal@icu_56@@QBEHXZ
?getVisibleFractionDigitCount@FixedDecimal@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getVisibleFractionDigitCount@FixedDecimal@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BC5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(icu_56::PluralAvailableLocalesEnumeration *this, enum UErrorCode *)
		public ??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z
??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralRules::getAvailableLocales(UErrorCode &)+71p

var_E4		= byte ptr -0E4h
var_20		= byte ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0StringEnumeration@icu_56@@IAE@XZ ; icu_56::StringEnumeration::StringEnumeration(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7PluralAvailableLocalesEnumeration@icu_56@@6B@ ; const icu_56::PluralAvailableLocalesEnumeration::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+70h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+74h], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[eax+6Ch], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_BCF6
		jmp	short loc_BD54
; ---------------------------------------------------------------------------

loc_BCF6:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &)+96j
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+6Ch], 0
		mov	eax, [ebp+var_14]
		add	eax, 6Ch ; 'l'
		push	eax
		push	offset ??_C@_07GECDDAFN@plurals?$AA@ ; "plurals"
		push	0
		call	_ures_openDirect_56
		add	esp, 0Ch
		push	eax		; struct UResourceBundle *
		lea	ecx, [ebp+var_20] ; this
		call	??0LocalUResourceBundlePointer@icu_56@@QAE@PAUUResourceBundle@@@Z ; icu_56::LocalUResourceBundlePointer::LocalUResourceBundlePointer(UResourceBundle *)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		add	eax, 6Ch ; 'l'
		push	eax
		push	0
		push	offset ??_C@_07HBKLOBCC@locales?$AA@ ; "locales"
		lea	ecx, [ebp+var_20]
		call	?getAlias@?$LocalPointerBase@UUResourceBundle@@@icu_56@@QBEPAUUResourceBundle@@XZ ; icu_56::LocalPointerBase<UResourceBundle>::getAlias(void)
		push	eax
		call	_ures_getByKey_56
		add	esp, 10h
		mov	ecx, [ebp+var_14]
		mov	[ecx+70h], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_20] ; this
		call	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)

loc_BD54:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &)+98j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN9_3		dd 1			; DATA XREF: icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &)+106o
		dd offset $LN8_2
$LN8_2		dd 0FFFFFFE0h, 4	; DATA XREF: .text:0000BD94o
		dd offset $LN6_6
$LN6_6		db 72h,	62h, 0		; DATA XREF: .text:0000BDA0o
		db ?
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0BDA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000BDE4o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000BDECo
		lea	ecx, [ebp-20h]	; this
		jmp	??1LocalUResourceBundlePointer@icu_56@@QAE@XZ ;	icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)
__unwindfunclet$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0BDE0h
__unwindtable$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000BDF8o
		dd offset __unwindfunclet$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0PluralAvailableLocalesEnumeration@icu_56@@QAE@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BE14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration(icu_56::PluralAvailableLocalesEnumeration *__hidden this)
		public ??1PluralAvailableLocalesEnumeration@icu_56@@UAE@XZ
??1PluralAvailableLocalesEnumeration@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`scalar	deleting destructor'(uint)+26p
					; icu_56::PluralAvailableLocalesEnumeration::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7PluralAvailableLocalesEnumeration@icu_56@@6B@ ; const icu_56::PluralAvailableLocalesEnumeration::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+70h]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+74h]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+70h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+74h], 0
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1PluralAvailableLocalesEnumeration@icu_56@@UAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BE98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::PluralAvailableLocalesEnumeration::next(icu_56::PluralAvailableLocalesEnumeration *this, int *, enum UErrorCode *)
		public ?next@PluralAvailableLocalesEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z
?next@PluralAvailableLocalesEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00002070o

var_D8		= byte ptr -0D8h
Str		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_BED7
		xor	eax, eax
		jmp	loc_BF7B
; ---------------------------------------------------------------------------

loc_BED7:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+6Ch]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_BEFC
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+6Ch]
		mov	[eax], edx
		xor	eax, eax
		jmp	short loc_BF7B
; ---------------------------------------------------------------------------

loc_BEFC:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)+53j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+74h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+70h]
		push	ecx
		call	_ures_getNextResource_56
		add	esp, 0Ch
		mov	edx, [ebp+var_8]
		mov	[edx+74h], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+74h], 0
		jz	short loc_BF3A
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_BF4F

loc_BF3A:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)+8Bj
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 8
		jnz	short loc_BF4B
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0

loc_BF4B:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)+A8j
		xor	eax, eax
		jmp	short loc_BF7B
; ---------------------------------------------------------------------------

loc_BF4F:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)+A0j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+74h]
		push	ecx
		call	_ures_getKey_56
		add	esp, 4
		mov	[ebp+Str], eax
		cmp	[ebp+arg_0], 0
		jz	short loc_BF78
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax

loc_BF78:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)+CDj
		mov	eax, [ebp+Str]

loc_BF7B:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)+3Aj
					; icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)+62j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?next@PluralAvailableLocalesEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BF94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::PluralAvailableLocalesEnumeration::reset(icu_56::PluralAvailableLocalesEnumeration *this, enum UErrorCode *)
		public ?reset@PluralAvailableLocalesEnumeration@icu_56@@UAEXAAW4UErrorCode@@@Z
?reset@PluralAvailableLocalesEnumeration@icu_56@@UAEXAAW4UErrorCode@@@Z	proc near
					; DATA XREF: .rdata:0000207Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_BFCE
		jmp	short loc_C000
; ---------------------------------------------------------------------------

loc_BFCE:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::reset(UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+6Ch]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_BFF1
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+6Ch]
		mov	[eax], edx
		jmp	short loc_C000
; ---------------------------------------------------------------------------

loc_BFF1:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::reset(UErrorCode &)+4Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+70h]
		push	ecx
		call	_ures_resetIterator_56
		add	esp, 4

loc_C000:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::reset(UErrorCode &)+38j
					; icu_56::PluralAvailableLocalesEnumeration::reset(UErrorCode &)+5Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?reset@PluralAvailableLocalesEnumeration@icu_56@@UAEXAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C018h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::PluralAvailableLocalesEnumeration::count(icu_56::PluralAvailableLocalesEnumeration *this, enum	UErrorCode *)
		public ?count@PluralAvailableLocalesEnumeration@icu_56@@UBEHAAW4UErrorCode@@@Z
?count@PluralAvailableLocalesEnumeration@icu_56@@UBEHAAW4UErrorCode@@@Z	proc near
					; DATA XREF: .rdata:0000206Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_C054
		xor	eax, eax
		jmp	short loc_C088
; ---------------------------------------------------------------------------

loc_C054:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::count(UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+6Ch]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_C079
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+6Ch]
		mov	[eax], edx
		xor	eax, eax
		jmp	short loc_C088
; ---------------------------------------------------------------------------

loc_C079:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::count(UErrorCode &)+50j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+70h]
		push	ecx
		call	_ures_getSize_56
		add	esp, 4

loc_C088:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::count(UErrorCode &)+3Aj
					; icu_56::PluralAvailableLocalesEnumeration::count(UErrorCode &)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?count@PluralAvailableLocalesEnumeration@icu_56@@UBEHAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C0A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<struct UResourceBundle>::LocalPointerBase<struct UResourceBundle>(struct UResourceBundle *)
		public ??0?$LocalPointerBase@UUResourceBundle@@@icu_56@@QAE@PAUUResourceBundle@@@Z
??0?$LocalPointerBase@UUResourceBundle@@@icu_56@@QAE@PAUUResourceBundle@@@Z proc near
					; CODE XREF: icu_56::LocalUResourceBundlePointer::LocalUResourceBundlePointer(UResourceBundle *)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocalPointerBase@UUResourceBundle@@@icu_56@@QAE@PAUUResourceBundle@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C0D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<struct UResourceBundle>::~LocalPointerBase<struct	UResourceBundle>(void)
		public ??1?$LocalPointerBase@UUResourceBundle@@@icu_56@@QAE@XZ
??1?$LocalPointerBase@UUResourceBundle@@@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)+34p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1?$LocalPointerBase@UUResourceBundle@@@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C104h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct UResourceBundle * __thiscall icu_56::LocalPointerBase<struct UResourceBundle>::getAlias(void)const
		public ?getAlias@?$LocalPointerBase@UUResourceBundle@@@icu_56@@QBEPAUUResourceBundle@@XZ
?getAlias@?$LocalPointerBase@UUResourceBundle@@@icu_56@@QBEPAUUResourceBundle@@XZ proc near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+1D8p
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+2A3p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$LocalPointerBase@UUResourceBundle@@@icu_56@@QBEPAUUResourceBundle@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C134h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>(void)
		public ??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C16Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>(class	icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099> const	&)
		public ??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@ABV01@@Z
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C1A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::~EnumSet<enum  UNumberFormatAttribute, 4096, 4099>(void)
		public ??1?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ
??1?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C1D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::clear(void)
		public ?clear@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXXZ
?clear@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C208h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::add(enum  UNumberFormatAttribute)
		public ?add@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z
?add@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?add@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C250h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::remove(enum  UNumberFormatAttribute)
		public ?remove@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z
?remove@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?remove@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C298h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::contains(enum  UNumberFormatAttribute)const
		public ?contains@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z
?contains@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::get(UNumberFormatAttribute)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C2E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::set(enum  UNumberFormatAttribute, int)
		public ?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z
?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z proc near
					; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::add(UNumberFormatAttribute)+2Cp
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::remove(UNumberFormatAttribute)+2Cp

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jz	short loc_C31D
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::flag(UNumberFormatAttribute)
		mov	[ebp+var_D0], eax
		jmp	short loc_C327
; ---------------------------------------------------------------------------

loc_C31D:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+27j
		mov	[ebp+var_D0], 0

loc_C327:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+3Bj
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::flag(UNumberFormatAttribute)
		not	eax
		mov	edx, [ebp+var_8]
		and	eax, [edx]
		or	eax, [ebp+var_D0]
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C35Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::get(enum  UNumberFormatAttribute)const
		public ?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z
?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z proc near
					; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::contains(UNumberFormatAttribute)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::flag(UNumberFormatAttribute)
		mov	ecx, [ebp+var_8]
		and	eax, [ecx]
		neg	eax
		sbb	eax, eax
		neg	eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C3ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::isValidEnum(enum  UNumberFormatAttribute)const
		public ?isValidEnum@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECW4UNumberFormatAttribute@@@Z
?isValidEnum@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECW4UNumberFormatAttribute@@@Z proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 1000h
		jb	short loc_C3EA
		cmp	[ebp+arg_0], 1003h
		jnb	short loc_C3EA
		mov	[ebp+var_CD], 1
		jmp	short loc_C3F1
; ---------------------------------------------------------------------------

loc_C3EA:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidEnum(UNumberFormatAttribute)+2Aj
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidEnum(UNumberFormatAttribute)+33j
		mov	[ebp+var_CD], 0

loc_C3F1:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidEnum(UNumberFormatAttribute)+3Cj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?isValidEnum@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECW4UNumberFormatAttribute@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C400h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::isValidValue(int)const
		public ?isValidValue@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECH@Z
?isValidValue@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECH@Z proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_C438
		cmp	[ebp+arg_0], 1
		jz	short loc_C438
		mov	[ebp+var_CD], 0
		jmp	short loc_C43F
; ---------------------------------------------------------------------------

loc_C438:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidValue(int)+27j
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidValue(int)+2Dj
		mov	[ebp+var_CD], 1

loc_C43F:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidValue(int)+36j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?isValidValue@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C450h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099> const	& __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::operator=(class	icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099> const	&)
		public ??4?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEABV01@ABV01@@Z
??4?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEABV01@ABV01@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEABV01@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C48Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::getAll(void)const
		public ?getAll@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEIXZ
?getAll@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEIXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAll@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C4BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: unsigned int	__thiscall icu_56::EnumSet<enum	 UNumberFormatAttribute, 4096, 4099>::flag(enum	 UNumberFormatAttribute)const
		public ?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z
?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z proc near
					; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+30p
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+4Ep ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		sub	ecx, 1000h
		mov	eax, 1
		shl	eax, cl
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C4F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber,	char, 40>::MaybeStackHeaderAndArray<struct decNumber, char, 40>(void)
		public ??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 0Ch
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 28h ; '('
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C544h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber,	char, 40>::~MaybeStackHeaderAndArray<struct decNumber, char, 40>(void)
		public ??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ
??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C584h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::getCapacity(void)const
		public ?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ
?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C5B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct decNumber * __thiscall	icu_56::MaybeStackHeaderAndArray<struct	decNumber, char, 40>::getAlias(void)const
		public ?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ
?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ proc near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getArrayStart(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C5E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::getArrayStart(void)const
		public ?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ
?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ proc near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getArrayLimit(void)+26p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::operator[](int)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getAlias(void)
		add	eax, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C628h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::getArrayLimit(void)const
		public ?getArrayLimit@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ
?getArrayLimit@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ ;	icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getArrayStart(void)
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getArrayLimit@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C670h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber,	char, 40>::operator struct decNumber *(void)const
		public ??B?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ
??B?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??B?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C6A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char & __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator[](int)
		public ??A?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEAADH@Z
??A?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEAADH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ ;	icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getArrayStart(void)
		add	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEAADH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C6E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::aliasInstead(struct decNumber *, int)
		public ?aliasInstead@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEXPAUdecNumber@@H@Z
?aliasInstead@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEXPAUdecNumber@@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_C733
		cmp	[ebp+arg_4], 0
		jle	short loc_C733
		mov	ecx, [ebp+var_8]
		call	?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0

loc_C733:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::aliasInstead(decNumber *,int)+27j
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::aliasInstead(decNumber *,int)+2Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?aliasInstead@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEXPAUdecNumber@@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C74Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::releaseMemory(void)
		public ?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ
?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::~MaybeStackHeaderAndArray<decNumber,char,40>(void)+26p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::aliasInstead(decNumber *,int)+32p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_C788
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_C788:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)+2Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C79Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: bool	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator==(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40> const &)
		public ??8?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z
??8?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	al, al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C7CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: bool	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator!=(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40> const &)
		public ??9?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z
??9?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	al, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??9?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C7FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::MaybeStackHeaderAndArray<struct decNumber, char, 40>(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char,	40> const &)
		public ??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE@ABV01@@Z
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C82Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator=(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40> const &)
		public ??4?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXABV01@@Z
??4?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C858h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointer<class	icu_56::StringEnumeration>::LocalPointer<class icu_56::StringEnumeration>(class	icu_56::StringEnumeration *)
		public ??0?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@PAVStringEnumeration@1@@Z
??0?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@PAVStringEnumeration@1@@Z proc near
					; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+68p
					; icu_56::PluralRules::operator==(icu_56::PluralRules const &)+84p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??0?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QAE@PAVStringEnumeration@1@@Z	; icu_56::LocalPointerBase<icu_56::StringEnumeration>::LocalPointerBase<icu_56::StringEnumeration>(icu_56::StringEnumeration *)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@PAVStringEnumeration@1@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C8A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointer<class	icu_56::StringEnumeration>::~LocalPointer<class	icu_56::StringEnumeration>(void)
		public ??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ
??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+AEp
					; icu_56::PluralRules::operator==(icu_56::PluralRules const &)+BDp ...

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_C92E
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_C938
; ---------------------------------------------------------------------------

loc_C92E:				; CODE XREF: icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)+67j
		mov	[ebp+var_F4], 0

loc_C938:				; CODE XREF: icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)+8Cj
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		call	??1?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointerBase<icu_56::StringEnumeration>::~LocalPointerBase<icu_56::StringEnumeration>(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0C968h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:0000C994o
		mov	ecx, [ebp-14h]
		jmp	??1?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointerBase<icu_56::StringEnumeration>::~LocalPointerBase<icu_56::StringEnumeration>(void)
__unwindfunclet$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0C990h
__unwindtable$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000C9A0o
		dd offset __unwindfunclet$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ$0
__ehfuncinfo$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C9BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringEnumeration * __thiscall icu_56::LocalPointerBase<class icu_56::StringEnumeration>::operator->(void)const
		public ??C?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QBEPAVStringEnumeration@1@XZ
??C?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QBEPAVStringEnumeration@1@XZ proc near
					; CODE XREF: icu_56::PluralRules::operator==(icu_56::PluralRules const &)+D0p
					; icu_56::PluralRules::operator==(icu_56::PluralRules const &)+DEp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??C?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QBEPAVStringEnumeration@1@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C9ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<class icu_56::StringEnumeration>::LocalPointerBase<class icu_56::StringEnumeration>(class	icu_56::StringEnumeration *)
		public ??0?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QAE@PAVStringEnumeration@1@@Z
??0?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QAE@PAVStringEnumeration@1@@Z	proc near
					; CODE XREF: icu_56::LocalPointer<icu_56::StringEnumeration>::LocalPointer<icu_56::StringEnumeration>(icu_56::StringEnumeration	*)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QAE@PAVStringEnumeration@1@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CA24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<class icu_56::StringEnumeration>::~LocalPointerBase<class	icu_56::StringEnumeration>(void)
		public ??1?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ
??1?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::LocalPointer<icu_56::StringEnumeration>::~LocalPointer<icu_56::StringEnumeration>(void)+A2p
					; __unwindfunclet$??1?$LocalPointer@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ$0+3j

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1?$LocalPointerBase@VStringEnumeration@icu_56@@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CA50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct decNumber * __thiscall	icu_56::MaybeStackHeaderAndArray<struct	decNumber, char, 40>::resize(int, int)
		public ?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z
?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z proc near

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	loc_CB20
		mov	eax, [ebp+arg_0]
		add	eax, 0Ch
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jz	loc_CB19
		cmp	[ebp+arg_4], 0
		jge	short loc_CAA8
		mov	[ebp+arg_4], 0
		jmp	short loc_CAD0
; ---------------------------------------------------------------------------

loc_CAA8:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+4Dj
		cmp	[ebp+arg_4], 0
		jle	short loc_CAD0
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jle	short loc_CAC2
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_4], ecx

loc_CAC2:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+67j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_0]
		jle	short loc_CAD0
		mov	eax, [ebp+arg_0]
		mov	[ebp+arg_4], eax

loc_CAD0:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+56j
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+5Cj ...
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+arg_4]
		add	edx, 0Ch
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	ecx, [ebp+var_8]
		call	?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Dst]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 1

loc_CB19:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+43j
		mov	eax, [ebp+Dst]
		jmp	short loc_CB22
; ---------------------------------------------------------------------------
		jmp	short loc_CB22
; ---------------------------------------------------------------------------

loc_CB20:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+27j
		xor	eax, eax

loc_CB22:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+CCj
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+CEj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CB38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct decNumber * __thiscall	icu_56::MaybeStackHeaderAndArray<struct	decNumber, char, 40>::orphanOrClone(int, int &)
		public ?orphanOrClone@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HAAH@Z
?orphanOrClone@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HAAH@Z proc near

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_CB70
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+Dst], ecx
		jmp	short loc_CBD8
; ---------------------------------------------------------------------------

loc_CB70:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+2Cj
		cmp	[ebp+arg_0], 0
		jge	short loc_CB7F
		mov	[ebp+arg_0], 0
		jmp	short loc_CB93
; ---------------------------------------------------------------------------

loc_CB7F:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+3Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_CB93
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_CB93:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+45j
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int &)+50j
		mov	eax, [ebp+arg_0]
		add	eax, 0Ch
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_CBAF
		xor	eax, eax
		jmp	short loc_CBFF
; ---------------------------------------------------------------------------

loc_CBAF:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+71j
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+arg_0]
		add	edx, 0Ch
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_CBD8:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+36j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		add	eax, 0Ch
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 28h ; '('
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+Dst]

loc_CBFF:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+75j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?orphanOrClone@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HAAH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CC18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::UnifiedCache::getByLocale<icu_56::SharedPluralRules>(struct icu_56::Locale *, int, enum UErrorCode *)
		public ??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z
??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::PluralRules::createSharedInstance(icu_56::Locale const &,UPluralType,UErrorCode &)+5Dp

var_1C4		= dword	ptr -1C4h
var_1C0		= dword	ptr -1C0h
var_1B8		= byte ptr -1B8h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1B8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1C4]
		mov	ecx, 6Eh ; 'n'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		call	dword ptr ds:__imp_?getInstance@UnifiedCache@icu_56@@SAPAV12@AAW4UErrorCode@@@Z	; icu_56::UnifiedCache::getInstance(UErrorCode &)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_CC88
		jmp	short loc_CCD9
; ---------------------------------------------------------------------------

loc_CC88:				; CODE XREF: icu_56::UnifiedCache::getByLocale<icu_56::SharedPluralRules>(icu_56::Locale const &,icu_56::SharedPluralRules const * &,UErrorCode	&)+6Cj
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::Locale	*
		lea	ecx, [ebp+var_1B8]
		call	??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z ; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::LocaleCacheKey<icu_56::SharedPluralRules>(icu_56::Locale const &)
		mov	[ebp+var_1C0], eax
		mov	eax, [ebp+var_1C0]
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_1C4]
		push	ecx		; struct icu_56::CacheKeyBase *
		mov	ecx, [ebp+var_18]
		call	??$get@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@QBEXABV?$CacheKey@VSharedPluralRules@icu_56@@@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z ; icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,icu_56::SharedPluralRules const * &,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_1B8]
		call	??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ ; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::~LocaleCacheKey<icu_56::SharedPluralRules>(void)

loc_CCD9:				; CODE XREF: icu_56::UnifiedCache::getByLocale<icu_56::SharedPluralRules>(icu_56::Locale const &,icu_56::SharedPluralRules const * &,UErrorCode	&)+6Ej
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1C4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0CD04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000CD3Co
		lea	ecx, [ebp-1B8h]
		jmp	??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ ; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::~LocaleCacheKey<icu_56::SharedPluralRules>(void)
__unwindfunclet$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UnifiedCache::getByLocale<icu_56::SharedPluralRules>(icu_56::Locale const &,icu_56::SharedPluralRules const * &,UErrorCode	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1C8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0CD38h
__unwindtable$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000CD48o
		dd offset __unwindfunclet$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CD64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual __thiscall icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::~LocaleCacheKey<class icu_56::SharedPluralRules>(void)
		public ??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ
??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::UnifiedCache::getByLocale<icu_56::SharedPluralRules>(icu_56::Locale const &,icu_56::SharedPluralRules const * &,UErrorCode	&)+BCp
					; __unwindfunclet$??$getByLocale@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@SAXABVLocale@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z$0+6j ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@ ; const icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`vftable'
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 0Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		call	??1?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ ; icu_56::CacheKey<icu_56::SharedPluralRules>::~CacheKey<icu_56::SharedPluralRules>(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0CDFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:0000CE48o
		mov	ecx, [ebp-14h]
		jmp	??1?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ ; icu_56::CacheKey<icu_56::SharedPluralRules>::~CacheKey<icu_56::SharedPluralRules>(void)
__unwindfunclet$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ proc	near
					; DATA XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::~LocaleCacheKey<icu_56::SharedPluralRules>(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CE24h
		dd offset ??_R4?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@	; const	icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`RTTI Complete Object Locator'
		public ??_7?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@
; const	icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::`vftable'
??_7?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@ dd	offset ??_E?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::~LocaleCacheKey<icu_56::SharedPluralRules>(void)+45o
					; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::LocaleCacheKey<icu_56::SharedPluralRules>(icu_56::LocaleCacheKey<icu_56::SharedPluralRules> const &)+58o ...
					; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?hashCode@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEHXZ	; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::hashCode(void)
		dd offset ?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ ;	icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::clone(void)
		dd offset ??8?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBECABVCacheKeyBase@1@@Z ; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase	const &)
		dd offset ?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z ; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const *,UErrorCode &)
		dd offset ?writeDescription@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPADPADH@Z ;	icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::writeDescription(char *,int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0CE44h
__unwindtable$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:0000CE54o
		dd offset __unwindfunclet$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ$0
__ehfuncinfo$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0CE70h
		public ??_R4?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@
; const	icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::`RTTI Complete	Object Locator'
??_R4?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@ dd 3 dup(0)
					; DATA XREF: .rdata:0000CE24o
		dd offset ??_R0?AV?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@@8 ; icu_56::LocaleCacheKey<icu_56::SharedPluralRules> `RTTI Type Descriptor'
		dd offset ??_R3?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@8 ;	icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 0CE84h
		public ??_R0?AV?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@@8
; class	icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>	`RTTI Type Descriptor'
??_R0?AV?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000CE7Co
					; .rdata$r:icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av?Localecac	db '.?AV?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0CEC8h
		public ??_R3?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@8
; icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::`RTTI Class Hierarchy Descriptor'
??_R3?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:0000CE80o
					; .rdata$r:0000CF08o
		dd 5
		dd offset ??_R2?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@8 ;	icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0CED8h
		public ??_R2?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@8
; icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::`RTTI Base Class Array'
??_R2?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@8 dd offset ??_R1A@?0A@EA@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@8
					; DATA XREF: .rdata$r:0000CED4o
					; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@8 ; icu_56::CacheKey<icu_56::SharedPluralRules>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@CacheKeyBase@icu_56@@8 ; icu_56::CacheKeyBase::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0CEF0h
		public ??_R1A@?0A@EA@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@8
; icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@8 dd	offset ??_R0?AV?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`RTTI Base Class Array'o
					; icu_56::LocaleCacheKey<icu_56::SharedPluralRules> `RTTI Type Descriptor'
		dd 4, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@8 ;	icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0CF0Ch
		public ??_R1A@?0A@EA@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@8
; icu_56::CacheKey<class icu_56::SharedPluralRules>::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@8 dd offset ??_R0?AV?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@@8
					; DATA XREF: .rdata$r:0000CEDCo
					; .rdata$r:icu_56::CacheKey<icu_56::SharedPluralRules>::`RTTI Base Class Array'o
					; icu_56::CacheKey<icu_56::SharedPluralRules> `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@8	; icu_56::CacheKey<icu_56::SharedPluralRules>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0CF28h
		public ??_R0?AV?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@@8
; class	icu_56::CacheKey<class icu_56::SharedPluralRules> `RTTI	Type Descriptor'
??_R0?AV?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::CacheKey<icu_56::SharedPluralRules>::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; .rdata$r:0000D2FCo
					; const	type_info::`vftable'
		align 10h
a_?av?Cachekey@	db '.?AV?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0CF64h
		public ??_R3?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@8
; icu_56::CacheKey<class icu_56::SharedPluralRules>::`RTTI Class Hierarchy Descriptor'
??_R3?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:0000CF24o
					; .rdata$r:0000D300o
		dd 4
		dd offset ??_R2?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@8	; icu_56::CacheKey<icu_56::SharedPluralRules>::`RTTI Base Class	Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0CF74h
		public ??_R2?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@8
; icu_56::CacheKey<class icu_56::SharedPluralRules>::`RTTI Base	Class Array'
??_R2?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@8 dd offset	??_R1A@?0A@EA@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@8
					; DATA XREF: .rdata$r:0000CF70o
					; icu_56::CacheKey<icu_56::SharedPluralRules>::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@CacheKeyBase@icu_56@@8 ; icu_56::CacheKeyBase::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0CF88h
		public ??_R1A@?0A@EA@CacheKeyBase@icu_56@@8
; icu_56::CacheKeyBase::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@CacheKeyBase@icu_56@@8 dd	offset ??_R0?AVCacheKeyBase@icu_56@@@8
					; DATA XREF: .rdata$r:0000CEE0o
					; .rdata$r:0000CF78o ...
					; icu_56::CacheKeyBase `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3CacheKeyBase@icu_56@@8 ;	icu_56::CacheKeyBase::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0CFA4h
		public ??_R0?AVCacheKeyBase@icu_56@@@8
; class	icu_56::CacheKeyBase `RTTI Type	Descriptor'
??_R0?AVCacheKeyBase@icu_56@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::CacheKeyBase::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avcachekeyba	db '.?AVCacheKeyBase@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0CFC8h
		public ??_R3CacheKeyBase@icu_56@@8
; icu_56::CacheKeyBase::`RTTI Class Hierarchy Descriptor'
??_R3CacheKeyBase@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000CFA0o
		dd 3
		dd offset ??_R2CacheKeyBase@icu_56@@8 ;	icu_56::CacheKeyBase::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0CFD8h
		public ??_R2CacheKeyBase@icu_56@@8
; icu_56::CacheKeyBase::`RTTI Base Class Array'
??_R2CacheKeyBase@icu_56@@8 dd offset ??_R1A@?0A@EA@CacheKeyBase@icu_56@@8
					; DATA XREF: .rdata$r:0000CFD4o
					; icu_56::CacheKeyBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CFE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual int __thiscall icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::hashCode(void)const
		public ?hashCode@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEHXZ
?hashCode@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEHXZ proc near
					; DATA XREF: .rdata:0000CE30o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?hashCode@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEHXZ	; icu_56::CacheKey<icu_56::SharedPluralRules>::hashCode(void)
		mov	esi, eax
		imul	esi, 25h
		mov	ecx, [ebp+var_8]
		add	ecx, 0Ch	; this
		mov	edi, esp
		call	dword ptr ds:__imp_?hashCode@Locale@icu_56@@QBEHXZ ; icu_56::Locale::hashCode(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D044h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::operator==(class icu_56::CacheKeyBase	const &)const
		public ??8?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBECABVCacheKeyBase@1@@Z
??8?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBECABVCacheKeyBase@1@@Z proc near
					; DATA XREF: .rdata:0000CE38o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_D073
		mov	al, 1
		jmp	short loc_D0AC
; ---------------------------------------------------------------------------

loc_D073:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase	const &)+29j
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBECABVCacheKeyBase@1@@Z ; icu_56::CacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase const	&)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_D08A
		xor	al, al
		jmp	short loc_D0AC
; ---------------------------------------------------------------------------

loc_D08A:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase	const &)+40j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		add	eax, 0Ch
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 0Ch
		call	dword ptr ds:__imp_??8Locale@icu_56@@QBECABV01@@Z ; icu_56::Locale::operator==(icu_56::Locale const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_D0AC:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase	const &)+2Dj
					; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase const &)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBECABVCacheKeyBase@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D0C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	icu_56::CacheKeyBase * __thiscall icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::clone(void)const
		public ?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ
?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ proc near
					; DATA XREF: .rdata:0000CE34o

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		push	0D8h ; ''      ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_D14A
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::CacheKeyBase *
		mov	ecx, [ebp+var_E0]
		call	??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z ; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::LocaleCacheKey<icu_56::SharedPluralRules>(icu_56::LocaleCacheKey<icu_56::SharedPluralRules> const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_D154
; ---------------------------------------------------------------------------

loc_D14A:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::clone(void)+6Dj
		mov	[ebp+var_F4], 0

loc_D154:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::clone(void)+84j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_EC]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0D18Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ$0 proc near
					; DATA XREF: .xdata$x:0000D1C8o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ	proc near
					; DATA XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::clone(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0D1C4h
__unwindtable$?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000D1D4o
		dd offset __unwindfunclet$?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ$0
__ehfuncinfo$?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ+14o
		dd offset __unwindtable$?clone@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPAVCacheKeyBase@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D1F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::writeDescription(char *Dest,	size_t Count)
		public ?writeDescription@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPADPADH@Z
?writeDescription@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPADPADH@Z proc near
					; DATA XREF: .rdata:0000CE40o

var_D8		= byte ptr -0D8h
Source		= dword	ptr -14h
var_8		= dword	ptr -8
Dest		= dword	ptr  8
Count		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 0Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_?getName@Locale@icu_56@@QBEPBDXZ ; icu_56::Locale::getName(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Source], eax
		push	1
		mov	eax, [ebp+Source]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		mov	ecx, [ebp+Count]
		push	ecx		; Count
		mov	edx, [ebp+Source]
		push	edx		; Source
		mov	eax, [ebp+Dest]
		push	eax		; Dest
		call	dword ptr ds:__imp__strncpy
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+Dest]
		add	eax, [ebp+Count]
		mov	byte ptr [eax-1], 0
		mov	eax, [ebp+Dest]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?writeDescription@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPADPADH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D27Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual __thiscall icu_56::CacheKey<class icu_56::SharedPluralRules>::~CacheKey<class	icu_56::SharedPluralRules>(void)
		public ??1?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ
??1?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::~LocaleCacheKey<icu_56::SharedPluralRules>(void)+71p
					; __unwindfunclet$??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ$0+3j ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@ ; const icu_56::CacheKey<icu_56::SharedPluralRules>::`vftable'
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1CacheKeyBase@icu_56@@UAE@XZ ; icu_56::CacheKeyBase::~CacheKeyBase(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D2D0h
		dd offset ??_R4?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@ ; const icu_56::CacheKey<icu_56::SharedPluralRules>::`RTTI Complete Object Locator'
		public ??_7?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@
; const	icu_56::CacheKey<class icu_56::SharedPluralRules>::`vftable'
??_7?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@ dd offset ??_E?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::~CacheKey<icu_56::SharedPluralRules>(void)+26o
					; icu_56::CacheKey<icu_56::SharedPluralRules>::CacheKey<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &)+3Co ...
					; icu_56::CacheKey<icu_56::SharedPluralRules>::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?hashCode@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEHXZ ; icu_56::CacheKey<icu_56::SharedPluralRules>::hashCode(void)
		dd offset __purecall
		dd offset ??8?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBECABVCacheKeyBase@1@@Z ; icu_56::CacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase const &)
		dd offset __purecall
		dd offset ?writeDescription@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPADPADH@Z	; icu_56::CacheKey<icu_56::SharedPluralRules>::writeDescription(char *,int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D2F0h
		public ??_R4?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@
; const	icu_56::CacheKey<class icu_56::SharedPluralRules>::`RTTI Complete Object Locator'
??_R4?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@	dd 3 dup(0)
					; DATA XREF: .rdata:0000D2D0o
		dd offset ??_R0?AV?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@@8 ; icu_56::CacheKey<icu_56::SharedPluralRules> `RTTI	Type Descriptor'
		dd offset ??_R3?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@8	; icu_56::CacheKey<icu_56::SharedPluralRules>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D304h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual int __thiscall icu_56::CacheKey<class	icu_56::SharedPluralRules>::hashCode(void)const
		public ?hashCode@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEHXZ
?hashCode@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEHXZ	proc near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::hashCode(void)+26p
					; DATA XREF: .rdata:0000D2DCo

var_D8		= byte ptr -0D8h
Str		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	offset ?__type_info_root_node@@3U__type_info_node@@A ; struct __type_info_node *
		mov	ecx, offset ??_R0?AVSharedPluralRules@icu_56@@@8 ; this
		call	dword ptr ds:__imp_?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name(__type_info_node *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Str], eax
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		push	eax
		mov	ecx, [ebp+Str]
		push	ecx
		call	_ustr_hashCharsN_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEHXZ	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D370h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::CacheKey<icu_56::SharedPluralRules>::writeDescription(char *Dest, size_t Count)
		public ?writeDescription@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPADPADH@Z
?writeDescription@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPADPADH@Z proc near
					; DATA XREF: .rdata:0000D2ECo

var_D8		= byte ptr -0D8h
Source		= dword	ptr -14h
var_8		= dword	ptr -8
Dest		= dword	ptr  8
Count		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	offset ?__type_info_root_node@@3U__type_info_node@@A ; struct __type_info_node *
		mov	ecx, offset ??_R0?AVSharedPluralRules@icu_56@@@8 ; this
		call	dword ptr ds:__imp_?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name(__type_info_node *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Source], eax
		push	1
		mov	eax, [ebp+Source]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		mov	ecx, [ebp+Count]
		push	ecx		; Count
		mov	edx, [ebp+Source]
		push	edx		; Source
		mov	eax, [ebp+Dest]
		push	eax		; Dest
		call	dword ptr ds:__imp__strncpy
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+Dest]
		add	eax, [ebp+Count]
		mov	byte ptr [eax-1], 0
		mov	eax, [ebp+Dest]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?writeDescription@?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPADPADH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D400h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::CacheKey<class	icu_56::SharedPluralRules>::operator==(class icu_56::CacheKeyBase const	&)const
		public ??8?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBECABVCacheKeyBase@1@@Z
??8?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBECABVCacheKeyBase@1@@Z proc	near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase	const &)+36p
					; DATA XREF: .rdata:0000D2E4o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??8type_info@@QBE_NABV0@@Z ;	type_info::operator==(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBECABVCacheKeyBase@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D464h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::`scalar deleting destructor'(unsigned int)
		public ??_G?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z
??_G?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??1?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ ; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::~LocaleCacheKey<icu_56::SharedPluralRules>(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_D4AD
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_D4AD:				; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D4C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::CacheKey<class icu_56::SharedPluralRules>::`scalar deleting	destructor'(unsigned int)
		public ??_G?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z
??_G?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??1?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ ; icu_56::CacheKey<icu_56::SharedPluralRules>::~CacheKey<icu_56::SharedPluralRules>(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_D511
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_D511:				; CODE XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D52Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::LocaleCacheKey<icu_56::SharedPluralRules>(struct icu_56::CacheKeyBase *)
		public ??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z
??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::clone(void)+79p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::CacheKeyBase *
		mov	ecx, [ebp+var_14]
		call	??0?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z ; icu_56::CacheKey<icu_56::SharedPluralRules>::CacheKey<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@ ; const icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`vftable'
		mov	eax, [ebp+arg_0]
		add	eax, 0Ch
		mov	esi, esp
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_14]
		add	ecx, 0Ch	; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0D5D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:0000D600o
		mov	ecx, [ebp-14h]
		jmp	??1?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ ; icu_56::CacheKey<icu_56::SharedPluralRules>::~CacheKey<icu_56::SharedPluralRules>(void)
__unwindfunclet$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::LocaleCacheKey<icu_56::SharedPluralRules>(icu_56::LocaleCacheKey<icu_56::SharedPluralRules> const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0D5FCh
__unwindtable$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000D60Co
		dd offset __unwindfunclet$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D628h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::CacheKey<icu_56::SharedPluralRules>::CacheKey<icu_56::SharedPluralRules>(struct	icu_56::CacheKeyBase *)
		public ??0?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z
??0?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::LocaleCacheKey<icu_56::SharedPluralRules>(icu_56::LocaleCacheKey<icu_56::SharedPluralRules> const &)+49p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::CacheKeyBase *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0CacheKeyBase@icu_56@@QAE@ABV01@@Z	; icu_56::CacheKeyBase::CacheKeyBase(icu_56::CacheKeyBase const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@ ; const icu_56::CacheKey<icu_56::SharedPluralRules>::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D684h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::LocaleCacheKey<icu_56::SharedPluralRules>(struct icu_56::Locale *)
		public ??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z
??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z proc	near
					; CODE XREF: icu_56::UnifiedCache::getByLocale<icu_56::SharedPluralRules>(icu_56::Locale const &,icu_56::SharedPluralRules const * &,UErrorCode	&)+82p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	??0?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@XZ ; icu_56::CacheKey<icu_56::SharedPluralRules>::CacheKey<icu_56::SharedPluralRules>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@ ; const icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`vftable'
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_14]
		add	ecx, 0Ch	; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0D724h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z$0 proc near
					; DATA XREF: .xdata$x:0000D750o
		mov	ecx, [ebp-14h]
		jmp	??1?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAE@XZ ; icu_56::CacheKey<icu_56::SharedPluralRules>::~CacheKey<icu_56::SharedPluralRules>(void)
__unwindfunclet$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z proc near
					; DATA XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::LocaleCacheKey<icu_56::SharedPluralRules>(icu_56::Locale const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0D74Ch
__unwindtable$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000D75Co
		dd offset __unwindfunclet$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z$0
__ehfuncinfo$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z+14o
		dd offset __unwindtable$??0?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@ABVLocale@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D778h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::CacheKey<class icu_56::SharedPluralRules>::CacheKey<class icu_56::SharedPluralRules>(void)
		public ??0?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@XZ
??0?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::LocaleCacheKey<icu_56::SharedPluralRules>(icu_56::Locale const &)+45p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0CacheKeyBase@icu_56@@QAE@XZ ; icu_56::CacheKeyBase::CacheKeyBase(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@6B@ ; const icu_56::CacheKey<icu_56::SharedPluralRules>::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D7D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(struct icu_56::CacheKeyBase *, int, int)
		public ??$get@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@QBEXABV?$CacheKey@VSharedPluralRules@icu_56@@@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z
??$get@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@QBEXABV?$CacheKey@VSharedPluralRules@icu_56@@@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UnifiedCache::getByLocale<icu_56::SharedPluralRules>(icu_56::Locale const &,icu_56::SharedPluralRules const * &,UErrorCode	&)+AAp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; void *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::CacheKeyBase *
		mov	ecx, [ebp+var_8]
		call	??$get@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@QBEXABV?$CacheKey@VSharedPluralRules@icu_56@@@1@PBXAAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z ; icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const	&,void const *,icu_56::SharedPluralRules const * &,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??$get@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@QBEXABV?$CacheKey@VSharedPluralRules@icu_56@@@1@AAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D820h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(struct icu_56::CacheKeyBase *, void *, int, int)
		public ??$get@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@QBEXABV?$CacheKey@VSharedPluralRules@icu_56@@@1@PBXAAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z
??$get@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@QBEXABV?$CacheKey@VSharedPluralRules@icu_56@@@1@PBXAAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,icu_56::SharedPluralRules	const *	&,UErrorCode &)+34p

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_D85D
		jmp	loc_D8E5
; ---------------------------------------------------------------------------

loc_D85D:				; CODE XREF: icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,void const *,icu_56::SharedPluralRules const * &,UErrorCode &)+36j
		mov	[ebp+var_14], 0
		mov	[ebp+var_20], 0
		mov	esi, esp
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; void *
		lea	edx, [ebp+var_20]
		push	edx		; struct icu_56::SharedObject **
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::CacheKeyBase *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_?_get@UnifiedCache@icu_56@@ABEXABVCacheKeyBase@2@AAPBVSharedObject@2@PBXAAW4UErrorCode@@@Z ;	icu_56::UnifiedCache::_get(icu_56::CacheKeyBase	const &,icu_56::SharedObject const * &,void const *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_14]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_D8B6
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_2C]
		push	ecx		; icu_56::SharedObject *
		call	??$copyPtr@VSharedPluralRules@icu_56@@@SharedObject@icu_56@@SAXPBVSharedPluralRules@1@AAPBV21@@Z ; icu_56::SharedObject::copyPtr<icu_56::SharedPluralRules>(icu_56::SharedPluralRules const *,icu_56::SharedPluralRules	const *	&)
		add	esp, 8

loc_D8B6:				; CODE XREF: icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,void const *,icu_56::SharedPluralRules const * &,UErrorCode &)+84j
		lea	eax, [ebp+var_2C]
		push	eax
		call	??$clearPtr@VSharedPluralRules@icu_56@@@SharedObject@icu_56@@SAXAAPBVSharedPluralRules@1@@Z ; icu_56::SharedObject::clearPtr<icu_56::SharedPluralRules>(icu_56::SharedPluralRules const	* &)
		add	esp, 4
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0
		jz	short loc_D8DD
		mov	eax, [ebp+var_14]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_D8E5

loc_D8DD:				; CODE XREF: icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,void const *,icu_56::SharedPluralRules const * &,UErrorCode &)+A8j
		mov	eax, [ebp+arg_C]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_D8E5:				; CODE XREF: icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,void const *,icu_56::SharedPluralRules const * &,UErrorCode &)+38j
					; icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,void	const *,icu_56::SharedPluralRules const	* &,UErrorCode &)+BBj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??$get@VSharedPluralRules@icu_56@@@UnifiedCache@icu_56@@QBEXABV?$CacheKey@VSharedPluralRules@icu_56@@@1@PBXAAPBVSharedPluralRules@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN11_4		dd 3			; DATA XREF: icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,void const *,icu_56::SharedPluralRules const * &,UErrorCode &)+C9o
		dd offset $LN10_1
$LN10_1		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000D910o
		dd offset $LN7_5	; "creationStatus"
		dd 0FFFFFFE0h, 4
		dd offset $LN8_3	; "value"
		dd 0FFFFFFD4h, 4
		dd offset $LN9_4	; "tvalue"
$LN9_4		db 'tvalue',0           ; DATA XREF: .text:0000D934o
$LN8_3		db 'value',0            ; DATA XREF: .text:0000D928o
$LN7_5		db 'creationStatus',0   ; DATA XREF: .text:0000D91Co
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D954h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::SharedObject::copyPtr<icu_56::SharedPluralRules>(icu_56::SharedObject *, int)
		public ??$copyPtr@VSharedPluralRules@icu_56@@@SharedObject@icu_56@@SAXPBVSharedPluralRules@1@AAPBV21@@Z
??$copyPtr@VSharedPluralRules@icu_56@@@SharedObject@icu_56@@SAXPBVSharedPluralRules@1@AAPBV21@@Z proc near
					; CODE XREF: icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,void const *,icu_56::SharedPluralRules const * &,UErrorCode &)+8Ep

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax]
		jz	short loc_D9B8
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jz	short loc_D998
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]	; this
		call	dword ptr ds:__imp_?removeRef@SharedObject@icu_56@@QBEXXZ ; icu_56::SharedObject::removeRef(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_D998:				; CODE XREF: icu_56::SharedObject::copyPtr<icu_56::SharedPluralRules>(icu_56::SharedPluralRules	const *,icu_56::SharedPluralRules const	* &)+2Ej
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_D9B8
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?addRef@SharedObject@icu_56@@QBEXXZ ; icu_56::SharedObject::addRef(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_D9B8:				; CODE XREF: icu_56::SharedObject::copyPtr<icu_56::SharedPluralRules>(icu_56::SharedPluralRules	const *,icu_56::SharedPluralRules const	* &)+26j
					; icu_56::SharedObject::copyPtr<icu_56::SharedPluralRules>(icu_56::SharedPluralRules const *,icu_56::SharedPluralRules const * &)+50j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$copyPtr@VSharedPluralRules@icu_56@@@SharedObject@icu_56@@SAXPBVSharedPluralRules@1@AAPBV21@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D9CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl icu_56::SharedObject::clearPtr<class icu_56::SharedPluralRules>(class icu_56::SharedPluralRules const * &)
		public ??$clearPtr@VSharedPluralRules@icu_56@@@SharedObject@icu_56@@SAXAAPBVSharedPluralRules@1@@Z
??$clearPtr@VSharedPluralRules@icu_56@@@SharedObject@icu_56@@SAXAAPBVSharedPluralRules@1@@Z proc near
					; CODE XREF: icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,void const *,icu_56::SharedPluralRules const * &,UErrorCode &)+9Ap

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jz	short loc_DA0F
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]	; this
		call	dword ptr ds:__imp_?removeRef@SharedObject@icu_56@@QBEXXZ ; icu_56::SharedObject::removeRef(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0

loc_DA0F:				; CODE XREF: icu_56::SharedObject::clearPtr<icu_56::SharedPluralRules>(icu_56::SharedPluralRules const * &)+24j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$clearPtr@VSharedPluralRules@icu_56@@@SharedObject@icu_56@@SAXAAPBVSharedPluralRules@1@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; public: signed char __thiscall icu_56::Formattable::operator==(class icu_56::Formattable const &)const
		extrn ??8Formattable@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::Formattable::operator!=(icu_56::Formattable const &)+2Ap
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::Formattable::operator!=(icu_56::Formattable const &)+42p
					; icu_56::Formattable::getString(icu_56::UnicodeString &)+37p ...
		extrn __fltused:near
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString const &)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::Formattable::getString(icu_56::UnicodeString &)+2Fp
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+80p ...
; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *__hidden this, enum UErrorCode *)
		extrn ?getLong@Formattable@icu_56@@QBEHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::Formattable::getLong(UErrorCode *)+2Ap
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		extrn __imp_??0UObject@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::FieldPosition::FieldPosition(void)+28p
					; icu_56::FieldPosition::FieldPosition(int)+28p ...
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::FieldPosition `RTTI Type Descriptor'o
					; .data:icu_56::UObject	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::FieldPosition::getDynamicClassID(void)const
		extrn ?getDynamicClassID@FieldPosition@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000006A8o
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this, const struct icu_56::UObject *)
		extrn __imp_??0UObject@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition	const &)+2Cp
					; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)+2Cp ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+39p
					; icu_56::FieldPosition::`vector deleting destructor'(uint)+81p ...
; _DWORD __thiscall icu_56::FieldPosition::~FieldPosition(icu_56::FieldPosition	*__hidden this)
		extrn ??1FieldPosition@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+26p
					; icu_56::FieldPosition::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn __imp_??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+53p
					; icu_56::PluralRules::`vector deleting	destructor'(uint)+53p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+3Dp
					; icu_56::PluralRules::`vector deleting	destructor'(uint)+3Dp ...
; public: signed char __thiscall icu_56::FieldPositionIterator::operator==(class icu_56::FieldPositionIterator const &)const
		extrn ??8FieldPositionIterator@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::FieldPositionIterator::operator!=(icu_56::FieldPositionIterator const &)+2Ap
; __declspec(dllimport)	public:	class icu_56::UObject &	__thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		extrn __imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::FieldPositionIterator::operator=(icu_56::FieldPositionIterator const &)+2Cp
					; icu_56::NumberFormatFactory::operator=(icu_56::NumberFormatFactory const &)+2Cp
					; DATA XREF: ...
; public: signed char __thiscall icu_56::DecimalFormatSymbols::operator==(class	icu_56::DecimalFormatSymbols const &)const
		extrn ??8DecimalFormatSymbols@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::operator!=(icu_56::DecimalFormatSymbols const &)+2Ap
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn __imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+59p
					; icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+79p ...
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+17Cp
					; __unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0+8p ...
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString &&)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+160p
					; icu_56::PluralRules::internalForLocale(icu_56::Locale	const &,UPluralType,UErrorCode &)+1B9p	...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@H@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+120p
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+120r
		extrn _u_charDigitValue_56:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+E0p
; int __thiscall icu_56::UnicodeString::char32At(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?char32At@UnicodeString@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+CCp
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+CCr
; int __thiscall icu_56::UnicodeString::countChar32(icu_56::UnicodeString *__hidden this, int, int)
		extrn __imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+AFp
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+AFr
		extrn ___security_cookie:near
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+2Er
					; icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+23j
					; __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z+19j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+1A1p
					; __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+Fp ...
; _DWORD __thiscall icu_56::Locale::Locale(icu_56::Locale *__hidden this, const	struct icu_56::Locale *)
		extrn __imp_??0Locale@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::getLocale(void)+3Bp
					; icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::LocaleCacheKey<icu_56::SharedPluralRules>(icu_56::LocaleCacheKey<icu_56::SharedPluralRules> const &)+6Dp ...
; public: virtual void * __thiscall icu_56::MeasureUnit::getDynamicClassID(void)const
		extrn ?getDynamicClassID@MeasureUnit@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000013FCo
; public: virtual class	icu_56::UObject	* __thiscall icu_56::MeasureUnit::clone(void)const
		extrn ?clone@MeasureUnit@icu_56@@UBEPAVUObject@2@XZ:near
					; DATA XREF: .rdata:00001400o
; public: virtual signed char __thiscall icu_56::MeasureUnit::operator==(class icu_56::UObject const &)const
		extrn ??8MeasureUnit@icu_56@@UBECABVUObject@1@@Z:near
					; DATA XREF: .rdata:00001404o
; _DWORD __thiscall icu_56::MeasureUnit::~MeasureUnit(icu_56::MeasureUnit *__hidden this)
		extrn ??1MeasureUnit@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::MeasureUnit::`scalar deleting destructor'(uint)+26p
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+6Ep
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001770o
					; .rdata:00001AA0o ...
		extrn __purecall:near	; DATA XREF: .rdata:00001774o
					; .rdata:00001778o ...
; _DWORD __thiscall icu_56::NumberFormatFactory::~NumberFormatFactory(icu_56::NumberFormatFactory *__hidden this)
		extrn ??1NumberFormatFactory@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::NumberFormatFactory::`scalar deleting destructor'(uint)+26p
					; icu_56::NumberFormatFactory::`vector deleting	destructor'(uint)+6Ep ...
; public: virtual signed char __thiscall icu_56::SimpleNumberFormatFactory::visible(void)const
		extrn ?visible@SimpleNumberFormatFactory@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00001AA4o
; public: virtual class	icu_56::UnicodeString const * __thiscall icu_56::SimpleNumberFormatFactory::getSupportedIDs(int	&, enum	 UErrorCode &)const
		extrn ?getSupportedIDs@SimpleNumberFormatFactory@icu_56@@UBEPBVUnicodeString@2@AAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00001AA8o
; _DWORD __thiscall icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory *__hidden this)
		extrn ??1SimpleNumberFormatFactory@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::SimpleNumberFormatFactory::`scalar	deleting destructor'(uint)+26p
					; icu_56::SimpleNumberFormatFactory::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; public: signed char __thiscall icu_56::DigitList::operator==(class icu_56::DigitList const &)const
		extrn ??8DigitList@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::DigitList::operator!=(icu_56::DigitList const &)+2Ap
		extrn _uprv_decNumberZero_56:near
					; CODE XREF: icu_56::DigitList::setToZero(void)+2Ap
; _DWORD __thiscall icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration *__hidden this, const struct	icu_56::StringEnumeration *)
		extrn __imp_??0StringEnumeration@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(icu_56::PluralAvailableLocalesEnumeration const &)+2Cp
					; DATA XREF: icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(icu_56::PluralAvailableLocalesEnumeration const &)+2Cr
; public: virtual class	icu_56::StringEnumeration * __thiscall icu_56::StringEnumeration::clone(void)const
		extrn ?clone@StringEnumeration@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:00002068o
					; .rdata:0000AA14o
; public: virtual wchar_t const	* __thiscall icu_56::StringEnumeration::unext(int *, enum  UErrorCode &)
		extrn ?unext@StringEnumeration@icu_56@@UAEPB_WPAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00002074o
					; .rdata:0000AA20o
; public: virtual class	icu_56::UnicodeString const * __thiscall icu_56::StringEnumeration::snext(enum	UErrorCode &)
		extrn ?snext@StringEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00002078o
; public: virtual signed char __thiscall icu_56::StringEnumeration::operator==(class icu_56::StringEnumeration const &)const
		extrn ??8StringEnumeration@icu_56@@UBECABV01@@Z:near
					; DATA XREF: .rdata:00002080o
					; .rdata:0000AA2Co
; public: virtual signed char __thiscall icu_56::StringEnumeration::operator!=(class icu_56::StringEnumeration const &)const
		extrn ??9StringEnumeration@icu_56@@UBECABV01@@Z:near
					; DATA XREF: .rdata:00002084o
					; .rdata:0000AA30o
; __declspec(dllimport)	public:	class icu_56::StringEnumeration	& __thiscall icu_56::StringEnumeration::operator=(class	icu_56::StringEnumeration const	&)
		extrn __imp_??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::operator=(icu_56::PluralAvailableLocalesEnumeration const &)+2Cp
					; DATA XREF: icu_56::PluralAvailableLocalesEnumeration::operator=(icu_56::PluralAvailableLocalesEnumeration const &)+2Cr
; _DWORD __thiscall icu_56::SharedObject::SharedObject(icu_56::SharedObject *__hidden this)
		extrn __imp_??0SharedObject@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::SharedPluralRules::SharedPluralRules(icu_56::PluralRules *)+28p
					; DATA XREF: icu_56::SharedPluralRules::SharedPluralRules(icu_56::PluralRules *)+28r
; _DWORD __thiscall icu_56::CharString::~CharString(icu_56::CharString *__hidden this)
		extrn __imp_??1CharString@icu_56@@QAE@XZ:near
					; CODE XREF: __unwindfunclet$??0VisibleDigits@icu_56@@QAE@XZ$0+5p
					; icu_56::VisibleDigits::~VisibleDigits(void)+28p ...
; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *__hidden	this)
		extrn __imp_??0CharString@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::VisibleDigits::VisibleDigits(void)+47p
					; icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+4Ap
					; DATA XREF: ...
; void __thiscall icu_56::VisibleDigits::clear(icu_56::VisibleDigits *__hidden this)
		extrn ?clear@VisibleDigits@icu_56@@AAEXXZ:near
					; CODE XREF: icu_56::VisibleDigitsWithExponent::clear(void)+26p
					; icu_56::VisibleDigitsWithExponent::clear(void)+31p
; signed __int8	__thiscall icu_56::VisibleDigits::isNegative(icu_56::VisibleDigits *__hidden this)
		extrn ?isNegative@VisibleDigits@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::VisibleDigitsWithExponent::isNegative(void)+26p
					; icu_56::FixedDecimal::FixedDecimal(icu_56::VisibleDigits const &)+55p
; signed __int8	__thiscall icu_56::VisibleDigits::isNaN(icu_56::VisibleDigits *__hidden	this)
		extrn ?isNaN@VisibleDigits@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::VisibleDigitsWithExponent::isNaN(void)+26p
; signed __int8	__thiscall icu_56::VisibleDigits::isInfinite(icu_56::VisibleDigits *__hidden this)
		extrn ?isInfinite@VisibleDigits@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::VisibleDigitsWithExponent::isInfinite(void)+26p
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn __imp_??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0PluralRules@icu_56@@QAE@ABV01@@Z$0+5p
					; icu_56::PluralRules::~PluralRules(void)+AEp ...
; _DWORD __thiscall icu_56::SharedObject::~SharedObject(icu_56::SharedObject *__hidden this)
		extrn __imp_??1SharedObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::SharedPluralRules::~SharedPluralRules(void)+AEp
					; __unwindfunclet$??1SharedPluralRules@icu_56@@UAE@XZ$0+5p
					; DATA XREF: ...
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn __imp_??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::PluralRules::clone(void)+46p
					; icu_56::PluralRules::operator=(icu_56::PluralRules const &)+BAp ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::PluralRules::createRules(icu_56::UnicodeString const &,UErrorCode &)+1A7p
					; icu_56::PluralRules::createSharedInstance(icu_56::Locale const &,UPluralType,UErrorCode &)+72p ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, signed __int8, const wchar_t *, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z:near
					; CODE XREF: icu_56::PluralRules::createDefaultRules(UErrorCode	&)+55p
					; icu_56::PluralRules::select(icu_56::FixedDecimal const &)+44p ...
; void __thiscall icu_56::SharedObject::addRef(icu_56::SharedObject *__hidden this)
		extrn __imp_?addRef@SharedObject@icu_56@@QBEXXZ:near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+19Fp
					; icu_56::SharedObject::copyPtr<icu_56::SharedPluralRules>(icu_56::SharedPluralRules const *,icu_56::SharedPluralRules const * &)+57p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::Locale::~Locale(icu_56::Locale *__hidden this)
		extrn __imp_??1Locale@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+AAp
					; __unwindfunclet$?createObject@?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UBEPBVSharedPluralRules@2@PBXAAW4UErrorCode@@@Z$0+8p ...
; _DWORD __thiscall icu_56::Locale::Locale(icu_56::Locale *__hidden this, const	char *,	const char *, const char *, const char *)
		extrn __imp_??0Locale@icu_56@@QAE@PBD000@Z:near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+6Fp
					; DATA XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+6Fr
; const	char *__thiscall icu_56::Locale::getName(icu_56::Locale	*__hidden this)
		extrn __imp_?getName@Locale@icu_56@@QBEPBDXZ:near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::createObject(void const	*,UErrorCode &)+4Dp
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+278p ...
; void __thiscall icu_56::SharedObject::removeRef(icu_56::SharedObject *__hidden this)
		extrn __imp_?removeRef@SharedObject@icu_56@@QBEXXZ:near
					; CODE XREF: icu_56::PluralRules::forLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+81p
					; icu_56::SharedObject::copyPtr<icu_56::SharedPluralRules>(icu_56::SharedPluralRules const *,icu_56::SharedPluralRules const * &)+37p ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const wchar_t *)
		extrn __imp_??0UnicodeString@icu_56@@QAE@PB_W@Z:near
					; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+18Ap
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+25Fp ...
; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		extrn __imp_?length@UnicodeString@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::PluralRules::internalForLocale(icu_56::Locale const &,UPluralType,UErrorCode &)+16Cp
					; icu_56::getSamplesFromString(icu_56::UnicodeString const &,double *,int,UErrorCode &)+6Dp ...
		extrn __imp__floor:near	; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+143p
					; icu_56::getSamplesFromString(icu_56::UnicodeString const &,double *,int,UErrorCode &)+3A8p ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, wchar_t)
		extrn __imp_?indexOf@UnicodeString@icu_56@@QBEH_W@Z:near
					; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+F1p
					; icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+111p
					; DATA XREF: ...
; struct icu_56::UnicodeString __thiscall __high icu_56::UnicodeString::tempSubStringBetween(int, int)
		extrn __imp_?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z:near
					; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+CDp
					; icu_56::getSamplesFromString(icu_56::UnicodeString const &,double *,int,UErrorCode &)+198p ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, wchar_t, int)
		extrn __imp_?indexOf@UnicodeString@icu_56@@QBEH_WH@Z:near
					; CODE XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+8Ep
					; DATA XREF: icu_56::getSamplesFromString(icu_56::UnicodeString	const &,double *,int,UErrorCode	&)+8Er
; __declspec(dllimport)	public:	signed char __thiscall icu_56::UnicodeString::operator==(class icu_56::UnicodeString const &)const
		extrn __imp_??8UnicodeString@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::PluralRules::rulesForKeyword(icu_56::UnicodeString	const &)+49p
					; icu_56::RuleChain::isKeyword(icu_56::UnicodeString const &)+2Fp
					; DATA XREF: ...
; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*__hidden this,	const wchar_t *, int)
		extrn __imp_?compare@UnicodeString@icu_56@@QBECPB_WH@Z:near
					; CODE XREF: icu_56::PluralRules::isKeyword(icu_56::UnicodeString const	&)+2Fp
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+839p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z:near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+960p
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+9D9p ...
; int __thiscall icu_56::UVector32::size(icu_56::UVector32 *__hidden this)
		extrn __imp_?size@UVector32@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+632p
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+675p ...
; void __thiscall icu_56::UVector32::setElementAt(icu_56::UVector32 *__hidden this, int, int)
		extrn __imp_?setElementAt@UVector32@icu_56@@QAEXHH@Z:near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+53Dp
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+56Cp ...
; int __thiscall icu_56::UVector32::elementAti(icu_56::UVector32 *__hidden this, int)
		extrn __imp_?elementAti@UVector32@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+509p
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+5BFp ...
; void __thiscall icu_56::UVector32::addElement(icu_56::UVector32 *__hidden this, int, enum UErrorCode *)
		extrn __imp_?addElement@UVector32@icu_56@@QAEXHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+406p
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+424p ...
; _DWORD __thiscall icu_56::UVector32::UVector32(icu_56::UVector32 *__hidden this, enum	UErrorCode *)
		extrn __imp_??0UVector32@icu_56@@QAE@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+3A2p
					; icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint const &)+C3p
					; DATA XREF: ...
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near
					; CODE XREF: icu_56::PluralRuleParser::parse(icu_56::UnicodeString const &,icu_56::PluralRules *,UErrorCode &)+7Bp
					; icu_56::PluralRuleParser::parse(icu_56::UnicodeString	const &,icu_56::PluralRules *,UErrorCode &)+15Cp ...
; public: virtual void * __thiscall icu_56::UVector32::`scalar deleting	destructor'(unsigned int)
		extrn ??_GUVector32@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::UVector32::`vector deleting	destructor'(unsigned int)
		extrn ??_EUVector32@icu_56@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::UVector32::`local vftable'o
; public: virtual void * __thiscall icu_56::UVector32::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UVector32@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00005E60o
; _DWORD __thiscall icu_56::UVector32::~UVector32(icu_56::UVector32 *__hidden this)
		extrn __imp_??1UVector32@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UVector32::`scalar	deleting destructor'(uint)+28p
					; DATA XREF: icu_56::UVector32::`scalar	deleting destructor'(uint)+28r
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, wchar_t)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z:near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+650p
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+683p ...
; _DWORD __thiscall __high icu_56::UnicodeString::UnicodeString(const char *, int, enum	icu_56::UnicodeString::EInvariant)
		extrn __imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z:near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+619p
					; DATA XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+619r
		extrn _ures_getSize_56:near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+57Ep
					; icu_56::PluralAvailableLocalesEnumeration::count(UErrorCode &)+68p
		extrn _u_UCharsToChars_56:near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+3FAp
		extrn _uloc_getParent_56:near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+316p
; char *__cdecl	strcpy(char *Dest, const char *Source)
		extrn _strcpy:near	; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+2F4p
		extrn _ures_getStringByKey_56:near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+2A9p
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+34Dp
		extrn _ures_getByKey_56:near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+1DEp
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+416p ...
		extrn _ures_openDirect_56:near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+CBp
					; icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &)+B2p
; __declspec(dllimport)	public:	__thiscall icu_56::UnicodeString::UnicodeString(class icu_56::UnicodeString &&)
		extrn __imp_??0UnicodeString@icu_56@@QAE@$$QAV01@@Z:near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+86p
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+FEp ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		extrn __imp_??0UnicodeString@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::PluralRules::getRuleFromResource(icu_56::Locale const &,UPluralType,UErrorCode &)+54p
					; icu_56::PluralRules::getRuleFromResource(icu_56::Locale const	&,UPluralType,UErrorCode &)+594p ...
		extrn _ures_close_56:near
					; CODE XREF: icu_56::LocalUResourceBundlePointer::~LocalUResourceBundlePointer(void)+29p
					; icu_56::PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration(void)+33p ...
		extrn _ures_getNextString_56:near
					; CODE XREF: icu_56::ures_getNextUnicodeString(UResourceBundle *,char const * *,UErrorCode *)+3Fp
; public: virtual void * __thiscall icu_56::AndConstraint::`scalar deleting destructor'(unsigned int)
		extrn ??_GAndConstraint@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::AndConstraint::`vector deleting destructor'(unsigned int)
		extrn ??_EAndConstraint@icu_56@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::AndConstraint::`vftable'o
; void __thiscall icu_56::UVector32::assign(icu_56::UVector32 *__hidden	this, const struct icu_56::UVector32 *,	enum UErrorCode	*)
		extrn __imp_?assign@UVector32@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+126p
					; DATA XREF: icu_56::AndConstraint::AndConstraint(icu_56::AndConstraint	const &)+126r
		extrn _fmod:near	; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+98p
		extrn _uprv_floor_56:near
					; CODE XREF: icu_56::AndConstraint::isFulfilled(icu_56::FixedDecimal const &)+5Dp
; public: virtual void * __thiscall icu_56::OrConstraint::`scalar deleting destructor'(unsigned int)
		extrn ??_GOrConstraint@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::OrConstraint::`vector deleting destructor'(unsigned int)
		extrn ??_EOrConstraint@icu_56@@UAEPAXI@Z:near ;	weak
					; DATA XREF: .rdata:const icu_56::OrConstraint::`vftable'o
; public: virtual void * __thiscall icu_56::RuleChain::`scalar deleting	destructor'(unsigned int)
		extrn ??_GRuleChain@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::RuleChain::`vector deleting	destructor'(unsigned int)
		extrn ??_ERuleChain@icu_56@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::RuleChain::`vftable'o
		extrn _uprv_itou_56:near
					; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+24Bp
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+3C1p ...
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator+=(wchar_t)
		extrn __imp_??YUnicodeString@icu_56@@QAEAAV01@_W@Z:near
					; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+72p
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+86p ...
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator+=(class icu_56::UnicodeString const &)
		extrn __imp_??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::RuleChain::dumpRules(icu_56::UnicodeString	&)+5Ep
					; icu_56::RuleChain::dumpRules(icu_56::UnicodeString &)+12Ep ...
; public: virtual void * __thiscall icu_56::PluralRuleParser::`scalar deleting destructor'(unsigned int)
		extrn ??_GPluralRuleParser@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::PluralRuleParser::`vector deleting destructor'(unsigned int)
		extrn ??_EPluralRuleParser@icu_56@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::PluralRuleParser::`vftable'o
; int __cdecl _atoi(const char *Str)
		extrn __imp__atoi:near	; CODE XREF: icu_56::PluralRuleParser::getNumberValue(icu_56::UnicodeString const &)+74p
					; icu_56::FixedDecimal::decimals(double)+DDp
					; DATA XREF: ...
; int __thiscall __high	icu_56::UnicodeString::extract(int, int, char *, int, enum icu_56::UnicodeString::EInvariant)
		extrn __imp_?extract@UnicodeString@icu_56@@QBEHHHPADHW4EInvariant@12@@Z:near
					; CODE XREF: icu_56::PluralRuleParser::getNumberValue(icu_56::UnicodeString const &)+50p
					; DATA XREF: icu_56::PluralRuleParser::getNumberValue(icu_56::UnicodeString const &)+50r
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@ABV01@HH@Z:near
					; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+3DBp
					; DATA XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+3DBr
; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z:near
					; CODE XREF: icu_56::PluralRuleParser::getNextToken(UErrorCode &)+8Bp
					; icu_56::PluralRuleParser::getNextToken(UErrorCode &)+159p ...
; _DWORD __thiscall icu_56::UVector::~UVector(icu_56::UVector *__hidden	this)
		extrn __imp_??1UVector@icu_56@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$1+8p
					; icu_56::PluralKeywordEnumeration::~PluralKeywordEnumeration(void)+5Ap
					; DATA XREF: ...
; _DWORD __thiscall icu_56::StringEnumeration::~StringEnumeration(icu_56::StringEnumeration *__hidden this)
		extrn __imp_??1StringEnumeration@icu_56@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0PluralKeywordEnumeration@icu_56@@QAE@PAVRuleChain@1@AAW4UErrorCode@@@Z$0+5p
					; icu_56::PluralKeywordEnumeration::~PluralKeywordEnumeration(void)+73p ...
; void __thiscall icu_56::UVector::addElement(icu_56::UVector *__hidden	this, void *, enum UErrorCode *)
		extrn __imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+15Dp
					; icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+24Dp
					; DATA XREF: ...
; void (__cdecl	*__thiscall icu_56::UVector::setDeleter(icu_56::UVector	*__hidden this,	void (__cdecl *)(void *)))(void	*)
		extrn __imp_?setDeleter@UVector@icu_56@@QAEP6AXPAX@ZP6AX0@Z@Z:near
					; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+B2p
					; DATA XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+B2r
; void __cdecl uprv_deleteUObject_56(void *)
		extrn _uprv_deleteUObject_56:near
					; DATA XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+A7o
; _DWORD __thiscall icu_56::UVector::UVector(icu_56::UVector *__hidden this, enum UErrorCode *)
		extrn __imp_??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+7Ap
					; DATA XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+7Ar
; _DWORD __thiscall icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration *__hidden this)
		extrn __imp_??0StringEnumeration@icu_56@@IAE@XZ:near
					; CODE XREF: icu_56::PluralKeywordEnumeration::PluralKeywordEnumeration(icu_56::RuleChain *,UErrorCode &)+47p
					; icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &)+47p
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::PluralKeywordEnumeration::`scalar deleting destructor'(unsigned int)
		extrn ??_GPluralKeywordEnumeration@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::PluralKeywordEnumeration::`vector deleting destructor'(unsigned int)
		extrn ??_EPluralKeywordEnumeration@icu_56@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::PluralKeywordEnumeration::`vftable'o
; public: virtual char const * __thiscall icu_56::StringEnumeration::next(int *, enum  UErrorCode &)
		extrn ?next@StringEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:0000AA1Co
; public: virtual void * __thiscall icu_56::UnicodeString::`scalar deleting destructor'(unsigned int)
		extrn ??_GUnicodeString@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::UnicodeString::`vector deleting destructor'(unsigned int)
		extrn ??_EUnicodeString@icu_56@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::UnicodeString::`local	vftable'o
; public: virtual void * __thiscall icu_56::UnicodeString::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:0000A9E4o
; public: virtual void __thiscall icu_56::UnicodeString::extractBetween(int, int, class	icu_56::UnicodeString &)const
		extrn ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z:near
					; DATA XREF: .rdata:0000A9E8o
; public: virtual void __thiscall icu_56::UnicodeString::handleReplaceBetween(int, int,	class icu_56::UnicodeString const &)
		extrn ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z:near
					; DATA XREF: .rdata:0000A9ECo
; public: virtual void __thiscall icu_56::UnicodeString::copy(int, int,	int)
		extrn ?copy@UnicodeString@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:0000A9F0o
; public: virtual signed char __thiscall icu_56::UnicodeString::hasMetaData(void)const
		extrn ?hasMetaData@UnicodeString@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:0000A9F4o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::UnicodeString::clone(void)const
		extrn ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ:near
					; DATA XREF: .rdata:0000A9F8o
; protected: virtual int __thiscall icu_56::UnicodeString::getLength(void)const
		extrn ?getLength@UnicodeString@icu_56@@MBEHXZ:near
					; DATA XREF: .rdata:0000A9FCo
; protected: virtual wchar_t __thiscall	icu_56::UnicodeString::getCharAt(int)const
		extrn ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z:near
					; DATA XREF: .rdata:0000AA00o
; protected: virtual int __thiscall icu_56::UnicodeString::getChar32At(int)const
		extrn ?getChar32At@UnicodeString@icu_56@@MBEHH@Z:near
					; DATA XREF: .rdata:0000AA04o
; void *__thiscall icu_56::UVector::elementAt(icu_56::UVector *__hidden	this, int)
		extrn __imp_?elementAt@UVector@icu_56@@QBEPAXH@Z:near
					; CODE XREF: icu_56::PluralKeywordEnumeration::snext(UErrorCode	&)+7Fp
					; DATA XREF: icu_56::PluralKeywordEnumeration::snext(UErrorCode	&)+7Fr
; int __thiscall icu_56::UVector::size(icu_56::UVector *__hidden this)
		extrn __imp_?size@UVector@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::PluralKeywordEnumeration::snext(UErrorCode	&)+40p
					; icu_56::PluralKeywordEnumeration::count(UErrorCode &)+2Bp
					; DATA XREF: ...
; signed __int8	__thiscall icu_56::VisibleDigits::isNaNOrInfinity(icu_56::VisibleDigits	*__hidden this)
		extrn ?isNaNOrInfinity@VisibleDigits@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::VisibleDigits const &)+63p
; void __thiscall icu_56::VisibleDigits::getFixedDecimal(icu_56::VisibleDigits *__hidden this, double *, __int64 *, __int64 *, __int64 *, int *, signed	__int8 *)
		extrn ?getFixedDecimal@VisibleDigits@icu_56@@QBEXAANAA_J11AAHAAC@Z:near
					; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::VisibleDigits const &)+4Dp
; double __thiscall icu_56::DigitList::getDouble(icu_56::DigitList *__hidden this)
		extrn ?getDouble@DigitList@icu_56@@QBENXZ:near
					; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+12Ap
; _DWORD __thiscall icu_56::DigitList::~DigitList(icu_56::DigitList *__hidden this)
		extrn ??1DigitList@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+E7p
					; icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+1BDp ...
; void __thiscall icu_56::DigitList::set(icu_56::DigitList *__hidden this, const struct	icu_56::StringPiece *, enum UErrorCode *, unsigned int)
		extrn ?set@DigitList@icu_56@@QAEXABVStringPiece@2@AAW4UErrorCode@@I@Z:near
					; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+ADp
; struct icu_56::StringPiece __thiscall	__high icu_56::CharString::toStringPiece()
		extrn __imp_?toStringPiece@CharString@icu_56@@QBE?AVStringPiece@2@XZ:near
					; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+99p
					; DATA XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+99r
; _DWORD __thiscall icu_56::DigitList::DigitList(icu_56::DigitList *__hidden this)
		extrn ??0DigitList@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+7Ep
; struct icu_56::CharString *__thiscall	icu_56::CharString::appendInvariantChars(icu_56::CharString *__hidden this, const struct icu_56::UnicodeString *, enum UErrorCode *)
		extrn __imp_?appendInvariantChars@CharString@icu_56@@QAEAAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+6Bp
					; DATA XREF: icu_56::FixedDecimal::FixedDecimal(icu_56::UnicodeString const &,UErrorCode &)+6Br
		extrn _uprv_isPositiveInfinity_56:near
					; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+86p
					; icu_56::FixedDecimal::getFractionalDigits(double,int)+6Cp
		extrn _uprv_isNaN_56:near
					; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+6Cp
					; icu_56::FixedDecimal::getFractionalDigits(double,int)+54p
		extrn _fabs:near	; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+54p
					; icu_56::FixedDecimal::quickInit(double)+30p ...
		extrn __alldiv:near	; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+1A4p
		extrn __allrem:near	; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+179p
		extrn __ftol2:near	; CODE XREF: icu_56::FixedDecimal::init(double,int,__int64)+F0p
					; icu_56::FixedDecimal::getFractionalDigits(double,int)+EEp ...
; int _sprintf(char *Dest, const char *Format, ...)
		extrn __imp__sprintf:near
					; CODE XREF: icu_56::FixedDecimal::decimals(double)+C7p
					; DATA XREF: icu_56::FixedDecimal::decimals(double)+C7r
		extrn _pow:near		; CODE XREF: icu_56::FixedDecimal::getFractionalDigits(double,int)+139p
		extrn __allmul:near	; CODE XREF: icu_56::FixedDecimal::adjustForMinFractionDigits(int)+89p
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)+D3p
					; icu_56::CacheKey<icu_56::SharedPluralRules>::hashCode(void)+43p
		extrn _ures_getKey_56:near
					; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)+BEp
		extrn _ures_getNextResource_56:near
					; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)+76p
		extrn _ures_resetIterator_56:near
					; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::reset(UErrorCode &)+64p
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)+34p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+A1p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int &)+98p
		extrn _uprv_checkValidMemory:near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+88p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int &)+7Fp ...
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+34p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int &)+62p
; struct icu_56::UnifiedCache *__cdecl static icu_56::UnifiedCache::getInstance(enum UErrorCode	*)
		extrn __imp_?getInstance@UnifiedCache@icu_56@@SAPAV12@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UnifiedCache::getByLocale<icu_56::SharedPluralRules>(icu_56::Locale const &,icu_56::SharedPluralRules const * &,UErrorCode	&)+46p
					; DATA XREF: icu_56::UnifiedCache::getByLocale<icu_56::SharedPluralRules>(icu_56::Locale const &,icu_56::SharedPluralRules const * &,UErrorCode	&)+46r
; public: virtual void * __thiscall icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::`scalar deleting destructor'(unsigned int)
		extrn ??_G?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::LocaleCacheKey<class icu_56::SharedPluralRules>::`vector deleting destructor'(unsigned int)
		extrn ??_E?$LocaleCacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z:near ;	weak
					; DATA XREF: .rdata:const icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::`vftable'o
; int __thiscall icu_56::Locale::hashCode(icu_56::Locale *__hidden this)
		extrn __imp_?hashCode@Locale@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::hashCode(void)+38p
					; DATA XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::hashCode(void)+38r
; __declspec(dllimport)	public:	signed char __thiscall icu_56::Locale::operator==(class	icu_56::Locale const &)const
		extrn __imp_??8Locale@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase	const &)+5Bp
					; DATA XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase	const &)+5Br
; char *__cdecl	_strncpy(char *Dest, const char	*Source, size_t	Count)
		extrn __imp__strncpy:near
					; CODE XREF: icu_56::LocaleCacheKey<icu_56::SharedPluralRules>::writeDescription(char *,int)+57p
					; icu_56::CacheKey<icu_56::SharedPluralRules>::writeDescription(char *,int)+5Bp
					; DATA XREF: ...
; _DWORD __thiscall icu_56::CacheKeyBase::~CacheKeyBase(icu_56::CacheKeyBase *__hidden this)
		extrn __imp_??1CacheKeyBase@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::~CacheKey<icu_56::SharedPluralRules>(void)+31p
					; DATA XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::~CacheKey<icu_56::SharedPluralRules>(void)+31r
; public: virtual void * __thiscall icu_56::CacheKey<class icu_56::SharedPluralRules>::`scalar deleting	destructor'(unsigned int)
		extrn ??_G?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::CacheKey<class icu_56::SharedPluralRules>::`vector deleting	destructor'(unsigned int)
		extrn ??_E?$CacheKey@VSharedPluralRules@icu_56@@@icu_56@@UAEPAXI@Z:near	; weak
					; DATA XREF: .rdata:const icu_56::CacheKey<icu_56::SharedPluralRules>::`vftable'o
		extrn _ustr_hashCharsN_56:near
					; CODE XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::hashCode(void)+50p
; const	char *__thiscall type_info::name(type_info *__hidden this, struct __type_info_node *)
		extrn __imp_?name@type_info@@QBEPBDPAU__type_info_node@@@Z:near
					; CODE XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::hashCode(void)+2Fp
					; icu_56::CacheKey<icu_56::SharedPluralRules>::writeDescription(char *,int)+2Fp
					; DATA XREF: ...
; struct __type_info_node __type_info_root_node
		extrn ?__type_info_root_node@@3U__type_info_node@@A:near
					; DATA XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::hashCode(void)+25o
					; icu_56::CacheKey<icu_56::SharedPluralRules>::writeDescription(char *,int)+25o
; __declspec(dllimport)	public:	bool __thiscall	type_info::operator==(class type_info const &)const
		extrn __imp_??8type_info@@QBE_NABV0@@Z:near
					; CODE XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase const	&)+40p
					; DATA XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase const	&)+40r
		extrn ___RTtypeid:near	; CODE XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase const	&)+27p
					; icu_56::CacheKey<icu_56::SharedPluralRules>::operator==(icu_56::CacheKeyBase const &)+36p
; _DWORD __thiscall icu_56::CacheKeyBase::CacheKeyBase(icu_56::CacheKeyBase *__hidden this, const struct icu_56::CacheKeyBase *)
		extrn __imp_??0CacheKeyBase@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::CacheKey<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const	&)+2Cp
					; DATA XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::CacheKey<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const	&)+2Cr
; _DWORD __thiscall icu_56::CacheKeyBase::CacheKeyBase(icu_56::CacheKeyBase *__hidden this)
		extrn __imp_??0CacheKeyBase@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::CacheKey<icu_56::SharedPluralRules>(void)+28p
					; DATA XREF: icu_56::CacheKey<icu_56::SharedPluralRules>::CacheKey<icu_56::SharedPluralRules>(void)+28r
; void __thiscall icu_56::UnifiedCache::_get(icu_56::UnifiedCache *__hidden this, const	struct icu_56::CacheKeyBase *, const struct icu_56::SharedObject **, const void	*, enum	UErrorCode *)
		extrn __imp_?_get@UnifiedCache@icu_56@@ABEXABVCacheKeyBase@2@AAPBVSharedObject@2@PBXAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,void const *,icu_56::SharedPluralRules const * &,UErrorCode &)+60p
					; DATA XREF: icu_56::UnifiedCache::get<icu_56::SharedPluralRules>(icu_56::CacheKey<icu_56::SharedPluralRules> const &,void const *,icu_56::SharedPluralRules const * &,UErrorCode &)+60r


		end
