;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	585C811EABAD8BEC5F3072D136A9E48C
; Input	CRC32 :	C317F35A

; File Name   :	D:\compspace\objfiles\firefox\i18n\digitlst.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_400
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_1000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_1DC@EOAAEPGI@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$DO?$AA?$DN?$AA?8?$AA0?$AA?8?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$DM?$AA?$DN?$AA?8?$AA9?$AA?8?$AA?$AA@+0Ch ;	"='0' && digit<='9'"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_4000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ ; icu_56::DecimalFormatSymbols::isCustomCurrencySymbol(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset ??_C@_1DC@EOAAEPGI@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$DO?$AA?$DN?$AA?8?$AA0?$AA?8?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$DM?$AA?$DN?$AA?8?$AA9?$AA?8?$AA?$AA@+0Ch	; "='0' && digit<='9'"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B db 2, 0
word_D2		dw 0			; DATA XREF: .data:?__LINE__Var@?1??formatBase10@icu_56@@YAH_JPAD@Z@4JA@2f57b92bo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; char `public:	static char __cdecl icu_56::DigitList::getStrtodDecimalSeparator(void)'::`2'::gDecimal
?gDecimal@?1??getStrtodDecimalSeparator@DigitList@icu_56@@SADXZ@4DA db ?
					; DATA XREF: icu_56::DigitList::getStrtodDecimalSeparator(void)+3Cr
					; icu_56::DigitList::getStrtodDecimalSeparator(void)+78w
; char `public:	double __thiscall icu_56::DigitList::getDouble(void)const'::`2'::gDecimal
?gDecimal@?1??getDouble@DigitList@icu_56@@QBENXZ@4DA db	?
					; DATA XREF: icu_56::DigitList::getDouble(void):loc_3200r
					; icu_56::DigitList::getDouble(void)+348w
		align 4
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_FF:					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 134h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 138h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
					; DATA XREF: .data:long	`icu_56::DigitList::setCount(int)'::`2'::__LINE__Varo
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 170h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::DecimalFormatSymbols::operator!=(class	icu_56::DecimalFormatSymbols const &)const
		public ??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z
??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8DecimalFormatSymbols@icu_56@@QBECABV01@@Z ; icu_56::DecimalFormatSymbols::operator==(icu_56::DecimalFormatSymbols const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DecimalFormatSymbols::isCustomCurrencySymbol(icu_56::DecimalFormatSymbols *__hidden this)
		public ?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ
?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ proc near
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+0AD0h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DecimalFormatSymbols::isCustomIntlCurrencySymbol(icu_56::DecimalFormatSymbols *__hidden this)
		public ?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ
?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi

loc_200:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+0AD1h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 228h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::DecimalFormatSymbols::getSymbol(enum  icu_56::DecimalFormatSymbols::ENumberFormatSymbol)const
		public ?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z
?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z proc near

var_E4		= byte ptr -0E4h
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_E0], 0
		cmp	[ebp+arg_4], 1Ch
		jge	short loc_26D
		mov	eax, [ebp+arg_4]
		shl	eax, 6
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax+4]
		mov	[ebp+var_14], edx
		jmp	short loc_278
; ---------------------------------------------------------------------------

loc_26D:				; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+31j
		mov	eax, [ebp+var_8]
		add	eax, 704h
		mov	[ebp+var_14], eax

loc_278:				; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+43j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_E0]
		or	ecx, 1
		mov	[ebp+var_E0], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString const & __thiscall icu_56::DecimalFormatSymbols::getConstSymbol(enum  icu_56::DecimalFormatSymbols::ENumberFormatSymbol)const
		public ?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z
?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 1Ch
		jge	short loc_2F3
		mov	eax, [ebp+arg_0]
		shl	eax, 6
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax+4]
		mov	[ebp+var_14], edx
		jmp	short loc_2FE
; ---------------------------------------------------------------------------

loc_2F3:				; CODE XREF: icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+27j
		mov	eax, [ebp+var_8]
		add	eax, 704h
		mov	[ebp+var_14], eax

loc_2FE:				; CODE XREF: icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+39j
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::DecimalFormatSymbols::setSymbol(enum	icu_56::DecimalFormatSymbols::ENumberFormatSymbol, class icu_56::UnicodeString const &,	signed char)
		public ?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z proc near

var_144		= dword	ptr -144h
var_140		= dword	ptr -140h
var_138		= byte ptr -138h
var_2D		= byte ptr -2Dh
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_144]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_0], 8
		jnz	short loc_363
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+0AD0h], 1
		jmp	short loc_373
; ---------------------------------------------------------------------------

loc_363:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+49j
		cmp	[ebp+arg_0], 9
		jnz	short loc_373
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+0AD1h], 1

loc_373:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+55j
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+5Bj
		cmp	[ebp+arg_0], 1Ch
		jge	short loc_399
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		shl	ecx, 6
		mov	edx, [ebp+var_18]
		lea	ecx, [edx+ecx+4]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_399:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+6Bj
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_49A
		cmp	[ebp+arg_0], 4
		jnz	loc_49A
		mov	esi, esp
		push	7FFFFFFFh	; int
		push	0		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z ; icu_56::UnicodeString::countChar32(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	loc_49A
		mov	esi, esp
		push	0		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?char32At@UnicodeString@icu_56@@QBEHH@Z ; icu_56::UnicodeString::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		push	eax
		call	_u_charDigitValue_56
		add	esp, 4
		test	eax, eax
		jnz	loc_49A
		mov	[ebp+var_2D], 1

loc_400:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		jmp	short loc_40A
; ---------------------------------------------------------------------------

loc_402:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+189j
		mov	al, [ebp+var_2D]
		add	al, 1
		mov	[ebp+var_2D], al

loc_40A:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char):loc_400j
		movsx	eax, [ebp+var_2D]
		cmp	eax, 9
		jg	loc_49A
		mov	eax, [ebp+var_24]
		add	eax, 1
		mov	[ebp+var_24], eax
		mov	esi, esp
		mov	eax, [ebp+var_24]
		push	eax		; int
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@H@Z ; icu_56::UnicodeString::UnicodeString(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_140], eax
		mov	ecx, [ebp+var_140]
		mov	[ebp+var_144], ecx
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	edx, [ebp+var_144]
		push	edx
		movsx	eax, [ebp+var_2D]
		add	eax, 11h
		shl	eax, 6
		mov	ecx, [ebp+var_18]
		lea	ecx, [ecx+eax+4]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z	; icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_402
; ---------------------------------------------------------------------------

loc_49A:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+93j
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+9Dj ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0 proc near
					; DATA XREF: .xdata$x:0000050Co
		mov	esi, esp
		lea	ecx, [ebp-138h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z	proc near
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-148h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		jmp	___CxxFrameHandler3
__ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 508h
__unwindtable$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000518o
		dd offset __unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0
__ehfuncinfo$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+1Eo
		dd offset __unwindtable$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 534h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Locale __thiscall icu_56::DecimalFormatSymbols::getLocale(void)const
		public ?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ
?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+var_8]
		add	eax, 744h
		mov	esi, esp
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_D4]
		or	ecx, 1
		mov	[ebp+var_D4], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::DecimalFormatSymbols::getCurrencyPattern(icu_56::DecimalFormatSymbols *__hidden this)
		public ?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ
?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+94Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Formattable::operator!=(class icu_56::Formattable const &)const
		public ??9Formattable@icu_56@@QBECABV01@@Z
??9Formattable@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8Formattable@icu_56@@QBECABV01@@Z ; icu_56::Formattable::operator==(icu_56::Formattable const	&)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Formattable@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 628h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDouble(icu_56::Formattable *__hidden this)
		public ?getDouble@Formattable@icu_56@@QBENXZ
?getDouble@Formattable@icu_56@@QBENXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDouble@Formattable@icu_56@@QBENXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 658h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *__hidden this)
		public ?getLong@Formattable@icu_56@@QBEHXZ
?getLong@Formattable@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLong@Formattable@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 688h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __thiscall icu_56::Formattable::getInt64(icu_56::Formattable *__hidden this)
		public ?getInt64@Formattable@icu_56@@QBE_JXZ
?getInt64@Formattable@icu_56@@QBE_JXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx+8]
		mov	edx, [ecx+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getInt64@Formattable@icu_56@@QBE_JXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDate(icu_56::Formattable *__hidden this)
		public ?getDate@Formattable@icu_56@@QBENXZ
?getDate@Formattable@icu_56@@QBENXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDate@Formattable@icu_56@@QBENXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *this, struct icu_56::UnicodeString *)
		public ?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 744h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__thiscall icu_56::Formattable::getArray(icu_56::Formattable *this,	int *)
		public ?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z
?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 784h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Formattable & __thiscall icu_56::Formattable::operator[](int)
		public ??AFormattable@icu_56@@QAEAAV01@H@Z
??AFormattable@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		imul	eax, 0E0h
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??AFormattable@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::DigitList *__thiscall icu_56::Formattable::getDigitList(icu_56::Formattable *__hidden this)
		public ?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ
?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDate(icu_56::Formattable *this, enum UErrorCode *)
		public ?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z
?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx

loc_7FD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+98h], 0
		jz	short loc_841
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_83D
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 3

loc_83D:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+42j
		fldz
		jmp	short loc_847
; ---------------------------------------------------------------------------

loc_841:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+2Dj
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]

loc_847:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+4Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 860h
		public __real@0000000000000000
__real@0000000000000000	dd 2 dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 868h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+35p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 894h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *__hidden this)
		public ?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ
?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *__hidden	this)
		public ?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ
?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *this, enum UErrorCode *)
		public ?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z
?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?getLong@Formattable@icu_56@@QBEHAAW4UErrorCode@@@Z ; icu_56::Formattable::getLong(UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 93Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void **__thiscall icu_56::Formattable::toUFormattable(icu_56::Formattable *__hidden this)
		public ?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ
?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 96Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *const *__thiscall icu_56::Formattable::toUFormattable(icu_56::Formattable *__hidden this)
		public ?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ
?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 99Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::Formattable *__cdecl icu_56::Formattable::fromUFormattable(void **)
		public ?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z
?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__cdecl icu_56::Formattable::fromUFormattable(void *const *)
		public ?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z
?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *__hidden this)
		public ??0FieldPosition@icu_56@@QAE@XZ
??0FieldPosition@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0FieldPosition@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A60h
		dd offset ??_R4FieldPosition@icu_56@@6B@ ; const icu_56::FieldPosition::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7FieldPosition@icu_56@@6B@
; const	icu_56::FieldPosition::`vftable'
??_7FieldPosition@icu_56@@6B@ dd offset	??_EFieldPosition@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::FieldPosition::FieldPosition(void)+38o
					; icu_56::FieldPosition::FieldPosition(int)+38o ...
					; icu_56::FieldPosition::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@FieldPosition@icu_56@@UBEPAXXZ ; icu_56::FieldPosition::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A6Ch
		public ??_R4FieldPosition@icu_56@@6B@
; const	icu_56::FieldPosition::`RTTI Complete Object Locator'
??_R4FieldPosition@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00000A60o
		dd offset ??_R0?AVFieldPosition@icu_56@@@8 ; icu_56::FieldPosition `RTTI Type Descriptor'
		dd offset ??_R3FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0A80h
		public ??_R0?AVFieldPosition@icu_56@@@8
; class	icu_56::FieldPosition `RTTI Type Descriptor'
??_R0?AVFieldPosition@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00000A78o
					; .rdata$r:icu_56::FieldPosition::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avfieldposit	db '.?AVFieldPosition@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AA4h
		public ??_R3FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
??_R3FieldPosition@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00000A7Co
					; .rdata$r:00000ADCo
		dd 3
		dd offset ??_R2FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AB4h
		public ??_R2FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Base Class Array'
??_R2FieldPosition@icu_56@@8 dd	offset ??_R1A@?0A@EA@FieldPosition@icu_56@@8
					; DATA XREF: .rdata$r:00000AB0o
					; icu_56::FieldPosition::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AC4h
		public ??_R1A@?0A@EA@FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@FieldPosition@icu_56@@8 dd offset	??_R0?AVFieldPosition@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::FieldPosition::`RTTI Base	Class Array'o
					; icu_56::FieldPosition	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AE0h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:00000AB8o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Array'o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0AFCh
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B1Ch
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000AF8o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B2Ch
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000B28o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B38h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000ABCo
					; .rdata$r:00000B30o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0B54h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B74h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000B50o
					; .rdata$r:00000BA4o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B84h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00000B80o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B8Ch
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *this, int)
		public ??0FieldPosition@icu_56@@QAE@H@Z
??0FieldPosition@icu_56@@QAE@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FieldPosition@icu_56@@QAE@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *this, const struct icu_56::FieldPosition *)
		public ??0FieldPosition@icu_56@@QAE@ABV01@@Z
??0FieldPosition@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FieldPosition@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getField(icu_56::FieldPosition *__hidden this)
		public ?getField@FieldPosition@icu_56@@QBEHXZ
?getField@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getField@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getBeginIndex(icu_56::FieldPosition *__hidden this)
		public ?getBeginIndex@FieldPosition@icu_56@@QBEHXZ
?getBeginIndex@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBeginIndex@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getEndIndex(icu_56::FieldPosition *__hidden this)
		public ?getEndIndex@FieldPosition@icu_56@@QBEHXZ
?getEndIndex@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getEndIndex@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setField(icu_56::FieldPosition	*this, int)
		public ?setField@FieldPosition@icu_56@@QAEXH@Z
?setField@FieldPosition@icu_56@@QAEXH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setField@FieldPosition@icu_56@@QAEXH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setBeginIndex(icu_56::FieldPosition *this, int)
		public ?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z
?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setEndIndex(icu_56::FieldPosition *this, int)
		public ?setEndIndex@FieldPosition@icu_56@@QAEXH@Z
?setEndIndex@FieldPosition@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setEndIndex@FieldPosition@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPosition::`scalar deleting destructor'(unsigned int)
		public ??_GFieldPosition@icu_56@@UAEPAXI@Z
??_GFieldPosition@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPosition@icu_56@@UAE@XZ	; icu_56::FieldPosition::~FieldPosition(void)

loc_DFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E1D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_E1D:				; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GFieldPosition@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPosition::`vector deleting destructor'(unsigned int)
		public ??_EFieldPosition@icu_56@@UAEPAXI@Z
??_EFieldPosition@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::FieldPosition::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_EA3
		push	offset ??1FieldPosition@icu_56@@UAE@XZ ; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E9B
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_E9B:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_ECC
; ---------------------------------------------------------------------------

loc_EA3:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPosition@icu_56@@UAE@XZ	; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_EC9
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_EC9:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_ECC:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EFieldPosition@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FieldPosition &	__thiscall icu_56::FieldPosition::operator=(class icu_56::FieldPosition	const &)
		public ??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z
??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPosition::operator==(class icu_56::FieldPosition const &)const
		public ??8FieldPosition@icu_56@@QBECABV01@@Z
??8FieldPosition@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::FieldPosition::operator!=(icu_56::FieldPosition const &)+2Ap

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_F8E
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+0Ch]
		cmp	edx, [ecx+0Ch]
		jnz	short loc_F8E
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+8]
		cmp	edx, [ecx+8]
		jnz	short loc_F8E
		mov	[ebp+var_CD], 1
		jmp	short loc_F95
; ---------------------------------------------------------------------------

loc_F8E:				; CODE XREF: icu_56::FieldPosition::operator==(icu_56::FieldPosition const &)+2Fj
					; icu_56::FieldPosition::operator==(icu_56::FieldPosition const	&)+3Dj	...
		mov	[ebp+var_CD], 0

loc_F95:				; CODE XREF: icu_56::FieldPosition::operator==(icu_56::FieldPosition const &)+54j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8FieldPosition@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPosition::operator!=(class icu_56::FieldPosition const &)const
		public ??9FieldPosition@icu_56@@QBECABV01@@Z
??9FieldPosition@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8FieldPosition@icu_56@@QBECABV01@@Z ;	icu_56::FieldPosition::operator==(icu_56::FieldPosition	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9FieldPosition@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPositionIterator::operator!=(class icu_56::FieldPositionIterator const &)const
		public ??9FieldPositionIterator@icu_56@@QBECABV01@@Z
??9FieldPositionIterator@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi

loc_1000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8FieldPositionIterator@icu_56@@QBECABV01@@Z ;	icu_56::FieldPositionIterator::operator==(icu_56::FieldPositionIterator	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9FieldPositionIterator@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1044h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FieldPositionIterator &	__thiscall icu_56::FieldPositionIterator::operator=(class icu_56::FieldPositionIterator	const &)
		public ??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z
??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Format::operator!=(class icu_56::Format const &)const
		public ??9Format@icu_56@@QBECABV01@@Z
??9Format@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Format@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 110Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__thiscall icu_56::Measure::getNumber(icu_56::Measure *__hidden this)
		public ?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ
?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 8
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 113Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::MeasureUnit *__thiscall icu_56::Measure::getUnit(icu_56::Measure	*__hidden this)
		public ?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ
?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	proc near
					; CODE XREF: icu_56::CurrencyAmount::getCurrency(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0E8h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1170h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MeasureUnit::MeasureUnit(icu_56::MeasureUnit *__hidden this)
		public ??0MeasureUnit@icu_56@@QAE@XZ
??0MeasureUnit@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0MeasureUnit@icu_56@@QAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 11E0h
		dd offset ??_R4MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7MeasureUnit@icu_56@@6B@
; const	icu_56::MeasureUnit::`vftable'
??_7MeasureUnit@icu_56@@6B@ dd offset ??_EMeasureUnit@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::MeasureUnit::MeasureUnit(void)+38o
					; icu_56::MeasureUnit::MeasureUnit(int,int)+38o
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@MeasureUnit@icu_56@@UBEPAXXZ ; icu_56::MeasureUnit::getDynamicClassID(void)
		dd offset ?clone@MeasureUnit@icu_56@@UBEPAVUObject@2@XZ	; icu_56::MeasureUnit::clone(void)
		dd offset ??8MeasureUnit@icu_56@@UBECABVUObject@1@@Z ; icu_56::MeasureUnit::operator==(icu_56::UObject const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 11F4h
		public ??_R4MeasureUnit@icu_56@@6B@
; const	icu_56::MeasureUnit::`RTTI Complete Object Locator'
??_R4MeasureUnit@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:000011E0o
		dd offset ??_R0?AVMeasureUnit@icu_56@@@8 ; icu_56::MeasureUnit `RTTI Type Descriptor'
		dd offset ??_R3MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1208h
		public ??_R0?AVMeasureUnit@icu_56@@@8
; class	icu_56::MeasureUnit `RTTI Type Descriptor'
??_R0?AVMeasureUnit@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00001200o
					; .rdata$r:icu_56::MeasureUnit::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avmeasureuni	db '.?AVMeasureUnit@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 122Ch
		public ??_R3MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Class Hierarchy Descriptor'
??_R3MeasureUnit@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00001204o
					; .rdata$r:00001264o
		dd 3
		dd offset ??_R2MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 123Ch
		public ??_R2MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Base Class	Array'
??_R2MeasureUnit@icu_56@@8 dd offset ??_R1A@?0A@EA@MeasureUnit@icu_56@@8
					; DATA XREF: .rdata$r:00001238o
					; icu_56::MeasureUnit::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 124Ch
		public ??_R1A@?0A@EA@MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@MeasureUnit@icu_56@@8 dd offset ??_R0?AVMeasureUnit@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::MeasureUnit::`RTTI Base Class Array'o
					; icu_56::MeasureUnit `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1268h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MeasureUnit::operator!=(class icu_56::UObject const &)const
		public ??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z
??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MeasureUnit::MeasureUnit(icu_56::MeasureUnit *this,	int, int)
		public ??0MeasureUnit@icu_56@@AAE@HH@Z
??0MeasureUnit@icu_56@@AAE@HH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0MeasureUnit@icu_56@@AAE@HH@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1334h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MeasureUnit::`scalar deleting destructor'(unsigned int)
		public ??_GMeasureUnit@icu_56@@UAEPAXI@Z
??_GMeasureUnit@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1MeasureUnit@icu_56@@UAE@XZ ;	icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_137D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_137D:				; CODE XREF: icu_56::MeasureUnit::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GMeasureUnit@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1398h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MeasureUnit::`vector deleting destructor'(unsigned int)
		public ??_EMeasureUnit@icu_56@@UAEPAXI@Z
??_EMeasureUnit@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::MeasureUnit::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1403
		push	offset ??1MeasureUnit@icu_56@@UAE@XZ ; icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_13FB
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_13FB:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_142C
; ---------------------------------------------------------------------------

loc_1403:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1MeasureUnit@icu_56@@UAE@XZ ;	icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1429
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1429:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_142C:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EMeasureUnit@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1444h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::CurrencyUnit::getISOCurrency(icu_56::CurrencyUnit *__hidden	this)
		public ?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ
?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ proc near
					; CODE XREF: icu_56::CurrencyAmount::getISOCurrency(void)+2Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 10h
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1474h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::CurrencyUnit *__thiscall	icu_56::CurrencyAmount::getCurrency(icu_56::CurrencyAmount *__hidden this)
		public ?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ
?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ proc near
					; CODE XREF: icu_56::CurrencyAmount::getISOCurrency(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	; icu_56::Measure::getUnit(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::CurrencyAmount::getISOCurrency(icu_56::CurrencyAmount *__hidden this)
		public ?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ
?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ ; icu_56::CurrencyAmount::getCurrency(void)
		mov	ecx, eax	; this
		call	?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ ; icu_56::CurrencyUnit::getISOCurrency(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory *__hidden this)
		public ??0NumberFormatFactory@icu_56@@QAE@XZ
??0NumberFormatFactory@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0NumberFormatFactory@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1554h
		dd offset ??_R4NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7NumberFormatFactory@icu_56@@6B@
; const	icu_56::NumberFormatFactory::`vftable'
??_7NumberFormatFactory@icu_56@@6B@ dd offset ??_ENumberFormatFactory@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::NumberFormatFactory::NumberFormatFactory(void)+38o
					; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)+3Co
					; icu_56::NumberFormatFactory::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 156Ch
		public ??_R4NumberFormatFactory@icu_56@@6B@
; const	icu_56::NumberFormatFactory::`RTTI Complete Object Locator'
??_R4NumberFormatFactory@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00001554o
		dd offset ??_R0?AVNumberFormatFactory@icu_56@@@8 ; icu_56::NumberFormatFactory `RTTI Type Descriptor'
		dd offset ??_R3NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1580h
		public ??_R0?AVNumberFormatFactory@icu_56@@@8
; class	icu_56::NumberFormatFactory `RTTI Type Descriptor'
??_R0?AVNumberFormatFactory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001578o
					; .rdata$r:icu_56::NumberFormatFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avnumberform	db '.?AVNumberFormatFactory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 15ACh
		public ??_R3NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Class Hierarchy Descriptor'
??_R3NumberFormatFactory@icu_56@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:0000157Co
					; .rdata$r:000015E4o
		dd 3
		dd offset ??_R2NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 15BCh
		public ??_R2NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Base Class	Array'
??_R2NumberFormatFactory@icu_56@@8 dd offset ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8
					; DATA XREF: .rdata$r:000015B8o
					; icu_56::NumberFormatFactory::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 15CCh
		public ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8 dd offset ??_R0?AVNumberFormatFactory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::NumberFormatFactory::`RTTI Base Class Array'o
					; .rdata$r:00001920o
					; icu_56::NumberFormatFactory `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory *this,	const struct icu_56::NumberFormatFactory *)
		public ??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z
??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+49p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1644h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::NumberFormatFactory & __thiscall icu_56::NumberFormatFactory::operator=(class icu_56::NumberFormatFactory const	&)
		public ??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z
??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1698h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::NumberFormatFactory::`scalar deleting destructor'(unsigned int)
		public ??_GNumberFormatFactory@icu_56@@UAEPAXI@Z
??_GNumberFormatFactory@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_16E1
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_16E1:				; CODE XREF: icu_56::NumberFormatFactory::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GNumberFormatFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::NumberFormatFactory::`vector deleting destructor'(unsigned int)
		public ??_ENumberFormatFactory@icu_56@@UAEPAXI@Z
??_ENumberFormatFactory@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::NumberFormatFactory::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1767
		push	offset ??1NumberFormatFactory@icu_56@@UAE@XZ ; icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_175F
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_175F:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1790
; ---------------------------------------------------------------------------

loc_1767:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_178D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_178D:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_1790:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ENumberFormatFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory *this, const	struct icu_56::SimpleNumberFormatFactory *)
		public ??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::NumberFormatFactory *
		mov	ecx, [ebp+var_14] ; this
		call	??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z ; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7SimpleNumberFormatFactory@icu_56@@6B@ ; const icu_56::SimpleNumberFormatFactory::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+4]
		mov	[eax+4], dl
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 185Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:000018A0o
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
__unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1884h
		dd offset ??_R4SimpleNumberFormatFactory@icu_56@@6B@ ; const icu_56::SimpleNumberFormatFactory::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7SimpleNumberFormatFactory@icu_56@@6B@
; const	icu_56::SimpleNumberFormatFactory::`vftable'
??_7SimpleNumberFormatFactory@icu_56@@6B@ dd offset ??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+58o
					; icu_56::SimpleNumberFormatFactory::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?visible@SimpleNumberFormatFactory@icu_56@@UBECXZ ; icu_56::SimpleNumberFormatFactory::visible(void)
		dd offset ?getSupportedIDs@SimpleNumberFormatFactory@icu_56@@UBEPBVUnicodeString@2@AAHAAW4UErrorCode@@@Z ; icu_56::SimpleNumberFormatFactory::getSupportedIDs(int &,UErrorCode &)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 189Ch
__unwindtable$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000018ACo
		dd offset __unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 18C8h
		public ??_R4SimpleNumberFormatFactory@icu_56@@6B@
; const	icu_56::SimpleNumberFormatFactory::`RTTI Complete Object Locator'
??_R4SimpleNumberFormatFactory@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:00001884o
		dd offset ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8 ; icu_56::SimpleNumberFormatFactory `RTTI Type Descriptor'
		dd offset ??_R3SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 18DCh
		public ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8
; class	icu_56::SimpleNumberFormatFactory `RTTI	Type Descriptor'
??_R0?AVSimpleNumberFormatFactory@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000018D4o
					; .rdata$r:icu_56::SimpleNumberFormatFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avsimplenumb	db '.?AVSimpleNumberFormatFactory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 190Ch
		public ??_R3SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
??_R3SimpleNumberFormatFactory@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:000018D8o
					; .rdata$r:00001948o
		dd 4
		dd offset ??_R2SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 191Ch
		public ??_R2SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Array'
??_R2SimpleNumberFormatFactory@icu_56@@8 dd offset ??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8
					; DATA XREF: .rdata$r:00001918o
					; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8 ;	icu_56::NumberFormatFactory::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1930h
		public ??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8 dd offset ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::SimpleNumberFormatFactory::`RTTI Base Class Array'o
					; icu_56::SimpleNumberFormatFactory `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 194Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SimpleNumberFormatFactory::`scalar deleting	destructor'(unsigned int)
		public ??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1995
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1995:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SimpleNumberFormatFactory::`vector deleting	destructor'(unsigned int)
		public ??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::SimpleNumberFormatFactory::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1A1B
		push	offset ??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	48h ; 'H'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1A13
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1A13:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1A44
; ---------------------------------------------------------------------------

loc_1A1B:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1A41
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1A41:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_1A44:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NumberFormat::isParseIntegerOnly(icu_56::NumberFormat *__hidden this)
		public ?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ
?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+154h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NumberFormat::isLenient(icu_56::NumberFormat	*__hidden this)
		public ?isLenient@NumberFormat@icu_56@@UBECXZ
?isLenient@NumberFormat@icu_56@@UBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+155h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLenient@NumberFormat@icu_56@@UBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::DigitList::operator!=(class icu_56::DigitList const &)const
		public ??9DigitList@icu_56@@QBECABV01@@Z
??9DigitList@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8DigitList@icu_56@@QBECABV01@@Z ; icu_56::DigitList::operator==(icu_56::DigitList const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9DigitList@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::isNaN(icu_56::DigitList *__hidden	this)
		public ?isNaN@DigitList@icu_56@@QBECXZ
?isNaN@DigitList@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 30h
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isNaN@DigitList@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::isInfinite(icu_56::DigitList *__hidden this)
		public ?isInfinite@DigitList@icu_56@@QBECXZ
?isInfinite@DigitList@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::DigitList::getDouble(void)+165p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 40h
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isInfinite@DigitList@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::setToZero(icu_56::DigitList *__hidden this)
		public ?setToZero@DigitList@icu_56@@QAEXXZ
?setToZero@DigitList@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberZero_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setToZero@DigitList@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::digits(icu_56::DigitList *__hidden this)
		public ?digits@DigitList@icu_56@@QBEHXZ
?digits@DigitList@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)+4Ap
					; icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)+54p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	eax, [ecx]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?digits@DigitList@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::isPositive(icu_56::DigitList *__hidden this)
		public ?isPositive@DigitList@icu_56@@QBECXZ
?isPositive@DigitList@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::DigitList::getDouble(void)+1A3p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 80h
		neg	edx
		sbb	edx, edx
		neg	edx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isPositive@DigitList@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::getLowerExponent(icu_56::DigitList *__hidden this)
		public ?getLowerExponent@DigitList@icu_56@@QBEHXZ
?getLowerExponent@DigitList@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLowerExponent@DigitList@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void *	__cdecl	icu_56::DigitList::operator new(unsigned int, void *, enum  icu_56::EStackMode)
		public ??2DigitList@icu_56@@SAPAXIPAXW4EStackMode@1@@Z
??2DigitList@icu_56@@SAPAXIPAXW4EStackMode@1@@Z	proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2DigitList@icu_56@@SAPAXIPAXW4EStackMode@1@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::DigitList::operator delete(void *)
		public ??3DigitList@icu_56@@SAXPAX0W4EStackMode@1@@Z
??3DigitList@icu_56@@SAXPAX0W4EStackMode@1@@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3DigitList@icu_56@@SAXPAX0W4EStackMode@1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::internalSetDouble(icu_56::DigitList *this,	double)
		public ?internalSetDouble@DigitList@icu_56@@AAEXN@Z
?internalSetDouble@DigitList@icu_56@@AAEXN@Z proc near
					; CODE XREF: icu_56::DigitList::DigitList(void)+B5p
					; icu_56::DigitList::clear(void)+4Bp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+68h], 1
		mov	eax, [ebp+var_8]
		fld	[ebp+arg_0]
		fstp	qword ptr [eax+60h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?internalSetDouble@DigitList@icu_56@@AAEXN@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::internalSetInt64(icu_56::DigitList	*this, __int64)
		public ?internalSetInt64@DigitList@icu_56@@AAEX_J@Z
?internalSetInt64@DigitList@icu_56@@AAEX_J@Z proc near
					; CODE XREF: icu_56::DigitList::setInteger(__int64)+38p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+68h], 2
		mov	eax, [ebp+var_8]
		mov	ecx, dword ptr [ebp+arg_0]
		mov	[eax+60h], ecx
		mov	edx, dword ptr [ebp+arg_0+4]
		mov	[eax+64h], edx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?internalSetInt64@DigitList@icu_56@@AAEX_J@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::internalClear(icu_56::DigitList *__hidden this)
		public ?internalClear@DigitList@icu_56@@AAEXXZ
?internalClear@DigitList@icu_56@@AAEXXZ	proc near
					; CODE XREF: icu_56::DigitList::setPositive(signed char)+62p
					; icu_56::DigitList::setDecimalAt(int)+109p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+68h], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?internalClear@DigitList@icu_56@@AAEXXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitInterval::DigitInterval(icu_56::DigitInterval *__hidden this)
		public ??0DigitInterval@icu_56@@QAE@XZ
??0DigitInterval@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 7FFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 80000000h
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0DigitInterval@icu_56@@QAE@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitInterval::clear(icu_56::DigitInterval *__hidden this)
		public ?clear@DigitInterval@icu_56@@QAEXXZ
?clear@DigitInterval@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 7FFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 80000000h
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@DigitInterval@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitInterval::equals(icu_56::DigitInterval *this, const struct icu_56::DigitInterval *)
		public ?equals@DigitInterval@icu_56@@QBECABV12@@Z
?equals@DigitInterval@icu_56@@QBECABV12@@Z proc	near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jnz	short loc_1E52
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_1E52
		mov	[ebp+var_CD], 1
		jmp	short loc_1E59
; ---------------------------------------------------------------------------

loc_1E52:				; CODE XREF: icu_56::DigitInterval::equals(icu_56::DigitInterval const &)+2Dj
					; icu_56::DigitInterval::equals(icu_56::DigitInterval const &)+3Bj
		mov	[ebp+var_CD], 0

loc_1E59:				; CODE XREF: icu_56::DigitInterval::equals(icu_56::DigitInterval const &)+44j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@DigitInterval@icu_56@@QBECABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitInterval::setLeastSignificantInclusive(icu_56::DigitInterval *this, int)
		public ?setLeastSignificantInclusive@DigitInterval@icu_56@@QAEXH@Z
?setLeastSignificantInclusive@DigitInterval@icu_56@@QAEXH@Z proc near
					; CODE XREF: icu_56::DigitList::getSmallestInterval(icu_56::DigitInterval &)+30p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	eax, eax
		cmp	[ebp+arg_0], 0
		setnl	al
		sub	eax, 1
		and	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setLeastSignificantInclusive@DigitInterval@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitInterval::setMostSignificantExclusive(icu_56::DigitInterval *this, int)
		public ?setMostSignificantExclusive@DigitInterval@icu_56@@QAEXH@Z
?setMostSignificantExclusive@DigitInterval@icu_56@@QAEXH@Z proc	near
					; CODE XREF: icu_56::DigitList::getSmallestInterval(icu_56::DigitInterval &)+41p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	eax, eax
		cmp	[ebp+arg_0], 0
		setle	al
		sub	eax, 1
		and	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setMostSignificantExclusive@DigitInterval@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getMostSignificantExclusive(icu_56::DigitInterval *__hidden this)
		public ?getMostSignificantExclusive@DigitInterval@icu_56@@QBEHXZ
?getMostSignificantExclusive@DigitInterval@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getMostSignificantExclusive@DigitInterval@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getIntDigitCount(icu_56::DigitInterval *__hidden this)
		public ?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ
?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getFracDigitCount(icu_56::DigitInterval	*__hidden this)
		public ?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ
?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ	proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 80000000h
		jnz	short loc_1F87
		mov	[ebp+var_D0], 7FFFFFFFh
		jmp	short loc_1F95
; ---------------------------------------------------------------------------

loc_1F87:				; CODE XREF: icu_56::DigitInterval::getFracDigitCount(void)+2Dj
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		neg	edx
		mov	[ebp+var_D0], edx

loc_1F95:				; CODE XREF: icu_56::DigitInterval::getFracDigitCount(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::length(icu_56::DigitInterval *__hidden this)
		public ?length@DigitInterval@icu_56@@QBEHXZ
?length@DigitInterval@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	eax, [eax]
		sub	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@DigitInterval@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getLeastSignificantInclusive(icu_56::DigitInterval *__hidden this)
		public ?getLeastSignificantInclusive@DigitInterval@icu_56@@QBEHXZ
?getLeastSignificantInclusive@DigitInterval@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx

loc_1FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLeastSignificantInclusive@DigitInterval@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 200Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitInterval &	__thiscall icu_56::DigitInterval::operator=(class icu_56::DigitInterval	const &)
		public ??4DigitInterval@icu_56@@QAEAAV01@ABV01@@Z
??4DigitInterval@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4DigitInterval@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 204Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitList::DigitList(icu_56::DigitList *__hidden this)
		public ??0DigitList@icu_56@@QAE@XZ
??0DigitList@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::DigitList::getLong(void)+89p
					; icu_56::DigitList::fitsIntoLong(signed char)+E7p ...

var_F0		= qword	ptr -0F0h
var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0DigitList@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		add	ecx, 20h ; ' '
		call	??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::MaybeStackHeaderAndArray<decNumber,char,40>(void)
		mov	[ebp+var_4], 0
		push	0
		mov	eax, [ebp+var_14]
		push	eax
		call	_uprv_decContextDefault_56
		add	esp, 8
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		push	3
		mov	eax, [ebp+var_14]
		push	eax
		call	_uprv_decContextSetRounding_56
		add	esp, 8
		mov	ecx, [ebp+var_14]
		add	ecx, 20h ; ' '
		call	?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getCapacity(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx], eax
		mov	ecx, [ebp+var_14]
		add	ecx, 20h ; ' '
		call	?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getAlias(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx+1Ch], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberZero_56
		add	esp, 4
		sub	esp, 8
		fldz
		fstp	[esp+0F0h+var_F0] ; double
		mov	ecx, [ebp+var_14] ; this
		call	?internalSetDouble@DigitList@icu_56@@AAEXN@Z ; icu_56::DigitList::internalSetDouble(double)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0DigitList@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2130h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitList@icu_56@@QAE@XZ$0 proc near	; DATA XREF: .xdata$x:00002160o
		mov	ecx, [ebp-14h]
		add	ecx, 20h ; ' '
		jmp	??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::~MaybeStackHeaderAndArray<decNumber,char,40>(void)
__unwindfunclet$??0DigitList@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0DigitList@icu_56@@QAE@XZ	proc near
					; DATA XREF: icu_56::DigitList::DigitList(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0DigitList@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0DigitList@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 215Ch
__unwindtable$??0DigitList@icu_56@@QAE@XZ dd 0FFFFFFFFh	; DATA XREF: .xdata$x:0000216Co
		dd offset __unwindfunclet$??0DigitList@icu_56@@QAE@XZ$0
__ehfuncinfo$??0DigitList@icu_56@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??0DigitList@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0DigitList@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2188h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitList::~DigitList(icu_56::DigitList *__hidden this)
		public ??1DigitList@icu_56@@QAE@XZ
??1DigitList@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::DigitList::getDouble(void)+22Bp
					; __unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$2+6j ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 20h ; ' '
		call	??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::~MaybeStackHeaderAndArray<decNumber,char,40>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1DigitList@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitList::DigitList(icu_56::DigitList *this, const	struct icu_56::DigitList *)
		public ??0DigitList@icu_56@@QAE@ABV01@@Z
??0DigitList@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::DigitList::getDouble(void)+1E5p
					; icu_56::DigitList::getLong(void)+77p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
Src		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0DigitList@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		add	ecx, 20h ; ' '
		call	??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::MaybeStackHeaderAndArray<decNumber,char,40>(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 20h ; ' '
		call	?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getAlias(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx+1Ch], eax
		mov	eax, [ebp+Src]
		push	eax		; Src
		mov	ecx, [ebp+var_14]
		call	??4DigitList@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::DigitList::operator=(icu_56::DigitList	const &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0DigitList@icu_56@@QAE@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2268h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitList@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00002298o
		mov	ecx, [ebp-14h]
		add	ecx, 20h ; ' '
		jmp	??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::~MaybeStackHeaderAndArray<decNumber,char,40>(void)
__unwindfunclet$??0DigitList@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0DigitList@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::DigitList::DigitList(icu_56::DigitList const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0DigitList@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0DigitList@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2294h
__unwindtable$??0DigitList@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000022A4o
		dd offset __unwindfunclet$??0DigitList@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DigitList@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0DigitList@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0DigitList@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::DigitList::operator=(void *Src)
		public ??4DigitList@icu_56@@QAEAAV01@ABV01@@Z
??4DigitList@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::DigitList::DigitList(icu_56::DigitList const &)+6Cp

var_D8		= byte ptr -0D8h
var_14		= byte ptr -14h
Dst		= dword	ptr -8
Src		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+Dst], ecx
		mov	eax, [ebp+Dst]
		cmp	eax, [ebp+Src]
		jz	loc_23D4
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	1Ch		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	ecx, [ebp+Src]
		add	ecx, 20h ; ' '
		call	?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getCapacity(void)
		mov	esi, eax
		mov	ecx, [ebp+Dst]
		add	ecx, 20h ; ' '
		call	?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getCapacity(void)
		cmp	esi, eax
		jle	short loc_234A
		push	0
		mov	ecx, [ebp+Src]
		add	ecx, 20h ; ' '
		call	?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getCapacity(void)
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, 20h ; ' '
		call	?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)
		mov	ecx, [ebp+Dst]
		mov	[ecx+1Ch], eax

loc_234A:				; CODE XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+69j
		mov	ecx, [ebp+Dst]
		add	ecx, 20h ; ' '
		call	?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getCapacity(void)
		mov	ecx, [ebp+Dst]
		mov	[ecx], eax
		mov	eax, [ebp+Src]
		mov	ecx, [eax+1Ch]
		push	ecx
		mov	edx, [ebp+Dst]
		mov	eax, [edx+1Ch]
		push	eax
		call	_uprv_decNumberCopy_56
		add	esp, 8
		mov	esi, esp
		push	0		; struct UMutex	*
		lea	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0Mutex@icu_56@@QAE@PAUUMutex@@@Z ;	icu_56::Mutex::Mutex(UMutex *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+68h], 1
		jnz	short loc_239B
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		fld	qword ptr [ecx+60h]
		fstp	qword ptr [eax+60h]
		jmp	short loc_23B6
; ---------------------------------------------------------------------------

loc_239B:				; CODE XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+CBj
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+68h], 2
		jnz	short loc_23B6
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+60h]
		mov	[eax+60h], edx
		mov	ecx, [ecx+64h]
		mov	[eax+64h], ecx

loc_23B6:				; CODE XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+D9j
					; icu_56::DigitList::operator=(icu_56::DigitList const &)+E2j
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+68h]
		mov	[eax+68h], edx
		mov	esi, esp
		lea	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1Mutex@icu_56@@QAE@XZ ; icu_56::Mutex::~Mutex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_23D4:				; CODE XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+29j
		mov	eax, [ebp+Dst]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4DigitList@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN11		dd 1			; DATA XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+11Bo
		dd offset $LN10
$LN10		dd 0FFFFFFECh, 4	; DATA XREF: .text:00002404o
		dd offset $LN9		; "mutex"
$LN9		db 'mutex',0            ; DATA XREF: .text:00002410o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 241Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::DigitList::operator==(class icu_56::DigitList const &)const
		public ??8DigitList@icu_56@@QBECABV01@@Z
??8DigitList@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::DigitList::operator!=(icu_56::DigitList const &)+2Ap

var_118		= byte ptr -118h
var_115		= byte ptr -115h
var_4D		= byte ptr -4Dh
var_44		= dword	ptr -44h
var_34		= dword	ptr -34h
var_20		= dword	ptr -20h
var_18		= byte ptr -18h
var_17		= byte ptr -17h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		mov	eax, [ebp+var_C]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_2455
		mov	al, 1
		jmp	short loc_24C2
; ---------------------------------------------------------------------------

loc_2455:				; CODE XREF: icu_56::DigitList::operator==(icu_56::DigitList const &)+33j
		push	0
		lea	eax, [ebp+var_44]
		push	eax
		call	_uprv_decContextDefault_56
		add	esp, 8
		mov	[ebp+var_44], 1
		mov	[ebp+var_34], 0
		lea	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1Ch]
		push	edx
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+1Ch]
		push	ecx
		lea	edx, [ebp+var_20]
		push	edx
		call	_uprv_decNumberCompare_56
		add	esp, 10h
		movzx	eax, [ebp+var_17]
		test	eax, eax
		jnz	short loc_24AF
		cmp	[ebp+var_20], 1
		jnz	short loc_24AF
		movzx	ecx, [ebp+var_18]
		and	ecx, 70h
		jnz	short loc_24AF
		mov	[ebp+var_115], 1
		jmp	short loc_24B6
; ---------------------------------------------------------------------------

loc_24AF:				; CODE XREF: icu_56::DigitList::operator==(icu_56::DigitList const &)+79j
					; icu_56::DigitList::operator==(icu_56::DigitList const	&)+7Fj	...
		mov	[ebp+var_115], 0

loc_24B6:				; CODE XREF: icu_56::DigitList::operator==(icu_56::DigitList const &)+91j
		mov	dl, [ebp+var_115]
		mov	[ebp+var_4D], dl
		mov	al, [ebp+var_4D]

loc_24C2:				; CODE XREF: icu_56::DigitList::operator==(icu_56::DigitList const &)+37j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8DigitList@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN9_0		dd 2			; DATA XREF: icu_56::DigitList::operator==(icu_56::DigitList const &)+AAo
		dd offset $LN8
$LN8		dd 0FFFFFFE0h, 0Ch	; DATA XREF: .text:000024F8o
		dd offset $LN6
		dd 0FFFFFFBCh, 1Ch
		dd offset $LN7
$LN7		db 63h,	0		; DATA XREF: .text:00002510o
$LN6		dw 6Eh			; DATA XREF: .text:00002504o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2518h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::compare(icu_56::DigitList *this, const struct icu_56::DigitList *)
		public ?compare@DigitList@icu_56@@QAEHABV12@@Z
?compare@DigitList@icu_56@@QAEHABV12@@Z	proc near
					; CODE XREF: icu_56::DigitList::fitsIntoLong(signed char)+12Fp
					; icu_56::DigitList::fitsIntoLong(signed char)+1A7p ...

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_18		= byte ptr -18h
var_17		= byte ptr -17h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		mov	eax, [ebp+var_C]
		mov	ecx, [eax]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_C]
		mov	dword ptr [eax], 1
		mov	eax, [ebp+var_C]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1Ch]
		push	edx
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+1Ch]
		push	ecx
		lea	edx, [ebp+var_20]
		push	edx
		call	_uprv_decNumberCompare_56
		add	esp, 10h
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_2C]
		mov	[eax], ecx
		movzx	eax, [ebp+var_17]
		test	eax, eax
		jnz	short loc_2599
		cmp	[ebp+var_20], 1
		jnz	short loc_2599
		movzx	eax, [ebp+var_18]
		and	eax, 70h
		jnz	short loc_2599
		xor	eax, eax
		jmp	short loc_25C2
; ---------------------------------------------------------------------------
		jmp	short loc_25C2
; ---------------------------------------------------------------------------

loc_2599:				; CODE XREF: icu_56::DigitList::compare(icu_56::DigitList const	&)+6Aj
					; icu_56::DigitList::compare(icu_56::DigitList const &)+70j ...
		movzx	eax, [ebp+var_18]
		and	eax, 70h
		jz	short loc_25AB
		mov	eax, 0FFFFFFFEh
		jmp	short loc_25C2
; ---------------------------------------------------------------------------
		jmp	short loc_25C2
; ---------------------------------------------------------------------------

loc_25AB:				; CODE XREF: icu_56::DigitList::compare(icu_56::DigitList const	&)+88j
		movzx	eax, [ebp+var_18]
		and	eax, 80h
		jz	short loc_25BD
		or	eax, 0FFFFFFFFh
		jmp	short loc_25C2
; ---------------------------------------------------------------------------
		jmp	short loc_25C2
; ---------------------------------------------------------------------------

loc_25BD:				; CODE XREF: icu_56::DigitList::compare(icu_56::DigitList const	&)+9Cj
		mov	eax, 1

loc_25C2:				; CODE XREF: icu_56::DigitList::compare(icu_56::DigitList const	&)+7Dj
					; icu_56::DigitList::compare(icu_56::DigitList const &)+7Fj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compare@DigitList@icu_56@@QAEHABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN11_0		dd 1			; DATA XREF: icu_56::DigitList::compare(icu_56::DigitList const	&)+AEo
		dd offset $LN10_0
$LN10_0		dd 0FFFFFFE0h, 0Ch	; DATA XREF: .text:000025F8o
		dd offset $LN9_1	; "result"
$LN9_1		db 'result',0           ; DATA XREF: .text:00002604o
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2610h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::reduce(icu_56::DigitList *__hidden	this)
		public ?reduce@DigitList@icu_56@@QAEXXZ
?reduce@DigitList@icu_56@@QAEXXZ proc near
					; CODE XREF: icu_56::DigitList::getDouble(void)+1F4p
					; icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)+6Bp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberReduce_56
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?reduce@DigitList@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2664h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::trim(icu_56::DigitList *__hidden this)
		public ?trim@DigitList@icu_56@@QAEXXZ
?trim@DigitList@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberTrim_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?trim@DigitList@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::clear(icu_56::DigitList *__hidden this)
		public ?clear@DigitList@icu_56@@QAEXXZ
?clear@DigitList@icu_56@@QAEXXZ	proc near

var_E0		= qword	ptr -0E0h
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberZero_56
		add	esp, 4
		push	3
		mov	eax, [ebp+var_8]
		push	eax
		call	_uprv_decContextSetRounding_56
		add	esp, 8
		sub	esp, 8
		fldz
		fstp	[esp+0E0h+var_E0] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?internalSetDouble@DigitList@icu_56@@AAEXN@Z ; icu_56::DigitList::internalSetDouble(double)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clear@DigitList@icu_56@@QAEXXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2710h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::DigitList::setRoundingMode(enum  icu_56::DecimalFormat::ERoundingMode)
		public ?setRoundingMode@DigitList@icu_56@@QAEXW4ERoundingMode@DecimalFormat@2@@Z
?setRoundingMode@DigitList@icu_56@@QAEXW4ERoundingMode@DecimalFormat@2@@Z proc near

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_DC], eax
		cmp	[ebp+var_DC], 7	; switch 8 cases
		ja	short loc_279A	; jumptable 0000274B default case
		mov	ecx, [ebp+var_DC]
		jmp	ds:$LN14[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN9_2:					; CODE XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+3Bj
					; DATA XREF: .text:$LN14o
		mov	[ebp+var_14], 0	; jumptable 0000274B case 0
		jmp	short loc_27A9
; ---------------------------------------------------------------------------

$LN8_0:					; CODE XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+3Bj
					; DATA XREF: .text:$LN14o
		mov	[ebp+var_14], 6	; jumptable 0000274B case 1
		jmp	short loc_27A9
; ---------------------------------------------------------------------------

$LN7_0:					; CODE XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+3Bj
					; DATA XREF: .text:$LN14o
		mov	[ebp+var_14], 5	; jumptable 0000274B case 2
		jmp	short loc_27A9
; ---------------------------------------------------------------------------

$LN6_0:					; CODE XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+3Bj
					; DATA XREF: .text:$LN14o
		mov	[ebp+var_14], 1	; jumptable 0000274B case 3
		jmp	short loc_27A9
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+3Bj
					; DATA XREF: .text:$LN14o
		mov	[ebp+var_14], 3	; jumptable 0000274B case 4
		jmp	short loc_27A9
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+3Bj
					; DATA XREF: .text:$LN14o
		mov	[ebp+var_14], 4	; jumptable 0000274B case 5
		jmp	short loc_27A9
; ---------------------------------------------------------------------------

$LN3:					; CODE XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+3Bj
					; DATA XREF: .text:$LN14o
		mov	[ebp+var_14], 2	; jumptable 0000274B case 6
		jmp	short loc_27A9
; ---------------------------------------------------------------------------

$LN2:					; CODE XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+3Bj
					; DATA XREF: .text:$LN14o
		mov	[ebp+var_14], 3	; jumptable 0000274B case 7
		jmp	short loc_27A9
; ---------------------------------------------------------------------------

loc_279A:				; CODE XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+33j
		mov	eax, [ebp+var_8] ; jumptable 0000274B default case
		push	eax
		call	_uprv_decContextGetRounding_56
		add	esp, 4
		mov	[ebp+var_14], eax

loc_27A9:				; CODE XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+49j
					; icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+52j	...
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	_uprv_decContextSetRounding_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setRoundingMode@DigitList@icu_56@@QAEXW4ERoundingMode@DecimalFormat@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN14		dd offset $LN9_2	; DATA XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+3Br
		dd offset $LN8_0	; jump table for switch	statement
		dd offset $LN7_0
		dd offset $LN6_0
		dd offset $LN5
		dd offset $LN4
		dd offset $LN3
		dd offset $LN2
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::setPositive(icu_56::DigitList *this, signed __int8)
		public ?setPositive@DigitList@icu_56@@QAEXC@Z
?setPositive@DigitList@icu_56@@QAEXC@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		movsx	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_2836
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 0FFFFFF7Fh
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	[ecx+8], dl
		jmp	short loc_284F
; ---------------------------------------------------------------------------

loc_2836:				; CODE XREF: icu_56::DigitList::setPositive(signed char)+29j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		or	edx, 80h
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	[ecx+8], dl

loc_284F:				; CODE XREF: icu_56::DigitList::setPositive(signed char)+44j
		mov	ecx, [ebp+var_8] ; this
		call	?internalClear@DigitList@icu_56@@AAEXXZ	; icu_56::DigitList::internalClear(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setPositive@DigitList@icu_56@@QAEXC@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2870h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::setDecimalAt(icu_56::DigitList *this, int)
		public ?setDecimalAt@DigitList@icu_56@@QAEXH@Z
?setDecimalAt@DigitList@icu_56@@QAEXH@Z	proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 70h
		jz	short loc_28C7
		mov	eax, ds:?__LINE__Var@?1??setDecimalAt@DigitList@icu_56@@QAEXH@Z@4JA ; long `icu_56::DigitList::setDecimalAt(int)'::`2'::__LINE__Var
		add	eax, 1
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1FG@EKJHPOJE@?$AA?$CI?$AAf?$AAD?$AAe?$AAc?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA0?$AAx?$AA4?$AA0?$AA?$HM?$AA0?$AAx?$AA2?$AA0?$AA?$HM?$AA0@ ; "(fDecNumber->bits &	(0x40|0x20|0x10)) ="...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_28C7:				; CODE XREF: icu_56::DigitList::setDecimalAt(int)+30j
		mov	eax, [ebp+arg_0]
		sub	eax, 1
		cmp	eax, 0C4653601h
		jg	short loc_28FA
		mov	ecx, ds:?__LINE__Var@?1??setDecimalAt@DigitList@icu_56@@QAEXH@Z@4JA ; long `icu_56::DigitList::setDecimalAt(int)'::`2'::__LINE__Var
		add	ecx, 2
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1BO@BJGAHGFL@?$AAd?$AA?9?$AA1?$AA?$DO?$AA?9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA?$AA@ ; "d-1>-999999999"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_28FA:				; CODE XREF: icu_56::DigitList::setDecimalAt(int)+62j
		mov	eax, [ebp+arg_0]
		sub	eax, 1
		cmp	eax, 3B9AC9FFh
		jl	short loc_292D
		mov	ecx, ds:?__LINE__Var@?1??setDecimalAt@DigitList@icu_56@@QAEXH@Z@4JA ; long `icu_56::DigitList::setDecimalAt(int)'::`2'::__LINE__Var
		add	ecx, 3
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1BO@DCJBGLJE@?$AAd?$AA?9?$AA1?$AA?$DM?$AA?5?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA?$AA@ ; "d-1< 999999999"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_292D:				; CODE XREF: icu_56::DigitList::setDecimalAt(int)+95j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+9]
		test	edx, edx
		jnz	short loc_2967
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		cmp	dword ptr [ecx], 1
		jnz	short loc_2967
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 70h
		jnz	short loc_2967
		mov	[ebp+var_14], 0

loc_2967:				; CODE XREF: icu_56::DigitList::setDecimalAt(int)+D4j
					; icu_56::DigitList::setDecimalAt(int)+DFj ...
		mov	eax, [ebp+arg_0]
		sub	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		mov	[edx+4], eax
		mov	ecx, [ebp+var_8] ; this
		call	?internalClear@DigitList@icu_56@@AAEXXZ	; icu_56::DigitList::internalClear(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setDecimalAt@DigitList@icu_56@@QAEXH@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2994h
		public ??_C@_1BO@DCJBGLJE@?$AAd?$AA?9?$AA1?$AA?$DM?$AA?5?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA?$AA@
; wchar_t `string'
??_C@_1BO@DCJBGLJE@?$AAd?$AA?9?$AA1?$AA?$DM?$AA?5?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA?$AA@:
					; DATA XREF: icu_56::DigitList::setDecimalAt(int)+A8o
		unicode	0, <d-1>
		dw 3Ch
		unicode	0, < 999999999>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 29B4h
		public ??_C@_1BO@BJGAHGFL@?$AAd?$AA?9?$AA1?$AA?$DO?$AA?9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA?$AA@
; wchar_t `string'
??_C@_1BO@BJGAHGFL@?$AAd?$AA?9?$AA1?$AA?$DO?$AA?9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA9?$AA?$AA@:
					; DATA XREF: icu_56::DigitList::setDecimalAt(int)+75o
		unicode	0, <d-1>
		dw 3Eh
		unicode	0, <-999999999>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 29D4h
		public ??_C@_1FG@EKJHPOJE@?$AA?$CI?$AAf?$AAD?$AAe?$AAc?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA0?$AAx?$AA4?$AA0?$AA?$HM?$AA0?$AAx?$AA2?$AA0?$AA?$HM?$AA0@
; wchar_t `string'
??_C@_1FG@EKJHPOJE@?$AA?$CI?$AAf?$AAD?$AAe?$AAc?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA0?$AAx?$AA4?$AA0?$AA?$HM?$AA0?$AAx?$AA2?$AA0?$AA?$HM?$AA0@:
					; DATA XREF: icu_56::DigitList::setDecimalAt(int)+42o
					; icu_56::DigitList::getDecimalAt(void)+42o
		unicode	0, <(fDecNumber->
		dw 3Eh
		unicode	0, <bits & (0x40|0x20|0x10)) ==	0>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2A2Ch
		public ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@
; wchar_t `string'
??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@:
					; DATA XREF: icu_56::DigitList::setDecimalAt(int)+3Do
					; icu_56::DigitList::setDecimalAt(int)+70o ...
		unicode	0, <d:\mozilla\intl\icu\source\i18n\digitlst.cpp>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2A88h
		public ?__LINE__Var@?1??setDecimalAt@DigitList@icu_56@@QAEXH@Z@4JA
; long `public:	void __thiscall	icu_56::DigitList::setDecimalAt(int)'::`2'::__LINE__Var
?__LINE__Var@?1??setDecimalAt@DigitList@icu_56@@QAEXH@Z@4JA dd 122h
					; DATA XREF: icu_56::DigitList::setDecimalAt(int)+32r
					; icu_56::DigitList::setDecimalAt(int)+64r ...
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::getDecimalAt(icu_56::DigitList *__hidden this)
		public ?getDecimalAt@DigitList@icu_56@@QAEHXZ
?getDecimalAt@DigitList@icu_56@@QAEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 70h
		jz	short loc_2AE3
		mov	eax, ds:?__LINE__Var@?1??getDecimalAt@DigitList@icu_56@@QAEHXZ@4JA ; long `icu_56::DigitList::getDecimalAt(void)'::`2'::__LINE__Var
		add	eax, 1
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1FG@EKJHPOJE@?$AA?$CI?$AAf?$AAD?$AAe?$AAc?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA0?$AAx?$AA4?$AA0?$AA?$HM?$AA0?$AAx?$AA2?$AA0?$AA?$HM?$AA0@ ; "(fDecNumber->bits &	(0x40|0x20|0x10)) ="...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2AE3:				; CODE XREF: icu_56::DigitList::getDecimalAt(void)+30j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+9]
		test	edx, edx
		jnz	short loc_2B0B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		cmp	dword ptr [ecx], 1
		jnz	short loc_2B0B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 70h
		jz	short loc_2B1A

loc_2B0B:				; CODE XREF: icu_56::DigitList::getDecimalAt(void)+63j
					; icu_56::DigitList::getDecimalAt(void)+6Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 70h
		jz	short loc_2B25

loc_2B1A:				; CODE XREF: icu_56::DigitList::getDecimalAt(void)+7Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	eax, [ecx+4]
		jmp	short loc_2B38
; ---------------------------------------------------------------------------

loc_2B25:				; CODE XREF: icu_56::DigitList::getDecimalAt(void)+8Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		mov	ecx, [ecx+4]
		add	ecx, [eax]
		mov	eax, ecx

loc_2B38:				; CODE XREF: icu_56::DigitList::getDecimalAt(void)+97j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDecimalAt@DigitList@icu_56@@QAEHXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2B4Ch
		public ?__LINE__Var@?1??getDecimalAt@DigitList@icu_56@@QAEHXZ@4JA
; long `public:	int __thiscall icu_56::DigitList::getDecimalAt(void)'::`2'::__LINE__Var
?__LINE__Var@?1??getDecimalAt@DigitList@icu_56@@QAEHXZ@4JA dd 130h
					; DATA XREF: icu_56::DigitList::getDecimalAt(void)+32r
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::setCount(icu_56::DigitList	*this, int)
		public ?setCount@DigitList@icu_56@@QAEXH@Z
?setCount@DigitList@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax]
		jle	short loc_2BA3
		mov	edx, ds:?__LINE__Var@?1??setCount@DigitList@icu_56@@QAEXH@Z@4JA	; long `icu_56::DigitList::setCount(int)'::`2'::__LINE__Var
		add	edx, 1
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1CK@IAJJLIHK@?$AAc?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAf?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?4?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@ ; "c <= fContext.digits"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2BA3:				; CODE XREF: icu_56::DigitList::setCount(int)+2Bj
		cmp	[ebp+arg_0], 0
		jnz	short loc_2BBA
		mov	[ebp+arg_0], 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	byte ptr [ecx+9], 0

loc_2BBA:				; CODE XREF: icu_56::DigitList::setCount(int)+57j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+arg_0]
		mov	[ecx], edx
		mov	ecx, [ebp+var_8] ; this
		call	?internalClear@DigitList@icu_56@@AAEXXZ	; icu_56::DigitList::internalClear(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setCount@DigitList@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2BE4h
		public ??_C@_1CK@IAJJLIHK@?$AAc?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAf?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?4?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@
; wchar_t `string'
??_C@_1CK@IAJJLIHK@?$AAc?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAf?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?4?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@:
					; DATA XREF: icu_56::DigitList::setCount(int)+3Eo
		unicode	0, <c >
		dw 3Ch
		unicode	0, <= fContext.digits>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2C10h
		public ?__LINE__Var@?1??setCount@DigitList@icu_56@@QAEXH@Z@4JA
; long `public:	void __thiscall	icu_56::DigitList::setCount(int)'::`2'::__LINE__Var
?__LINE__Var@?1??setCount@DigitList@icu_56@@QAEXH@Z@4JA	dd offset __RTC_InitBase_rtc$IMZ+1
					; DATA XREF: icu_56::DigitList::setCount(int)+2Dr
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::getCount(icu_56::DigitList *__hidden this)
		public ?getCount@DigitList@icu_56@@QBEHXZ
?getCount@DigitList@icu_56@@QBEHXZ proc	near
					; CODE XREF: icu_56::DigitList::getDouble(void)+1D1p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+9]
		test	edx, edx
		jnz	short loc_2C71
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		cmp	dword ptr [ecx], 1
		jnz	short loc_2C71
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 70h
		jnz	short loc_2C71
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		cmp	dword ptr [ecx+4], 0
		jnz	short loc_2C71
		xor	eax, eax
		jmp	short loc_2C79
; ---------------------------------------------------------------------------
		jmp	short loc_2C79
; ---------------------------------------------------------------------------

loc_2C71:				; CODE XREF: icu_56::DigitList::getCount(void)+2Fj
					; icu_56::DigitList::getCount(void)+3Aj ...
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	eax, [ecx]

loc_2C79:				; CODE XREF: icu_56::DigitList::getCount(void)+59j
					; icu_56::DigitList::getCount(void)+5Bj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCount@DigitList@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::setDigit(icu_56::DigitList	*this, int, char)
		public ?setDigit@DigitList@icu_56@@QAEXHD@Z
?setDigit@DigitList@icu_56@@QAEXHD@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_14]
		jl	short loc_2CDC
		mov	ecx, ds:?__LINE__Var@?1??setDigit@DigitList@icu_56@@QAEXHD@Z@4JA ; long	`icu_56::DigitList::setDigit(int,char)'::`2'::__LINE__Var
		add	ecx, 2
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1BA@DLGOMFHK@?$AAi?$AA?$DM?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@ ; "i<count"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2CDC:				; CODE XREF: icu_56::DigitList::setDigit(int,char)+34j
		movsx	eax, [ebp+arg_4]
		cmp	eax, 30h ; '0'
		jl	short loc_2CEE
		movsx	ecx, [ebp+arg_4]
		cmp	ecx, 39h ; '9'
		jle	short loc_2D14

loc_2CEE:				; CODE XREF: icu_56::DigitList::setDigit(int,char)+63j
		mov	edx, ds:?__LINE__Var@?1??setDigit@DigitList@icu_56@@QAEXHD@Z@4JA ; long	`icu_56::DigitList::setDigit(int,char)'::`2'::__LINE__Var
		add	edx, 3
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1CC@INIKOOMG@?$AAv?$AA?$DO?$AA?$DN?$AA?8?$AA0?$AA?8?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv?$AA?$DM?$AA?$DN?$AA?8?$AA9?$AA?8?$AA?$AA@ ; "v>='0' && v<='9'"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2D14:				; CODE XREF: icu_56::DigitList::setDigit(int,char)+6Cj
		movsx	eax, [ebp+arg_4]
		and	eax, 0Fh
		mov	[ebp+arg_4], al
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+var_14]
		sub	edx, [ebp+arg_0]
		mov	al, [ebp+arg_4]
		mov	[ecx+edx+8], al
		mov	ecx, [ebp+var_8] ; this
		call	?internalClear@DigitList@icu_56@@AAEXXZ	; icu_56::DigitList::internalClear(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setDigit@DigitList@icu_56@@QAEXHD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2D50h
		public ??_C@_1CC@INIKOOMG@?$AAv?$AA?$DO?$AA?$DN?$AA?8?$AA0?$AA?8?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv?$AA?$DM?$AA?$DN?$AA?8?$AA9?$AA?8?$AA?$AA@
; wchar_t `string'
??_C@_1CC@INIKOOMG@?$AAv?$AA?$DO?$AA?$DN?$AA?8?$AA0?$AA?8?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv?$AA?$DM?$AA?$DN?$AA?8?$AA9?$AA?8?$AA?$AA@:
					; DATA XREF: icu_56::DigitList::setDigit(int,char)+7Fo
		unicode	0, <v>
		dw 3Eh
		unicode	0, <=>
		dw 27h
		unicode	0, <0>
		dw 27h
		unicode	0, < &&	v>
		dw 3Ch
		unicode	0, <=>
		dw 27h
		unicode	0, <9>
		dw 27h,	0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2D74h
		public ??_C@_1BA@DLGOMFHK@?$AAi?$AA?$DM?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@
; wchar_t `string'
??_C@_1BA@DLGOMFHK@?$AAi?$AA?$DM?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@:
					; DATA XREF: icu_56::DigitList::setDigit(int,char)+47o
					; icu_56::DigitList::getDigit(int)+47o	...
		unicode	0, <i>
		dw 3Ch
		unicode	0, <count>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2D84h
		public ?__LINE__Var@?1??setDigit@DigitList@icu_56@@QAEXHD@Z@4JA
; long `public:	void __thiscall	icu_56::DigitList::setDigit(int, char)'::`2'::__LINE__Var
?__LINE__Var@?1??setDigit@DigitList@icu_56@@QAEXHD@Z@4JA dd 151h
					; DATA XREF: icu_56::DigitList::setDigit(int,char)+36r
					; icu_56::DigitList::setDigit(int,char):loc_2CEEr
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char __thiscall icu_56::DigitList::getDigit(icu_56::DigitList	*this, int)
		public ?getDigit@DigitList@icu_56@@QAEDH@Z
?getDigit@DigitList@icu_56@@QAEDH@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_14]
		jl	short loc_2DE4
		mov	ecx, ds:?__LINE__Var@?1??getDigit@DigitList@icu_56@@QAEDH@Z@4JA	; long `icu_56::DigitList::getDigit(int)'::`2'::__LINE__Var
		add	ecx, 2
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1BA@DLGOMFHK@?$AAi?$AA?$DM?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@ ; "i<count"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2DE4:				; CODE XREF: icu_56::DigitList::getDigit(int)+34j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+var_14]
		sub	edx, [ebp+arg_0]
		movzx	eax, byte ptr [ecx+edx+8]
		add	eax, 30h ; '0'
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getDigit@DigitList@icu_56@@QAEDH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2E10h
		public ?__LINE__Var@?1??getDigit@DigitList@icu_56@@QAEDH@Z@4JA
; long `public:	char __thiscall	icu_56::DigitList::getDigit(int)'::`2'::__LINE__Var
?__LINE__Var@?1??getDigit@DigitList@icu_56@@QAEDH@Z@4JA	dd 15Bh
					; DATA XREF: icu_56::DigitList::getDigit(int)+36r
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int8 __thiscall icu_56::DigitList::getDigitValue(icu_56::DigitList	*this, int)
		public ?getDigitValue@DigitList@icu_56@@QAEEH@Z
?getDigitValue@DigitList@icu_56@@QAEEH@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_14]
		jl	short loc_2E70
		mov	ecx, ds:?__LINE__Var@?1??getDigitValue@DigitList@icu_56@@QAEEH@Z@4JA ; long `icu_56::DigitList::getDigitValue(int)'::`2'::__LINE__Var
		add	ecx, 2
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1BA@DLGOMFHK@?$AAi?$AA?$DM?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@ ; "i<count"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2E70:				; CODE XREF: icu_56::DigitList::getDigitValue(int)+34j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+var_14]
		sub	edx, [ebp+arg_0]
		mov	al, [ecx+edx+8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getDigitValue@DigitList@icu_56@@QAEEH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2E98h
		public ?__LINE__Var@?1??getDigitValue@DigitList@icu_56@@QAEEH@Z@4JA
; long `public:	unsigned char __thiscall icu_56::DigitList::getDigitValue(int)'::`2'::__LINE__Var
?__LINE__Var@?1??getDigitValue@DigitList@icu_56@@QAEEH@Z@4JA dd	163h
					; DATA XREF: icu_56::DigitList::getDigitValue(int)+36r
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::append(icu_56::DigitList *this, char)
		public ?append@DigitList@icu_56@@QAEXD@Z
?append@DigitList@icu_56@@QAEXD@Z proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		movsx	eax, [ebp+arg_0]
		cmp	eax, 30h ; '0'
		jl	short loc_2ED1
		movsx	ecx, [ebp+arg_0]
		cmp	ecx, 39h ; '9'
		jle	short loc_2EF7

loc_2ED1:				; CODE XREF: icu_56::DigitList::append(char)+2Aj
		mov	edx, ds:?__LINE__Var@?1??append@DigitList@icu_56@@QAEXD@Z@4JA ;	long `icu_56::DigitList::append(char)'::`2'::__LINE__Var
		add	edx, 1
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1DC@EOAAEPGI@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$DO?$AA?$DN?$AA?8?$AA0?$AA?8?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$DM?$AA?$DN?$AA?8?$AA9?$AA?8?$AA?$AA@ ; "digit>='0' && digit<='9'"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2EF7:				; CODE XREF: icu_56::DigitList::append(char)+33j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+9]
		test	edx, edx
		jnz	short loc_2F55
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		cmp	dword ptr [ecx], 1
		jnz	short loc_2F55
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 70h
		jnz	short loc_2F55
		movsx	eax, [ebp+arg_0]
		and	eax, 0Fh
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		mov	[edx+9], al
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	dword ptr [ecx], 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx+4]
		sub	edx, 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	[ecx+4], edx
		jmp	loc_2FD5
; ---------------------------------------------------------------------------

loc_2F55:				; CODE XREF: icu_56::DigitList::append(char)+67j
					; icu_56::DigitList::append(char)+72j ...
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax]
		jge	short loc_2FD5
		mov	eax, [ebp+var_14]
		mov	[ebp+var_20], eax
		jmp	short loc_2F7B
; ---------------------------------------------------------------------------

loc_2F72:				; CODE XREF: icu_56::DigitList::append(char)+FFj
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax

loc_2F7B:				; CODE XREF: icu_56::DigitList::append(char)+D4j
		cmp	[ebp+var_20], 0
		jle	short loc_2F9D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		mov	edx, [ebp+var_20]
		mov	esi, [ebp+var_20]
		mov	cl, [ecx+esi+8]
		mov	[eax+edx+9], cl
		jmp	short loc_2F72
; ---------------------------------------------------------------------------

loc_2F9D:				; CODE XREF: icu_56::DigitList::append(char)+E3j
		movsx	eax, [ebp+arg_0]
		and	eax, 0Fh
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		mov	[edx+9], al
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx]
		add	edx, 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	[ecx], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx+4]
		sub	edx, 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	[ecx+4], edx

loc_2FD5:				; CODE XREF: icu_56::DigitList::append(char)+B4j
					; icu_56::DigitList::append(char)+CCj
		mov	ecx, [ebp+var_8] ; this
		call	?internalClear@DigitList@icu_56@@AAEXXZ	; icu_56::DigitList::internalClear(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@DigitList@icu_56@@QAEXD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2FF4h
		public ??_C@_1DC@EOAAEPGI@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$DO?$AA?$DN?$AA?8?$AA0?$AA?8?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$DM?$AA?$DN?$AA?8?$AA9?$AA?8?$AA?$AA@
; wchar_t `string'
??_C@_1DC@EOAAEPGI@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$DO?$AA?$DN?$AA?8?$AA0?$AA?8?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$DM?$AA?$DN?$AA?8?$AA9?$AA?8?$AA?$AA@:
					; DATA XREF: icu_56::DigitList::append(char)+46o
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato ...
		unicode	0, <digit>
		dw 3Eh
		unicode	0, <=>
		dw 27h
		unicode	0, <0>
		dw 27h
		unicode	0, < &&	digit>
		dw 3Ch
		unicode	0, <=>
		dw 27h
		unicode	0, <9>
		dw 27h,	0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 3028h
		public ?__LINE__Var@?1??append@DigitList@icu_56@@QAEXD@Z@4JA
; long `public:	void __thiscall	icu_56::DigitList::append(char)'::`2'::__LINE__Var
?__LINE__Var@?1??append@DigitList@icu_56@@QAEXD@Z@4JA dd 173h
					; DATA XREF: icu_56::DigitList::append(char):loc_2ED1r
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 302Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char __cdecl icu_56::DigitList::getStrtodDecimalSeparator()
		public ?getStrtodDecimalSeparator@DigitList@icu_56@@SADXZ
?getStrtodDecimalSeparator@DigitList@icu_56@@SADXZ proc	near

var_10C		= qword	ptr -10Ch
var_F8		= byte ptr -0F8h
Dest		= byte ptr -34h
var_32		= byte ptr -32h
var_18		= byte ptr -18h
var_9		= byte ptr -9
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 0F8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F8]
		mov	ecx, 3Eh ; '>'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	esi, esp
		push	0		; struct UMutex	*
		lea	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??0Mutex@icu_56@@QAE@PAUUMutex@@@Z ;	icu_56::Mutex::Mutex(UMutex *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, ds:?gDecimal@?1??getStrtodDecimalSeparator@DigitList@icu_56@@SADXZ@4DA ; char `icu_56::DigitList::getStrtodDecimalSeparator(void)'::`2'::gDecimal
		mov	[ebp+var_9], al
		movsx	eax, [ebp+var_9]
		test	eax, eax
		jnz	short loc_30A9
		mov	esi, esp
		sub	esp, 8
		fld1
		fstp	[esp+10Ch+var_10C]
		push	offset ??_C@_06FINPMJPC@?$CF?$CL1?41f?$AA@ ; "%+1.1f"
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	dword ptr ds:__imp__sprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, [ebp+var_32]
		mov	[ebp+var_9], al
		mov	al, [ebp+var_9]
		mov	ds:?gDecimal@?1??getStrtodDecimalSeparator@DigitList@icu_56@@SADXZ@4DA,	al ; char `icu_56::DigitList::getStrtodDecimalSeparator(void)'::`2'::gDecimal

loc_30A9:				; CODE XREF: icu_56::DigitList::getStrtodDecimalSeparator(void)+4Aj
		mov	esi, esp
		lea	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??1Mutex@icu_56@@QAE@XZ ; icu_56::Mutex::~Mutex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, [ebp+var_9]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0F8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getStrtodDecimalSeparator@DigitList@icu_56@@SADXZ endp

; ---------------------------------------------------------------------------
		align 10h
$LN8_1		dd 2			; DATA XREF: icu_56::DigitList::getStrtodDecimalSeparator(void)+96o
		dd offset $LN7_1
$LN7_1		dd 0FFFFFFE8h, 4	; DATA XREF: .text:000030F4o
		dd offset $LN5_0	; "mutex"
		db 0CCh
		db 3 dup(0FFh)
		dd 13h
		dd offset $LN6_1
$LN6_1		dd 706572h		; DATA XREF: .text:0000310Co
$LN5_0		db 'mutex',0            ; DATA XREF: .text:00003100o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 311Ch
		public ??_C@_06FINPMJPC@?$CF?$CL1?41f?$AA@
; char `string'[]
??_C@_06FINPMJPC@?$CF?$CL1?41f?$AA@ db '%+1.1f',0
					; DATA XREF: icu_56::DigitList::getStrtodDecimalSeparator(void)+56o
					; icu_56::DigitList::getDouble(void)+107o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 3124h
		public __real@3ff0000000000000
__real@3ff0000000000000	dd 0
		dd 3FF00000h
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 312Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::DigitList::getDouble(icu_56::DigitList *__hidden this)
		public ?getDouble@DigitList@icu_56@@QBENXZ
?getDouble@DigitList@icu_56@@QBENXZ proc near

var_234		= qword	ptr -234h
var_21C		= byte ptr -21Ch
var_218		= qword	ptr -218h
var_208		= qword	ptr -208h
var_138		= dword	ptr -138h
var_12C		= byte ptr -12Ch
EndPtr		= dword	ptr -120h
var_114		= dword	ptr -114h
var_108		= byte ptr -108h
var_EC		= dword	ptr -0ECh
var_90		= byte ptr -90h
var_5C		= qword	ptr -5Ch
Dest		= byte ptr -4Ch
var_4A		= byte ptr -4Ah
var_30		= byte ptr -30h
var_21		= byte ptr -21h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getDouble@DigitList@icu_56@@QBENXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 210h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_21C]
		mov	ecx, 84h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	esi, esp
		push	0		; struct UMutex	*
		lea	ecx, [ebp+var_30] ; this
		call	dword ptr ds:__imp_??0Mutex@icu_56@@QAE@PAUUMutex@@@Z ;	icu_56::Mutex::Mutex(UMutex *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+68h], 1
		jnz	short loc_31C7
		mov	eax, [ebp+var_18]
		fld	qword ptr [eax+60h]
		fstp	[ebp+var_218]
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_30] ; this
		call	dword ptr ds:__imp_??1Mutex@icu_56@@QAE@XZ ; icu_56::Mutex::~Mutex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+var_218]
		jmp	loc_3498
; ---------------------------------------------------------------------------
		jmp	short loc_3200
; ---------------------------------------------------------------------------

loc_31C7:				; CODE XREF: icu_56::DigitList::getDouble(void)+67j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+68h], 2
		jnz	short loc_3200
		mov	eax, [ebp+var_18]
		fild	qword ptr [eax+60h]
		fstp	[ebp+var_208]
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_30] ; this
		call	dword ptr ds:__imp_??1Mutex@icu_56@@QAE@XZ ; icu_56::Mutex::~Mutex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+var_208]
		jmp	loc_3498
; ---------------------------------------------------------------------------

loc_3200:				; CODE XREF: icu_56::DigitList::getDouble(void)+99j
					; icu_56::DigitList::getDouble(void)+A2j
		mov	al, ds:?gDecimal@?1??getDouble@DigitList@icu_56@@QBENXZ@4DA ; char `icu_56::DigitList::getDouble(void)'::`2'::gDecimal
		mov	[ebp+var_21], al
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_30] ; this
		call	dword ptr ds:__imp_??1Mutex@icu_56@@QAE@XZ ; icu_56::Mutex::~Mutex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, [ebp+var_21]
		test	eax, eax
		jnz	short loc_3252
		mov	esi, esp
		sub	esp, 8
		fld1
		fstp	[esp+234h+var_234]
		push	offset ??_C@_06FINPMJPC@?$CF?$CL1?41f?$AA@ ; "%+1.1f"
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	dword ptr ds:__imp__sprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, [ebp+var_4A]
		mov	[ebp+var_21], al

loc_3252:				; CODE XREF: icu_56::DigitList::getDouble(void)+FBj
		fldz
		fstp	[ebp+var_5C]
		mov	ecx, [ebp+var_18] ; this
		call	?isZero@DigitList@icu_56@@QBECXZ ; icu_56::DigitList::isZero(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_328E
		fldz
		fstp	[ebp+var_5C]
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 80h
		jz	short loc_3289
		fld	[ebp+var_5C]
		fdiv	ds:__real@bff0000000000000
		fstp	[ebp+var_5C]

loc_3289:				; CODE XREF: icu_56::DigitList::getDouble(void)+14Fj
		jmp	loc_3436
; ---------------------------------------------------------------------------

loc_328E:				; CODE XREF: icu_56::DigitList::getDouble(void)+138j
		mov	ecx, [ebp+var_18] ; this
		call	?isInfinite@DigitList@icu_56@@QBECXZ ; icu_56::DigitList::isInfinite(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_32E8
		mov	eax, 1
		test	eax, eax
		jz	short loc_32BA
		mov	esi, esp
		call	dword ptr ds:__imp_?infinity@?$numeric_limits@N@std@@SANXZ ; std::numeric_limits<double>::infinity(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		fstp	[ebp+var_5C]
		jmp	short loc_32CC
; ---------------------------------------------------------------------------

loc_32BA:				; CODE XREF: icu_56::DigitList::getDouble(void)+178j
		mov	esi, esp
		call	dword ptr ds:__imp_?max@?$numeric_limits@N@std@@SANXZ ;	std::numeric_limits<double>::max(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		fstp	[ebp+var_5C]

loc_32CC:				; CODE XREF: icu_56::DigitList::getDouble(void)+18Cj
		mov	ecx, [ebp+var_18] ; this
		call	?isPositive@DigitList@icu_56@@QBECXZ ; icu_56::DigitList::isPositive(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_32E3
		fld	[ebp+var_5C]
		fchs
		fstp	[ebp+var_5C]

loc_32E3:				; CODE XREF: icu_56::DigitList::getDouble(void)+1ADj
		jmp	loc_3436
; ---------------------------------------------------------------------------

loc_32E8:				; CODE XREF: icu_56::DigitList::getDouble(void)+16Fj
		lea	ecx, [ebp+var_90]
		call	??0?$MaybeStackArray@D$0CB@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,33>::MaybeStackArray<char,33>(void)
		mov	[ebp+var_4], 1
		mov	ecx, [ebp+var_18] ; this
		call	?getCount@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getCount(void)
		cmp	eax, 12h
		jle	short loc_335E
		mov	eax, [ebp+var_18]
		push	eax		; struct icu_56::DigitList *
		lea	ecx, [ebp+var_108] ; this
		call	??0DigitList@icu_56@@QAE@ABV01@@Z ; icu_56::DigitList::DigitList(icu_56::DigitList const &)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_108] ; this
		call	?reduce@DigitList@icu_56@@QAEXXZ ; icu_56::DigitList::reduce(void)
		push	12h		; int
		lea	ecx, [ebp+var_108] ; this
		call	?round@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::round(int)
		lea	ecx, [ebp+var_90]
		call	?getAlias@?$MaybeStackArray@D$0CB@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,33>::getAlias(void)
		push	eax
		mov	eax, [ebp+var_EC]
		push	eax
		call	_uprv_decNumberToString_56
		add	esp, 8
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_108] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		jmp	short loc_3379
; ---------------------------------------------------------------------------

loc_335E:				; CODE XREF: icu_56::DigitList::getDouble(void)+1D9j
		lea	ecx, [ebp+var_90]
		call	?getAlias@?$MaybeStackArray@D$0CB@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,33>::getAlias(void)
		push	eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberToString_56
		add	esp, 8

loc_3379:				; CODE XREF: icu_56::DigitList::getDouble(void)+230j
		push	0
		lea	ecx, [ebp+var_90]
		call	??A?$MaybeStackArray@D$0CB@@icu_56@@QAEAADH@Z ;	icu_56::MaybeStackArray<char,33>::operator[](int)
		push	eax		; Str
		call	_strlen
		add	esp, 4
		cmp	eax, 21h ; '!'
		jb	short loc_33B9
		mov	eax, ds:?__LINE__Var@?1??getDouble@DigitList@icu_56@@QBENXZ@4JA	; long `icu_56::DigitList::getDouble(void)'::`2'::__LINE__Var
		add	eax, 38h ; '8'
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1EK@FDIIEIOF@?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AA?$CG?$AAs?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAD?$AAB?$AAL?$AA_?$AAD?$AAI?$AAG?$AAI?$AAT@ ; ":: strlen(&s[0]) < MAX_DBL_DIGITS+18"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_33B9:				; CODE XREF: icu_56::DigitList::getDouble(void)+266j
		movsx	eax, [ebp+var_21]
		cmp	eax, 2Eh ; '.'
		jz	short loc_33F2
		push	2Eh ; '.'       ; Val
		lea	ecx, [ebp+var_90]
		call	?getAlias@?$MaybeStackArray@D$0CB@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,33>::getAlias(void)
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_114], eax
		cmp	[ebp+var_114], 0
		jz	short loc_33F2
		mov	eax, [ebp+var_114]
		mov	cl, [ebp+var_21]
		mov	[eax], cl

loc_33F2:				; CODE XREF: icu_56::DigitList::getDouble(void)+294j
					; icu_56::DigitList::getDouble(void)+2B9j
		mov	[ebp+EndPtr], 0
		mov	esi, esp
		lea	eax, [ebp+EndPtr]
		push	eax		; EndPtr
		lea	ecx, [ebp+var_90]
		call	?getAlias@?$MaybeStackArray@D$0CB@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,33>::getAlias(void)
		push	eax		; Str
		call	dword ptr ds:__imp__strtod
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		fstp	[ebp+var_5C]
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_90]
		call	??1?$MaybeStackArray@D$0CB@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,33>::~MaybeStackArray<char,33>(void)

loc_3436:				; CODE XREF: icu_56::DigitList::getDouble(void):loc_3289j
					; icu_56::DigitList::getDouble(void):loc_32E3j
		mov	esi, esp
		push	0		; struct UMutex	*
		lea	ecx, [ebp+var_12C] ; this
		call	dword ptr ds:__imp_??0Mutex@icu_56@@QAE@PAUUMutex@@@Z ;	icu_56::Mutex::Mutex(UMutex *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 3
		mov	eax, [ebp+var_18]
		mov	[ebp+var_138], eax
		sub	esp, 8
		fld	[ebp+var_5C]
		fstp	qword ptr [esp]	; double
		mov	ecx, [ebp+var_138] ; this
		call	?internalSetDouble@DigitList@icu_56@@AAEXN@Z ; icu_56::DigitList::internalSetDouble(double)
		mov	al, [ebp+var_21]
		mov	ds:?gDecimal@?1??getDouble@DigitList@icu_56@@QBENXZ@4DA, al ; char `icu_56::DigitList::getDouble(void)'::`2'::gDecimal
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_12C] ; this
		call	dword ptr ds:__imp_??1Mutex@icu_56@@QAE@XZ ; icu_56::Mutex::~Mutex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		fld	[ebp+var_5C]

loc_3498:				; CODE XREF: icu_56::DigitList::getDouble(void)+94j
					; icu_56::DigitList::getDouble(void)+CFj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN32
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 21Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDouble@DigitList@icu_56@@QBENXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN32		dd 6			; DATA XREF: icu_56::DigitList::getDouble(void)+370o
		dd offset $LN31
$LN31		dd 0FFFFFFD0h, 4	; DATA XREF: .text:000034D8o
		dd offset $LN24		; "mutex"
		dd 0FFFFFFB4h, 13h
		dd offset $LN25		; "rep"
		dd 0FFFFFF70h, 2Ch
		dd offset $LN26		; "s"
		dd 0FFFFFEF8h, 70h
		dd offset $LN27		; "numToConvert"
		dd 0FFFFFEE0h, 4
		dd offset $LN28		; "end"
		dd 0FFFFFED4h, 4
		dd offset $LN29		; "mutex"
$LN29		db 'mutex',0            ; DATA XREF: .text:00003520o
$LN28		db 'end',0              ; DATA XREF: .text:00003514o
$LN27		db 'numToConvert',0     ; DATA XREF: .text:00003508o
$LN26		db 's',0                ; DATA XREF: .text:000034FCo
$LN25		db 'rep',0              ; DATA XREF: .text:000034F0o
$LN24		db 'mutex',0            ; DATA XREF: .text:000034E4o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3548h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$0 proc near
					; DATA XREF: .xdata$x:0000360Co
		mov	esi, esp
		lea	ecx, [ebp-30h]	; this
		call	dword ptr ds:__imp_??1Mutex@icu_56@@QAE@XZ ; icu_56::Mutex::~Mutex(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$1 proc near
					; DATA XREF: .xdata$x:00003614o
		lea	ecx, [ebp-90h]
		jmp	??1?$MaybeStackArray@D$0CB@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,33>::~MaybeStackArray<char,33>(void)
__unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$2 proc near
					; DATA XREF: .xdata$x:0000361Co
		lea	ecx, [ebp-108h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$3 proc near
					; DATA XREF: .xdata$x:00003624o
		mov	esi, esp
		lea	ecx, [ebp-12Ch]	; this
		call	dword ptr ds:__imp_??1Mutex@icu_56@@QAE@XZ ; icu_56::Mutex::~Mutex(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getDouble@DigitList@icu_56@@QBENXZ	proc near
					; DATA XREF: icu_56::DigitList::getDouble(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-220h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getDouble@DigitList@icu_56@@QBENXZ
		jmp	___CxxFrameHandler3
__ehhandler$?getDouble@DigitList@icu_56@@QBENXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 35B0h
		public ??_C@_1EK@FDIIEIOF@?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AA?$CG?$AAs?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAD?$AAB?$AAL?$AA_?$AAD?$AAI?$AAG?$AAI?$AAT@
; wchar_t `string'
??_C@_1EK@FDIIEIOF@?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AA?$CG?$AAs?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAD?$AAB?$AAL?$AA_?$AAD?$AAI?$AAG?$AAI?$AAT@:
					; DATA XREF: icu_56::DigitList::getDouble(void)+278o
		unicode	0, <:: strlen(&s[0]) >
		dw 3Ch
		unicode	0, < MAX_DBL_DIGITS+18>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 35FCh
		public ?__LINE__Var@?1??getDouble@DigitList@icu_56@@QBENXZ@4JA
; long `public:	double __thiscall icu_56::DigitList::getDouble(void)const'::`2'::__LINE__Var
?__LINE__Var@?1??getDouble@DigitList@icu_56@@QBENXZ@4JA	dd 1B0h
					; DATA XREF: icu_56::DigitList::getDouble(void)+268r
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 3600h
		public __real@bff0000000000000
__real@bff0000000000000	dq -1.0		; DATA XREF: icu_56::DigitList::getDouble(void)+154r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3608h
__unwindtable$?getDouble@DigitList@icu_56@@QBENXZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003630o
		dd offset __unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$1
		dd 1
		dd offset __unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$2
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$3
__ehfuncinfo$?getDouble@DigitList@icu_56@@QBENXZ dd 19930522h, 4
					; DATA XREF: __ehhandler$?getDouble@DigitList@icu_56@@QBENXZ+1Eo
		dd offset __unwindtable$?getDouble@DigitList@icu_56@@QBENXZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 364Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char *__cdecl	strchr(char *Str, int Val)
		public ?strchr@@YAPADPADH@Z
?strchr@@YAPADPADH@Z proc near		; CODE XREF: icu_56::DigitList::getDouble(void)+2A4p
					; icu_56::DigitList::set(double)+E6p

var_C0		= byte ptr -0C0h
Str		= dword	ptr  8
Val		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+Val]
		push	eax		; Val
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?strchr@@YAPADPADH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3698h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::getLong(icu_56::DigitList *__hidden	this)
		public ?getLong@DigitList@icu_56@@QAEHXZ
?getLong@DigitList@icu_56@@QAEHXZ proc near

var_1D8		= byte ptr -1D8h
var_114		= byte ptr -114h
var_F8		= dword	ptr -0F8h
var_9C		= byte ptr -9Ch
var_80		= dword	ptr -80h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getLong@DigitList@icu_56@@QAEHXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 1CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1D8]
		mov	ecx, 73h ; 's'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_24], 0
		mov	ecx, [ebp+var_18] ; this
		call	?getUpperExponent@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getUpperExponent(void)
		cmp	eax, 0Ah
		jle	short loc_36F9
		mov	eax, [ebp+var_24]
		jmp	loc_378C
; ---------------------------------------------------------------------------

loc_36F9:				; CODE XREF: icu_56::DigitList::getLong(void)+57j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		cmp	dword ptr [ecx+4], 0
		jz	short loc_3773
		mov	eax, [ebp+var_18]
		push	eax		; struct icu_56::DigitList *
		lea	ecx, [ebp+var_9C] ; this
		call	??0DigitList@icu_56@@QAE@ABV01@@Z ; icu_56::DigitList::DigitList(icu_56::DigitList const &)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_114] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	eax, [ebp+var_18]
		push	eax
		mov	ecx, [ebp+var_F8]
		push	ecx
		mov	edx, [ebp+var_80]
		push	edx
		mov	eax, [ebp+var_80]
		push	eax
		call	_uprv_decNumberQuantize_56
		add	esp, 10h
		mov	eax, [ebp+var_18]
		push	eax
		mov	ecx, [ebp+var_80]
		push	ecx
		call	_uprv_decNumberToInt32_56
		add	esp, 8
		mov	[ebp+var_24], eax
		lea	ecx, [ebp+var_114] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_9C] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		jmp	short loc_3789
; ---------------------------------------------------------------------------

loc_3773:				; CODE XREF: icu_56::DigitList::getLong(void)+6Bj
		mov	eax, [ebp+var_18]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+1Ch]
		push	edx
		call	_uprv_decNumberToInt32_56
		add	esp, 8
		mov	[ebp+var_24], eax

loc_3789:				; CODE XREF: icu_56::DigitList::getLong(void)+D9j
		mov	eax, [ebp+var_24]

loc_378C:				; CODE XREF: icu_56::DigitList::getLong(void)+5Cj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getLong@DigitList@icu_56@@QAEHXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN12		dd 2			; DATA XREF: icu_56::DigitList::getLong(void)+F8o
		dd offset $LN11_1
$LN11_1		dd 0FFFFFF64h, 70h	; DATA XREF: .text:000037CCo
		dd offset $LN8_2	; "copy"
		dd 0FFFFFEECh, 70h
		dd offset $LN9_3	; "zero"
$LN9_3		db 'zero',0             ; DATA XREF: .text:000037E4o
$LN8_2		db 'copy',0             ; DATA XREF: .text:000037D8o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 37F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getLong@DigitList@icu_56@@QAEHXZ$0 proc near
					; DATA XREF: .xdata$x:0000382Co
		lea	ecx, [ebp-9Ch]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$?getLong@DigitList@icu_56@@QAEHXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getLong@DigitList@icu_56@@QAEHXZ proc near
					; DATA XREF: icu_56::DigitList::getLong(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getLong@DigitList@icu_56@@QAEHXZ
		jmp	___CxxFrameHandler3
__ehhandler$?getLong@DigitList@icu_56@@QAEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3828h
__unwindtable$?getLong@DigitList@icu_56@@QAEHXZ	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003838o
		dd offset __unwindfunclet$?getLong@DigitList@icu_56@@QAEHXZ$0
__ehfuncinfo$?getLong@DigitList@icu_56@@QAEHXZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?getLong@DigitList@icu_56@@QAEHXZ+1Eo
		dd offset __unwindtable$?getLong@DigitList@icu_56@@QAEHXZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3854h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __thiscall icu_56::DigitList::getInt64(icu_56::DigitList *__hidden this)
		public ?getInt64@DigitList@icu_56@@QAE_JXZ
?getInt64@DigitList@icu_56@@QAE_JXZ proc near

var_120		= dword	ptr -120h
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+68h], 2
		jnz	short loc_388E
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx+60h]
		mov	edx, [ecx+64h]
		jmp	loc_39D2
; ---------------------------------------------------------------------------

loc_388E:				; CODE XREF: icu_56::DigitList::getInt64(void)+2Aj
		mov	ecx, [ebp+var_8] ; this
		call	?getUpperExponent@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getUpperExponent(void)
		cmp	eax, 13h
		jle	short loc_38A4
		xor	eax, eax
		xor	edx, edx
		jmp	loc_39D2
; ---------------------------------------------------------------------------

loc_38A4:				; CODE XREF: icu_56::DigitList::getInt64(void)+45j
		mov	ecx, [ebp+var_8] ; this
		call	?getUpperExponent@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getUpperExponent(void)
		mov	[ebp+var_14], eax
		mov	[ebp+var_24], 0
		mov	[ebp+var_20], 0
		mov	[ebp+var_30], 0
		jmp	short loc_38CF
; ---------------------------------------------------------------------------

loc_38C6:				; CODE XREF: icu_56::DigitList::getInt64(void)+E2j
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax

loc_38CF:				; CODE XREF: icu_56::DigitList::getInt64(void)+70j
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_14]
		jge	short loc_3938
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx]
		sub	edx, [ebp+var_30]
		sub	edx, 1
		mov	[ebp+var_3C], edx
		js	short loc_3900
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+var_3C]
		movzx	eax, byte ptr [ecx+edx+9]
		mov	[ebp+var_120], eax
		jmp	short loc_390A
; ---------------------------------------------------------------------------

loc_3900:				; CODE XREF: icu_56::DigitList::getInt64(void)+94j
		mov	[ebp+var_120], 0

loc_390A:				; CODE XREF: icu_56::DigitList::getInt64(void)+AAj
		mov	ecx, [ebp+var_120]
		mov	[ebp+var_48], ecx
		push	0
		push	0Ah
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_24]
		push	ecx
		call	__allmul
		mov	ecx, eax
		mov	esi, edx
		mov	eax, [ebp+var_48]
		cdq
		add	ecx, eax
		adc	esi, edx
		mov	[ebp+var_24], ecx
		mov	[ebp+var_20], esi
		jmp	short loc_38C6
; ---------------------------------------------------------------------------

loc_3938:				; CODE XREF: icu_56::DigitList::getInt64(void)+81j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 80h
		jz	short loc_396C
		mov	eax, [ebp+var_24]
		not	eax
		mov	ecx, [ebp+var_20]
		not	ecx
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_24]
		add	eax, 1
		mov	ecx, [ebp+var_20]
		adc	ecx, 0
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], ecx

loc_396C:				; CODE XREF: icu_56::DigitList::getInt64(void)+F4j
		mov	eax, [ebp+var_24]
		mov	[ebp+var_58], eax
		mov	ecx, [ebp+var_20]
		mov	[ebp+var_54], ecx
		cmp	[ebp+var_14], 13h
		jnz	short loc_39CC
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 80h
		jz	short loc_399E
		cmp	[ebp+var_54], 0
		jg	short loc_39BE
		jl	short loc_399E
		cmp	[ebp+var_58], 0
		ja	short loc_39BE

loc_399E:				; CODE XREF: icu_56::DigitList::getInt64(void)+13Aj
					; icu_56::DigitList::getInt64(void)+142j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 80h
		jnz	short loc_39CC
		cmp	[ebp+var_54], 0
		jg	short loc_39CC
		jl	short loc_39BE
		cmp	[ebp+var_58], 0
		jnb	short loc_39CC

loc_39BE:				; CODE XREF: icu_56::DigitList::getInt64(void)+140j
					; icu_56::DigitList::getInt64(void)+148j ...
		mov	[ebp+var_58], 0
		mov	[ebp+var_54], 0

loc_39CC:				; CODE XREF: icu_56::DigitList::getInt64(void)+128j
					; icu_56::DigitList::getInt64(void)+15Aj ...
		mov	eax, [ebp+var_58]
		mov	edx, [ebp+var_54]

loc_39D2:				; CODE XREF: icu_56::DigitList::getInt64(void)+35j
					; icu_56::DigitList::getInt64(void)+4Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getInt64@DigitList@icu_56@@QAE_JXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::getDecimal(icu_56::DigitList *__hidden this, struct icu_56::CharString *, enum UErrorCode *)
		public ?getDecimal@DigitList@icu_56@@QAEXAAVCharString@2@AAW4UErrorCode@@@Z
?getDecimal@DigitList@icu_56@@QAEXAAVCharString@2@AAW4UErrorCode@@@Z proc near

var_F0		= byte ptr -0F0h
Str		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx		; int *
		push	esi		; int
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3A25
		jmp	loc_3B1C
; ---------------------------------------------------------------------------

loc_3A25:				; CODE XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx]
		add	edx, 0Eh
		mov	[ebp+var_14], edx
		mov	[ebp+var_20], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_20]
		push	ecx		; int *
		push	0		; int
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	edi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?clear@CharString@icu_56@@QAEAAV12@XZ ; icu_56::CharString::clear(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax	; this
		call	dword ptr ds:__imp_?getAppendBuffer@CharString@icu_56@@QAEPADHHAAHAAW4UErrorCode@@@Z ; icu_56::CharString::getAppendBuffer(int,int,int &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Str], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3A88
		jmp	loc_3B1C
; ---------------------------------------------------------------------------

loc_3A88:				; CODE XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+99j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	short loc_3AB6
		mov	ecx, ds:?__LINE__Var@?1??getDecimal@DigitList@icu_56@@QAEXAAVCharString@3@AAW4UErrorCode@@@Z@4JA ; long	`icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 0Dh
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1CM@BCJNILJF@?$AAc?$AAa?$AAp?$AAa?$AAc?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAm?$AAa?$AAx?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@ ; "capacity >= maxLength"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3AB6:				; CODE XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+A6j
		mov	eax, [ebp+Str]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		push	edx
		call	_uprv_decNumberToString_56
		add	esp, 8
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		cmp	eax, [ebp+var_14]
		jle	short loc_3B00
		mov	ecx, ds:?__LINE__Var@?1??getDecimal@DigitList@icu_56@@QAEXAAVCharString@3@AAW4UErrorCode@@@Z@4JA ; long	`icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 0Fh
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1FA@HABFCLIA@?$AA?$CI?$AAi?$AAn?$AAt?$AA3?$AA2?$AA_?$AAt?$AA?$CJ?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AAa@ ; "(int32_t):: strlen(buffer) <= maxLength"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3B00:				; CODE XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+F0j
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		push	0FFFFFFFFh	; int
		mov	ecx, [ebp+Str]
		push	ecx		; char *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z ;	icu_56::CharString::append(char	const *,int,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3B1C:				; CODE XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+38j
					; icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode	&)+9Bj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getDecimal@DigitList@icu_56@@QAEXAAVCharString@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN9_4		dd 1			; DATA XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+138o
		dd offset $LN8_3
$LN8_3		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00003B48o
		dd offset $LN7_2	; "capacity"
$LN7_2		db 'capacity',0         ; DATA XREF: .text:00003B54o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 3B64h
		public ??_C@_1FA@HABFCLIA@?$AA?$CI?$AAi?$AAn?$AAt?$AA3?$AA2?$AA_?$AAt?$AA?$CJ?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AAa@
; wchar_t `string'
??_C@_1FA@HABFCLIA@?$AA?$CI?$AAi?$AAn?$AAt?$AA3?$AA2?$AA_?$AAt?$AA?$CJ?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AAa@:
					; DATA XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+103o
		unicode	0, <(int32_t)::	strlen(buffer) >
		dw 3Ch
		unicode	0, <= maxLength>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3BB4h
		public ??_C@_1CM@BCJNILJF@?$AAc?$AAa?$AAp?$AAa?$AAc?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAm?$AAa?$AAx?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@
; wchar_t `string'
??_C@_1CM@BCJNILJF@?$AAc?$AAa?$AAp?$AAa?$AAc?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAm?$AAa?$AAx?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@:
					; DATA XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+B9o
		unicode	0, <capacity >
		dw 3Eh
		unicode	0, <= maxLength>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 3BE0h
		public ?__LINE__Var@?1??getDecimal@DigitList@icu_56@@QAEXAAVCharString@3@AAW4UErrorCode@@@Z@4JA
; long `public:	void __thiscall	icu_56::DigitList::getDecimal(class icu_56::CharString &, enum	UErrorCode &)'::`2'::__LINE__Var
?__LINE__Var@?1??getDecimal@DigitList@icu_56@@QAEXAAVCharString@3@AAW4UErrorCode@@@Z@4JA dd 254h
					; DATA XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+A8r
					; icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode	&)+F2r
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+29p
					; icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode	&)+8Cp	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::fitsIntoLong(icu_56::DigitList *this, signed __int8)
		public ?fitsIntoLong@DigitList@icu_56@@QAECC@Z
?fitsIntoLong@DigitList@icu_56@@QAECC@Z	proc near

var_228		= byte ptr -228h
var_224		= byte ptr -224h
var_211		= byte ptr -211h
var_208		= byte ptr -208h
var_1F5		= byte ptr -1F5h
var_1E9		= byte ptr -1E9h
var_1DD		= byte ptr -1DDh
var_114		= byte ptr -114h
var_9C		= byte ptr -9Ch
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?fitsIntoLong@DigitList@icu_56@@QAECC@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 21Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_228]
		mov	ecx, 87h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 70h
		jz	short loc_3C6B
		xor	al, al
		jmp	loc_3E61
; ---------------------------------------------------------------------------

loc_3C6B:				; CODE XREF: icu_56::DigitList::fitsIntoLong(signed char)+52j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberTrim_56
		add	esp, 4
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		cmp	dword ptr [ecx+4], 0
		jge	short loc_3C8D
		xor	al, al
		jmp	loc_3E61
; ---------------------------------------------------------------------------

loc_3C8D:				; CODE XREF: icu_56::DigitList::fitsIntoLong(signed char)+74j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+9]
		test	edx, edx
		jnz	short loc_3CD6
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		cmp	dword ptr [ecx], 1
		jnz	short loc_3CD6
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 70h
		jnz	short loc_3CD6
		movsx	eax, [ebp+arg_0]
		test	eax, eax
		jnz	short loc_3CD6
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 80h
		jz	short loc_3CD6
		xor	al, al
		jmp	loc_3E61
; ---------------------------------------------------------------------------

loc_3CD6:				; CODE XREF: icu_56::DigitList::fitsIntoLong(signed char)+89j
					; icu_56::DigitList::fitsIntoLong(signed char)+94j ...
		mov	ecx, [ebp+var_18] ; this
		call	?getUpperExponent@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getUpperExponent(void)
		cmp	eax, 0Ah
		jge	short loc_3CEA
		mov	al, 1
		jmp	loc_3E61
; ---------------------------------------------------------------------------

loc_3CEA:				; CODE XREF: icu_56::DigitList::fitsIntoLong(signed char)+D1j
		mov	[ebp+var_24], 0
		lea	ecx, [ebp+var_9C] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	[ebp+var_4], 0
		mov	esi, esp
		push	offset ??_C@_0M@LKGPKDPK@?92147483648?$AA@ ; "-2147483648"
		lea	ecx, [ebp+var_224] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0		; unsigned int
		lea	eax, [ebp+var_24]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_224]
		push	ecx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_9C] ; this
		call	?set@DigitList@icu_56@@QAEXABVStringPiece@2@AAW4UErrorCode@@I@Z	; icu_56::DigitList::set(icu_56::StringPiece const &,UErrorCode	&,uint)
		lea	eax, [ebp+var_9C]
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?compare@DigitList@icu_56@@QAEHABV12@@Z	; icu_56::DigitList::compare(icu_56::DigitList const &)
		test	eax, eax
		jge	short loc_3D6C
		mov	[ebp+var_211], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_9C] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_211]
		jmp	loc_3E61
; ---------------------------------------------------------------------------

loc_3D6C:				; CODE XREF: icu_56::DigitList::fitsIntoLong(signed char)+136j
		lea	ecx, [ebp+var_114] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		push	offset ??_C@_0L@KLDLBCKA@2147483647?$AA@ ; "2147483647"
		lea	ecx, [ebp+var_208] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0		; unsigned int
		lea	eax, [ebp+var_24]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_208]
		push	ecx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_114] ; this
		call	?set@DigitList@icu_56@@QAEXABVStringPiece@2@AAW4UErrorCode@@I@Z	; icu_56::DigitList::set(icu_56::StringPiece const &,UErrorCode	&,uint)
		lea	eax, [ebp+var_114]
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?compare@DigitList@icu_56@@QAEHABV12@@Z	; icu_56::DigitList::compare(icu_56::DigitList const &)
		test	eax, eax
		jle	short loc_3DF0
		mov	[ebp+var_1F5], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_114] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_9C] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1F5]
		jmp	short loc_3E61
; ---------------------------------------------------------------------------

loc_3DF0:				; CODE XREF: icu_56::DigitList::fitsIntoLong(signed char)+1AEj
		mov	eax, [ebp+var_24]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_3E33
		mov	[ebp+var_1E9], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_114] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_9C] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1E9]
		jmp	short loc_3E61
; ---------------------------------------------------------------------------

loc_3E33:				; CODE XREF: icu_56::DigitList::fitsIntoLong(signed char)+1F1j
		mov	[ebp+var_1DD], 1
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_114] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_9C] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1DD]

loc_3E61:				; CODE XREF: icu_56::DigitList::fitsIntoLong(signed char)+56j
					; icu_56::DigitList::fitsIntoLong(signed char)+78j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 228h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?fitsIntoLong@DigitList@icu_56@@QAECC@Z	endp

; ---------------------------------------------------------------------------
		align 10h
$LN17		dd 3			; DATA XREF: icu_56::DigitList::fitsIntoLong(signed char)+255o
		dd offset $LN16
$LN16		dd 0FFFFFFDCh, 4	; DATA XREF: .text:00003EA4o
		dd offset $LN12_0	; "status"
		dd 0FFFFFF64h, 70h
		dd offset $LN13		; "min32"
		dd 0FFFFFEECh, 70h
		dd offset $LN14_0	; "max32"
$LN14_0		db 'max32',0            ; DATA XREF: .text:00003EC8o
$LN13		db 'min32',0            ; DATA XREF: .text:00003EBCo
$LN12_0		db 'status',0           ; DATA XREF: .text:00003EB0o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3EE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?fitsIntoLong@DigitList@icu_56@@QAECC@Z$0 proc near
					; DATA XREF: .xdata$x:00003F3Co
		lea	ecx, [ebp-9Ch]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$?fitsIntoLong@DigitList@icu_56@@QAECC@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?fitsIntoLong@DigitList@icu_56@@QAECC@Z$1 proc near
					; DATA XREF: .xdata$x:00003F44o
		lea	ecx, [ebp-114h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$?fitsIntoLong@DigitList@icu_56@@QAECC@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?fitsIntoLong@DigitList@icu_56@@QAECC@Z proc near
					; DATA XREF: icu_56::DigitList::fitsIntoLong(signed char)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-22Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?fitsIntoLong@DigitList@icu_56@@QAECC@Z
		jmp	___CxxFrameHandler3
__ehhandler$?fitsIntoLong@DigitList@icu_56@@QAECC@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3F20h
		public ??_C@_0L@KLDLBCKA@2147483647?$AA@
; char `string'[]
??_C@_0L@KLDLBCKA@2147483647?$AA@ db '2147483647',0
					; DATA XREF: icu_56::DigitList::fitsIntoLong(signed char)+16Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3F2Ch
		public ??_C@_0M@LKGPKDPK@?92147483648?$AA@
; char `string'[]
??_C@_0M@LKGPKDPK@?92147483648?$AA@ db '-2147483648',0
					; DATA XREF: icu_56::DigitList::fitsIntoLong(signed char)+F5o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3F38h
__unwindtable$?fitsIntoLong@DigitList@icu_56@@QAECC@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003F50o
		dd offset __unwindfunclet$?fitsIntoLong@DigitList@icu_56@@QAECC@Z$0
		dd 0
		dd offset __unwindfunclet$?fitsIntoLong@DigitList@icu_56@@QAECC@Z$1
__ehfuncinfo$?fitsIntoLong@DigitList@icu_56@@QAECC@Z dd	19930522h, 2
					; DATA XREF: __ehhandler$?fitsIntoLong@DigitList@icu_56@@QAECC@Z+1Eo
		dd offset __unwindtable$?fitsIntoLong@DigitList@icu_56@@QAECC@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::fitsIntoInt64(icu_56::DigitList *this, signed __int8)
		public ?fitsIntoInt64@DigitList@icu_56@@QAECC@Z
?fitsIntoInt64@DigitList@icu_56@@QAECC@Z proc near

var_228		= byte ptr -228h
var_224		= byte ptr -224h
var_211		= byte ptr -211h
var_208		= byte ptr -208h
var_1F5		= byte ptr -1F5h
var_1E9		= byte ptr -1E9h
var_1DD		= byte ptr -1DDh
var_114		= byte ptr -114h
var_9C		= byte ptr -9Ch
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 21Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_228]
		mov	ecx, 87h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 70h
		jz	short loc_3FC7
		xor	al, al
		jmp	loc_41BD
; ---------------------------------------------------------------------------

loc_3FC7:				; CODE XREF: icu_56::DigitList::fitsIntoInt64(signed char)+52j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberTrim_56
		add	esp, 4
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		cmp	dword ptr [ecx+4], 0
		jge	short loc_3FE9
		xor	al, al
		jmp	loc_41BD
; ---------------------------------------------------------------------------

loc_3FE9:				; CODE XREF: icu_56::DigitList::fitsIntoInt64(signed char)+74j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+9]
		test	edx, edx
		jnz	short loc_4032
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		cmp	dword ptr [ecx], 1

loc_4000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		jnz	short loc_4032
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 70h
		jnz	short loc_4032
		movsx	eax, [ebp+arg_0]
		test	eax, eax
		jnz	short loc_4032
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 80h
		jz	short loc_4032
		xor	al, al
		jmp	loc_41BD
; ---------------------------------------------------------------------------

loc_4032:				; CODE XREF: icu_56::DigitList::fitsIntoInt64(signed char)+89j
					; icu_56::DigitList::fitsIntoInt64(signed char):loc_4000j ...
		mov	ecx, [ebp+var_18] ; this
		call	?getUpperExponent@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getUpperExponent(void)
		cmp	eax, 13h
		jge	short loc_4046
		mov	al, 1
		jmp	loc_41BD
; ---------------------------------------------------------------------------

loc_4046:				; CODE XREF: icu_56::DigitList::fitsIntoInt64(signed char)+D1j
		mov	[ebp+var_24], 0
		lea	ecx, [ebp+var_9C] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	[ebp+var_4], 0
		mov	esi, esp
		push	offset ??_C@_0BF@LKIEOMOJ@?99223372036854775808?$AA@ ; "-9223372036854775808"
		lea	ecx, [ebp+var_224] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0		; unsigned int
		lea	eax, [ebp+var_24]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_224]
		push	ecx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_9C] ; this
		call	?set@DigitList@icu_56@@QAEXABVStringPiece@2@AAW4UErrorCode@@I@Z	; icu_56::DigitList::set(icu_56::StringPiece const &,UErrorCode	&,uint)
		lea	eax, [ebp+var_9C]
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?compare@DigitList@icu_56@@QAEHABV12@@Z	; icu_56::DigitList::compare(icu_56::DigitList const &)
		test	eax, eax
		jge	short loc_40C8
		mov	[ebp+var_211], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_9C] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_211]
		jmp	loc_41BD
; ---------------------------------------------------------------------------

loc_40C8:				; CODE XREF: icu_56::DigitList::fitsIntoInt64(signed char)+136j
		lea	ecx, [ebp+var_114] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		push	offset ??_C@_0BE@EMNEAFKL@9223372036854775807?$AA@ ; "9223372036854775807"
		lea	ecx, [ebp+var_208] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0		; unsigned int
		lea	eax, [ebp+var_24]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_208]
		push	ecx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_114] ; this
		call	?set@DigitList@icu_56@@QAEXABVStringPiece@2@AAW4UErrorCode@@I@Z	; icu_56::DigitList::set(icu_56::StringPiece const &,UErrorCode	&,uint)
		lea	eax, [ebp+var_114]
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?compare@DigitList@icu_56@@QAEHABV12@@Z	; icu_56::DigitList::compare(icu_56::DigitList const &)
		test	eax, eax
		jle	short loc_414C
		mov	[ebp+var_1F5], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_114] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_9C] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1F5]
		jmp	short loc_41BD
; ---------------------------------------------------------------------------

loc_414C:				; CODE XREF: icu_56::DigitList::fitsIntoInt64(signed char)+1AEj
		mov	eax, [ebp+var_24]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_418F
		mov	[ebp+var_1E9], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_114] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_9C] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1E9]
		jmp	short loc_41BD
; ---------------------------------------------------------------------------

loc_418F:				; CODE XREF: icu_56::DigitList::fitsIntoInt64(signed char)+1F1j
		mov	[ebp+var_1DD], 1
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_114] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_9C] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1DD]

loc_41BD:				; CODE XREF: icu_56::DigitList::fitsIntoInt64(signed char)+56j
					; icu_56::DigitList::fitsIntoInt64(signed char)+78j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 228h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?fitsIntoInt64@DigitList@icu_56@@QAECC@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN17_0		dd 3			; DATA XREF: icu_56::DigitList::fitsIntoInt64(signed char)+255o
		dd offset $LN16_0
$LN16_0		dd 0FFFFFFDCh, 4	; DATA XREF: .text:00004200o
		dd offset $LN12_1	; "status"
		dd 0FFFFFF64h, 70h
		dd offset $LN13_0	; "min64"
		dd 0FFFFFEECh, 70h
		dd offset $LN14_1	; "max64"
$LN14_1		db 'max64',0            ; DATA XREF: .text:00004224o
$LN13_0		db 'min64',0            ; DATA XREF: .text:00004218o
$LN12_1		db 'status',0           ; DATA XREF: .text:0000420Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 423Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z$0 proc	near
					; DATA XREF: .xdata$x:000042ACo
		lea	ecx, [ebp-9Ch]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z$1 proc	near
					; DATA XREF: .xdata$x:000042B4o
		lea	ecx, [ebp-114h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z proc near
					; DATA XREF: icu_56::DigitList::fitsIntoInt64(signed char)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-22Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z
		jmp	___CxxFrameHandler3
__ehhandler$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 427Ch
		public ??_C@_0BE@EMNEAFKL@9223372036854775807?$AA@
; char `string'[]
??_C@_0BE@EMNEAFKL@9223372036854775807?$AA@ db '9223372036854775807',0
					; DATA XREF: icu_56::DigitList::fitsIntoInt64(signed char)+16Do
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4290h
		public ??_C@_0BF@LKIEOMOJ@?99223372036854775808?$AA@
; char `string'[]
??_C@_0BF@LKIEOMOJ@?99223372036854775808?$AA@ db '-9223372036854775808',0
					; DATA XREF: icu_56::DigitList::fitsIntoInt64(signed char)+F5o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 42A8h
__unwindtable$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000042C0o
		dd offset __unwindfunclet$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z$0
		dd 0
		dd offset __unwindfunclet$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z$1
__ehfuncinfo$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z+1Eo
		dd offset __unwindtable$?fitsIntoInt64@DigitList@icu_56@@QAECC@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 42DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::set(icu_56::DigitList *__hidden this, int)
		public ?set@DigitList@icu_56@@QAEXH@Z
?set@DigitList@icu_56@@QAEXH@Z proc near

var_E0		= qword	ptr -0E0h
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, dword ptr [ebp+arg_0]
		cdq
		push	edx
		push	eax		; __int64
		mov	ecx, [ebp+var_8] ; this
		call	?set@DigitList@icu_56@@QAEX_J@Z	; icu_56::DigitList::set(__int64)
		fild	dword ptr [ebp+arg_0]
		sub	esp, 8
		fstp	[esp+0E0h+var_E0] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?internalSetDouble@DigitList@icu_56@@AAEXN@Z ; icu_56::DigitList::internalSetDouble(double)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?set@DigitList@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4334h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::set(icu_56::DigitList *this, __int64)
		public ?set@DigitList@icu_56@@QAEX_J@Z
?set@DigitList@icu_56@@QAEX_J@Z	proc near ; CODE XREF: icu_56::DigitList::set(int)+2Cp

var_104		= qword	ptr -104h
var_F0		= byte ptr -0F0h
Str		= byte ptr -2Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		lea	eax, [ebp+Str]
		push	eax		; Dst
		mov	ecx, dword ptr [ebp+arg_0+4]
		push	ecx		; int
		mov	edx, dword ptr [ebp+arg_0]
		push	edx		; int
		call	?formatBase10@icu_56@@YAH_JPAD@Z ; icu_56::formatBase10(__int64,char *)
		add	esp, 0Ch
		lea	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		cmp	eax, 15h
		jb	short loc_43AC
		mov	ecx, ds:?__LINE__Var@?1??set@DigitList@icu_56@@QAEX_J@Z@4JA ; long `icu_56::DigitList::set(__int64)'::`2'::__LINE__Var
		add	ecx, 3
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1DK@BBDELKPF@?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ ; ":: strlen(str) <	sizeof(str)"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_43AC:				; CODE XREF: icu_56::DigitList::set(__int64)+50j
		mov	eax, [ebp+var_C]
		push	eax
		lea	ecx, [ebp+Str]
		push	ecx
		mov	edx, [ebp+var_C]
		mov	eax, [edx+1Ch]
		push	eax
		call	_uprv_decNumberFromString_56
		add	esp, 0Ch
		fild	[ebp+arg_0]
		sub	esp, 8
		fstp	[esp+104h+var_104] ; double
		mov	ecx, [ebp+var_C] ; this
		call	?internalSetDouble@DigitList@icu_56@@AAEXN@Z ; icu_56::DigitList::internalSetDouble(double)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?set@DigitList@icu_56@@QAEX_J@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN6_2		dd 1			; DATA XREF: icu_56::DigitList::set(__int64)+A4o
		dd offset $LN5_1
$LN5_1		dd 0FFFFFFD4h, 15h	; DATA XREF: .text:0000440Co
		dd offset $LN4_0
$LN4_0		dd 727473h		; DATA XREF: .text:00004418o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4420h
		public ??_C@_1DK@BBDELKPF@?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
; wchar_t `string'
??_C@_1DK@BBDELKPF@?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@:
					; DATA XREF: icu_56::DigitList::set(__int64)+63o
		unicode	0, <:: strlen(str) >
		dw 3Ch
		unicode	0, < sizeof(str)>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 445Ch
		public ?__LINE__Var@?1??set@DigitList@icu_56@@QAEX_J@Z@4JA
; long `public:	void __thiscall	icu_56::DigitList::set(__int64)'::`2'::__LINE__Var
?__LINE__Var@?1??set@DigitList@icu_56@@QAEX_J@Z@4JA dd 2D3h
					; DATA XREF: icu_56::DigitList::set(__int64)+52r
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4460h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::formatBase10(int,	int, void *Dst)
?formatBase10@icu_56@@YAH_JPAD@Z proc near ; CODE XREF:	icu_56::DigitList::set(__int64)+39p

var_F4		= byte ptr -0F4h
Size		= dword	ptr -30h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 15h
		mov	[ebp+var_14], 15h
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+var_14]
		mov	byte ptr [ecx],	0
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_24], eax
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_20], ecx
		cmp	[ebp+arg_4], 0
		jg	short loc_44FE
		jl	short loc_44B8
		cmp	[ebp+arg_0], 0
		jnb	short loc_44FE

loc_44B8:				; CODE XREF: icu_56::formatBase10(__int64,char *)+50j
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax
		push	0
		push	0Ah
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_24]
		push	edx
		call	__allrem
		neg	eax
		adc	edx, 0
		neg	edx
		add	eax, 30h ; '0'
		adc	edx, 0
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+var_14]
		mov	[ecx], al
		push	0FFFFFFFFh
		push	0FFFFFFF6h
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_24]
		push	ecx
		call	__alldiv
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], edx

loc_44FE:				; CODE XREF: icu_56::formatBase10(__int64,char *)+4Ej
					; icu_56::formatBase10(__int64,char *)+56j ...
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax
		push	0
		push	0Ah
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_24]
		push	edx
		call	__allrem
		add	eax, 30h ; '0'
		adc	edx, 0
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+var_14]
		mov	[ecx], al
		push	0
		push	0Ah
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_24]
		push	ecx
		call	__alldiv
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], edx
		cmp	[ebp+var_20], 0
		jg	short loc_44FE
		jl	short loc_454B
		cmp	[ebp+var_24], 0
		ja	short loc_44FE

loc_454B:				; CODE XREF: icu_56::formatBase10(__int64,char *)+E3j
		cmp	[ebp+arg_4], 0
		jg	short loc_456B
		jl	short loc_4559
		cmp	[ebp+arg_0], 0
		jnb	short loc_456B

loc_4559:				; CODE XREF: icu_56::formatBase10(__int64,char *)+F1j
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+var_14]
		mov	byte ptr [ecx],	2Dh ; '-'

loc_456B:				; CODE XREF: icu_56::formatBase10(__int64,char *)+EFj
					; icu_56::formatBase10(__int64,char *)+F7j
		cmp	[ebp+var_14], 0
		jge	short loc_4596
		mov	eax, ds:?__LINE__Var@?1??formatBase10@icu_56@@YAH_JPAD@Z@4JA@2f57b92b
		add	eax, 18h
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1BK@KDFMMPOE@?$AAd?$AAe?$AAs?$AAt?$AAI?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@	; "destIdx >= 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4596:				; CODE XREF: icu_56::formatBase10(__int64,char *)+10Fj
		mov	eax, 15h
		sub	eax, [ebp+var_14]
		mov	[ebp+Size], eax
		push	1
		mov	eax, [ebp+Dst]
		add	eax, 15h
		sub	eax, [ebp+Size]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Dst]
		add	edx, 15h
		sub	edx, [ebp+Size]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+Size]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?formatBase10@icu_56@@YAH_JPAD@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 45F0h
		public ??_C@_1BK@KDFMMPOE@?$AAd?$AAe?$AAs?$AAt?$AAI?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1BK@KDFMMPOE@?$AAd?$AAe?$AAs?$AAt?$AAI?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: icu_56::formatBase10(__int64,char *)+121o
		unicode	0, <destIdx >
		dw 3Eh
		unicode	0, <= 0>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 460Ch
		public ?__LINE__Var@?1??formatBase10@icu_56@@YAH_JPAD@Z@4JA@2f57b92b
?__LINE__Var@?1??formatBase10@icu_56@@YAH_JPAD@Z@4JA@2f57b92b dd offset	word_D2
					; DATA XREF: icu_56::formatBase10(__int64,char *)+111r
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4610h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::setInteger(icu_56::DigitList *this, __int64)
		public ?setInteger@DigitList@icu_56@@QAEX_J@Z
?setInteger@DigitList@icu_56@@QAEX_J@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, dword ptr [ebp+arg_0+4]
		push	eax
		mov	ecx, dword ptr [ebp+arg_0]
		push	ecx		; __int64
		mov	ecx, [ebp+var_8] ; this
		call	?internalSetInt64@DigitList@icu_56@@AAEX_J@Z ; icu_56::DigitList::internalSetInt64(__int64)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setInteger@DigitList@icu_56@@QAEX_J@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4664h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::set(icu_56::DigitList *this, const	struct icu_56::StringPiece *, enum UErrorCode *, unsigned int)
		public ?set@DigitList@icu_56@@QAEXABVStringPiece@2@AAW4UErrorCode@@I@Z
?set@DigitList@icu_56@@QAEXABVStringPiece@2@AAW4UErrorCode@@I@Z	proc near
					; CODE XREF: icu_56::DigitList::fitsIntoLong(signed char)+120p
					; icu_56::DigitList::fitsIntoLong(signed char)+198p ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_46A1
		jmp	loc_474C
; ---------------------------------------------------------------------------

loc_46A1:				; CODE XREF: icu_56::DigitList::set(icu_56::StringPiece	const &,UErrorCode &,uint)+36j
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@StringPiece@icu_56@@QBEHXZ ;	icu_56::StringPiece::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax]
		jle	short loc_4700
		mov	ecx, [ebp+var_8]
		add	ecx, 20h ; ' '
		call	?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getCapacity(void)
		push	eax
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 20h ; ' '
		call	?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jnz	short loc_46EF
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		jmp	short loc_474C
; ---------------------------------------------------------------------------

loc_46EF:				; CODE XREF: icu_56::DigitList::set(icu_56::StringPiece	const &,UErrorCode &,uint)+7Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_20]
		mov	[eax+1Ch], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_4700:				; CODE XREF: icu_56::DigitList::set(icu_56::StringPiece	const &,UErrorCode &,uint)+5Aj
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_8]
		push	eax
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?data@StringPiece@icu_56@@QBEPBDXZ ;	icu_56::StringPiece::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		push	edx
		call	_uprv_decNumberFromString_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		and	ecx, 1
		jz	short loc_4744
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 10110h

loc_4744:				; CODE XREF: icu_56::DigitList::set(icu_56::StringPiece	const &,UErrorCode &,uint)+D5j
		mov	ecx, [ebp+var_8] ; this
		call	?internalClear@DigitList@icu_56@@AAEXXZ	; icu_56::DigitList::internalClear(void)

loc_474C:				; CODE XREF: icu_56::DigitList::set(icu_56::StringPiece	const &,UErrorCode &,uint)+38j
					; icu_56::DigitList::set(icu_56::StringPiece const &,UErrorCode	&,uint)+89j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?set@DigitList@icu_56@@QAEXABVStringPiece@2@AAW4UErrorCode@@I@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4764h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::set(icu_56::DigitList *this, double)
		public ?set@DigitList@icu_56@@QAEXN@Z
?set@DigitList@icu_56@@QAEXN@Z proc near

var_114		= qword	ptr -114h
var_100		= byte ptr -100h
var_3C		= dword	ptr -3Ch
Dest		= byte ptr -30h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+114h+var_114]
		call	_uprv_isInfinite_56
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jz	short loc_47E7
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+114h+var_114]
		call	_uprv_isNegativeInfinity_56
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jz	short loc_47D4
		push	offset ??_C@_04DHEMHBNF@?9inf?$AA@ ; "-inf"
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	_strcpy
		add	esp, 8
		jmp	short loc_47E5
; ---------------------------------------------------------------------------

loc_47D4:				; CODE XREF: icu_56::DigitList::set(double)+5Bj
		push	offset ??_C@_03OJHLLCGB@inf?$AA@ ; "inf"
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	_strcpy
		add	esp, 8

loc_47E5:				; CODE XREF: icu_56::DigitList::set(double)+6Ej
		jmp	short loc_480D
; ---------------------------------------------------------------------------

loc_47E7:				; CODE XREF: icu_56::DigitList::set(double)+43j
		mov	esi, esp
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+114h+var_114]
		push	0Eh
		push	offset ??_C@_06GDIBNGKA@?$CF?$CL1?4?$CKe?$AA@ ;	"%+1.*e"
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	dword ptr ds:__imp__sprintf
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_480D:				; CODE XREF: icu_56::DigitList::set(double):loc_47E5j
		lea	eax, [ebp+Dest]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		cmp	eax, 1Bh
		jb	short loc_4844
		mov	ecx, ds:?__LINE__Var@?1??set@DigitList@icu_56@@QAEXN@Z@4JA ; long `icu_56::DigitList::set(double)'::`2'::__LINE__Var
		add	ecx, 11h
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@KILIOGMG@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\d"...
		push	offset ??_C@_1DK@LDJCKIDC@?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAr?$AAe?$AAp?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAr?$AAe?$AAp?$AA?$CJ?$AA?$AA@ ; ":: strlen(rep) <	sizeof(rep)"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4844:				; CODE XREF: icu_56::DigitList::set(double)+B8j
		push	2Ch ; ','       ; Val
		lea	eax, [ebp+Dest]
		push	eax		; Str
		call	?strchr@@YAPADPADH@Z ; strchr(char *,int)
		add	esp, 8
		mov	[ebp+var_3C], eax
		cmp	[ebp+var_3C], 0
		jz	short loc_4861
		mov	eax, [ebp+var_3C]
		mov	byte ptr [eax],	2Eh ; '.'

loc_4861:				; CODE XREF: icu_56::DigitList::set(double)+F5j
		mov	eax, [ebp+var_C]
		push	eax
		lea	ecx, [ebp+Dest]
		push	ecx
		mov	edx, [ebp+var_C]
		mov	eax, [edx+1Ch]
		push	eax
		call	_uprv_decNumberFromString_56
		add	esp, 0Ch
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberTrim_56
		add	esp, 4
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+114h+var_114] ; double
		mov	ecx, [ebp+var_C] ; this
		call	?internalSetDouble@DigitList@icu_56@@AAEXN@Z ; icu_56::DigitList::internalSetDouble(double)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?set@DigitList@icu_56@@QAEXN@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN11_2		dd 1			; DATA XREF: icu_56::DigitList::set(double)+138o
		dd offset $LN10_1
$LN10_1		dd 0FFFFFFD0h, 1Bh	; DATA XREF: .text:000048D0o
		dd offset $LN9_5
$LN9_5		dd 706572h		; DATA XREF: .text:000048DCo
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48E4h
		public ??_C@_1DK@LDJCKIDC@?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAr?$AAe?$AAp?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAr?$AAe?$AAp?$AA?$CJ?$AA?$AA@
; wchar_t `string'
??_C@_1DK@LDJCKIDC@?$AA?3?$AA?3?$AA?5?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAr?$AAe?$AAp?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAr?$AAe?$AAp?$AA?$CJ?$AA?$AA@:
					; DATA XREF: icu_56::DigitList::set(double)+CBo
		unicode	0, <:: strlen(rep) >
		dw 3Ch
		unicode	0, < sizeof(rep)>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4920h
		public ?__LINE__Var@?1??set@DigitList@icu_56@@QAEXN@Z@4JA
; long `public:	void __thiscall	icu_56::DigitList::set(double)'::`2'::__LINE__Var
?__LINE__Var@?1??set@DigitList@icu_56@@QAEXN@Z@4JA dd 32Eh
					; DATA XREF: icu_56::DigitList::set(double)+BAr
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4924h
		public ??_C@_06GDIBNGKA@?$CF?$CL1?4?$CKe?$AA@
; char `string'[]
??_C@_06GDIBNGKA@?$CF?$CL1?4?$CKe?$AA@ db '%+1.*e',0
					; DATA XREF: icu_56::DigitList::set(double)+90o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 492Ch
		public ??_C@_03OJHLLCGB@inf?$AA@
; char `string'[4]
??_C@_03OJHLLCGB@inf?$AA@ db 'inf',0    ; DATA XREF: icu_56::DigitList::set(double):loc_47D4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4930h
		public ??_C@_04DHEMHBNF@?9inf?$AA@
; char `string'[]
??_C@_04DHEMHBNF@?9inf?$AA@ db '-inf',0 ; DATA XREF: icu_56::DigitList::set(double)+5Do
		align 4
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4938h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::mult(icu_56::DigitList *this, const struct	icu_56::DigitList *, enum UErrorCode *)
		public ?mult@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z
?mult@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DigitList::quantize(icu_56::DigitList const &,UErrorCode &)+64p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4975
		jmp	loc_49F8
; ---------------------------------------------------------------------------

loc_4975:				; CODE XREF: icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+14h], 0
		mov	ecx, [ebp+var_8] ; this
		call	?digits@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::digits(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?digits@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::digits(void)
		add	esi, eax
		mov	[ebp+var_14], esi
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax]
		jle	short loc_49CF
		mov	ecx, [ebp+var_8] ; this
		call	?reduce@DigitList@icu_56@@QAEXXZ ; icu_56::DigitList::reduce(void)
		mov	ecx, [ebp+var_8] ; this
		call	?digits@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::digits(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?digits@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::digits(void)
		add	esi, eax
		mov	[ebp+var_20], esi
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@DigitList@icu_56@@QAEXHAAW4UErrorCode@@@Z ; icu_56::DigitList::ensureCapacity(int,UErrorCode &)

loc_49CF:				; CODE XREF: icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)+66j
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1Ch]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		push	eax
		call	_uprv_decNumberMultiply_56
		add	esp, 10h
		mov	ecx, [ebp+var_8] ; this
		call	?internalClear@DigitList@icu_56@@AAEXXZ	; icu_56::DigitList::internalClear(void)

loc_49F8:				; CODE XREF: icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?mult@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::div(icu_56::DigitList *this, const	struct icu_56::DigitList *, enum UErrorCode *)
		public ?div@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z
?div@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DigitList::quantize(icu_56::DigitList const &,UErrorCode &)+45p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4A4A
		jmp	short loc_4A73
; ---------------------------------------------------------------------------

loc_4A4A:				; CODE XREF: icu_56::DigitList::div(icu_56::DigitList const &,UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1Ch]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		push	eax
		call	_uprv_decNumberDivide_56
		add	esp, 10h
		mov	ecx, [ebp+var_8] ; this
		call	?internalClear@DigitList@icu_56@@AAEXXZ	; icu_56::DigitList::internalClear(void)

loc_4A73:				; CODE XREF: icu_56::DigitList::div(icu_56::DigitList const &,UErrorCode &)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?div@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::ensureCapacity(icu_56::DigitList *this, int, enum UErrorCode *)
		public ?ensureCapacity@DigitList@icu_56@@QAEXHAAW4UErrorCode@@@Z
?ensureCapacity@DigitList@icu_56@@QAEXHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)+92p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4AC6
		jmp	short loc_4B31
; ---------------------------------------------------------------------------

loc_4AC6:				; CODE XREF: icu_56::DigitList::ensureCapacity(int,UErrorCode &)+36j
		cmp	[ebp+arg_0], 0
		jg	short loc_4AD7
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		jmp	short loc_4B31
; ---------------------------------------------------------------------------

loc_4AD7:				; CODE XREF: icu_56::DigitList::ensureCapacity(int,UErrorCode &)+3Ej
		cmp	[ebp+arg_0], 3B9AC9FFh
		jle	short loc_4AE7
		mov	[ebp+arg_0], 3B9AC9FFh

loc_4AE7:				; CODE XREF: icu_56::DigitList::ensureCapacity(int,UErrorCode &)+52j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax]
		jle	short loc_4B31
		mov	ecx, [ebp+var_8]
		add	ecx, 20h ; ' '
		call	?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getCapacity(void)
		push	eax
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 20h ; ' '
		call	?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_4B20
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		jmp	short loc_4B31
; ---------------------------------------------------------------------------

loc_4B20:				; CODE XREF: icu_56::DigitList::ensureCapacity(int,UErrorCode &)+87j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+1Ch], ecx

loc_4B31:				; CODE XREF: icu_56::DigitList::ensureCapacity(int,UErrorCode &)+38j
					; icu_56::DigitList::ensureCapacity(int,UErrorCode &)+49j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?ensureCapacity@DigitList@icu_56@@QAEXHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::round(icu_56::DigitList *this, int)
		public ?round@DigitList@icu_56@@QAEXH@Z
?round@DigitList@icu_56@@QAEXH@Z proc near
					; CODE XREF: icu_56::DigitList::getDouble(void)+201p
					; icu_56::DigitList::roundAtExponent(int,int)+7Fp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?reduce@DigitList@icu_56@@QAEXXZ ; icu_56::DigitList::reduce(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+arg_0]
		cmp	edx, [ecx]
		jl	short loc_4B82
		jmp	short loc_4BD3
; ---------------------------------------------------------------------------

loc_4B82:				; CODE XREF: icu_56::DigitList::round(int)+36j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberPlus_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberTrim_56
		add	esp, 4
		mov	ecx, [ebp+var_8] ; this
		call	?reduce@DigitList@icu_56@@QAEXXZ ; icu_56::DigitList::reduce(void)
		mov	ecx, [ebp+var_8] ; this
		call	?internalClear@DigitList@icu_56@@AAEXXZ	; icu_56::DigitList::internalClear(void)

loc_4BD3:				; CODE XREF: icu_56::DigitList::round(int)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?round@DigitList@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4BECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::roundFixedPoint(icu_56::DigitList *this, int)
		public ?roundFixedPoint@DigitList@icu_56@@QAEXH@Z
?roundFixedPoint@DigitList@icu_56@@QAEXH@Z proc	near
					; CODE XREF: icu_56::DigitList::roundAtExponent(int,int)+8Fp

var_E4		= byte ptr -0E4h
var_20		= byte ptr -20h
var_1C		= dword	ptr -1Ch
var_17		= byte ptr -17h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		mov	ecx, [ebp+var_C] ; this
		call	?reduce@DigitList@icu_56@@QAEXXZ ; icu_56::DigitList::reduce(void)
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+arg_0]
		neg	edx
		cmp	[ecx+4], edx
		jl	short loc_4C33
		jmp	short loc_4C79
; ---------------------------------------------------------------------------

loc_4C33:				; CODE XREF: icu_56::DigitList::roundFixedPoint(int)+43j
		lea	eax, [ebp+var_20]
		push	eax
		call	_uprv_decNumberZero_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		neg	eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_17], 1
		mov	eax, [ebp+var_C]
		push	eax
		lea	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_C]
		mov	eax, [edx+1Ch]
		push	eax
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx+1Ch]
		push	edx
		call	_uprv_decNumberQuantize_56
		add	esp, 10h
		mov	ecx, [ebp+var_C] ; this
		call	?reduce@DigitList@icu_56@@QAEXXZ ; icu_56::DigitList::reduce(void)
		mov	ecx, [ebp+var_C] ; this
		call	?internalClear@DigitList@icu_56@@AAEXXZ	; icu_56::DigitList::internalClear(void)

loc_4C79:				; CODE XREF: icu_56::DigitList::roundFixedPoint(int)+45j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?roundFixedPoint@DigitList@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN6_3		dd 1			; DATA XREF: icu_56::DigitList::roundFixedPoint(int)+91o
		dd offset $LN5_2
$LN5_2		dd 0FFFFFFE0h, 0Ch	; DATA XREF: .text:00004CB0o
		dd offset $LN4_1	; "scale"
$LN4_1		db 'scale',0            ; DATA XREF: .text:00004CBCo
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::toIntegralValue(icu_56::DigitList *__hidden this)
		public ?toIntegralValue@DigitList@icu_56@@QAEXXZ
?toIntegralValue@DigitList@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberToIntegralValue_56
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?toIntegralValue@DigitList@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::isZero(icu_56::DigitList *__hidden this)
		public ?isZero@DigitList@icu_56@@QBECXZ
?isZero@DigitList@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::DigitList::getDouble(void)+12Ep
					; icu_56::DigitList::getScientificExponent(int,int)+26p

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+9]
		test	edx, edx
		jnz	short loc_4D70
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		cmp	dword ptr [ecx], 1
		jnz	short loc_4D70
		mov	edx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		movzx	ecx, byte ptr [eax+8]
		and	ecx, 70h
		jnz	short loc_4D70
		mov	[ebp+var_CD], 1
		jmp	short loc_4D77
; ---------------------------------------------------------------------------

loc_4D70:				; CODE XREF: icu_56::DigitList::isZero(void)+2Fj
					; icu_56::DigitList::isZero(void)+3Aj ...
		mov	[ebp+var_CD], 0

loc_4D77:				; CODE XREF: icu_56::DigitList::isZero(void)+52j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isZero@DigitList@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::getUpperExponent(icu_56::DigitList *__hidden this)
		public ?getUpperExponent@DigitList@icu_56@@QBEHXZ
?getUpperExponent@DigitList@icu_56@@QBEHXZ proc	near
					; CODE XREF: icu_56::DigitList::getLong(void)+4Fp
					; icu_56::DigitList::getInt64(void)+3Dp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		mov	ecx, [ecx]
		add	ecx, [eax+4]
		mov	eax, ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getUpperExponent@DigitList@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4DC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::DigitInterval *__thiscall icu_56::DigitList::getSmallestInterval(icu_56::DigitList *this, struct icu_56::DigitInterval	*)
		public ?getSmallestInterval@DigitList@icu_56@@QBEAAVDigitInterval@2@AAV32@@Z
?getSmallestInterval@DigitList@icu_56@@QBEAAVDigitInterval@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx+4]
		push	edx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?setLeastSignificantInclusive@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::setLeastSignificantInclusive(int)
		mov	ecx, [ebp+var_8] ; this
		call	?getUpperExponent@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getUpperExponent(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?setMostSignificantExclusive@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::setMostSignificantExclusive(int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getSmallestInterval@DigitList@icu_56@@QBEAAVDigitInterval@2@AAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int8 __thiscall icu_56::DigitList::getDigitByExponent(icu_56::DigitList *this, int)
		public ?getDigitByExponent@DigitList@icu_56@@QBEEH@Z
?getDigitByExponent@DigitList@icu_56@@QBEEH@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+arg_0]
		sub	edx, [ecx+4]
		mov	[ebp+var_14], edx
		js	short loc_4E65
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+var_14]
		cmp	edx, [ecx]
		jl	short loc_4E69

loc_4E65:				; CODE XREF: icu_56::DigitList::getDigitByExponent(int)+32j
		xor	al, al
		jmp	short loc_4E76
; ---------------------------------------------------------------------------

loc_4E69:				; CODE XREF: icu_56::DigitList::getDigitByExponent(int)+3Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+var_14]
		mov	al, [ecx+edx+9]

loc_4E76:				; CODE XREF: icu_56::DigitList::getDigitByExponent(int)+43j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getDigitByExponent@DigitList@icu_56@@QBEEH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::appendDigitsTo(icu_56::DigitList *this, struct icu_56::CharString *, enum UErrorCode *)
		public ?appendDigitsTo@DigitList@icu_56@@QBEXAAVCharString@2@AAW4UErrorCode@@@Z
?appendDigitsTo@DigitList@icu_56@@QBEXAAVCharString@2@AAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		mov	eax, [edx]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		add	edx, 9
		push	edx		; char *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z ;	icu_56::CharString::append(char	const *,int,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?appendDigitsTo@DigitList@icu_56@@QBEXAAVCharString@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4EE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::roundAtExponent(icu_56::DigitList *this, int, int)
		public ?roundAtExponent@DigitList@icu_56@@QAEXHH@Z
?roundAtExponent@DigitList@icu_56@@QAEXHH@Z proc near
					; CODE XREF: icu_56::DigitList::quantize(icu_56::DigitList const &,UErrorCode &)+54p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?reduce@DigitList@icu_56@@QAEXXZ ; icu_56::DigitList::reduce(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx]
		jge	short loc_4F38
		mov	ecx, [ebp+var_8] ; this
		call	?getUpperExponent@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getUpperExponent(void)
		sub	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_14]
		jge	short loc_4F38
		mov	eax, [ebp+var_14]
		mov	[ebp+arg_0], eax

loc_4F38:				; CODE XREF: icu_56::DigitList::roundAtExponent(int,int)+36j
					; icu_56::DigitList::roundAtExponent(int,int)+4Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ebp+arg_0]
		cmp	edx, [ecx+4]
		jg	short loc_4F48
		jmp	short loc_4F78
; ---------------------------------------------------------------------------

loc_4F48:				; CODE XREF: icu_56::DigitList::roundAtExponent(int,int)+60j
		mov	ecx, [ebp+var_8] ; this
		call	?getUpperExponent@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getUpperExponent(void)
		sub	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jle	short loc_4F6A
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?round@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::round(int)
		jmp	short loc_4F78
; ---------------------------------------------------------------------------

loc_4F6A:				; CODE XREF: icu_56::DigitList::roundAtExponent(int,int)+76j
		mov	eax, [ebp+arg_0]
		neg	eax
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?roundFixedPoint@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::roundFixedPoint(int)

loc_4F78:				; CODE XREF: icu_56::DigitList::roundAtExponent(int,int)+62j
					; icu_56::DigitList::roundAtExponent(int,int)+84j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?roundAtExponent@DigitList@icu_56@@QAEXHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::quantize(icu_56::DigitList	*this, const struct icu_56::DigitList *, enum UErrorCode *)
		public ?quantize@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z
?quantize@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4FCA
		jmp	short loc_5001
; ---------------------------------------------------------------------------

loc_4FCA:				; CODE XREF: icu_56::DigitList::quantize(icu_56::DigitList const &,UErrorCode &)+36j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_8] ; this
		call	?div@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z ; icu_56::DigitList::div(icu_56::DigitList const &,UErrorCode &)
		push	7FFFFFFFh	; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?roundAtExponent@DigitList@icu_56@@QAEXHH@Z ; icu_56::DigitList::roundAtExponent(int,int)
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_8] ; this
		call	?mult@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z ; icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)
		mov	ecx, [ebp+var_8] ; this
		call	?reduce@DigitList@icu_56@@QAEXXZ ; icu_56::DigitList::reduce(void)

loc_5001:				; CODE XREF: icu_56::DigitList::quantize(icu_56::DigitList const &,UErrorCode &)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?quantize@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5018h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::getScientificExponent(icu_56::DigitList *this, int,	int)
		public ?getScientificExponent@DigitList@icu_56@@QBEHHH@Z
?getScientificExponent@DigitList@icu_56@@QBEHHH@Z proc near
					; CODE XREF: icu_56::DigitList::toScientific(int,int)+2Ep

var_FC		= byte ptr -0FCh
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isZero@DigitList@icu_56@@QBECXZ ; icu_56::DigitList::isZero(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_504E
		xor	eax, eax
		jmp	short loc_509F
; ---------------------------------------------------------------------------

loc_504E:				; CODE XREF: icu_56::DigitList::getScientificExponent(int,int)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?getUpperExponent@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getUpperExponent(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jl	short loc_507A
		mov	eax, [ebp+var_14]
		sub	eax, [ebp+arg_0]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		cdq
		idiv	[ebp+arg_4]
		imul	eax, [ebp+arg_4]
		mov	[ebp+var_20], eax
		jmp	short loc_509C
; ---------------------------------------------------------------------------

loc_507A:				; CODE XREF: icu_56::DigitList::getScientificExponent(int,int)+47j
		mov	eax, [ebp+arg_0]
		sub	eax, [ebp+var_14]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_38]
		lea	eax, [ecx+eax-1]
		cdq
		idiv	[ebp+arg_4]
		mov	edx, [ebp+arg_4]
		neg	edx
		imul	eax, edx
		mov	[ebp+var_20], eax

loc_509C:				; CODE XREF: icu_56::DigitList::getScientificExponent(int,int)+60j
		mov	eax, [ebp+var_20]

loc_509F:				; CODE XREF: icu_56::DigitList::getScientificExponent(int,int)+34j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getScientificExponent@DigitList@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 50B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::toScientific(icu_56::DigitList *this, int, int)
		public ?toScientific@DigitList@icu_56@@QAEHHH@Z
?toScientific@DigitList@icu_56@@QAEHHH@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getScientificExponent@DigitList@icu_56@@QBEHHH@Z ; icu_56::DigitList::getScientificExponent(int,int)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		neg	eax
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::shiftDecimalRight(int)
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?toScientific@DigitList@icu_56@@QAEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5118h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::shiftDecimalRight(icu_56::DigitList *this,	int)
		public ?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z
?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z proc near
					; CODE XREF: icu_56::DigitList::toScientific(int,int)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	edx, [ecx+4]
		add	edx, [ebp+arg_0]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	[ecx+4], edx
		mov	ecx, [ebp+var_8] ; this
		call	?internalClear@DigitList@icu_56@@AAEXXZ	; icu_56::DigitList::internalClear(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5170h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>(void)
		public ??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 51A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>(class	icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099> const	&)
		public ??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@ABV01@@Z
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 51E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::~EnumSet<enum  UNumberFormatAttribute, 4096, 4099>(void)
		public ??1?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ
??1?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5210h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::clear(void)
		public ?clear@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXXZ
?clear@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5244h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::add(enum  UNumberFormatAttribute)
		public ?add@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z
?add@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?add@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 528Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::remove(enum  UNumberFormatAttribute)
		public ?remove@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z
?remove@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?remove@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 52D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::contains(enum  UNumberFormatAttribute)const
		public ?contains@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z
?contains@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::get(UNumberFormatAttribute)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 531Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::set(enum  UNumberFormatAttribute, int)
		public ?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z
?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z proc near
					; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::add(UNumberFormatAttribute)+2Cp
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::remove(UNumberFormatAttribute)+2Cp

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jz	short loc_5359
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::flag(UNumberFormatAttribute)
		mov	[ebp+var_D0], eax
		jmp	short loc_5363
; ---------------------------------------------------------------------------

loc_5359:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+27j
		mov	[ebp+var_D0], 0

loc_5363:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+3Bj
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::flag(UNumberFormatAttribute)
		not	eax
		mov	edx, [ebp+var_8]
		and	eax, [edx]
		or	eax, [ebp+var_D0]
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5398h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::get(enum  UNumberFormatAttribute)const
		public ?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z
?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z proc near
					; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::contains(UNumberFormatAttribute)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::flag(UNumberFormatAttribute)
		mov	ecx, [ebp+var_8]
		and	eax, [ecx]
		neg	eax
		sbb	eax, eax
		neg	eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 53E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::isValidEnum(enum  UNumberFormatAttribute)const
		public ?isValidEnum@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECW4UNumberFormatAttribute@@@Z
?isValidEnum@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECW4UNumberFormatAttribute@@@Z proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 1000h
		jb	short loc_5426
		cmp	[ebp+arg_0], 1003h
		jnb	short loc_5426
		mov	[ebp+var_CD], 1
		jmp	short loc_542D
; ---------------------------------------------------------------------------

loc_5426:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidEnum(UNumberFormatAttribute)+2Aj
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidEnum(UNumberFormatAttribute)+33j
		mov	[ebp+var_CD], 0

loc_542D:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidEnum(UNumberFormatAttribute)+3Cj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?isValidEnum@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECW4UNumberFormatAttribute@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 543Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::isValidValue(int)const
		public ?isValidValue@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECH@Z
?isValidValue@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECH@Z proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_5474
		cmp	[ebp+arg_0], 1
		jz	short loc_5474
		mov	[ebp+var_CD], 0
		jmp	short loc_547B
; ---------------------------------------------------------------------------

loc_5474:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidValue(int)+27j
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidValue(int)+2Dj
		mov	[ebp+var_CD], 1

loc_547B:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidValue(int)+36j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?isValidValue@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 548Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099> const	& __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::operator=(class	icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099> const	&)
		public ??4?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEABV01@ABV01@@Z
??4?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEABV01@ABV01@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEABV01@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::getAll(void)const
		public ?getAll@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEIXZ
?getAll@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEIXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAll@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: unsigned int	__thiscall icu_56::EnumSet<enum	 UNumberFormatAttribute, 4096, 4099>::flag(enum	 UNumberFormatAttribute)const
		public ?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z
?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z proc near
					; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+30p
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+4Ep ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		sub	ecx, 1000h
		mov	eax, 1
		shl	eax, cl
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5534h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber,	char, 40>::MaybeStackHeaderAndArray<struct decNumber, char, 40>(void)
		public ??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::DigitList::DigitList(void)+48p
					; icu_56::DigitList::DigitList(icu_56::DigitList const &)+48p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 0Ch
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 28h ; '('
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5580h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber,	char, 40>::~MaybeStackHeaderAndArray<struct decNumber, char, 40>(void)
		public ??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ
??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	proc near
					; CODE XREF: __unwindfunclet$??0DigitList@icu_56@@QAE@XZ$0+6j
					; icu_56::DigitList::~DigitList(void)+29p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 55C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::getCapacity(void)const
		public ?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ
?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::DigitList::DigitList(void)+80p
					; icu_56::DigitList::operator=(icu_56::DigitList const &)+55p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 55F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct decNumber * __thiscall	icu_56::MaybeStackHeaderAndArray<struct	decNumber, char, 40>::getAlias(void)const
		public ?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ
?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ proc near
					; CODE XREF: icu_56::DigitList::DigitList(void)+90p
					; icu_56::DigitList::DigitList(icu_56::DigitList const &)+5Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5620h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::getArrayStart(void)const
		public ?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ
?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ proc near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getArrayLimit(void)+26p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::operator[](int)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getAlias(void)
		add	eax, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5664h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::getArrayLimit(void)const
		public ?getArrayLimit@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ
?getArrayLimit@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ ;	icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getArrayStart(void)
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getArrayLimit@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 56ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber,	char, 40>::operator struct decNumber *(void)const
		public ??B?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ
??B?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??B?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 56DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char & __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator[](int)
		public ??A?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEAADH@Z
??A?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEAADH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ ;	icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getArrayStart(void)
		add	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEAADH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5720h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::aliasInstead(struct decNumber *, int)
		public ?aliasInstead@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEXPAUdecNumber@@H@Z
?aliasInstead@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEXPAUdecNumber@@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_576F
		cmp	[ebp+arg_4], 0
		jle	short loc_576F
		mov	ecx, [ebp+var_8]
		call	?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0

loc_576F:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::aliasInstead(decNumber *,int)+27j
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::aliasInstead(decNumber *,int)+2Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?aliasInstead@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEXPAUdecNumber@@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5788h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::releaseMemory(void)
		public ?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ
?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::~MaybeStackHeaderAndArray<decNumber,char,40>(void)+26p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::aliasInstead(decNumber *,int)+32p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_57C4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_57C4:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)+2Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 57D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: bool	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator==(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40> const &)
		public ??8?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z
??8?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	al, al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5808h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: bool	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator!=(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40> const &)
		public ??9?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z
??9?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	al, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??9?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5838h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::MaybeStackHeaderAndArray<struct decNumber, char, 40>(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char,	40> const &)
		public ??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE@ABV01@@Z
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5868h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator=(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40> const &)
		public ??4?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXABV01@@Z
??4?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5894h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackArray<char, 33>::MaybeStackArray<char, 33>(void)
		public ??0?$MaybeStackArray@D$0CB@@icu_56@@QAE@XZ
??0?$MaybeStackArray@D$0CB@@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::DigitList::getDouble(void)+1C2p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 9
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 21h ; '!'
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0?$MaybeStackArray@D$0CB@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 58E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackArray<char, 33>::~MaybeStackArray<char, 33>(void)
		public ??1?$MaybeStackArray@D$0CB@@icu_56@@QAE@XZ
??1?$MaybeStackArray@D$0CB@@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::DigitList::getDouble(void)+305p
					; __unwindfunclet$?getDouble@DigitList@icu_56@@QBENXZ$1+6j

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?releaseArray@?$MaybeStackArray@D$0CB@@icu_56@@AAEXXZ ;	icu_56::MaybeStackArray<char,33>::releaseArray(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$MaybeStackArray@D$0CB@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5920h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::MaybeStackArray<char, 33>::getAlias(void)const
		public ?getAlias@?$MaybeStackArray@D$0CB@@icu_56@@QBEPADXZ
?getAlias@?$MaybeStackArray@D$0CB@@icu_56@@QBEPADXZ proc near
					; CODE XREF: icu_56::DigitList::getDouble(void)+20Cp
					; icu_56::DigitList::getDouble(void)+238p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$MaybeStackArray@D$0CB@@icu_56@@QBEPADXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5950h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char & __thiscall icu_56::MaybeStackArray<char, 33>::operator[](int)
		public ??A?$MaybeStackArray@D$0CB@@icu_56@@QAEAADH@Z
??A?$MaybeStackArray@D$0CB@@icu_56@@QAEAADH@Z proc near
					; CODE XREF: icu_56::DigitList::getDouble(void)+255p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		add	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$MaybeStackArray@D$0CB@@icu_56@@QAEAADH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5984h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackArray<char, 33>::releaseArray(void)
		public ?releaseArray@?$MaybeStackArray@D$0CB@@icu_56@@AAEXXZ
?releaseArray@?$MaybeStackArray@D$0CB@@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::MaybeStackArray<char,33>::~MaybeStackArray<char,33>(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_59C0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_59C0:				; CODE XREF: icu_56::MaybeStackArray<char,33>::releaseArray(void)+2Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?releaseArray@?$MaybeStackArray@D$0CB@@icu_56@@AAEXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 59D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct decNumber * __thiscall	icu_56::MaybeStackHeaderAndArray<struct	decNumber, char, 40>::resize(int, int)
		public ?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z
?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z proc near
					; CODE XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+7Fp
					; icu_56::DigitList::set(icu_56::StringPiece const &,UErrorCode	&,uint)+72p ...

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	loc_5AA4
		mov	eax, [ebp+arg_0]
		add	eax, 0Ch
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jz	loc_5A9D
		cmp	[ebp+arg_4], 0
		jge	short loc_5A2C
		mov	[ebp+arg_4], 0
		jmp	short loc_5A54
; ---------------------------------------------------------------------------

loc_5A2C:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+4Dj
		cmp	[ebp+arg_4], 0
		jle	short loc_5A54
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jle	short loc_5A46
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_4], ecx

loc_5A46:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+67j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_0]
		jle	short loc_5A54
		mov	eax, [ebp+arg_0]
		mov	[ebp+arg_4], eax

loc_5A54:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+56j
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+5Cj ...
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+arg_4]
		add	edx, 0Ch
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	ecx, [ebp+var_8]
		call	?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Dst]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 1

loc_5A9D:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+43j
		mov	eax, [ebp+Dst]
		jmp	short loc_5AA6
; ---------------------------------------------------------------------------
		jmp	short loc_5AA6
; ---------------------------------------------------------------------------

loc_5AA4:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+27j
		xor	eax, eax

loc_5AA6:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+CCj
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+CEj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct decNumber * __thiscall	icu_56::MaybeStackHeaderAndArray<struct	decNumber, char, 40>::orphanOrClone(int, int &)
		public ?orphanOrClone@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HAAH@Z
?orphanOrClone@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HAAH@Z proc near

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_5AF4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+Dst], ecx
		jmp	short loc_5B5C
; ---------------------------------------------------------------------------

loc_5AF4:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+2Cj
		cmp	[ebp+arg_0], 0
		jge	short loc_5B03
		mov	[ebp+arg_0], 0
		jmp	short loc_5B17
; ---------------------------------------------------------------------------

loc_5B03:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+3Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_5B17
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_5B17:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+45j
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int &)+50j
		mov	eax, [ebp+arg_0]
		add	eax, 0Ch
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_5B33
		xor	eax, eax
		jmp	short loc_5B83
; ---------------------------------------------------------------------------

loc_5B33:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+71j
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+arg_0]
		add	edx, 0Ch
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_5B5C:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+36j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		add	eax, 0Ch
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 28h ; '('
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+Dst]

loc_5B83:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+75j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?orphanOrClone@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HAAH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; public: signed char __thiscall icu_56::DecimalFormatSymbols::operator==(class	icu_56::DecimalFormatSymbols const &)const
		extrn ??8DecimalFormatSymbols@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::operator!=(icu_56::DecimalFormatSymbols const &)+2Ap
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::DecimalFormatSymbols::operator!=(icu_56::DecimalFormatSymbols const &)+42p
					; icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+61p ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn __imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+59p
					; icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+79p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+17Cp
					; __unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0+8p
					; DATA XREF: ...
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString &&)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+160p
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+160r
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@H@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+120p
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+120r
		extrn _u_charDigitValue_56:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+E0p
; int __thiscall icu_56::UnicodeString::char32At(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?char32At@UnicodeString@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+CCp
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+CCr
; int __thiscall icu_56::UnicodeString::countChar32(icu_56::UnicodeString *__hidden this, int, int)
		extrn __imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+AFp
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+AFr
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString const &)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+80p
					; icu_56::Formattable::getString(icu_56::UnicodeString &)+2Fp
					; DATA XREF: ...
		extrn ___security_cookie:near
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+2Er
					; icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+23j
					; __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z+19j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+1A1p
					; __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+Fp ...
; _DWORD __thiscall icu_56::Locale::Locale(icu_56::Locale *__hidden this, const	struct icu_56::Locale *)
		extrn __imp_??0Locale@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::getLocale(void)+3Bp
					; DATA XREF: icu_56::DecimalFormatSymbols::getLocale(void)+3Br
; public: signed char __thiscall icu_56::Formattable::operator==(class icu_56::Formattable const &)const
		extrn ??8Formattable@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::Formattable::operator!=(icu_56::Formattable const &)+2Ap
		extrn __fltused:near
; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *__hidden this, enum UErrorCode *)
		extrn ?getLong@Formattable@icu_56@@QBEHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::Formattable::getLong(UErrorCode *)+2Ap
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		extrn __imp_??0UObject@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::FieldPosition::FieldPosition(void)+28p
					; icu_56::FieldPosition::FieldPosition(int)+28p ...
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::FieldPosition `RTTI Type Descriptor'o
					; .data:icu_56::UObject	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::FieldPosition::getDynamicClassID(void)const
		extrn ?getDynamicClassID@FieldPosition@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000A68o
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this, const struct icu_56::UObject *)
		extrn __imp_??0UObject@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition	const &)+2Cp
					; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)+2Cp
					; DATA XREF: ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+39p
					; icu_56::FieldPosition::`vector deleting destructor'(uint)+81p ...
; _DWORD __thiscall icu_56::FieldPosition::~FieldPosition(icu_56::FieldPosition	*__hidden this)
		extrn ??1FieldPosition@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+26p
					; icu_56::FieldPosition::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn __imp_??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+53p
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+53p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+3Dp
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+3Dp ...
; public: signed char __thiscall icu_56::FieldPositionIterator::operator==(class icu_56::FieldPositionIterator const &)const
		extrn ??8FieldPositionIterator@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::FieldPositionIterator::operator!=(icu_56::FieldPositionIterator const &)+2Ap
; __declspec(dllimport)	public:	class icu_56::UObject &	__thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		extrn __imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::FieldPositionIterator::operator=(icu_56::FieldPositionIterator const &)+2Cp
					; icu_56::NumberFormatFactory::operator=(icu_56::NumberFormatFactory const &)+2Cp
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::MeasureUnit::getDynamicClassID(void)const
		extrn ?getDynamicClassID@MeasureUnit@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000011E8o
; public: virtual class	icu_56::UObject	* __thiscall icu_56::MeasureUnit::clone(void)const
		extrn ?clone@MeasureUnit@icu_56@@UBEPAVUObject@2@XZ:near
					; DATA XREF: .rdata:000011ECo
; public: virtual signed char __thiscall icu_56::MeasureUnit::operator==(class icu_56::UObject const &)const
		extrn ??8MeasureUnit@icu_56@@UBECABVUObject@1@@Z:near
					; DATA XREF: .rdata:000011F0o
; _DWORD __thiscall icu_56::MeasureUnit::~MeasureUnit(icu_56::MeasureUnit *__hidden this)
		extrn ??1MeasureUnit@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::MeasureUnit::`scalar deleting destructor'(uint)+26p
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+6Ep
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:0000155Co
					; .rdata:0000188Co
		extrn __purecall:near	; DATA XREF: .rdata:00001560o
					; .rdata:00001564o ...
; _DWORD __thiscall icu_56::NumberFormatFactory::~NumberFormatFactory(icu_56::NumberFormatFactory *__hidden this)
		extrn ??1NumberFormatFactory@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::NumberFormatFactory::`scalar deleting destructor'(uint)+26p
					; icu_56::NumberFormatFactory::`vector deleting	destructor'(uint)+6Ep ...
; public: virtual signed char __thiscall icu_56::SimpleNumberFormatFactory::visible(void)const
		extrn ?visible@SimpleNumberFormatFactory@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00001890o
; public: virtual class	icu_56::UnicodeString const * __thiscall icu_56::SimpleNumberFormatFactory::getSupportedIDs(int	&, enum	 UErrorCode &)const
		extrn ?getSupportedIDs@SimpleNumberFormatFactory@icu_56@@UBEPBVUnicodeString@2@AAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00001894o
; _DWORD __thiscall icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory *__hidden this)
		extrn ??1SimpleNumberFormatFactory@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::SimpleNumberFormatFactory::`scalar	deleting destructor'(uint)+26p
					; icu_56::SimpleNumberFormatFactory::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
		extrn _uprv_decNumberZero_56:near
					; CODE XREF: icu_56::DigitList::setToZero(void)+2Ap
					; icu_56::DigitList::DigitList(void)+A2p ...
		extrn _uprv_decContextSetRounding_56:near
					; CODE XREF: icu_56::DigitList::DigitList(void)+72p
					; icu_56::DigitList::clear(void)+38p ...
		extrn _uprv_decContextDefault_56:near
					; CODE XREF: icu_56::DigitList::DigitList(void)+5Ap
					; icu_56::DigitList::operator==(icu_56::DigitList const	&)+3Fp
; _DWORD __thiscall icu_56::Mutex::~Mutex(icu_56::Mutex	*__hidden this)
		extrn __imp_??1Mutex@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+107p
					; icu_56::DigitList::getStrtodDecimalSeparator(void)+82p ...
; _DWORD __thiscall icu_56::Mutex::Mutex(icu_56::Mutex *__hidden this, struct UMutex *)
		extrn __imp_??0Mutex@icu_56@@QAE@PAUUMutex@@@Z:near
					; CODE XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+B7p
					; icu_56::DigitList::getStrtodDecimalSeparator(void)+2Fp ...
		extrn _uprv_decNumberCopy_56:near
					; CODE XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+A8p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+47p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+A1p ...
		extrn _uprv_checkValidMemory:near
					; CODE XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+35p
					; icu_56::formatBase10(__int64,char *)+14Dp ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::DigitList::operator=(icu_56::DigitList const &)+121p
					; icu_56::DigitList::operator==(icu_56::DigitList const	&)+B0p	...
		extrn _uprv_decNumberCompare_56:near
					; CODE XREF: icu_56::DigitList::operator==(icu_56::DigitList const &)+6Bp
					; icu_56::DigitList::compare(icu_56::DigitList const &)+54p
		extrn _uprv_decNumberReduce_56:near
					; CODE XREF: icu_56::DigitList::reduce(void)+35p
		extrn _uprv_decNumberTrim_56:near
					; CODE XREF: icu_56::DigitList::trim(void)+2Ap
					; icu_56::DigitList::fitsIntoLong(signed char)+62p ...
		extrn _uprv_decContextGetRounding_56:near
					; CODE XREF: icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)+8Ep
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near
					; CODE XREF: icu_56::DigitList::setDecimalAt(int)+47p
					; icu_56::DigitList::setDecimalAt(int)+7Ap ...
; int _sprintf(char *Dest, const char *Format, ...)
		extrn __imp__sprintf:near
					; CODE XREF: icu_56::DigitList::getStrtodDecimalSeparator(void)+5Fp
					; icu_56::DigitList::getDouble(void)+110p ...
; double __cdecl _strtod(const char *Str, char **EndPtr)
		extrn __imp__strtod:near
					; CODE XREF: icu_56::DigitList::getDouble(void)+2E5p
					; DATA XREF: icu_56::DigitList::getDouble(void)+2E5r
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: icu_56::DigitList::getDouble(void)+25Bp
					; icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode	&)+E5p	...
		extrn _uprv_decNumberToString_56:near
					; CODE XREF: icu_56::DigitList::getDouble(void)+219p
					; icu_56::DigitList::getDouble(void)+245p ...
; __declspec(dllimport)	public:	static double __cdecl std::numeric_limits<double>::max(void)
		extrn __imp_?max@?$numeric_limits@N@std@@SANXZ:near
					; CODE XREF: icu_56::DigitList::getDouble(void)+190p
					; DATA XREF: icu_56::DigitList::getDouble(void)+190r
; __declspec(dllimport)	public:	static double __cdecl std::numeric_limits<double>::infinity(void)
		extrn __imp_?infinity@?$numeric_limits@N@std@@SANXZ:near
					; CODE XREF: icu_56::DigitList::getDouble(void)+17Cp
					; DATA XREF: icu_56::DigitList::getDouble(void)+17Cr
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: strchr(char *,int)+28p
					; DATA XREF: strchr(char *,int)+28r
		extrn _uprv_decNumberToInt32_56:near
					; CODE XREF: icu_56::DigitList::getLong(void)+B1p
					; icu_56::DigitList::getLong(void)+E6p
		extrn _uprv_decNumberQuantize_56:near
					; CODE XREF: icu_56::DigitList::getLong(void)+A1p
					; icu_56::DigitList::roundFixedPoint(int)+75p
		extrn __allmul:near	; CODE XREF: icu_56::DigitList::getInt64(void)+CBp
; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *__hidden	this, const char *, int, enum UErrorCode *)
		extrn __imp_?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+127p
					; icu_56::DigitList::appendDigitsTo(icu_56::CharString &,UErrorCode &)+3Fp
					; DATA XREF: ...
; char *__thiscall icu_56::CharString::getAppendBuffer(icu_56::CharString *__hidden this, int, int, int	*, enum	UErrorCode *)
		extrn __imp_?getAppendBuffer@CharString@icu_56@@QAEPADHHAAHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+76p
					; DATA XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+76r
; struct icu_56::CharString *__thiscall	icu_56::CharString::clear(icu_56::CharString *__hidden this)
		extrn __imp_?clear@CharString@icu_56@@QAEAAV12@XZ:near
					; CODE XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+67p
					; DATA XREF: icu_56::DigitList::getDecimal(icu_56::CharString &,UErrorCode &)+67r
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const char *)
		extrn __imp_??0StringPiece@icu_56@@QAE@PBD@Z:near
					; CODE XREF: icu_56::DigitList::fitsIntoLong(signed char)+100p
					; icu_56::DigitList::fitsIntoLong(signed char)+178p ...
		extrn _uprv_decNumberFromString_56:near
					; CODE XREF: icu_56::DigitList::set(__int64)+87p
					; icu_56::DigitList::set(icu_56::StringPiece const &,UErrorCode	&,uint)+C4p ...
; void *__cdecl	_memmove(void *Dst, const void *Src, size_t Size)
		extrn __imp__memmove:near
					; CODE XREF: icu_56::formatBase10(__int64,char *)+169p
					; DATA XREF: icu_56::formatBase10(__int64,char *)+169r
		extrn __alldiv:near	; CODE XREF: icu_56::formatBase10(__int64,char *)+93p
					; icu_56::formatBase10(__int64,char *)+D2p
		extrn __allrem:near	; CODE XREF: icu_56::formatBase10(__int64,char *)+6Dp
					; icu_56::formatBase10(__int64,char *)+B3p
; const	char *__thiscall icu_56::StringPiece::data(icu_56::StringPiece *__hidden this)
		extrn __imp_?data@StringPiece@icu_56@@QBEPBDXZ:near
					; CODE XREF: icu_56::DigitList::set(icu_56::StringPiece	const &,UErrorCode &,uint)+AFp
					; DATA XREF: icu_56::DigitList::set(icu_56::StringPiece	const &,UErrorCode &,uint)+AFr
; int __thiscall icu_56::StringPiece::length(icu_56::StringPiece *__hidden this)
		extrn __imp_?length@StringPiece@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::DigitList::set(icu_56::StringPiece	const &,UErrorCode &,uint)+42p
					; DATA XREF: icu_56::DigitList::set(icu_56::StringPiece	const &,UErrorCode &,uint)+42r
; char *__cdecl	strcpy(char *Dest, const char *Source)
		extrn _strcpy:near	; CODE XREF: icu_56::DigitList::set(double)+66p
					; icu_56::DigitList::set(double)+79p
		extrn _uprv_isNegativeInfinity_56:near
					; CODE XREF: icu_56::DigitList::set(double)+4Ep
		extrn _uprv_isInfinite_56:near
					; CODE XREF: icu_56::DigitList::set(double)+36p
		extrn _uprv_decNumberMultiply_56:near
					; CODE XREF: icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)+B0p
		extrn _uprv_decNumberDivide_56:near
					; CODE XREF: icu_56::DigitList::div(icu_56::DigitList const &,UErrorCode &)+53p
		extrn _uprv_decNumberPlus_56:near
					; CODE XREF: icu_56::DigitList::round(int)+5Cp
		extrn _uprv_decNumberToIntegralValue_56:near
					; CODE XREF: icu_56::DigitList::toIntegralValue(void)+35p
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)+34p
					; icu_56::MaybeStackArray<char,33>::releaseArray(void)+34p
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+34p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int &)+62p


		end
