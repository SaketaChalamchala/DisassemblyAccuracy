;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	8136883C280720556586DFBA33EACF9E
; Input	CRC32 :	09406FA3

; File Name   :	D:\compspace\objfiles\firefox\i18n\uregex.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_FB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_400
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	??_GRegularExpression@icu_56@@QAEPAXI@Z	; icu_56::RegularExpression::`scalar deleting destructor'(uint)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_2000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_4000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1BF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_E00
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_FB:					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 130h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 134h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 138h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::RegexPattern::operator!=(class	icu_56::RegexPattern const &)const
		public ??9RegexPattern@icu_56@@QBECABV01@@Z
??9RegexPattern@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8RegexPattern@icu_56@@QBECABV01@@Z ; icu_56::RegexPattern::operator==(icu_56::RegexPattern const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9RegexPattern@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RegularExpression::RegularExpression(icu_56::RegularExpression *__hidden this)
		public ??0RegularExpression@icu_56@@QAE@XZ
??0RegularExpression@icu_56@@QAE@XZ proc near ;	CODE XREF: _uregex_open_56+A0p
					; _uregex_openUText_56+A3p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_1BF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 72657870h
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]

loc_1FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+20h], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0RegularExpression@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 240h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RegularExpression::~RegularExpression(icu_56::RegularExpression *__hidden this)
		public ??1RegularExpression@icu_56@@QAE@XZ
??1RegularExpression@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::RegularExpression::`scalar	deleting destructor'(uint)+26p

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi		; volatile __int32 *
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	[ebp+var_EC], ecx
		mov	edx, [ebp+var_EC]
		mov	[ebp+var_F8], edx
		cmp	[ebp+var_F8], 0
		jz	short loc_2A9
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_F8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_F8]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_100], eax
		jmp	short loc_2B3
; ---------------------------------------------------------------------------

loc_2A9:				; CODE XREF: icu_56::RegularExpression::~RegularExpression(void)+42j
		mov	[ebp+var_100], 0

loc_2B3:				; CODE XREF: icu_56::RegularExpression::~RegularExpression(void)+67j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	loc_34B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx		; lpAddend
		call	?umtx_atomic_dec@icu_56@@YAHPCJ@Z ; icu_56::umtx_atomic_dec(long volatile *)
		add	esp, 4
		test	eax, eax
		jnz	short loc_34B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_D4], ecx
		mov	edx, [ebp+var_D4]
		mov	[ebp+var_E0], edx
		cmp	[ebp+var_E0], 0
		jz	short loc_323
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_E0]
		mov	edx, [eax]
		mov	ecx, [ebp+var_E0]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_100], eax
		jmp	short loc_32D
; ---------------------------------------------------------------------------

loc_323:				; CODE XREF: icu_56::RegularExpression::~RegularExpression(void)+BCj
		mov	[ebp+var_100], 0

loc_32D:				; CODE XREF: icu_56::RegularExpression::~RegularExpression(void)+E1j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_34B:				; CODE XREF: icu_56::RegularExpression::~RegularExpression(void)+84j
					; icu_56::RegularExpression::~RegularExpression(void)+9Bj
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+20h]
		test	ecx, ecx
		jz	short loc_36E
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_36E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_36E:				; CODE XREF: icu_56::RegularExpression::~RegularExpression(void)+114j
					; icu_56::RegularExpression::~RegularExpression(void)+11Dj
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1RegularExpression@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::umtx_atomic_dec(volatile LONG *lpAddend, volatile	__int32	*)
		public ?umtx_atomic_dec@icu_56@@YAHPCJ@Z
?umtx_atomic_dec@icu_56@@YAHPCJ@Z proc near
					; CODE XREF: icu_56::RegularExpression::~RegularExpression(void)+91p

var_C0		= byte ptr -0C0h
lpAddend	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+lpAddend]
		push	eax		; lpAddend
		call	dword ptr ds:__imp__InterlockedDecrement@4 ; InterlockedDecrement(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?umtx_atomic_dec@icu_56@@YAHPCJ@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uregex_open_56(int, int, unsigned	int, struct UParseError	*, enum	UErrorCode *)
		public _uregex_open_56
_uregex_open_56	proc near

var_1B4		= dword	ptr -1B4h
var_1AC		= dword	ptr -1ACh
var_1A0		= dword	ptr -1A0h
var_194		= dword	ptr -194h
var_188		= dword	ptr -188h
var_17C		= dword	ptr -17Ch
var_170		= dword	ptr -170h
var_A4		= dword	ptr -0A4h
var_A0		= dword	ptr -0A0h
var_9C		= dword	ptr -9Ch
var_98		= dword	ptr -98h
var_94		= dword	ptr -94h
var_90		= dword	ptr -90h
var_8C		= dword	ptr -8Ch
var_88		= dword	ptr -88h
var_84		= dword	ptr -84h
var_80		= dword	ptr -80h
var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_74		= dword	ptr -74h
var_70		= dword	ptr -70h
var_6C		= dword	ptr -6Ch
var_68		= dword	ptr -68h
var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 1B4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1B4]
		mov	ecx, 6Dh ; 'm'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4

loc_400:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		movsx	edx, al
		test	edx, edx
		jz	short loc_40E
		xor	eax, eax
		jmp	loc_765
; ---------------------------------------------------------------------------

loc_40E:				; CODE XREF: _uregex_open_56+31j
		cmp	[ebp+arg_0], 0
		jz	short loc_420
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jl	short loc_420
		cmp	[ebp+arg_4], 0
		jnz	short loc_430

loc_420:				; CODE XREF: _uregex_open_56+3Ej
					; _uregex_open_56+44j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_765
; ---------------------------------------------------------------------------

loc_430:				; CODE XREF: _uregex_open_56+4Aj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0FFFFFFFFh
		jnz	short loc_44B
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+var_8], eax

loc_44B:				; CODE XREF: _uregex_open_56+66j
		mov	esi, esp
		push	24h ; '$'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1A0], eax
		cmp	[ebp+var_1A0], 0
		jz	short loc_481
		mov	ecx, [ebp+var_1A0] ; this
		call	??0RegularExpression@icu_56@@QAE@XZ ; icu_56::RegularExpression::RegularExpression(void)
		mov	[ebp+var_1B4], eax
		jmp	short loc_48B
; ---------------------------------------------------------------------------

loc_481:				; CODE XREF: _uregex_open_56+98j
		mov	[ebp+var_1B4], 0

loc_48B:				; CODE XREF: _uregex_open_56+ABj
		mov	eax, [ebp+var_1B4]
		mov	[ebp+var_1AC], eax
		mov	ecx, [ebp+var_1AC]
		mov	[ebp+var_14], ecx
		push	4
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_8]
		lea	ecx, [eax+eax+2]
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_14], 0
		jz	short loc_4D2
		cmp	[ebp+var_20], 0
		jz	short loc_4D2
		cmp	[ebp+var_2C], 0
		jnz	short loc_537

loc_4D2:				; CODE XREF: _uregex_open_56+F0j
					; _uregex_open_56+F6j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_14]
		mov	[ebp+var_188], eax
		mov	ecx, [ebp+var_188]
		mov	[ebp+var_194], ecx
		cmp	[ebp+var_194], 0
		jz	short loc_50E
		push	1
		mov	ecx, [ebp+var_194]
		call	??_GRegularExpression@icu_56@@QAEPAXI@Z	; icu_56::RegularExpression::`scalar deleting destructor'(uint)
		mov	[ebp+var_1B4], eax
		jmp	short loc_518
; ---------------------------------------------------------------------------

loc_50E:				; CODE XREF: _uregex_open_56+123j
		mov	[ebp+var_1B4], 0

loc_518:				; CODE XREF: _uregex_open_56+138j
		mov	eax, [ebp+var_20]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_2C]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_765
; ---------------------------------------------------------------------------

loc_537:				; CODE XREF: _uregex_open_56+FCj
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_20]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		mov	dword ptr [ecx], 1
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_2C]
		push	edx
		call	_u_memcpy_56
		add	esp, 0Ch
		xor	eax, eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_2C]
		mov	[edx+ecx*2], ax
		mov	[ebp+var_A4], 345AD82Ch
		mov	[ebp+var_A0], 0
		mov	[ebp+var_9C], 0
		mov	[ebp+var_98], 70h ; 'p'
		mov	[ebp+var_94], 0
		mov	[ebp+var_90], 0
		mov	[ebp+var_8C], 0
		mov	[ebp+var_88], 0
		mov	[ebp+var_84], 0
		mov	[ebp+var_80], 0
		mov	[ebp+var_7C], 0
		mov	[ebp+var_78], 0
		mov	[ebp+var_74], 0
		mov	[ebp+var_70], 0
		mov	[ebp+var_6C], 0
		mov	[ebp+var_68], 0
		mov	[ebp+var_64], 0
		mov	[ebp+var_60], 0
		mov	[ebp+var_5C], 0
		mov	[ebp+var_58], 0
		mov	[ebp+var_54], 0
		mov	[ebp+var_50], 0
		mov	[ebp+var_4C], 0
		mov	[ebp+var_48], 0
		mov	[ebp+var_44], 0
		mov	[ebp+var_40], 0
		mov	[ebp+var_3C], 0
		mov	[ebp+var_38], 0
		mov	eax, [ebp+arg_10]
		push	eax
		mov	eax, [ebp+arg_4]
		cdq
		push	edx
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		lea	edx, [ebp+var_A4]
		push	edx
		call	_utext_openUChars_56
		add	esp, 14h
		cmp	[ebp+arg_C], 0
		jz	short loc_6A3
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_8]
		push	edx		; unsigned int
		lea	eax, [ebp+var_A4]
		push	eax		; struct UText *
		call	?compile@RegexPattern@icu_56@@SAPAV12@PAUUText@@IAAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::RegexPattern::compile(UText *,uint,UParseError &,UErrorCode &)
		add	esp, 10h
		mov	ecx, [ebp+var_14]
		mov	[ecx+4], eax
		jmp	short loc_6C0
; ---------------------------------------------------------------------------

loc_6A3:				; CODE XREF: _uregex_open_56+2AAj
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; unsigned int
		lea	edx, [ebp+var_A4]
		push	edx		; struct UText *
		call	?compile@RegexPattern@icu_56@@SAPAV12@PAUUText@@IAAW4UErrorCode@@@Z ; icu_56::RegexPattern::compile(UText *,uint,UErrorCode &)
		add	esp, 0Ch
		mov	ecx, [ebp+var_14]
		mov	[ecx+4], eax

loc_6C0:				; CODE XREF: _uregex_open_56+2CDj
		lea	eax, [ebp+var_A4]
		push	eax
		call	_utext_close_56
		add	esp, 4
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6E6
		jmp	short $ErrorExit$69984
; ---------------------------------------------------------------------------

loc_6E6:				; CODE XREF: _uregex_open_56+30Ej
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+4]
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]
		mov	edx, [edx]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14]
		mov	[ecx+14h], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short $ErrorExit$69984
		mov	eax, [ebp+var_14]
		jmp	short loc_765
; ---------------------------------------------------------------------------

$ErrorExit$69984:			; CODE XREF: _uregex_open_56+310j
					; _uregex_open_56+34Bj
		mov	eax, [ebp+var_14]
		mov	[ebp+var_170], eax
		mov	ecx, [ebp+var_170]
		mov	[ebp+var_17C], ecx
		cmp	[ebp+var_17C], 0
		jz	short loc_759
		push	1
		mov	ecx, [ebp+var_17C]
		call	??_GRegularExpression@icu_56@@QAEPAXI@Z	; icu_56::RegularExpression::`scalar deleting destructor'(uint)
		mov	[ebp+var_1B4], eax
		jmp	short loc_763
; ---------------------------------------------------------------------------

loc_759:				; CODE XREF: _uregex_open_56+36Ej
		mov	[ebp+var_1B4], 0

loc_763:				; CODE XREF: _uregex_open_56+383j
		xor	eax, eax

loc_765:				; CODE XREF: _uregex_open_56+35j
					; _uregex_open_56+57j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN22
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 1B4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_open_56	endp

; ---------------------------------------------------------------------------
		align 4
$LN22		dd 1			; DATA XREF: _uregex_open_56+395o
		dd offset $LN21
$LN21		dd 0FFFFFF5Ch, 70h	; DATA XREF: .text:00000790o
		dd offset $LN20		; "patText"
$LN20		db 'patText',0          ; DATA XREF: .text:0000079Co
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _uregex_open_56+33Ep
					; _uregex_openUText_56+387p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _uregex_open_56+24p
					; _uregex_open_56+301p	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 800h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::RegularExpression::`scalar deleting	destructor'(unsigned int)
		public ??_GRegularExpression@icu_56@@QAEPAXI@Z
??_GRegularExpression@icu_56@@QAEPAXI@Z	proc near ; CODE XREF: _uregex_open_56+12Dp
					; _uregex_open_56+378p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1RegularExpression@icu_56@@QAE@XZ ; icu_56::RegularExpression::~RegularExpression(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_849
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_849:				; CODE XREF: icu_56::RegularExpression::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRegularExpression@icu_56@@QAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 864h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uregex_openUText_56(int, unsigned	int, struct UParseError	*, enum	UErrorCode *)
		public _uregex_openUText_56
_uregex_openUText_56 proc near

var_1D0		= dword	ptr -1D0h
var_1C8		= dword	ptr -1C8h
var_1BC		= dword	ptr -1BCh
var_1B0		= dword	ptr -1B0h
var_1A4		= dword	ptr -1A4h
var_198		= dword	ptr -198h
var_18C		= dword	ptr -18Ch
var_C0		= dword	ptr -0C0h
var_BC		= dword	ptr -0BCh
var_B8		= dword	ptr -0B8h
var_B4		= dword	ptr -0B4h
var_B0		= dword	ptr -0B0h
var_AC		= dword	ptr -0ACh
var_A8		= dword	ptr -0A8h
var_A4		= dword	ptr -0A4h
var_A0		= dword	ptr -0A0h
var_9C		= dword	ptr -9Ch
var_98		= dword	ptr -98h
var_94		= dword	ptr -94h
var_90		= dword	ptr -90h
var_8C		= dword	ptr -8Ch
var_88		= dword	ptr -88h
var_84		= dword	ptr -84h
var_80		= dword	ptr -80h
var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_74		= dword	ptr -74h
var_70		= dword	ptr -70h
var_6C		= dword	ptr -6Ch
var_68		= dword	ptr -68h
var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 1D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1D0]
		mov	ecx, 74h ; 't'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_89E
		xor	eax, eax
		jmp	loc_C3E
; ---------------------------------------------------------------------------

loc_89E:				; CODE XREF: _uregex_openUText_56+31j
		cmp	[ebp+arg_0], 0
		jnz	short loc_8B4
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_C3E
; ---------------------------------------------------------------------------

loc_8B4:				; CODE XREF: _uregex_openUText_56+3Ej
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utext_nativeLength_56
		add	esp, 4
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_C]
		or	eax, [ebp+var_8]
		jnz	short loc_8DE
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_C3E
; ---------------------------------------------------------------------------

loc_8DE:				; CODE XREF: _uregex_openUText_56+68j
		mov	esi, esp
		push	24h ; '$'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1BC], eax
		cmp	[ebp+var_1BC], 0
		jz	short loc_914
		mov	ecx, [ebp+var_1BC] ; this
		call	??0RegularExpression@icu_56@@QAE@XZ ; icu_56::RegularExpression::RegularExpression(void)
		mov	[ebp+var_1D0], eax
		jmp	short loc_91E
; ---------------------------------------------------------------------------

loc_914:				; CODE XREF: _uregex_openUText_56+9Bj
		mov	[ebp+var_1D0], 0

loc_91E:				; CODE XREF: _uregex_openUText_56+AEj
		mov	eax, [ebp+var_1D0]
		mov	[ebp+var_1C8], eax
		mov	ecx, [ebp+var_1C8]
		mov	[ebp+var_18], ecx
		mov	[ebp+var_24], 0
		lea	eax, [ebp+var_24]
		push	eax
		push	0
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+var_C]
		push	edx
		push	0
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utext_extract_56
		add	esp, 20h
		mov	[ebp+var_30], eax
		push	4
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_3C], eax
		mov	eax, [ebp+var_30]
		lea	ecx, [eax+eax+2]
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_48], eax
		cmp	[ebp+var_18], 0
		jz	short loc_98F
		cmp	[ebp+var_3C], 0
		jz	short loc_98F
		cmp	[ebp+var_48], 0
		jnz	short loc_9F4

loc_98F:				; CODE XREF: _uregex_openUText_56+11Dj
					; _uregex_openUText_56+123j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_18]
		mov	[ebp+var_1A4], eax
		mov	ecx, [ebp+var_1A4]
		mov	[ebp+var_1B0], ecx
		cmp	[ebp+var_1B0], 0
		jz	short loc_9CB
		push	1
		mov	ecx, [ebp+var_1B0]
		call	??_GRegularExpression@icu_56@@QAEPAXI@Z	; icu_56::RegularExpression::`scalar deleting destructor'(uint)
		mov	[ebp+var_1D0], eax
		jmp	short loc_9D5
; ---------------------------------------------------------------------------

loc_9CB:				; CODE XREF: _uregex_openUText_56+150j
		mov	[ebp+var_1D0], 0

loc_9D5:				; CODE XREF: _uregex_openUText_56+165j
		mov	eax, [ebp+var_3C]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_48]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_C3E
; ---------------------------------------------------------------------------

loc_9F4:				; CODE XREF: _uregex_openUText_56+129j
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_3C]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		mov	dword ptr [ecx], 1
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_48]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_30]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		push	ecx
		mov	edx, [ebp+var_48]
		push	edx
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+var_C]
		push	ecx
		push	0
		push	0
		mov	edx, [ebp+arg_0]
		push	edx
		call	_utext_extract_56
		add	esp, 20h
		mov	[ebp+var_C0], 345AD82Ch
		mov	[ebp+var_BC], 0
		mov	[ebp+var_B8], 0
		mov	[ebp+var_B4], 70h ; 'p'
		mov	[ebp+var_B0], 0
		mov	[ebp+var_AC], 0
		mov	[ebp+var_A8], 0
		mov	[ebp+var_A4], 0
		mov	[ebp+var_A0], 0
		mov	[ebp+var_9C], 0
		mov	[ebp+var_98], 0
		mov	[ebp+var_94], 0
		mov	[ebp+var_90], 0
		mov	[ebp+var_8C], 0
		mov	[ebp+var_88], 0
		mov	[ebp+var_84], 0
		mov	[ebp+var_80], 0
		mov	[ebp+var_7C], 0
		mov	[ebp+var_78], 0
		mov	[ebp+var_74], 0
		mov	[ebp+var_70], 0
		mov	[ebp+var_6C], 0
		mov	[ebp+var_68], 0
		mov	[ebp+var_64], 0
		mov	[ebp+var_60], 0
		mov	[ebp+var_5C], 0
		mov	[ebp+var_58], 0
		mov	[ebp+var_54], 0
		mov	eax, [ebp+arg_C]
		push	eax
		mov	eax, [ebp+var_30]
		cdq
		push	edx
		push	eax
		mov	ecx, [ebp+var_48]
		push	ecx
		lea	edx, [ebp+var_C0]
		push	edx
		call	_utext_openUChars_56
		add	esp, 14h
		cmp	[ebp+arg_8], 0
		jz	short loc_B7C
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_4]
		push	edx		; unsigned int
		lea	eax, [ebp+var_C0]
		push	eax		; struct UText *
		call	?compile@RegexPattern@icu_56@@SAPAV12@PAUUText@@IAAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::RegexPattern::compile(UText *,uint,UParseError &,UErrorCode &)
		add	esp, 10h
		mov	ecx, [ebp+var_18]
		mov	[ecx+4], eax
		jmp	short loc_B99
; ---------------------------------------------------------------------------

loc_B7C:				; CODE XREF: _uregex_openUText_56+2F3j
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; unsigned int
		lea	edx, [ebp+var_C0]
		push	edx		; struct UText *
		call	?compile@RegexPattern@icu_56@@SAPAV12@PAUUText@@IAAW4UErrorCode@@@Z ; icu_56::RegexPattern::compile(UText *,uint,UErrorCode &)
		add	esp, 0Ch
		mov	ecx, [ebp+var_18]
		mov	[ecx+4], eax

loc_B99:				; CODE XREF: _uregex_openUText_56+316j
		lea	eax, [ebp+var_C0]
		push	eax
		call	_utext_close_56
		add	esp, 4
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_BBF
		jmp	short $ErrorExit$70027
; ---------------------------------------------------------------------------

loc_BBF:				; CODE XREF: _uregex_openUText_56+357j
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+4]
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]
		mov	edx, [edx]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_18]
		mov	[ecx+14h], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short $ErrorExit$70027
		mov	eax, [ebp+var_18]
		jmp	short loc_C3E
; ---------------------------------------------------------------------------

$ErrorExit$70027:			; CODE XREF: _uregex_openUText_56+359j
					; _uregex_openUText_56+394j
		mov	eax, [ebp+var_18]
		mov	[ebp+var_18C], eax
		mov	ecx, [ebp+var_18C]
		mov	[ebp+var_198], ecx
		cmp	[ebp+var_198], 0
		jz	short loc_C32
		push	1
		mov	ecx, [ebp+var_198]
		call	??_GRegularExpression@icu_56@@QAEPAXI@Z	; icu_56::RegularExpression::`scalar deleting destructor'(uint)
		mov	[ebp+var_1D0], eax
		jmp	short loc_C3C
; ---------------------------------------------------------------------------

loc_C32:				; CODE XREF: _uregex_openUText_56+3B7j
		mov	[ebp+var_1D0], 0

loc_C3C:				; CODE XREF: _uregex_openUText_56+3CCj
		xor	eax, eax

loc_C3E:				; CODE XREF: _uregex_openUText_56+35j
					; _uregex_openUText_56+4Bj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN22_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 1D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_openUText_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN22_0		dd 2			; DATA XREF: _uregex_openUText_56+3DEo
		dd offset $LN21_0
$LN21_0		dd 0FFFFFFDCh, 4	; DATA XREF: .text:00000C68o
		dd offset $LN19		; "lengthStatus"
		dd 0FFFFFF40h, 70h
		dd offset $LN20_0	; "patText"
$LN20_0		db 'patText',0          ; DATA XREF: .text:00000C80o
$LN19		db 'lengthStatus',0     ; DATA XREF: .text:00000C74o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_close_56
_uregex_close_56 proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_CE2
		jmp	short loc_D1F
; ---------------------------------------------------------------------------

loc_CE2:				; CODE XREF: _uregex_close_56+42j
		mov	eax, [ebp+var_8]
		mov	[ebp+var_E0], eax
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_EC], ecx
		cmp	[ebp+var_EC], 0
		jz	short loc_D15
		push	1
		mov	ecx, [ebp+var_EC]
		call	??_GRegularExpression@icu_56@@QAEPAXI@Z	; icu_56::RegularExpression::`scalar deleting destructor'(uint)
		mov	[ebp+var_F4], eax
		jmp	short loc_D1F
; ---------------------------------------------------------------------------

loc_D15:				; CODE XREF: _uregex_close_56+62j
		mov	[ebp+var_F4], 0

loc_D1F:				; CODE XREF: _uregex_close_56+44j
					; _uregex_close_56+77j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_close_56 endp

; ---------------------------------------------------------------------------
$LN8		dd 1			; DATA XREF: _uregex_close_56+87o
		dd offset $LN7
$LN7		dd 0FFFFFFECh, 4	; DATA XREF: .text:00000D48o
		dd offset $LN6		; "status"
$LN6		db 'status',0           ; DATA XREF: .text:00000D54o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl validateRE(struct	icu_56::RegularExpression const	*, signed char,	enum  UErrorCode *)
?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z proc near
					; CODE XREF: _uregex_close_56+35p
					; _uregex_clone_56+2Ep	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_D97
		xor	al, al
		jmp	short loc_DE0
; ---------------------------------------------------------------------------

loc_D97:				; CODE XREF: validateRE(icu_56::RegularExpression const	*,signed char,UErrorCode *)+31j
		cmp	[ebp+arg_0], 0
		jz	short loc_DA8
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 72657870h
		jz	short loc_DB5

loc_DA8:				; CODE XREF: validateRE(icu_56::RegularExpression const	*,signed char,UErrorCode *)+3Bj
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	short loc_DE0
; ---------------------------------------------------------------------------

loc_DB5:				; CODE XREF: validateRE(icu_56::RegularExpression const	*,signed char,UErrorCode *)+46j
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_DDE
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jnz	short loc_DDE
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+20h]
		test	ecx, ecx
		jnz	short loc_DDE
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 10302h
		xor	al, al
		jmp	short loc_DE0
; ---------------------------------------------------------------------------

loc_DDE:				; CODE XREF: validateRE(icu_56::RegularExpression const	*,signed char,UErrorCode *)+5Bj
					; validateRE(icu_56::RegularExpression const *,signed char,UErrorCode *)+64j ...
		mov	al, 1

loc_DE0:				; CODE XREF: validateRE(icu_56::RegularExpression const	*,signed char,UErrorCode *)+35j
					; validateRE(icu_56::RegularExpression const *,signed char,UErrorCode *)+53j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_clone_56
_uregex_clone_56 proc near

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi		; volatile __int32 *

loc_E00:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_E38
		xor	eax, eax
		jmp	loc_F61
; ---------------------------------------------------------------------------

loc_E38:				; CODE XREF: _uregex_clone_56+3Bj
		mov	esi, esp
		push	24h ; '$'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F8], eax
		cmp	[ebp+var_F8], 0
		jz	short loc_E6E
		mov	ecx, [ebp+var_F8] ; this
		call	??0RegularExpression@icu_56@@QAE@XZ ; icu_56::RegularExpression::RegularExpression(void)
		mov	[ebp+var_10C], eax
		jmp	short loc_E78
; ---------------------------------------------------------------------------

loc_E6E:				; CODE XREF: _uregex_clone_56+65j
		mov	[ebp+var_10C], 0

loc_E78:				; CODE XREF: _uregex_clone_56+78j
		mov	eax, [ebp+var_10C]
		mov	[ebp+var_104], eax
		mov	ecx, [ebp+var_104]
		mov	[ebp+var_14], ecx
		cmp	[ebp+var_14], 0
		jnz	short loc_EA3
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_F61
; ---------------------------------------------------------------------------

loc_EA3:				; CODE XREF: _uregex_clone_56+9Dj
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [edx]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14]
		mov	[ecx+14h], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_F1F
		mov	eax, [ebp+var_14]
		mov	[ebp+var_E0], eax
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_EC], ecx
		cmp	[ebp+var_EC], 0
		jz	short loc_F11
		push	1
		mov	ecx, [ebp+var_EC]
		call	??_GRegularExpression@icu_56@@QAEPAXI@Z	; icu_56::RegularExpression::`scalar deleting destructor'(uint)
		mov	[ebp+var_10C], eax
		jmp	short loc_F1B
; ---------------------------------------------------------------------------

loc_F11:				; CODE XREF: _uregex_clone_56+106j
		mov	[ebp+var_10C], 0

loc_F1B:				; CODE XREF: _uregex_clone_56+11Bj
		xor	eax, eax
		jmp	short loc_F61
; ---------------------------------------------------------------------------

loc_F1F:				; CODE XREF: _uregex_clone_56+E8j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx		; lpAddend
		call	?umtx_atomic_inc@icu_56@@YAHPCJ@Z ; icu_56::umtx_atomic_inc(long volatile *)
		add	esp, 4
		mov	eax, [ebp+var_14]

loc_F61:				; CODE XREF: _uregex_clone_56+3Fj
					; _uregex_clone_56+AAj	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_clone_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::umtx_atomic_inc(volatile LONG *lpAddend, volatile	__int32	*)
		public ?umtx_atomic_inc@icu_56@@YAHPCJ@Z
?umtx_atomic_inc@icu_56@@YAHPCJ@Z proc near ; CODE XREF: _uregex_clone_56+162p

var_C0		= byte ptr -0C0h
lpAddend	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+lpAddend]
		push	eax		; lpAddend
		call	dword ptr ds:__imp__InterlockedIncrement@4 ; InterlockedIncrement(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?umtx_atomic_inc@icu_56@@YAHPCJ@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_pattern_56
_uregex_pattern_56 proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1001
		xor	eax, eax

loc_FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		jmp	short loc_1018
; ---------------------------------------------------------------------------

loc_1001:				; CODE XREF: _uregex_pattern_56+3Bj
		cmp	[ebp+arg_4], 0
		jz	short loc_1012
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		mov	[eax], edx

loc_1012:				; CODE XREF: _uregex_pattern_56+45j
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]

loc_1018:				; CODE XREF: _uregex_pattern_56:loc_FFFj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_pattern_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 102Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_patternUText_56
_uregex_patternUText_56	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [edx]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_patternUText_56	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1084h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_flags_56
_uregex_flags_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_10C5
		xor	eax, eax
		jmp	short loc_10E9
; ---------------------------------------------------------------------------

loc_10C5:				; CODE XREF: _uregex_flags_56+3Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+4]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]

loc_10E9:				; CODE XREF: _uregex_flags_56+3Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_flags_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1100h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_setText_56
_uregex_setText_56 proc	near

var_144		= byte ptr -144h
var_80		= dword	ptr -80h
var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_74		= dword	ptr -74h
var_70		= dword	ptr -70h
var_6C		= dword	ptr -6Ch
var_68		= dword	ptr -68h
var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 144h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_144]
		mov	ecx, 51h ; 'Q'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1142
		jmp	loc_12A2
; ---------------------------------------------------------------------------

loc_1142:				; CODE XREF: _uregex_setText_56+3Bj
		cmp	[ebp+arg_4], 0
		jz	short loc_114E
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jge	short loc_115C

loc_114E:				; CODE XREF: _uregex_setText_56+46j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		jmp	loc_12A2
; ---------------------------------------------------------------------------

loc_115C:				; CODE XREF: _uregex_setText_56+4Cj
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+20h]
		test	ecx, ecx
		jz	short loc_117F
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_117F
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_117F:				; CODE XREF: _uregex_setText_56+65j
					; _uregex_setText_56+6Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+18h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+1Ch], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+20h], 0
		mov	[ebp+var_80], 345AD82Ch
		mov	[ebp+var_7C], 0
		mov	[ebp+var_78], 0
		mov	[ebp+var_74], 70h ; 'p'
		mov	[ebp+var_70], 0
		mov	[ebp+var_6C], 0
		mov	[ebp+var_68], 0
		mov	[ebp+var_64], 0
		mov	[ebp+var_60], 0
		mov	[ebp+var_5C], 0
		mov	[ebp+var_58], 0
		mov	[ebp+var_54], 0
		mov	[ebp+var_50], 0
		mov	[ebp+var_4C], 0
		mov	[ebp+var_48], 0
		mov	[ebp+var_44], 0
		mov	[ebp+var_40], 0
		mov	[ebp+var_3C], 0
		mov	[ebp+var_38], 0
		mov	[ebp+var_34], 0
		mov	[ebp+var_30], 0
		mov	[ebp+var_2C], 0
		mov	[ebp+var_28], 0
		mov	[ebp+var_24], 0
		mov	[ebp+var_20], 0
		mov	[ebp+var_1C], 0
		mov	[ebp+var_18], 0
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_C]
		push	eax
		mov	eax, [ebp+arg_8]
		cdq
		push	edx
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		lea	edx, [ebp+var_80]
		push	edx
		call	_utext_openUChars_56
		add	esp, 14h
		mov	esi, esp
		lea	eax, [ebp+var_80]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+58h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	eax, [ebp+var_80]
		push	eax
		call	_utext_close_56
		add	esp, 4

loc_12A2:				; CODE XREF: _uregex_setText_56+3Dj
					; _uregex_setText_56+57j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_setText_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN9		dd 1			; DATA XREF: _uregex_setText_56+1A6o
		dd offset $LN8_0
$LN8_0		dd 0FFFFFF80h, 70h	; DATA XREF: .text:000012CCo
		dd offset $LN7_0	; "input"
$LN7_0		db 'input',0            ; DATA XREF: .text:000012D8o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_setUText_56
_uregex_setUText_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1323
		jmp	short loc_1392
; ---------------------------------------------------------------------------

loc_1323:				; CODE XREF: _uregex_setUText_56+3Bj
		cmp	[ebp+arg_4], 0
		jnz	short loc_1334
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	short loc_1392
; ---------------------------------------------------------------------------

loc_1334:				; CODE XREF: _uregex_setUText_56+43j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+20h]
		test	ecx, ecx
		jz	short loc_1357
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_1357
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_1357:				; CODE XREF: _uregex_setUText_56+59j
					; _uregex_setUText_56+62j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+1Ch], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+20h], 1
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+58h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1392:				; CODE XREF: _uregex_setUText_56+3Dj
					; _uregex_setUText_56+4Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_setUText_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_getText_56
_uregex_getText_56 proc	near

var_108		= dword	ptr -108h
var_104		= dword	ptr -104h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_13EC
		xor	eax, eax
		jmp	loc_154D
; ---------------------------------------------------------------------------

loc_13EC:				; CODE XREF: _uregex_getText_56+3Bj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 0
		jnz	loc_1536
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+70h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		push	eax
		call	_utext_nativeLength_56
		add	esp, 4
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_14]
		mov	[ebp+var_104], eax
		mov	ecx, [ebp+var_104]
		cmp	dword ptr [ecx+20h], 0
		jnz	short loc_14B9
		mov	edx, [ebp+var_104]
		cmp	dword ptr [edx+24h], 0
		jnz	short loc_14B9
		mov	eax, [ebp+var_14]
		mov	[ebp+var_104], eax
		mov	ecx, [ebp+var_104]
		mov	edx, [ebp+var_24]
		cmp	edx, [ecx+10h]
		jnz	short loc_14B9
		mov	eax, [ebp+var_104]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+14h]
		jnz	short loc_14B9
		mov	eax, [ebp+var_14]
		mov	eax, [eax+1Ch]
		cdq
		mov	[ebp+var_108], eax
		mov	[ebp+var_104], edx
		mov	ecx, [ebp+var_24]
		cmp	ecx, [ebp+var_108]
		jnz	short loc_14B9
		mov	edx, [ebp+var_20]
		cmp	edx, [ebp+var_104]
		jnz	short loc_14B9
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+30h]
		mov	[eax+18h], edx
		mov	eax, [ebp+var_24]
		mov	ecx, [ebp+var_8]
		mov	[ecx+1Ch], eax
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+20h], 0
		jmp	short loc_1536
; ---------------------------------------------------------------------------

loc_14B9:				; CODE XREF: _uregex_getText_56+97j
					; _uregex_getText_56+A3j ...
		mov	[ebp+var_30], 0
		lea	eax, [ebp+var_30]
		push	eax
		push	0
		push	0
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_24]
		push	edx
		push	0
		push	0
		mov	eax, [ebp+var_14]
		push	eax
		call	_utext_extract_56
		add	esp, 20h
		mov	ecx, [ebp+var_8]
		mov	[ecx+1Ch], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		lea	edx, [ecx+ecx+2]
		push	edx
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_3C], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		add	edx, 1
		push	edx
		mov	eax, [ebp+var_3C]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_24]
		push	edx
		push	0
		push	0
		mov	eax, [ebp+var_14]
		push	eax
		call	_utext_extract_56
		add	esp, 20h
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_3C]
		mov	[eax+18h], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+20h], 1

loc_1536:				; CODE XREF: _uregex_getText_56+4Bj
					; _uregex_getText_56+10Fj
		cmp	[ebp+arg_4], 0
		jz	short loc_1547
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		mov	[eax], edx

loc_1547:				; CODE XREF: _uregex_getText_56+192j
		mov	eax, [ebp+var_8]
		mov	eax, [eax+18h]

loc_154D:				; CODE XREF: _uregex_getText_56+3Fj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_getText_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN10		dd 1			; DATA XREF: _uregex_getText_56+1A9o
		dd offset $LN9_0
$LN9_0		dd 0FFFFFFD0h, 4	; DATA XREF: .text:00001578o
		dd offset $LN8_1	; "lengthStatus"
$LN8_1		db 'lengthStatus',0     ; DATA XREF: .text:00001584o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1598h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_getUText_56
_uregex_getUText_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_15DA
		mov	eax, [ebp+arg_4]
		jmp	short loc_15FE
; ---------------------------------------------------------------------------

loc_15DA:				; CODE XREF: _uregex_getUText_56+3Bj
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+74h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_15FE:				; CODE XREF: _uregex_getUText_56+40j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_getUText_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1614h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_refreshUText_56
_uregex_refreshUText_56	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1653
		jmp	short loc_1677
; ---------------------------------------------------------------------------

loc_1653:				; CODE XREF: _uregex_refreshUText_56+3Bj
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+68h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1677:				; CODE XREF: _uregex_refreshUText_56+3Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_refreshUText_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 168Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_matches_56
_uregex_matches_56 proc	near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax
		mov	eax, [ebp+arg_4]
		cdq
		push	edx
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uregex_matches64_56
		add	esp, 10h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_matches_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_matches64_56
_uregex_matches64_56 proc near		; CODE XREF: _uregex_matches_56+2Cp

var_D8		= byte ptr -0D8h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	[ebp+var_11], 0
		mov	eax, [ebp+arg_C]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_171A
		mov	al, [ebp+var_11]
		jmp	short loc_177A
; ---------------------------------------------------------------------------

loc_171A:				; CODE XREF: _uregex_matches64_56+3Fj
		mov	eax, [ebp+arg_4]
		and	eax, [ebp+arg_8]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_174A
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11], al
		jmp	short loc_1777
; ---------------------------------------------------------------------------

loc_174A:				; CODE XREF: _uregex_matches64_56+4Fj
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11], al

loc_1777:				; CODE XREF: _uregex_matches64_56+74j
		mov	al, [ebp+var_11]

loc_177A:				; CODE XREF: _uregex_matches64_56+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_matches64_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1790h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_lookingAt_56
_uregex_lookingAt_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax
		mov	eax, [ebp+arg_4]
		cdq
		push	edx
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uregex_lookingAt64_56
		add	esp, 10h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_lookingAt_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_lookingAt64_56
_uregex_lookingAt64_56 proc near	; CODE XREF: _uregex_lookingAt_56+2Cp

var_D8		= byte ptr -0D8h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	[ebp+var_11], 0
		mov	eax, [ebp+arg_C]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_181E
		mov	al, [ebp+var_11]
		jmp	short loc_187E
; ---------------------------------------------------------------------------

loc_181E:				; CODE XREF: _uregex_lookingAt64_56+3Fj
		mov	eax, [ebp+arg_4]
		and	eax, [ebp+arg_8]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_184E
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+14h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11], al
		jmp	short loc_187B
; ---------------------------------------------------------------------------

loc_184E:				; CODE XREF: _uregex_lookingAt64_56+4Fj
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11], al

loc_187B:				; CODE XREF: _uregex_lookingAt64_56+74j
		mov	al, [ebp+var_11]

loc_187E:				; CODE XREF: _uregex_lookingAt64_56+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_lookingAt64_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1894h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_find_56
_uregex_find_56	proc near		; CODE XREF: _uregex_replaceFirst_56+92p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax
		mov	eax, [ebp+arg_4]
		cdq
		push	edx
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uregex_find64_56
		add	esp, 10h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_find_56	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_find64_56
_uregex_find64_56 proc near		; CODE XREF: _uregex_find_56+2Cp

var_D8		= byte ptr -0D8h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	[ebp+var_11], 0
		mov	eax, [ebp+arg_C]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1922
		mov	al, [ebp+var_11]
		jmp	short loc_198D
; ---------------------------------------------------------------------------

loc_1922:				; CODE XREF: _uregex_find64_56+3Fj
		mov	eax, [ebp+arg_4]
		and	eax, [ebp+arg_8]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_195D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]	; this
		call	?resetPreserveRegion@RegexMatcher@icu_56@@QAEXXZ ; icu_56::RegexMatcher::resetPreserveRegion(void)
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11], al
		jmp	short loc_198A
; ---------------------------------------------------------------------------

loc_195D:				; CODE XREF: _uregex_find64_56+4Fj
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11], al

loc_198A:				; CODE XREF: _uregex_find64_56+7Fj
		mov	al, [ebp+var_11]

loc_198D:				; CODE XREF: _uregex_find64_56+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_find64_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_findNext_56
_uregex_findNext_56 proc near		; CODE XREF: _uregex_replaceAll_56+9Bp

var_D8		= byte ptr -0D8h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_19E5
		xor	al, al
		jmp	short loc_1A0B
; ---------------------------------------------------------------------------

loc_19E5:				; CODE XREF: _uregex_findNext_56+3Bj
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_11], al
		mov	al, [ebp+var_11]

loc_1A0B:				; CODE XREF: _uregex_findNext_56+3Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_findNext_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_groupCount_56
_uregex_groupCount_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1A61
		xor	eax, eax
		jmp	short loc_1A85
; ---------------------------------------------------------------------------

loc_1A61:				; CODE XREF: _uregex_groupCount_56+3Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]

loc_1A85:				; CODE XREF: _uregex_groupCount_56+3Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_groupCount_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uregex_groupNumberFromName_56(int, wchar_t *, int, int)
		public _uregex_groupNumberFromName_56
_uregex_groupNumberFromName_56 proc near

var_124		= byte ptr -124h
var_120		= byte ptr -120h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_124]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+var_C]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1AE7
		xor	eax, eax
		jmp	short loc_1B42
; ---------------------------------------------------------------------------

loc_1AE7:				; CODE XREF: _uregex_groupNumberFromName_56+45j
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t *
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PB_WH@Z	; icu_56::UnicodeString::UnicodeString(wchar_t const *,int)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_C]
		mov	eax, [edx+4]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_18], eax
		mov	esi, esp
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]

loc_1B42:				; CODE XREF: _uregex_groupNumberFromName_56+49j
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_groupNumberFromName_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_groupNumberFromCName_56
_uregex_groupNumberFromCName_56	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1BA1
		xor	eax, eax
		jmp	short loc_1BCB
; ---------------------------------------------------------------------------

loc_1BA1:				; CODE XREF: _uregex_groupNumberFromCName_56+3Bj
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+4]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1BCB:				; CODE XREF: _uregex_groupNumberFromCName_56+3Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_groupNumberFromCName_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_group_56
_uregex_group_56 proc near		; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+A72p
					; icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t	*,int,int *,wchar_t * *	const,int,UErrorCode *)+2D2p

var_128		= byte ptr -128h
var_64		= dword	ptr -64h
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 128h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_128]
		mov	ecx, 4Ah ; 'J'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_10]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1C24
		xor	eax, eax
		jmp	loc_1DEE
; ---------------------------------------------------------------------------

loc_1C24:				; CODE XREF: _uregex_group_56+3Bj
		cmp	[ebp+arg_C], 0
		jl	short loc_1C36
		cmp	[ebp+arg_C], 0
		jle	short loc_1C46
		cmp	[ebp+arg_8], 0
		jnz	short loc_1C46

loc_1C36:				; CODE XREF: _uregex_group_56+48j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_1DEE
; ---------------------------------------------------------------------------

loc_1C46:				; CODE XREF: _uregex_group_56+4Ej
					; _uregex_group_56+54j
		cmp	[ebp+arg_C], 0
		jz	short loc_1C59
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 0
		jz	loc_1D3A

loc_1C59:				; CODE XREF: _uregex_group_56+6Aj
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+38h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+48h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1CC3
		xor	eax, eax
		jmp	loc_1DEE
; ---------------------------------------------------------------------------

loc_1CC3:				; CODE XREF: _uregex_group_56+DAj
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+var_14]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+arg_C]
		jge	short loc_1CE8
		xor	eax, eax
		mov	ecx, [ebp+var_38]
		mov	edx, [ebp+arg_8]
		mov	[edx+ecx*2], ax
		jmp	short loc_1D0A
; ---------------------------------------------------------------------------

loc_1CE8:				; CODE XREF: _uregex_group_56+F8j
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+arg_C]
		jnz	short loc_1CFB
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0FFFFFF84h
		jmp	short loc_1D0A
; ---------------------------------------------------------------------------

loc_1CFB:				; CODE XREF: _uregex_group_56+10Ej
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0Fh

loc_1D0A:				; CODE XREF: _uregex_group_56+106j
					; _uregex_group_56+119j
		cmp	[ebp+var_38], 0
		jle	short loc_1D2D
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+18h]
		mov	eax, [ebp+var_14]
		lea	ecx, [edx+eax*2]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_u_memcpy_56
		add	esp, 0Ch

loc_1D2D:				; CODE XREF: _uregex_group_56+12Ej
		mov	eax, [ebp+var_2C]
		jmp	loc_1DEE
; ---------------------------------------------------------------------------
		jmp	loc_1DEE
; ---------------------------------------------------------------------------

loc_1D3A:				; CODE XREF: _uregex_group_56+73j
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+40h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_48], eax
		mov	[ebp+var_44], edx
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+50h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_58], eax
		mov	[ebp+var_54], edx
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1DA7
		xor	eax, eax
		jmp	short loc_1DEE
; ---------------------------------------------------------------------------

loc_1DA7:				; CODE XREF: _uregex_group_56+1C1j
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+var_54]
		push	eax
		mov	ecx, [ebp+var_58]
		push	ecx
		mov	edx, [ebp+var_44]
		push	edx
		mov	eax, [ebp+var_48]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	esi, esp
		mov	eax, [edx+70h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	_utext_extract_56
		add	esp, 20h
		mov	[ebp+var_64], eax
		mov	eax, [ebp+var_64]

loc_1DEE:				; CODE XREF: _uregex_group_56+3Fj
					; _uregex_group_56+61j	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 128h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_group_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_groupUText_56
_uregex_groupUText_56 proc near

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_10]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1E7B
		mov	[ebp+var_14], 0
		cmp	[ebp+arg_8], 0
		jz	short loc_1E59
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_DC], eax
		jmp	short loc_1E73
; ---------------------------------------------------------------------------

loc_1E59:				; CODE XREF: _uregex_groupUText_56+48j
		lea	ecx, [ebp+var_14]
		push	ecx
		push	0
		push	0
		push	0
		push	0
		call	_utext_openUChars_56
		add	esp, 14h
		mov	[ebp+var_DC], eax

loc_1E73:				; CODE XREF: _uregex_groupUText_56+53j
		mov	eax, [ebp+var_DC]
		jmp	short loc_1EA7
; ---------------------------------------------------------------------------

loc_1E7B:				; CODE XREF: _uregex_groupUText_56+3Bj
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1EA7:				; CODE XREF: _uregex_groupUText_56+75j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_groupUText_56 endp

; ---------------------------------------------------------------------------
$LN8_2		dd 1			; DATA XREF: _uregex_groupUText_56+A7o
		dd offset $LN7_1
$LN7_1		dd 0FFFFFFECh, 4	; DATA XREF: .text:00001ED0o
		dd offset $LN6_0	; "emptyTextStatus"
$LN6_0		db 'emptyTextStatus',0  ; DATA XREF: .text:00001EDCo
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_start_56
_uregex_start_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_uregex_start64_56
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_start_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_start64_56
_uregex_start64_56 proc	near		; CODE XREF: _uregex_start_56+2Ap

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1F7B
		xor	eax, eax
		xor	edx, edx
		jmp	short loc_1FA6
; ---------------------------------------------------------------------------

loc_1F7B:				; CODE XREF: _uregex_start64_56+3Bj
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+38h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		cdq

loc_1FA6:				; CODE XREF: _uregex_start64_56+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_start64_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_end_56
_uregex_end_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_uregex_end64_56
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp

loc_2000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		pop	ebp
		retn
_uregex_end_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2004h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_end64_56
_uregex_end64_56 proc near		; CODE XREF: _uregex_end_56+2Ap

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2047
		xor	eax, eax
		xor	edx, edx
		jmp	short loc_2072
; ---------------------------------------------------------------------------

loc_2047:				; CODE XREF: _uregex_end64_56+3Bj
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+48h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		cdq

loc_2072:				; CODE XREF: _uregex_end64_56+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_end64_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2088h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_reset_56
_uregex_reset_56 proc near		; CODE XREF: _uregex_replaceAll_56+83p
					; _uregex_replaceFirst_56+80p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax
		mov	eax, [ebp+arg_4]
		cdq
		push	edx
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uregex_reset64_56
		add	esp, 10h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_reset_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_reset64_56
_uregex_reset64_56 proc	near		; CODE XREF: _uregex_reset_56+2Cp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_210F
		jmp	short loc_2139
; ---------------------------------------------------------------------------

loc_210F:				; CODE XREF: _uregex_reset64_56+3Bj
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+60h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2139:				; CODE XREF: _uregex_reset64_56+3Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_reset64_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2150h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_setRegion_56
_uregex_setRegion_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		push	eax
		mov	eax, [ebp+arg_8]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+arg_4]
		cdq
		push	edx
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uregex_setRegion64_56
		add	esp, 18h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_setRegion_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_setRegion64_56
_uregex_setRegion64_56 proc near	; CODE XREF: _uregex_setRegion_56+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_14]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_21DF
		jmp	short loc_220F
; ---------------------------------------------------------------------------

loc_21DF:				; CODE XREF: _uregex_setRegion64_56+3Bj
		mov	esi, esp
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+7Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_220F:				; CODE XREF: _uregex_setRegion64_56+3Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_setRegion64_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2224h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_setRegionAndStart_56
_uregex_setRegionAndStart_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_1C]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2263
		jmp	short loc_229B
; ---------------------------------------------------------------------------

loc_2263:				; CODE XREF: _uregex_setRegionAndStart_56+3Bj
		mov	esi, esp
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+arg_18]
		push	ecx
		mov	edx, [ebp+arg_14]
		push	edx
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+78h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_229B:				; CODE XREF: _uregex_setRegionAndStart_56+3Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_setRegionAndStart_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_regionStart_56
_uregex_regionStart_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uregex_regionStart64_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_regionStart_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_regionStart64_56
_uregex_regionStart64_56 proc near	; CODE XREF: _uregex_regionStart_56+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2337
		xor	eax, eax
		xor	edx, edx
		jmp	short loc_2359
; ---------------------------------------------------------------------------

loc_2337:				; CODE XREF: _uregex_regionStart64_56+3Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+80h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cdq

loc_2359:				; CODE XREF: _uregex_regionStart64_56+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_regionStart64_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2370h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_regionEnd_56
_uregex_regionEnd_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uregex_regionEnd64_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_regionEnd_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_regionEnd64_56
_uregex_regionEnd64_56 proc near	; CODE XREF: _uregex_regionEnd_56+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_23F7
		xor	eax, eax
		xor	edx, edx
		jmp	short loc_2419
; ---------------------------------------------------------------------------

loc_23F7:				; CODE XREF: _uregex_regionEnd64_56+3Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+88h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cdq

loc_2419:				; CODE XREF: _uregex_regionEnd64_56+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_regionEnd64_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2430h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_hasTransparentBounds_56
_uregex_hasTransparentBounds_56	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2471
		xor	al, al
		jmp	short loc_2492
; ---------------------------------------------------------------------------

loc_2471:				; CODE XREF: _uregex_hasTransparentBounds_56+3Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+90h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2492:				; CODE XREF: _uregex_hasTransparentBounds_56+3Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_hasTransparentBounds_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_useTransparentBounds_56
_uregex_useTransparentBounds_56	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_24E7
		jmp	short loc_250B
; ---------------------------------------------------------------------------

loc_24E7:				; CODE XREF: _uregex_useTransparentBounds_56+3Bj
		mov	esi, esp
		movzx	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+94h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_250B:				; CODE XREF: _uregex_useTransparentBounds_56+3Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_useTransparentBounds_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2520h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_hasAnchoringBounds_56
_uregex_hasAnchoringBounds_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2561
		xor	al, al
		jmp	short loc_2582
; ---------------------------------------------------------------------------

loc_2561:				; CODE XREF: _uregex_hasAnchoringBounds_56+3Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+98h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2582:				; CODE XREF: _uregex_hasAnchoringBounds_56+3Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_hasAnchoringBounds_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2598h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_useAnchoringBounds_56
_uregex_useAnchoringBounds_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_25D7
		jmp	short loc_25FB
; ---------------------------------------------------------------------------

loc_25D7:				; CODE XREF: _uregex_useAnchoringBounds_56+3Bj
		mov	esi, esp
		movzx	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+9Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_25FB:				; CODE XREF: _uregex_useAnchoringBounds_56+3Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_useAnchoringBounds_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2610h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_hitEnd_56
_uregex_hitEnd_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2651
		xor	al, al
		jmp	short loc_2672
; ---------------------------------------------------------------------------

loc_2651:				; CODE XREF: _uregex_hitEnd_56+3Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+0A0h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2672:				; CODE XREF: _uregex_hitEnd_56+3Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_hitEnd_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2688h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_requireEnd_56
_uregex_requireEnd_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_26C9
		xor	al, al
		jmp	short loc_26EA
; ---------------------------------------------------------------------------

loc_26C9:				; CODE XREF: _uregex_requireEnd_56+3Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+0A4h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_26EA:				; CODE XREF: _uregex_requireEnd_56+3Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_requireEnd_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2700h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_setTimeLimit_56
_uregex_setTimeLimit_56	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jz	short loc_2764
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+0D4h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2764:				; CODE XREF: _uregex_setTimeLimit_56+3Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_setTimeLimit_56	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2778h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_getTimeLimit_56
_uregex_getTimeLimit_56	proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+var_14]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jz	short loc_27E0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+0D8h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax

loc_27E0:				; CODE XREF: _uregex_getTimeLimit_56+42j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_getTimeLimit_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_setStackLimit_56
_uregex_setStackLimit_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jz	short loc_285C
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+0DCh]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_285C:				; CODE XREF: _uregex_setStackLimit_56+3Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_setStackLimit_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2870h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_getStackLimit_56
_uregex_getStackLimit_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+var_14]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jz	short loc_28D8
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+0E0h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax

loc_28D8:				; CODE XREF: _uregex_getStackLimit_56+42j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_getStackLimit_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_setMatchCallback_56
_uregex_setMatchCallback_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jz	short loc_295A
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+0E4h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_295A:				; CODE XREF: _uregex_setMatchCallback_56+3Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_setMatchCallback_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2970h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_getMatchCallback_56
_uregex_getMatchCallback_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jz	short loc_29DA
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+0E8h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_29DA:				; CODE XREF: _uregex_getMatchCallback_56+3Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_getMatchCallback_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_setFindProgressCallback_56
_uregex_setFindProgressCallback_56 proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jz	short loc_2A5A
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+0ECh]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2A5A:				; CODE XREF: _uregex_setFindProgressCallback_56+3Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_setFindProgressCallback_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_getFindProgressCallback_56
_uregex_getFindProgressCallback_56 proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jz	short loc_2ADA
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+0F0h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2ADA:				; CODE XREF: _uregex_getFindProgressCallback_56+3Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_getFindProgressCallback_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2AF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uregex_replaceAll_56(int,	wchar_t	*, int,	wchar_t	*, int,	enum UErrorCode	*)
		public _uregex_replaceAll_56
_uregex_replaceAll_56 proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_14]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2B34
		xor	eax, eax
		jmp	loc_2BFE
; ---------------------------------------------------------------------------

loc_2B34:				; CODE XREF: _uregex_replaceAll_56+3Bj
		cmp	[ebp+arg_4], 0
		jz	short loc_2B52
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jl	short loc_2B52
		cmp	[ebp+arg_C], 0
		jnz	short loc_2B4C
		cmp	[ebp+arg_10], 0
		jg	short loc_2B52

loc_2B4C:				; CODE XREF: _uregex_replaceAll_56+54j
		cmp	[ebp+arg_10], 0
		jge	short loc_2B62

loc_2B52:				; CODE XREF: _uregex_replaceAll_56+48j
					; _uregex_replaceAll_56+4Ej ...
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_2BFE
; ---------------------------------------------------------------------------

loc_2B62:				; CODE XREF: _uregex_replaceAll_56+60j
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_14]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uregex_reset_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		mov	[ebp+var_20], ecx

loc_2B83:				; CODE XREF: _uregex_replaceAll_56+D0j
		lea	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uregex_findNext_56
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_2BC2
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+arg_10]
		push	ecx		; int *
		lea	edx, [ebp+arg_C]
		push	edx		; wchar_t **
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_0]
		push	edx		; int
		call	_uregex_appendReplacement_56
		add	esp, 18h
		add	eax, [ebp+var_14]
		mov	[ebp+var_14], eax
		jmp	short loc_2B83
; ---------------------------------------------------------------------------

loc_2BC2:				; CODE XREF: _uregex_replaceAll_56+A8j
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+arg_10]
		push	ecx		; int *
		lea	edx, [ebp+arg_C]
		push	edx		; wchar_t **
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	_uregex_appendTail_56
		add	esp, 10h
		add	eax, [ebp+var_14]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_2BFB
		mov	eax, [ebp+arg_14]
		mov	ecx, [ebp+var_20]
		mov	[eax], ecx

loc_2BFB:				; CODE XREF: _uregex_replaceAll_56+101j
		mov	eax, [ebp+var_14]

loc_2BFE:				; CODE XREF: _uregex_replaceAll_56+3Fj
					; _uregex_replaceAll_56+6Dj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_replaceAll_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN12		dd 1			; DATA XREF: _uregex_replaceAll_56+112o
		dd offset $LN11
$LN11		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00002C28o
		dd offset $LN10_0	; "findStatus"
$LN10_0		db 'findStatus',0       ; DATA XREF: .text:00002C34o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_replaceAllUText_56
_uregex_replaceAllUText_56 proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2C85
		xor	eax, eax
		jmp	short loc_2CCB
; ---------------------------------------------------------------------------

loc_2C85:				; CODE XREF: _uregex_replaceAllUText_56+3Bj
		cmp	[ebp+arg_4], 0
		jnz	short loc_2C98
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_2CCB
; ---------------------------------------------------------------------------

loc_2C98:				; CODE XREF: _uregex_replaceAllUText_56+45j
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+0ACh]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+arg_8], eax
		mov	eax, [ebp+arg_8]

loc_2CCB:				; CODE XREF: _uregex_replaceAllUText_56+3Fj
					; _uregex_replaceAllUText_56+52j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_replaceAllUText_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uregex_replaceFirst_56(int, wchar_t *, int, wchar_t *, int, enum UErrorCode *)
		public _uregex_replaceFirst_56
_uregex_replaceFirst_56	proc near

var_E4		= byte ptr -0E4h
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_14]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2D24
		xor	eax, eax
		jmp	loc_2DC9
; ---------------------------------------------------------------------------

loc_2D24:				; CODE XREF: _uregex_replaceFirst_56+3Bj
		cmp	[ebp+arg_4], 0
		jz	short loc_2D42
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jl	short loc_2D42
		cmp	[ebp+arg_C], 0
		jnz	short loc_2D3C
		cmp	[ebp+arg_10], 0
		jg	short loc_2D42

loc_2D3C:				; CODE XREF: _uregex_replaceFirst_56+54j
		cmp	[ebp+arg_10], 0
		jge	short loc_2D4F

loc_2D42:				; CODE XREF: _uregex_replaceFirst_56+48j
					; _uregex_replaceFirst_56+4Ej ...
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_2DC9
; ---------------------------------------------------------------------------

loc_2D4F:				; CODE XREF: _uregex_replaceFirst_56+60j
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_14]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uregex_reset_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_14]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_uregex_find_56
		add	esp, 0Ch
		mov	[ebp+var_1D], al
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jz	short loc_2DA8
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+arg_10]
		push	ecx		; int *
		lea	edx, [ebp+arg_C]
		push	edx		; wchar_t **
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_0]
		push	edx		; int
		call	_uregex_appendReplacement_56
		add	esp, 18h
		mov	[ebp+var_14], eax

loc_2DA8:				; CODE XREF: _uregex_replaceFirst_56+A3j
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+arg_10]
		push	ecx		; int *
		lea	edx, [ebp+arg_C]
		push	edx		; wchar_t **
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	_uregex_appendTail_56
		add	esp, 10h
		add	eax, [ebp+var_14]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]

loc_2DC9:				; CODE XREF: _uregex_replaceFirst_56+3Fj
					; _uregex_replaceFirst_56+6Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_replaceFirst_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_replaceFirstUText_56
_uregex_replaceFirstUText_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2E21
		xor	eax, eax
		jmp	short loc_2E67
; ---------------------------------------------------------------------------

loc_2E21:				; CODE XREF: _uregex_replaceFirstUText_56+3Bj
		cmp	[ebp+arg_4], 0
		jnz	short loc_2E34
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_2E67
; ---------------------------------------------------------------------------

loc_2E34:				; CODE XREF: _uregex_replaceFirstUText_56+45j
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+0B4h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+arg_8], eax
		mov	eax, [ebp+arg_8]

loc_2E67:				; CODE XREF: _uregex_replaceFirstUText_56+3Fj
					; _uregex_replaceFirstUText_56+52j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_replaceFirstUText_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uregex_appendReplacement_56(int, wchar_t *, int, wchar_t **, int *, enum UErrorCode *)
		public _uregex_appendReplacement_56
_uregex_appendReplacement_56 proc near	; CODE XREF: _uregex_replaceAll_56+C2p
					; _uregex_replaceFirst_56+BDp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; int *
		mov	edx, [ebp+arg_C]
		push	edx		; wchar_t **
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::RegularExpression *
		call	?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z ; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode *)
		add	esp, 18h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_appendReplacement_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2ED4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::RegexCImpl::appendReplacement(struct icu_56::RegularExpression *,	const wchar_t *, int, wchar_t **, int *, enum UErrorCode *)
		public ?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z
?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z proc near
					; CODE XREF: _uregex_appendReplacement_56+3Cp

var_21C		= dword	ptr -21Ch
var_218		= dword	ptr -218h
var_150		= word ptr -150h
var_144		= byte ptr -144h
var_FC		= dword	ptr -0FCh
var_F0		= word ptr -0F0h
var_E4		= dword	ptr -0E4h
var_D8		= dword	ptr -0D8h
var_CC		= word ptr -0CCh
var_C0		= dword	ptr -0C0h
var_B4		= dword	ptr -0B4h
var_A8		= dword	ptr -0A8h
var_9C		= word ptr -9Ch
var_90		= dword	ptr -90h
var_84		= dword	ptr -84h
var_78		= dword	ptr -78h
var_6C		= dword	ptr -6Ch
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_15		= byte ptr -15h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 210h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_21C]
		mov	ecx, 84h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_15], 0
		mov	eax, [ebp+arg_14]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_2F3B
		cmp	[ebp+arg_10], 0
		jz	short loc_2F3B
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jnz	short loc_2F3B
		mov	[ebp+var_15], 1
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 0

loc_2F3B:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+4Aj
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+50j ...
		mov	eax, [ebp+arg_14]
		push	eax
		push	1
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_2F5B
		xor	eax, eax
		jmp	loc_3A41
; ---------------------------------------------------------------------------

loc_2F5B:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+7Ej
		cmp	[ebp+arg_4], 0
		jz	short loc_2F8B
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jl	short loc_2F8B
		cmp	[ebp+arg_10], 0
		jz	short loc_2F8B
		cmp	[ebp+arg_C], 0
		jz	short loc_2F8B
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0
		jnz	short loc_2F83
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jg	short loc_2F8B

loc_2F83:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+A5j
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jge	short loc_2F9B

loc_2F8B:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+8Bj
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+91j ...
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_3A41
; ---------------------------------------------------------------------------

loc_2F9B:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+B5j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_24], ecx
		mov	eax, [ebp+var_24]
		movsx	ecx, byte ptr [eax+6Ah]
		test	ecx, ecx
		jnz	short loc_2FBF
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 10302h
		xor	eax, eax
		jmp	loc_3A41
; ---------------------------------------------------------------------------

loc_2FBF:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+D9j
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		mov	[ebp+var_30], ecx
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		mov	[ebp+var_3C], ecx
		mov	[ebp+var_48], 0
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jnz	short loc_2FEB
		mov	eax, [ebp+arg_4]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_2FEB:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+106j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	loc_30D6
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+10h]

loc_2FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		mov	edx, [ecx+34h]
		cmp	dword ptr [edx+2Ch], 0
		jnz	short loc_301E
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+80h]
		mov	[ebp+var_6C], ecx
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+70h]
		mov	[ebp+var_60], ecx
		jmp	short loc_3094
; ---------------------------------------------------------------------------

loc_301E:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+131j
		mov	[ebp+var_78], 0
		lea	eax, [ebp+var_78]
		push	eax
		push	0
		push	0
		mov	ecx, [ebp+var_24]
		mov	edx, [ecx+84h]
		push	edx
		mov	eax, [ecx+80h]
		push	eax
		push	0
		push	0
		mov	ecx, [ebp+var_24]
		mov	edx, [ecx+10h]
		push	edx
		call	_utext_extract_56
		add	esp, 20h
		mov	[ebp+var_6C], eax
		mov	[ebp+var_78], 0
		lea	eax, [ebp+var_78]
		push	eax
		push	0
		push	0
		mov	ecx, [ebp+var_24]
		mov	edx, [ecx+74h]
		push	edx
		mov	eax, [ecx+70h]
		push	eax
		mov	ecx, [ebp+var_24]
		mov	edx, [ecx+84h]
		push	edx
		mov	eax, [ecx+80h]
		push	eax
		mov	ecx, [ebp+var_24]
		mov	edx, [ecx+10h]
		push	edx
		call	_utext_extract_56
		add	esp, 20h
		add	eax, [ebp+var_6C]
		mov	[ebp+var_60], eax

loc_3094:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+148j
		mov	eax, [ebp+var_6C]
		mov	[ebp+var_54], eax
		jmp	short loc_30A5
; ---------------------------------------------------------------------------

loc_309C:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+1FBj
		mov	eax, [ebp+var_54]
		add	eax, 1
		mov	[ebp+var_54], eax

loc_30A5:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+1C6j
		mov	eax, [ebp+var_54]
		cmp	eax, [ebp+var_60]
		jge	short loc_30D1
		mov	eax, [ebp+var_3C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		lea	edx, [ebp+var_48]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_54]
		movzx	eax, word ptr [ecx+edx*2]
		push	eax
		call	?appendToBuf@@YAX_WPAHPA_WH@Z ;	appendToBuf(wchar_t,int	*,wchar_t *,int)
		add	esp, 10h
		jmp	short loc_309C
; ---------------------------------------------------------------------------

loc_30D1:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+1D7j
		jmp	loc_3169
; ---------------------------------------------------------------------------

loc_30D6:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+11Ej
		mov	[ebp+var_84], 0
		mov	eax, [ebp+var_3C]
		sub	eax, [ebp+var_48]
		test	eax, eax
		jle	short loc_30F8
		mov	ecx, [ebp+var_3C]
		sub	ecx, [ebp+var_48]
		mov	[ebp+var_218], ecx
		jmp	short loc_3102
; ---------------------------------------------------------------------------

loc_30F8:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+214j
		mov	[ebp+var_218], 0

loc_3102:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+222j
		cmp	[ebp+var_30], 0
		jnz	short loc_3114
		mov	[ebp+var_21C], 0
		jmp	short loc_3123
; ---------------------------------------------------------------------------

loc_3114:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+232j
		mov	edx, [ebp+var_48]
		mov	eax, [ebp+var_30]
		lea	ecx, [eax+edx*2]
		mov	[ebp+var_21C], ecx

loc_3123:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+23Ej
		lea	edx, [ebp+var_84]
		push	edx
		mov	eax, [ebp+var_218]
		push	eax
		mov	ecx, [ebp+var_21C]
		push	ecx
		mov	edx, [ebp+var_24]
		mov	eax, [edx+74h]
		push	eax
		mov	ecx, [edx+70h]
		push	ecx
		mov	edx, [ebp+var_24]
		mov	eax, [edx+84h]
		push	eax
		mov	ecx, [edx+80h]
		push	ecx
		mov	edx, [ebp+var_24]
		mov	eax, [edx+10h]
		push	eax
		call	_utext_extract_56
		add	esp, 20h
		add	eax, [ebp+var_48]
		mov	[ebp+var_48], eax

loc_3169:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*):loc_30D1j
		cmp	[ebp+var_48], 0
		jge	short loc_3194
		mov	eax, ds:?__LINE__Var@?1??appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@3@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z@4JA@34ef717a
		add	eax, 42h ; 'B'
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FG@DFDDLAOB@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_1BK@KDFMMPOE@?$AAd?$AAe?$AAs?$AAt?$AAI?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@	; "destIdx >= 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3194:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+299j
		mov	[ebp+var_90], 0

loc_319E:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+349j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *):loc_330Fj ...
		mov	eax, [ebp+var_90]
		cmp	eax, [ebp+arg_8]
		jge	loc_3981
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_3981
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_9C], dx
		mov	eax, [ebp+var_90]
		add	eax, 1
		mov	[ebp+var_90], eax
		movzx	eax, [ebp+var_9C]
		cmp	eax, 24h ; '$'
		jz	short loc_3222
		movzx	eax, [ebp+var_9C]
		cmp	eax, 5Ch ; '\'
		jz	short loc_3222
		mov	eax, [ebp+var_3C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		lea	edx, [ebp+var_48]
		push	edx
		movzx	eax, [ebp+var_9C]
		push	eax
		call	?appendToBuf@@YAX_WPAHPA_WH@Z ;	appendToBuf(wchar_t,int	*,wchar_t *,int)
		add	esp, 10h
		jmp	loc_319E
; ---------------------------------------------------------------------------

loc_3222:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+31Fj
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+32Bj
		movzx	eax, [ebp+var_9C]
		cmp	eax, 5Ch ; '\'
		jnz	loc_3344
		mov	eax, [ebp+var_90]
		cmp	eax, [ebp+arg_8]
		jl	short loc_3242
		jmp	loc_3981
; ---------------------------------------------------------------------------

loc_3242:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+367j
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_9C], dx
		movzx	eax, [ebp+var_9C]
		cmp	eax, 55h ; 'U'
		jz	short loc_3272
		movzx	eax, [ebp+var_9C]
		cmp	eax, 75h ; 'u'
		jnz	loc_3314

loc_3272:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+38Cj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		lea	edx, [ebp+var_90]
		push	edx
		push	offset _uregex_ucstr_unescape_charAt_56
		call	_u_unescapeAt_56
		add	esp, 10h
		mov	[ebp+var_A8], eax
		cmp	[ebp+var_A8], 0FFFFFFFFh
		jz	short loc_3314
		cmp	[ebp+var_A8], 0FFFFh
		jg	short loc_32C7
		mov	eax, [ebp+var_3C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		lea	edx, [ebp+var_48]
		push	edx
		movzx	eax, word ptr [ebp+var_A8]
		push	eax
		call	?appendToBuf@@YAX_WPAHPA_WH@Z ;	appendToBuf(wchar_t,int	*,wchar_t *,int)
		add	esp, 10h
		jmp	short loc_330F
; ---------------------------------------------------------------------------

loc_32C7:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+3D3j
		mov	eax, [ebp+var_3C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		lea	edx, [ebp+var_48]
		push	edx
		mov	eax, [ebp+var_A8]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		push	eax
		call	?appendToBuf@@YAX_WPAHPA_WH@Z ;	appendToBuf(wchar_t,int	*,wchar_t *,int)
		add	esp, 10h
		mov	eax, [ebp+var_3C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		lea	edx, [ebp+var_48]
		push	edx
		mov	eax, [ebp+var_A8]
		and	eax, 3FFh
		or	eax, 0DC00h
		push	eax
		call	?appendToBuf@@YAX_WPAHPA_WH@Z ;	appendToBuf(wchar_t,int	*,wchar_t *,int)
		add	esp, 10h

loc_330F:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+3F1j
		jmp	loc_319E
; ---------------------------------------------------------------------------

loc_3314:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+398j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+3C7j
		mov	eax, [ebp+var_3C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		lea	edx, [ebp+var_48]
		push	edx
		movzx	eax, [ebp+var_9C]
		push	eax
		call	?appendToBuf@@YAX_WPAHPA_WH@Z ;	appendToBuf(wchar_t,int	*,wchar_t *,int)
		add	esp, 10h
		mov	eax, [ebp+var_90]
		add	eax, 1
		mov	[ebp+var_90], eax
		jmp	loc_319E
; ---------------------------------------------------------------------------

loc_3344:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+358j
		mov	[ebp+var_B4], 0
		movzx	eax, [ebp+var_9C]
		cmp	eax, 24h ; '$'
		jz	short loc_3380
		mov	ecx, ds:?__LINE__Var@?1??appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@3@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z@4JA@34ef717a
		add	ecx, 7Bh ; '{'
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FG@DFDDLAOB@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_1CA@BEAIEIMD@?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAD?$AAO?$AAL?$AAL?$AAA?$AAR?$AAS?$AAI?$AAG?$AAN?$AA?$AA@ ; "c == DOLLARSIGN"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3380:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+484j
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_C0], edx
		mov	eax, [ebp+var_C0]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	loc_3459
		mov	eax, [ebp+var_C0]
		and	eax, 400h
		jnz	short loc_340B
		mov	eax, [ebp+var_90]
		add	eax, 1
		cmp	eax, [ebp+arg_8]
		jz	short loc_3409
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		mov	dx, [ecx+eax*2+2]
		mov	[ebp+var_CC], dx
		movzx	eax, [ebp+var_CC]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_3409
		mov	eax, [ebp+var_C0]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_CC]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_C0], edx

loc_3409:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+4EEj
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+516j
		jmp	short loc_3459
; ---------------------------------------------------------------------------

loc_340B:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+4E0j
		cmp	[ebp+var_90], 0
		jle	short loc_3459
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		mov	dx, [ecx+eax*2-2]
		mov	[ebp+var_CC], dx
		movzx	eax, [ebp+var_CC]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_3459
		movzx	eax, [ebp+var_CC]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_C0]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_C0], edx

loc_3459:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+4CFj
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *):loc_3409j ...
		mov	eax, [ebp+var_C0]
		push	eax
		call	_u_isdigit_56
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_3691
		mov	[ebp+var_D8], 0
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+4]
		mov	esi, esp
		mov	ecx, [ecx+6Ch]	; this
		call	dword ptr ds:__imp_?size@UVector32@icu_56@@QBEHXZ ; icu_56::UVector32::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E4], eax

loc_349B:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*):loc_3687j
		mov	eax, [ebp+var_90]
		cmp	eax, [ebp+arg_8]
		jl	short loc_34AB
		jmp	loc_368C
; ---------------------------------------------------------------------------

loc_34AB:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+5D0j
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_C0], edx
		mov	eax, [ebp+var_C0]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	loc_3584
		mov	eax, [ebp+var_C0]
		and	eax, 400h
		jnz	short loc_3536
		mov	eax, [ebp+var_90]
		add	eax, 1
		cmp	eax, [ebp+arg_8]
		jz	short loc_3534
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		mov	dx, [ecx+eax*2+2]
		mov	[ebp+var_F0], dx
		movzx	eax, [ebp+var_F0]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_3534
		mov	eax, [ebp+var_C0]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_F0]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_C0], edx

loc_3534:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+619j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+641j
		jmp	short loc_3584
; ---------------------------------------------------------------------------

loc_3536:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+60Bj
		cmp	[ebp+var_90], 0
		jle	short loc_3584
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		mov	dx, [ecx+eax*2-2]
		mov	[ebp+var_F0], dx
		movzx	eax, [ebp+var_F0]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_3584
		movzx	eax, [ebp+var_F0]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_C0]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_C0], edx

loc_3584:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+5FAj
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *):loc_3534j ...
		mov	eax, [ebp+var_C0]
		push	eax
		call	_u_isdigit_56
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_359F
		jmp	loc_368C
; ---------------------------------------------------------------------------

loc_359F:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+6C4j
		mov	eax, [ebp+var_C0]
		push	eax
		call	_u_charDigitValue_56
		add	esp, 4
		mov	[ebp+var_FC], eax
		mov	eax, [ebp+var_B4]
		imul	eax, 0Ah
		add	eax, [ebp+var_FC]
		cmp	eax, [ebp+var_E4]
		jg	loc_3673
		mov	eax, [ebp+var_B4]
		imul	eax, 0Ah
		add	eax, [ebp+var_FC]
		mov	[ebp+var_B4], eax
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		movzx	edx, word ptr [ecx+eax*2]
		and	edx, 0FFFFFC00h
		mov	eax, [ebp+var_90]
		add	eax, 1
		mov	[ebp+var_90], eax
		cmp	edx, 0D800h
		jnz	short loc_361A
		mov	[ebp+var_218], 1
		jmp	short loc_3624
; ---------------------------------------------------------------------------

loc_361A:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+738j
		mov	[ebp+var_218], 0

loc_3624:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+744j
		cmp	[ebp+var_218], 0
		jz	short loc_3662
		mov	eax, [ebp+var_90]
		cmp	eax, [ebp+arg_8]
		jz	short loc_3662
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		movzx	edx, word ptr [ecx+eax*2]
		and	edx, 0FFFFFC00h
		cmp	edx, 0DC00h
		jnz	short loc_3662
		mov	eax, [ebp+var_90]
		add	eax, 1
		mov	[ebp+var_90], eax

loc_3662:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+757j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+762j ...
		mov	eax, [ebp+var_D8]
		add	eax, 1
		mov	[ebp+var_D8], eax
		jmp	short loc_3687
; ---------------------------------------------------------------------------

loc_3673:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+6F5j
		cmp	[ebp+var_D8], 0
		jnz	short loc_3685
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 8

loc_3685:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+7A6j
		jmp	short loc_368C
; ---------------------------------------------------------------------------

loc_3687:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+79Dj
		jmp	loc_349B
; ---------------------------------------------------------------------------

loc_368C:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+5D2j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+6C6j ...
		jmp	loc_38D1
; ---------------------------------------------------------------------------

loc_3691:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+599j
		cmp	[ebp+var_C0], 7Bh ; '{'
		jnz	loc_38C8
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		movzx	edx, word ptr [ecx+eax*2]
		and	edx, 0FFFFFC00h
		mov	eax, [ebp+var_90]
		add	eax, 1
		mov	[ebp+var_90], eax
		cmp	edx, 0D800h
		jnz	short loc_36F0
		mov	[ebp+var_218], 1
		jmp	short loc_36FA
; ---------------------------------------------------------------------------

loc_36F0:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+80Ej
		mov	[ebp+var_218], 0

loc_36FA:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+81Aj
		cmp	[ebp+var_218], 0
		jz	short loc_3738
		mov	eax, [ebp+var_90]
		cmp	eax, [ebp+arg_8]
		jz	short loc_3738
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		movzx	edx, word ptr [ecx+eax*2]
		and	edx, 0FFFFFC00h
		cmp	edx, 0DC00h
		jnz	short loc_3738
		mov	eax, [ebp+var_90]
		add	eax, 1
		mov	[ebp+var_90], eax

loc_3738:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+82Dj
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+838j ...
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_38AA
		cmp	[ebp+var_C0], 7Dh ; '}'
		jz	loc_38AA
		mov	eax, [ebp+var_90]
		cmp	eax, [ebp+arg_8]
		jl	short loc_3777
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 10315h
		jmp	loc_38AA
; ---------------------------------------------------------------------------

loc_3777:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+893j
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_C0], edx
		mov	eax, [ebp+var_90]
		add	eax, 1
		mov	[ebp+var_90], eax
		mov	eax, [ebp+var_C0]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_3809
		mov	eax, [ebp+var_90]
		cmp	eax, [ebp+arg_8]
		jz	short loc_3809
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+arg_4]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_150], dx
		movzx	eax, [ebp+var_150]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_3809
		mov	eax, [ebp+var_90]
		add	eax, 1
		mov	[ebp+var_90], eax
		mov	eax, [ebp+var_C0]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_150]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_C0], edx

loc_3809:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+8D5j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+8E0j ...
		cmp	[ebp+var_C0], 41h ; 'A'
		jl	short loc_381B
		cmp	[ebp+var_C0], 5Ah ; 'Z'
		jle	short loc_383F

loc_381B:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+93Cj
		cmp	[ebp+var_C0], 61h ; 'a'
		jl	short loc_382D
		cmp	[ebp+var_C0], 7Ah ; 'z'
		jle	short loc_383F

loc_382D:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+94Ej
		cmp	[ebp+var_C0], 31h ; '1'
		jl	short loc_385D
		cmp	[ebp+var_C0], 39h ; '9'
		jg	short loc_385D

loc_383F:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+945j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+957j
		mov	esi, esp
		mov	eax, [ebp+var_C0]
		push	eax		; int
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@H@Z ;	icu_56::UnicodeString::append(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_38A5
; ---------------------------------------------------------------------------

loc_385D:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+960j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+969j
		cmp	[ebp+var_C0], 7Dh ; '}'
		jnz	short loc_389C
		lea	eax, [ebp+var_144]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	eax, [edx+94h]
		push	eax
		call	_uhash_geti_56
		add	esp, 8
		mov	[ebp+var_B4], eax
		cmp	[ebp+var_B4], 0
		jnz	short loc_389A
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 10315h

loc_389A:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+9BBj
		jmp	short loc_38A5
; ---------------------------------------------------------------------------

loc_389C:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+990j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 10315h

loc_38A5:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+987j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *):loc_389Aj
		jmp	loc_3738
; ---------------------------------------------------------------------------

loc_38AA:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+877j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+884j ...
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_38D1
; ---------------------------------------------------------------------------

loc_38C8:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+7C4j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 10315h

loc_38D1:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*):loc_368Cj
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+9F2j
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3965
		mov	eax, [ebp+var_3C]
		sub	eax, [ebp+var_48]
		test	eax, eax
		jle	short loc_38FE
		mov	ecx, [ebp+var_3C]
		sub	ecx, [ebp+var_48]
		mov	[ebp+var_218], ecx
		jmp	short loc_3908
; ---------------------------------------------------------------------------

loc_38FE:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+A1Aj
		mov	[ebp+var_218], 0

loc_3908:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+A28j
		cmp	[ebp+var_30], 0
		jnz	short loc_391A
		mov	[ebp+var_21C], 0
		jmp	short loc_3929
; ---------------------------------------------------------------------------

loc_391A:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+A38j
		mov	edx, [ebp+var_48]
		mov	eax, [ebp+var_30]
		lea	ecx, [eax+edx*2]
		mov	[ebp+var_21C], ecx

loc_3929:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+A44j
		mov	edx, [ebp+arg_14]
		push	edx
		mov	eax, [ebp+var_218]
		push	eax
		mov	ecx, [ebp+var_21C]
		push	ecx
		mov	edx, [ebp+var_B4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uregex_group_56
		add	esp, 14h
		add	eax, [ebp+var_48]
		mov	[ebp+var_48], eax
		mov	eax, [ebp+arg_14]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_3965
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 0

loc_3965:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+A10j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+A86j
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_397C
		jmp	short loc_3981
; ---------------------------------------------------------------------------

loc_397C:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+AA4j
		jmp	loc_319E
; ---------------------------------------------------------------------------

loc_3981:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+2D3j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+2ECj ...
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_3C]
		jge	short loc_3997
		xor	eax, eax
		mov	ecx, [ebp+var_48]
		mov	edx, [ebp+var_30]
		mov	[edx+ecx*2], ax
		jmp	short loc_39CA
; ---------------------------------------------------------------------------

loc_3997:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+AB3j
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_39CA
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+var_48]
		cmp	ecx, [eax]
		jnz	short loc_39C1
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 0FFFFFF84h
		jmp	short loc_39CA
; ---------------------------------------------------------------------------

loc_39C1:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+AE0j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 0Fh

loc_39CA:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+AC1j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+AD6j ...
		cmp	[ebp+var_48], 0
		jle	short loc_3A18
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_3A18
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_3C]
		jge	short loc_39FF
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		mov	edx, [ebp+var_48]
		lea	eax, [ecx+edx*2]
		mov	ecx, [ebp+arg_C]
		mov	[ecx], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		sub	ecx, [ebp+var_48]
		mov	edx, [ebp+arg_10]
		mov	[edx], ecx
		jmp	short loc_3A18
; ---------------------------------------------------------------------------

loc_39FF:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+B0Aj
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		mov	edx, [ebp+var_3C]
		lea	eax, [ecx+edx*2]
		mov	ecx, [ebp+arg_C]
		mov	[ecx], eax
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0

loc_3A18:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+AFAj
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+B02j ...
		movsx	eax, [ebp+var_15]
		test	eax, eax
		jz	short loc_3A3E
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3A3E
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 0Fh

loc_3A3E:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+B4Aj
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+B5Fj
		mov	eax, [ebp+var_48]

loc_3A41:				; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+82j
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+C2j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN100
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 21Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN100		dd 5			; DATA XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+B71o
		dd offset $LN99
$LN99		dd 0FFFFFFB8h, 4	; DATA XREF: .text:00003A80o
		dd offset $LN93		; "destIdx"
		db 88h,	0FFh
		dw 0FFFFh
		dd 4
		dd offset $LN94		; "tempStatus"
		dd 0FFFFFF7Ch, 4
		dd offset $LN95		; "possibleOverflowError"
		dd 0FFFFFF70h, 4
		dd offset $LN96		; "replIdx"
		dd 0FFFFFEBCh, 40h
		dd offset $LN97		; "groupName"
$LN97		db 'groupName',0        ; DATA XREF: .text:00003ABCo
$LN96		db 'replIdx',0          ; DATA XREF: .text:00003AB0o
$LN95		db 'possibleOverflowError',0 ; DATA XREF: .text:00003AA4o
$LN94		db 'tempStatus',0       ; DATA XREF: .text:00003A98o
$LN93		db 'destIdx',0          ; DATA XREF: .text:00003A8Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3AFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:00003BD8o
		mov	esi, esp
		lea	ecx, [ebp-144h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-220h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3B3Ch
		public ??_C@_1CA@BEAIEIMD@?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAD?$AAO?$AAL?$AAL?$AAA?$AAR?$AAS?$AAI?$AAG?$AAN?$AA?$AA@
; wchar_t `string'
??_C@_1CA@BEAIEIMD@?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAD?$AAO?$AAL?$AAL?$AAA?$AAR?$AAS?$AAI?$AAG?$AAN?$AA?$AA@:
					; DATA XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+497o
		unicode	0, <c == DOLLARSIGN>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3B5Ch
		public ??_C@_1BK@KDFMMPOE@?$AAd?$AAe?$AAs?$AAt?$AAI?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1BK@KDFMMPOE@?$AAd?$AAe?$AAs?$AAt?$AAI?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+2ABo
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+183o
		unicode	0, <destIdx >
		dw 3Eh
		unicode	0, <= 0>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 3B78h
		public ??_C@_1FG@DFDDLAOB@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@
; wchar_t `string'
??_C@_1FG@DFDDLAOB@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@:
					; DATA XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+2A6o
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+492o ...
		unicode	0, <d:\mozilla\intl\icu\source\i18n\uregex.cpp>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 3BD0h
		public ?__LINE__Var@?1??appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@3@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z@4JA@34ef717a
?__LINE__Var@?1??appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@3@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z@4JA@34ef717a dd 53Eh
					; DATA XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+29Br
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+486r
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3BD4h
__unwindtable$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003BE4o
		dd offset __unwindfunclet$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z$0
__ehfuncinfo$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl appendToBuf(wchar_t, int	*, wchar_t *, int)
?appendToBuf@@YAX_WPAHPA_WH@Z proc near	; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+1F3p
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+341p ...

var_C0		= byte ptr -0C0h
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		cmp	ecx, [ebp+arg_C]
		jge	short loc_3C38
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_8]
		mov	ax, [ebp+arg_0]
		mov	[edx+ecx*2], ax

loc_3C38:				; CODE XREF: appendToBuf(wchar_t,int *,wchar_t *,int)+26j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		add	ecx, 1
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?appendToBuf@@YAX_WPAHPA_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_appendReplacementUText_56
_uregex_appendReplacementUText_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+0BCh]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_appendReplacementUText_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3CB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uregex_appendTail_56(int,	wchar_t	**, int	*, enum	UErrorCode *)
		public _uregex_appendTail_56
_uregex_appendTail_56 proc near		; CODE XREF: _uregex_replaceAll_56+E2p
					; _uregex_replaceFirst_56+D8p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int *
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t **
		mov	eax, [ebp+var_8]
		push	eax		; struct icu_56::RegularExpression *
		call	?appendTail@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PAPA_WPAHPAW4UErrorCode@@@Z ; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression	*,wchar_t * *,int *,UErrorCode *)
		add	esp, 10h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_appendTail_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::RegexCImpl::appendTail(struct icu_56::RegularExpression *, wchar_t **, int *, enum UErrorCode *)
		public ?appendTail@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PAPA_WPAHPAW4UErrorCode@@@Z
?appendTail@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PAPA_WPAHPAW4UErrorCode@@@Z proc near
					; CODE XREF: _uregex_appendTail_56+34p

var_148		= dword	ptr -148h
var_144		= dword	ptr -144h
var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_6C		= word ptr -6Ch
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_5		= byte ptr -5
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 148h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_148]
		mov	ecx, 52h ; 'R'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_5], 0
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0Fh
		jnz	short loc_3D49
		cmp	[ebp+arg_8], 0
		jz	short loc_3D49
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax], 0
		jnz	short loc_3D49
		mov	[ebp+var_5], 1
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0

loc_3D49:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+28j
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+2Ej ...
		mov	eax, [ebp+arg_C]
		push	eax
		push	1
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_3D69
		xor	eax, eax
		jmp	loc_403F
; ---------------------------------------------------------------------------

loc_3D69:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+5Cj
		cmp	[ebp+arg_8], 0
		jz	short loc_3D8D
		cmp	[ebp+arg_4], 0
		jz	short loc_3D8D
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jnz	short loc_3D85
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax], 0
		jg	short loc_3D8D

loc_3D85:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+77j
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax], 0
		jge	short loc_3D9D

loc_3D8D:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+69j
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+6Fj ...
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_403F
; ---------------------------------------------------------------------------

loc_3D9D:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+87j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	loc_3F21
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+6Ah]
		test	ecx, ecx
		jz	short loc_3DEC
		mov	edx, [ebp+var_14]
		mov	eax, [edx+78h]
		mov	[ebp+var_148], eax
		mov	ecx, [edx+7Ch]
		mov	[ebp+var_144], ecx
		jmp	short loc_3E07
; ---------------------------------------------------------------------------

loc_3DEC:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+CFj
		mov	edx, [ebp+var_14]
		mov	eax, [edx+80h]
		mov	[ebp+var_148], eax
		mov	ecx, [edx+84h]
		mov	[ebp+var_144], ecx

loc_3E07:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+E6j
		mov	edx, [ebp+var_148]
		mov	[ebp+var_54], edx
		mov	eax, [ebp+var_144]
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_54]
		and	eax, [ebp+var_50]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_3E2D
		mov	[ebp+var_44], 0
		jmp	short loc_3E71
; ---------------------------------------------------------------------------

loc_3E2D:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+11Ej
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+10h]
		mov	edx, [ecx+34h]
		cmp	dword ptr [edx+2Ch], 0
		jnz	short loc_3E44
		mov	eax, [ebp+var_54]
		mov	[ebp+var_44], eax
		jmp	short loc_3E71
; ---------------------------------------------------------------------------

loc_3E44:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+136j
		mov	[ebp+var_60], 0
		lea	eax, [ebp+var_60]
		push	eax
		push	0
		push	0
		mov	ecx, [ebp+var_50]
		push	ecx
		mov	edx, [ebp+var_54]
		push	edx
		push	0
		push	0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+10h]
		push	ecx
		call	_utext_extract_56
		add	esp, 20h
		mov	[ebp+var_44], eax

loc_3E71:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+127j
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+13Ej ...
		cmp	[ebp+var_20], 0
		jge	short loc_3E9C
		mov	eax, ds:?__LINE__Var@?1??appendTail@RegexCImpl@icu_56@@SAHPAURegularExpression@3@PAPA_WPAHPAW4UErrorCode@@@Z@4JA@34ef717a
		add	eax, 2Ah ; '*'
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FG@DFDDLAOB@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_1BK@KDFMMPOE@?$AAd?$AAe?$AAs?$AAt?$AAI?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@	; "destIdx >= 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3E9C:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+171j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_44]
		cmp	ecx, [eax+1Ch]
		jnz	short loc_3EA9
		jmp	short loc_3F1F
; ---------------------------------------------------------------------------

loc_3EA9:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+1A1j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_44]
		mov	ax, [ecx+edx*2]
		mov	[ebp+var_6C], ax
		movzx	eax, [ebp+var_6C]
		test	eax, eax
		jnz	short loc_3ED6
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1Ch], 0FFFFFFFFh
		jnz	short loc_3ED6
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_44]
		mov	[eax+1Ch], ecx
		jmp	short loc_3F1F
; ---------------------------------------------------------------------------

loc_3ED6:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+1BCj
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+1C5j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jge	short loc_3EEE
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_38]
		mov	dx, [ebp+var_6C]
		mov	[ecx+eax*2], dx
		jmp	short loc_3F08
; ---------------------------------------------------------------------------

loc_3EEE:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+1D8j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1Ch], 0
		jle	short loc_3F08
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1Ch]
		sub	ecx, [ebp+var_44]
		add	ecx, [ebp+var_20]
		mov	[ebp+var_20], ecx
		jmp	short loc_3F1F
; ---------------------------------------------------------------------------

loc_3F08:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+1E8j
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+1F1j
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		jmp	loc_3E71
; ---------------------------------------------------------------------------

loc_3F1F:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+1A3j
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+1D0j ...
		jmp	short loc_3F9C
; ---------------------------------------------------------------------------

loc_3F21:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+C0j
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+6Ah]
		test	ecx, ecx
		jz	short loc_3F3D
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+78h]
		mov	[ebp+var_7C], ecx
		mov	edx, [eax+7Ch]
		mov	[ebp+var_78], edx
		jmp	short loc_3F6B
; ---------------------------------------------------------------------------

loc_3F3D:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+226j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+80h]
		mov	[ebp+var_7C], ecx
		mov	edx, [eax+84h]
		mov	[ebp+var_78], edx
		mov	eax, [ebp+var_7C]
		and	eax, [ebp+var_78]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_3F6B
		mov	[ebp+var_7C], 0
		mov	[ebp+var_78], 0

loc_3F6B:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+237j
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+257j
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_38]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+1Ch]
		push	ecx
		mov	edx, [eax+18h]
		push	edx
		mov	eax, [ebp+var_78]
		push	eax
		mov	ecx, [ebp+var_7C]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+10h]
		push	eax
		call	_utext_extract_56
		add	esp, 20h
		mov	[ebp+var_20], eax

loc_3F9C:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *):loc_3F1Fj
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jge	short loc_3FB2
		xor	eax, eax
		mov	ecx, [ebp+var_20]
		mov	edx, [ebp+var_38]
		mov	[edx+ecx*2], ax
		jmp	short loc_3FCE
; ---------------------------------------------------------------------------

loc_3FB2:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+29Ej
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jnz	short loc_3FC5
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0FFFFFF84h
		jmp	short loc_3FCE
; ---------------------------------------------------------------------------

loc_3FC5:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+2B4j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0Fh

loc_3FCE:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+2ACj
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+2BFj
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jge	short loc_3FF5
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	edx, [ebp+var_20]
		lea	eax, [ecx+edx*2]
		mov	ecx, [ebp+arg_4]
		mov	[ecx], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		sub	ecx, [ebp+var_20]
		mov	edx, [ebp+arg_8]
		mov	[edx], ecx
		jmp	short loc_4016
; ---------------------------------------------------------------------------

loc_3FF5:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+2D0j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jz	short loc_4016
		mov	eax, [ebp+arg_4]

loc_4000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		mov	ecx, [eax]
		mov	edx, [ebp+var_2C]
		lea	eax, [ecx+edx*2]
		mov	ecx, [ebp+arg_4]
		mov	[ecx], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0

loc_4016:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+2EFj
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+2F7j
		movsx	eax, [ebp+var_5]
		test	eax, eax
		jz	short loc_403C
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_403C
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0Fh

loc_403C:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+318j
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+32Dj
		mov	eax, [ebp+var_20]

loc_403F:				; CODE XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+60j
					; icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t * *,int *,UErrorCode *)+94j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN37
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 148h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?appendTail@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PAPA_WPAHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN37		dd 1			; DATA XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+33Fo
		dd offset $LN36
$LN36		dd 0FFFFFFA0h, 4	; DATA XREF: .text:00004068o
		dd offset $LN35		; "status"
$LN35		db 'status',0           ; DATA XREF: .text:00004074o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4080h
		public ?__LINE__Var@?1??appendTail@RegexCImpl@icu_56@@SAHPAURegularExpression@3@PAPA_WPAHPAW4UErrorCode@@@Z@4JA@34ef717a
?__LINE__Var@?1??appendTail@RegexCImpl@icu_56@@SAHPAURegularExpression@3@PAPA_WPAHPAW4UErrorCode@@@Z@4JA@34ef717a dd 650h
					; DATA XREF: icu_56::RegexCImpl::appendTail(icu_56::RegularExpression *,wchar_t	* *,int	*,UErrorCode *)+173r
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4084h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_appendTailUText_56
_uregex_appendTailUText_56 proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+14h]
		mov	edx, [eax]
		mov	eax, [edx+0C4h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_appendTailUText_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 40E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uregex_split_56(int, wchar_t *, int, int *, wchar_t **, int, enum	UErrorCode *)
		public _uregex_split_56
_uregex_split_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_18]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?validateRE@@YACPBURegularExpression@icu_56@@CPAW4UErrorCode@@@Z ; validateRE(icu_56::RegularExpression	const *,signed char,UErrorCode *)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jnz	short loc_4125
		xor	eax, eax
		jmp	short loc_4174
; ---------------------------------------------------------------------------

loc_4125:				; CODE XREF: _uregex_split_56+3Bj
		cmp	[ebp+arg_4], 0
		jnz	short loc_4131
		cmp	[ebp+arg_8], 0
		jg	short loc_4143

loc_4131:				; CODE XREF: _uregex_split_56+45j
		cmp	[ebp+arg_8], 0
		jl	short loc_4143
		cmp	[ebp+arg_10], 0
		jz	short loc_4143
		cmp	[ebp+arg_14], 1
		jge	short loc_4150

loc_4143:				; CODE XREF: _uregex_split_56+4Bj
					; _uregex_split_56+51j	...
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_4174
; ---------------------------------------------------------------------------

loc_4150:				; CODE XREF: _uregex_split_56+5Dj
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_14]
		push	ecx		; int
		mov	edx, [ebp+arg_10]
		push	edx		; wchar_t **
		mov	eax, [ebp+arg_C]
		push	eax		; int *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t *
		mov	eax, [ebp+var_8]
		push	eax		; struct icu_56::RegularExpression *
		call	?split@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PA_WHPAHQAPA_WHPAW4UErrorCode@@@Z ;	icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int	*,wchar_t * * const,int,UErrorCode *)
		add	esp, 1Ch

loc_4174:				; CODE XREF: _uregex_split_56+3Fj
					; _uregex_split_56+6Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_split_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4188h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::RegexCImpl::split(struct icu_56::RegularExpression *, wchar_t *, int, int	*, wchar_t **const , int, enum UErrorCode *)
		public ?split@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PA_WHPAHQAPA_WHPAW4UErrorCode@@@Z
?split@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PA_WHPAHQAPA_WHPAW4UErrorCode@@@Z proc near
					; CODE XREF: _uregex_split_56+88p

var_144		= dword	ptr -144h
var_7C		= dword	ptr -7Ch
var_70		= dword	ptr -70h
var_64		= dword	ptr -64h
var_58		= dword	ptr -58h
var_4C		= dword	ptr -4Ch
var_40		= dword	ptr -40h
var_34		= dword	ptr -34h
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 144h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_144]
		mov	ecx, 51h ; 'Q'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	edx, [ecx+10h]
		mov	[ebp+var_8], edx
		mov	[ebp+var_18], 0
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	edx, [ecx+18h]
		mov	[ebp+var_28], edx
		mov	eax, [ecx+1Ch]
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_28]
		or	eax, [ebp+var_24]
		jnz	short loc_41FF
		xor	eax, eax
		jmp	loc_45B3
; ---------------------------------------------------------------------------

loc_41FF:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+6Ej
		mov	[ebp+var_40], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4C], eax
		mov	[ebp+var_58], 0
		mov	[ebp+var_34], 0
		jmp	short loc_4240
; ---------------------------------------------------------------------------

loc_4237:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*):loc_455Ej
		mov	eax, [ebp+var_34]
		add	eax, 1
		mov	[ebp+var_34], eax

loc_4240:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+ADj
		mov	eax, [ebp+arg_14]
		sub	eax, 1
		cmp	[ebp+var_34], eax
		jl	loc_4304
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+var_14]
		jl	loc_42FF
		jg	short loc_4269
		mov	ecx, [ebp+var_28]
		cmp	ecx, [ebp+var_18]
		jbe	loc_42FF

loc_4269:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+D3j
		mov	eax, [ebp+arg_14]
		sub	eax, 1
		cmp	[ebp+var_34], eax
		jz	short loc_4290
		mov	eax, [ebp+arg_14]
		sub	eax, 1
		mov	[ebp+var_34], eax
		mov	eax, [ebp+var_34]
		mov	ecx, [ebp+arg_10]
		mov	edx, [ebp+arg_10]
		mov	eax, [ecx+eax*4]
		sub	eax, [edx]
		sar	eax, 1
		mov	[ebp+var_40], eax

loc_4290:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+EAj
		mov	eax, [ebp+var_40]
		mov	ecx, [ebp+arg_4]
		lea	edx, [ecx+eax*2]
		mov	eax, [ebp+var_34]
		mov	ecx, [ebp+arg_10]
		mov	[ecx+eax*4], edx
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+var_40]
		test	eax, eax
		jle	short loc_42BA
		mov	ecx, [ebp+arg_8]
		sub	ecx, [ebp+var_40]
		mov	[ebp+var_144], ecx
		jmp	short loc_42C4
; ---------------------------------------------------------------------------

loc_42BA:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+122j
		mov	[ebp+var_144], 0

loc_42C4:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+130j
		mov	edx, [ebp+arg_18]
		push	edx
		mov	eax, [ebp+var_144]
		push	eax
		mov	ecx, [ebp+var_40]
		mov	edx, [ebp+arg_4]
		lea	eax, [edx+ecx*2]
		push	eax
		mov	ecx, [ebp+var_24]
		push	ecx
		mov	edx, [ebp+var_28]
		push	edx
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_18]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	_utext_extract_56
		add	esp, 20h
		mov	ecx, [ebp+var_40]
		lea	edx, [ecx+eax+1]
		mov	[ebp+var_40], edx

loc_42FF:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+CDj
					; icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t	*,int,int *,wchar_t * *	const,int,UErrorCode *)+DBj
		jmp	loc_4563
; ---------------------------------------------------------------------------

loc_4304:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+C1j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_44ED
		mov	eax, [ebp+var_40]
		mov	ecx, [ebp+arg_4]
		lea	edx, [ecx+eax*2]
		mov	eax, [ebp+var_34]
		mov	ecx, [ebp+arg_10]
		mov	[ecx+eax*4], edx
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+var_40]
		test	eax, eax
		jle	short loc_4357
		mov	ecx, [ebp+arg_8]
		sub	ecx, [ebp+var_40]
		mov	[ebp+var_144], ecx
		jmp	short loc_4361
; ---------------------------------------------------------------------------

loc_4357:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+1BFj
		mov	[ebp+var_144], 0

loc_4361:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+1CDj
		lea	edx, [ebp+var_58]
		push	edx
		mov	eax, [ebp+var_144]
		push	eax
		mov	ecx, [ebp+var_40]
		mov	edx, [ebp+arg_4]
		lea	eax, [edx+ecx*2]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	eax, [edx+74h]
		push	eax
		mov	ecx, [edx+70h]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+var_18]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	_utext_extract_56
		add	esp, 20h
		mov	edx, [ebp+var_40]
		lea	eax, [edx+eax+1]
		mov	[ebp+var_40], eax
		cmp	[ebp+var_58], 0Fh
		jnz	short loc_43B1
		mov	[ebp+var_58], 0
		jmp	short loc_43B9
; ---------------------------------------------------------------------------

loc_43B1:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+21Ej
		mov	eax, [ebp+arg_18]
		mov	ecx, [ebp+var_58]
		mov	[eax], ecx

loc_43B9:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+227j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	edx, [ecx+78h]
		mov	[ebp+var_18], edx
		mov	eax, [ecx+7Ch]
		mov	[ebp+var_14], eax
		mov	[ebp+var_64], 1
		jmp	short loc_43DD
; ---------------------------------------------------------------------------

loc_43D4:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*):loc_4489j
		mov	eax, [ebp+var_64]
		add	eax, 1
		mov	[ebp+var_64], eax

loc_43DD:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+24Aj
		mov	eax, [ebp+var_64]
		cmp	eax, [ebp+var_4C]
		jg	loc_448E
		mov	eax, [ebp+arg_14]
		sub	eax, 1
		cmp	[ebp+var_34], eax
		jnz	short loc_43F9
		jmp	loc_448E
; ---------------------------------------------------------------------------

loc_43F9:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+26Aj
		mov	eax, [ebp+var_34]
		add	eax, 1
		mov	[ebp+var_34], eax
		mov	eax, [ebp+var_40]
		mov	ecx, [ebp+arg_4]
		lea	edx, [ecx+eax*2]
		mov	eax, [ebp+var_34]
		mov	ecx, [ebp+arg_10]
		mov	[ecx+eax*4], edx
		mov	[ebp+var_58], 0
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+var_40]
		test	eax, eax
		jle	short loc_4433
		mov	ecx, [ebp+arg_8]
		sub	ecx, [ebp+var_40]
		mov	[ebp+var_144], ecx
		jmp	short loc_443D
; ---------------------------------------------------------------------------

loc_4433:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+29Bj
		mov	[ebp+var_144], 0

loc_443D:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+2A9j
		lea	edx, [ebp+var_58]
		push	edx
		mov	eax, [ebp+var_144]
		push	eax
		mov	ecx, [ebp+var_34]
		mov	edx, [ebp+arg_10]
		mov	eax, [edx+ecx*4]
		push	eax
		mov	ecx, [ebp+var_64]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_uregex_group_56
		add	esp, 14h
		mov	[ebp+var_70], eax
		mov	eax, [ebp+var_70]
		mov	ecx, [ebp+var_40]
		lea	edx, [ecx+eax+1]
		mov	[ebp+var_40], edx
		cmp	[ebp+var_58], 0Fh
		jnz	short loc_4481
		mov	[ebp+var_58], 0
		jmp	short loc_4489
; ---------------------------------------------------------------------------

loc_4481:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+2EEj
		mov	eax, [ebp+arg_18]
		mov	ecx, [ebp+var_58]
		mov	[eax], ecx

loc_4489:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+2F7j
		jmp	loc_43D4
; ---------------------------------------------------------------------------

loc_448E:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+25Bj
					; icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t	*,int,int *,wchar_t * *	const,int,UErrorCode *)+26Cj
		mov	eax, [ebp+var_18]
		cmp	eax, [ebp+var_28]
		jnz	short loc_44EB
		mov	ecx, [ebp+var_14]
		cmp	ecx, [ebp+var_24]
		jnz	short loc_44EB
		mov	eax, [ebp+var_40]
		cmp	eax, [ebp+arg_8]
		jge	short loc_44B2
		xor	eax, eax
		mov	ecx, [ebp+var_40]
		mov	edx, [ebp+arg_4]
		mov	[edx+ecx*2], ax

loc_44B2:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+31Cj
		mov	eax, [ebp+arg_14]
		sub	eax, 1
		cmp	[ebp+var_34], eax
		jge	short loc_44C6
		mov	eax, [ebp+var_34]
		add	eax, 1
		mov	[ebp+var_34], eax

loc_44C6:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+333j
		mov	eax, [ebp+var_40]
		cmp	eax, [ebp+arg_8]
		jge	short loc_44E0
		mov	eax, [ebp+var_40]
		mov	ecx, [ebp+arg_4]
		lea	edx, [ecx+eax*2]
		mov	eax, [ebp+var_34]
		mov	ecx, [ebp+arg_10]
		mov	[ecx+eax*4], edx

loc_44E0:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+344j
		mov	eax, [ebp+var_40]
		add	eax, 1
		mov	[ebp+var_40], eax
		jmp	short loc_4563
; ---------------------------------------------------------------------------

loc_44EB:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+30Cj
					; icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t	*,int,int *,wchar_t * *	const,int,UErrorCode *)+314j
		jmp	short loc_455E
; ---------------------------------------------------------------------------

loc_44ED:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+19Fj
		mov	eax, [ebp+var_40]
		mov	ecx, [ebp+arg_4]
		lea	edx, [ecx+eax*2]
		mov	eax, [ebp+var_34]
		mov	ecx, [ebp+arg_10]
		mov	[ecx+eax*4], edx
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+var_40]
		test	eax, eax
		jle	short loc_4517
		mov	ecx, [ebp+arg_8]
		sub	ecx, [ebp+var_40]
		mov	[ebp+var_144], ecx
		jmp	short loc_4521
; ---------------------------------------------------------------------------

loc_4517:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+37Fj
		mov	[ebp+var_144], 0

loc_4521:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+38Dj
		mov	edx, [ebp+arg_18]
		push	edx
		mov	eax, [ebp+var_144]
		push	eax
		mov	ecx, [ebp+var_40]
		mov	edx, [ebp+arg_4]
		lea	eax, [edx+ecx*2]
		push	eax
		mov	ecx, [ebp+var_24]
		push	ecx
		mov	edx, [ebp+var_28]
		push	edx
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_18]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	_utext_extract_56
		add	esp, 20h
		mov	ecx, [ebp+var_40]
		lea	edx, [ecx+eax+1]
		mov	[ebp+var_40], edx
		jmp	short loc_4563
; ---------------------------------------------------------------------------

loc_455E:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*):loc_44EBj
		jmp	loc_4237
; ---------------------------------------------------------------------------

loc_4563:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*):loc_42FFj
					; icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t	*,int,int *,wchar_t * *	const,int,UErrorCode *)+361j ...
		mov	eax, [ebp+var_34]
		add	eax, 1
		mov	[ebp+var_7C], eax
		jmp	short loc_4577
; ---------------------------------------------------------------------------

loc_456E:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+404j
		mov	eax, [ebp+var_7C]
		add	eax, 1
		mov	[ebp+var_7C], eax

loc_4577:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+3E4j
		mov	eax, [ebp+var_7C]
		cmp	eax, [ebp+arg_14]
		jge	short loc_458E
		mov	eax, [ebp+var_7C]
		mov	ecx, [ebp+arg_10]
		mov	dword ptr [ecx+eax*4], 0
		jmp	short loc_456E
; ---------------------------------------------------------------------------

loc_458E:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+3F5j
		cmp	[ebp+arg_C], 0
		jz	short loc_459C
		mov	eax, [ebp+arg_C]
		mov	ecx, [ebp+var_40]
		mov	[eax], ecx

loc_459C:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+40Aj
		mov	eax, [ebp+var_40]
		cmp	eax, [ebp+arg_8]
		jle	short loc_45AD
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 0Fh

loc_45AD:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+41Aj
		mov	eax, [ebp+var_34]
		add	eax, 1

loc_45B3:				; CODE XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+72j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN40
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?split@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PA_WHPAHQAPA_WHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN40		dd 1			; DATA XREF: icu_56::RegexCImpl::split(icu_56::RegularExpression *,wchar_t *,int,int *,wchar_t * * const,int,UErrorCode	*)+42Fo
		dd offset $LN39
$LN39		dd 0FFFFFFA8h, 4	; DATA XREF: .text:000045DCo
		dd offset $LN38		; "tStatus"
$LN38		db 'tStatus',0          ; DATA XREF: .text:000045E8o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uregex_splitUText_56
_uregex_splitUText_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		mov	edx, [ecx]
		mov	edi, esp
		mov	ecx, eax
		mov	eax, [edx+70h]
		call	eax
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+0CCh]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uregex_splitUText_56 endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; public: signed char __thiscall icu_56::RegexPattern::operator==(class	icu_56::RegexPattern const &)const
		extrn ??8RegexPattern@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::RegexPattern::operator!=(icu_56::RegexPattern const &)+2Ap
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::RegexPattern::operator!=(icu_56::RegexPattern const &)+42p
					; icu_56::RegularExpression::~RegularExpression(void)+5Cp ...
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::RegularExpression::~RegularExpression(void)+F4p
					; icu_56::RegularExpression::~RegularExpression(void)+103p ...
; LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend)
		extrn __imp__InterlockedDecrement@4:near
					; CODE XREF: icu_56::umtx_atomic_dec(long volatile *)+24p
					; DATA XREF: icu_56::umtx_atomic_dec(long volatile *)+24r
		extrn _utext_close_56:near ; CODE XREF:	_uregex_open_56+2F3p
					; _uregex_openUText_56+33Cp ...
; struct icu_56::RegexPattern *__cdecl static icu_56::RegexPattern::compile(struct UText *, unsigned int, enum UErrorCode *)
		extrn ?compile@RegexPattern@icu_56@@SAPAV12@PAUUText@@IAAW4UErrorCode@@@Z:near
					; CODE XREF: _uregex_open_56+2DEp
					; _uregex_openUText_56+327p
; struct icu_56::RegexPattern *__cdecl static icu_56::RegexPattern::compile(struct UText *, unsigned int, struct UParseError *,	enum UErrorCode	*)
		extrn ?compile@RegexPattern@icu_56@@SAPAV12@PAUUText@@IAAUUParseError@@AAW4UErrorCode@@@Z:near
					; CODE XREF: _uregex_open_56+2BFp
					; _uregex_openUText_56+308p
		extrn _utext_openUChars_56:near	; CODE XREF: _uregex_open_56+29Ep
					; _uregex_openUText_56+2E7p ...
		extrn _u_memcpy_56:near	; CODE XREF: _uregex_open_56+196p
					; _uregex_group_56+145p
		extrn _uprv_malloc_56:near ; CODE XREF:	_uregex_open_56+CEp
					; _uregex_open_56+E1p ...
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn __imp_??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: _uregex_open_56+7Bp
					; _uregex_openUText_56+7Ep ...
		extrn _u_strlen_56:near	; CODE XREF: _uregex_open_56+6Cp
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+10Cp
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near ; CODE XREF: _uregex_open_56+39Bp
					; _uregex_openUText_56+3E4p ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::RegularExpression::`scalar	deleting destructor'(uint)+39p
					; DATA XREF: icu_56::RegularExpression::`scalar	deleting destructor'(uint)+39r
		extrn _utext_extract_56:near ; CODE XREF: _uregex_openUText_56+EEp
					; _uregex_openUText_56+1D6p ...
		extrn _utext_nativeLength_56:near ; CODE XREF: _uregex_openUText_56+54p
					; _uregex_getText_56+76p
; LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend)
		extrn __imp__InterlockedIncrement@4:near
					; CODE XREF: icu_56::umtx_atomic_inc(long volatile *)+24p
					; DATA XREF: icu_56::umtx_atomic_inc(long volatile *)+24r
; void __thiscall icu_56::RegexMatcher::resetPreserveRegion(icu_56::RegexMatcher *__hidden this)
		extrn ?resetPreserveRegion@RegexMatcher@icu_56@@QAEXXZ:near
					; CODE XREF: _uregex_find64_56+57p
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: _uregex_groupNumberFromName_56+96p
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+9E5p ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const wchar_t *,	int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@PB_WH@Z:near
					; CODE XREF: _uregex_groupNumberFromName_56+61p
					; DATA XREF: _uregex_groupNumberFromName_56+61r
		extrn ___security_cookie:near
					; DATA XREF: _uregex_groupNumberFromName_56+1Er
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+2Cr
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: _uregex_groupNumberFromName_56+AEp
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+B91p ...
		extrn _uhash_geti_56:near
					; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+9A6p
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+97Ap
					; DATA XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+97Ar
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		extrn __imp_??0UnicodeString@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+7D2p
					; DATA XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+7D2r
		extrn _u_charDigitValue_56:near
					; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+6D2p
; int __thiscall icu_56::UVector32::size(icu_56::UVector32 *__hidden this)
		extrn __imp_?size@UVector32@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+5B4p
					; DATA XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+5B4r
		extrn _u_isdigit_56:near
					; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+58Cp
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+6B7p
		extrn _u_unescapeAt_56:near
					; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+3B2p
		extrn _uregex_ucstr_unescape_charAt_56:near
					; DATA XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+3ADo
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near
					; CODE XREF: icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t * *,int *,UErrorCode	*)+2B0p
					; icu_56::RegexCImpl::appendReplacement(icu_56::RegularExpression *,wchar_t const *,int,wchar_t	* *,int	*,UErrorCode *)+49Cp ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$?appendReplacement@RegexCImpl@icu_56@@SAHPAURegularExpression@2@PB_WHPAPA_WPAHPAW4UErrorCode@@@Z+23j


		end
