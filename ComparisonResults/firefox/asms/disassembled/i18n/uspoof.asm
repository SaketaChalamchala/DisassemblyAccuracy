;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	8A8DAA970ACC1A7E0BD5213C6EB8FDD3
; Input	CRC32 :	BBBC8863

; File Name   :	D:\compspace\objfiles\firefox\i18n\uspoof.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		public ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@
; `string'
??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@ db '[\u0030-\u0039\u0041-\u005A\u005F\u0061-\u007A\u00C0-\u00D6\u00D8'
					; DATA XREF: .data:char	const *	const `initializeStatics(UErrorCode &)'::`2'::recommendedPato
		db '-\u00F6\u00F8-\u0131\u0134-\u013E\u0141-\u0148\u014A-\u017E\u018F'
		db '\u01A0-\u01A1\u01AF-\u01B0\u01CD-\u01DC\u01DE-\u01E3\u01E6-\u01F0'
		db '\u01F4-\u01F5\u01F8-\u021B\u021E-\u021F\u0226-\u0233\u0259\u02BB-'
		db '\u02BC\u02EC\u0300-\u0304\u0306-\u030C\u030F-\u0311\u0313-\u0314\'
		db 'u031B\u0323-\u0328\u032D-\u032E\u0330-\u0331\u0335\u0338-\u0339\u'
		db '0342\u0345\u037B-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03'
		db 'A3-\u03CE\u03FC-\u045F\u048A-\u0529\u052E-\u052F\u0531-\u0556\u05'
		db '59\u0561-\u0586\u05B4\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u064'
		db '1-\u0655\u0660-\u0669\u0670-\u0672\u0674\u0679-\u068D\u068F-\u06D'
		db '3\u06D5\u06E5-\u06E6\u06EE-\u06FC\u06FF\u0750-\u07B1\u08A0-\u08AC'
		db '\u08B2\u0901-\u094D\u094F-\u0950\u0956-\u0957\u0960-\u0963\u0966-'
		db '\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F-'
		db '\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\'
		db 'u09C7-\u09C8\u09CB-\u09CE\u09D7\u09E0-\u09E3\u09E6-\u09F1\u0A01-\'
		db 'u0A03\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u'
		db '0A35\u0A38-\u0A39\u0A3C\u0A3E-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0'
		db 'A5C\u0A66-\u0A74\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0'
		db 'AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0'
		db 'AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B'
		db '05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B'
		db '35-\u0B39\u0B3C-\u0B43\u0B47-\u0B48\u0B4B-\u0B4D\u0B56-\u0B57\u0B'
		db '5F-\u0B61\u0B66-\u0B6F\u0B71\u0B82-\u0B83\u0B85-\u0B8A\u0B8E-\u0B'
		db '90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA'
		db '8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD'
		db '0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12'
		db '-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A'
		db '-\u0C4D\u0C55-\u0C56\u0C60-\u0C61\u0C66-\u0C6F\u0C82-\u0C83\u0C85'
		db '-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC'
		db '-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5-\u0CD6\u0CE0-\u0CE3\u0CE6'
		db '-\u0CEF\u0CF1-\u0CF2\u0D02-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12'
		db '-\u0D3A\u0D3D-\u0D43\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D61'
		db '\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82-\u0D83\u0D85-\u0D8E\u0D91-\u0D96'
		db '\u0D9A-\u0DA5\u0DA7-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\'
		db 'u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDE\u0DF2\u0E01-\u0E32\u0E34-\u0E3A\u'
		db '0E40-\u0E4E\u0E50-\u0E59\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0'
		db 'E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0E'
		db 'AB\u0EAD-\u0EB2\u0EB4-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC'
		db '8-\u0ECD\u0ED0-\u0ED9\u0EDE-\u0EDF\u0F00\u0F20-\u0F29\u0F35\u0F37'
		db '\u0F3E-\u0F42\u0F44-\u0F47\u0F49-\u0F4C\u0F4E-\u0F51\u0F53-\u0F56'
		db '\u0F58-\u0F5B\u0F5D-\u0F68\u0F6A-\u0F6C\u0F71-\u0F72\u0F74\u0F7A-'
		db '\u0F80\u0F82-\u0F84\u0F86-\u0F92\u0F94-\u0F97\u0F99-\u0F9C\u0F9E-'
		db '\u0FA1\u0FA3-\u0FA6\u0FA8-\u0FAB\u0FAD-\u0FB8\u0FBA-\u0FBC\u0FC6\'
		db 'u1000-\u1049\u1050-\u109D\u10C7\u10CD\u10D0-\u10F0\u10F7-\u10FA\u'
		db '10FD-\u10FF\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u'
		db '125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u'
		db '12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1'
		db '318-\u135A\u135D-\u135F\u1380-\u138F\u1780-\u17A2\u17A5-\u17A7\u1'
		db '7A9-\u17B3\u17B6-\u17CA\u17D2\u17D7\u17DC\u17E0-\u17E9\u1E00-\u1E'
		db '99\u1E9E\u1EA0-\u1EF9\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F4'
		db '8-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F70\u1F72\u1F74\'
		db 'u1F76\u1F78\u1F7A\u1F7C\u1F80-\u1FB4\u1FB6-\u1FBA\u1FBC\u1FC2-\u1'
		db 'FC4\u1FC6-\u1FC8\u1FCA\u1FCC\u1FD0-\u1FD2\u1FD6-\u1FDA\u1FE0-\u1F'
		db 'E2\u1FE4-\u1FEA\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FF8\u1FFA\u1FFC\u2D27'
		db '\u2D2D\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-'
		db '\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-'
		db '\u3007\u3041-\u3096\u3099-\u309A\u309D-\u309E\u30A1-\u30FA\u30FC-'
		db '\u30FE\u3105-\u312D\u31A0-\u31BA\u3400-\u4DB5\u4E00-\u9FD5\uA660-'
		db '\uA661\uA674-\uA67B\uA67F\uA69F\uA717-\uA71F\uA788\uA78D-\uA78E\u'
		db 'A790-\uA793\uA7A0-\uA7AA\uA7FA\uA9E7-\uA9FE\uAA60-\uAA76\uAA7A-\u'
		db 'AA7F\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\u'
		db 'AB2E\uAC00-\uD7A3\uFA0E-\uFA0F\uFA11\uFA13-\uFA14\uFA1F\uFA21\uFA'
		db '23-\uFA24\uFA27-\uFA29\U00020000-\U0002A6D6\U0002A700-\U0002B734\'
		db 'U0002B740-\U0002B81D\U0002B820-\U0002CEA1]',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 102Ch
		public ??_C@_0HJ@OADLBNPH@?$FL?2u0027?2u002D?9?2u002E?2u003A?2u00B7@
; `string'
??_C@_0HJ@OADLBNPH@?$FL?2u0027?2u002D?9?2u002E?2u003A?2u00B7@ db '[\u0027\u002D-\u002E\u003A\u00B7\u0375\u058A\u05F3-\u05F4\u06FD-\'
					; DATA XREF: .data:char	const *	const `initializeStatics(UErrorCode &)'::`2'::inclusionPato
		db 'u06FE\u0F0B\u200C-\u200D\u2010\u2019\u2027\u30A0\u30FB]',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 10A8h
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 10ACh
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10B0h
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10B4h
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10B8h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10BCh
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10C0h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10C4h
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10C8h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10CCh
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10D0h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10D4h
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10D8h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10DCh
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10E0h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10E4h
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10E8h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10ECh
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10F0h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10F4h
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10F8h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10FCh
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1100h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1104h
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+20h ; "F\\u0061-\\u007A\\u00C0-\\u00D6\\u00D8-"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1108h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+3Fh ; "D8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 110Ch
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1110h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1114h
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1118h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 111Ch
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1120h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1124h
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+20h ; "F\\u0061-\\u007A\\u00C0-\\u00D6\\u00D8-"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1128h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+40h ;	"8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013E"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 112Ch
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+80h ; "8F\\u01A0-\\u01A1\\u01AF-\\u01B0\\u01CD"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1130h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+100h ; "2BB-\\u02BC\\u02EC\\u0300-\\u0304\\u030"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1134h
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+200h ;	"0556\\u0559\\u0561-\\u0586\\u05B4\\u05D"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1138h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+400h ;	"A-\\u0A30\\u0A32\\u0A35\\u0A38-\\u0A39\"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 113Ch
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+800h ;	"\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D61\\"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1140h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+1000h ;	"0002B740-\\U0002B81D\\U0002B820-\\U0002"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1144h
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1148h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 114Ch
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_1FG@NOAAMNGO@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@+54h ;	""
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1150h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1154h
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+1C0h ;	"3A1\\u03A3-\\u03CE\\u03FC-\\u045F\\u048"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1158h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+0E00h ; "DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2D"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 115Ch
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1160h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1164h
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1168h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 116Ch
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1170h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1174h
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1178h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 117Ch
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1180h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1184h
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1188h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+40h ; "8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013E"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 118Ch
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+80h ; "8F\\u01A0-\\u01A1\\u01AF-\\u01B0\\u01CD"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1190h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+20h	; "F\\u0061-\\u007A\\u00C0-\\u00D6\\u00D8-"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1194h
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1198h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 119Ch
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 11A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; icu_56::UnicodeSet *gInclusionSet
_gInclusionSet	dd ?			; DATA XREF: initializeStatics(UErrorCode &)+127w
					; initializeStatics(UErrorCode &)+15Cr	...
; icu_56::UnicodeSet *gRecommendedSet
_gRecommendedSet dd ?			; DATA XREF: initializeStatics(UErrorCode &)+24Cw
					; initializeStatics(UErrorCode &)+281r	...
_gNfdNormalizer	dd ?			; DATA XREF: initializeStatics(UErrorCode &)+2AAw
					; uspoof_cleanup(void)+D0w ...
; icu_56::SpoofData *gDefaultSpoofData
_gDefaultSpoofData dd ?			; DATA XREF: uspoof_cleanup(void)+DAr
					; uspoof_cleanup(void)+E3r ...
; icu_56::UInitOnce gSpoofInitStaticsOnce
_gSpoofInitStaticsOnce dd 2 dup(?)	; DATA XREF: _uspoof_internalInitStatics_56+27o
					; uspoof_cleanup(void)+F8o ...
; icu_56::UInitOnce gSpoofInitDefaultOnce
_gSpoofInitDefaultOnce dd 2 dup(?)	; DATA XREF: uspoof_cleanup(void)+102o
					; _uspoof_open_56+3Do
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 11C0h
; char const * const `void __cdecl initializeStatics(enum  UErrorCode &)'::`2'::inclusionPat
?inclusionPat@?1??initializeStatics@@YAXAAW4UErrorCode@@@Z@4PBDB dd offset ??_C@_0HJ@OADLBNPH@?$FL?2u0027?2u002D?9?2u002E?2u003A?2u00B7@
					; DATA XREF: initializeStatics(UErrorCode &)+84r
					; "[\\u0027\\u002D-\\u002E\\u003A\\u00B7\\"...
; char const * const `void __cdecl initializeStatics(enum  UErrorCode &)'::`2'::recommendedPat
?recommendedPat@?1??initializeStatics@@YAXAAW4UErrorCode@@@Z@4PBDB dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@
					; DATA XREF: initializeStatics(UErrorCode &)+1A9r
_data		ends			; "[\\u0030-\\u0039\\u0041-\\u005A\\u005F\"...

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 1200h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 1204h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1208h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 123Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::IdentifierInfo & __thiscall icu_56::IdentifierInfo::operator=(class icu_56::IdentifierInfo const &)
		public ??4IdentifierInfo@icu_56@@QAEAAV01@ABV01@@Z
??4IdentifierInfo@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4IdentifierInfo@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uspoof_internalInitStatics_56
_uspoof_internalInitStatics_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi		; enum UErrorCode *
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax		; void (__cdecl	*)(enum	UErrorCode *)
		push	offset ?initializeStatics@@YAXAAW4UErrorCode@@@Z ; struct icu_56::UInitOnce *
		push	offset _gSpoofInitStaticsOnce ;	this
		call	?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z ; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_internalInitStatics_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::umtx_initOnce(icu_56 *__hidden this, struct icu_56::UInitOnce *,	void (__cdecl *)(enum UErrorCode *), enum UErrorCode *)
		public ?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z
?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z proc	near
					; CODE XREF: _uspoof_internalInitStatics_56+2Cp
					; _uspoof_open_56+2Cp ...

var_C0		= byte ptr -0C0h
Destination	= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi		; struct icu_56::UInitOnce *
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1334
		jmp	loc_13B9
; ---------------------------------------------------------------------------

loc_1334:				; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+31j
		mov	eax, [ebp+Destination]
		push	eax		; Destination
		call	?umtx_loadAcquire@icu_56@@YAHACJ@Z ; icu_56::umtx_loadAcquire(long volatile &)
		add	esp, 4
		cmp	eax, 2
		jz	short loc_1398
		mov	esi, esp
		mov	eax, [ebp+Destination]
		push	eax		; this
		call	dword ptr ds:__imp_?umtx_initImplPreInit@icu_56@@YACAAUUInitOnce@1@@Z ;	icu_56::umtx_initImplPreInit(icu_56::UInitOnce &)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_1398
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		call	[ebp+arg_4]
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+Destination]
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx]
		mov	[eax+4], edx
		mov	esi, esp
		mov	eax, [ebp+Destination]
		push	eax		; this
		call	dword ptr ds:__imp_?umtx_initImplPostInit@icu_56@@YAXAAUUInitOnce@1@@Z ; icu_56::umtx_initImplPostInit(icu_56::UInitOnce &)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_13B9
; ---------------------------------------------------------------------------

loc_1398:				; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+47j
					; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode	&),UErrorCode &)+64j
		mov	eax, [ebp+Destination]
		mov	ecx, [eax+4]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_13B9
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+Destination]
		mov	edx, [ecx+4]
		mov	[eax], edx

loc_13B9:				; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+33j
					; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode	&),UErrorCode &)+9Aj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+24p
					; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode	&),UErrorCode &)+A3p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::umtx_loadAcquire(volatile	LONG *Destination, volatile __int32 *)
		public ?umtx_loadAcquire@icu_56@@YAHACJ@Z
?umtx_loadAcquire@icu_56@@YAHACJ@Z proc	near
					; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+3Cp

var_C0		= byte ptr -0C0h
Destination	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		push	0		; Comperand
		push	0		; Exchange
		mov	eax, [ebp+Destination]
		push	eax		; Destination
		call	dword ptr ds:__imp__InterlockedCompareExchange@12 ; InterlockedCompareExchange(x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?umtx_loadAcquire@icu_56@@YAHACJ@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1448h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UInitOnce initializeStatics
?initializeStatics@@YAXAAW4UErrorCode@@@Z proc near
					; DATA XREF: _uspoof_internalInitStatics_56+22o
					; _uspoof_open_56+22o ...

var_1A8		= dword	ptr -1A8h
var_1A4		= dword	ptr -1A4h
var_1A0		= dword	ptr -1A0h
var_198		= byte ptr -198h
var_150		= byte ptr -150h
var_108		= dword	ptr -108h
var_FC		= dword	ptr -0FCh
var_F0		= dword	ptr -0F0h
var_E4		= dword	ptr -0E4h
var_D8		= dword	ptr -0D8h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?initializeStatics@@YAXAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 19Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1A8]
		mov	ecx, 67h ; 'g'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax		; enum UErrorCode *
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_D8], 0
		mov	esi, esp
		push	34h ; '4'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_FC], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_FC], 0
		jz	loc_154C
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	edi, esp
		push	0
		push	0FFFFFFFFh
		mov	ecx, ds:?inclusionPat@?1??initializeStatics@@YAXAAW4UErrorCode@@@Z@4PBDB ; char	const *	const `initializeStatics(UErrorCode &)'::`2'::inclusionPat
		push	ecx
		lea	ecx, [ebp+var_198]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1A0], eax
		mov	edx, [ebp+var_1A0]
		mov	[ebp+var_1A4], edx
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_D8]
		or	eax, 1
		mov	[ebp+var_D8], eax
		mov	ecx, [ebp+var_1A4]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_FC] ; this
		call	dword ptr ds:__imp_??0UnicodeSet@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z ; icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeString const	&,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_FC]
		mov	dword ptr [edx], offset	??_SUnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_FC]
		mov	dword ptr [eax+4], offset ??_SUnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeMatcher'}
		mov	ecx, [ebp+var_FC]
		mov	[ebp+var_1A8], ecx
		jmp	short loc_1556
; ---------------------------------------------------------------------------

loc_154C:				; CODE XREF: initializeStatics(UErrorCode &)+72j
		mov	[ebp+var_1A8], 0

loc_1556:				; CODE XREF: initializeStatics(UErrorCode &)+102j
		mov	edx, [ebp+var_1A8]
		mov	[ebp+var_108], edx
		mov	[ebp+var_4], 2
		mov	eax, [ebp+var_108]
		mov	ds:_gInclusionSet, eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_D8]
		and	ecx, 1
		jz	short loc_15A2
		and	[ebp+var_D8], 0FFFFFFFEh
		mov	esi, esp
		lea	ecx, [ebp+var_198] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_15A2:				; CODE XREF: initializeStatics(UErrorCode &)+13Cj
		mov	esi, esp
		mov	ecx, ds:_gInclusionSet ; this
		call	dword ptr ds:__imp_?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ	; icu_56::UnicodeSet::freeze(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	34h ; '4'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E4], eax
		mov	[ebp+var_4], 3
		cmp	[ebp+var_E4], 0
		jz	loc_1671
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	edi, esp
		push	0
		push	0FFFFFFFFh
		mov	ecx, ds:?recommendedPat@?1??initializeStatics@@YAXAAW4UErrorCode@@@Z@4PBDB ; char const	* const	`initializeStatics(UErrorCode &)'::`2'::recommendedPat
		push	ecx
		lea	ecx, [ebp+var_150]
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z ; icu_56::UnicodeString::UnicodeString(char const *,int,icu_56::UnicodeString::EInvariant)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1A0], eax
		mov	edx, [ebp+var_1A0]
		mov	[ebp+var_1A4], edx
		mov	byte ptr [ebp+var_4], 4
		mov	eax, [ebp+var_D8]
		or	eax, 2
		mov	[ebp+var_D8], eax
		mov	ecx, [ebp+var_1A4]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_??0UnicodeSet@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z ; icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeString const	&,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_E4]
		mov	dword ptr [edx], offset	??_SUnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_E4]
		mov	dword ptr [eax+4], offset ??_SUnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeMatcher'}
		mov	ecx, [ebp+var_E4]
		mov	[ebp+var_1A8], ecx
		jmp	short loc_167B
; ---------------------------------------------------------------------------

loc_1671:				; CODE XREF: initializeStatics(UErrorCode &)+197j
		mov	[ebp+var_1A8], 0

loc_167B:				; CODE XREF: initializeStatics(UErrorCode &)+227j
		mov	edx, [ebp+var_1A8]
		mov	[ebp+var_F0], edx
		mov	[ebp+var_4], 5
		mov	eax, [ebp+var_F0]
		mov	ds:_gRecommendedSet, eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_D8]
		and	ecx, 2
		jz	short loc_16C7
		and	[ebp+var_D8], 0FFFFFFFDh
		mov	esi, esp
		lea	ecx, [ebp+var_150] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_16C7:				; CODE XREF: initializeStatics(UErrorCode &)+261j
		mov	esi, esp
		mov	ecx, ds:_gRecommendedSet ; this
		call	dword ptr ds:__imp_?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ	; icu_56::UnicodeSet::freeze(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		call	dword ptr ds:__imp_?getNFDInstance@Normalizer2@icu_56@@SAPBV12@AAW4UErrorCode@@@Z ; icu_56::Normalizer2::getNFDInstance(UErrorCode &)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ds:_gNfdNormalizer, eax
		push	offset ?uspoof_cleanup@@YACXZ ;	uspoof_cleanup(void)
		push	1
		call	_ucln_i18n_registerCleanup_56
		add	esp, 8
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1A8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initializeStatics@@YAXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1730h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00001898o
		mov	esi, esp
		mov	eax, [ebp-0FCh]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:000018A0o
					; .xdata$x:000018A8o
		mov	eax, [ebp-0D8h]
		and	eax, 1
		jz	$LN9
		and	dword ptr [ebp-0D8h], 0FFFFFFFEh
		mov	esi, esp
		lea	ecx, [ebp-198h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN9:					; CODE XREF: __unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$1+9j
		retn
__unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:000018B0o
		mov	esi, esp
		mov	eax, [ebp-0E4h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:000018B8o
					; .xdata$x:000018C0o
		mov	eax, [ebp-0D8h]
		and	eax, 2
		jz	$LN13
		and	dword ptr [ebp-0D8h], 0FFFFFFFDh
		mov	esi, esp
		lea	ecx, [ebp-150h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN13:					; CODE XREF: __unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$3+9j
		retn
__unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?initializeStatics@@YAXAAW4UErrorCode@@@Z proc near
					; DATA XREF: initializeStatics(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1ACh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?initializeStatics@@YAXAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?initializeStatics@@YAXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 17E4h
		dd offset ??_R4UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeMatcher'}
		public ??_SUnicodeSet@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeMatcher'}
??_SUnicodeSet@icu_56@@6BUnicodeMatcher@1@@ dd offset ??_EUnicodeSet@icu_56@@W3AEPAXI@Z
					; DATA XREF: initializeStatics(UErrorCode &)+EFo
					; initializeStatics(UErrorCode &)+214o
					; [thunk]:icu_56::UnicodeSet::`vector deleting destructor'`adjustor{4}' (uint)
		dd offset ?matches@UnicodeSet@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z ; icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed	char)
		dd offset ?toPattern@UnicodeSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z	; icu_56::UnicodeSet::toPattern(icu_56::UnicodeString &,signed char)
		dd offset ?matchesIndexValue@UnicodeSet@icu_56@@EBECE@Z	; icu_56::UnicodeSet::matchesIndexValue(uchar)
		dd offset ?addMatchSetTo@UnicodeSet@icu_56@@UBEXAAV12@@Z ; icu_56::UnicodeSet::addMatchSetTo(icu_56::UnicodeSet	&)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 17FCh
		dd offset ??_R4UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeFunctor'}
		public ??_SUnicodeSet@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeFunctor'}
??_SUnicodeSet@icu_56@@6BUnicodeFunctor@1@@ dd offset ??_EUnicodeSet@icu_56@@UAEPAXI@Z
					; DATA XREF: initializeStatics(UErrorCode &)+E3o
					; initializeStatics(UErrorCode &)+208o
					; icu_56::UnicodeSet::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeSet@icu_56@@UBEPAXXZ ; icu_56::UnicodeSet::getDynamicClassID(void)
		dd offset ?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ ;	icu_56::UnicodeSet::clone(void)
		dd offset ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ ; icu_56::UnicodeFilter::toMatcher(void)
		dd offset ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ	; icu_56::UnicodeFunctor::toReplacer(void)
		dd offset ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z ; icu_56::UnicodeFilter::setData(icu_56::TransliterationRuleData const *)
		dd offset ?contains@UnicodeSet@icu_56@@UBECH@Z ; icu_56::UnicodeSet::contains(int)
		dd offset ??8UnicodeSet@icu_56@@UBECABV01@@Z ; icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &)
		dd offset ?hashCode@UnicodeSet@icu_56@@UBEHXZ ;	icu_56::UnicodeSet::hashCode(void)
		dd offset ?size@UnicodeSet@icu_56@@UBEHXZ ; icu_56::UnicodeSet::size(void)
		dd offset ?isEmpty@UnicodeSet@icu_56@@UBECXZ ; icu_56::UnicodeSet::isEmpty(void)
		dd offset ?contains@UnicodeSet@icu_56@@UBECHH@Z	; icu_56::UnicodeSet::contains(int,int)
		dd offset ?containsAll@UnicodeSet@icu_56@@UBECABV12@@Z ; icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet const &)
		dd offset ?add@UnicodeSet@icu_56@@UAEAAV12@HH@Z	; icu_56::UnicodeSet::add(int,int)
		dd offset ?addAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ; icu_56::UnicodeSet::addAll(icu_56::UnicodeSet const &)
		dd offset ?retainAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ; icu_56::UnicodeSet::retainAll(icu_56::UnicodeSet const &)
		dd offset ?complementAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ;	icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet const &)
		dd offset ?removeAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ; icu_56::UnicodeSet::removeAll(icu_56::UnicodeSet const &)
		dd offset ?retain@UnicodeSet@icu_56@@UAEAAV12@HH@Z ; icu_56::UnicodeSet::retain(int,int)
		dd offset ?remove@UnicodeSet@icu_56@@UAEAAV12@HH@Z ; icu_56::UnicodeSet::remove(int,int)
		dd offset ?complement@UnicodeSet@icu_56@@UAEAAV12@HH@Z ; icu_56::UnicodeSet::complement(int,int)
		dd offset ?complement@UnicodeSet@icu_56@@UAEAAV12@XZ ; icu_56::UnicodeSet::complement(void)
		dd offset ?clear@UnicodeSet@icu_56@@UAEAAV12@XZ	; icu_56::UnicodeSet::clear(void)
		dd offset ?removeAllStrings@UnicodeSet@icu_56@@UAEAAV12@XZ ; icu_56::UnicodeSet::removeAllStrings(void)
		dd offset ?getRangeCount@UnicodeSet@icu_56@@UBEHXZ ; icu_56::UnicodeSet::getRangeCount(void)
		dd offset ?getRangeStart@UnicodeSet@icu_56@@UBEHH@Z ; icu_56::UnicodeSet::getRangeStart(int)
		dd offset ?getRangeEnd@UnicodeSet@icu_56@@UBEHH@Z ; icu_56::UnicodeSet::getRangeEnd(int)
		dd offset ?compact@UnicodeSet@icu_56@@UAEAAV12@XZ ; icu_56::UnicodeSet::compact(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1870h
__ehfuncinfo$?initializeStatics@@YAXAAW4UErrorCode@@@Z dd 19930522h, 6
					; DATA XREF: __ehhandler$?initializeStatics@@YAXAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?initializeStatics@@YAXAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$?initializeStatics@@YAXAAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001878o
		dd offset __unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$0
		align 10h
		dd offset __unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$1
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$1
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$2
		dd 3
		dd offset __unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$3
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$3
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 18C4h
		public ??_R4UnicodeSet@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeFunctor'}
??_R4UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ dd	3 dup(0) ; DATA	XREF: .rdata:000017FCo
		dd offset ??_R0?AVUnicodeSet@icu_56@@@8	; icu_56::UnicodeSet `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 18D8h
		public ??_R0?AVUnicodeSet@icu_56@@@8
; class	icu_56::UnicodeSet `RTTI Type Descriptor'
??_R0?AVUnicodeSet@icu_56@@@8 dd offset	??_7type_info@@6B@ ; DATA XREF:	.rdata$r:000018D0o
					; .rdata$r:icu_56::UnicodeSet::`RTTI Base Class	Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		align 10h
a_?avunicodeset	db '.?AVUnicodeSet@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 18F8h
		public ??_R3UnicodeSet@icu_56@@8
; icu_56::UnicodeSet::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeSet@icu_56@@8 dd 0		; DATA XREF: .rdata$r:000018D4o
					; .rdata$r:0000193Co ...
		dd 1, 6
		dd offset ??_R2UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1908h
		public ??_R2UnicodeSet@icu_56@@8
; icu_56::UnicodeSet::`RTTI Base Class Array'
??_R2UnicodeSet@icu_56@@8 dd offset ??_R1A@?0A@EA@UnicodeSet@icu_56@@8
					; DATA XREF: .rdata$r:00001904o
					; icu_56::UnicodeSet::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8	; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 ; icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1924h
		public ??_R1A@?0A@EA@UnicodeSet@icu_56@@8
; icu_56::UnicodeSet::`RTTI Base Class Descriptor at (0, -1, 0,	64)'
??_R1A@?0A@EA@UnicodeSet@icu_56@@8 dd offset ??_R0?AVUnicodeSet@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeSet::`RTTI	Base Class Array'o
					; icu_56::UnicodeSet `RTTI Type	Descriptor'
		dd 5, 0
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+40h ; "8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013E"...
		dd offset ??_R3UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1940h
		public ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeFilter@icu_56@@8 dd offset	??_R0?AVUnicodeFilter@icu_56@@@8
					; DATA XREF: .rdata$r:0000190Co
					; .rdata$r:icu_56::UnicodeFilter::`RTTI	Base Class Array'o
					; icu_56::UnicodeFilter	`RTTI Type Descriptor'
		dd 4, 0
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+40h ; "8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013E"...
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 195Ch
		public ??_R0?AVUnicodeFilter@icu_56@@@8
; class	icu_56::UnicodeFilter `RTTI Type Descriptor'
??_R0?AVUnicodeFilter@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UnicodeFilter::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodefil	db '.?AVUnicodeFilter@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1980h
		public ??_R3UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeFilter@icu_56@@8 dd	0	; DATA XREF: .rdata$r:00001958o
		dd 1, 5
		dd offset ??_R2UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1990h
		public ??_R2UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Array'
??_R2UnicodeFilter@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
					; DATA XREF: .rdata$r:0000198Co
					; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 ; icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 19A8h
		public ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 dd offset ??_R0?AVUnicodeFunctor@icu_56@@@8
					; DATA XREF: .rdata$r:00001910o
					; .rdata$r:00001994o ...
					; icu_56::UnicodeFunctor `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+40h ; "8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013E"...
		dd offset ??_R3UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 19C4h
		public ??_R0?AVUnicodeFunctor@icu_56@@@8
; class	icu_56::UnicodeFunctor `RTTI Type Descriptor'
??_R0?AVUnicodeFunctor@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodefun	db '.?AVUnicodeFunctor@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 19E8h
		public ??_R3UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeFunctor@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:000019C0o
		dd 3
		dd offset ??_R2UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 19F8h
		public ??_R2UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
??_R2UnicodeFunctor@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
					; DATA XREF: .rdata$r:000019F4o
					; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A08h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:00001914o
					; .rdata$r:00001998o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+40h ; "8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013E"...
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1A24h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A44h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00001A20o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A54h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00001A50o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A60h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00001918o
					; .rdata$r:0000199Co ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 8
		dd 4, 0FFFFFFFFh, 0
		dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+40h ; "8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013E"...
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1A7Ch
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A9Ch
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00001A78o
					; .rdata$r:00001ACCo
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1AACh
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00001AA8o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1AB4h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+40h ; "8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013E"...
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1AD0h
		public ??_R13?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UnicodeMatcher@icu_56@@8 dd offset	??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:0000191Co
					; .rdata$r:000019A0o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		align 8
		dd 4, 0FFFFFFFFh, 0
		dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+40h ; "8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013E"...
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1AECh
		public ??_R0?AVUnicodeMatcher@icu_56@@@8
; class	icu_56::UnicodeMatcher `RTTI Type Descriptor'
??_R0?AVUnicodeMatcher@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodemat	db '.?AVUnicodeMatcher@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1B10h
		public ??_R3UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeMatcher@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00001AE8o
					; .rdata$r:00001B40o
		dd 1
		dd offset ??_R2UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1B20h
		public ??_R2UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
??_R2UnicodeMatcher@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
					; DATA XREF: .rdata$r:00001B1Co
					; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1B28h
		public ??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8 dd offset ??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Array'o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+40h ; "8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013E"...
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1B44h
		public ??_R4UnicodeSet@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeMatcher'}
??_R4UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ dd	0 ; DATA XREF: .rdata:000017E4o
		dd 4, 0
		dd offset ??_R0?AVUnicodeSet@icu_56@@@8	; icu_56::UnicodeSet `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl uspoof_cleanup(void)
?uspoof_cleanup@@YACXZ proc near	; DATA XREF: initializeStatics(UErrorCode &)+2AFo
					; initializeDefaultData(UErrorCode &)+2Fo

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, ds:_gInclusionSet
		mov	[ebp+var_E0], eax
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_EC], ecx
		cmp	[ebp+var_EC], 0
		jz	short loc_1BBB
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_EC]
		mov	eax, [edx]
		mov	ecx, [ebp+var_EC]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_1BC5
; ---------------------------------------------------------------------------

loc_1BBB:				; CODE XREF: uspoof_cleanup(void)+3Cj
		mov	[ebp+var_F4], 0

loc_1BC5:				; CODE XREF: uspoof_cleanup(void)+61j
		mov	ds:_gInclusionSet, 0
		mov	eax, ds:_gRecommendedSet
		mov	[ebp+var_C8], eax
		mov	ecx, [ebp+var_C8]
		mov	[ebp+var_D4], ecx
		cmp	[ebp+var_D4], 0
		jz	short loc_1C14
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_D4]
		mov	eax, [edx]
		mov	ecx, [ebp+var_D4]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_1C1E
; ---------------------------------------------------------------------------

loc_1C14:				; CODE XREF: uspoof_cleanup(void)+95j
		mov	[ebp+var_F4], 0

loc_1C1E:				; CODE XREF: uspoof_cleanup(void)+BAj
		mov	ds:_gRecommendedSet, 0
		mov	ds:_gNfdNormalizer, 0
		cmp	ds:_gDefaultSpoofData, 0
		jz	short loc_1C46
		mov	ecx, ds:_gDefaultSpoofData ; this
		call	?removeReference@SpoofData@icu_56@@QAEXXZ ; icu_56::SpoofData::removeReference(void)

loc_1C46:				; CODE XREF: uspoof_cleanup(void)+E1j
		mov	ds:_gDefaultSpoofData, 0
		mov	ecx, offset _gSpoofInitStaticsOnce ; this
		call	?reset@UInitOnce@icu_56@@QAEXXZ	; icu_56::UInitOnce::reset(void)
		mov	ecx, offset _gSpoofInitDefaultOnce ; this
		call	?reset@UInitOnce@icu_56@@QAEXXZ	; icu_56::UInitOnce::reset(void)
		mov	al, 1
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?uspoof_cleanup@@YACXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UInitOnce::reset(icu_56::UInitOnce *__hidden this)
		public ?reset@UInitOnce@icu_56@@QAEXXZ
?reset@UInitOnce@icu_56@@QAEXXZ	proc near ; CODE XREF: uspoof_cleanup(void)+FDp
					; uspoof_cleanup(void)+107p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?reset@UInitOnce@icu_56@@QAEXXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeSet::`scalar	deleting destructor'(unsigned int)
		public ??_GUnicodeSet@icu_56@@UAEPAXI@Z
??_GUnicodeSet@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1D03
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1D03:				; CODE XREF: icu_56::UnicodeSet::`scalar deleting destructor'(uint)+3Bj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeSet@icu_56@@UAEPAXI@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uspoof_open_56
_uspoof_open_56	proc near

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi		; enum UErrorCode *
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax		; void (__cdecl	*)(enum	UErrorCode *)
		push	offset ?initializeStatics@@YAXAAW4UErrorCode@@@Z ; struct icu_56::UInitOnce *
		push	offset _gSpoofInitStaticsOnce ;	this
		call	?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z ; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		push	eax		; void (__cdecl	*)(enum	UErrorCode *)
		push	offset ?initializeDefaultData@@YAXAAW4UErrorCode@@@Z ; struct icu_56::UInitOnce	*
		push	offset _gSpoofInitDefaultOnce ;	this
		call	?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z ; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1D82
		xor	eax, eax
		jmp	loc_1E83
; ---------------------------------------------------------------------------

loc_1D82:				; CODE XREF: _uspoof_open_56+5Dj
		mov	esi, esp
		push	20h ; ' '       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_EC], eax
		cmp	[ebp+var_EC], 0
		jz	short loc_1DC3
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, ds:_gDefaultSpoofData
		push	ecx		; struct icu_56::SpoofData *
		mov	ecx, [ebp+var_EC] ; this
		call	??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)
		mov	[ebp+var_100], eax
		jmp	short loc_1DCD
; ---------------------------------------------------------------------------

loc_1DC3:				; CODE XREF: _uspoof_open_56+87j
		mov	[ebp+var_100], 0

loc_1DCD:				; CODE XREF: _uspoof_open_56+A5j
		mov	edx, [ebp+var_100]
		mov	[ebp+var_F8], edx
		mov	eax, [ebp+var_F8]
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_1DF3
		mov	ecx, ds:_gDefaultSpoofData ; this
		call	?addReference@SpoofData@icu_56@@QAEPAV12@XZ ; icu_56::SpoofData::addReference(void)

loc_1DF3:				; CODE XREF: _uspoof_open_56+CAj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1E17
		cmp	[ebp+var_8], 0
		jnz	short loc_1E17
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7

loc_1E17:				; CODE XREF: _uspoof_open_56+EAj
					; _uspoof_open_56+F0j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1E80
		mov	eax, [ebp+var_8]
		mov	[ebp+var_D4], eax
		mov	ecx, [ebp+var_D4]
		mov	[ebp+var_E0], ecx
		cmp	[ebp+var_E0], 0
		jz	short loc_1E6F
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_E0]
		mov	eax, [edx]
		mov	ecx, [ebp+var_E0]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_100], eax
		jmp	short loc_1E79
; ---------------------------------------------------------------------------

loc_1E6F:				; CODE XREF: _uspoof_open_56+12Cj
		mov	[ebp+var_100], 0

loc_1E79:				; CODE XREF: _uspoof_open_56+151j
		mov	[ebp+var_8], 0

loc_1E80:				; CODE XREF: _uspoof_open_56+10Ej
		mov	eax, [ebp+var_8]

loc_1E83:				; CODE XREF: _uspoof_open_56+61j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_open_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _uspoof_open_56+DDp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UInitOnce initializeDefaultData
?initializeDefaultData@@YAXAAW4UErrorCode@@@Z proc near	; DATA XREF: _uspoof_open_56+38o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		call	?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z ; icu_56::SpoofData::getDefault(UErrorCode &)
		add	esp, 4
		mov	ds:_gDefaultSpoofData, eax
		push	offset ?uspoof_cleanup@@YACXZ ;	uspoof_cleanup(void)
		push	1
		call	_ucln_i18n_registerCleanup_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initializeDefaultData@@YAXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uspoof_openFromSerialized_56
_uspoof_openFromSerialized_56 proc near

var_16C		= dword	ptr -16Ch
var_164		= dword	ptr -164h
var_158		= dword	ptr -158h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 16Ch
		push	ebx
		push	esi
		push	edi		; enum UErrorCode *
		lea	edi, [ebp+var_16C]
		mov	ecx, 5Bh ; '['
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1F52
		xor	eax, eax
		jmp	loc_218D
; ---------------------------------------------------------------------------

loc_1F52:				; CODE XREF: _uspoof_openFromSerialized_56+31j
		mov	eax, [ebp+arg_C]
		push	eax		; void (__cdecl	*)(enum	UErrorCode *)
		push	offset ?initializeStatics@@YAXAAW4UErrorCode@@@Z ; struct icu_56::UInitOnce *
		push	offset _gSpoofInitStaticsOnce ;	this
		call	?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z ; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)
		add	esp, 0Ch
		mov	esi, esp
		push	30h ; '0'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_158], eax
		cmp	[ebp+var_158], 0
		jz	short loc_1FAA
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; void *
		mov	ecx, [ebp+var_158] ; this
		call	??0SpoofData@icu_56@@QAE@PBXHAAW4UErrorCode@@@Z	; icu_56::SpoofData::SpoofData(void const *,int,UErrorCode &)
		mov	[ebp+var_16C], eax
		jmp	short loc_1FB4
; ---------------------------------------------------------------------------

loc_1FAA:				; CODE XREF: _uspoof_openFromSerialized_56+71j
		mov	[ebp+var_16C], 0

loc_1FB4:				; CODE XREF: _uspoof_openFromSerialized_56+90j
		mov	eax, [ebp+var_16C]
		mov	[ebp+var_164], eax
		mov	ecx, [ebp+var_164]
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	20h ; ' '       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_140], eax
		cmp	[ebp+var_140], 0
		jz	short loc_2007
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		push	ecx		; struct icu_56::SpoofData *
		mov	ecx, [ebp+var_140] ; this
		call	??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofData *,UErrorCode &)

loc_1FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		mov	[ebp+var_16C], eax
		jmp	short loc_2011
; ---------------------------------------------------------------------------

loc_2007:				; CODE XREF: _uspoof_openFromSerialized_56+D2j
		mov	[ebp+var_16C], 0

loc_2011:				; CODE XREF: _uspoof_openFromSerialized_56+EDj
		mov	edx, [ebp+var_16C]
		mov	[ebp+var_14C], edx
		mov	eax, [ebp+var_14C]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_20D0
		mov	eax, [ebp+var_8]
		mov	[ebp+var_128], eax
		mov	ecx, [ebp+var_128]
		mov	[ebp+var_134], ecx
		cmp	[ebp+var_134], 0
		jz	short loc_2072
		push	1
		mov	ecx, [ebp+var_134]
		call	??_GSpoofData@icu_56@@QAEPAXI@Z	; icu_56::SpoofData::`scalar deleting destructor'(uint)
		mov	[ebp+var_16C], eax
		jmp	short loc_207C
; ---------------------------------------------------------------------------

loc_2072:				; CODE XREF: _uspoof_openFromSerialized_56+143j
		mov	[ebp+var_16C], 0

loc_207C:				; CODE XREF: _uspoof_openFromSerialized_56+158j
		mov	eax, [ebp+var_14]
		mov	[ebp+var_110], eax
		mov	ecx, [ebp+var_110]
		mov	[ebp+var_11C], ecx
		cmp	[ebp+var_11C], 0
		jz	short loc_20BF
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_11C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_11C]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_16C], eax
		jmp	short loc_20C9
; ---------------------------------------------------------------------------

loc_20BF:				; CODE XREF: _uspoof_openFromSerialized_56+180j
		mov	[ebp+var_16C], 0

loc_20C9:				; CODE XREF: _uspoof_openFromSerialized_56+1A5j
		xor	eax, eax
		jmp	loc_218D
; ---------------------------------------------------------------------------

loc_20D0:				; CODE XREF: _uspoof_openFromSerialized_56+121j
		cmp	[ebp+var_8], 0
		jz	short loc_20E0
		cmp	[ebp+var_14], 0
		jnz	loc_2177

loc_20E0:				; CODE XREF: _uspoof_openFromSerialized_56+1BCj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_8]
		mov	[ebp+var_F8], eax
		mov	ecx, [ebp+var_F8]
		mov	[ebp+var_104], ecx
		cmp	[ebp+var_104], 0
		jz	short loc_211C
		push	1
		mov	ecx, [ebp+var_104]
		call	??_GSpoofData@icu_56@@QAEPAXI@Z	; icu_56::SpoofData::`scalar deleting destructor'(uint)
		mov	[ebp+var_16C], eax
		jmp	short loc_2126
; ---------------------------------------------------------------------------

loc_211C:				; CODE XREF: _uspoof_openFromSerialized_56+1EDj
		mov	[ebp+var_16C], 0

loc_2126:				; CODE XREF: _uspoof_openFromSerialized_56+202j
		mov	eax, [ebp+var_14]
		mov	[ebp+var_E0], eax
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_EC], ecx
		cmp	[ebp+var_EC], 0
		jz	short loc_2169
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_EC]
		mov	eax, [edx]
		mov	ecx, [ebp+var_EC]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_16C], eax
		jmp	short loc_2173
; ---------------------------------------------------------------------------

loc_2169:				; CODE XREF: _uspoof_openFromSerialized_56+22Aj
		mov	[ebp+var_16C], 0

loc_2173:				; CODE XREF: _uspoof_openFromSerialized_56+24Fj
		xor	eax, eax
		jmp	short loc_218D
; ---------------------------------------------------------------------------

loc_2177:				; CODE XREF: _uspoof_openFromSerialized_56+1C2j
		cmp	[ebp+arg_8], 0
		jz	short loc_218A
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_8]
		mov	eax, [ecx+8]
		mov	[edx], eax

loc_218A:				; CODE XREF: _uspoof_openFromSerialized_56+263j
		mov	eax, [ebp+var_14]

loc_218D:				; CODE XREF: _uspoof_openFromSerialized_56+35j
					; _uspoof_openFromSerialized_56+1B3j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 16Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_openFromSerialized_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::SpoofData::`scalar deleting	destructor'(unsigned int)
		public ??_GSpoofData@icu_56@@QAEPAXI@Z
??_GSpoofData@icu_56@@QAEPAXI@Z	proc near ; CODE XREF: _uspoof_openFromSerialized_56+14Dp
					; _uspoof_openFromSerialized_56+1F7p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SpoofData@icu_56@@QAE@XZ ; icu_56::SpoofData::~SpoofData(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_21ED
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_21ED:				; CODE XREF: icu_56::SpoofData::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSpoofData@icu_56@@QAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2208h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_clone_56(struct USpoofChecker *, enum UErrorCode *)
		public _uspoof_clone_56
_uspoof_clone_56 proc near

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_2246
		xor	eax, eax
		jmp	loc_230F
; ---------------------------------------------------------------------------

loc_2246:				; CODE XREF: _uspoof_clone_56+35j
		mov	esi, esp
		push	20h ; ' '       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F8], eax
		cmp	[ebp+var_F8], 0
		jz	short loc_2284
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		push	ecx		; struct icu_56::SpoofImpl *
		mov	ecx, [ebp+var_F8] ; this
		call	??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl const &,UErrorCode &)
		mov	[ebp+var_10C], eax
		jmp	short loc_228E
; ---------------------------------------------------------------------------

loc_2284:				; CODE XREF: _uspoof_clone_56+5Fj
		mov	[ebp+var_10C], 0

loc_228E:				; CODE XREF: _uspoof_clone_56+7Aj
		mov	edx, [ebp+var_10C]
		mov	[ebp+var_104], edx
		mov	eax, [ebp+var_104]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_230C
		mov	eax, [ebp+var_14]
		mov	[ebp+var_E0], eax
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_EC], ecx
		cmp	[ebp+var_EC], 0
		jz	short loc_22FB
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_EC]
		mov	eax, [edx]
		mov	ecx, [ebp+var_EC]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_2305
; ---------------------------------------------------------------------------

loc_22FB:				; CODE XREF: _uspoof_clone_56+CCj
		mov	[ebp+var_10C], 0

loc_2305:				; CODE XREF: _uspoof_clone_56+F1j
		mov	[ebp+var_14], 0

loc_230C:				; CODE XREF: _uspoof_clone_56+AEj
		mov	eax, [ebp+var_14]

loc_230F:				; CODE XREF: _uspoof_clone_56+39j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_clone_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2324h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_close_56(struct USpoofChecker *)
		public _uspoof_close_56
_uspoof_close_56 proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		lea	eax, [ebp+var_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPAV12@PAUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker *,UErrorCode &)
		add	esp, 8
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	[ebp+var_E0], eax
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_EC], ecx
		cmp	[ebp+var_EC], 0
		jz	short loc_239F
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_EC]
		mov	eax, [edx]
		mov	ecx, [ebp+var_EC]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_23A9
; ---------------------------------------------------------------------------

loc_239F:				; CODE XREF: _uspoof_close_56+54j
		mov	[ebp+var_F4], 0

loc_23A9:				; CODE XREF: _uspoof_close_56+79j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_close_56 endp

; ---------------------------------------------------------------------------
		align 10h
$LN7		dd 1			; DATA XREF: _uspoof_close_56+89o
		dd offset $LN6
$LN6		dd 0FFFFFFF8h, 4	; DATA XREF: .text:000023D4o
		dd offset $LN5		; "status"
$LN5		db 'status',0           ; DATA XREF: .text:000023E0o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_setChecks_56(struct USpoofChecker *, int, enum UErrorCode *)
		public _uspoof_setChecks_56
_uspoof_setChecks_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPAV12@PAUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker *,UErrorCode &)
		add	esp, 8
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_2425
		jmp	short loc_2443
; ---------------------------------------------------------------------------

loc_2425:				; CODE XREF: _uspoof_setChecks_56+35j
		mov	eax, [ebp+arg_4]
		and	eax, 0BFFF0000h
		jz	short loc_243A
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	short loc_2443
; ---------------------------------------------------------------------------

loc_243A:				; CODE XREF: _uspoof_setChecks_56+41j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+8], ecx

loc_2443:				; CODE XREF: _uspoof_setChecks_56+37j
					; _uspoof_setChecks_56+4Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_setChecks_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2458h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_getChecks_56(struct USpoofChecker *, enum UErrorCode *)
		public _uspoof_getChecks_56
_uspoof_getChecks_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_2493
		xor	eax, eax
		jmp	short loc_2499
; ---------------------------------------------------------------------------

loc_2493:				; CODE XREF: _uspoof_getChecks_56+35j
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]

loc_2499:				; CODE XREF: _uspoof_getChecks_56+39j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_getChecks_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_setRestrictionLevel_56(struct USpoofChecker *, int)
		public _uspoof_setRestrictionLevel_56
_uspoof_setRestrictionLevel_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		lea	eax, [ebp+var_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPAV12@PAUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker *,UErrorCode &)
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_24F7
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	[eax+18h], ecx

loc_24F7:				; CODE XREF: _uspoof_setRestrictionLevel_56+3Cj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_setRestrictionLevel_56 endp

; ---------------------------------------------------------------------------
$LN6_0		dd 1			; DATA XREF: _uspoof_setRestrictionLevel_56+4Bo
		dd offset $LN5_0
$LN5_0		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00002520o
		dd offset $LN4		; "status"
$LN4		db 'status',0           ; DATA XREF: .text:0000252Co
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2538h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_getRestrictionLevel_56(struct USpoofChecker *)
		public _uspoof_getRestrictionLevel_56
_uspoof_getRestrictionLevel_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		lea	eax, [ebp+var_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_257D
		mov	eax, 60000000h
		jmp	short loc_2583
; ---------------------------------------------------------------------------

loc_257D:				; CODE XREF: _uspoof_getRestrictionLevel_56+3Cj
		mov	eax, [ebp+var_14]
		mov	eax, [eax+18h]

loc_2583:				; CODE XREF: _uspoof_getRestrictionLevel_56+43j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_getRestrictionLevel_56 endp

; ---------------------------------------------------------------------------
$LN6_1		dd 1			; DATA XREF: _uspoof_getRestrictionLevel_56+4Fo
		dd offset $LN5_1
$LN5_1		dd 0FFFFFFF8h, 4	; DATA XREF: .text:000025ACo
		dd offset $LN4_0	; "status"
$LN4_0		db 'status',0           ; DATA XREF: .text:000025B8o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_setAllowedLocales_56(struct USpoofChecker *, char *, enum UErrorCode *)
		public _uspoof_setAllowedLocales_56
_uspoof_setAllowedLocales_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPAV12@PAUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker *,UErrorCode &)
		add	esp, 8
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_25FD
		jmp	short loc_260D
; ---------------------------------------------------------------------------

loc_25FD:				; CODE XREF: _uspoof_setAllowedLocales_56+35j
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; char *
		mov	ecx, [ebp+var_8] ; this
		call	?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z ; icu_56::SpoofImpl::setAllowedLocales(char const *,UErrorCode &)

loc_260D:				; CODE XREF: _uspoof_setAllowedLocales_56+37j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_setAllowedLocales_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2624h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_getAllowedLocales_56(struct USpoofChecker *, enum UErrorCode *)
		public _uspoof_getAllowedLocales_56
_uspoof_getAllowedLocales_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPAV12@PAUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker *,UErrorCode &)
		add	esp, 8
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_265F
		xor	eax, eax
		jmp	short loc_266B
; ---------------------------------------------------------------------------

loc_265F:				; CODE XREF: _uspoof_getAllowedLocales_56+35j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?getAllowedLocales@SpoofImpl@icu_56@@QAEPBDAAW4UErrorCode@@@Z ;	icu_56::SpoofImpl::getAllowedLocales(UErrorCode	&)

loc_266B:				; CODE XREF: _uspoof_getAllowedLocales_56+39j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_getAllowedLocales_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2680h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_getAllowedChars_56(struct USpoofChecker *,	enum UErrorCode	*)
		public _uspoof_getAllowedChars_56
_uspoof_getAllowedChars_56 proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	_uspoof_getAllowedUnicodeSet_56
		add	esp, 8
		mov	[ebp+var_8], eax
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ ; icu_56::UnicodeSet::toUSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_getAllowedChars_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_getAllowedUnicodeSet_56(struct USpoofChecker *, enum UErrorCode *)
		public _uspoof_getAllowedUnicodeSet_56
_uspoof_getAllowedUnicodeSet_56	proc near ; CODE XREF: _uspoof_getAllowedChars_56+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_2713
		xor	eax, eax
		jmp	short loc_2719
; ---------------------------------------------------------------------------

loc_2713:				; CODE XREF: _uspoof_getAllowedUnicodeSet_56+35j
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]

loc_2719:				; CODE XREF: _uspoof_getAllowedUnicodeSet_56+39j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_getAllowedUnicodeSet_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2730h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_setAllowedChars_56(struct USpoofChecker *,	struct USet *, enum UErrorCode *)
		public _uspoof_setAllowedChars_56
_uspoof_setAllowedChars_56 proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; struct USet *
		call	dword ptr ds:__imp_?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z ; icu_56::UnicodeSet::fromUSet(USet	const *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		push	ecx		; icu_56::UnicodeSet *
		mov	edx, [ebp+arg_0]
		push	edx		; struct USpoofChecker *
		call	_uspoof_setAllowedUnicodeSet_56
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_setAllowedChars_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2790h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_setAllowedUnicodeSet_56(struct USpoofChecker *, icu_56::UnicodeSet	*, enum	UErrorCode *)
		public _uspoof_setAllowedUnicodeSet_56
_uspoof_setAllowedUnicodeSet_56	proc near ; CODE XREF: _uspoof_setAllowedChars_56+43p

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPAV12@PAUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker *,UErrorCode &)
		add	esp, 8
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_27CC
		jmp	loc_28B0
; ---------------------------------------------------------------------------

loc_27CC:				; CODE XREF: _uspoof_setAllowedUnicodeSet_56+35j
		mov	esi, esp
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?isBogus@UnicodeSet@icu_56@@QBECXZ ;	icu_56::UnicodeSet::isBogus(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_27F3
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	loc_28B0
; ---------------------------------------------------------------------------

loc_27F3:				; CODE XREF: _uspoof_setAllowedUnicodeSet_56+53j
		mov	eax, [ebp+arg_4]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_4]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_282B
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_?isBogus@UnicodeSet@icu_56@@QBECXZ ;	icu_56::UnicodeSet::isBogus(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_2836

loc_282B:				; CODE XREF: _uspoof_setAllowedUnicodeSet_56+80j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	short loc_28B0
; ---------------------------------------------------------------------------

loc_2836:				; CODE XREF: _uspoof_setAllowedUnicodeSet_56+99j
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ	; icu_56::UnicodeSet::freeze(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_288E
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_2898
; ---------------------------------------------------------------------------

loc_288E:				; CODE XREF: _uspoof_setAllowedUnicodeSet_56+D7j
		mov	[ebp+var_F4], 0

loc_2898:				; CODE XREF: _uspoof_setAllowedUnicodeSet_56+FCj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		or	ecx, 40h
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx

loc_28B0:				; CODE XREF: _uspoof_setAllowedUnicodeSet_56+37j
					; _uspoof_setAllowedUnicodeSet_56+5Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_setAllowedUnicodeSet_56	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_check_56(struct USpoofChecker *, wchar_t *, int, int, enum	UErrorCode *)
		public _uspoof_check_56
_uspoof_check_56 proc near

var_130		= byte ptr -130h
var_12C		= dword	ptr -12Ch
var_60		= dword	ptr -60h
var_54		= byte ptr -54h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 130h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_130]
		mov	ecx, 4Ch ; 'L'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	[ebp+var_C], eax
		cmp	[ebp+var_C], 0
		jnz	short loc_2909
		xor	eax, eax
		jmp	short loc_297D
; ---------------------------------------------------------------------------

loc_2909:				; CODE XREF: _uspoof_check_56+3Fj
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jge	short loc_291C
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_297D
; ---------------------------------------------------------------------------

loc_291C:				; CODE XREF: _uspoof_check_56+49j
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		cmp	[ebp+arg_8], 0FFFFFFFFh
		setz	dl
		movzx	eax, dl
		push	eax		; signed __int8
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		lea	edx, [ebp+var_54]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_0]
		push	eax		; struct USpoofChecker *
		call	_uspoof_checkUnicodeString_56
		add	esp, 10h
		mov	[ebp+var_60], eax
		mov	eax, [ebp+var_60]
		mov	[ebp+var_12C], eax
		mov	esi, esp
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_12C]

loc_297D:				; CODE XREF: _uspoof_check_56+43j
					; _uspoof_check_56+56j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 130h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_check_56 endp

; ---------------------------------------------------------------------------
$LN7_0		dd 1			; DATA XREF: _uspoof_check_56+BDo
		dd offset $LN6_2
$LN6_2		dd 0FFFFFFACh, 40h	; DATA XREF: .text:000029B0o
		dd offset $LN5_2	; "idStr"
$LN5_2		db 'idStr',0            ; DATA XREF: .text:000029BCo
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_checkUTF8_56(struct USpoofChecker *, char *Str, int, int, enum UErrorCode *)
		public _uspoof_checkUTF8_56
_uspoof_checkUTF8_56 proc near

var_138		= dword	ptr -138h
var_130		= byte ptr -130h
var_120		= dword	ptr -120h
var_54		= dword	ptr -54h
var_48		= byte ptr -48h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_138]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2A0C
		xor	eax, eax
		jmp	loc_2AA2
; ---------------------------------------------------------------------------

loc_2A0C:				; CODE XREF: _uspoof_checkUTF8_56+3Bj
		cmp	[ebp+arg_8], 0
		jl	short loc_2A1D
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_138], eax
		jmp	short loc_2A2F
; ---------------------------------------------------------------------------

loc_2A1D:				; CODE XREF: _uspoof_checkUTF8_56+48j
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_138], eax

loc_2A2F:				; CODE XREF: _uspoof_checkUTF8_56+53j
		mov	esi, esp
		mov	edx, [ebp+var_138]
		push	edx		; int
		mov	eax, [ebp+Str]
		push	eax		; char *
		lea	ecx, [ebp+var_130] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBDH@Z ; icu_56::StringPiece::StringPiece(char const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		lea	ecx, [ebp+var_48]
		push	ecx
		call	dword ptr ds:__imp_?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z ; icu_56::UnicodeString::fromUTF8(icu_56::StringPiece const &)
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		lea	edx, [ebp+var_48]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_0]
		push	eax		; struct USpoofChecker *
		call	_uspoof_checkUnicodeString_56
		add	esp, 10h
		mov	[ebp+var_54], eax
		mov	eax, [ebp+var_54]
		mov	[ebp+var_120], eax
		mov	esi, esp
		lea	ecx, [ebp+var_48] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_120]

loc_2AA2:				; CODE XREF: _uspoof_checkUTF8_56+3Fj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 138h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_checkUTF8_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN8		dd 1			; DATA XREF: _uspoof_checkUTF8_56+DEo
		dd offset $LN7_1
$LN7_1		dd 0FFFFFFB8h, 40h	; DATA XREF: .text:00002AD8o
		dd offset $LN6_3	; "idStr"
$LN6_3		db 'idStr',0            ; DATA XREF: .text:00002AE4o
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2AF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_areConfusable_56(struct USpoofChecker *, wchar_t *, int, wchar_t *, int, enum UErrorCode *)
		public _uspoof_areConfusable_56
_uspoof_areConfusable_56 proc near

var_160		= byte ptr -160h
var_15C		= dword	ptr -15Ch
var_90		= byte ptr -90h
var_48		= byte ptr -48h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 160h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_160]
		mov	ecx, 58h ; 'X'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2B44
		xor	eax, eax
		jmp	loc_2BFB
; ---------------------------------------------------------------------------

loc_2B44:				; CODE XREF: _uspoof_areConfusable_56+4Bj
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jl	short loc_2B50
		cmp	[ebp+arg_10], 0FFFFFFFFh
		jge	short loc_2B60

loc_2B50:				; CODE XREF: _uspoof_areConfusable_56+58j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_2BFB
; ---------------------------------------------------------------------------

loc_2B60:				; CODE XREF: _uspoof_areConfusable_56+5Ej
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		cmp	[ebp+arg_8], 0FFFFFFFFh
		setz	dl
		movzx	eax, dl
		push	eax		; signed __int8
		lea	ecx, [ebp+var_48] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; wchar_t *
		cmp	[ebp+arg_10], 0FFFFFFFFh
		setz	dl
		movzx	eax, dl
		push	eax		; signed __int8
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_14]
		push	eax
		lea	ecx, [ebp+var_90]
		push	ecx
		lea	edx, [ebp+var_48]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uspoof_areConfusableUnicodeString_56
		add	esp, 10h
		mov	[ebp+var_15C], eax
		mov	esi, esp
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_48] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_15C]

loc_2BFB:				; CODE XREF: _uspoof_areConfusable_56+4Fj
					; _uspoof_areConfusable_56+6Bj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 160h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_areConfusable_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN9_0		dd 2			; DATA XREF: _uspoof_areConfusable_56+10Fo
		dd offset $LN8_0
$LN8_0		dd 0FFFFFFB8h, 40h	; DATA XREF: .text:00002C30o
		dd offset $LN6_4	; "id1Str"
		dd 0FFFFFF70h, 40h
		dd offset $LN7_2	; "id2Str"
$LN7_2		db 'id2Str',0           ; DATA XREF: .text:00002C48o
$LN6_4		db 'id1Str',0           ; DATA XREF: .text:00002C3Co
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_areConfusableUTF8_56(struct USpoofChecker *, char *Str, int, char *, int, enum UErrorCode *)
		public _uspoof_areConfusableUTF8_56
_uspoof_areConfusableUTF8_56 proc near

var_190		= dword	ptr -190h
var_188		= byte ptr -188h
var_178		= byte ptr -178h
var_168		= dword	ptr -168h
var_9C		= dword	ptr -9Ch
var_90		= byte ptr -90h
var_48		= byte ptr -48h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 190h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_190]
		mov	ecx, 64h ; 'd'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2CB0
		xor	eax, eax
		jmp	loc_2DDD
; ---------------------------------------------------------------------------

loc_2CB0:				; CODE XREF: _uspoof_areConfusableUTF8_56+4Bj
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jl	short loc_2CBC
		cmp	[ebp+arg_10], 0FFFFFFFFh
		jge	short loc_2CCC

loc_2CBC:				; CODE XREF: _uspoof_areConfusableUTF8_56+58j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_2DDD
; ---------------------------------------------------------------------------

loc_2CCC:				; CODE XREF: _uspoof_areConfusableUTF8_56+5Ej
		cmp	[ebp+arg_8], 0
		jl	short loc_2CDD
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_190], eax
		jmp	short loc_2CEF
; ---------------------------------------------------------------------------

loc_2CDD:				; CODE XREF: _uspoof_areConfusableUTF8_56+74j
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_190], eax

loc_2CEF:				; CODE XREF: _uspoof_areConfusableUTF8_56+7Fj
		mov	esi, esp
		mov	edx, [ebp+var_190]
		push	edx		; int
		mov	eax, [ebp+Str]
		push	eax		; char *
		lea	ecx, [ebp+var_188] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBDH@Z ; icu_56::StringPiece::StringPiece(char const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		lea	ecx, [ebp+var_48]
		push	ecx
		call	dword ptr ds:__imp_?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z ; icu_56::UnicodeString::fromUTF8(icu_56::StringPiece const &)
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+arg_10], 0
		jl	short loc_2D37
		mov	eax, [ebp+arg_10]
		mov	[ebp+var_190], eax
		jmp	short loc_2D49
; ---------------------------------------------------------------------------

loc_2D37:				; CODE XREF: _uspoof_areConfusableUTF8_56+CEj
		mov	ecx, [ebp+arg_C]
		push	ecx		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_190], eax

loc_2D49:				; CODE XREF: _uspoof_areConfusableUTF8_56+D9j
		mov	esi, esp
		mov	edx, [ebp+var_190]
		push	edx		; int
		mov	eax, [ebp+arg_C]
		push	eax		; char *
		lea	ecx, [ebp+var_178] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBDH@Z ; icu_56::StringPiece::StringPiece(char const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		lea	ecx, [ebp+var_90]
		push	ecx
		call	dword ptr ds:__imp_?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z ; icu_56::UnicodeString::fromUTF8(icu_56::StringPiece const &)
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_14]
		push	eax
		lea	ecx, [ebp+var_90]
		push	ecx
		lea	edx, [ebp+var_48]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uspoof_areConfusableUnicodeString_56
		add	esp, 10h
		mov	[ebp+var_9C], eax
		mov	eax, [ebp+var_9C]
		mov	[ebp+var_168], eax
		mov	esi, esp
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_48] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_168]

loc_2DDD:				; CODE XREF: _uspoof_areConfusableUTF8_56+4Fj
					; _uspoof_areConfusableUTF8_56+6Bj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 190h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_areConfusableUTF8_56 endp

; ---------------------------------------------------------------------------
$LN13_0		dd 2			; DATA XREF: _uspoof_areConfusableUTF8_56+185o
		dd offset $LN12
$LN12		dd 0FFFFFFB8h, 40h	; DATA XREF: .text:00002E10o
		dd offset $LN10		; "id1Str"
		dd 0FFFFFF70h, 40h
		dd offset $LN11		; "id2Str"
$LN11		db 'id2Str',0           ; DATA XREF: .text:00002E28o
$LN10		db 'id1Str',0           ; DATA XREF: .text:00002E1Co
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uspoof_areConfusableUnicodeString_56
_uspoof_areConfusableUnicodeString_56 proc near	; CODE XREF: _uspoof_areConfusable_56+D0p
					; _uspoof_areConfusableUTF8_56+13Ap

var_254		= byte ptr -254h
var_251		= byte ptr -251h
var_18C		= byte ptr -18Ch
var_144		= byte ptr -144h
var_F9		= byte ptr -0F9h
var_F0		= byte ptr -0F0h
var_A8		= byte ptr -0A8h
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 254h
		push	ebx
		push	esi
		push	edi		; int
		lea	edi, [ebp+var_254]
		mov	ecx, 95h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2E93
		xor	eax, eax
		jmp	loc_3186
; ---------------------------------------------------------------------------

loc_2E93:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+4Ej
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 7
		jnz	short loc_2EAE
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1Bh
		xor	eax, eax
		jmp	loc_3186
; ---------------------------------------------------------------------------

loc_2EAE:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+60j
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 8
		mov	[ebp+var_18], ecx
		mov	[ebp+var_24], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_C] ; this
		call	?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)
		mov	[ebp+var_30], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2EEC
		xor	eax, eax
		jmp	loc_3186
; ---------------------------------------------------------------------------

loc_2EEC:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+A7j
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_30] ; this
		call	?setIdentifier@IdentifierInfo@icu_56@@QAEAAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::IdentifierInfo::setIdentifier(icu_56::UnicodeString const &,UErrorCode &)
		mov	ecx, [ebp+var_30] ; this
		call	?getScriptCount@IdentifierInfo@icu_56@@QBEHXZ ;	icu_56::IdentifierInfo::getScriptCount(void)
		mov	[ebp+var_3C], eax
		push	0		; int
		mov	ecx, [ebp+var_30] ; this
		call	?getScripts@IdentifierInfo@icu_56@@QBEPBVScriptSet@2@XZ	; icu_56::IdentifierInfo::getScripts(void)
		mov	ecx, eax	; this
		call	?nextSetBit@ScriptSet@icu_56@@QBEHH@Z ;	icu_56::ScriptSet::nextSetBit(int)
		mov	[ebp+var_48], eax
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_30] ; this
		call	?setIdentifier@IdentifierInfo@icu_56@@QAEAAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::IdentifierInfo::setIdentifier(icu_56::UnicodeString const &,UErrorCode &)
		mov	ecx, [ebp+var_30] ; this
		call	?getScriptCount@IdentifierInfo@icu_56@@QBEHXZ ;	icu_56::IdentifierInfo::getScriptCount(void)
		mov	[ebp+var_54], eax
		push	0		; int
		mov	ecx, [ebp+var_30] ; this
		call	?getScripts@IdentifierInfo@icu_56@@QBEPBVScriptSet@2@XZ	; icu_56::IdentifierInfo::getScripts(void)
		mov	ecx, eax	; this
		call	?nextSetBit@ScriptSet@icu_56@@QBEHH@Z ;	icu_56::ScriptSet::nextSetBit(int)
		mov	[ebp+var_60], eax
		mov	eax, [ebp+var_30]
		push	eax		; struct icu_56::IdentifierInfo	*
		mov	ecx, [ebp+var_C] ; this
		call	?releaseIdentifierInfo@SpoofImpl@icu_56@@QBEXPAVIdentifierInfo@2@@Z ; icu_56::SpoofImpl::releaseIdentifierInfo(icu_56::IdentifierInfo *)
		mov	[ebp+var_30], 0
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 1
		jz	loc_304B
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_F0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_3C], 1
		jg	loc_3021
		cmp	[ebp+var_54], 1
		jg	short loc_3021
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_60]
		jnz	short loc_3021
		mov	eax, [ebp+var_18]
		or	eax, 1
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_A8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+var_18]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z ; uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString	const &,icu_56::UnicodeString &,UErrorCode *)
		add	esp, 14h
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_F0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+var_18]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z ; uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString	const &,icu_56::UnicodeString &,UErrorCode *)
		add	esp, 14h
		mov	esi, esp
		lea	eax, [ebp+var_F0]
		push	eax

loc_2FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		lea	ecx, [ebp+var_A8]
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_3021
		mov	eax, [ebp+var_24]
		or	eax, 1
		mov	[ebp+var_24], eax

loc_3021:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+15Ej
					; _uspoof_areConfusableUnicodeString_56+168j ...
		mov	esi, esp
		lea	ecx, [ebp+var_F0] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_304B:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+12Aj
		mov	eax, [ebp+var_24]
		and	eax, 1
		jz	short loc_305B
		mov	eax, [ebp+var_24]
		jmp	loc_3186
; ---------------------------------------------------------------------------

loc_305B:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+215j
		cmp	[ebp+var_3C], 1
		jg	short loc_307B
		cmp	[ebp+var_54], 1
		jg	short loc_307B
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 4
		jz	short loc_307B
		mov	[ebp+var_251], 1
		jmp	short loc_3082
; ---------------------------------------------------------------------------

loc_307B:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+223j
					; _uspoof_areConfusableUnicodeString_56+229j ...
		mov	[ebp+var_251], 0

loc_3082:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+23Dj
		mov	dl, [ebp+var_251]
		mov	[ebp+var_F9], dl
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 2
		jnz	short loc_30A8
		movsx	eax, [ebp+var_F9]
		test	eax, eax
		jz	loc_3183

loc_30A8:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+25Bj
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_18C] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]
		and	eax, 0FFFFFFFEh
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_144]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+var_18]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z ; uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString	const &,icu_56::UnicodeString &,UErrorCode *)
		add	esp, 14h
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_18C]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+var_18]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z ; uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString	const &,icu_56::UnicodeString &,UErrorCode *)
		add	esp, 14h
		mov	esi, esp
		lea	eax, [ebp+var_18C]
		push	eax
		lea	ecx, [ebp+var_144]
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_3159
		mov	eax, [ebp+var_24]
		or	eax, 2
		mov	[ebp+var_24], eax
		movsx	eax, [ebp+var_F9]
		test	eax, eax
		jz	short loc_3159
		mov	eax, [ebp+var_24]
		or	eax, 4
		mov	[ebp+var_24], eax

loc_3159:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+2FEj
					; _uspoof_areConfusableUnicodeString_56+312j
		mov	esi, esp
		lea	ecx, [ebp+var_18C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3183:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+266j
		mov	eax, [ebp+var_24]

loc_3186:				; CODE XREF: _uspoof_areConfusableUnicodeString_56+52j
					; _uspoof_areConfusableUnicodeString_56+6Dj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN21
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 254h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_areConfusableUnicodeString_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN21		dd 4			; DATA XREF: _uspoof_areConfusableUnicodeString_56+34Eo
		dd offset $LN20
$LN20		dd 0FFFFFF58h, 40h	; DATA XREF: .text:000031BCo
		dd offset $LN16		; "id1Skeleton"
		dd 0FFFFFF10h, 40h
		dd offset $LN17		; "id2Skeleton"
		dd 0FFFFFEBCh, 40h
		dd offset $LN18		; "id1Skeleton"
		dd 0FFFFFE74h, 40h
		dd offset $LN19		; "id2Skeleton"
$LN19		db 'id2Skeleton',0      ; DATA XREF: .text:000031ECo
$LN18		db 'id1Skeleton',0      ; DATA XREF: .text:000031E0o
$LN17		db 'id2Skeleton',0      ; DATA XREF: .text:000031D4o
$LN16		db 'id1Skeleton',0      ; DATA XREF: .text:000031C8o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3220h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_checkUnicodeString_56(struct USpoofChecker	*, struct icu_56::UnicodeString	*, int,	enum UErrorCode	*)
		public _uspoof_checkUnicodeString_56
_uspoof_checkUnicodeString_56 proc near	; CODE XREF: _uspoof_check_56+8Dp
					; _uspoof_checkUTF8_56+AEp

var_21C		= byte ptr -21Ch
var_158		= dword	ptr -158h
var_14C		= byte ptr -14Ch
var_12C		= dword	ptr -12Ch
var_120		= byte ptr -120h
var_E1		= byte ptr -0E1h
var_D8		= dword	ptr -0D8h
var_CC		= dword	ptr -0CCh
var_C0		= dword	ptr -0C0h
var_B4		= dword	ptr -0B4h
var_A8		= byte ptr -0A8h
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 21Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_21C]
		mov	ecx, 87h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	[ebp+var_C], eax
		cmp	[ebp+var_C], 0
		jnz	short loc_3268
		xor	eax, eax
		jmp	loc_3709
; ---------------------------------------------------------------------------

loc_3268:				; CODE XREF: _uspoof_checkUnicodeString_56+3Fj
		mov	[ebp+var_18], 0
		mov	[ebp+var_24], 0
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 90h
		jz	short loc_32CC
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_C] ; this
		call	?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)
		mov	[ebp+var_24], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_32AD
		jmp	$cleanupAndReturn$71316
; ---------------------------------------------------------------------------

loc_32AD:				; CODE XREF: _uspoof_checkUnicodeString_56+86j
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_24] ; this
		call	?setIdentifier@IdentifierInfo@icu_56@@QAEAAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::IdentifierInfo::setIdentifier(icu_56::UnicodeString const &,UErrorCode &)
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+10h]
		push	ecx		; struct icu_56::UnicodeSet *
		mov	ecx, [ebp+var_24] ; this
		call	?setIdentifierProfile@IdentifierInfo@icu_56@@QAEAAV12@ABVUnicodeSet@2@@Z ; icu_56::IdentifierInfo::setIdentifierProfile(icu_56::UnicodeSet const &)

loc_32CC:				; CODE XREF: _uspoof_checkUnicodeString_56+62j
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 10h
		jz	short loc_3311
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_24]
		call	?getRestrictionLevel@IdentifierInfo@icu_56@@QBE?AW4URestrictionLevel@@AAW4UErrorCode@@@Z ; icu_56::IdentifierInfo::getRestrictionLevel(UErrorCode &)
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_C]
		mov	ecx, [ebp+var_30]
		cmp	ecx, [eax+18h]
		jle	short loc_32FA
		mov	eax, [ebp+var_18]
		or	eax, 10h
		mov	[ebp+var_18], eax

loc_32FA:				; CODE XREF: _uspoof_checkUnicodeString_56+CFj
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 40000000h
		jz	short loc_3311
		mov	eax, [ebp+var_18]
		or	eax, [ebp+var_30]
		mov	[ebp+var_18], eax

loc_3311:				; CODE XREF: _uspoof_checkUnicodeString_56+B5j
					; _uspoof_checkUnicodeString_56+E6j
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 80h
		jz	short loc_3350
		mov	ecx, [ebp+var_24] ; this
		call	?getNumerics@IdentifierInfo@icu_56@@QBEPBVUnicodeSet@2@XZ ; icu_56::IdentifierInfo::getNumerics(void)
		mov	[ebp+var_3C], eax
		mov	eax, [ebp+var_3C]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_3C]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jle	short loc_3350
		mov	eax, [ebp+var_18]
		or	eax, 80h
		mov	[ebp+var_18], eax

loc_3350:				; CODE XREF: _uspoof_checkUnicodeString_56+FDj
					; _uspoof_checkUnicodeString_56+123j
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 40h
		jz	loc_33E5
		mov	esi, esp
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_60], eax
		mov	[ebp+var_48], 0

loc_337B:				; CODE XREF: _uspoof_checkUnicodeString_56:loc_33E3j
		mov	eax, [ebp+var_48]
		cmp	eax, [ebp+var_60]
		jge	short loc_33E5
		mov	esi, esp
		mov	eax, [ebp+var_48]
		push	eax		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?char32At@UnicodeString@icu_56@@QBEHH@Z ; icu_56::UnicodeString::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_54], eax
		mov	eax, 0FFFFh
		cmp	eax, [ebp+var_54]
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		add	ecx, [ebp+var_48]
		mov	[ebp+var_48], ecx
		mov	esi, esp
		mov	eax, [ebp+var_54]
		push	eax
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+10h]
		mov	edx, [edx]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_33E3
		mov	eax, [ebp+var_18]
		or	eax, 40h
		mov	[ebp+var_18], eax
		jmp	short loc_33E5
; ---------------------------------------------------------------------------

loc_33E3:				; CODE XREF: _uspoof_checkUnicodeString_56+1B6j
		jmp	short loc_337B
; ---------------------------------------------------------------------------

loc_33E5:				; CODE XREF: _uspoof_checkUnicodeString_56+139j
					; _uspoof_checkUnicodeString_56+161j ...
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 26h
		jz	$cleanupAndReturn$71316
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_A8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, ds:_gNfdNormalizer
		mov	edx, [eax]
		mov	ecx, ds:_gNfdNormalizer
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_B4], eax
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 20h
		jz	loc_35D8
		mov	[ebp+var_D8], 0
		mov	[ebp+var_E1], 0
		mov	esi, esp
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_??0UnicodeSet@icu_56@@QAE@XZ	; icu_56::UnicodeSet::UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_C0], 0

loc_348D:				; CODE XREF: _uspoof_checkUnicodeString_56:loc_3527j
					; _uspoof_checkUnicodeString_56+321j ...
		mov	eax, [ebp+var_C0]
		cmp	eax, [ebp+var_B4]
		jge	loc_35C3
		mov	esi, esp
		mov	eax, [ebp+var_C0]
		push	eax		; int
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_?char32At@UnicodeString@icu_56@@QBEHH@Z ; icu_56::UnicodeString::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_CC], eax
		mov	eax, 0FFFFh
		cmp	eax, [ebp+var_CC]
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		add	ecx, [ebp+var_C0]
		mov	[ebp+var_C0], ecx
		mov	eax, [ebp+var_CC]
		push	eax
		call	_u_charType_56
		add	esp, 4
		movsx	ecx, al
		cmp	ecx, 6
		jz	short loc_352C
		mov	[ebp+var_D8], 0
		movsx	eax, [ebp+var_E1]
		test	eax, eax
		jz	short loc_3527
		mov	esi, esp
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_?clear@UnicodeSet@icu_56@@UAEAAV12@XZ ; icu_56::UnicodeSet::clear(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E1], 0

loc_3527:				; CODE XREF: _uspoof_checkUnicodeString_56+2E9j
		jmp	loc_348D
; ---------------------------------------------------------------------------

loc_352C:				; CODE XREF: _uspoof_checkUnicodeString_56+2D4j
		cmp	[ebp+var_D8], 0
		jnz	short loc_3546
		mov	eax, [ebp+var_CC]
		mov	[ebp+var_D8], eax
		jmp	loc_348D
; ---------------------------------------------------------------------------

loc_3546:				; CODE XREF: _uspoof_checkUnicodeString_56+313j
		movsx	eax, [ebp+var_E1]
		test	eax, eax
		jnz	short loc_3574
		mov	esi, esp
		mov	eax, [ebp+var_D8]
		push	eax		; int
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_?add@UnicodeSet@icu_56@@QAEAAV12@H@Z	; icu_56::UnicodeSet::add(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E1], 1

loc_3574:				; CODE XREF: _uspoof_checkUnicodeString_56+32Fj
		mov	esi, esp
		mov	eax, [ebp+var_CC]
		push	eax		; int
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_?contains@UnicodeSet@icu_56@@UBECH@Z	; icu_56::UnicodeSet::contains(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_35A2
		mov	eax, [ebp+var_18]
		or	eax, 20h
		mov	[ebp+var_18], eax
		jmp	short loc_35C3
; ---------------------------------------------------------------------------

loc_35A2:				; CODE XREF: _uspoof_checkUnicodeString_56+375j
		mov	esi, esp
		mov	eax, [ebp+var_CC]
		push	eax		; int
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_?add@UnicodeSet@icu_56@@QAEAAV12@H@Z	; icu_56::UnicodeSet::add(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_348D
; ---------------------------------------------------------------------------

loc_35C3:				; CODE XREF: _uspoof_checkUnicodeString_56+279j
					; _uspoof_checkUnicodeString_56+380j
		mov	esi, esp
		lea	ecx, [ebp+var_120] ; this
		call	dword ptr ds:__imp_??1UnicodeSet@icu_56@@UAE@XZ	; icu_56::UnicodeSet::~UnicodeSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_35D8:				; CODE XREF: _uspoof_checkUnicodeString_56+237j
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 6
		jz	loc_36D6
		cmp	[ebp+var_24], 0
		jnz	short loc_363B
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_C] ; this
		call	?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::getIdentifierInfo(UErrorCode &)
		mov	[ebp+var_24], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_362B
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	$cleanupAndReturn$71316
; ---------------------------------------------------------------------------

loc_362B:				; CODE XREF: _uspoof_checkUnicodeString_56+3EFj
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_24] ; this
		call	?setIdentifier@IdentifierInfo@icu_56@@QAEAAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::IdentifierInfo::setIdentifier(icu_56::UnicodeString const &,UErrorCode &)

loc_363B:				; CODE XREF: _uspoof_checkUnicodeString_56+3CBj
		mov	ecx, [ebp+var_24] ; this
		call	?getScriptCount@IdentifierInfo@icu_56@@QBEHXZ ;	icu_56::IdentifierInfo::getScriptCount(void)
		mov	[ebp+var_12C], eax
		lea	ecx, [ebp+var_14C] ; this
		call	??0ScriptSet@icu_56@@QAE@XZ ; icu_56::ScriptSet::ScriptSet(void)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_14C]
		push	ecx		; struct icu_56::ScriptSet *
		lea	edx, [ebp+var_A8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_C] ; this
		call	?wholeScriptCheck@SpoofImpl@icu_56@@QBEXABVUnicodeString@2@PAVScriptSet@2@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::wholeScriptCheck(icu_56::UnicodeString const &,icu_56::ScriptSet *,UErrorCode	&)
		lea	ecx, [ebp+var_14C] ; this
		call	?countMembers@ScriptSet@icu_56@@QBEHXZ ; icu_56::ScriptSet::countMembers(void)
		mov	[ebp+var_158], eax
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 4
		jz	short loc_36A5
		cmp	[ebp+var_158], 2
		jl	short loc_36A5
		cmp	[ebp+var_12C], 1
		jnz	short loc_36A5
		mov	eax, [ebp+var_18]
		or	eax, 4
		mov	[ebp+var_18], eax

loc_36A5:				; CODE XREF: _uspoof_checkUnicodeString_56+468j
					; _uspoof_checkUnicodeString_56+471j ...
		mov	eax, [ebp+var_C]
		mov	ecx, [eax+8]
		and	ecx, 2
		jz	short loc_36CB
		cmp	[ebp+var_158], 1
		jl	short loc_36CB
		cmp	[ebp+var_12C], 1
		jle	short loc_36CB
		mov	eax, [ebp+var_18]
		or	eax, 2
		mov	[ebp+var_18], eax

loc_36CB:				; CODE XREF: _uspoof_checkUnicodeString_56+48Ej
					; _uspoof_checkUnicodeString_56+497j ...
		lea	ecx, [ebp+var_14C] ; this
		call	??1ScriptSet@icu_56@@QAE@XZ ; icu_56::ScriptSet::~ScriptSet(void)

loc_36D6:				; CODE XREF: _uspoof_checkUnicodeString_56+3C1j
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

$cleanupAndReturn$71316:		; CODE XREF: _uspoof_checkUnicodeString_56+88j
					; _uspoof_checkUnicodeString_56+1CEj ...
		mov	eax, [ebp+var_24]
		push	eax		; struct icu_56::IdentifierInfo	*
		mov	ecx, [ebp+var_C] ; this
		call	?releaseIdentifierInfo@SpoofImpl@icu_56@@QBEXPAVIdentifierInfo@2@@Z ; icu_56::SpoofImpl::releaseIdentifierInfo(icu_56::IdentifierInfo *)
		cmp	[ebp+arg_8], 0
		jz	short loc_3706
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0

loc_3706:				; CODE XREF: _uspoof_checkUnicodeString_56+4DBj
		mov	eax, [ebp+var_18]

loc_3709:				; CODE XREF: _uspoof_checkUnicodeString_56+43j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN38
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 21Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_checkUnicodeString_56 endp ; sp-analysis failed

; ---------------------------------------------------------------------------
$LN38		dd 3			; DATA XREF: _uspoof_checkUnicodeString_56+4EDo
		dd offset $LN37
$LN37		dd 0FFFFFF58h, 40h	; DATA XREF: .text:0000373Co
		dd offset $LN34		; "nfdText"
		dd 0FFFFFEE0h, 34h
		dd offset $LN35		; "marksSeenSoFar"
		dd 0FFFFFEB4h, 18h
		dd offset $LN36		; "scripts"
$LN36		db 'scripts',0          ; DATA XREF: .text:00003760o
$LN35		db 'marksSeenSoFar',0   ; DATA XREF: .text:00003754o
$LN34		db 'nfdText',0          ; DATA XREF: .text:00003748o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3784h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_getSkeleton_56(struct USpoofChecker *, unsigned int, wchar_t *, int, wchar_t *, int, enum UErrorCode *)
		public _uspoof_getSkeleton_56
_uspoof_getSkeleton_56 proc near

var_160		= byte ptr -160h
var_15C		= dword	ptr -15Ch
var_90		= byte ptr -90h
var_48		= byte ptr -48h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 160h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_160]
		mov	ecx, 58h ; 'X'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_37D8
		xor	eax, eax
		jmp	loc_38C2
; ---------------------------------------------------------------------------

loc_37D8:				; CODE XREF: _uspoof_getSkeleton_56+4Bj
		cmp	[ebp+arg_C], 0FFFFFFFFh
		jl	short loc_37F0
		cmp	[ebp+arg_14], 0
		jl	short loc_37F0
		cmp	[ebp+arg_14], 0
		jnz	short loc_3800
		cmp	[ebp+arg_10], 0
		jz	short loc_3800

loc_37F0:				; CODE XREF: _uspoof_getSkeleton_56+58j
					; _uspoof_getSkeleton_56+5Ej
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_38C2
; ---------------------------------------------------------------------------

loc_3800:				; CODE XREF: _uspoof_getSkeleton_56+64j
					; _uspoof_getSkeleton_56+6Aj
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		cmp	[ebp+arg_C], 0FFFFFFFFh
		setz	dl
		movzx	eax, dl
		push	eax		; signed __int8
		lea	ecx, [ebp+var_48] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_90]
		push	ecx		; struct icu_56::UnicodeString *
		lea	edx, [ebp+var_48]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z ; uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString	const &,icu_56::UnicodeString &,UErrorCode *)
		add	esp, 14h
		mov	esi, esp
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_14]
		push	ecx		; int
		mov	edx, [ebp+arg_10]
		push	edx		; wchar_t *
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_?extract@UnicodeString@icu_56@@QBEHPA_WHAAW4UErrorCode@@@Z ;	icu_56::UnicodeString::extract(wchar_t *,int,UErrorCode	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_15C], eax
		mov	esi, esp
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_48] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_15C]

loc_38C2:				; CODE XREF: _uspoof_getSkeleton_56+4Fj
					; _uspoof_getSkeleton_56+77j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 160h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_getSkeleton_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN9_1		dd 2			; DATA XREF: _uspoof_getSkeleton_56+142o
		dd offset $LN8_1
$LN8_1		dd 0FFFFFFB8h, 40h	; DATA XREF: .text:000038F8o
		dd offset $LN6_5	; "idStr"
		dd 0FFFFFF70h, 40h
		dd offset $LN7_3	; "destStr"
$LN7_3		db 'destStr',0          ; DATA XREF: .text:00003910o
$LN6_5		db 'idStr',0            ; DATA XREF: .text:00003904o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3924h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__cdecl	uspoof_getSkeletonUnicodeString_56(const struct	USpoofChecker *, unsigned int, const struct icu_56::UnicodeString *, struct icu_56::UnicodeString *, enum UErrorCode *)
		public ?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z
?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z proc near
					; CODE XREF: _uspoof_areConfusableUnicodeString_56+192p
					; _uspoof_areConfusableUnicodeString_56+1B1p ...

var_1AC		= dword	ptr -1ACh
var_1A4		= dword	ptr -1A4h
var_D8		= dword	ptr -0D8h
var_CC		= dword	ptr -0CCh
var_C0		= byte ptr -0C0h
var_78		= dword	ptr -78h
var_6C		= byte ptr -6Ch
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1A0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1AC]
		mov	ecx, 68h ; 'h'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3994
		mov	eax, [ebp+arg_C]
		jmp	loc_3B3B
; ---------------------------------------------------------------------------

loc_3994:				; CODE XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+66j
		mov	[ebp+var_24], 0
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_1AC], eax
		cmp	[ebp+var_1AC], 9 ; switch 10 cases
		ja	short $LN3	; jumptable 000039BA default case
		mov	ecx, [ebp+var_1AC]
		movzx	edx, ds:$LN15[ecx]
		jmp	ds:$LN21_0[edx*4] ; switch jump
; ---------------------------------------------------------------------------

$LN7_4:					; CODE XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+96j
					; DATA XREF: .text:$LN21_0o
		mov	[ebp+var_24], 4000000h ; jumptable 000039BA case 0
		jmp	short loc_39F6
; ---------------------------------------------------------------------------

$LN6_6:					; CODE XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+96j
					; DATA XREF: .text:$LN21_0o
		mov	[ebp+var_24], 1000000h ; jumptable 000039BA case 1
		jmp	short loc_39F6
; ---------------------------------------------------------------------------

$LN5_3:					; CODE XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+96j
					; DATA XREF: .text:$LN21_0o
		mov	[ebp+var_24], 8000000h ; jumptable 000039BA case 8
		jmp	short loc_39F6
; ---------------------------------------------------------------------------

$LN4_1:					; CODE XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+96j
					; DATA XREF: .text:$LN21_0o
		mov	[ebp+var_24], 2000000h ; jumptable 000039BA case 9
		jmp	short loc_39F6
; ---------------------------------------------------------------------------

$LN3:					; CODE XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+87j
					; uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+96j
					; DATA XREF: ...
		mov	eax, [ebp+arg_10] ; jumptable 000039BA default case
		mov	dword ptr [eax], 1
		mov	eax, [ebp+arg_C]
		jmp	loc_3B3B
; ---------------------------------------------------------------------------

loc_39F6:				; CODE XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+A4j
					; uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+ADj ...
		mov	esi, esp
		lea	ecx, [ebp+var_6C] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_6C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, ds:_gNfdNormalizer
		mov	edx, [eax]
		mov	ecx, ds:_gNfdNormalizer
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_78], 0
		mov	esi, esp
		lea	ecx, [ebp+var_C0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_6C] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_CC], eax
		mov	[ebp+var_78], 0

loc_3A75:				; CODE XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+1AAj
		mov	eax, [ebp+var_78]
		cmp	eax, [ebp+var_CC]
		jge	short loc_3AD0
		mov	esi, esp
		mov	eax, [ebp+var_78]
		push	eax		; int
		lea	ecx, [ebp+var_6C] ; this
		call	dword ptr ds:__imp_?char32At@UnicodeString@icu_56@@QBEHH@Z ; icu_56::UnicodeString::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_D8], eax
		mov	eax, 0FFFFh
		cmp	eax, [ebp+var_D8]
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		add	ecx, [ebp+var_78]
		mov	[ebp+var_78], ecx
		lea	eax, [ebp+var_C0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_24]
		push	ecx		; int
		mov	edx, [ebp+var_D8]
		push	edx		; int
		mov	ecx, [ebp+var_18] ; this
		call	?confusableLookup@SpoofImpl@icu_56@@QBEHHHAAVUnicodeString@2@@Z	; icu_56::SpoofImpl::confusableLookup(int,int,icu_56::UnicodeString &)
		jmp	short loc_3A75
; ---------------------------------------------------------------------------

loc_3AD0:				; CODE XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+15Aj
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		lea	edx, [ebp+var_C0]
		push	edx
		mov	eax, ds:_gNfdNormalizer
		mov	edx, [eax]
		mov	ecx, ds:_gNfdNormalizer
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_1A4], eax
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_C0] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_6C] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_1A4]

loc_3B3B:				; CODE XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+6Bj
					; uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+CDj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN20_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1ACh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN20_0		dd 2			; DATA XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+21Bo
		dd offset $LN19_0
$LN19_0		dd 0FFFFFF94h, 40h	; DATA XREF: .text:00003B7Co
		dd offset $LN16_0	; "nfdId"
		dd 0FFFFFF40h, 40h
		dd offset $LN17_0	; "skelStr"
$LN17_0		db 'skelStr',0          ; DATA XREF: .text:00003B94o
$LN16_0		db 'nfdId',0            ; DATA XREF: .text:00003B88o
		align 4
$LN21_0		dd offset $LN7_4	; DATA XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+96r
		dd offset $LN6_6	; jump table for switch	statement
		dd offset $LN5_3
		dd offset $LN4_1
		dd offset $LN3
$LN15		db	0,     1,     4,     4
					; DATA XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+8Fr
		db	4,     4,     4,     4 ; indirect table	for switch statement
		db	2,     3
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3BC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00003C1Co
		mov	esi, esp
		lea	ecx, [ebp-6Ch]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00003C24o
		mov	esi, esp
		lea	ecx, [ebp-0C0h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z proc near
					; DATA XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1B0h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3C18h
__unwindtable$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003C30o
		dd offset __unwindfunclet$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z$1
__ehfuncinfo$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_getSkeletonUTF8_56(struct USpoofChecker *,	unsigned int, char *Str, int, int, int,	enum UErrorCode	*)
		public _uspoof_getSkeletonUTF8_56
_uspoof_getSkeletonUTF8_56 proc	near

var_18C		= dword	ptr -18Ch
var_184		= byte ptr -184h
var_174		= dword	ptr -174h
var_168		= dword	ptr -168h
var_9C		= dword	ptr -9Ch
var_90		= byte ptr -90h
var_48		= byte ptr -48h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Str		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 18Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_18C]
		mov	ecx, 63h ; 'c'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker const *,UErrorCode	&)
		add	esp, 8
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3CA0
		xor	eax, eax
		jmp	loc_3E31
; ---------------------------------------------------------------------------

loc_3CA0:				; CODE XREF: _uspoof_getSkeletonUTF8_56+4Bj
		cmp	[ebp+arg_C], 0FFFFFFFFh
		jl	short loc_3CB8
		cmp	[ebp+arg_14], 0
		jl	short loc_3CB8
		cmp	[ebp+arg_14], 0
		jnz	short loc_3CC8
		cmp	[ebp+arg_10], 0
		jz	short loc_3CC8

loc_3CB8:				; CODE XREF: _uspoof_getSkeletonUTF8_56+58j
					; _uspoof_getSkeletonUTF8_56+5Ej
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_3E31
; ---------------------------------------------------------------------------

loc_3CC8:				; CODE XREF: _uspoof_getSkeletonUTF8_56+64j
					; _uspoof_getSkeletonUTF8_56+6Aj
		cmp	[ebp+arg_C], 0
		jl	short loc_3CD9
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_18C], eax
		jmp	short loc_3CEB
; ---------------------------------------------------------------------------

loc_3CD9:				; CODE XREF: _uspoof_getSkeletonUTF8_56+80j
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_18C], eax

loc_3CEB:				; CODE XREF: _uspoof_getSkeletonUTF8_56+8Bj
		mov	esi, esp
		mov	edx, [ebp+var_18C]
		push	edx		; int
		mov	eax, [ebp+Str]
		push	eax		; char *
		lea	ecx, [ebp+var_184] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBDH@Z ; icu_56::StringPiece::StringPiece(char const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		lea	ecx, [ebp+var_48]
		push	ecx
		call	dword ptr ds:__imp_?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z ; icu_56::UnicodeString::fromUTF8(icu_56::StringPiece const &)
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_90]
		push	ecx		; struct icu_56::UnicodeString *
		lea	edx, [ebp+var_48]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z ; uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString	const &,icu_56::UnicodeString &,UErrorCode *)
		add	esp, 14h
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3DA7
		mov	[ebp+var_174], 0
		mov	esi, esp
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_48] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_174]
		jmp	loc_3E31
; ---------------------------------------------------------------------------

loc_3DA7:				; CODE XREF: _uspoof_getSkeletonUTF8_56+11Dj
		mov	[ebp+var_9C], 0
		mov	eax, [ebp+arg_18]
		push	eax
		mov	esi, esp
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	esi, esp
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ;	icu_56::UnicodeString::getBuffer(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		lea	ecx, [ebp+var_9C]
		push	ecx
		mov	edx, [ebp+arg_14]
		push	edx
		mov	eax, [ebp+arg_10]
		push	eax
		call	_u_strToUTF8_56
		add	esp, 18h
		mov	eax, [ebp+var_9C]
		mov	[ebp+var_168], eax
		mov	esi, esp
		lea	ecx, [ebp+var_90] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_48] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_168]

loc_3E31:				; CODE XREF: _uspoof_getSkeletonUTF8_56+4Fj
					; _uspoof_getSkeletonUTF8_56+77j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_getSkeletonUTF8_56 endp

; ---------------------------------------------------------------------------
$LN13_1		dd 3			; DATA XREF: _uspoof_getSkeletonUTF8_56+1E9o
		dd offset $LN12_0
$LN12_0		dd 0FFFFFFB8h, 40h	; DATA XREF: .text:00003E64o
		dd offset $LN9_2	; "srcStr"
		dd 0FFFFFF70h, 40h
		dd offset $LN10_0	; "destStr"
		dd 0FFFFFF64h, 4
		dd offset $LN11_0	; "lengthInUTF8"
$LN11_0		db 'lengthInUTF8',0     ; DATA XREF: .text:00003E88o
$LN10_0		db 'destStr',0          ; DATA XREF: .text:00003E7Co
$LN9_2		db 'srcStr',0           ; DATA XREF: .text:00003E70o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3EA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uspoof_serialize_56(struct USpoofChecker *, void *Dst, int, enum UErrorCode *)
		public _uspoof_serialize_56
_uspoof_serialize_56 proc near

var_D8		= byte ptr -0D8h
Size		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Dst		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct USpoofChecker *
		call	?validateThis@SpoofImpl@icu_56@@SAPAV12@PAUUSpoofChecker@@AAW4UErrorCode@@@Z ; icu_56::SpoofImpl::validateThis(USpoofChecker *,UErrorCode &)
		add	esp, 8
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_3F1D
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	short loc_3F19
		mov	eax, ds:?__LINE__Var@?1??uspoof_serialize_56@@9@4JA ; long `uspoof_serialize_56'::`2'::__LINE__Var
		add	eax, 3
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FG@NOAAMNGO@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_1CG@GFHCBPDH@?$AAU?$AA_?$AAF?$AAA?$AAI?$AAL?$AAU?$AAR?$AAE?$AA?$CI?$AA?$CK?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$CJ?$AA?$AA@ ; "U_FAILURE(*status)"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3F19:				; CODE XREF: _uspoof_serialize_56+4Aj
		xor	eax, eax
		jmp	short loc_3F70
; ---------------------------------------------------------------------------

loc_3F1D:				; CODE XREF: _uspoof_serialize_56+35j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ecx]
		mov	eax, [edx+8]
		mov	[ebp+Size], eax
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+Size]
		jge	short loc_3F41
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0Fh
		mov	eax, [ebp+Size]
		jmp	short loc_3F70
; ---------------------------------------------------------------------------

loc_3F41:				; CODE XREF: _uspoof_serialize_56+89j
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ecx]
		push	edx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	eax, [ebp+Size]
		push	eax		; Size
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	eax, [edx]
		push	eax		; Src
		mov	ecx, [ebp+Dst]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Size]

loc_3F70:				; CODE XREF: _uspoof_serialize_56+73j
					; _uspoof_serialize_56+97j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_serialize_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3F84h
		public ??_C@_1CG@GFHCBPDH@?$AAU?$AA_?$AAF?$AAA?$AAI?$AAL?$AAU?$AAR?$AAE?$AA?$CI?$AA?$CK?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$CJ?$AA?$AA@
; wchar_t `string'
??_C@_1CG@GFHCBPDH@?$AAU?$AA_?$AAF?$AAA?$AAI?$AAL?$AAU?$AAR?$AAE?$AA?$CI?$AA?$CK?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$CJ?$AA?$AA@:
					; DATA XREF: _uspoof_serialize_56+5Co
		unicode	0, <U_FAILURE(*status)>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 3FACh
		public ??_C@_1FG@NOAAMNGO@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@
; wchar_t `string'
??_C@_1FG@NOAAMNGO@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@:
					; DATA XREF: _uspoof_serialize_56+57o
		unicode	0, <d:\mozilla\intl\icu\source\i18n\uspoof.cpp>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4004h
		public ?__LINE__Var@?1??uspoof_serialize_56@@9@4JA
; long `uspoof_serialize_56'::`2'::__LINE__Var
?__LINE__Var@?1??uspoof_serialize_56@@9@4JA dd offset ??_C@_0BACK@CDOMAMMN@?$FL?2u0030?9?2u0039?2u0041?9?2u005A?2u005@+2F6h
					; DATA XREF: _uspoof_serialize_56+4Cr
_data		ends			; "57\\u0960-\\u0963\\u0966-\\u096F\\u0971"...

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4008h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uspoof_getInclusionSet_56
_uspoof_getInclusionSet_56 proc	near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi		; enum UErrorCode *
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax		; void (__cdecl	*)(enum	UErrorCode *)
		push	offset ?initializeStatics@@YAXAAW4UErrorCode@@@Z ; struct icu_56::UInitOnce *
		push	offset _gSpoofInitStaticsOnce ;	this
		call	?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z ; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)
		add	esp, 0Ch
		mov	esi, esp
		mov	ecx, ds:_gInclusionSet ; this
		call	dword ptr ds:__imp_?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ ; icu_56::UnicodeSet::toUSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_getInclusionSet_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4068h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uspoof_getRecommendedSet_56
_uspoof_getRecommendedSet_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi		; enum UErrorCode *
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax		; void (__cdecl	*)(enum	UErrorCode *)
		push	offset ?initializeStatics@@YAXAAW4UErrorCode@@@Z ; struct icu_56::UInitOnce *
		push	offset _gSpoofInitStaticsOnce ;	this
		call	?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z ; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)
		add	esp, 0Ch
		mov	esi, esp
		mov	ecx, ds:_gRecommendedSet ; this
		call	dword ptr ds:__imp_?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ ; icu_56::UnicodeSet::toUSet(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_getRecommendedSet_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 40C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uspoof_getInclusionUnicodeSet_56
_uspoof_getInclusionUnicodeSet_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi		; enum UErrorCode *
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax		; void (__cdecl	*)(enum	UErrorCode *)
		push	offset ?initializeStatics@@YAXAAW4UErrorCode@@@Z ; struct icu_56::UInitOnce *
		push	offset _gSpoofInitStaticsOnce ;	this
		call	?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z ; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)
		add	esp, 0Ch
		mov	eax, ds:_gInclusionSet
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_getInclusionUnicodeSet_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4118h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uspoof_getRecommendedUnicodeSet_56
_uspoof_getRecommendedUnicodeSet_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi		; enum UErrorCode *
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax		; void (__cdecl	*)(enum	UErrorCode *)
		push	offset ?initializeStatics@@YAXAAW4UErrorCode@@@Z ; struct icu_56::UInitOnce *
		push	offset _gSpoofInitStaticsOnce ;	this
		call	?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXAAW4UErrorCode@@@Z1@Z ; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)
		add	esp, 0Ch
		mov	eax, ds:_gRecommendedSet
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uspoof_getRecommendedUnicodeSet_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4168h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; [thunk]:public: virtual void * __thiscall icu_56::UnicodeSet::`vector	deleting destructor'`adjustor{4}' (unsigned int)
		public ??_EUnicodeSet@icu_56@@W3AEPAXI@Z
??_EUnicodeSet@icu_56@@W3AEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeMatcher'}o
		sub	ecx, 4
		jmp	??_EUnicodeSet@icu_56@@UAEPAXI@Z ; icu_56::UnicodeSet::`vector deleting	destructor'(uint)
??_EUnicodeSet@icu_56@@W3AEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn __RTC_CheckEsp:near ; CODE XREF: _uspoof_internalInitStatics_56+3Fp
					; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode	&),UErrorCode &)+5Ap ...
; void __cdecl icu_56::umtx_initImplPostInit(icu_56 *__hidden this, struct icu_56::UInitOnce *)
		extrn __imp_?umtx_initImplPostInit@icu_56@@YAXAAUUInitOnce@1@@Z:near
					; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+8Ap
					; DATA XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+8Ar
; signed __int8	__cdecl	icu_56::umtx_initImplPreInit(icu_56 *__hidden this, struct icu_56::UInitOnce *)
		extrn __imp_?umtx_initImplPreInit@icu_56@@YACAAUUInitOnce@1@@Z:near
					; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+4Fp
					; DATA XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(UErrorCode &),UErrorCode &)+4Fr
; LONG __stdcall InterlockedCompareExchange(volatile LONG *Destination,	LONG Exchange, LONG Comperand)
		extrn __imp__InterlockedCompareExchange@12:near
					; CODE XREF: icu_56::umtx_loadAcquire(long volatile &)+28p
					; DATA XREF: icu_56::umtx_loadAcquire(long volatile &)+28r
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: __unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$0+9p
					; __unwindfunclet$?initializeStatics@@YAXAAW4UErrorCode@@@Z$2+9p ...
		extrn _ucln_i18n_registerCleanup_56:near
					; CODE XREF: initializeStatics(UErrorCode &)+2B6p
					; initializeDefaultData(UErrorCode &)+36p
; const	struct icu_56::Normalizer2 *__cdecl static icu_56::Normalizer2::getNFDInstance(enum UErrorCode *)
		extrn __imp_?getNFDInstance@Normalizer2@icu_56@@SAPBV12@AAW4UErrorCode@@@Z:near
					; CODE XREF: initializeStatics(UErrorCode &)+29Ap
					; DATA XREF: initializeStatics(UErrorCode &)+29Ar
; struct icu_56::UnicodeFunctor	*__thiscall icu_56::UnicodeSet::freeze(icu_56::UnicodeSet *__hidden this)
		extrn __imp_?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ:near
					; CODE XREF: initializeStatics(UErrorCode &)+162p
					; initializeStatics(UErrorCode &)+287p	...
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: initializeStatics(UErrorCode &)+14Dp
					; initializeStatics(UErrorCode &)+272p	...
; _DWORD __thiscall icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet *__hidden	this, const struct icu_56::UnicodeString *, enum UErrorCode *)
		extrn __imp_??0UnicodeSet@icu_56@@QAE@ABVUnicodeString@1@AAW4UErrorCode@@@Z:near
					; CODE XREF: initializeStatics(UErrorCode &)+D0p
					; initializeStatics(UErrorCode &)+1F5p
					; DATA XREF: ...
; _DWORD __thiscall __high icu_56::UnicodeString::UnicodeString(const char *, int, enum	icu_56::UnicodeString::EInvariant)
		extrn __imp_??0UnicodeString@icu_56@@QAE@PBDHW4EInvariant@01@@Z:near
					; CODE XREF: initializeStatics(UErrorCode &)+91p
					; initializeStatics(UErrorCode &)+1B6p
					; DATA XREF: ...
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn __imp_??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: initializeStatics(UErrorCode &)+4Ep
					; initializeStatics(UErrorCode &)+173p	...
		extrn ___security_cookie:near
					; DATA XREF: initializeStatics(UErrorCode &)+2Cr
					; _uspoof_check_56+1Er	...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$?initializeStatics@@YAXAAW4UErrorCode@@@Z+23j
					; __ehhandler$?uspoof_getSkeletonUnicodeString_56@@YAAAVUnicodeString@icu_56@@PBUUSpoofChecker@@IABV12@AAV12@PAW4UErrorCode@@@Z+23j
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: initializeStatics(UErrorCode &)+2D1p
					; __ehhandler$?initializeStatics@@YAXAAW4UErrorCode@@@Z+Fp ...
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UnicodeSet `RTTI Type Descriptor'o
					; .data:icu_56::UnicodeFilter `RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UnicodeSet::`scalar	deleting destructor'(unsigned int)
		extrn ??_GUnicodeSet@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::UnicodeSet::`vector	deleting destructor'(unsigned int)
		extrn ??_EUnicodeSet@icu_56@@UAEPAXI@Z:near ; weak
					; CODE XREF: [thunk]:icu_56::UnicodeSet::`vector deleting destructor'`adjustor{4}' (uint)+3j
					; DATA XREF: .rdata:const icu_56::UnicodeSet::`local vftable'{for `icu_56::UnicodeFunctor'}o
; public: virtual void * __thiscall icu_56::UnicodeSet::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeSet@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001804o
; public: virtual class	icu_56::UnicodeFunctor * __thiscall icu_56::UnicodeSet::clone(void)const
		extrn ?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ:near
					; DATA XREF: .rdata:00001808o
; public: virtual class	icu_56::UnicodeMatcher * __thiscall icu_56::UnicodeFilter::toMatcher(void)const
		extrn ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ:near
					; DATA XREF: .rdata:0000180Co
; public: virtual class	icu_56::UnicodeReplacer	* __thiscall icu_56::UnicodeFunctor::toReplacer(void)const
		extrn ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ:near
					; DATA XREF: .rdata:00001810o
; public: virtual void __thiscall icu_56::UnicodeFilter::setData(class icu_56::TransliterationRuleData const *)
		extrn ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z:near
					; DATA XREF: .rdata:00001814o
; public: virtual signed char __thiscall icu_56::UnicodeSet::contains(int)const
		extrn ?contains@UnicodeSet@icu_56@@UBECH@Z:near
					; DATA XREF: .rdata:00001818o
; public: virtual signed char __thiscall icu_56::UnicodeSet::operator==(class icu_56::UnicodeSet const &)const
		extrn ??8UnicodeSet@icu_56@@UBECABV01@@Z:near ;	DATA XREF: .rdata:0000181Co
; public: virtual int __thiscall icu_56::UnicodeSet::hashCode(void)const
		extrn ?hashCode@UnicodeSet@icu_56@@UBEHXZ:near ; DATA XREF: .rdata:00001820o
; public: virtual int __thiscall icu_56::UnicodeSet::size(void)const
		extrn ?size@UnicodeSet@icu_56@@UBEHXZ:near ; DATA XREF:	.rdata:00001824o
; public: virtual signed char __thiscall icu_56::UnicodeSet::isEmpty(void)const
		extrn ?isEmpty@UnicodeSet@icu_56@@UBECXZ:near ;	DATA XREF: .rdata:00001828o
; public: virtual signed char __thiscall icu_56::UnicodeSet::contains(int, int)const
		extrn ?contains@UnicodeSet@icu_56@@UBECHH@Z:near
					; DATA XREF: .rdata:0000182Co
; public: virtual signed char __thiscall icu_56::UnicodeSet::containsAll(class icu_56::UnicodeSet const	&)const
		extrn ?containsAll@UnicodeSet@icu_56@@UBECABV12@@Z:near
					; DATA XREF: .rdata:00001830o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::add(int, int)
		extrn ?add@UnicodeSet@icu_56@@UAEAAV12@HH@Z:near
					; DATA XREF: .rdata:00001834o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::addAll(class icu_56::UnicodeSet const &)
		extrn ?addAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z:near
					; DATA XREF: .rdata:00001838o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::retainAll(class icu_56::UnicodeSet const &)
		extrn ?retainAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z:near
					; DATA XREF: .rdata:0000183Co
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::complementAll(class	icu_56::UnicodeSet const &)
		extrn ?complementAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z:near
					; DATA XREF: .rdata:00001840o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::removeAll(class icu_56::UnicodeSet const &)
		extrn ?removeAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z:near
					; DATA XREF: .rdata:00001844o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::retain(int,	int)
		extrn ?retain@UnicodeSet@icu_56@@UAEAAV12@HH@Z:near
					; DATA XREF: .rdata:00001848o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::remove(int,	int)
		extrn ?remove@UnicodeSet@icu_56@@UAEAAV12@HH@Z:near
					; DATA XREF: .rdata:0000184Co
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::complement(int, int)
		extrn ?complement@UnicodeSet@icu_56@@UAEAAV12@HH@Z:near
					; DATA XREF: .rdata:00001850o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::complement(void)
		extrn ?complement@UnicodeSet@icu_56@@UAEAAV12@XZ:near
					; DATA XREF: .rdata:00001854o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::clear(void)
		extrn ?clear@UnicodeSet@icu_56@@UAEAAV12@XZ:near
					; DATA XREF: .rdata:00001858o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::removeAllStrings(void)
		extrn ?removeAllStrings@UnicodeSet@icu_56@@UAEAAV12@XZ:near
					; DATA XREF: .rdata:0000185Co
; public: virtual int __thiscall icu_56::UnicodeSet::getRangeCount(void)const
		extrn ?getRangeCount@UnicodeSet@icu_56@@UBEHXZ:near
					; DATA XREF: .rdata:00001860o
; public: virtual int __thiscall icu_56::UnicodeSet::getRangeStart(int)const
		extrn ?getRangeStart@UnicodeSet@icu_56@@UBEHH@Z:near
					; DATA XREF: .rdata:00001864o
; public: virtual int __thiscall icu_56::UnicodeSet::getRangeEnd(int)const
		extrn ?getRangeEnd@UnicodeSet@icu_56@@UBEHH@Z:near
					; DATA XREF: .rdata:00001868o
; public: virtual class	icu_56::UnicodeSet & __thiscall	icu_56::UnicodeSet::compact(void)
		extrn ?compact@UnicodeSet@icu_56@@UAEAAV12@XZ:near
					; DATA XREF: .rdata:0000186Co
; public: virtual enum	icu_56::UMatchDegree __thiscall	icu_56::UnicodeSet::matches(class icu_56::Replaceable const &, int &, int, signed char)
		extrn ?matches@UnicodeSet@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z:near
					; DATA XREF: .rdata:000017ECo
; public: virtual class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeSet::toPattern(class icu_56::UnicodeString &,	signed char)const
		extrn ?toPattern@UnicodeSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z:near
					; DATA XREF: .rdata:000017F0o
; private: virtual signed char __thiscall icu_56::UnicodeSet::matchesIndexValue(unsigned char)const
		extrn ?matchesIndexValue@UnicodeSet@icu_56@@EBECE@Z:near
					; DATA XREF: .rdata:000017F4o
; public: virtual void __thiscall icu_56::UnicodeSet::addMatchSetTo(class icu_56::UnicodeSet &)const
		extrn ?addMatchSetTo@UnicodeSet@icu_56@@UBEXAAV12@@Z:near
					; DATA XREF: .rdata:000017F8o
; void __thiscall icu_56::SpoofData::removeReference(icu_56::SpoofData *__hidden this)
		extrn ?removeReference@SpoofData@icu_56@@QAEXXZ:near
					; CODE XREF: uspoof_cleanup(void)+E9p
; _DWORD __thiscall icu_56::UnicodeSet::~UnicodeSet(icu_56::UnicodeSet *__hidden this)
		extrn __imp_??1UnicodeSet@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeSet::`scalar deleting destructor'(uint)+28p
					; _uspoof_checkUnicodeString_56+3ABp
					; DATA XREF: ...
; struct icu_56::SpoofData *__thiscall icu_56::SpoofData::addReference(icu_56::SpoofData *__hidden this)
		extrn ?addReference@SpoofData@icu_56@@QAEPAV12@XZ:near
					; CODE XREF: _uspoof_open_56+D2p
; _DWORD __thiscall icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl *__hidden this, struct icu_56::SpoofData *, enum UErrorCode *)
		extrn ??0SpoofImpl@icu_56@@QAE@PAVSpoofData@1@AAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_open_56+9Ap
					; _uspoof_openFromSerialized_56+E2p
; struct icu_56::SpoofData *__cdecl static icu_56::SpoofData::getDefault(enum UErrorCode *)
		extrn ?getDefault@SpoofData@icu_56@@SAPAV12@AAW4UErrorCode@@@Z:near
					; CODE XREF: initializeDefaultData(UErrorCode &)+22p
; _DWORD __thiscall icu_56::SpoofData::SpoofData(icu_56::SpoofData *__hidden this, const void *, int, enum UErrorCode *)
		extrn ??0SpoofData@icu_56@@QAE@PBXHAAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_openFromSerialized_56+85p
; _DWORD __thiscall icu_56::SpoofData::~SpoofData(icu_56::SpoofData *__hidden this)
		extrn ??1SpoofData@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::SpoofData::`scalar	deleting destructor'(uint)+26p
; _DWORD __thiscall icu_56::SpoofImpl::SpoofImpl(icu_56::SpoofImpl *__hidden this, const struct	icu_56::SpoofImpl *, enum UErrorCode *)
		extrn ??0SpoofImpl@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_clone_56+6Fp
; const	struct icu_56::SpoofImpl *__cdecl static icu_56::SpoofImpl::validateThis(const struct USpoofChecker *, enum UErrorCode *)
		extrn ?validateThis@SpoofImpl@icu_56@@SAPBV12@PBUUSpoofChecker@@AAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_clone_56+26p
					; _uspoof_getChecks_56+26p ...
; struct icu_56::SpoofImpl *__cdecl static icu_56::SpoofImpl::validateThis(struct USpoofChecker	*, enum	UErrorCode *)
		extrn ?validateThis@SpoofImpl@icu_56@@SAPAV12@PAUUSpoofChecker@@AAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_close_56+2Dp
					; _uspoof_setChecks_56+26p ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near ; CODE XREF: _uspoof_close_56+8Fp
					; _uspoof_setRestrictionLevel_56+51p ...
; void __thiscall icu_56::SpoofImpl::setAllowedLocales(icu_56::SpoofImpl *__hidden this, const char *, enum UErrorCode *)
		extrn ?setAllowedLocales@SpoofImpl@icu_56@@QAEXPBDAAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_setAllowedLocales_56+44p
; const	char *__thiscall icu_56::SpoofImpl::getAllowedLocales(icu_56::SpoofImpl	*__hidden this,	enum UErrorCode	*)
		extrn ?getAllowedLocales@SpoofImpl@icu_56@@QAEPBDAAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_getAllowedLocales_56+42p
; const	struct USet *__thiscall	icu_56::UnicodeSet::toUSet(icu_56::UnicodeSet *__hidden	this)
		extrn __imp_?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ:near
					; CODE XREF: _uspoof_getAllowedChars_56+36p
					; DATA XREF: _uspoof_getAllowedChars_56+36r
; const	struct icu_56::UnicodeSet *__cdecl static icu_56::UnicodeSet::fromUSet(const struct USet *)
		extrn __imp_?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z:near
					; CODE XREF: _uspoof_setAllowedChars_56+24p
					; DATA XREF: _uspoof_setAllowedChars_56+24r
; signed __int8	__thiscall icu_56::UnicodeSet::isBogus(icu_56::UnicodeSet *__hidden this)
		extrn __imp_?isBogus@UnicodeSet@icu_56@@QBECXZ:near
					; CODE XREF: _uspoof_setAllowedUnicodeSet_56+41p
					; _uspoof_setAllowedUnicodeSet_56+87p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, signed __int8, const wchar_t *, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z:near
					; CODE XREF: _uspoof_check_56+70p
					; _uspoof_areConfusable_56+88p	...
; struct icu_56::UnicodeString __cdecl __high static icu_56::UnicodeString::fromUTF8(const struct icu_56::StringPiece *)
		extrn __imp_?fromUTF8@UnicodeString@icu_56@@SA?AV12@ABVStringPiece@2@@Z:near
					; CODE XREF: _uspoof_checkUTF8_56+8Ep
					; _uspoof_areConfusableUTF8_56+BAp ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const char *, int)
		extrn __imp_??0StringPiece@icu_56@@QAE@PBDH@Z:near
					; CODE XREF: _uspoof_checkUTF8_56+7Ap
					; _uspoof_areConfusableUTF8_56+A6p ...
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: _uspoof_checkUTF8_56+59p
					; _uspoof_areConfusableUTF8_56+85p ...
; __declspec(dllimport)	public:	signed char __thiscall icu_56::UnicodeString::operator==(class icu_56::UnicodeString const &)const
		extrn __imp_??8UnicodeString@icu_56@@QBECABV01@@Z:near
					; CODE XREF: _uspoof_areConfusableUnicodeString_56+1C8p
					; _uspoof_areConfusableUnicodeString_56+2ECp
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		extrn __imp_??0UnicodeString@icu_56@@QAE@XZ:near
					; CODE XREF: _uspoof_areConfusableUnicodeString_56+138p
					; _uspoof_areConfusableUnicodeString_56+14Dp ...
; void __thiscall icu_56::SpoofImpl::releaseIdentifierInfo(icu_56::SpoofImpl *__hidden this, struct icu_56::IdentifierInfo *)
		extrn ?releaseIdentifierInfo@SpoofImpl@icu_56@@QBEXPAVIdentifierInfo@2@@Z:near
					; CODE XREF: _uspoof_areConfusableUnicodeString_56+115p
					; _uspoof_checkUnicodeString_56+4D2p
; int __thiscall icu_56::ScriptSet::nextSetBit(icu_56::ScriptSet *__hidden this, int)
		extrn ?nextSetBit@ScriptSet@icu_56@@QBEHH@Z:near
					; CODE XREF: _uspoof_areConfusableUnicodeString_56+D7p
					; _uspoof_areConfusableUnicodeString_56+106p
; const	struct icu_56::ScriptSet *__thiscall icu_56::IdentifierInfo::getScripts(icu_56::IdentifierInfo *__hidden this)
		extrn ?getScripts@IdentifierInfo@icu_56@@QBEPBVScriptSet@2@XZ:near
					; CODE XREF: _uspoof_areConfusableUnicodeString_56+D0p
					; _uspoof_areConfusableUnicodeString_56+FFp
; int __thiscall icu_56::IdentifierInfo::getScriptCount(icu_56::IdentifierInfo *__hidden this)
		extrn ?getScriptCount@IdentifierInfo@icu_56@@QBEHXZ:near
					; CODE XREF: _uspoof_areConfusableUnicodeString_56+C3p
					; _uspoof_areConfusableUnicodeString_56+F2p ...
; struct icu_56::IdentifierInfo	*__thiscall icu_56::IdentifierInfo::setIdentifier(icu_56::IdentifierInfo *__hidden this, const struct icu_56::UnicodeString *, enum UErrorCode *)
		extrn ?setIdentifier@IdentifierInfo@icu_56@@QAEAAV12@ABVUnicodeString@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_areConfusableUnicodeString_56+BBp
					; _uspoof_areConfusableUnicodeString_56+EAp ...
; struct icu_56::IdentifierInfo	*__thiscall icu_56::SpoofImpl::getIdentifierInfo(icu_56::SpoofImpl *__hidden this, enum	UErrorCode *)
		extrn ?getIdentifierInfo@SpoofImpl@icu_56@@QBEPAVIdentifierInfo@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_areConfusableUnicodeString_56+8Cp
					; _uspoof_checkUnicodeString_56+6Bp ...
; _DWORD __thiscall icu_56::ScriptSet::~ScriptSet(icu_56::ScriptSet *__hidden this)
		extrn ??1ScriptSet@icu_56@@QAE@XZ:near
					; CODE XREF: _uspoof_checkUnicodeString_56+4B1p
; int __thiscall icu_56::ScriptSet::countMembers(icu_56::ScriptSet *__hidden this)
		extrn ?countMembers@ScriptSet@icu_56@@QBEHXZ:near
					; CODE XREF: _uspoof_checkUnicodeString_56+454p
; void __thiscall icu_56::SpoofImpl::wholeScriptCheck(icu_56::SpoofImpl	*__hidden this,	const struct icu_56::UnicodeString *, struct icu_56::ScriptSet *, enum UErrorCode *)
		extrn ?wholeScriptCheck@SpoofImpl@icu_56@@QBEXABVUnicodeString@2@PAVScriptSet@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_checkUnicodeString_56+449p
; _DWORD __thiscall icu_56::ScriptSet::ScriptSet(icu_56::ScriptSet *__hidden this)
		extrn ??0ScriptSet@icu_56@@QAE@XZ:near
					; CODE XREF: _uspoof_checkUnicodeString_56+42Fp
; signed __int8	__thiscall icu_56::UnicodeSet::contains(icu_56::UnicodeSet *__hidden this, int)
		extrn __imp_?contains@UnicodeSet@icu_56@@UBECH@Z:near
					; CODE XREF: _uspoof_checkUnicodeString_56+363p
					; DATA XREF: _uspoof_checkUnicodeString_56+363r
; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::add(icu_56::UnicodeSet *__hidden this, int)
		extrn __imp_?add@UnicodeSet@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: _uspoof_checkUnicodeString_56+340p
					; _uspoof_checkUnicodeString_56+391p
					; DATA XREF: ...
; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::clear(icu_56::UnicodeSet *__hidden this)
		extrn __imp_?clear@UnicodeSet@icu_56@@UAEAAV12@XZ:near
					; CODE XREF: _uspoof_checkUnicodeString_56+2F3p
					; DATA XREF: _uspoof_checkUnicodeString_56+2F3r
		extrn _u_charType_56:near ; CODE XREF: _uspoof_checkUnicodeString_56+2C6p
; _DWORD __thiscall icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet *__hidden	this)
		extrn __imp_??0UnicodeSet@icu_56@@QAE@XZ:near
					; CODE XREF: _uspoof_checkUnicodeString_56+256p
					; DATA XREF: _uspoof_checkUnicodeString_56+256r
; int __thiscall icu_56::UnicodeString::char32At(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?char32At@UnicodeString@icu_56@@QBEHH@Z:near
					; CODE XREF: _uspoof_checkUnicodeString_56+16Cp
					; _uspoof_checkUnicodeString_56+28Ep ...
; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		extrn __imp_?length@UnicodeString@icu_56@@QBEHXZ:near
					; CODE XREF: _uspoof_checkUnicodeString_56+144p
					; _uspoof_checkUnicodeString_56+21Bp ...
; const	struct icu_56::UnicodeSet *__thiscall icu_56::IdentifierInfo::getNumerics(icu_56::IdentifierInfo *__hidden this)
		extrn ?getNumerics@IdentifierInfo@icu_56@@QBEPBVUnicodeSet@2@XZ:near
					; CODE XREF: _uspoof_checkUnicodeString_56+102p
; enum URestrictionLevel __thiscall __high icu_56::IdentifierInfo::getRestrictionLevel(enum UErrorCode *)
		extrn ?getRestrictionLevel@IdentifierInfo@icu_56@@QBE?AW4URestrictionLevel@@AAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_checkUnicodeString_56+BEp
; struct icu_56::IdentifierInfo	*__thiscall icu_56::IdentifierInfo::setIdentifierProfile(icu_56::IdentifierInfo	*__hidden this,	const struct icu_56::UnicodeSet	*)
		extrn ?setIdentifierProfile@IdentifierInfo@icu_56@@QAEAAV12@ABVUnicodeSet@2@@Z:near
					; CODE XREF: _uspoof_checkUnicodeString_56+A7p
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, wchar_t *, int, enum UErrorCode *)
		extrn __imp_?extract@UnicodeString@icu_56@@QBEHPA_WHAAW4UErrorCode@@@Z:near
					; CODE XREF: _uspoof_getSkeleton_56+E9p
					; DATA XREF: _uspoof_getSkeleton_56+E9r
; int __thiscall icu_56::SpoofImpl::confusableLookup(icu_56::SpoofImpl *__hidden this, int, int, struct	icu_56::UnicodeString *)
		extrn ?confusableLookup@SpoofImpl@icu_56@@QBEHHHAAVUnicodeString@2@@Z:near
					; CODE XREF: uspoof_getSkeletonUnicodeString_56(USpoofChecker const *,uint,icu_56::UnicodeString const &,icu_56::UnicodeString &,UErrorCode *)+1A5p
		extrn _u_strToUTF8_56:near ; CODE XREF:	_uspoof_getSkeletonUTF8_56+1A4p
; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		extrn __imp_?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ:near
					; CODE XREF: _uspoof_getSkeletonUTF8_56+187p
					; DATA XREF: _uspoof_getSkeletonUTF8_56+187r
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _uspoof_serialize_56+BDp
		extrn _uprv_checkValidMemory:near ; CODE XREF: _uspoof_serialize_56+A4p
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near ; CODE XREF:	_uspoof_serialize_56+61p
					; DATA XREF: _uspoof_serialize_56+61r
; struct USet *__thiscall icu_56::UnicodeSet::toUSet(icu_56::UnicodeSet	*__hidden this)
		extrn __imp_?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ:near
					; CODE XREF: _uspoof_getInclusionSet_56+3Cp
					; _uspoof_getRecommendedSet_56+3Cp
					; DATA XREF: ...


		end
