;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	C609747A4DBAF368CD6CB5DA43D3B373
; Input	CRC32 :	E9DBA075

; File Name   :	D:\compspace\objfiles\firefox\i18n\usearch.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5 ; DATA XREF: .rdata:`string'o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_800
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_4000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; icu_56::Normalizer2Impl *g_nfcImpl
_g_nfcImpl	dd ?			; DATA XREF: initializeFCD(UErrorCode *)+1Er
					; initializeFCD(UErrorCode *)+3Dw ...
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_FF:					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 134h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 138h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 170h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_open_56(int, int,	int, int, int, int, enum UErrorCode *)
		public _usearch_open_56
_usearch_open_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1AA
		xor	eax, eax
		jmp	loc_237
; ---------------------------------------------------------------------------

loc_1AA:				; CODE XREF: _usearch_open_56+31j
		cmp	[ebp+arg_10], 0
		jz	short loc_22C
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		call	_ucol_open_56
		add	esp, 8

loc_1C0:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_14]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; int
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	_usearch_openFromCollator_56
		add	esp, 1Ch
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_205
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4

loc_1FE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		movsx	edx, al
		test	edx, edx
		jz	short loc_21D

loc_205:				; CODE XREF: _usearch_open_56+7Ej
		cmp	[ebp+var_8], 0
		jz	short loc_217
		mov	eax, [ebp+var_8]
		push	eax
		call	_ucol_close_56
		add	esp, 4

loc_217:				; CODE XREF: _usearch_open_56+99j
		xor	eax, eax
		jmp	short loc_237
; ---------------------------------------------------------------------------
		jmp	short loc_227
; ---------------------------------------------------------------------------

loc_21D:				; CODE XREF: _usearch_open_56+93j
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+103Ch], 1

loc_227:				; CODE XREF: _usearch_open_56+ABj
		mov	eax, [ebp+var_14]
		jmp	short loc_237
; ---------------------------------------------------------------------------

loc_22C:				; CODE XREF: _usearch_open_56+3Ej
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		xor	eax, eax

loc_237:				; CODE XREF: _usearch_open_56+35j
					; _usearch_open_56+A9j	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_open_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _usearch_open_56+24p
					; _usearch_open_56+86p	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 278h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_openFromCollator_56(int, int, int, int, int, int,	enum UErrorCode	*)
		public _usearch_openFromCollator_56
_usearch_openFromCollator_56 proc near	; CODE XREF: _usearch_open_56+6Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2B2
		xor	eax, eax
		jmp	loc_623
; ---------------------------------------------------------------------------

loc_2B2:				; CODE XREF: _usearch_openFromCollator_56+31j
		cmp	[ebp+arg_0], 0
		jz	short loc_2C4
		cmp	[ebp+arg_8], 0
		jz	short loc_2C4
		cmp	[ebp+arg_10], 0
		jnz	short loc_2D4

loc_2C4:				; CODE XREF: _usearch_openFromCollator_56+3Ej
					; _usearch_openFromCollator_56+44j
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_623
; ---------------------------------------------------------------------------

loc_2D4:				; CODE XREF: _usearch_openFromCollator_56+4Aj
		mov	eax, [ebp+arg_18]
		push	eax
		push	7
		mov	ecx, [ebp+arg_10]
		push	ecx
		call	_ucol_getAttribute_56
		add	esp, 0Ch
		cmp	eax, 11h
		jnz	short loc_2FB
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 10h
		xor	eax, eax
		jmp	loc_623
; ---------------------------------------------------------------------------

loc_2FB:				; CODE XREF: _usearch_openFromCollator_56+71j
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_621
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		call	?initializeFCD@@YAXPAW4UErrorCode@@@Z ;	initializeFCD(UErrorCode *)
		add	esp, 4
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_33C
		xor	eax, eax
		jmp	loc_623
; ---------------------------------------------------------------------------

loc_33C:				; CODE XREF: _usearch_openFromCollator_56+BBj
		cmp	[ebp+arg_C], 0FFFFFFFFh
		jnz	short loc_351
		mov	eax, [ebp+arg_8]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_C], eax

loc_351:				; CODE XREF: _usearch_openFromCollator_56+C8j
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jnz	short loc_366
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_366:				; CODE XREF: _usearch_openFromCollator_56+DDj
		cmp	[ebp+arg_C], 0
		jle	short loc_372
		cmp	[ebp+arg_4], 0
		jg	short loc_382

loc_372:				; CODE XREF: _usearch_openFromCollator_56+F2j
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_623
; ---------------------------------------------------------------------------

loc_382:				; CODE XREF: _usearch_openFromCollator_56+F8j
		push	1450h
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_3A8
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_623
; ---------------------------------------------------------------------------

loc_3A8:				; CODE XREF: _usearch_openFromCollator_56+11Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_10]
		mov	[eax+1028h], ecx
		mov	eax, [ebp+arg_10]
		push	eax
		call	_ucol_getStrength_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		mov	[ecx+1040h], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1040h]
		push	ecx
		call	?getMask@@YAIW4UColAttributeValue@@@Z ;	getMask(UColAttributeValue)
		add	esp, 4
		mov	edx, [ebp+var_8]
		mov	[edx+1044h], eax
		mov	eax, [ebp+arg_18]
		push	eax
		push	1
		mov	ecx, [ebp+arg_10]
		push	ecx
		call	_ucol_getAttribute_56
		add	esp, 0Ch
		cmp	eax, 14h
		setz	dl
		mov	eax, [ebp+var_8]

loc_3FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		mov	[eax+104Ch], dl
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		call	_ucol_getVariableTop_56
		add	esp, 8
		mov	edx, [ebp+var_8]
		mov	[edx+1048h], eax
		mov	esi, esp
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		call	dword ptr ds:__imp_?getNFDInstance@Normalizer2@icu_56@@SAPBV12@AAW4UErrorCode@@@Z ; icu_56::Normalizer2::getNFDInstance(UErrorCode &)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_8]
		mov	[ecx+102Ch], eax
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_465
		mov	eax, [ebp+var_8]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_623
; ---------------------------------------------------------------------------

loc_465:				; CODE XREF: _usearch_openFromCollator_56+1D8j
		push	20h ; ' '
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		jnz	short loc_498
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_8]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_623
; ---------------------------------------------------------------------------

loc_498:				; CODE XREF: _usearch_openFromCollator_56+202j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_8]
		mov	[ecx], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_C]
		mov	[ecx+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+41Ch], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_14]
		mov	[ecx+10h], edx
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_18]
		push	eax
		push	1
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1028h]
		push	edx
		call	_ucol_getLocaleByType_56
		add	esp, 0Ch
		push	eax
		push	0
		call	_ubrk_open_56
		add	esp, 14h
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	[edx+0Ch], eax
		cmp	[ebp+arg_14], 0
		jz	short loc_536
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_14]
		push	eax
		call	_ubrk_setText_56
		add	esp, 10h

loc_536:				; CODE XREF: _usearch_openFromCollator_56+2A4j
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+103Ch], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	dword ptr [ecx+18h], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	dword ptr [ecx+14h], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+1038h], 0
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_10]
		push	eax
		call	_ucol_openElements_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx+1030h], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+1034h], 0
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5B8
		mov	eax, [ebp+var_8]
		push	eax
		call	_usearch_close_56
		add	esp, 4
		xor	eax, eax
		jmp	short loc_623
; ---------------------------------------------------------------------------

loc_5B8:				; CODE XREF: _usearch_openFromCollator_56+32Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	byte ptr [ecx+8], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	byte ptr [ecx+9], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		xor	edx, edx
		mov	[ecx+0Ah], dx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	byte ptr [ecx+1Ch], 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	byte ptr [ecx+1Dh], 1
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?initialize@@YAXPAUUStringSearch@@PAW4UErrorCode@@@Z ; initialize(UStringSearch	*,UErrorCode *)
		add	esp, 8
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_61C
		mov	eax, [ebp+var_8]
		push	eax
		call	_usearch_close_56
		add	esp, 4
		xor	eax, eax
		jmp	short loc_623
; ---------------------------------------------------------------------------

loc_61C:				; CODE XREF: _usearch_openFromCollator_56+392j
		mov	eax, [ebp+var_8]
		jmp	short loc_623
; ---------------------------------------------------------------------------

loc_621:				; CODE XREF: _usearch_openFromCollator_56+96j
		xor	eax, eax

loc_623:				; CODE XREF: _usearch_openFromCollator_56+35j
					; _usearch_openFromCollator_56+57j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_openFromCollator_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 638h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _usearch_openFromCollator_56+89p
					; initialize(UStringSearch *,UErrorCode	*)+38p	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 664h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl getMask(enum  UColAttributeValue)
?getMask@@YAIW4UColAttributeValue@@@Z proc near
					; CODE XREF: _usearch_openFromCollator_56+15Bp
					; _usearch_setCollator_56+146p	...

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C4], eax
		cmp	[ebp+var_C4], 0
		jz	short loc_69F
		cmp	[ebp+var_C4], 1
		jz	short loc_6A6
		jmp	short loc_6AD
; ---------------------------------------------------------------------------

loc_69F:				; CODE XREF: getMask(UColAttributeValue)+2Ej
		mov	eax, 0FFFF0000h
		jmp	short loc_6B0
; ---------------------------------------------------------------------------

loc_6A6:				; CODE XREF: getMask(UColAttributeValue)+37j
		mov	eax, 0FFFFFF00h
		jmp	short loc_6B0
; ---------------------------------------------------------------------------

loc_6AD:				; CODE XREF: getMask(UColAttributeValue)+39j
		or	eax, 0FFFFFFFFh

loc_6B0:				; CODE XREF: getMask(UColAttributeValue)+40j
					; getMask(UColAttributeValue)+47j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getMask@@YAIW4UColAttributeValue@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl initializeFCD(enum UErrorCode *)
?initializeFCD@@YAXPAW4UErrorCode@@@Z proc near
					; CODE XREF: _usearch_openFromCollator_56+A0p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	ds:_g_nfcImpl, 0
		jnz	short loc_709
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		call	dword ptr ds:__imp_?getNFCImpl@Normalizer2Factory@icu_56@@SAPBVNormalizer2Impl@2@AAW4UErrorCode@@@Z ; icu_56::Normalizer2Factory::getNFCImpl(UErrorCode	&)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ds:_g_nfcImpl, eax
		push	offset _usearch_cleanup
		push	14h
		call	_ucln_i18n_registerCleanup_56
		add	esp, 8

loc_709:				; CODE XREF: initializeFCD(UErrorCode *)+25j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initializeFCD@@YAXPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 720h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_usearch_cleanup proc near		; DATA XREF: initializeFCD(UErrorCode *)+42o

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	ds:_g_nfcImpl, 0
		mov	al, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_usearch_cleanup endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 754h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl initialize(struct UStringSearch *, enum	UErrorCode *)
?initialize@@YAXPAUUStringSearch@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: _usearch_openFromCollator_56+377p
					; _usearch_setCollator_56+235p	...

var_F4		= dword	ptr -0F4h
var_2C		= word ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?initializePattern@@YAFPAUUStringSearch@@PAW4UErrorCode@@@Z ; initializePattern(UStringSearch *,UErrorCode *)
		add	esp, 8
		mov	[ebp+var_8], ax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_833
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+10h], 0
		jle	loc_833
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+var_8]
		cmp	[ebp+var_20], eax
		jle	short loc_7D9
		movsx	ecx, word ptr [ebp+var_20]
		movsx	edx, [ebp+var_8]
		sub	ecx, edx
		mov	[ebp+var_F4], ecx
		jmp	short loc_7E3
; ---------------------------------------------------------------------------

loc_7D9:				; CODE XREF: initialize(UStringSearch *,UErrorCode *)+71j
		mov	[ebp+var_F4], 1

loc_7E3:				; CODE XREF: initialize(UStringSearch *,UErrorCode *)+83j
		mov	ax, word ptr [ebp+var_F4]
		mov	[ebp+var_2C], ax
		mov	eax, [ebp+var_14]
		mov	cx, [ebp+var_2C]
		mov	[eax+0C1Ah], cx
		movzx	eax, [ebp+var_2C]

loc_800:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		push	eax
		movzx	ecx, [ebp+var_2C]
		push	ecx
		movzx	edx, [ebp+var_8]
		push	edx
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+0Ch]
		push	edx
		mov	eax, [ebp+var_14]
		add	eax, 0E1Eh
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 0C1Ch
		push	ecx
		call	?setShiftTable@@YAXQAF0PAHHFFF@Z ; setShiftTable(short * const,short * const,int *,int,short,short,short)
		add	esp, 1Ch
		jmp	short loc_83F
; ---------------------------------------------------------------------------

loc_833:				; CODE XREF: initialize(UStringSearch *,UErrorCode *)+45j
					; initialize(UStringSearch *,UErrorCode	*)+52j
		xor	eax, eax
		mov	ecx, [ebp+arg_0]
		mov	[ecx+0C22h], ax

loc_83F:				; CODE XREF: initialize(UStringSearch *,UErrorCode *)+DDj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initialize@@YAXPAUUStringSearch@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 854h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; short	__cdecl	initializePattern(struct UStringSearch *, enum	UErrorCode *)
?initializePattern@@YAFPAUUStringSearch@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: initialize(UStringSearch *,UErrorCode *)+26p

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_88E
		xor	eax, eax
		jmp	loc_9B7
; ---------------------------------------------------------------------------

loc_88E:				; CODE XREF: initializePattern(UStringSearch *,UErrorCode *)+31j
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_20], ecx
		mov	[ebp+var_2C], 0
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1040h], 0
		jnz	short loc_8D4
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0C18h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0C19h], 0
		jmp	loc_969
; ---------------------------------------------------------------------------

loc_8D4:				; CODE XREF: initializePattern(UStringSearch *,UErrorCode *)+65j
		mov	eax, [ebp+var_20]
		push	eax
		lea	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		call	?getFCD@@YAGPB_WPAHH@Z ; getFCD(wchar_t	const *,int *,int)
		add	esp, 0Ch
		movzx	eax, ax
		sar	eax, 8
		mov	ecx, [ebp+var_8]
		mov	[ecx+0C18h], al
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_2C]
		mov	edx, [ebp+var_14]
		movzx	eax, word ptr [edx+ecx*2]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_944
		cmp	[ebp+var_2C], 0
		jle	short loc_944
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+eax*2-2]
		and	edx, 0FFFFFC00h
		cmp	edx, 0D800h
		jnz	short loc_944
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	[ebp+var_2C], eax

loc_944:				; CODE XREF: initializePattern(UStringSearch *,UErrorCode *)+C6j
					; initializePattern(UStringSearch *,UErrorCode *)+CCj ...
		mov	eax, [ebp+var_20]
		push	eax
		lea	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		call	?getFCD@@YAGPB_WPAHH@Z ; getFCD(wchar_t	const *,int *,int)
		add	esp, 0Ch
		movzx	eax, ax
		and	eax, 0FFh
		mov	ecx, [ebp+var_8]
		mov	[ecx+0C19h], al

loc_969:				; CODE XREF: initializePattern(UStringSearch *,UErrorCode *)+7Bj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+41Ch], 0
		jz	short loc_9A7
		mov	eax, [ebp+arg_0]
		add	eax, 420h
		mov	ecx, [ebp+arg_0]
		cmp	[ecx+41Ch], eax
		jz	short loc_99A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+41Ch]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_99A:				; CODE XREF: initializePattern(UStringSearch *,UErrorCode *)+132j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+41Ch], 0

loc_9A7:				; CODE XREF: initializePattern(UStringSearch *,UErrorCode *)+11Fj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?initializePatternCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z ; initializePatternCETable(UStringSearch *,UErrorCode *)
		add	esp, 8

loc_9B7:				; CODE XREF: initializePattern(UStringSearch *,UErrorCode *)+35j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initializePattern@@YAFPAUUStringSearch@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN11		dd 1			; DATA XREF: initializePattern(UStringSearch *,UErrorCode *)+167o
		dd offset $LN10
$LN10		dd 0FFFFFFD4h, 4	; DATA XREF: .text:000009E0o
		dd offset $LN9		; "index"
$LN9		db 'index',0            ; DATA XREF: .text:000009ECo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned short __cdecl getFCD(wchar_t	const *, int *,	int)
?getFCD@@YAGPB_WPAHH@Z proc near	; CODE XREF: initializePattern(UStringSearch *,UErrorCode *)+8Cp
					; initializePattern(UStringSearch *,UErrorCode *)+FCp

var_D8		= byte ptr -0D8h
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		mov	esi, esp
		push	edx		; wchar_t *
		lea	eax, [ebp+var_8]
		push	eax		; wchar_t **
		mov	ecx, ds:_g_nfcImpl ; this
		call	dword ptr ds:__imp_?nextFCD16@Normalizer2Impl@icu_56@@QBEGAAPB_WPB_W@Z ; icu_56::Normalizer2Impl::nextFCD16(wchar_t const * &,wchar_t const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], ax
		mov	eax, [ebp+var_8]
		sub	eax, [ebp+arg_0]
		sar	eax, 1
		mov	ecx, [ebp+arg_4]
		mov	[ecx], eax
		mov	ax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getFCD@@YAGPB_WPAHH@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5		dd 1			; DATA XREF: getFCD(wchar_t const *,int	*,int)+68o
		dd offset $LN4
$LN4		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00000A88o
		dd offset $LN3		; "temp"
$LN3		db 'temp',0             ; DATA XREF: .text:00000A94o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned short __cdecl initializePatternCETable(struct UStringSearch *, enum	UErrorCode *)
?initializePatternCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z proc	near
					; CODE XREF: initializePattern(UStringSearch *,UErrorCode *)+15Bp

var_138		= byte ptr -138h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= word ptr -50h
var_44		= word ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
Src		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_138]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	[ebp+var_8], eax
		mov	[ebp+var_14], 100h
		mov	eax, [ebp+var_8]
		add	eax, 10h
		mov	[ebp+Src], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1038h]
		mov	[ebp+var_38], ecx
		cmp	[ebp+var_38], 0
		jnz	short loc_B23
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1028h]
		push	edx
		call	_ucol_openElements_56
		add	esp, 10h
		mov	[ebp+var_38], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_38]
		mov	[eax+1038h], ecx
		jmp	short loc_B40
; ---------------------------------------------------------------------------

loc_B23:				; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+50j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+var_38]
		push	edx
		call	_ucol_setText_56
		add	esp, 10h

loc_B40:				; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+81j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B5C
		xor	eax, eax
		jmp	loc_CA3
; ---------------------------------------------------------------------------

loc_B5C:				; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+B3j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		cmp	ecx, [ebp+Src]
		jz	short loc_B7F
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_B7F
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_B7F:				; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+C5j
					; initializePatternCETable(UStringSearch *,UErrorCode *)+CEj
		xor	eax, eax
		mov	[ebp+var_44], ax
		xor	eax, eax
		mov	[ebp+var_50], ax

loc_B8B:				; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+1D9j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		call	_ucol_next_56
		add	esp, 8
		mov	[ebp+var_5C], eax
		cmp	[ebp+var_5C], 0FFFFFFFFh
		jz	loc_C7E
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_C7E
		mov	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getCE@@YAHPBUUStringSearch@@I@Z ; getCE(UStringSearch const *,uint)
		add	esp, 8
		mov	[ebp+var_68], eax
		cmp	[ebp+var_68], 0
		jz	short loc_C59
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_38]
		push	ecx
		call	_ucol_getOffset_56
		add	esp, 4
		mov	edx, [ebp+var_2C]
		sub	edx, eax
		add	edx, 1
		push	edx		; int
		mov	eax, [ebp+var_68]
		push	eax		; int
		lea	ecx, [ebp+var_14]
		push	ecx		; int
		movzx	edx, [ebp+var_44]
		push	edx		; int
		mov	eax, [ebp+Src]
		push	eax		; Src
		call	?addTouint32_tArray@@YAPAHPAHIPAIIIPAW4UErrorCode@@@Z ;	addTouint32_tArray(int *,uint,uint *,uint,uint,UErrorCode *)
		add	esp, 18h
		mov	[ebp+var_74], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_C28
		xor	eax, eax
		jmp	short loc_CA3
; ---------------------------------------------------------------------------

loc_C28:				; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+182j
		mov	ax, [ebp+var_44]
		add	ax, 1
		mov	[ebp+var_44], ax
		mov	eax, [ebp+Src]
		cmp	eax, [ebp+var_74]
		jz	short loc_C53
		mov	eax, [ebp+var_8]
		add	eax, 10h
		cmp	[ebp+Src], eax
		jz	short loc_C53
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_C53:				; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+19Aj
					; initializePatternCETable(UStringSearch *,UErrorCode *)+1A5j
		mov	eax, [ebp+var_74]
		mov	[ebp+Src], eax

loc_C59:				; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+138j
		mov	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		call	_ucol_getMaxExpansion_56
		add	esp, 8
		sub	eax, 1
		movzx	edx, ax
		movzx	eax, [ebp+var_50]
		add	eax, edx
		mov	[ebp+var_50], ax
		jmp	loc_B8B
; ---------------------------------------------------------------------------

loc_C7E:				; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+102j
					; initializePatternCETable(UStringSearch *,UErrorCode *)+11Bj
		movzx	eax, [ebp+var_44]
		mov	ecx, [ebp+Src]
		mov	dword ptr [ecx+eax*4], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Src]
		mov	[eax+0Ch], ecx
		movzx	eax, [ebp+var_44]
		mov	ecx, [ebp+var_8]
		mov	[ecx+8], eax
		mov	ax, [ebp+var_50]

loc_CA3:				; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+B7j
					; initializePatternCETable(UStringSearch *,UErrorCode *)+186j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 138h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initializePatternCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN14		dd 1			; DATA XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+207o
		dd offset $LN13
$LN13		dd 0FFFFFFECh, 4	; DATA XREF: .text:00000CCCo
		dd offset $LN12		; "cetablesize"
$LN12		db 'cetablesize',0      ; DATA XREF: .text:00000CD8o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl getCE(struct UStringSearch const *, unsigned int)
?getCE@@YAHPBUUStringSearch@@I@Z proc near
					; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+129p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		and	ecx, [eax+1044h]
		mov	[ebp+arg_4], ecx
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+104Ch]
		test	ecx, ecx
		jz	short loc_D53
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1048h]
		cmp	ecx, [ebp+arg_4]
		jbe	short loc_D51
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1040h], 3
		jl	short loc_D4A
		mov	eax, [ebp+arg_4]
		and	eax, 0FFFF0000h
		mov	[ebp+arg_4], eax
		jmp	short loc_D51
; ---------------------------------------------------------------------------

loc_D4A:				; CODE XREF: getCE(UStringSearch const *,uint)+53j
		mov	[ebp+arg_4], 0

loc_D51:				; CODE XREF: getCE(UStringSearch const *,uint)+47j
					; getCE(UStringSearch const *,uint)+60j
		jmp	short loc_D6C
; ---------------------------------------------------------------------------

loc_D53:				; CODE XREF: getCE(UStringSearch const *,uint)+39j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1040h], 3
		jl	short loc_D6C
		cmp	[ebp+arg_4], 0
		jnz	short loc_D6C
		mov	[ebp+arg_4], 0FFFFh

loc_D6C:				; CODE XREF: getCE(UStringSearch const *,uint):loc_D51j
					; getCE(UStringSearch const *,uint)+75j ...
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCE@@YAHPBUUStringSearch@@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl addTouint32_tArray(void *Src, int, int, int, int,	int)
?addTouint32_tArray@@YAPAHPAHIPAIIIPAW4UErrorCode@@@Z proc near
					; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+164p

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		add	eax, 1
		cmp	eax, [ebp+var_8]
		jnz	short loc_E14
		mov	eax, [ebp+var_8]
		add	eax, [ebp+arg_10]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+var_8]
		shl	ecx, 2
		push	ecx
		call	?allocateMemory@@YAPAXIPAW4UErrorCode@@@Z ; allocateMemory(uint,UErrorCode *)
		add	esp, 8
		mov	[ebp+Dst], eax
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_DE1
		xor	eax, eax
		jmp	short loc_E23
; ---------------------------------------------------------------------------

loc_DE1:				; CODE XREF: addTouint32_tArray(int *,uint,uint	*,uint,uint,UErrorCode *)+63j
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+arg_4]
		shl	ecx, 2
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst

loc_DFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_8]
		mov	[eax], ecx
		mov	eax, [ebp+Dst]
		mov	[ebp+Src], eax

loc_E14:				; CODE XREF: addTouint32_tArray(int *,uint,uint	*,uint,uint,UErrorCode *)+2Fj
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+Src]
		mov	edx, [ebp+arg_C]
		mov	[ecx+eax*4], edx
		mov	eax, [ebp+Src]

loc_E23:				; CODE XREF: addTouint32_tArray(int *,uint,uint	*,uint,uint,UErrorCode *)+67j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?addTouint32_tArray@@YAPAHPAHIPAIIIPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void * __cdecl allocateMemory(unsigned int, enum  UErrorCode *)
?allocateMemory@@YAPAXIPAW4UErrorCode@@@Z proc near
					; CODE XREF: addTouint32_tArray(int *,uint,uint	*,uint,uint,UErrorCode *)+45p
					; addTouint64_tArray(__int64 *,uint,uint *,unsigned __int64,uint,UErrorCode *)+45p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_E74
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7

loc_E74:				; CODE XREF: allocateMemory(uint,UErrorCode *)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?allocateMemory@@YAPAXIPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl setShiftTable(short * const, short * const, int *, int, short, short, short)
?setShiftTable@@YAXQAF0PAHHFFF@Z proc near
					; CODE XREF: initialize(UStringSearch *,UErrorCode *)+D5p

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= word ptr  18h
arg_14		= word ptr  1Ch
arg_18		= word ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		jmp	short loc_EBC
; ---------------------------------------------------------------------------

loc_EB3:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+47j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_EBC:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+25j
		cmp	[ebp+var_8], 101h
		jge	short loc_ED5
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ebp+arg_14]
		mov	[ecx+eax*2], dx
		jmp	short loc_EB3
; ---------------------------------------------------------------------------

loc_ED5:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+37j
		mov	eax, [ebp+arg_C]
		sub	eax, 1
		mov	[ebp+arg_C], eax
		mov	[ebp+var_8], 0
		jmp	short loc_EF0
; ---------------------------------------------------------------------------

loc_EE7:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+B4j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_EF0:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+59j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_C]
		jge	short loc_F42
		movsx	eax, [ebp+arg_14]
		sub	eax, [ebp+var_8]
		sub	eax, 1
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 1
		jle	short loc_F16
		mov	eax, [ebp+var_14]
		mov	[ebp+var_DC], eax
		jmp	short loc_F20
; ---------------------------------------------------------------------------

loc_F16:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+7Dj
		mov	[ebp+var_DC], 1

loc_F20:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+88j
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+arg_8]
		mov	eax, [edx+ecx*4]
		push	eax
		call	?hashFromCE32@@YAHI@Z ;	hashFromCE32(uint)
		add	esp, 4
		mov	ecx, [ebp+arg_0]
		mov	dx, word ptr [ebp+var_DC]
		mov	[ecx+eax*2], dx
		jmp	short loc_EE7
; ---------------------------------------------------------------------------

loc_F42:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+6Aj
		mov	eax, [ebp+arg_C]
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx+eax*4]
		push	edx
		call	?hashFromCE32@@YAHI@Z ;	hashFromCE32(uint)
		add	esp, 4
		mov	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+eax*2], cx
		push	0
		call	?hashFromCE32@@YAHI@Z ;	hashFromCE32(uint)
		add	esp, 4
		mov	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+eax*2], cx
		mov	[ebp+var_8], 0
		jmp	short loc_F88
; ---------------------------------------------------------------------------

loc_F7F:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+113j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_F88:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+F1j
		cmp	[ebp+var_8], 101h
		jge	short loc_FA1
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	dx, [ebp+arg_18]
		mov	[ecx+eax*2], dx
		jmp	short loc_F7F
; ---------------------------------------------------------------------------

loc_FA1:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+103j
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_8], eax
		jmp	short loc_FB2
; ---------------------------------------------------------------------------

loc_FA9:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short):loc_FFFj
		mov	eax, [ebp+var_8]
		sub	eax, 1
		mov	[ebp+var_8], eax

loc_FB2:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+11Bj
		cmp	[ebp+var_8], 0
		jle	short loc_1001
		movsx	eax, [ebp+arg_10]
		cmp	[ebp+var_8], eax
		jle	short loc_FD5
		movsx	ecx, [ebp+arg_10]
		mov	edx, [ebp+var_8]
		sub	edx, ecx
		movsx	eax, dx
		mov	[ebp+var_DC], eax
		jmp	short loc_FDF
; ---------------------------------------------------------------------------

loc_FD5:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+133j
		mov	[ebp+var_DC], 1

loc_FDF:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+147j
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+arg_8]
		mov	eax, [edx+ecx*4]
		push	eax
		call	?hashFromCE32@@YAHI@Z ;	hashFromCE32(uint)
		add	esp, 4
		mov	ecx, [ebp+arg_4]
		mov	dx, word ptr [ebp+var_DC]
		mov	[ecx+eax*2], dx

loc_FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		jmp	short loc_FA9
; ---------------------------------------------------------------------------

loc_1001:				; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+12Aj
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?hashFromCE32@@YAHI@Z ;	hashFromCE32(uint)
		add	esp, 4
		mov	edx, 1
		mov	ecx, [ebp+arg_4]
		mov	[ecx+eax*2], dx
		push	0
		call	?hashFromCE32@@YAHI@Z ;	hashFromCE32(uint)
		add	esp, 4
		mov	ecx, 1
		mov	edx, [ebp+arg_4]
		mov	[edx+eax*2], cx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setShiftTable@@YAXQAF0PAHHFFF@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1048h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl hashFromCE32(unsigned int)
?hashFromCE32@@YAHI@Z proc near		; CODE XREF: setShiftTable(short * const,short * const,int *,int,short,short,short)+9Ep
					; setShiftTable(short *	const,short * const,int	*,int,short,short,short)+C0p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		shr	eax, 18h
		imul	eax, 25h
		mov	ecx, [ebp+arg_0]
		shr	ecx, 10h
		add	eax, ecx
		imul	eax, 25h
		mov	edx, [ebp+arg_0]
		shr	edx, 8
		add	eax, edx
		imul	eax, 25h
		add	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		cdq
		mov	ecx, 101h
		idiv	ecx
		mov	[ebp+var_8], edx
		cmp	[ebp+var_8], 0
		jge	short loc_10AA
		mov	eax, [ebp+var_8]
		add	eax, 101h
		mov	[ebp+var_8], eax

loc_10AA:				; CODE XREF: hashFromCE32(uint)+55j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hashFromCE32@@YAHI@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_close_56
_usearch_close_56 proc near		; CODE XREF: _usearch_openFromCollator_56+334p
					; _usearch_openFromCollator_56+398p

var_DC		= dword	ptr -0DCh
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	loc_11FC
		mov	eax, [ebp+arg_0]
		add	eax, 18h
		mov	ecx, [ebp+arg_0]
		cmp	[ecx+14h], eax
		jz	short loc_1102
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+14h], 0
		jz	short loc_1102
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_1102:				; CODE XREF: _usearch_close_56+34j
					; _usearch_close_56+3Dj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+41Ch], 0
		jz	short loc_1133
		mov	eax, [ebp+arg_0]
		add	eax, 420h
		mov	ecx, [ebp+arg_0]
		cmp	[ecx+41Ch], eax
		jz	short loc_1133
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+41Ch]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_1133:				; CODE XREF: _usearch_close_56+58j
					; _usearch_close_56+6Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1034h]
		mov	[ebp+var_C8], ecx
		mov	edx, [ebp+var_C8]
		mov	[ebp+var_D4], edx
		cmp	[ebp+var_D4], 0
		jz	short loc_116C
		push	1
		mov	ecx, [ebp+var_D4]
		call	??_GUCollationPCE@icu_56@@QAEPAXI@Z ; icu_56::UCollationPCE::`scalar deleting destructor'(uint)
		mov	[ebp+var_DC], eax
		jmp	short loc_1176
; ---------------------------------------------------------------------------

loc_116C:				; CODE XREF: _usearch_close_56+A1j
		mov	[ebp+var_DC], 0

loc_1176:				; CODE XREF: _usearch_close_56+B6j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_closeElements_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1038h]
		push	ecx
		call	_ucol_closeElements_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+103Ch]
		test	ecx, ecx
		jz	short loc_11C6
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1028h], 0
		jz	short loc_11C6
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1028h]
		push	ecx
		call	_ucol_close_56
		add	esp, 4

loc_11C6:				; CODE XREF: _usearch_close_56+F2j
					; _usearch_close_56+FEj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+0Ch], 0
		jz	short loc_11E2
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+0Ch]
		push	edx
		call	_ubrk_close_56
		add	esp, 4

loc_11E2:				; CODE XREF: _usearch_close_56+11Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_11FC:				; CODE XREF: _usearch_close_56+22j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_close_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1210h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::UCollationPCE::`scalar deleting destructor'(unsigned int)
		public ??_GUCollationPCE@icu_56@@QAEPAXI@Z
??_GUCollationPCE@icu_56@@QAEPAXI@Z proc near ;	CODE XREF: _usearch_close_56+ABp
					; _usearch_setCollator_56+81p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UCollationPCE@icu_56@@QAE@XZ	; icu_56::UCollationPCE::~UCollationPCE(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1259
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1259:				; CODE XREF: icu_56::UCollationPCE::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUCollationPCE@icu_56@@QAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1274h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl `anonymous namespace'::initTextProcessedIter(struct UStringSearch *, enum  UErrorCode *)
		public ?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z
?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+149p
					; _usearch_handlePreviousExact_56+96p ...

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_12CD
		xor	al, al
		jmp	loc_1388
; ---------------------------------------------------------------------------

loc_12CD:				; CODE XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+50j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1034h], 0
		jnz	loc_136E
		mov	esi, esp
		push	120h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_D4], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_D4], 0
		jz	short loc_1327
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx		; struct UCollationElements *
		mov	ecx, [ebp+var_D4] ; this
		call	??0UCollationPCE@icu_56@@QAE@PAUUCollationElements@@@Z ; icu_56::UCollationPCE::UCollationPCE(UCollationElements *)
		mov	[ebp+var_E8], eax
		jmp	short loc_1331
; ---------------------------------------------------------------------------

loc_1327:				; CODE XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+94j
		mov	[ebp+var_E8], 0

loc_1331:				; CODE XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+B1j
		mov	edx, [ebp+var_E8]
		mov	[ebp+var_E0], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_E0]
		mov	[eax+1034h], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1034h], 0
		jnz	short loc_136C
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		xor	al, al
		jmp	short loc_1388
; ---------------------------------------------------------------------------

loc_136C:				; CODE XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+E9j
		jmp	short loc_1386
; ---------------------------------------------------------------------------

loc_136E:				; CODE XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+63j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx		; struct UCollationElements *
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+1034h] ; this
		call	?init@UCollationPCE@icu_56@@QAEXPAUUCollationElements@@@Z ; icu_56::UCollationPCE::init(UCollationElements *)

loc_1386:				; CODE XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *):loc_136Cj
		mov	al, 1

loc_1388:				; CODE XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+54j
					; `anonymous namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+F6j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 13A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000013E4o
		mov	esi, esp
		mov	eax, [ebp-0D4h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0ECh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 13E0h
__unwindtable$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000013F0o
		dd offset __unwindfunclet$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z$0
__ehfuncinfo$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 140Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_setOffset_56
_usearch_setOffset_56 proc near		; CODE XREF: _usearch_first_56+4Cp
					; _usearch_following_56+4Ep ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_14A3
		cmp	[ebp+arg_0], 0
		jz	short loc_14A3
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		call	?isOutOfBounds@@YACHH@Z	; isOutOfBounds(int,int)
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_146C
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 8
		jmp	short loc_1482
; ---------------------------------------------------------------------------

loc_146C:				; CODE XREF: _usearch_setOffset_56+53j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1030h]
		push	edx
		call	?setColEIterOffset@@YAXPAUUCollationElements@@H@Z ; setColEIterOffset(UCollationElements *,int)
		add	esp, 8

loc_1482:				; CODE XREF: _usearch_setOffset_56+5Ej
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	dword ptr [ecx+14h], 0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	dword ptr [ecx+18h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	byte ptr [ecx+1Dh], 0

loc_14A3:				; CODE XREF: _usearch_setOffset_56+31j
					; _usearch_setOffset_56+37j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_setOffset_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl setColEIterOffset(struct	UCollationElements *, int)
?setColEIterOffset@@YAXPAUUCollationElements@@H@Z proc near
					; CODE XREF: _usearch_setOffset_56+6Ep
					; _usearch_next_56+1A8p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		lea	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_ucol_setOffset_56
		add	esp, 0Ch
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setColEIterOffset@@YAXPAUUCollationElements@@H@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_0		dd 1			; DATA XREF: setColEIterOffset(UCollationElements *,int)+3Do
		dd offset $LN4_0
$LN4_0		dd 0FFFFFFF8h, 4	; DATA XREF: .text:0000151Co
		dd offset $LN3_0	; "status"
$LN3_0		db 'status',0           ; DATA XREF: .text:00001528o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1534h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isOutOfBounds(int, int)
?isOutOfBounds@@YACHH@Z	proc near	; CODE XREF: _usearch_setOffset_56+46p
					; _usearch_getOffset_56+46p

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jl	short loc_1569
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_0]
		jg	short loc_1569
		mov	[ebp+var_C1], 0
		jmp	short loc_1570
; ---------------------------------------------------------------------------

loc_1569:				; CODE XREF: isOutOfBounds(int,int)+22j
					; isOutOfBounds(int,int)+2Aj
		mov	[ebp+var_C1], 1

loc_1570:				; CODE XREF: isOutOfBounds(int,int)+33j
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isOutOfBounds@@YACHH@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1580h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_getOffset_56
_usearch_getOffset_56 proc near		; CODE XREF: _usearch_next_56+45p
					; _usearch_previous_56+87p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_15DF
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_getOffset_56
		add	esp, 4
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		call	?isOutOfBounds@@YACHH@Z	; isOutOfBounds(int,int)
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_15DA
		or	eax, 0FFFFFFFFh
		jmp	short loc_15E2
; ---------------------------------------------------------------------------

loc_15DA:				; CODE XREF: _usearch_getOffset_56+53j
		mov	eax, [ebp+var_8]
		jmp	short loc_15E2
; ---------------------------------------------------------------------------

loc_15DF:				; CODE XREF: _usearch_getOffset_56+22j
		or	eax, 0FFFFFFFFh

loc_15E2:				; CODE XREF: _usearch_getOffset_56+58j
					; _usearch_getOffset_56+5Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_getOffset_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_setAttribute_56
_usearch_setAttribute_56 proc near

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_16B2
		cmp	[ebp+arg_0], 0
		jz	short loc_16B2
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_C4], eax
		cmp	[ebp+var_C4], 0
		jz	short loc_165B
		cmp	[ebp+var_C4], 1
		jz	short loc_166E
		cmp	[ebp+var_C4], 2
		jz	short loc_1681
		jmp	short loc_16A9
; ---------------------------------------------------------------------------

loc_165B:				; CODE XREF: _usearch_setAttribute_56+4Dj
		xor	eax, eax
		cmp	[ebp+arg_8], 1
		setz	al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[edx+8], al
		jmp	short loc_16B2
; ---------------------------------------------------------------------------

loc_166E:				; CODE XREF: _usearch_setAttribute_56+56j
		xor	eax, eax
		cmp	[ebp+arg_8], 1
		setz	al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[edx+9], al
		jmp	short loc_16B2
; ---------------------------------------------------------------------------

loc_1681:				; CODE XREF: _usearch_setAttribute_56+5Fj
		cmp	[ebp+arg_8], 3
		jz	short loc_168D
		cmp	[ebp+arg_8], 4
		jnz	short loc_169C

loc_168D:				; CODE XREF: _usearch_setAttribute_56+8Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	dx, word ptr [ebp+arg_8]
		mov	[ecx+0Ah], dx
		jmp	short loc_16A7
; ---------------------------------------------------------------------------

loc_169C:				; CODE XREF: _usearch_setAttribute_56+93j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		xor	edx, edx
		mov	[ecx+0Ah], dx

loc_16A7:				; CODE XREF: _usearch_setAttribute_56+A2j
		jmp	short loc_16B2
; ---------------------------------------------------------------------------

loc_16A9:				; CODE XREF: _usearch_setAttribute_56+61j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1

loc_16B2:				; CODE XREF: _usearch_setAttribute_56+31j
					; _usearch_setAttribute_56+3Bj	...
		cmp	[ebp+arg_8], 5
		jnz	short loc_16C1
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1

loc_16C1:				; CODE XREF: _usearch_setAttribute_56+BEj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_setAttribute_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_getAttribute_56
_usearch_getAttribute_56 proc near

var_D0		= dword	ptr -0D0h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_1778	; jumptable 00001714 default case
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_D0], eax
		cmp	[ebp+var_D0], 3	; switch 4 cases
		ja	short loc_1778	; jumptable 00001714 default case
		mov	ecx, [ebp+var_D0]
		jmp	ds:$LN13_0[ecx*4] ; switch jump
; ---------------------------------------------------------------------------

$LN7:					; CODE XREF: _usearch_getAttribute_56+3Cj
					; DATA XREF: .text:$LN13_0o
		mov	eax, [ebp+arg_0] ; jumptable 00001714 case 0
		mov	ecx, [eax]
		movsx	eax, byte ptr [ecx+8]
		sub	eax, 1
		neg	eax
		sbb	eax, eax
		add	eax, 1
		jmp	short loc_177B
; ---------------------------------------------------------------------------

$LN6:					; CODE XREF: _usearch_getAttribute_56+3Cj
					; DATA XREF: .text:$LN13_0o
		mov	eax, [ebp+arg_0] ; jumptable 00001714 case 1
		mov	ecx, [eax]
		movsx	eax, byte ptr [ecx+9]
		sub	eax, 1
		neg	eax
		sbb	eax, eax
		add	eax, 1
		jmp	short loc_177B
; ---------------------------------------------------------------------------

$LN5_1:					; CODE XREF: _usearch_getAttribute_56+3Cj
					; DATA XREF: .text:$LN13_0o
		mov	eax, [ebp+arg_0] ; jumptable 00001714 case 2
		mov	ecx, [eax]
		mov	dx, [ecx+0Ah]
		mov	[ebp+var_8], dx
		movsx	eax, [ebp+var_8]
		cmp	eax, 3
		jz	short loc_1764
		movsx	eax, [ebp+var_8]
		cmp	eax, 4
		jnz	short loc_176C

loc_1764:				; CODE XREF: _usearch_getAttribute_56+81j
		movsx	eax, [ebp+var_8]
		jmp	short loc_177B
; ---------------------------------------------------------------------------
		jmp	short $LN1	; jumptable 00001714 case 3
; ---------------------------------------------------------------------------

loc_176C:				; CODE XREF: _usearch_getAttribute_56+8Aj
		mov	eax, 2
		jmp	short loc_177B
; ---------------------------------------------------------------------------

$LN1:					; CODE XREF: _usearch_getAttribute_56+3Cj
					; _usearch_getAttribute_56+92j
					; DATA XREF: ...
		or	eax, 0FFFFFFFFh	; jumptable 00001714 case 3
		jmp	short loc_177B
; ---------------------------------------------------------------------------

loc_1778:				; CODE XREF: _usearch_getAttribute_56+22j
					; _usearch_getAttribute_56+34j
		or	eax, 0FFFFFFFFh	; jumptable 00001714 default case

loc_177B:				; CODE XREF: _usearch_getAttribute_56+56j
					; _usearch_getAttribute_56+6Bj	...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_usearch_getAttribute_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN13_0		dd offset $LN7		; DATA XREF: _usearch_getAttribute_56+3Cr
		dd offset $LN6		; jump table for switch	statement
		dd offset $LN5_1
		dd offset $LN1
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1794h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_getMatchedStart_56
_usearch_getMatchedStart_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jnz	short loc_17BD
		or	eax, 0FFFFFFFFh
		jmp	short loc_17C5
; ---------------------------------------------------------------------------

loc_17BD:				; CODE XREF: _usearch_getMatchedStart_56+22j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	eax, [ecx+14h]

loc_17C5:				; CODE XREF: _usearch_getMatchedStart_56+27j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_usearch_getMatchedStart_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_getMatchedText_56(int, void *Dst,	int, int)
		public _usearch_getMatchedText_56
_usearch_getMatchedText_56 proc	near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Dst		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1807
		or	eax, 0FFFFFFFFh
		jmp	loc_18D0
; ---------------------------------------------------------------------------

loc_1807:				; CODE XREF: _usearch_getMatchedText_56+31j
		cmp	[ebp+arg_0], 0
		jz	short loc_181F
		cmp	[ebp+arg_8], 0
		jl	short loc_181F
		cmp	[ebp+arg_8], 0
		jle	short loc_1830
		cmp	[ebp+Dst], 0
		jnz	short loc_1830

loc_181F:				; CODE XREF: _usearch_getMatchedText_56+3Fj
					; _usearch_getMatchedText_56+45j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		or	eax, 0FFFFFFFFh
		jmp	loc_18D0
; ---------------------------------------------------------------------------

loc_1830:				; CODE XREF: _usearch_getMatchedText_56+4Bj
					; _usearch_getMatchedText_56+51j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+18h]
		mov	[ebp+var_8], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+14h]
		mov	[ebp+var_14], edx
		cmp	[ebp+var_14], 0FFFFFFFFh
		jnz	short loc_1867
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx
		call	_u_terminateUChars_56
		add	esp, 10h
		or	eax, 0FFFFFFFFh
		jmp	short loc_18D0
; ---------------------------------------------------------------------------

loc_1867:				; CODE XREF: _usearch_getMatchedText_56+7Ej
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_8]
		jge	short loc_1875
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_8], eax

loc_1875:				; CODE XREF: _usearch_getMatchedText_56+A1j
		cmp	[ebp+var_8], 0
		jle	short loc_18B3
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx]
		mov	eax, [ebp+var_14]
		lea	ecx, [edx+eax*2]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+var_8]
		shl	edx, 1
		push	edx		; Size
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx]
		mov	eax, [ebp+var_14]
		lea	ecx, [edx+eax*2]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_18B3:				; CODE XREF: _usearch_getMatchedText_56+ADj
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx+18h]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx
		call	_u_terminateUChars_56
		add	esp, 10h

loc_18D0:				; CODE XREF: _usearch_getMatchedText_56+36j
					; _usearch_getMatchedText_56+5Fj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_getMatchedText_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_getMatchedLength_56
_usearch_getMatchedLength_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_1912
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	eax, [ecx+18h]
		jmp	short loc_1915
; ---------------------------------------------------------------------------

loc_1912:				; CODE XREF: _usearch_getMatchedLength_56+22j
		or	eax, 0FFFFFFFFh

loc_1915:				; CODE XREF: _usearch_getMatchedLength_56+2Cj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_usearch_getMatchedLength_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 191Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_setBreakIterator_56
_usearch_setBreakIterator_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1987
		cmp	[ebp+arg_0], 0
		jz	short loc_1987
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	[ecx+10h], edx
		cmp	[ebp+arg_4], 0
		jz	short loc_1987
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	_ubrk_setText_56
		add	esp, 10h

loc_1987:				; CODE XREF: _usearch_setBreakIterator_56+31j
					; _usearch_setBreakIterator_56+37j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_setBreakIterator_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 199Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_getBreakIterator_56
_usearch_getBreakIterator_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_19CA
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	eax, [ecx+10h]
		jmp	short loc_19CC
; ---------------------------------------------------------------------------

loc_19CA:				; CODE XREF: _usearch_getBreakIterator_56+22j
		xor	eax, eax

loc_19CC:				; CODE XREF: _usearch_getBreakIterator_56+2Cj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_usearch_getBreakIterator_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_setText_56
_usearch_setText_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_1ADF
		cmp	[ebp+arg_0], 0
		jz	short loc_1A23
		cmp	[ebp+arg_4], 0
		jz	short loc_1A23
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jl	short loc_1A23
		cmp	[ebp+arg_8], 0
		jnz	short loc_1A31

loc_1A23:				; CODE XREF: _usearch_setText_56+3Bj
					; _usearch_setText_56+41j ...
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		jmp	loc_1ADF
; ---------------------------------------------------------------------------

loc_1A31:				; CODE XREF: _usearch_setText_56+4Dj
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jnz	short loc_1A46
		mov	eax, [ebp+arg_4]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_1A46:				; CODE XREF: _usearch_setText_56+61j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	[ecx], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_8]
		mov	[ecx+4], edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_setText_56
		add	esp, 10h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	dword ptr [ecx+14h], 0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	dword ptr [ecx+18h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	byte ptr [ecx+1Dh], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+10h], 0
		jz	short loc_1AC2
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+10h]
		push	edx
		call	_ubrk_setText_56
		add	esp, 10h

loc_1AC2:				; CODE XREF: _usearch_setText_56+CFj
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+0Ch]
		push	edx
		call	_ubrk_setText_56
		add	esp, 10h

loc_1ADF:				; CODE XREF: _usearch_setText_56+31j
					; _usearch_setText_56+58j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_setText_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_getText_56
_usearch_getText_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_1B2E
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	eax, [ecx+4]
		mov	[edx], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	eax, [ecx]
		jmp	short loc_1B30
; ---------------------------------------------------------------------------

loc_1B2E:				; CODE XREF: _usearch_getText_56+22j
		xor	eax, eax

loc_1B30:				; CODE XREF: _usearch_getText_56+38j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_usearch_getText_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_setCollator_56
_usearch_setCollator_56	proc near

var_DC		= dword	ptr -0DCh
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_1D75
		cmp	[ebp+arg_4], 0
		jnz	short loc_1B83
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	loc_1D75
; ---------------------------------------------------------------------------

loc_1B83:				; CODE XREF: _usearch_setCollator_56+3Bj
		cmp	[ebp+arg_0], 0
		jz	loc_1D75
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1034h]
		mov	[ebp+var_C8], ecx
		mov	edx, [ebp+var_C8]
		mov	[ebp+var_D4], edx
		cmp	[ebp+var_D4], 0
		jz	short loc_1BC6
		push	1
		mov	ecx, [ebp+var_D4]
		call	??_GUCollationPCE@icu_56@@QAEPAXI@Z ; icu_56::UCollationPCE::`scalar deleting destructor'(uint)
		mov	[ebp+var_DC], eax
		jmp	short loc_1BD0
; ---------------------------------------------------------------------------

loc_1BC6:				; CODE XREF: _usearch_setCollator_56+77j
		mov	[ebp+var_DC], 0

loc_1BD0:				; CODE XREF: _usearch_setCollator_56+8Cj
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+1034h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_closeElements_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1038h]
		push	ecx
		call	_ucol_closeElements_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+1038h], 0
		mov	ecx, [ebp+arg_0]
		mov	dword ptr [ecx+1030h], 0
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+103Ch]
		test	ecx, ecx
		jz	short loc_1C53
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1028h]
		cmp	ecx, [ebp+arg_4]
		jz	short loc_1C53
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1028h]
		push	ecx
		call	_ucol_close_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+103Ch], 0

loc_1C53:				; CODE XREF: _usearch_setCollator_56+EFj
					; _usearch_setCollator_56+FDj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+1028h], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		call	_ucol_getStrength_56
		add	esp, 4
		mov	ecx, [ebp+arg_0]
		mov	[ecx+1040h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1040h]
		push	ecx
		call	?getMask@@YAIW4UColAttributeValue@@@Z ;	getMask(UColAttributeValue)
		add	esp, 4
		mov	edx, [ebp+arg_0]
		mov	[edx+1044h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+0Ch]
		push	edx
		call	_ubrk_close_56
		add	esp, 4
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		push	1
		mov	edx, [ebp+arg_4]
		push	edx
		call	_ucol_getLocaleByType_56
		add	esp, 0Ch
		push	eax
		push	0
		call	_ubrk_open_56
		add	esp, 14h
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[edx+0Ch], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	1
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	_ucol_getAttribute_56
		add	esp, 0Ch
		cmp	eax, 14h
		setz	dl
		mov	eax, [ebp+arg_0]
		mov	[eax+104Ch], dl
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	_ucol_getVariableTop_56
		add	esp, 8
		mov	edx, [ebp+arg_0]
		mov	[edx+1048h], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	_ucol_openElements_56
		add	esp, 10h
		mov	edx, [ebp+arg_0]
		mov	[edx+1030h], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		call	_ucol_openElements_56
		add	esp, 10h
		mov	ecx, [ebp+arg_0]
		mov	[ecx+1038h], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?initialize@@YAXPAUUStringSearch@@PAW4UErrorCode@@@Z ; initialize(UStringSearch	*,UErrorCode *)
		add	esp, 8

loc_1D75:				; CODE XREF: _usearch_setCollator_56+31j
					; _usearch_setCollator_56+46j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_setCollator_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_getCollator_56
_usearch_getCollator_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_1DBB
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+1028h]
		jmp	short loc_1DBD
; ---------------------------------------------------------------------------

loc_1DBB:				; CODE XREF: _usearch_getCollator_56+22j
		xor	eax, eax

loc_1DBD:				; CODE XREF: _usearch_getCollator_56+2Dj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_usearch_getCollator_56	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_setPattern_56
_usearch_setPattern_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1E56
		cmp	[ebp+arg_0], 0
		jz	short loc_1E03
		cmp	[ebp+arg_4], 0
		jnz	short loc_1E0E

loc_1E03:				; CODE XREF: _usearch_setPattern_56+37j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		jmp	short loc_1E56
; ---------------------------------------------------------------------------

loc_1E0E:				; CODE XREF: _usearch_setPattern_56+3Dj
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jnz	short loc_1E23
		mov	eax, [ebp+arg_4]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_1E23:				; CODE XREF: _usearch_setPattern_56+4Ej
		cmp	[ebp+arg_8], 0
		jnz	short loc_1E34
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		jmp	short loc_1E56
; ---------------------------------------------------------------------------

loc_1E34:				; CODE XREF: _usearch_setPattern_56+63j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_8]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?initialize@@YAXPAUUStringSearch@@PAW4UErrorCode@@@Z ; initialize(UStringSearch	*,UErrorCode *)
		add	esp, 8

loc_1E56:				; CODE XREF: _usearch_setPattern_56+31j
					; _usearch_setPattern_56+48j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_setPattern_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_getPattern_56
_usearch_getPattern_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_1EA3
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax], edx
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+8]
		jmp	short loc_1EA5
; ---------------------------------------------------------------------------

loc_1EA3:				; CODE XREF: _usearch_getPattern_56+22j
		xor	eax, eax

loc_1EA5:				; CODE XREF: _usearch_getPattern_56+35j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_usearch_getPattern_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_first_56(int, enum UErrorCode *)
		public _usearch_first_56
_usearch_first_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_1F27
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1F27
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	byte ptr [ecx+1Ch], 1
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_usearch_setOffset_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1F27
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_next_56
		add	esp, 8
		jmp	short loc_1F2A
; ---------------------------------------------------------------------------

loc_1F27:				; CODE XREF: _usearch_first_56+22j
					; _usearch_first_56+37j ...
		or	eax, 0FFFFFFFFh

loc_1F2A:				; CODE XREF: _usearch_first_56+79j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_first_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_following_56(int,	int, enum UErrorCode *)
		public _usearch_following_56
_usearch_following_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_1FBD
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1FBD
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	byte ptr [ecx+1Ch], 1
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_usearch_setOffset_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1FBD
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_next_56
		add	esp, 8
		jmp	short loc_1FC0
; ---------------------------------------------------------------------------

loc_1FBD:				; CODE XREF: _usearch_following_56+22j
					; _usearch_following_56+37j ...
		or	eax, 0FFFFFFFFh

loc_1FC0:				; CODE XREF: _usearch_following_56+7Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_following_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_last_56(int, enum	UErrorCode *)
		public _usearch_last_56
_usearch_last_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_2056
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx

loc_1FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2056
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	byte ptr [ecx+1Ch], 0
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_usearch_setOffset_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2056
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_previous_56
		add	esp, 8
		jmp	short loc_2059
; ---------------------------------------------------------------------------

loc_2056:				; CODE XREF: _usearch_last_56+22j
					; _usearch_last_56+37j	...
		or	eax, 0FFFFFFFFh

loc_2059:				; CODE XREF: _usearch_last_56+80j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_last_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2070h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_preceding_56(int,	int, enum UErrorCode *)
		public _usearch_preceding_56
_usearch_preceding_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_20ED
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_20ED
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	byte ptr [ecx+1Ch], 0
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_usearch_setOffset_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_20ED
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_previous_56
		add	esp, 8
		jmp	short loc_20F0
; ---------------------------------------------------------------------------

loc_20ED:				; CODE XREF: _usearch_preceding_56+22j
					; _usearch_preceding_56+37j ...
		or	eax, 0FFFFFFFFh

loc_20F0:				; CODE XREF: _usearch_preceding_56+7Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_preceding_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2104h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_next_56(int, enum	UErrorCode *)
		public _usearch_next_56
_usearch_next_56 proc near		; CODE XREF: _usearch_first_56+71p
					; _usearch_following_56+73p

var_E8		= dword	ptr -0E8h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_23C3
		cmp	[ebp+arg_0], 0
		jz	loc_23C3
		mov	eax, [ebp+arg_0]
		push	eax
		call	_usearch_getOffset_56
		add	esp, 4
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+1Dh], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+1Ch]
		test	ecx, ecx
		jz	short loc_21B7
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jz	short loc_21A1
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jnz	short loc_21B5
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+14h], 0FFFFFFFFh
		jz	short loc_21B5
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		add	ecx, [eax+18h]
		cmp	ecx, [ebp+var_20]
		jle	short loc_21B5

loc_21A1:				; CODE XREF: _usearch_next_56+79j
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		or	eax, 0FFFFFFFFh
		jmp	loc_23C6
; ---------------------------------------------------------------------------

loc_21B5:				; CODE XREF: _usearch_next_56+84j
					; _usearch_next_56+8Dj	...
		jmp	short loc_21D2
; ---------------------------------------------------------------------------

loc_21B7:				; CODE XREF: _usearch_next_56+71j
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+1Ch], 1
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+14h], 0FFFFFFFFh
		jz	short loc_21D2
		mov	eax, [ebp+var_14]
		mov	eax, [eax+14h]
		jmp	loc_23C6
; ---------------------------------------------------------------------------

loc_21D2:				; CODE XREF: _usearch_next_56:loc_21B5j
					; _usearch_next_56+C1j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_23C3
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+10h], 0
		jnz	loc_22CE
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+14h], 0FFFFFFFFh
		jnz	short loc_220F
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	[eax+14h], ecx
		jmp	loc_2291
; ---------------------------------------------------------------------------

loc_220F:				; CODE XREF: _usearch_next_56+FBj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx]
		movzx	ecx, word ptr [eax+ecx*2]
		and	ecx, 0FFFFFC00h
		mov	edx, [ebp+var_14]
		mov	eax, [edx+14h]
		add	eax, 1
		mov	edx, [ebp+var_14]
		mov	[edx+14h], eax
		cmp	ecx, 0D800h
		jnz	short loc_2247
		mov	[ebp+var_E8], 1
		jmp	short loc_2251
; ---------------------------------------------------------------------------

loc_2247:				; CODE XREF: _usearch_next_56+135j
		mov	[ebp+var_E8], 0

loc_2251:				; CODE XREF: _usearch_next_56+141j
		cmp	[ebp+var_E8], 0
		jz	short loc_2291
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		cmp	ecx, [ebp+var_20]
		jz	short loc_2291
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx]
		movzx	ecx, word ptr [eax+ecx*2]
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jnz	short loc_2291
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		add	ecx, 1
		mov	edx, [ebp+var_14]
		mov	[edx+14h], ecx

loc_2291:				; CODE XREF: _usearch_next_56+106j
					; _usearch_next_56+154j ...
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1030h]
		push	eax
		call	?setColEIterOffset@@YAXPAUUCollationElements@@H@Z ; setColEIterOffset(UCollationElements *,int)
		add	esp, 8
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_22C9
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+14h], 0FFFFFFFFh

loc_22C9:				; CODE XREF: _usearch_next_56+1B9j
		jmp	loc_235C
; ---------------------------------------------------------------------------

loc_22CE:				; CODE XREF: _usearch_next_56+EEj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+18h], 0
		jle	short loc_2323
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_2301
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 1
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1030h]
		push	eax
		call	_ucol_setOffset_56
		add	esp, 0Ch
		jmp	short loc_2321
; ---------------------------------------------------------------------------

loc_2301:				; CODE XREF: _usearch_next_56+1DCj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_8]
		add	edx, [ecx+18h]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_setOffset_56
		add	esp, 0Ch

loc_2321:				; CODE XREF: _usearch_next_56+1FBj
		jmp	short loc_232F
; ---------------------------------------------------------------------------

loc_2323:				; CODE XREF: _usearch_next_56+1D1j
		mov	eax, [ebp+var_8]
		sub	eax, 1
		mov	ecx, [ebp+var_14]
		mov	[ecx+14h], eax

loc_232F:				; CODE XREF: _usearch_next_56:loc_2321j
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+9]
		test	ecx, ecx
		jz	short loc_234C
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_handleNextCanonical_56
		add	esp, 8
		jmp	short loc_235C
; ---------------------------------------------------------------------------

loc_234C:				; CODE XREF: _usearch_next_56+234j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_handleNextExact_56
		add	esp, 8

loc_235C:				; CODE XREF: _usearch_next_56:loc_22C9j
					; _usearch_next_56+246j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2376
		or	eax, 0FFFFFFFFh
		jmp	short loc_23C6
; ---------------------------------------------------------------------------

loc_2376:				; CODE XREF: _usearch_next_56+26Bj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+14h], 0FFFFFFFFh
		jnz	short loc_239E
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_setOffset_56
		add	esp, 0Ch
		jmp	short loc_23BB
; ---------------------------------------------------------------------------

loc_239E:				; CODE XREF: _usearch_next_56+279j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+14h]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_setOffset_56
		add	esp, 0Ch

loc_23BB:				; CODE XREF: _usearch_next_56+298j
		mov	eax, [ebp+var_14]
		mov	eax, [eax+14h]
		jmp	short loc_23C6
; ---------------------------------------------------------------------------

loc_23C3:				; CODE XREF: _usearch_next_56+31j
					; _usearch_next_56+3Bj	...
		or	eax, 0FFFFFFFFh

loc_23C6:				; CODE XREF: _usearch_next_56+ACj
					; _usearch_next_56+C9j	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_next_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl setMatchNotFound(struct UStringSearch *)
?setMatchNotFound@@YAXPAUUStringSearch@@@Z proc	near ; CODE XREF: _usearch_next_56+A1p
					; _usearch_previous_56+CEp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	dword ptr [ecx+14h], 0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	dword ptr [ecx+18h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movsx	edx, byte ptr [ecx+1Ch]
		test	edx, edx
		jz	short loc_243C
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	?setColEIterOffset@@YAXPAUUCollationElements@@H@Z ; setColEIterOffset(UCollationElements *,int)
		add	esp, 8
		jmp	short loc_2450
; ---------------------------------------------------------------------------

loc_243C:				; CODE XREF: setMatchNotFound(UStringSearch *)+41j
		push	0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	?setColEIterOffset@@YAXPAUUCollationElements@@H@Z ; setColEIterOffset(UCollationElements *,int)
		add	esp, 8

loc_2450:				; CODE XREF: setMatchNotFound(UStringSearch *)+5Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setMatchNotFound@@YAXPAUUStringSearch@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2464h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_previous_56(int, enum UErrorCode *)
		public _usearch_previous_56
_usearch_previous_56 proc near		; CODE XREF: _usearch_last_56+78p
					; _usearch_preceding_56+73p

var_E8		= dword	ptr -0E8h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_268C
		cmp	[ebp+arg_0], 0
		jz	loc_268C
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+1Dh]
		test	ecx, ecx
		jz	short loc_24E7
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+1Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+1Dh], 0
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1030h]
		push	edx
		call	?setColEIterOffset@@YAXPAUUCollationElements@@H@Z ; setColEIterOffset(UCollationElements *,int)
		add	esp, 8
		jmp	short loc_24F6
; ---------------------------------------------------------------------------

loc_24E7:				; CODE XREF: _usearch_previous_56+52j
		mov	eax, [ebp+arg_0]
		push	eax
		call	_usearch_getOffset_56
		add	esp, 4
		mov	[ebp+var_8], eax

loc_24F6:				; CODE XREF: _usearch_previous_56+81j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+1Ch]
		cmp	ecx, 1
		jnz	short loc_2522
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+1Ch], 0
		cmp	[ebp+var_20], 0FFFFFFFFh
		jz	short loc_2520
		mov	eax, [ebp+var_20]
		jmp	loc_268F
; ---------------------------------------------------------------------------

loc_2520:				; CODE XREF: _usearch_previous_56+B2j
		jmp	short loc_2542
; ---------------------------------------------------------------------------

loc_2522:				; CODE XREF: _usearch_previous_56+A5j
		cmp	[ebp+var_8], 0
		jz	short loc_252E
		cmp	[ebp+var_20], 0
		jnz	short loc_2542

loc_252E:				; CODE XREF: _usearch_previous_56+C2j
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		or	eax, 0FFFFFFFFh
		jmp	loc_268F
; ---------------------------------------------------------------------------

loc_2542:				; CODE XREF: _usearch_previous_56:loc_2520j
					; _usearch_previous_56+C8j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_268C
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+10h], 0
		jnz	loc_263B
		cmp	[ebp+var_20], 0FFFFFFFFh
		jnz	short loc_2579
		mov	eax, [ebp+var_8]
		mov	[ebp+var_E8], eax
		jmp	short loc_2582
; ---------------------------------------------------------------------------

loc_2579:				; CODE XREF: _usearch_previous_56+108j
		mov	ecx, [ebp+var_20]
		mov	[ebp+var_E8], ecx

loc_2582:				; CODE XREF: _usearch_previous_56+113j
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_E8]
		mov	[edx+14h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_25A8
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		jmp	loc_2639
; ---------------------------------------------------------------------------

loc_25A8:				; CODE XREF: _usearch_previous_56+131j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		sub	ecx, 1
		mov	[ebp+var_E8], ecx
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_E8]
		mov	[edx+14h], eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx]
		mov	eax, [ebp+var_E8]
		movzx	ecx, word ptr [edx+eax*2]
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jnz	short loc_2616
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+14h], 0
		jle	short loc_2616
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx]
		movzx	ecx, word ptr [eax+ecx*2-2]
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0D800h
		jnz	short loc_2616
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		sub	ecx, 1
		mov	edx, [ebp+var_14]
		mov	[edx+14h], ecx

loc_2616:				; CODE XREF: _usearch_previous_56+17Aj
					; _usearch_previous_56+183j ...
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1030h]
		push	eax
		call	?setColEIterOffset@@YAXPAUUCollationElements@@H@Z ; setColEIterOffset(UCollationElements *,int)
		add	esp, 8
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+18h], 0

loc_2639:				; CODE XREF: _usearch_previous_56+13Fj
		jmp	short loc_266A
; ---------------------------------------------------------------------------

loc_263B:				; CODE XREF: _usearch_previous_56+FEj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movsx	edx, byte ptr [ecx+9]
		test	edx, edx
		jz	short loc_265A
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_handlePreviousCanonical_56
		add	esp, 8
		jmp	short loc_266A
; ---------------------------------------------------------------------------

loc_265A:				; CODE XREF: _usearch_previous_56+1E2j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_handlePreviousExact_56
		add	esp, 8

loc_266A:				; CODE XREF: _usearch_previous_56:loc_2639j
					; _usearch_previous_56+1F4j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2684
		or	eax, 0FFFFFFFFh
		jmp	short loc_268F
; ---------------------------------------------------------------------------

loc_2684:				; CODE XREF: _usearch_previous_56+219j
		mov	eax, [ebp+var_14]
		mov	eax, [eax+14h]
		jmp	short loc_268F
; ---------------------------------------------------------------------------

loc_268C:				; CODE XREF: _usearch_previous_56+31j
					; _usearch_previous_56+3Bj ...
		or	eax, 0FFFFFFFFh

loc_268F:				; CODE XREF: _usearch_previous_56+B7j
					; _usearch_previous_56+D9j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_previous_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _usearch_reset_56
_usearch_reset_56 proc near

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_29		= byte ptr -29h
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	loc_2862
		mov	[ebp+var_8], 0
		mov	[ebp+var_11], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1028h]
		push	ecx
		call	_ucol_getStrength_56
		add	esp, 4
		mov	[ebp+var_44], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1040h], 3
		jge	short loc_26FE
		cmp	[ebp+var_44], 3
		jge	short loc_2710

loc_26FE:				; CODE XREF: _usearch_reset_56+52j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1040h], 3
		jl	short loc_2714
		cmp	[ebp+var_44], 3
		jge	short loc_2714

loc_2710:				; CODE XREF: _usearch_reset_56+58j
		mov	[ebp+var_11], 0

loc_2714:				; CODE XREF: _usearch_reset_56+64j
					; _usearch_reset_56+6Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1028h]
		push	ecx
		call	_ucol_getStrength_56
		add	esp, 4
		mov	edx, [ebp+arg_0]
		mov	[edx+1040h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1040h]
		push	ecx
		call	?getMask@@YAIW4UColAttributeValue@@@Z ;	getMask(UColAttributeValue)
		add	esp, 4
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1044h]
		cmp	ecx, [ebp+var_20]
		jz	short loc_2762
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+1044h], ecx
		mov	[ebp+var_11], 0

loc_2762:				; CODE XREF: _usearch_reset_56+ACj
		lea	eax, [ebp+var_8]
		push	eax
		push	1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1028h]
		push	edx
		call	_ucol_getAttribute_56
		add	esp, 0Ch
		cmp	eax, 14h
		setz	al
		mov	[ebp+var_29], al
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+104Ch]
		movsx	edx, [ebp+var_29]
		cmp	ecx, edx
		jz	short loc_27A5
		mov	eax, [ebp+arg_0]
		mov	cl, [ebp+var_29]
		mov	[eax+104Ch], cl
		mov	[ebp+var_11], 0

loc_27A5:				; CODE XREF: _usearch_reset_56+EFj
		lea	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1028h]
		push	edx
		call	_ucol_getVariableTop_56
		add	esp, 8
		mov	[ebp+var_38], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1048h]
		cmp	ecx, [ebp+var_38]
		jz	short loc_27DC
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_38]
		mov	[eax+1048h], ecx
		mov	[ebp+var_11], 0

loc_27DC:				; CODE XREF: _usearch_reset_56+126j
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jnz	short loc_27F4
		lea	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?initialize@@YAXPAUUStringSearch@@PAW4UErrorCode@@@Z ; initialize(UStringSearch	*,UErrorCode *)
		add	esp, 8

loc_27F4:				; CODE XREF: _usearch_reset_56+13Ej
		lea	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [edx]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1030h]
		push	edx
		call	_ucol_setText_56
		add	esp, 10h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	dword ptr [ecx+18h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	dword ptr [ecx+14h], 0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	byte ptr [ecx+8], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	byte ptr [ecx+9], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		xor	edx, edx
		mov	[ecx+0Ah], dx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	byte ptr [ecx+1Ch], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	byte ptr [ecx+1Dh], 1

loc_2862:				; CODE XREF: _usearch_reset_56+22j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_reset_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN13_1		dd 1			; DATA XREF: _usearch_reset_56+1C2o
		dd offset $LN12_0
$LN12_0		dd 0FFFFFFF8h, 4	; DATA XREF: .text:0000288Co
		dd offset $LN11_0	; "status"
$LN11_0		db 'status',0           ; DATA XREF: .text:00002898o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(struct UStringSearch *, enum  UErrorCode *)
		public ??0CEIBuffer@?A0x7b251a59@icu_56@@QAE@PAUUStringSearch@@PAW4UErrorCode@@@Z
??0CEIBuffer@?A0x7b251a59@icu_56@@QAE@PAUUStringSearch@@PAW4UErrorCode@@@Z proc	near
					; CODE XREF: _usearch_search_56+BDp
					; _usearch_searchBackwards_56+A3p

var_F0		= byte ptr -0F0h
var_2C		= word ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	[eax+600h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+614h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+418h]
		add	ecx, 20h ; ' '
		mov	edx, [ebp+var_8]
		mov	[edx+604h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movsx	edx, word ptr [ecx+0Ah]
		test	edx, edx
		jz	loc_29B9
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		cmp	[ebp+var_14], 0
		jz	loc_29B9
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_20], eax

loc_2927:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *):loc_29B4j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jnb	loc_29B9
		mov	eax, [ebp+var_14]
		mov	cx, [eax]
		mov	[ebp+var_2C], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		movzx	eax, [ebp+var_2C]
		cmp	eax, 1100h
		jl	short loc_295C
		movzx	eax, [ebp+var_2C]
		cmp	eax, 115Eh
		jle	short loc_2988

loc_295C:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+ABj
		movzx	eax, [ebp+var_2C]
		cmp	eax, 3131h
		jl	short loc_2972
		movzx	eax, [ebp+var_2C]
		cmp	eax, 314Eh
		jle	short loc_2988

loc_2972:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+C1j
		movzx	eax, [ebp+var_2C]
		cmp	eax, 3165h
		jl	short loc_299F
		movzx	eax, [ebp+var_2C]
		cmp	eax, 3186h
		jg	short loc_299F

loc_2988:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+B6j
					; icu_56::`anonymous namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+CCj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+604h]
		add	ecx, 8
		mov	edx, [ebp+var_8]
		mov	[edx+604h], ecx
		jmp	short loc_29B4
; ---------------------------------------------------------------------------

loc_299F:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+D7j
					; icu_56::`anonymous namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+E2j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+604h]
		add	ecx, 3
		mov	edx, [ebp+var_8]
		mov	[edx+604h], ecx

loc_29B4:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+F9j
		jmp	loc_2927
; ---------------------------------------------------------------------------

loc_29B9:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+5Bj
					; icu_56::`anonymous namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+6Ej ...
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1030h]
		mov	[eax+610h], edx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+608h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+60Ch], 0
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z ; `anonymous namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jnz	short loc_29FE
		jmp	short loc_2A3D
; ---------------------------------------------------------------------------

loc_29FE:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+156j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+604h], 60h ; '`'
		jle	short loc_2A3D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+604h]
		shl	ecx, 4
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	edx, [ebp+var_8]
		mov	[edx+600h], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+600h], 0
		jnz	short loc_2A3D
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7

loc_2A3D:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+158j
					; icu_56::`anonymous namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)+164j ...
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0CEIBuffer@?A0x7b251a59@icu_56@@QAE@PAUUStringSearch@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::`anonymous	namespace'::CEIBuffer::~CEIBuffer(void)
		public ??1CEIBuffer@?A0x7b251a59@icu_56@@QAE@XZ
??1CEIBuffer@?A0x7b251a59@icu_56@@QAE@XZ proc near ; CODE XREF:	_usearch_search_56+79Ep
					; _usearch_searchBackwards_56+715p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+600h]
		cmp	ecx, [ebp+var_8]
		jz	short loc_2A9B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+600h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_2A9B:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::~CEIBuffer(void)+2Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1CEIBuffer@?A0x7b251a59@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2AB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct CEI const * __thiscall	icu_56::`anonymous namespace'::CEIBuffer::get(int)
		public ?get@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z
?get@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z proc	near
					; CODE XREF: _usearch_search_56+137p
					; _usearch_search_56+1CBp ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		cdq
		idiv	dword ptr [ecx+604h]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+608h]
		jl	short loc_2B13
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+60Ch]
		jge	short loc_2B13
		mov	eax, [ebp+var_14]
		shl	eax, 4
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+600h]
		jmp	loc_2C05
; ---------------------------------------------------------------------------

loc_2B13:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::get(int)+3Fj
					; icu_56::`anonymous namespace'::CEIBuffer::get(int)+4Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+60Ch]
		jz	short loc_2B52
		xor	eax, eax
		jnz	short loc_2B4B
		mov	ecx, ds:?__LINE__Var@?1??get@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z@4JA ; long `icu_56::`anonymous namespace'::CEIBuffer::get(int)'::`2'::__LINE__Var
		add	ecx, 0Dh
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FI@IKBFFFGJ@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_13COJANIEC@?$AA0?$AA?$AA@ ; Message
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2B4B:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::get(int)+73j
		xor	eax, eax
		jmp	loc_2C05
; ---------------------------------------------------------------------------

loc_2B52:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::get(int)+6Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+60Ch]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+60Ch], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+60Ch]
		sub	edx, [ecx+608h]
		mov	eax, [ebp+var_8]
		cmp	edx, [eax+604h]
		jl	short loc_2B99
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+608h]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+608h], ecx

loc_2B99:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::get(int)+D2j
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14]
		shl	ecx, 4
		mov	edx, [ebp+var_8]
		mov	eax, [edx+600h]
		lea	ecx, [eax+ecx+0Ch]
		push	ecx		; int *
		mov	edx, [ebp+var_14]
		shl	edx, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+600h]
		lea	edx, [ecx+edx+8]
		push	edx		; int *
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+614h]
		mov	ecx, [ecx+1034h] ; this
		call	?nextProcessed@UCollationPCE@icu_56@@QAE_JPAH0PAW4UErrorCode@@@Z ; icu_56::UCollationPCE::nextProcessed(int *,int *,UErrorCode *)
		mov	ecx, [ebp+var_14]
		shl	ecx, 4
		mov	esi, [ebp+var_8]
		mov	esi, [esi+600h]
		mov	[ecx+esi], eax
		mov	[ecx+esi+4], edx
		mov	eax, [ebp+var_14]
		shl	eax, 4
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+600h]

loc_2C05:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::get(int)+5Ej
					; icu_56::`anonymous namespace'::CEIBuffer::get(int)+9Dj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?get@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z endp

; ---------------------------------------------------------------------------
$LN9_0		dd 1			; DATA XREF: icu_56::`anonymous	namespace'::CEIBuffer::get(int)+159o
		dd offset $LN8
$LN8		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00002C30o
		dd offset $LN7_0	; "status"
$LN7_0		db 'status',0           ; DATA XREF: .text:00002C3Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C48h
		public ??_C@_13COJANIEC@?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_13COJANIEC@?$AA0?$AA?$AA@	dd offset ?_Rank@?$_Arithmetic_traits@K@std@@2HB
					; DATA XREF: icu_56::`anonymous	namespace'::CEIBuffer::get(int)+86o
					; icu_56::`anonymous namespace'::CEIBuffer::getPrevious(int)+86o
_rdata		ends			; int const std::_Arithmetic_traits<ulong>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2C4Ch
		public ??_C@_1FI@IKBFFFGJ@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@
; wchar_t `string'
??_C@_1FI@IKBFFFGJ@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@:
					; DATA XREF: icu_56::`anonymous	namespace'::CEIBuffer::get(int)+81o
					; icu_56::`anonymous namespace'::CEIBuffer::getPrevious(int)+81o
		unicode	0, <d:\mozilla\intl\icu\source\i18n\usearch.cpp>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2CA4h
		public ?__LINE__Var@?1??get@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z@4JA
; long `public:	struct CEI const * __thiscall icu_56::`anonymous namespace'::CEIBuffer::get(int)'::`2'::__LINE__Var
?__LINE__Var@?1??get@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z@4JA dd 0DCCh
					; DATA XREF: icu_56::`anonymous	namespace'::CEIBuffer::get(int)+75r
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct CEI const * __thiscall	icu_56::`anonymous namespace'::CEIBuffer::getPrevious(int)
		public ?getPrevious@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z
?getPrevious@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z proc	near
					; CODE XREF: _usearch_searchBackwards_56+12Bp
					; _usearch_searchBackwards_56+1B3p ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		cdq
		idiv	dword ptr [ecx+604h]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+608h]
		jl	short loc_2D0B
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+60Ch]
		jge	short loc_2D0B
		mov	eax, [ebp+var_14]
		shl	eax, 4
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+600h]
		jmp	loc_2DFD
; ---------------------------------------------------------------------------

loc_2D0B:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)+3Fj
					; icu_56::`anonymous namespace'::CEIBuffer::getPrevious(int)+4Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+60Ch]
		jz	short loc_2D4A
		xor	eax, eax
		jnz	short loc_2D43
		mov	ecx, ds:?__LINE__Var@?1??getPrevious@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z@4JA ; long `icu_56::`anonymous namespace'::CEIBuffer::getPrevious(int)'::`2'::__LINE__Var
		add	ecx, 0Dh
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FI@IKBFFFGJ@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\u"...
		push	offset ??_C@_13COJANIEC@?$AA0?$AA?$AA@ ; Message
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2D43:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)+73j
		xor	eax, eax
		jmp	loc_2DFD
; ---------------------------------------------------------------------------

loc_2D4A:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)+6Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+60Ch]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+60Ch], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+60Ch]
		sub	edx, [ecx+608h]
		mov	eax, [ebp+var_8]
		cmp	edx, [eax+604h]
		jl	short loc_2D91
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+608h]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+608h], ecx

loc_2D91:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)+D2j
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14]
		shl	ecx, 4
		mov	edx, [ebp+var_8]
		mov	eax, [edx+600h]
		lea	ecx, [eax+ecx+0Ch]
		push	ecx		; int *
		mov	edx, [ebp+var_14]
		shl	edx, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+600h]
		lea	edx, [ecx+edx+8]
		push	edx		; int *
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+614h]
		mov	ecx, [ecx+1034h] ; this
		call	?previousProcessed@UCollationPCE@icu_56@@QAE_JPAH0PAW4UErrorCode@@@Z ; icu_56::UCollationPCE::previousProcessed(int *,int *,UErrorCode *)
		mov	ecx, [ebp+var_14]
		shl	ecx, 4
		mov	esi, [ebp+var_8]
		mov	esi, [esi+600h]
		mov	[ecx+esi], eax
		mov	[ecx+esi+4], edx
		mov	eax, [ebp+var_14]
		shl	eax, 4
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+600h]

loc_2DFD:				; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)+5Ej
					; icu_56::`anonymous namespace'::CEIBuffer::getPrevious(int)+9Dj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getPrevious@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z endp

; ---------------------------------------------------------------------------
$LN9_1		dd 1			; DATA XREF: icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)+159o
		dd offset $LN8_0
$LN8_0		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00002E28o
		dd offset $LN7_1	; "status"
$LN7_1		db 'status',0           ; DATA XREF: .text:00002E34o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2E40h
		public ?__LINE__Var@?1??getPrevious@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z@4JA
; long `public:	struct CEI const * __thiscall icu_56::`anonymous namespace'::CEIBuffer::getPrevious(int)'::`2'::__LINE__Var
?__LINE__Var@?1??getPrevious@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z@4JA dd 0DF3h
					; DATA XREF: icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)+75r
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl `anonymous namespace'::codePointAt(struct USearch const &, int)
		public ?codePointAt@?A0x7b251a59@@YAHABUUSearch@@H@Z
?codePointAt@?A0x7b251a59@@YAHABUUSearch@@H@Z proc near	; CODE XREF: _usearch_search_56+59Dp
					; _usearch_searchBackwards_56+4FFp

var_D8		= byte ptr -0D8h
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jge	short loc_2EE3
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		movzx	eax, word ptr [ecx+edx*2]
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+arg_4]
		add	ecx, 1
		mov	[ebp+arg_4], ecx
		mov	eax, [ebp+var_8]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_2EDE
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jz	short loc_2EDE
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	ax, [ecx+edx*2]
		mov	[ebp+var_14], ax
		movzx	ecx, [ebp+var_14]
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jnz	short loc_2EDE
		mov	eax, [ebp+arg_4]
		add	eax, 1
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+var_8]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_14]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_8], edx

loc_2EDE:				; CODE XREF: `anonymous	namespace'::codePointAt(USearch const &,int)+4Ej
					; `anonymous namespace'::codePointAt(USearch const &,int)+59j ...
		mov	eax, [ebp+var_8]
		jmp	short loc_2EE6
; ---------------------------------------------------------------------------

loc_2EE3:				; CODE XREF: `anonymous	namespace'::codePointAt(USearch const &,int)+27j
		or	eax, 0FFFFFFFFh

loc_2EE6:				; CODE XREF: `anonymous	namespace'::codePointAt(USearch const &,int)+9Dj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?codePointAt@?A0x7b251a59@@YAHABUUSearch@@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2EF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl `anonymous namespace'::codePointBefore(struct USearch const &, int)
		public ?codePointBefore@?A0x7b251a59@@YAHABUUSearch@@H@Z
?codePointBefore@?A0x7b251a59@@YAHABUUSearch@@H@Z proc near
					; CODE XREF: _usearch_search_56+5DCp
					; _usearch_searchBackwards_56+53Ep

var_D8		= byte ptr -0D8h
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jle	short loc_2F86
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_4]
		movzx	ecx, word ptr [edx+eax*2]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_2F81
		cmp	[ebp+arg_4], 0
		jle	short loc_2F81
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	ax, [ecx+edx*2-2]
		mov	[ebp+var_14], ax
		movzx	ecx, [ebp+var_14]
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0D800h
		jnz	short loc_2F81
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		movzx	eax, [ebp+var_14]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_8]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_8], edx

loc_2F81:				; CODE XREF: `anonymous	namespace'::codePointBefore(USearch const &,int)+49j
					; `anonymous namespace'::codePointBefore(USearch const &,int)+4Fj ...
		mov	eax, [ebp+var_8]
		jmp	short loc_2F89
; ---------------------------------------------------------------------------

loc_2F86:				; CODE XREF: `anonymous	namespace'::codePointBefore(USearch const &,int)+22j
		or	eax, 0FFFFFFFFh

loc_2F89:				; CODE XREF: `anonymous	namespace'::codePointBefore(USearch const &,int)+94j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?codePointBefore@?A0x7b251a59@@YAHABUUSearch@@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_search_56(int, int, int, int, enum UErrorCode *)
		public _usearch_search_56
_usearch_search_56 proc	near		; CODE XREF: _usearch_handleNextExact_56+7Ap
					; _usearch_handleNextCanonical_56+7Ap

var_7D8		= byte ptr -7D8h
var_7D5		= byte ptr -7D5h
var_7D4		= dword	ptr -7D4h
var_7D0		= dword	ptr -7D0h
var_7C5		= byte ptr -7C5h
var_6FC		= dword	ptr -6FCh
var_6ED		= byte ptr -6EDh
var_6E4		= dword	ptr -6E4h
var_6D8		= dword	ptr -6D8h
var_6CC		= dword	ptr -6CCh
var_6C0		= dword	ptr -6C0h
var_6B4		= dword	ptr -6B4h
var_6A8		= dword	ptr -6A8h
var_69C		= dword	ptr -69Ch
var_698		= dword	ptr -698h
var_68C		= dword	ptr -68Ch
var_680		= dword	ptr -680h
var_674		= dword	ptr -674h
var_668		= dword	ptr -668h
var_65C		= dword	ptr -65Ch
var_64D		= byte ptr -64Dh
var_644		= dword	ptr -644h
var_638		= dword	ptr -638h
var_62C		= dword	ptr -62Ch
var_620		= byte ptr -620h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 7D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_7D8]
		mov	ecx, 1F6h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2FD4
		xor	al, al
		jmp	loc_3739
; ---------------------------------------------------------------------------

loc_2FD4:				; CODE XREF: _usearch_search_56+3Bj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_2FF9
		cmp	[ebp+arg_4], 0
		jl	short loc_2FF9
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+4]
		jg	short loc_2FF9
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_3009

loc_2FF9:				; CODE XREF: _usearch_search_56+4Bj
					; _usearch_search_56+51j ...
		mov	eax, [ebp+arg_10]

loc_2FFC:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	loc_3739
; ---------------------------------------------------------------------------

loc_3009:				; CODE XREF: _usearch_search_56+67j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+41Ch], 0
		jnz	short loc_3025
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z ; initializePatternPCETable(UStringSearch *,UErrorCode *)
		add	esp, 8

loc_3025:				; CODE XREF: _usearch_search_56+83j
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1030h]
		push	eax
		call	_ucol_setOffset_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		lea	ecx, [ebp+var_620]
		call	??0CEIBuffer@?A0x7b251a59@icu_56@@QAE@PAUUStringSearch@@PAW4UErrorCode@@@Z ; icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)
		mov	[ebp+var_62C], 0
		mov	[ebp+var_638], 0
		mov	[ebp+var_65C], 0FFFFFFFFh
		mov	[ebp+var_668], 0FFFFFFFFh
		mov	[ebp+var_62C], 0
		jmp	short loc_3095
; ---------------------------------------------------------------------------

loc_3086:				; CODE XREF: _usearch_search_56:loc_3242j
					; _usearch_search_56:loc_36D6j
		mov	eax, [ebp+var_62C]
		add	eax, 1
		mov	[ebp+var_62C], eax

loc_3095:				; CODE XREF: _usearch_search_56+F4j
		mov	[ebp+var_64D], 1
		mov	[ebp+var_68C], 0
		mov	[ebp+var_69C], 0
		mov	[ebp+var_698], 0
		mov	eax, [ebp+var_62C]
		push	eax
		lea	ecx, [ebp+var_620]
		call	?get@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z ; icu_56::`anonymous	namespace'::CEIBuffer::get(int)
		mov	[ebp+var_6A8], eax
		cmp	[ebp+var_6A8], 0
		jnz	short loc_30F0
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 5
		mov	[ebp+var_64D], 0
		jmp	loc_36DB
; ---------------------------------------------------------------------------

loc_30F0:				; CODE XREF: _usearch_search_56+149j
		mov	[ebp+var_644], 0
		jmp	short loc_310B
; ---------------------------------------------------------------------------

loc_30FC:				; CODE XREF: _usearch_search_56:loc_31EEj
		mov	eax, [ebp+var_644]
		add	eax, 1
		mov	[ebp+var_644], eax

loc_310B:				; CODE XREF: _usearch_search_56+16Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_644]
		cmp	ecx, [eax+418h]
		jge	loc_31F3
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+41Ch]
		mov	edx, [ebp+var_644]
		mov	eax, [ecx+edx*8]
		mov	[ebp+var_69C], eax
		mov	ecx, [ecx+edx*8+4]
		mov	[ebp+var_698], ecx
		mov	eax, [ebp+var_62C]
		add	eax, [ebp+var_644]
		add	eax, [ebp+var_68C]
		push	eax
		lea	ecx, [ebp+var_620]
		call	?get@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z ; icu_56::`anonymous	namespace'::CEIBuffer::get(int)
		mov	[ebp+var_638], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movzx	edx, word ptr [ecx+0Ah]
		push	edx
		mov	eax, [ebp+var_698]
		push	eax
		mov	ecx, [ebp+var_69C]
		push	ecx
		mov	edx, [ebp+var_638]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [edx]
		push	ecx
		call	?compareCE64s@@YA?AW4UCompareCEsResult@@_J0F@Z ; compareCE64s(__int64,__int64,short)
		add	esp, 14h
		mov	[ebp+var_6B4], eax
		cmp	[ebp+var_6B4], 0
		jnz	short loc_31AD
		mov	[ebp+var_64D], 0
		jmp	short loc_31F3
; ---------------------------------------------------------------------------
		jmp	short loc_31EE
; ---------------------------------------------------------------------------

loc_31AD:				; CODE XREF: _usearch_search_56+210j
		cmp	[ebp+var_6B4], 0
		jle	short loc_31EE
		cmp	[ebp+var_6B4], 1
		jnz	short loc_31DF
		mov	eax, [ebp+var_644]
		sub	eax, 1
		mov	[ebp+var_644], eax
		mov	eax, [ebp+var_68C]
		add	eax, 1
		mov	[ebp+var_68C], eax
		jmp	short loc_31EE
; ---------------------------------------------------------------------------

loc_31DF:				; CODE XREF: _usearch_search_56+22Dj
		mov	eax, [ebp+var_68C]
		sub	eax, 1
		mov	[ebp+var_68C], eax

loc_31EE:				; CODE XREF: _usearch_search_56+21Bj
					; _usearch_search_56+224j ...
		jmp	loc_30FC
; ---------------------------------------------------------------------------

loc_31F3:				; CODE XREF: _usearch_search_56+18Aj
					; _usearch_search_56+219j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_68C]
		add	ecx, [eax+418h]
		mov	[ebp+var_68C], ecx
		movsx	eax, [ebp+var_64D]
		test	eax, eax
		jnz	short loc_3247
		cmp	[ebp+var_638], 0
		jz	short loc_3242
		mov	eax, [ebp+var_638]
		mov	[ebp+var_7D0], eax
		mov	ecx, [ebp+var_7D0]
		cmp	dword ptr [ecx], 0FFFFFFFFh
		jnz	short loc_3242
		mov	edx, [ebp+var_7D0]
		cmp	dword ptr [edx+4], 7FFFFFFFh
		jz	short loc_3247

loc_3242:				; CODE XREF: _usearch_search_56+28Aj
					; _usearch_search_56+2A1j
		jmp	loc_3086
; ---------------------------------------------------------------------------

loc_3247:				; CODE XREF: _usearch_search_56+281j
					; _usearch_search_56+2B0j
		movsx	eax, [ebp+var_64D]
		test	eax, eax
		jnz	short loc_3257
		jmp	loc_36DB
; ---------------------------------------------------------------------------

loc_3257:				; CODE XREF: _usearch_search_56+2C0j
		mov	eax, [ebp+var_68C]
		mov	ecx, [ebp+var_62C]
		lea	edx, [ecx+eax-1]
		push	edx
		lea	ecx, [ebp+var_620]
		call	?get@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z ; icu_56::`anonymous	namespace'::CEIBuffer::get(int)
		mov	[ebp+var_6C0], eax
		mov	eax, [ebp+var_6A8]
		mov	ecx, [eax+8]
		mov	[ebp+var_65C], ecx
		mov	eax, [ebp+var_6C0]
		mov	ecx, [eax+8]
		mov	[ebp+var_674], ecx
		mov	[ebp+var_6CC], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movsx	edx, word ptr [ecx+0Ah]
		test	edx, edx
		jnz	short loc_3321
		mov	eax, [ebp+var_62C]
		add	eax, [ebp+var_68C]
		push	eax
		lea	ecx, [ebp+var_620]
		call	?get@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z ; icu_56::`anonymous	namespace'::CEIBuffer::get(int)
		mov	[ebp+var_6CC], eax
		mov	eax, [ebp+var_6CC]
		mov	ecx, [eax+8]
		mov	[ebp+var_680], ecx
		mov	eax, [ebp+var_6CC]
		mov	ecx, [ebp+var_6CC]
		mov	edx, [eax+8]
		cmp	edx, [ecx+0Ch]
		jnz	short loc_331C
		mov	eax, [ebp+var_6CC]
		mov	[ebp+var_7D0], eax
		mov	ecx, [ebp+var_7D0]
		cmp	dword ptr [ecx], 0FFFFFFFFh
		jnz	short loc_3315
		mov	edx, [ebp+var_7D0]
		cmp	dword ptr [edx+4], 7FFFFFFFh
		jz	short loc_331C

loc_3315:				; CODE XREF: _usearch_search_56+374j
		mov	[ebp+var_64D], 0

loc_331C:				; CODE XREF: _usearch_search_56+35Dj
					; _usearch_search_56+383j
		jmp	loc_3434
; ---------------------------------------------------------------------------

loc_3321:				; CODE XREF: _usearch_search_56+31Cj
		jmp	short loc_3332
; ---------------------------------------------------------------------------

loc_3323:				; CODE XREF: _usearch_search_56:loc_342Fj
		mov	eax, [ebp+var_68C]
		add	eax, 1
		mov	[ebp+var_68C], eax

loc_3332:				; CODE XREF: _usearch_search_56:loc_3321j
		mov	eax, [ebp+var_62C]
		add	eax, [ebp+var_68C]
		push	eax
		lea	ecx, [ebp+var_620]
		call	?get@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z ; icu_56::`anonymous	namespace'::CEIBuffer::get(int)
		mov	[ebp+var_6CC], eax
		mov	eax, [ebp+var_6CC]
		mov	ecx, [eax+8]
		mov	[ebp+var_680], ecx
		mov	eax, [ebp+var_6CC]
		mov	[ebp+var_7D0], eax
		mov	ecx, [ebp+var_7D0]
		cmp	dword ptr [ecx], 0FFFFFFFFh
		jnz	short loc_338A
		mov	edx, [ebp+var_7D0]
		cmp	dword ptr [edx+4], 7FFFFFFFh
		jnz	short loc_338A
		jmp	loc_3434
; ---------------------------------------------------------------------------

loc_338A:				; CODE XREF: _usearch_search_56+3E4j
					; _usearch_search_56+3F3j
		mov	ecx, [ebp+var_6CC]
		mov	eax, [ecx]
		mov	edx, [ecx+4]
		mov	cl, 20h	; ' '
		call	__allshr
		and	eax, 0FFFF0000h
		and	edx, 0
		mov	[ebp+var_7D4], eax
		mov	[ebp+var_7D0], edx
		mov	edx, [ebp+var_7D4]
		or	edx, [ebp+var_7D0]
		jnz	short loc_340E
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movzx	edx, word ptr [ecx+0Ah]
		push	edx
		mov	eax, [ebp+var_698]
		push	eax
		mov	ecx, [ebp+var_69C]
		push	ecx
		mov	edx, [ebp+var_6CC]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [edx]
		push	ecx
		call	?compareCE64s@@YA?AW4UCompareCEsResult@@_J0F@Z ; compareCE64s(__int64,__int64,short)
		add	esp, 14h
		mov	[ebp+var_6D8], eax
		cmp	[ebp+var_6D8], 0
		jz	short loc_3403
		cmp	[ebp+var_6D8], 2
		jnz	short loc_340C

loc_3403:				; CODE XREF: _usearch_search_56+468j
		mov	[ebp+var_64D], 0
		jmp	short loc_3434
; ---------------------------------------------------------------------------

loc_340C:				; CODE XREF: _usearch_search_56+471j
		jmp	short loc_342F
; ---------------------------------------------------------------------------

loc_340E:				; CODE XREF: _usearch_search_56+42Cj
		mov	eax, [ebp+var_6CC]
		mov	ecx, [ebp+var_6CC]
		mov	edx, [eax+8]
		cmp	edx, [ecx+0Ch]
		jnz	short loc_342D
		mov	[ebp+var_64D], 0
		jmp	short loc_3434
; ---------------------------------------------------------------------------
		jmp	short loc_342F
; ---------------------------------------------------------------------------

loc_342D:				; CODE XREF: _usearch_search_56+490j
		jmp	short loc_3434
; ---------------------------------------------------------------------------

loc_342F:				; CODE XREF: _usearch_search_56:loc_340Cj
					; _usearch_search_56+49Bj
		jmp	loc_3323
; ---------------------------------------------------------------------------

loc_3434:				; CODE XREF: _usearch_search_56:loc_331Cj
					; _usearch_search_56+3F5j ...
		mov	eax, [ebp+var_65C]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?isBreakBoundary@@YACPAUUStringSearch@@H@Z ; isBreakBoundary(UStringSearch *,int)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jnz	short loc_3455
		mov	[ebp+var_64D], 0

loc_3455:				; CODE XREF: _usearch_search_56+4BCj
		mov	eax, [ebp+var_6A8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_6E4], ecx
		mov	eax, [ebp+var_65C]
		cmp	eax, [ebp+var_6E4]
		jnz	short loc_3479
		mov	[ebp+var_64D], 0

loc_3479:				; CODE XREF: _usearch_search_56+4E0j
		mov	[ebp+var_6ED], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	dword ptr [ecx], 0
		jz	loc_35BA
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		cmp	edx, [ebp+var_680]
		jle	loc_35BA
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+10h], 0
		jnz	loc_35A7
		cmp	[ebp+var_6CC], 0
		jz	loc_35A7
		mov	edx, [ebp+var_6CC]
		mov	eax, [edx]
		mov	edx, [edx+4]
		mov	cl, 20h	; ' '
		call	__allshr
		and	eax, 0FFFF0000h
		and	edx, 0
		mov	[ebp+var_7D4], eax
		mov	[ebp+var_7D0], edx
		mov	eax, [ebp+var_7D4]
		or	eax, [ebp+var_7D0]
		jz	loc_35A7
		mov	ecx, [ebp+var_6C0]
		mov	edx, [ebp+var_680]
		cmp	edx, [ecx+0Ch]
		jl	loc_35A7
		mov	eax, [ebp+var_6CC]
		mov	ecx, [eax+0Ch]
		cmp	ecx, [ebp+var_680]
		jle	loc_35A7
		mov	edx, [ebp+var_680]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?codePointAt@?A0x7b251a59@@YAHABUUSearch@@H@Z ;	`anonymous namespace'::codePointAt(USearch const &,int)
		add	esp, 8
		mov	esi, esp
		push	eax
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+102Ch]
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+102Ch]
		mov	edx, [eax]
		mov	eax, [edx+30h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_359E
		mov	edx, [ebp+var_680]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?codePointBefore@?A0x7b251a59@@YAHABUUSearch@@H@Z ; `anonymous namespace'::codePointBefore(USearch const &,int)
		add	esp, 8
		mov	esi, esp
		push	eax
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+102Ch]
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+102Ch]
		mov	edx, [eax]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_35A7

loc_359E:				; CODE XREF: _usearch_search_56+5CDj
		mov	[ebp+var_7D5], 1
		jmp	short loc_35AE
; ---------------------------------------------------------------------------

loc_35A7:				; CODE XREF: _usearch_search_56+51Bj
					; _usearch_search_56+528j ...
		mov	[ebp+var_7D5], 0

loc_35AE:				; CODE XREF: _usearch_search_56+615j
		mov	dl, [ebp+var_7D5]
		mov	[ebp+var_6ED], dl

loc_35BA:				; CODE XREF: _usearch_search_56+4F8j
					; _usearch_search_56+50Cj
		mov	eax, [ebp+var_680]
		mov	[ebp+var_668], eax
		mov	eax, [ebp+var_674]
		cmp	eax, [ebp+var_680]
		jge	loc_3660
		mov	eax, [ebp+var_6C0]
		mov	ecx, [ebp+var_674]
		cmp	ecx, [eax+0Ch]
		jnz	short loc_3611
		mov	eax, [ebp+var_674]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?isBreakBoundary@@YACPAUUStringSearch@@H@Z ; isBreakBoundary(UStringSearch *,int)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_3611
		mov	eax, [ebp+var_674]
		mov	[ebp+var_668], eax
		jmp	short loc_3660
; ---------------------------------------------------------------------------

loc_3611:				; CODE XREF: _usearch_search_56+657j
					; _usearch_search_56+671j
		mov	eax, [ebp+var_674]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?nextBoundaryAfter@@YAHPAUUStringSearch@@H@Z ; nextBoundaryAfter(UStringSearch *,int)
		add	esp, 8
		mov	[ebp+var_6FC], eax
		mov	eax, [ebp+var_6C0]
		mov	ecx, [ebp+var_6FC]
		cmp	ecx, [eax+0Ch]
		jl	short loc_3660
		movsx	eax, [ebp+var_6ED]
		test	eax, eax
		jz	short loc_3654
		mov	eax, [ebp+var_6FC]
		cmp	eax, [ebp+var_680]
		jge	short loc_3660

loc_3654:				; CODE XREF: _usearch_search_56+6B4j
		mov	eax, [ebp+var_6FC]
		mov	[ebp+var_668], eax

loc_3660:				; CODE XREF: _usearch_search_56+642j
					; _usearch_search_56+67Fj ...
		movsx	eax, [ebp+var_6ED]
		test	eax, eax
		jnz	short loc_36A1
		mov	eax, [ebp+var_668]
		cmp	eax, [ebp+var_680]
		jle	short loc_3680
		mov	[ebp+var_64D], 0

loc_3680:				; CODE XREF: _usearch_search_56+6E7j
		mov	eax, [ebp+var_668]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?isBreakBoundary@@YACPAUUStringSearch@@H@Z ; isBreakBoundary(UStringSearch *,int)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jnz	short loc_36A1
		mov	[ebp+var_64D], 0

loc_36A1:				; CODE XREF: _usearch_search_56+6D9j
					; _usearch_search_56+708j
		mov	eax, [ebp+var_668]
		push	eax
		mov	ecx, [ebp+var_65C]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?checkIdentical@@YACPBUUStringSearch@@HH@Z ; checkIdentical(UStringSearch const	*,int,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jnz	short loc_36C9
		mov	[ebp+var_64D], 0

loc_36C9:				; CODE XREF: _usearch_search_56+730j
		movsx	eax, [ebp+var_64D]
		test	eax, eax
		jz	short loc_36D6
		jmp	short loc_36DB
; ---------------------------------------------------------------------------

loc_36D6:				; CODE XREF: _usearch_search_56+742j
		jmp	loc_3086
; ---------------------------------------------------------------------------

loc_36DB:				; CODE XREF: _usearch_search_56+15Bj
					; _usearch_search_56+2C2j ...
		movsx	eax, [ebp+var_64D]
		test	eax, eax
		jnz	short loc_36FA
		mov	[ebp+var_668], 0FFFFFFFFh
		mov	[ebp+var_65C], 0FFFFFFFFh

loc_36FA:				; CODE XREF: _usearch_search_56+754j
		cmp	[ebp+arg_8], 0
		jz	short loc_370B
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_65C]
		mov	[eax], ecx

loc_370B:				; CODE XREF: _usearch_search_56+76Ej
		cmp	[ebp+arg_C], 0
		jz	short loc_371C
		mov	eax, [ebp+arg_C]
		mov	ecx, [ebp+var_668]
		mov	[eax], ecx

loc_371C:				; CODE XREF: _usearch_search_56+77Fj
		mov	al, [ebp+var_64D]
		mov	[ebp+var_7C5], al
		lea	ecx, [ebp+var_620]
		call	??1CEIBuffer@?A0x7b251a59@icu_56@@QAE@XZ ; icu_56::`anonymous namespace'::CEIBuffer::~CEIBuffer(void)
		mov	al, [ebp+var_7C5]

loc_3739:				; CODE XREF: _usearch_search_56+3Fj
					; _usearch_search_56+74j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN58
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 7D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_search_56 endp

; ---------------------------------------------------------------------------
$LN58		dd 1			; DATA XREF: _usearch_search_56+7ADo
		dd offset $LN57
$LN57		dd 0FFFFF9E0h, 618h	; DATA XREF: .text:0000376Co
		dd offset $LN56
$LN56		dd 626563h		; DATA XREF: .text:00003778o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3780h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl initializePatternPCETable(int, enum UErrorCode *)
?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: _usearch_search_56+8Dp
					; _usearch_searchBackwards_56+8Dp ...

var_280		= byte ptr -280h
var_27A		= word ptr -27Ah
var_26E		= word ptr -26Eh
var_1A4		= dword	ptr -1A4h
var_198		= byte ptr -198h
var_70		= dword	ptr -70h
var_6C		= dword	ptr -6Ch
var_60		= word ptr -60h
var_54		= word ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
Src		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 274h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_280]
		mov	ecx, 9Dh ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	[ebp+var_18], eax
		mov	[ebp+var_24], 100h
		mov	eax, [ebp+var_18]
		add	eax, 418h
		mov	[ebp+Src], eax
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]
		mov	[ebp+var_3C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1038h]
		mov	[ebp+var_48], ecx
		cmp	[ebp+var_48], 0
		jnz	short loc_3827
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_3C]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	eax, [edx]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1028h]
		push	edx
		call	_ucol_openElements_56
		add	esp, 10h
		mov	[ebp+var_48], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_48]
		mov	[eax+1038h], ecx
		jmp	short loc_3844
; ---------------------------------------------------------------------------

loc_3827:				; CODE XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+74j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+var_48]
		push	edx
		call	_ucol_setText_56
		add	esp, 10h

loc_3844:				; CODE XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+A5j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3860
		xor	eax, eax
		jmp	loc_39FB
; ---------------------------------------------------------------------------

loc_3860:				; CODE XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+D7j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+414h]
		cmp	ecx, [ebp+Src]
		jz	short loc_388C
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+414h], 0
		jz	short loc_388C
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+414h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_388C:				; CODE XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+ECj
					; initializePatternPCETable(UStringSearch *,UErrorCode *)+F8j
		xor	eax, eax
		mov	[ebp+var_54], ax
		xor	eax, eax
		mov	[ebp+var_60], ax
		mov	eax, [ebp+var_48]
		push	eax		; struct UCollationElements *
		lea	ecx, [ebp+var_198] ; this
		call	??0UCollationPCE@icu_56@@QAE@PAUUCollationElements@@@Z ; icu_56::UCollationPCE::UCollationPCE(UCollationElements *)
		mov	[ebp+var_4], 0

loc_38AE:				; CODE XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+223j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		push	0		; int *
		push	0		; int *
		lea	ecx, [ebp+var_198] ; this
		call	?nextProcessed@UCollationPCE@icu_56@@QAE_JPAH0PAW4UErrorCode@@@Z ; icu_56::UCollationPCE::nextProcessed(int *,int *,UErrorCode *)
		mov	[ebp+var_70], eax
		mov	[ebp+var_6C], edx
		cmp	[ebp+var_70], 0FFFFFFFFh
		jnz	short loc_38DA
		cmp	[ebp+var_6C], 7FFFFFFFh
		jz	loc_39A8

loc_38DA:				; CODE XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+14Bj
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_39A8
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_48]
		push	ecx
		call	_ucol_getOffset_56
		add	esp, 4
		mov	edx, [ebp+var_3C]
		sub	edx, eax
		add	edx, 1
		push	edx		; int
		mov	eax, [ebp+var_6C]
		push	eax		; int
		mov	ecx, [ebp+var_70]
		push	ecx		; int
		lea	edx, [ebp+var_24]
		push	edx		; int
		movzx	eax, [ebp+var_54]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		call	?addTouint64_tArray@@YAPA_JPA_JIPAI_KIPAW4UErrorCode@@@Z ; addTouint64_tArray(__int64 *,uint,uint *,unsigned __int64,uint,UErrorCode *)
		add	esp, 1Ch
		mov	[ebp+var_1A4], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_396B
		xor	eax, eax
		mov	[ebp+var_27A], ax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_198] ; this
		call	??1UCollationPCE@icu_56@@QAE@XZ	; icu_56::UCollationPCE::~UCollationPCE(void)
		mov	ax, [ebp+var_27A]
		jmp	loc_39FB
; ---------------------------------------------------------------------------

loc_396B:				; CODE XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+1C2j
		movzx	eax, [ebp+var_54]
		add	eax, 1
		mov	[ebp+var_54], ax
		mov	eax, [ebp+Src]
		cmp	eax, [ebp+var_1A4]
		jz	short loc_399A
		mov	eax, [ebp+var_18]
		add	eax, 418h
		cmp	[ebp+Src], eax
		jz	short loc_399A
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_399A:				; CODE XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+1FFj
					; initializePatternPCETable(UStringSearch *,UErrorCode *)+20Cj
		mov	eax, [ebp+var_1A4]
		mov	[ebp+Src], eax
		jmp	loc_38AE
; ---------------------------------------------------------------------------

loc_39A8:				; CODE XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+154j
					; initializePatternPCETable(UStringSearch *,UErrorCode *)+16Dj
		movzx	eax, [ebp+var_54]
		mov	ecx, [ebp+Src]
		mov	dword ptr [ecx+eax*8], 0
		mov	dword ptr [ecx+eax*8+4], 0
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+Src]
		mov	[eax+414h], ecx
		movzx	eax, [ebp+var_54]
		mov	ecx, [ebp+var_18]
		mov	[ecx+410h], eax
		mov	ax, [ebp+var_60]
		mov	[ebp+var_26E], ax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_198] ; this
		call	??1UCollationPCE@icu_56@@QAE@XZ	; icu_56::UCollationPCE::~UCollationPCE(void)
		mov	ax, [ebp+var_26E]

loc_39FB:				; CODE XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+DBj
					; initializePatternPCETable(UStringSearch *,UErrorCode *)+1E6j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 280h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN17		dd 2			; DATA XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+27Fo
		dd offset $LN16
$LN16		dd 0FFFFFFDCh, 4	; DATA XREF: .text:00003A3Co
		dd offset $LN13_2	; "pcetablesize"
		dd 0FFFFFE68h, 120h
		dd offset $LN14_0	; "iter"
$LN14_0		db 'iter',0             ; DATA XREF: .text:00003A54o
$LN13_2		db 'pcetablesize',0     ; DATA XREF: .text:00003A48o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3A6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00003AA4o
		lea	ecx, [ebp-198h]	; this
		jmp	??1UCollationPCE@icu_56@@QAE@XZ	; icu_56::UCollationPCE::~UCollationPCE(void)
__unwindfunclet$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z	proc near
					; DATA XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-284h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3AA0h
__unwindtable$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003AB0o
		dd offset __unwindfunclet$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z$0
__ehfuncinfo$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3ACCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl addTouint64_tArray(void *Src, int, int, int, int,	int, int)
?addTouint64_tArray@@YAPA_JPA_JIPAI_KIPAW4UErrorCode@@@Z proc near
					; CODE XREF: initializePatternPCETable(UStringSearch *,UErrorCode *)+1A1p

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		add	eax, 1
		cmp	eax, [ebp+var_8]
		jnz	short loc_3B68
		mov	eax, [ebp+var_8]
		add	eax, [ebp+arg_14]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+var_8]
		shl	ecx, 3
		push	ecx
		call	?allocateMemory@@YAPAXIPAW4UErrorCode@@@Z ; allocateMemory(uint,UErrorCode *)
		add	esp, 8
		mov	[ebp+Dst], eax
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3B35
		xor	eax, eax
		jmp	short loc_3B7E
; ---------------------------------------------------------------------------

loc_3B35:				; CODE XREF: addTouint64_tArray(__int64	*,uint,uint *,unsigned __int64,uint,UErrorCode *)+63j
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+arg_4]
		shl	ecx, 3
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_8]
		mov	[eax], ecx
		mov	eax, [ebp+Dst]
		mov	[ebp+Src], eax

loc_3B68:				; CODE XREF: addTouint64_tArray(__int64	*,uint,uint *,unsigned __int64,uint,UErrorCode *)+2Fj
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+Src]
		mov	edx, [ebp+arg_C]
		mov	[ecx+eax*8], edx
		mov	edx, [ebp+arg_10]
		mov	[ecx+eax*8+4], edx
		mov	eax, [ebp+Src]

loc_3B7E:				; CODE XREF: addTouint64_tArray(__int64	*,uint,uint *,unsigned __int64,uint,UErrorCode *)+67j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?addTouint64_tArray@@YAPA_JPA_JIPAI_KIPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl checkIdentical(struct UStringSearch const	*, int,	int)
?checkIdentical@@YACPBUUStringSearch@@HH@Z proc	near ; CODE XREF: _usearch_search_56+723p
					; _usearch_searchBackwards_56+69Ap

var_210		= dword	ptr -210h
var_20C		= dword	ptr -20Ch
var_204		= byte ptr -204h
var_1BC		= byte ptr -1BCh
var_171		= byte ptr -171h
var_A8		= byte ptr -0A8h
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?checkIdentical@@YACPBUUStringSearch@@HH@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 204h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_210]
		mov	ecx, 81h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+1040h], 0Fh
		jz	short loc_3BE7
		mov	al, 1
		jmp	loc_3DBB
; ---------------------------------------------------------------------------

loc_3BE7:				; CODE XREF: checkIdentical(UStringSearch const	*,int,int)+4Aj
		mov	[ebp+var_18], 0
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	eax, [ebp+var_18]
		push	eax
		lea	ecx, [ebp+var_60]
		push	ecx
		mov	edx, [ebp+arg_8]
		sub	edx, [ebp+arg_4]
		mov	edi, esp
		push	edx		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_4]
		lea	ecx, [edx+eax*2]
		push	ecx		; wchar_t *
		push	0		; signed __int8
		lea	ecx, [ebp+var_204] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20C], eax
		mov	edx, [ebp+var_20C]
		mov	[ebp+var_210], edx
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_210]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+102Ch]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+102Ch]
		mov	edx, [edx]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_204] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	eax, [ebp+var_18]
		push	eax
		lea	ecx, [ebp+var_A8]
		push	ecx
		mov	edi, esp
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+0Ch]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		push	edx		; wchar_t *
		push	0		; signed __int8
		lea	ecx, [ebp+var_1BC] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20C], eax
		mov	eax, [ebp+var_20C]
		mov	[ebp+var_210], eax
		mov	byte ptr [ebp+var_4], 3
		mov	ecx, [ebp+var_210]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+102Ch]
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+102Ch]
		mov	edx, [eax]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_1BC] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_3D70
		mov	esi, esp
		lea	edx, [ebp+var_A8]
		push	edx
		lea	ecx, [ebp+var_60]
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_3D70
		mov	byte ptr [ebp+var_20C+3], 1
		jmp	short loc_3D77
; ---------------------------------------------------------------------------

loc_3D70:				; CODE XREF: checkIdentical(UStringSearch const	*,int,int)+1B1j
					; checkIdentical(UStringSearch const *,int,int)+1D1j
		mov	byte ptr [ebp+var_20C+3], 0

loc_3D77:				; CODE XREF: checkIdentical(UStringSearch const	*,int,int)+1DAj
		mov	cl, byte ptr [ebp+var_20C+3]
		mov	[ebp+var_171], cl
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_A8] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, [ebp+var_171]

loc_3DBB:				; CODE XREF: checkIdentical(UStringSearch const	*,int,int)+4Ej
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN15
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 210h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?checkIdentical@@YACPBUUStringSearch@@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN15		dd 3			; DATA XREF: checkIdentical(UStringSearch const	*,int,int)+22Bo
		dd offset $LN14_1
$LN14_1		dd 0FFFFFFE8h, 4	; DATA XREF: .text:00003DFCo
		dd offset $LN10_0	; "status"
		dd 0FFFFFFA0h, 40h
		dd offset $LN11_1
		dd 0FFFFFF58h, 40h
		dd offset $LN12_1
$LN12_1		db 70h,	32h, 0		; DATA XREF: .text:00003E20o
$LN11_1		db 74h			; DATA XREF: .text:00003E14o
		db 32h,	0
$LN10_0		db 'status',0           ; DATA XREF: .text:00003E08o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3E34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$0 proc near
					; DATA XREF: .xdata$x:00003EB4o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$1 proc near
					; DATA XREF: .xdata$x:00003EBCo
		mov	esi, esp
		lea	ecx, [ebp-0A8h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$2 proc near
					; DATA XREF: .xdata$x:00003EC4o
		mov	esi, esp
		lea	ecx, [ebp-204h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$3 proc near
					; DATA XREF: .xdata$x:00003ECCo
		mov	esi, esp
		lea	ecx, [ebp-1BCh]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?checkIdentical@@YACPBUUStringSearch@@HH@Z proc near
					; DATA XREF: checkIdentical(UStringSearch const	*,int,int)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-214h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?checkIdentical@@YACPBUUStringSearch@@HH@Z
		jmp	___CxxFrameHandler3
__ehhandler$?checkIdentical@@YACPBUUStringSearch@@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3EB0h
__unwindtable$?checkIdentical@@YACPBUUStringSearch@@HH@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003ED8o
		dd offset __unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$0
		dd 0
		dd offset __unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$1
		dd 1
		dd offset __unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$2
		dd 1
		dd offset __unwindfunclet$?checkIdentical@@YACPBUUStringSearch@@HH@Z$3
__ehfuncinfo$?checkIdentical@@YACPBUUStringSearch@@HH@Z	dd 19930522h, 4
					; DATA XREF: __ehhandler$?checkIdentical@@YACPBUUStringSearch@@HH@Z+1Eo
		dd offset __unwindtable$?checkIdentical@@YACPBUUStringSearch@@HH@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3EF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl nextBoundaryAfter(struct UStringSearch *,	int)
?nextBoundaryAfter@@YAHPAUUStringSearch@@H@Z proc near ; CODE XREF: _usearch_search_56+68Cp
					; _usearch_searchBackwards_56+5A5p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+10h]
		mov	[ebp+var_8], edx
		cmp	[ebp+var_8], 0
		jnz	short loc_3F2E
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+0Ch]
		mov	[ebp+var_8], edx

loc_3F2E:				; CODE XREF: nextBoundaryAfter(UStringSearch *,int)+2Dj
		cmp	[ebp+var_8], 0
		jz	short loc_3F46
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	_ubrk_following_56
		add	esp, 8
		jmp	short loc_3F49
; ---------------------------------------------------------------------------

loc_3F46:				; CODE XREF: nextBoundaryAfter(UStringSearch *,int)+3Ej
		mov	eax, [ebp+arg_4]

loc_3F49:				; CODE XREF: nextBoundaryAfter(UStringSearch *,int)+50j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?nextBoundaryAfter@@YAHPAUUStringSearch@@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isBreakBoundary(struct UStringSearch *, int)
?isBreakBoundary@@YACPAUUStringSearch@@H@Z proc	near ; CODE XREF: _usearch_search_56+4AFp
					; _usearch_search_56+664p ...

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+10h]
		mov	[ebp+var_8], edx
		cmp	[ebp+var_8], 0
		jnz	short loc_3F9A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+0Ch]
		mov	[ebp+var_8], edx

loc_3F9A:				; CODE XREF: isBreakBoundary(UStringSearch *,int)+2Dj
		cmp	[ebp+var_8], 0
		jz	short loc_3FC0
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	_ubrk_isBoundary_56
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_3FC0
		mov	[ebp+var_CD], 1
		jmp	short loc_3FC7
; ---------------------------------------------------------------------------

loc_3FC0:				; CODE XREF: isBreakBoundary(UStringSearch *,int)+3Ej
					; isBreakBoundary(UStringSearch	*,int)+55j
		mov	[ebp+var_CD], 0

loc_3FC7:				; CODE XREF: isBreakBoundary(UStringSearch *,int)+5Ej
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isBreakBoundary@@YACPAUUStringSearch@@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; enum	UCompareCEsResult __cdecl compareCE64s(__int64,	__int64, short)
?compareCE64s@@YA?AW4UCompareCEsResult@@_J0F@Z proc near
					; CODE XREF: _usearch_search_56+1FBp
					; _usearch_search_56+453p ...

var_13C		= dword	ptr -13Ch
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= word ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 13Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Fh ; 'O'
		mov	eax, 0CCCCCCCCh

loc_4000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_8]
		jnz	short loc_401A
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_C]
		jnz	short loc_401A
		or	eax, 0FFFFFFFFh
		jmp	loc_41B3
; ---------------------------------------------------------------------------

loc_401A:				; CODE XREF: compareCE64s(__int64,__int64,short)+24j
					; compareCE64s(__int64,__int64,short)+2Cj
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jnz	short loc_4029
		xor	eax, eax
		jmp	loc_41B3
; ---------------------------------------------------------------------------

loc_4029:				; CODE XREF: compareCE64s(__int64,__int64,short)+3Cj
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	cl, 20h	; ' '
		call	__allshr
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], edx
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_C]
		mov	cl, 20h	; ' '
		call	__allshr
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], edx
		mov	[ebp+var_2C], 0FFFF0000h
		mov	[ebp+var_28], 0
		mov	eax, [ebp+var_C]
		and	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_8]
		and	ecx, [ebp+var_28]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_1C]
		and	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_18]
		and	ecx, [ebp+var_28]
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_44]
		jz	short loc_40B3
		cmp	[ebp+var_38], 0
		jnz	short loc_4093
		mov	eax, 1
		jmp	loc_41B3
; ---------------------------------------------------------------------------

loc_4093:				; CODE XREF: compareCE64s(__int64,__int64,short)+A3j
		cmp	[ebp+var_44], 0
		jnz	short loc_40AC
		movsx	eax, [ebp+arg_10]
		cmp	eax, 4
		jnz	short loc_40AC
		mov	eax, 2
		jmp	loc_41B3
; ---------------------------------------------------------------------------

loc_40AC:				; CODE XREF: compareCE64s(__int64,__int64,short)+B3j
					; compareCE64s(__int64,__int64,short)+BCj
		xor	eax, eax
		jmp	loc_41B3
; ---------------------------------------------------------------------------

loc_40B3:				; CODE XREF: compareCE64s(__int64,__int64,short)+9Dj
		mov	[ebp+var_2C], 0FFFFh
		mov	[ebp+var_28], 0
		mov	eax, [ebp+var_C]
		and	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_8]
		and	ecx, [ebp+var_28]
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_1C]
		and	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_18]
		and	ecx, [ebp+var_28]
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_5C]
		jz	short loc_4143
		cmp	[ebp+var_50], 0
		jnz	short loc_40F7
		mov	eax, 1
		jmp	loc_41B3
; ---------------------------------------------------------------------------

loc_40F7:				; CODE XREF: compareCE64s(__int64,__int64,short)+107j
		cmp	[ebp+var_5C], 0
		jnz	short loc_4110
		movsx	eax, [ebp+arg_10]
		cmp	eax, 4
		jnz	short loc_4110
		mov	eax, 2
		jmp	loc_41B3
; ---------------------------------------------------------------------------

loc_4110:				; CODE XREF: compareCE64s(__int64,__int64,short)+117j
					; compareCE64s(__int64,__int64,short)+120j
		cmp	[ebp+var_5C], 5
		jz	short loc_4131
		movsx	eax, [ebp+arg_10]
		cmp	eax, 4
		jnz	short loc_4125
		cmp	[ebp+var_50], 5
		jz	short loc_4131

loc_4125:				; CODE XREF: compareCE64s(__int64,__int64,short)+139j
		mov	[ebp+var_13C], 0
		jmp	short loc_413B
; ---------------------------------------------------------------------------

loc_4131:				; CODE XREF: compareCE64s(__int64,__int64,short)+130j
					; compareCE64s(__int64,__int64,short)+13Fj
		mov	[ebp+var_13C], 0FFFFFFFFh

loc_413B:				; CODE XREF: compareCE64s(__int64,__int64,short)+14Bj
		mov	eax, [ebp+var_13C]
		jmp	short loc_41B3
; ---------------------------------------------------------------------------

loc_4143:				; CODE XREF: compareCE64s(__int64,__int64,short)+101j
		mov	[ebp+var_2C], 0FFFF0000h
		mov	[ebp+var_28], 0
		mov	eax, [ebp+arg_0]
		and	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_4]
		and	ecx, [ebp+var_28]
		mov	[ebp+var_68], eax
		mov	eax, [ebp+arg_8]
		and	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_C]
		and	ecx, [ebp+var_28]
		mov	[ebp+var_74], eax
		mov	eax, [ebp+var_68]
		cmp	eax, [ebp+var_74]
		jz	short loc_41B0
		cmp	[ebp+var_74], 50000h
		jz	short loc_419E
		movsx	eax, [ebp+arg_10]
		cmp	eax, 4
		jnz	short loc_4192
		cmp	[ebp+var_68], 50000h
		jz	short loc_419E

loc_4192:				; CODE XREF: compareCE64s(__int64,__int64,short)+1A3j
		mov	[ebp+var_13C], 0
		jmp	short loc_41A8
; ---------------------------------------------------------------------------

loc_419E:				; CODE XREF: compareCE64s(__int64,__int64,short)+19Aj
					; compareCE64s(__int64,__int64,short)+1ACj
		mov	[ebp+var_13C], 0FFFFFFFFh

loc_41A8:				; CODE XREF: compareCE64s(__int64,__int64,short)+1B8j
		mov	eax, [ebp+var_13C]
		jmp	short loc_41B3
; ---------------------------------------------------------------------------

loc_41B0:				; CODE XREF: compareCE64s(__int64,__int64,short)+191j
		or	eax, 0FFFFFFFFh

loc_41B3:				; CODE XREF: compareCE64s(__int64,__int64,short)+31j
					; compareCE64s(__int64,__int64,short)+40j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?compareCE64s@@YA?AW4UCompareCEsResult@@_J0F@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_searchBackwards_56(int, int, int,	int, enum UErrorCode *)
		public _usearch_searchBackwards_56
_usearch_searchBackwards_56 proc near	; CODE XREF: _usearch_handlePreviousExact_56+180p
					; _usearch_handlePreviousCanonical_56+180p

var_7F0		= byte ptr -7F0h
var_7ED		= byte ptr -7EDh
var_7EC		= dword	ptr -7ECh
var_7E8		= dword	ptr -7E8h
var_7DD		= byte ptr -7DDh
var_714		= dword	ptr -714h
var_708		= dword	ptr -708h
var_6F9		= byte ptr -6F9h
var_6F0		= dword	ptr -6F0h
var_6E4		= dword	ptr -6E4h
var_6D8		= dword	ptr -6D8h
var_6CC		= dword	ptr -6CCh
var_6C8		= dword	ptr -6C8h
var_6BC		= dword	ptr -6BCh
var_6B0		= dword	ptr -6B0h
var_6A4		= dword	ptr -6A4h
var_698		= dword	ptr -698h
var_68C		= dword	ptr -68Ch
var_680		= dword	ptr -680h
var_674		= dword	ptr -674h
var_665		= byte ptr -665h
var_65C		= dword	ptr -65Ch
var_650		= dword	ptr -650h
var_644		= dword	ptr -644h
var_638		= dword	ptr -638h
var_62C		= dword	ptr -62Ch
var_620		= byte ptr -620h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 7F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_7F0]
		mov	ecx, 1FCh
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_420C
		xor	al, al
		jmp	loc_48E8
; ---------------------------------------------------------------------------

loc_420C:				; CODE XREF: _usearch_searchBackwards_56+3Bj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_4231
		cmp	[ebp+arg_4], 0
		jl	short loc_4231
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+4]
		jg	short loc_4231
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_4241

loc_4231:				; CODE XREF: _usearch_searchBackwards_56+4Bj
					; _usearch_searchBackwards_56+51j ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	loc_48E8
; ---------------------------------------------------------------------------

loc_4241:				; CODE XREF: _usearch_searchBackwards_56+67j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+41Ch], 0
		jnz	short loc_425D
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z ; initializePatternPCETable(UStringSearch *,UErrorCode *)
		add	esp, 8

loc_425D:				; CODE XREF: _usearch_searchBackwards_56+83j
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		lea	ecx, [ebp+var_620]
		call	??0CEIBuffer@?A0x7b251a59@icu_56@@QAE@PAUUStringSearch@@PAW4UErrorCode@@@Z ; icu_56::`anonymous	namespace'::CEIBuffer::CEIBuffer(UStringSearch *,UErrorCode *)
		mov	[ebp+var_62C], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+4]
		jge	short loc_4306
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+0Ch]
		mov	[ebp+var_638], edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_638]
		push	ecx
		call	_ubrk_following_56
		add	esp, 8
		mov	[ebp+var_644], eax
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_644]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1030h]
		push	eax
		call	_ucol_setOffset_56
		add	esp, 0Ch
		mov	[ebp+var_62C], 0
		jmp	short loc_42E6
; ---------------------------------------------------------------------------

loc_42D7:				; CODE XREF: _usearch_searchBackwards_56:loc_4302j
		mov	eax, [ebp+var_62C]
		add	eax, 1
		mov	[ebp+var_62C], eax

loc_42E6:				; CODE XREF: _usearch_searchBackwards_56+10Dj
		mov	eax, [ebp+var_62C]
		push	eax
		lea	ecx, [ebp+var_620]
		call	?getPrevious@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z ; icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)
		mov	ecx, [eax+8]
		cmp	ecx, [ebp+arg_4]
		jge	short loc_4302
		jmp	short loc_4304
; ---------------------------------------------------------------------------

loc_4302:				; CODE XREF: _usearch_searchBackwards_56+136j
		jmp	short loc_42D7
; ---------------------------------------------------------------------------

loc_4304:				; CODE XREF: _usearch_searchBackwards_56+138j
		jmp	short loc_4320
; ---------------------------------------------------------------------------

loc_4306:				; CODE XREF: _usearch_searchBackwards_56+BDj
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1030h]
		push	eax
		call	_ucol_setOffset_56
		add	esp, 0Ch

loc_4320:				; CODE XREF: _usearch_searchBackwards_56:loc_4304j
		mov	[ebp+var_650], 0
		mov	eax, [ebp+var_62C]
		mov	[ebp+var_674], eax
		mov	[ebp+var_680], 0FFFFFFFFh
		mov	[ebp+var_68C], 0FFFFFFFFh
		mov	eax, [ebp+var_674]
		mov	[ebp+var_62C], eax
		jmp	short loc_4367
; ---------------------------------------------------------------------------

loc_4358:				; CODE XREF: _usearch_searchBackwards_56:loc_44F8j
					; _usearch_searchBackwards_56:loc_4885j
		mov	eax, [ebp+var_62C]
		add	eax, 1
		mov	[ebp+var_62C], eax

loc_4367:				; CODE XREF: _usearch_searchBackwards_56+18Ej
		mov	[ebp+var_665], 1
		mov	eax, [ebp+var_62C]
		push	eax
		lea	ecx, [ebp+var_620]
		call	?getPrevious@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z ; icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)
		mov	[ebp+var_6B0], eax
		cmp	[ebp+var_6B0], 0
		jnz	short loc_43A4
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 5
		mov	[ebp+var_665], 0
		jmp	loc_488A
; ---------------------------------------------------------------------------

loc_43A4:				; CODE XREF: _usearch_searchBackwards_56+1C5j
		mov	[ebp+var_6BC], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+418h]
		sub	ecx, 1
		mov	[ebp+var_65C], ecx
		jmp	short loc_43D1
; ---------------------------------------------------------------------------

loc_43C2:				; CODE XREF: _usearch_searchBackwards_56:loc_44B9j
		mov	eax, [ebp+var_65C]
		sub	eax, 1
		mov	[ebp+var_65C], eax

loc_43D1:				; CODE XREF: _usearch_searchBackwards_56+1F8j
		cmp	[ebp+var_65C], 0
		jl	loc_44BE
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+41Ch]
		mov	edx, [ebp+var_65C]
		mov	eax, [ecx+edx*8]
		mov	[ebp+var_6CC], eax
		mov	ecx, [ecx+edx*8+4]
		mov	[ebp+var_6C8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+418h]
		mov	edx, [ebp+var_62C]
		lea	eax, [edx+ecx-1]
		sub	eax, [ebp+var_65C]
		add	eax, [ebp+var_6BC]
		push	eax
		lea	ecx, [ebp+var_620]
		call	?getPrevious@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z ; icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)
		mov	[ebp+var_650], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movzx	edx, word ptr [ecx+0Ah]
		push	edx
		mov	eax, [ebp+var_6C8]
		push	eax
		mov	ecx, [ebp+var_6CC]
		push	ecx
		mov	edx, [ebp+var_650]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [edx]
		push	ecx
		call	?compareCE64s@@YA?AW4UCompareCEsResult@@_J0F@Z ; compareCE64s(__int64,__int64,short)
		add	esp, 14h
		mov	[ebp+var_6D8], eax
		cmp	[ebp+var_6D8], 0
		jnz	short loc_4478
		mov	[ebp+var_665], 0
		jmp	short loc_44BE
; ---------------------------------------------------------------------------
		jmp	short loc_44B9
; ---------------------------------------------------------------------------

loc_4478:				; CODE XREF: _usearch_searchBackwards_56+2A3j
		cmp	[ebp+var_6D8], 0
		jle	short loc_44B9
		cmp	[ebp+var_6D8], 1
		jnz	short loc_44AA
		mov	eax, [ebp+var_65C]
		add	eax, 1
		mov	[ebp+var_65C], eax
		mov	eax, [ebp+var_6BC]
		add	eax, 1
		mov	[ebp+var_6BC], eax
		jmp	short loc_44B9
; ---------------------------------------------------------------------------

loc_44AA:				; CODE XREF: _usearch_searchBackwards_56+2C0j
		mov	eax, [ebp+var_6BC]
		sub	eax, 1
		mov	[ebp+var_6BC], eax

loc_44B9:				; CODE XREF: _usearch_searchBackwards_56+2AEj
					; _usearch_searchBackwards_56+2B7j ...
		jmp	loc_43C2
; ---------------------------------------------------------------------------

loc_44BE:				; CODE XREF: _usearch_searchBackwards_56+210j
					; _usearch_searchBackwards_56+2ACj
		movsx	eax, [ebp+var_665]
		test	eax, eax
		jnz	short loc_44FD
		cmp	[ebp+var_650], 0
		jz	short loc_44F8
		mov	eax, [ebp+var_650]
		mov	[ebp+var_7E8], eax
		mov	ecx, [ebp+var_7E8]
		cmp	dword ptr [ecx], 0FFFFFFFFh
		jnz	short loc_44F8
		mov	edx, [ebp+var_7E8]
		cmp	dword ptr [edx+4], 7FFFFFFFh
		jz	short loc_44FD

loc_44F8:				; CODE XREF: _usearch_searchBackwards_56+308j
					; _usearch_searchBackwards_56+31Fj
		jmp	loc_4358
; ---------------------------------------------------------------------------

loc_44FD:				; CODE XREF: _usearch_searchBackwards_56+2FFj
					; _usearch_searchBackwards_56+32Ej
		movsx	eax, [ebp+var_665]
		test	eax, eax
		jnz	short loc_450D
		jmp	loc_488A
; ---------------------------------------------------------------------------

loc_450D:				; CODE XREF: _usearch_searchBackwards_56+33Ej
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_62C]
		add	ecx, [eax+418h]
		mov	edx, [ebp+var_6BC]
		lea	eax, [ecx+edx-1]
		push	eax
		lea	ecx, [ebp+var_620]
		call	?getPrevious@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z ; icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)
		mov	[ebp+var_6E4], eax
		mov	eax, [ebp+var_6E4]
		mov	ecx, [eax+8]
		mov	[ebp+var_680], ecx
		mov	eax, [ebp+var_680]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?isBreakBoundary@@YACPAUUStringSearch@@H@Z ; isBreakBoundary(UStringSearch *,int)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jnz	short loc_4568
		mov	[ebp+var_665], 0

loc_4568:				; CODE XREF: _usearch_searchBackwards_56+397j
		mov	eax, [ebp+var_6E4]
		mov	ecx, [ebp+var_680]
		cmp	ecx, [eax+0Ch]
		jnz	short loc_4580
		mov	[ebp+var_665], 0

loc_4580:				; CODE XREF: _usearch_searchBackwards_56+3AFj
		mov	eax, [ebp+var_6B0]
		mov	ecx, [eax+8]
		mov	[ebp+var_698], ecx
		cmp	[ebp+var_62C], 0
		jle	loc_47F4
		mov	eax, [ebp+var_62C]
		sub	eax, 1
		push	eax
		lea	ecx, [ebp+var_620]
		call	?getPrevious@CEIBuffer@?A0x7b251a59@icu_56@@QAEPBUCEI@@H@Z ; icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)
		mov	[ebp+var_6F0], eax
		mov	eax, [ebp+var_6F0]
		mov	ecx, [ebp+var_6F0]
		mov	edx, [eax+8]
		cmp	edx, [ecx+0Ch]
		jnz	short loc_45F8
		mov	eax, [ebp+var_6F0]
		mov	[ebp+var_7E8], eax
		mov	ecx, [ebp+var_7E8]
		cmp	dword ptr [ecx], 0FFFFFFFFh
		jnz	short loc_45F1
		mov	edx, [ebp+var_7E8]
		cmp	dword ptr [edx+4], 7FFFFFFFh
		jz	short loc_45F8

loc_45F1:				; CODE XREF: _usearch_searchBackwards_56+418j
		mov	[ebp+var_665], 0

loc_45F8:				; CODE XREF: _usearch_searchBackwards_56+401j
					; _usearch_searchBackwards_56+427j
		mov	eax, [ebp+var_6F0]
		mov	ecx, [eax+8]
		mov	[ebp+var_6A4], ecx
		mov	edx, [ebp+var_6A4]
		mov	[ebp+var_68C], edx
		mov	[ebp+var_6F9], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	dword ptr [ecx], 0
		jz	loc_4754
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ecx+4]
		cmp	edx, [ebp+var_6A4]
		jle	loc_4754
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+10h], 0
		jnz	loc_4741
		cmp	[ebp+var_6F0], 0
		jz	loc_4741
		mov	edx, [ebp+var_6F0]
		mov	eax, [edx]
		mov	edx, [edx+4]
		mov	cl, 20h	; ' '
		call	__allshr
		and	eax, 0FFFF0000h
		and	edx, 0
		mov	[ebp+var_7EC], eax
		mov	[ebp+var_7E8], edx
		mov	eax, [ebp+var_7EC]
		or	eax, [ebp+var_7E8]
		jz	loc_4741
		mov	ecx, [ebp+var_6B0]
		mov	edx, [ebp+var_6A4]
		cmp	edx, [ecx+0Ch]
		jl	loc_4741
		mov	eax, [ebp+var_6F0]
		mov	ecx, [eax+0Ch]
		cmp	ecx, [ebp+var_6A4]
		jle	loc_4741
		mov	edx, [ebp+var_6A4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?codePointAt@?A0x7b251a59@@YAHABUUSearch@@H@Z ;	`anonymous namespace'::codePointAt(USearch const &,int)
		add	esp, 8
		mov	esi, esp
		push	eax
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+102Ch]
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+102Ch]
		mov	edx, [eax]
		mov	eax, [edx+30h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_4738
		mov	edx, [ebp+var_6A4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?codePointBefore@?A0x7b251a59@@YAHABUUSearch@@H@Z ; `anonymous namespace'::codePointBefore(USearch const &,int)
		add	esp, 8
		mov	esi, esp
		push	eax
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+102Ch]
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+102Ch]
		mov	edx, [eax]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_4741

loc_4738:				; CODE XREF: _usearch_searchBackwards_56+52Fj
		mov	[ebp+var_7ED], 1
		jmp	short loc_4748
; ---------------------------------------------------------------------------

loc_4741:				; CODE XREF: _usearch_searchBackwards_56+47Dj
					; _usearch_searchBackwards_56+48Aj ...
		mov	[ebp+var_7ED], 0

loc_4748:				; CODE XREF: _usearch_searchBackwards_56+577j
		mov	dl, [ebp+var_7ED]
		mov	[ebp+var_6F9], dl

loc_4754:				; CODE XREF: _usearch_searchBackwards_56+45Aj
					; _usearch_searchBackwards_56+46Ej
		mov	eax, [ebp+var_698]
		cmp	eax, [ebp+var_6A4]
		jge	short loc_47B1
		mov	eax, [ebp+var_698]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?nextBoundaryAfter@@YAHPAUUStringSearch@@H@Z ; nextBoundaryAfter(UStringSearch *,int)
		add	esp, 8
		mov	[ebp+var_708], eax
		mov	eax, [ebp+var_6B0]
		mov	ecx, [ebp+var_708]
		cmp	ecx, [eax+0Ch]
		jl	short loc_47B1
		movsx	eax, [ebp+var_6F9]
		test	eax, eax
		jz	short loc_47A5
		mov	eax, [ebp+var_708]
		cmp	eax, [ebp+var_6A4]
		jge	short loc_47B1

loc_47A5:				; CODE XREF: _usearch_searchBackwards_56+5CDj
		mov	eax, [ebp+var_708]
		mov	[ebp+var_68C], eax

loc_47B1:				; CODE XREF: _usearch_searchBackwards_56+598j
					; _usearch_searchBackwards_56+5C2j ...
		movsx	eax, [ebp+var_6F9]
		test	eax, eax
		jnz	short loc_47F2
		mov	eax, [ebp+var_68C]
		cmp	eax, [ebp+var_6A4]
		jle	short loc_47D1
		mov	[ebp+var_665], 0

loc_47D1:				; CODE XREF: _usearch_searchBackwards_56+600j
		mov	eax, [ebp+var_68C]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?isBreakBoundary@@YACPAUUStringSearch@@H@Z ; isBreakBoundary(UStringSearch *,int)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jnz	short loc_47F2
		mov	[ebp+var_665], 0

loc_47F2:				; CODE XREF: _usearch_searchBackwards_56+5F2j
					; _usearch_searchBackwards_56+621j
		jmp	short loc_4850
; ---------------------------------------------------------------------------

loc_47F4:				; CODE XREF: _usearch_searchBackwards_56+3CEj
		mov	eax, [ebp+var_698]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?nextBoundaryAfter@@YAHPAUUStringSearch@@H@Z ; nextBoundaryAfter(UStringSearch *,int)
		add	esp, 8
		mov	[ebp+var_714], eax
		cmp	[ebp+var_714], 0
		jle	short loc_482F
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_714]
		jle	short loc_482F
		mov	ecx, [ebp+var_714]
		mov	[ebp+var_7E8], ecx
		jmp	short loc_4838
; ---------------------------------------------------------------------------

loc_482F:				; CODE XREF: _usearch_searchBackwards_56+64Cj
					; _usearch_searchBackwards_56+657j
		mov	edx, [ebp+arg_4]
		mov	[ebp+var_7E8], edx

loc_4838:				; CODE XREF: _usearch_searchBackwards_56+665j
		mov	eax, [ebp+var_7E8]
		mov	[ebp+var_6A4], eax
		mov	ecx, [ebp+var_6A4]
		mov	[ebp+var_68C], ecx

loc_4850:				; CODE XREF: _usearch_searchBackwards_56:loc_47F2j
		mov	eax, [ebp+var_68C]
		push	eax
		mov	ecx, [ebp+var_680]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?checkIdentical@@YACPBUUStringSearch@@HH@Z ; checkIdentical(UStringSearch const	*,int,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jnz	short loc_4878
		mov	[ebp+var_665], 0

loc_4878:				; CODE XREF: _usearch_searchBackwards_56+6A7j
		movsx	eax, [ebp+var_665]
		test	eax, eax
		jz	short loc_4885
		jmp	short loc_488A
; ---------------------------------------------------------------------------

loc_4885:				; CODE XREF: _usearch_searchBackwards_56+6B9j
		jmp	loc_4358
; ---------------------------------------------------------------------------

loc_488A:				; CODE XREF: _usearch_searchBackwards_56+1D7j
					; _usearch_searchBackwards_56+340j ...
		movsx	eax, [ebp+var_665]
		test	eax, eax
		jnz	short loc_48A9
		mov	[ebp+var_68C], 0FFFFFFFFh
		mov	[ebp+var_680], 0FFFFFFFFh

loc_48A9:				; CODE XREF: _usearch_searchBackwards_56+6CBj
		cmp	[ebp+arg_8], 0
		jz	short loc_48BA
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_680]
		mov	[eax], ecx

loc_48BA:				; CODE XREF: _usearch_searchBackwards_56+6E5j
		cmp	[ebp+arg_C], 0
		jz	short loc_48CB
		mov	eax, [ebp+arg_C]
		mov	ecx, [ebp+var_68C]
		mov	[eax], ecx

loc_48CB:				; CODE XREF: _usearch_searchBackwards_56+6F6j
		mov	al, [ebp+var_665]
		mov	[ebp+var_7DD], al
		lea	ecx, [ebp+var_620]
		call	??1CEIBuffer@?A0x7b251a59@icu_56@@QAE@XZ ; icu_56::`anonymous namespace'::CEIBuffer::~CEIBuffer(void)
		mov	al, [ebp+var_7DD]

loc_48E8:				; CODE XREF: _usearch_searchBackwards_56+3Fj
					; _usearch_searchBackwards_56+74j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN54
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 7F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_searchBackwards_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN54		dd 1			; DATA XREF: _usearch_searchBackwards_56+724o
		dd offset $LN53
$LN53		dd 0FFFFF9E0h, 618h	; DATA XREF: .text:0000491Co
		dd offset $LN52
$LN52		dd 626563h		; DATA XREF: .text:00004928o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4930h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_handleNextExact_56(int, enum UErrorCode *)
		public _usearch_handleNextExact_56
_usearch_handleNextExact_56 proc near	; CODE XREF: _usearch_next_56+250p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4973
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al
		jmp	short loc_49E6
; ---------------------------------------------------------------------------

loc_4973:				; CODE XREF: _usearch_handleNextExact_56+31j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_getOffset_56
		add	esp, 4
		mov	[ebp+var_8], eax
		mov	[ebp+var_14], 0FFFFFFFFh
		mov	[ebp+var_20], 0FFFFFFFFh
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_20]
		push	ecx		; int
		lea	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_search_56
		add	esp, 14h
		movsx	edx, al
		test	edx, edx
		jz	short loc_49D8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		mov	[ecx+14h], edx
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[edx+18h], eax
		mov	al, 1
		jmp	short loc_49E6
; ---------------------------------------------------------------------------
		jmp	short loc_49E6
; ---------------------------------------------------------------------------

loc_49D8:				; CODE XREF: _usearch_handleNextExact_56+87j
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al

loc_49E6:				; CODE XREF: _usearch_handleNextExact_56+41j
					; _usearch_handleNextExact_56+A4j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_handleNextExact_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN9_2		dd 2			; DATA XREF: _usearch_handleNextExact_56+BAo
		dd offset $LN8_1
$LN8_1		dd 0FFFFFFECh, 4	; DATA XREF: .text:00004A10o
		dd offset $LN6_0	; "start"
		dd 0FFFFFFE0h, 4
		dd offset $LN7_2
$LN7_2		dd 646E65h		; DATA XREF: .text:00004A28o
$LN6_0		db 'start',0            ; DATA XREF: .text:00004A1Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_handleNextCanonical_56(int, enum UErrorCode *)
		public _usearch_handleNextCanonical_56
_usearch_handleNextCanonical_56	proc near ; CODE XREF: _usearch_next_56+23Ep

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4A7B
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al
		jmp	short loc_4AEE
; ---------------------------------------------------------------------------

loc_4A7B:				; CODE XREF: _usearch_handleNextCanonical_56+31j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_getOffset_56
		add	esp, 4
		mov	[ebp+var_8], eax
		mov	[ebp+var_14], 0FFFFFFFFh
		mov	[ebp+var_20], 0FFFFFFFFh
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_20]
		push	ecx		; int
		lea	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_search_56
		add	esp, 14h
		movsx	edx, al
		test	edx, edx
		jz	short loc_4AE0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		mov	[ecx+14h], edx
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[edx+18h], eax
		mov	al, 1
		jmp	short loc_4AEE
; ---------------------------------------------------------------------------
		jmp	short loc_4AEE
; ---------------------------------------------------------------------------

loc_4AE0:				; CODE XREF: _usearch_handleNextCanonical_56+87j
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al

loc_4AEE:				; CODE XREF: _usearch_handleNextCanonical_56+41j
					; _usearch_handleNextCanonical_56+A4j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_handleNextCanonical_56	endp

; ---------------------------------------------------------------------------
		align 4
$LN9_3		dd 2			; DATA XREF: _usearch_handleNextCanonical_56+BAo
		dd offset $LN8_2
$LN8_2		dd 0FFFFFFECh, 4	; DATA XREF: .text:00004B18o
		dd offset $LN6_1	; "start"
		dd 0FFFFFFE0h, 4
		dd offset $LN7_3
$LN7_3		dd 646E65h		; DATA XREF: .text:00004B30o
$LN6_1		db 'start',0            ; DATA XREF: .text:00004B24o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_handlePreviousExact_56(int, enum UErrorCode *)
		public _usearch_handlePreviousExact_56
_usearch_handlePreviousExact_56	proc near ; CODE XREF: _usearch_previous_56+1FEp

var_100		= byte ptr -100h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4B86
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al
		jmp	loc_4CFC
; ---------------------------------------------------------------------------

loc_4B86:				; CODE XREF: _usearch_handlePreviousExact_56+31j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movsx	edx, byte ptr [ecx+8]
		test	edx, edx
		jz	loc_4C89
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+14h], 0FFFFFFFFh
		jz	short loc_4BBE
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ecx+14h]
		mov	edx, [eax+18h]
		lea	eax, [ecx+edx-1]
		mov	[ebp+var_8], eax
		jmp	loc_4C87
; ---------------------------------------------------------------------------

loc_4BBE:				; CODE XREF: _usearch_handlePreviousExact_56+60j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z ; initializePatternPCETable(UStringSearch *,UErrorCode *)
		add	esp, 8
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z ; `anonymous namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jnz	short loc_4BF8
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al
		jmp	loc_4CFC
; ---------------------------------------------------------------------------

loc_4BF8:				; CODE XREF: _usearch_handlePreviousExact_56+A3j
		mov	[ebp+var_14], 0
		jmp	short loc_4C0A
; ---------------------------------------------------------------------------

loc_4C01:				; CODE XREF: _usearch_handlePreviousExact_56:loc_4C48j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_4C0A:				; CODE XREF: _usearch_handlePreviousExact_56+BFj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+418h]
		sub	ecx, 1
		cmp	[ebp+var_14], ecx
		jge	short loc_4C4A
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		push	0		; int *
		push	0		; int *
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+1034h] ; this
		call	?nextProcessed@UCollationPCE@icu_56@@QAE_JPAH0PAW4UErrorCode@@@Z ; icu_56::UCollationPCE::nextProcessed(int *,int *,UErrorCode *)
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], edx
		cmp	[ebp+var_24], 0FFFFFFFFh
		jnz	short loc_4C48
		cmp	[ebp+var_20], 7FFFFFFFh
		jnz	short loc_4C48
		jmp	short loc_4C4A
; ---------------------------------------------------------------------------

loc_4C48:				; CODE XREF: _usearch_handlePreviousExact_56+FBj
					; _usearch_handlePreviousExact_56+104j
		jmp	short loc_4C01
; ---------------------------------------------------------------------------

loc_4C4A:				; CODE XREF: _usearch_handlePreviousExact_56+D9j
					; _usearch_handlePreviousExact_56+106j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4C72
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al
		jmp	loc_4CFC
; ---------------------------------------------------------------------------

loc_4C72:				; CODE XREF: _usearch_handlePreviousExact_56+11Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_getOffset_56
		add	esp, 4
		mov	[ebp+var_8], eax

loc_4C87:				; CODE XREF: _usearch_handlePreviousExact_56+79j
		jmp	short loc_4C9E
; ---------------------------------------------------------------------------

loc_4C89:				; CODE XREF: _usearch_handlePreviousExact_56+51j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_getOffset_56
		add	esp, 4
		mov	[ebp+var_8], eax

loc_4C9E:				; CODE XREF: _usearch_handlePreviousExact_56:loc_4C87j
		mov	[ebp+var_30], 0FFFFFFFFh
		mov	[ebp+var_3C], 0FFFFFFFFh
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_3C]
		push	ecx		; int
		lea	edx, [ebp+var_30]
		push	edx		; int
		mov	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_searchBackwards_56
		add	esp, 14h
		movsx	edx, al
		test	edx, edx
		jz	short loc_4CEE
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_30]
		mov	[ecx+14h], edx
		mov	eax, [ebp+var_3C]
		sub	eax, [ebp+var_30]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[edx+18h], eax
		mov	al, 1
		jmp	short loc_4CFC
; ---------------------------------------------------------------------------
		jmp	short loc_4CFC
; ---------------------------------------------------------------------------

loc_4CEE:				; CODE XREF: _usearch_handlePreviousExact_56+18Dj
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al

loc_4CFC:				; CODE XREF: _usearch_handlePreviousExact_56+41j
					; _usearch_handlePreviousExact_56+B3j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN19
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_handlePreviousExact_56	endp

; ---------------------------------------------------------------------------
		align 4
$LN19		dd 2			; DATA XREF: _usearch_handlePreviousExact_56+1C0o
		dd offset $LN18
$LN18		dd 0FFFFFFD0h, 4	; DATA XREF: .text:00004D28o
		dd offset $LN16_0	; "start"
		dd 0FFFFFFC4h, 4
		dd offset $LN17_0
$LN17_0		dd 646E65h		; DATA XREF: .text:00004D40o
$LN16_0		db 'start',0            ; DATA XREF: .text:00004D34o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl usearch_handlePreviousCanonical_56(int, enum UErrorCode *)
		public _usearch_handlePreviousCanonical_56
_usearch_handlePreviousCanonical_56 proc near ;	CODE XREF: _usearch_previous_56+1ECp

var_100		= byte ptr -100h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4D96
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al
		jmp	loc_4F0C
; ---------------------------------------------------------------------------

loc_4D96:				; CODE XREF: _usearch_handlePreviousCanonical_56+31j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movsx	edx, byte ptr [ecx+8]
		test	edx, edx
		jz	loc_4E99
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+14h], 0FFFFFFFFh
		jz	short loc_4DCE
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ecx+14h]
		mov	edx, [eax+18h]
		lea	eax, [ecx+edx-1]
		mov	[ebp+var_8], eax
		jmp	loc_4E97
; ---------------------------------------------------------------------------

loc_4DCE:				; CODE XREF: _usearch_handlePreviousCanonical_56+60j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z ; initializePatternPCETable(UStringSearch *,UErrorCode *)
		add	esp, 8
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z ; `anonymous namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jnz	short loc_4E08
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al
		jmp	loc_4F0C
; ---------------------------------------------------------------------------

loc_4E08:				; CODE XREF: _usearch_handlePreviousCanonical_56+A3j
		mov	[ebp+var_14], 0
		jmp	short loc_4E1A
; ---------------------------------------------------------------------------

loc_4E11:				; CODE XREF: _usearch_handlePreviousCanonical_56:loc_4E58j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_4E1A:				; CODE XREF: _usearch_handlePreviousCanonical_56+BFj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+418h]
		sub	ecx, 1
		cmp	[ebp+var_14], ecx
		jge	short loc_4E5A
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		push	0		; int *
		push	0		; int *
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+1034h] ; this
		call	?nextProcessed@UCollationPCE@icu_56@@QAE_JPAH0PAW4UErrorCode@@@Z ; icu_56::UCollationPCE::nextProcessed(int *,int *,UErrorCode *)
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], edx
		cmp	[ebp+var_24], 0FFFFFFFFh
		jnz	short loc_4E58
		cmp	[ebp+var_20], 7FFFFFFFh
		jnz	short loc_4E58
		jmp	short loc_4E5A
; ---------------------------------------------------------------------------

loc_4E58:				; CODE XREF: _usearch_handlePreviousCanonical_56+FBj
					; _usearch_handlePreviousCanonical_56+104j
		jmp	short loc_4E11
; ---------------------------------------------------------------------------

loc_4E5A:				; CODE XREF: _usearch_handlePreviousCanonical_56+D9j
					; _usearch_handlePreviousCanonical_56+106j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4E82
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al
		jmp	loc_4F0C
; ---------------------------------------------------------------------------

loc_4E82:				; CODE XREF: _usearch_handlePreviousCanonical_56+11Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_getOffset_56
		add	esp, 4
		mov	[ebp+var_8], eax

loc_4E97:				; CODE XREF: _usearch_handlePreviousCanonical_56+79j
		jmp	short loc_4EAE
; ---------------------------------------------------------------------------

loc_4E99:				; CODE XREF: _usearch_handlePreviousCanonical_56+51j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1030h]
		push	ecx
		call	_ucol_getOffset_56
		add	esp, 4
		mov	[ebp+var_8], eax

loc_4EAE:				; CODE XREF: _usearch_handlePreviousCanonical_56:loc_4E97j
		mov	[ebp+var_30], 0FFFFFFFFh
		mov	[ebp+var_3C], 0FFFFFFFFh
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_3C]
		push	ecx		; int
		lea	edx, [ebp+var_30]
		push	edx		; int
		mov	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	_usearch_searchBackwards_56
		add	esp, 14h
		movsx	edx, al
		test	edx, edx
		jz	short loc_4EFE
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+var_30]
		mov	[ecx+14h], edx
		mov	eax, [ebp+var_3C]
		sub	eax, [ebp+var_30]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[edx+18h], eax
		mov	al, 1
		jmp	short loc_4F0C
; ---------------------------------------------------------------------------
		jmp	short loc_4F0C
; ---------------------------------------------------------------------------

loc_4EFE:				; CODE XREF: _usearch_handlePreviousCanonical_56+18Dj
		mov	eax, [ebp+arg_0]
		push	eax
		call	?setMatchNotFound@@YAXPAUUStringSearch@@@Z ; setMatchNotFound(UStringSearch *)
		add	esp, 4
		xor	al, al

loc_4F0C:				; CODE XREF: _usearch_handlePreviousCanonical_56+41j
					; _usearch_handlePreviousCanonical_56+B3j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN19_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_usearch_handlePreviousCanonical_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN19_0		dd 2			; DATA XREF: _usearch_handlePreviousCanonical_56+1C0o
		dd offset $LN18_0
$LN18_0		dd 0FFFFFFD0h, 4	; DATA XREF: .text:00004F38o
		dd offset $LN16_1	; "start"
		dd 0FFFFFFC4h, 4
		dd offset $LN17_1
$LN17_1		dd 646E65h		; DATA XREF: .text:00004F50o
$LN16_1		db 'start',0            ; DATA XREF: .text:00004F44o
_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn _ucol_close_56:near ; CODE XREF: _usearch_open_56+9Fp
					; _usearch_close_56+10Ap ...
		extrn _ucol_open_56:near ; CODE	XREF: _usearch_open_56+48p
		extrn __RTC_CheckEsp:near ; CODE XREF: _usearch_open_56+D2p
					; _usearch_openFromCollator_56+1B7p ...
		extrn _ucol_openElements_56:near
					; CODE XREF: _usearch_openFromCollator_56+2FDp
					; initializePatternCETable(UStringSearch *,UErrorCode *)+6Ap ...
		extrn _ubrk_setText_56:near ; CODE XREF: _usearch_openFromCollator_56+2B6p
					; _usearch_setBreakIterator_56+63p ...
		extrn _ubrk_open_56:near ; CODE	XREF: _usearch_openFromCollator_56+290p
					; _usearch_setCollator_56+192p
		extrn _ucol_getLocaleByType_56:near
					; CODE XREF: _usearch_openFromCollator_56+285p
					; _usearch_setCollator_56+187p
		extrn _uprv_free_56:near ; CODE	XREF: _usearch_openFromCollator_56+1DEp
					; _usearch_openFromCollator_56+211p ...
; const	struct icu_56::Normalizer2 *__cdecl static icu_56::Normalizer2::getNFDInstance(enum UErrorCode *)
		extrn __imp_?getNFDInstance@Normalizer2@icu_56@@SAPBV12@AAW4UErrorCode@@@Z:near
					; CODE XREF: _usearch_openFromCollator_56+1ACp
					; DATA XREF: _usearch_openFromCollator_56+1ACr
		extrn _ucol_getVariableTop_56:near
					; CODE XREF: _usearch_openFromCollator_56+195p
					; _usearch_setCollator_56+1CBp	...
		extrn _ucol_getStrength_56:near
					; CODE XREF: _usearch_openFromCollator_56+140p
					; _usearch_setCollator_56+12Bp	...
		extrn _uprv_malloc_56:near ; CODE XREF:	_usearch_openFromCollator_56+10Fp
					; _usearch_openFromCollator_56+1EFp ...
		extrn _u_strlen_56:near	; CODE XREF: _usearch_openFromCollator_56+CEp
					; _usearch_openFromCollator_56+E3p ...
		extrn _ucol_getAttribute_56:near
					; CODE XREF: _usearch_openFromCollator_56+66p
					; _usearch_openFromCollator_56+176p ...
		extrn _ucln_i18n_registerCleanup_56:near
					; CODE XREF: initializeFCD(UErrorCode *)+49p
; const	struct icu_56::Normalizer2Impl *__cdecl	static icu_56::Normalizer2Factory::getNFCImpl(enum UErrorCode *)
		extrn __imp_?getNFCImpl@Normalizer2Factory@icu_56@@SAPBVNormalizer2Impl@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: initializeFCD(UErrorCode *)+2Dp
					; DATA XREF: initializeFCD(UErrorCode *)+2Dr
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: initializePattern(UStringSearch *,UErrorCode *)+16Dp
					; getFCD(wchar_t const *,int *,int)+6Ep ...
; unsigned __int16 __thiscall icu_56::Normalizer2Impl::nextFCD16(icu_56::Normalizer2Impl *__hidden this, const wchar_t **, const wchar_t *)
		extrn __imp_?nextFCD16@Normalizer2Impl@icu_56@@QBEGAAPB_WPB_W@Z:near
					; CODE XREF: getFCD(wchar_t const *,int	*,int)+42p
					; DATA XREF: getFCD(wchar_t const *,int	*,int)+42r
		extrn _ucol_getMaxExpansion_56:near
					; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+1C1p
		extrn _ucol_getOffset_56:near
					; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+142p
					; _usearch_getOffset_56+2Ep ...
		extrn _ucol_next_56:near
					; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+F3p
		extrn _ucol_setText_56:near
					; CODE XREF: initializePatternCETable(UStringSearch *,UErrorCode *)+98p
					; _usearch_setText_56+9Dp ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: addTouint32_tArray(int *,uint,uint	*,uint,uint,UErrorCode *):loc_DFEp
					; _usearch_getMatchedText_56+DFp ...
		extrn _uprv_checkValidMemory:near
					; CODE XREF: addTouint32_tArray(int *,uint,uint	*,uint,uint,UErrorCode *)+6Fp
					; _usearch_getMatchedText_56+BFp ...
		extrn _ubrk_close_56:near ; CODE XREF: _usearch_close_56+126p
					; _usearch_setCollator_56+160p
		extrn _ucol_closeElements_56:near ; CODE XREF: _usearch_close_56+CCp
					; _usearch_close_56+DEp ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UCollationPCE::`scalar deleting destructor'(uint)+39p
					; __unwindfunclet$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z$0+9p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UCollationPCE::~UCollationPCE(icu_56::UCollationPCE	*__hidden this)
		extrn ??1UCollationPCE@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::UCollationPCE::`scalar deleting destructor'(uint)+26p
					; initializePatternPCETable(UStringSearch *,UErrorCode *)+1DAp	...
; void __thiscall icu_56::UCollationPCE::init(icu_56::UCollationPCE *__hidden this, struct UCollationElements *)
		extrn ?init@UCollationPCE@icu_56@@QAEXPAUUCollationElements@@@Z:near
					; CODE XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+10Dp
; _DWORD __thiscall icu_56::UCollationPCE::UCollationPCE(icu_56::UCollationPCE *__hidden this, struct UCollationElements *)
		extrn ??0UCollationPCE@icu_56@@QAE@PAUUCollationElements@@@Z:near
					; CODE XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+A6p
					; initializePatternPCETable(UStringSearch *,UErrorCode *)+122p
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn __imp_??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+70p
					; DATA XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+70r
		extrn ___security_cookie:near
					; DATA XREF: `anonymous	namespace'::initTextProcessedIter(UStringSearch *,UErrorCode *)+2Cr
					; _usearch_search_56+1Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z+19j
					; __ehhandler$?initializePatternPCETable@@YAGPAUUStringSearch@@PAW4UErrorCode@@@Z+23j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$?initTextProcessedIter@?A0x7b251a59@@YACPAUUStringSearch@@PAW4UErrorCode@@@Z+Fp
					; _usearch_search_56+7C2p ...
		extrn _ucol_setOffset_56:near
					; CODE XREF: setColEIterOffset(UCollationElements *,int)+31p
					; _usearch_next_56+1F3p ...
		extrn _u_terminateUChars_56:near ; CODE	XREF: _usearch_getMatchedText_56+8Ep
					; _usearch_getMatchedText_56+FCp
; __int64 __thiscall icu_56::UCollationPCE::nextProcessed(icu_56::UCollationPCE	*__hidden this,	int *, int *, enum UErrorCode *)
		extrn ?nextProcessed@UCollationPCE@icu_56@@QAE_JPAH0PAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::get(int)+12Bp
					; initializePatternPCETable(UStringSearch *,UErrorCode *)+13Cp	...
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near
					; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::get(int)+8Bp
					; icu_56::`anonymous namespace'::CEIBuffer::getPrevious(int)+8Bp
					; DATA XREF: ...
; __int64 __thiscall icu_56::UCollationPCE::previousProcessed(icu_56::UCollationPCE *__hidden this, int	*, int *, enum UErrorCode *)
		extrn ?previousProcessed@UCollationPCE@icu_56@@QAE_JPAH0PAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::`anonymous	namespace'::CEIBuffer::getPrevious(int)+12Bp
		extrn __allshr:near	; CODE XREF: _usearch_search_56+407p
					; _usearch_search_56+53Bp ...
; __declspec(dllimport)	public:	signed char __thiscall icu_56::UnicodeString::operator==(class icu_56::UnicodeString const &)const
		extrn __imp_??8UnicodeString@icu_56@@QBECABV01@@Z:near
					; CODE XREF: checkIdentical(UStringSearch const	*,int,int)+1BFp
					; DATA XREF: checkIdentical(UStringSearch const	*,int,int)+1BFr
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: checkIdentical(UStringSearch const	*,int,int)+10Bp
					; checkIdentical(UStringSearch const *,int,int)+193p ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, signed __int8, const wchar_t *, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z:near
					; CODE XREF: checkIdentical(UStringSearch const	*,int,int)+B5p
					; checkIdentical(UStringSearch const *,int,int)+13Dp
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		extrn __imp_??0UnicodeString@icu_56@@QAE@XZ:near
					; CODE XREF: checkIdentical(UStringSearch const	*,int,int)+5Fp
					; checkIdentical(UStringSearch const *,int,int)+7Bp
					; DATA XREF: ...
		extrn _ubrk_following_56:near
					; CODE XREF: nextBoundaryAfter(UStringSearch *,int)+48p
					; _usearch_searchBackwards_56+D8p
		extrn _ubrk_isBoundary_56:near
					; CODE XREF: isBreakBoundary(UStringSearch *,int)+48p


		end
