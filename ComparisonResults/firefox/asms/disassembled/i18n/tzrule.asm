;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	F59E24FF925248D50D5BA7D4609EA3CE
; Input	CRC32 :	6A7AD4FE

; File Name   :	D:\compspace\objfiles\firefox\i18n\tzrule.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??2@YAPAXI@Z ; operator new(uint)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	a_?avumemory@ic+14h ; ""
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_FFC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; char `public:	static void * __cdecl icu_56::InitialTimeZoneRule::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@InitialTimeZoneRule@icu_56@@SAPAXXZ@4DA db ?
					; DATA XREF: icu_56::InitialTimeZoneRule::getStaticClassID(void)+1Eo
; char `public:	static void * __cdecl icu_56::AnnualTimeZoneRule::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@AnnualTimeZoneRule@icu_56@@SAPAXXZ@4DA db	?
					; DATA XREF: icu_56::AnnualTimeZoneRule::getStaticClassID(void)+1Eo
; char `public:	static void * __cdecl icu_56::TimeArrayTimeZoneRule::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@TimeArrayTimeZoneRule@icu_56@@SAPAXXZ@4DA	db ?
					; DATA XREF: icu_56::TimeArrayTimeZoneRule::getStaticClassID(void)+1Eo
		align 4
_bss		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0FCh
		public ?MAX_YEAR@AnnualTimeZoneRule@icu_56@@2HB
; public: static int const icu_56::AnnualTimeZoneRule::MAX_YEAR
?MAX_YEAR@AnnualTimeZoneRule@icu_56@@2HB dd 7FFFFFFFh
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 100h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 138h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 13Ch
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 140h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 174h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::TimeZoneRule::`scalar deleting destructor'(unsigned int)
		public ??_GTimeZoneRule@icu_56@@UAEPAXI@Z
??_GTimeZoneRule@icu_56@@UAEPAXI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1TimeZoneRule@icu_56@@UAE@XZ ; icu_56::TimeZoneRule::~TimeZoneRule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1BD
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1BD:				; CODE XREF: icu_56::TimeZoneRule::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]

loc_1C0:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GTimeZoneRule@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::TimeZoneRule::`vector deleting destructor'(unsigned int)
		public ??_ETimeZoneRule@icu_56@@UAEPAXI@Z
??_ETimeZoneRule@icu_56@@UAEPAXI@Z proc	near
					; DATA XREF: .rdata:const icu_56::TimeZoneRule::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]

loc_1FE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		and	eax, 2
		jz	short loc_243
		push	offset ??1TimeZoneRule@icu_56@@UAE@XZ ;	icu_56::TimeZoneRule::~TimeZoneRule(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4Ch ; 'L'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_23B
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_23B:				; CODE XREF: icu_56::TimeZoneRule::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_26C
; ---------------------------------------------------------------------------

loc_243:				; CODE XREF: icu_56::TimeZoneRule::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1TimeZoneRule@icu_56@@UAE@XZ ; icu_56::TimeZoneRule::~TimeZoneRule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_269
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_269:				; CODE XREF: icu_56::TimeZoneRule::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_26C:				; CODE XREF: icu_56::TimeZoneRule::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ETimeZoneRule@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 284h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::InitialTimeZoneRule::`scalar deleting destructor'(unsigned int)
		public ??_GInitialTimeZoneRule@icu_56@@UAEPAXI@Z
??_GInitialTimeZoneRule@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1InitialTimeZoneRule@icu_56@@UAE@XZ ;	icu_56::InitialTimeZoneRule::~InitialTimeZoneRule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_2CD
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2CD:				; CODE XREF: icu_56::InitialTimeZoneRule::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GInitialTimeZoneRule@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::InitialTimeZoneRule::`vector deleting destructor'(unsigned int)
		public ??_EInitialTimeZoneRule@icu_56@@UAEPAXI@Z
??_EInitialTimeZoneRule@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::InitialTimeZoneRule::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_353
		push	offset ??1InitialTimeZoneRule@icu_56@@UAE@XZ ; icu_56::InitialTimeZoneRule::~InitialTimeZoneRule(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4Ch ; 'L'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_34B
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_34B:				; CODE XREF: icu_56::InitialTimeZoneRule::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_37C
; ---------------------------------------------------------------------------

loc_353:				; CODE XREF: icu_56::InitialTimeZoneRule::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1InitialTimeZoneRule@icu_56@@UAE@XZ ;	icu_56::InitialTimeZoneRule::~InitialTimeZoneRule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_379
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_379:				; CODE XREF: icu_56::InitialTimeZoneRule::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_37C:				; CODE XREF: icu_56::InitialTimeZoneRule::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EInitialTimeZoneRule@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 394h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::AnnualTimeZoneRule::`scalar	deleting destructor'(unsigned int)
		public ??_GAnnualTimeZoneRule@icu_56@@UAEPAXI@Z
??_GAnnualTimeZoneRule@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1AnnualTimeZoneRule@icu_56@@UAE@XZ ; icu_56::AnnualTimeZoneRule::~AnnualTimeZoneRule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3DD
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3DD:				; CODE XREF: icu_56::AnnualTimeZoneRule::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GAnnualTimeZoneRule@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::AnnualTimeZoneRule::`vector	deleting destructor'(unsigned int)
		public ??_EAnnualTimeZoneRule@icu_56@@UAEPAXI@Z
??_EAnnualTimeZoneRule@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::AnnualTimeZoneRule::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp

loc_3FB:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_463
		push	offset ??1AnnualTimeZoneRule@icu_56@@UAE@XZ ; icu_56::AnnualTimeZoneRule::~AnnualTimeZoneRule(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	58h ; 'X'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_45B
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_45B:				; CODE XREF: icu_56::AnnualTimeZoneRule::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_48C
; ---------------------------------------------------------------------------

loc_463:				; CODE XREF: icu_56::AnnualTimeZoneRule::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1AnnualTimeZoneRule@icu_56@@UAE@XZ ; icu_56::AnnualTimeZoneRule::~AnnualTimeZoneRule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_489
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_489:				; CODE XREF: icu_56::AnnualTimeZoneRule::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_48C:				; CODE XREF: icu_56::AnnualTimeZoneRule::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EAnnualTimeZoneRule@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::TimeArrayTimeZoneRule::`scalar deleting destructor'(unsigned int)
		public ??_GTimeArrayTimeZoneRule@icu_56@@UAEPAXI@Z
??_GTimeArrayTimeZoneRule@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1TimeArrayTimeZoneRule@icu_56@@UAE@XZ	; icu_56::TimeArrayTimeZoneRule::~TimeArrayTimeZoneRule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4ED
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4ED:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GTimeArrayTimeZoneRule@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 508h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::TimeArrayTimeZoneRule::`vector deleting destructor'(unsigned int)
		public ??_ETimeArrayTimeZoneRule@icu_56@@UAEPAXI@Z
??_ETimeArrayTimeZoneRule@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::TimeArrayTimeZoneRule::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_576
		push	offset ??1TimeArrayTimeZoneRule@icu_56@@UAE@XZ ; icu_56::TimeArrayTimeZoneRule::~TimeArrayTimeZoneRule(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	158h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_56E
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_56E:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::`vector deleting destructor'(uint)+4Bj
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_59F
; ---------------------------------------------------------------------------

loc_576:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1TimeArrayTimeZoneRule@icu_56@@UAE@XZ	; icu_56::TimeArrayTimeZoneRule::~TimeArrayTimeZoneRule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_59C
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_59C:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::`vector deleting destructor'(uint)+7Cj
		mov	eax, [ebp+var_8]

loc_59F:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::`vector deleting destructor'(uint)+6Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ETimeArrayTimeZoneRule@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::TimeZoneRule::TimeZoneRule(icu_56::TimeZoneRule *this, const struct	icu_56::UnicodeString *, int, int)
		public ??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z
??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z proc near
					; CODE XREF: icu_56::InitialTimeZoneRule::InitialTimeZoneRule(icu_56::UnicodeString const &,int,int)+32p
					; icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::UnicodeString const &,int,int,icu_56::DateTimeRule const &,int,int)+51p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7TimeZoneRule@icu_56@@6B@ ; const icu_56::TimeZoneRule::`vftable'
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 4		; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	[eax+44h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_8]
		mov	[eax+48h], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 674h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z$0 proc near
					; DATA XREF: .xdata$x:000006D4o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z	proc near
					; DATA XREF: icu_56::TimeZoneRule::TimeZoneRule(icu_56::UnicodeString const &,int,int)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6A4h
		dd offset ??_R4TimeZoneRule@icu_56@@6B@	; const	icu_56::TimeZoneRule::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7TimeZoneRule@icu_56@@6B@
; const	icu_56::TimeZoneRule::`vftable'
??_7TimeZoneRule@icu_56@@6B@ dd	offset ??_ETimeZoneRule@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::TimeZoneRule::TimeZoneRule(icu_56::UnicodeString const &,int,int)+5Eo
					; icu_56::TimeZoneRule::TimeZoneRule(icu_56::TimeZoneRule const	&)+62o	...
					; icu_56::TimeZoneRule::`vector	deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset ??8TimeZoneRule@icu_56@@UBECABV01@@Z ; icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule const &)
		dd offset ??9TimeZoneRule@icu_56@@UBECABV01@@Z ; icu_56::TimeZoneRule::operator!=(icu_56::TimeZoneRule const &)
		dd offset ?isEquivalentTo@TimeZoneRule@icu_56@@UBECABV12@@Z ; icu_56::TimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6D0h
__unwindtable$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000006E0o
		dd offset __unwindfunclet$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z$0
__ehfuncinfo$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z+14o
		dd offset __unwindtable$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6FCh
		public ??_R4TimeZoneRule@icu_56@@6B@
; const	icu_56::TimeZoneRule::`RTTI Complete Object Locator'
??_R4TimeZoneRule@icu_56@@6B@ dd 3 dup(0) ; DATA XREF: .rdata:000006A4o
		dd offset ??_R0?AVTimeZoneRule@icu_56@@@8 ; icu_56::TimeZoneRule `RTTI Type Descriptor'
		dd offset ??_R3TimeZoneRule@icu_56@@8 ;	icu_56::TimeZoneRule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 710h
		public ??_R0?AVTimeZoneRule@icu_56@@@8
; class	icu_56::TimeZoneRule `RTTI Type	Descriptor'
??_R0?AVTimeZoneRule@icu_56@@@8	dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000708o
					; .rdata$r:icu_56::TimeZoneRule::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avtimezoneru	db '.?AVTimeZoneRule@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 734h
		public ??_R3TimeZoneRule@icu_56@@8
; icu_56::TimeZoneRule::`RTTI Class Hierarchy Descriptor'
??_R3TimeZoneRule@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000070Co
					; .rdata$r:0000076Co
		dd 3
		dd offset ??_R2TimeZoneRule@icu_56@@8 ;	icu_56::TimeZoneRule::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 744h
		public ??_R2TimeZoneRule@icu_56@@8
; icu_56::TimeZoneRule::`RTTI Base Class Array'
??_R2TimeZoneRule@icu_56@@8 dd offset ??_R1A@?0A@EA@TimeZoneRule@icu_56@@8
					; DATA XREF: .rdata$r:00000740o
					; icu_56::TimeZoneRule::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 754h
		public ??_R1A@?0A@EA@TimeZoneRule@icu_56@@8
; icu_56::TimeZoneRule::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@TimeZoneRule@icu_56@@8 dd	offset ??_R0?AVTimeZoneRule@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::TimeZoneRule::`RTTI Base Class Array'o
					; .rdata$r:00000E94o ...
					; icu_56::TimeZoneRule `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3TimeZoneRule@icu_56@@8 ;	icu_56::TimeZoneRule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 770h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:00000748o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Array'o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 78Ch
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7ACh
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000788o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7BCh
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:000007B8o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7C8h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:0000074Co
					; .rdata$r:000007C0o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 7E4h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 804h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000007E0o
					; .rdata$r:00000834o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 814h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00000810o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 81Ch
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 838h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::TimeZoneRule::TimeZoneRule(icu_56::TimeZoneRule *this, const struct	icu_56::TimeZoneRule *)
		public ??0TimeZoneRule@icu_56@@IAE@ABV01@@Z
??0TimeZoneRule@icu_56@@IAE@ABV01@@Z proc near
					; CODE XREF: icu_56::InitialTimeZoneRule::InitialTimeZoneRule(icu_56::InitialTimeZoneRule const	&)+2Ap
					; icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::AnnualTimeZoneRule const &)+49p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7TimeZoneRule@icu_56@@6B@ ; const icu_56::TimeZoneRule::`vftable'
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 4		; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+44h]
		mov	[eax+44h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+48h]
		mov	[eax+48h], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0TimeZoneRule@icu_56@@IAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 900h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00000934o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z proc near
					; DATA XREF: icu_56::TimeZoneRule::TimeZoneRule(icu_56::TimeZoneRule const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 930h
__unwindtable$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000940o
		dd offset __unwindfunclet$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z$0
__ehfuncinfo$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z+14o
		dd offset __unwindtable$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 95Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::TimeZoneRule::~TimeZoneRule(icu_56::TimeZoneRule *__hidden this)
		public ??1TimeZoneRule@icu_56@@UAE@XZ
??1TimeZoneRule@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::TimeZoneRule::`scalar deleting destructor'(uint)+26p
					; icu_56::TimeZoneRule::`vector	deleting destructor'(uint)+6Ep ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1TimeZoneRule@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7TimeZoneRule@icu_56@@6B@ ; const icu_56::TimeZoneRule::`vftable'
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 4		; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1TimeZoneRule@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 9FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1TimeZoneRule@icu_56@@UAE@XZ$0 proc near ; DATA XREF:	.xdata$x:00000A30o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1TimeZoneRule@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1TimeZoneRule@icu_56@@UAE@XZ proc	near
					; DATA XREF: icu_56::TimeZoneRule::~TimeZoneRule(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1TimeZoneRule@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1TimeZoneRule@icu_56@@UAE@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0A2Ch
__unwindtable$??1TimeZoneRule@icu_56@@UAE@XZ dd	0FFFFFFFFh ; DATA XREF:	.xdata$x:00000A3Co
		dd offset __unwindfunclet$??1TimeZoneRule@icu_56@@UAE@XZ$0
__ehfuncinfo$??1TimeZoneRule@icu_56@@UAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1TimeZoneRule@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1TimeZoneRule@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: class icu_56::TimeZoneRule	& __thiscall icu_56::TimeZoneRule::operator=(class icu_56::TimeZoneRule	const &)
		public ??4TimeZoneRule@icu_56@@IAEAAV01@ABV01@@Z
??4TimeZoneRule@icu_56@@IAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::InitialTimeZoneRule::operator=(icu_56::InitialTimeZoneRule	const &)+32p
					; icu_56::AnnualTimeZoneRule::operator=(icu_56::AnnualTimeZoneRule const &)+36p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jz	short loc_AB7
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 4
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+44h]
		mov	[eax+44h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+48h]
		mov	[eax+48h], edx

loc_AB7:				; CODE XREF: icu_56::TimeZoneRule::operator=(icu_56::TimeZoneRule const	&)+29j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4TimeZoneRule@icu_56@@IAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::TimeZoneRule::operator==(class	icu_56::TimeZoneRule const &)const
		public ??8TimeZoneRule@icu_56@@UBECABV01@@Z
??8TimeZoneRule@icu_56@@UBECABV01@@Z proc near
					; CODE XREF: icu_56::InitialTimeZoneRule::operator==(icu_56::TimeZoneRule const	&)+63p
					; icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+6Ap
					; DATA XREF: ...

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jz	short loc_B74
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	edx, [ebp+var_8]
		push	edx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??8type_info@@QBE_NABV0@@Z ;	type_info::operator==(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	eax, al
		test	eax, eax
		jz	short loc_B6B
		mov	ecx, [ebp+arg_0]
		add	ecx, 4
		mov	esi, esp
		push	ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 4
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	edx, al
		test	edx, edx
		jz	short loc_B6B
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+44h]
		cmp	edx, [ecx+44h]
		jnz	short loc_B6B
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+48h]
		cmp	edx, [ecx+48h]
		jz	short loc_B74

loc_B6B:				; CODE XREF: icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule const &)+5Aj
					; icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule	const &)+7Dj ...
		mov	[ebp+var_CD], 0
		jmp	short loc_B7B
; ---------------------------------------------------------------------------

loc_B74:				; CODE XREF: icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule const &)+29j
					; icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule	const &)+99j
		mov	[ebp+var_CD], 1

loc_B7B:				; CODE XREF: icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule const &)+A2j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8TimeZoneRule@icu_56@@UBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::TimeZoneRule::operator!=(class	icu_56::TimeZoneRule const &)const
		public ??9TimeZoneRule@icu_56@@UBECABV01@@Z
??9TimeZoneRule@icu_56@@UBECABV01@@Z proc near ; DATA XREF: .rdata:000006B8o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9TimeZoneRule@icu_56@@UBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::TimeZoneRule::getName(icu_56::TimeZoneRule *this, struct icu_56::UnicodeString *)
		public ?getName@TimeZoneRule@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?getName@TimeZoneRule@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getName@TimeZoneRule@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::TimeZoneRule::getRawOffset(icu_56::TimeZoneRule *__hidden this)
		public ?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ
?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+44h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getRawOffset@TimeZoneRule@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::TimeZoneRule::getDSTSavings(icu_56::TimeZoneRule *__hidden this)
		public ?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ
?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+48h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDSTSavings@TimeZoneRule@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::TimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule *this, const struct icu_56::TimeZoneRule *)
		public ?isEquivalentTo@TimeZoneRule@icu_56@@UBECABV12@@Z
?isEquivalentTo@TimeZoneRule@icu_56@@UBECABV12@@Z proc near
					; CODE XREF: icu_56::InitialTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+67p
					; icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const	&)+6Ap	...

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jz	short loc_D2D
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	edx, [ebp+var_8]
		push	edx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??8type_info@@QBE_NABV0@@Z ;	type_info::operator==(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	eax, al
		test	eax, eax
		jz	short loc_D24
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+arg_0]
		mov	eax, [ecx+44h]
		cmp	eax, [edx+44h]
		jnz	short loc_D24
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+arg_0]
		mov	eax, [ecx+48h]
		cmp	eax, [edx+48h]
		jz	short loc_D2D

loc_D24:				; CODE XREF: icu_56::TimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+5Aj
					; icu_56::TimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+68j
		mov	[ebp+var_CD], 0
		jmp	short loc_D34
; ---------------------------------------------------------------------------

loc_D2D:				; CODE XREF: icu_56::TimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+29j
					; icu_56::TimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+76j
		mov	[ebp+var_CD], 1

loc_D34:				; CODE XREF: icu_56::TimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+7Fj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isEquivalentTo@TimeZoneRule@icu_56@@UBECABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::InitialTimeZoneRule::getStaticClassID()
		public ?getStaticClassID@InitialTimeZoneRule@icu_56@@SAPAXXZ
?getStaticClassID@InitialTimeZoneRule@icu_56@@SAPAXXZ proc near
					; CODE XREF: icu_56::InitialTimeZoneRule::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@InitialTimeZoneRule@icu_56@@SAPAXXZ@4DA ; char `icu_56::InitialTimeZoneRule::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@InitialTimeZoneRule@icu_56@@SAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::InitialTimeZoneRule::getDynamicClassID(icu_56::InitialTimeZoneRule *__hidden	this)
		public ?getDynamicClassID@InitialTimeZoneRule@icu_56@@UBEPAXXZ
?getDynamicClassID@InitialTimeZoneRule@icu_56@@UBEPAXXZ	proc near
					; DATA XREF: .rdata:00000E1Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@InitialTimeZoneRule@icu_56@@SAPAXXZ ;	icu_56::InitialTimeZoneRule::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@InitialTimeZoneRule@icu_56@@UBEPAXXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::InitialTimeZoneRule::InitialTimeZoneRule(icu_56::InitialTimeZoneRule *this,	const struct icu_56::UnicodeString *, int, int)
		public ??0InitialTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HH@Z
??0InitialTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z ; icu_56::TimeZoneRule::TimeZoneRule(icu_56::UnicodeString const &,int,int)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7InitialTimeZoneRule@icu_56@@6B@ ; const icu_56::InitialTimeZoneRule::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx

loc_DFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0InitialTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E14h
		dd offset ??_R4InitialTimeZoneRule@icu_56@@6B@ ; const icu_56::InitialTimeZoneRule::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7InitialTimeZoneRule@icu_56@@6B@
; const	icu_56::InitialTimeZoneRule::`vftable'
??_7InitialTimeZoneRule@icu_56@@6B@ dd offset ??_EInitialTimeZoneRule@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::InitialTimeZoneRule::InitialTimeZoneRule(icu_56::UnicodeString const &,int,int)+3Ao
					; icu_56::InitialTimeZoneRule::InitialTimeZoneRule(icu_56::InitialTimeZoneRule const &)+32o ...
					; icu_56::InitialTimeZoneRule::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@InitialTimeZoneRule@icu_56@@UBEPAXXZ ; icu_56::InitialTimeZoneRule::getDynamicClassID(void)
		dd offset ?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ ; icu_56::InitialTimeZoneRule::clone(void)
		dd offset ??8InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z ; icu_56::InitialTimeZoneRule::operator==(icu_56::TimeZoneRule const &)
		dd offset ??9InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z ; icu_56::InitialTimeZoneRule::operator!=(icu_56::TimeZoneRule const &)
		dd offset ?isEquivalentTo@InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z ; icu_56::InitialTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const	&)
		dd offset ?getFirstStart@InitialTimeZoneRule@icu_56@@UBECHHAAN@Z ; icu_56::InitialTimeZoneRule::getFirstStart(int,int,double &)
		dd offset ?getFinalStart@InitialTimeZoneRule@icu_56@@UBECHHAAN@Z ; icu_56::InitialTimeZoneRule::getFinalStart(int,int,double &)
		dd offset ?getNextStart@InitialTimeZoneRule@icu_56@@UBECNHHCAAN@Z ; icu_56::InitialTimeZoneRule::getNextStart(double,int,int,signed char,double	&)
		dd offset ?getPreviousStart@InitialTimeZoneRule@icu_56@@UBECNHHCAAN@Z ;	icu_56::InitialTimeZoneRule::getPreviousStart(double,int,int,signed char,double	&)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E40h
		public ??_R4InitialTimeZoneRule@icu_56@@6B@
; const	icu_56::InitialTimeZoneRule::`RTTI Complete Object Locator'
??_R4InitialTimeZoneRule@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00000E14o
		dd offset ??_R0?AVInitialTimeZoneRule@icu_56@@@8 ; icu_56::InitialTimeZoneRule `RTTI Type Descriptor'
		dd offset ??_R3InitialTimeZoneRule@icu_56@@8 ; icu_56::InitialTimeZoneRule::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0E54h
		public ??_R0?AVInitialTimeZoneRule@icu_56@@@8
; class	icu_56::InitialTimeZoneRule `RTTI Type Descriptor'
??_R0?AVInitialTimeZoneRule@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00000E4Co
					; .rdata$r:icu_56::InitialTimeZoneRule::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avinitialtim	db '.?AVInitialTimeZoneRule@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E80h
		public ??_R3InitialTimeZoneRule@icu_56@@8
; icu_56::InitialTimeZoneRule::`RTTI Class Hierarchy Descriptor'
??_R3InitialTimeZoneRule@icu_56@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:00000E50o
					; .rdata$r:00000EBCo
		dd 4
		dd offset ??_R2InitialTimeZoneRule@icu_56@@8 ; icu_56::InitialTimeZoneRule::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E90h
		public ??_R2InitialTimeZoneRule@icu_56@@8
; icu_56::InitialTimeZoneRule::`RTTI Base Class	Array'
??_R2InitialTimeZoneRule@icu_56@@8 dd offset ??_R1A@?0A@EA@InitialTimeZoneRule@icu_56@@8
					; DATA XREF: .rdata$r:00000E8Co
					; icu_56::InitialTimeZoneRule::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@TimeZoneRule@icu_56@@8 ; icu_56::TimeZoneRule::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0EA4h
		public ??_R1A@?0A@EA@InitialTimeZoneRule@icu_56@@8
; icu_56::InitialTimeZoneRule::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@InitialTimeZoneRule@icu_56@@8 dd offset ??_R0?AVInitialTimeZoneRule@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::InitialTimeZoneRule::`RTTI Base Class Array'o
					; icu_56::InitialTimeZoneRule `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3InitialTimeZoneRule@icu_56@@8 ; icu_56::InitialTimeZoneRule::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::InitialTimeZoneRule::InitialTimeZoneRule(icu_56::InitialTimeZoneRule *this,	const struct icu_56::InitialTimeZoneRule *)
		public ??0InitialTimeZoneRule@icu_56@@QAE@ABV01@@Z
??0InitialTimeZoneRule@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::InitialTimeZoneRule::clone(void)+76p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::TimeZoneRule *
		mov	ecx, [ebp+var_8] ; this
		call	??0TimeZoneRule@icu_56@@IAE@ABV01@@Z ; icu_56::TimeZoneRule::TimeZoneRule(icu_56::TimeZoneRule const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7InitialTimeZoneRule@icu_56@@6B@ ; const icu_56::InitialTimeZoneRule::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0InitialTimeZoneRule@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::InitialTimeZoneRule::~InitialTimeZoneRule(icu_56::InitialTimeZoneRule *__hidden this)
		public ??1InitialTimeZoneRule@icu_56@@UAE@XZ
??1InitialTimeZoneRule@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::InitialTimeZoneRule::`scalar deleting destructor'(uint)+26p
					; icu_56::InitialTimeZoneRule::`vector deleting	destructor'(uint)+6Ep
					; DATA XREF: ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7InitialTimeZoneRule@icu_56@@6B@ ; const icu_56::InitialTimeZoneRule::`vftable'
		mov	ecx, [ebp+var_8] ; this
		call	??1TimeZoneRule@icu_56@@UAE@XZ ; icu_56::TimeZoneRule::~TimeZoneRule(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1InitialTimeZoneRule@icu_56@@UAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::InitialTimeZoneRule *__thiscall icu_56::InitialTimeZoneRule::clone(icu_56::InitialTimeZoneRule	*__hidden this)
		public ?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ
?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ proc near ; DATA	XREF: .rdata:00000E20o

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		push	4Ch ; 'L'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_FDF
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::InitialTimeZoneRule *
		mov	ecx, [ebp+var_E0] ; this
		call	??0InitialTimeZoneRule@icu_56@@QAE@ABV01@@Z ; icu_56::InitialTimeZoneRule::InitialTimeZoneRule(icu_56::InitialTimeZoneRule const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_FE9
; ---------------------------------------------------------------------------

loc_FDF:				; CODE XREF: icu_56::InitialTimeZoneRule::clone(void)+6Aj
		mov	[ebp+var_F4], 0

loc_FE9:				; CODE XREF: icu_56::InitialTimeZoneRule::clone(void)+81j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh

loc_FFC:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		mov	eax, [ebp+var_EC]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1024h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ$0 proc near
					; DATA XREF: .xdata$x:00001060o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ proc	near
					; DATA XREF: icu_56::InitialTimeZoneRule::clone(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 105Ch
__unwindtable$?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:0000106Co
		dd offset __unwindfunclet$?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ$0
__ehfuncinfo$?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ+14o
		dd offset __unwindtable$?clone@InitialTimeZoneRule@icu_56@@UBEPAV12@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1088h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::InitialTimeZoneRule & __thiscall icu_56::InitialTimeZoneRule::operator=(class icu_56::InitialTimeZoneRule const	&)
		public ??4InitialTimeZoneRule@icu_56@@QAEAAV01@ABV01@@Z
??4InitialTimeZoneRule@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jz	short loc_10BF
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4TimeZoneRule@icu_56@@IAEAAV01@ABV01@@Z ; icu_56::TimeZoneRule::operator=(icu_56::TimeZoneRule const &)

loc_10BF:				; CODE XREF: icu_56::InitialTimeZoneRule::operator=(icu_56::InitialTimeZoneRule	const &)+29j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4InitialTimeZoneRule@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::InitialTimeZoneRule::operator==(class icu_56::TimeZoneRule const &)const
		public ??8InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z
??8InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z	proc near
					; DATA XREF: .rdata:00000E24o

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jz	short loc_1150
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	edx, [ebp+var_8]
		push	edx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??8type_info@@QBE_NABV0@@Z ;	type_info::operator==(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	eax, al
		test	eax, eax
		jz	short loc_1147
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	??8TimeZoneRule@icu_56@@UBECABV01@@Z ; icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule const &)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1150

loc_1147:				; CODE XREF: icu_56::InitialTimeZoneRule::operator==(icu_56::TimeZoneRule const	&)+5Aj
		mov	[ebp+var_CD], 0
		jmp	short loc_1157
; ---------------------------------------------------------------------------

loc_1150:				; CODE XREF: icu_56::InitialTimeZoneRule::operator==(icu_56::TimeZoneRule const	&)+29j
					; icu_56::InitialTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+6Dj
		mov	[ebp+var_CD], 1

loc_1157:				; CODE XREF: icu_56::InitialTimeZoneRule::operator==(icu_56::TimeZoneRule const	&)+76j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1174h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::InitialTimeZoneRule::operator!=(class icu_56::TimeZoneRule const &)const
		public ??9InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z
??9InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z	proc near
					; DATA XREF: .rdata:00000E28o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::InitialTimeZoneRule::isEquivalentTo(icu_56::InitialTimeZoneRule *this, const	struct icu_56::TimeZoneRule *)
		public ?isEquivalentTo@InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z
?isEquivalentTo@InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z proc near
					; DATA XREF: .rdata:00000E2Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_11FF
		mov	al, 1
		jmp	short loc_1249
; ---------------------------------------------------------------------------

loc_11FF:				; CODE XREF: icu_56::InitialTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+29j
		mov	eax, [ebp+arg_0]
		push	eax
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??9type_info@@QBE_NABV0@@Z ;	type_info::operator!=(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, al
		test	edx, edx
		jnz	short loc_1243
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::TimeZoneRule *
		mov	ecx, [ebp+var_8] ; this
		call	?isEquivalentTo@TimeZoneRule@icu_56@@UBECABV12@@Z ; icu_56::TimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_1247

loc_1243:				; CODE XREF: icu_56::InitialTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+5Ej
		xor	al, al
		jmp	short loc_1249
; ---------------------------------------------------------------------------

loc_1247:				; CODE XREF: icu_56::InitialTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+71j
		mov	al, 1

loc_1249:				; CODE XREF: icu_56::InitialTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+2Dj
					; icu_56::InitialTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+75j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isEquivalentTo@InitialTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1260h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::InitialTimeZoneRule::getFirstStart(icu_56::InitialTimeZoneRule *this, int, int, double *)
		public ?getFirstStart@InitialTimeZoneRule@icu_56@@UBECHHAAN@Z
?getFirstStart@InitialTimeZoneRule@icu_56@@UBECHHAAN@Z proc near
					; DATA XREF: .rdata:00000E30o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	al, al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getFirstStart@InitialTimeZoneRule@icu_56@@UBECHHAAN@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1290h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::InitialTimeZoneRule::getFinalStart(icu_56::InitialTimeZoneRule *this, int, int, double *)
		public ?getFinalStart@InitialTimeZoneRule@icu_56@@UBECHHAAN@Z
?getFinalStart@InitialTimeZoneRule@icu_56@@UBECHHAAN@Z proc near
					; DATA XREF: .rdata:00000E34o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	al, al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getFinalStart@InitialTimeZoneRule@icu_56@@UBECHHAAN@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::InitialTimeZoneRule::getNextStart(icu_56::InitialTimeZoneRule *this,	double,	int, int, signed __int8, double	*)
		public ?getNextStart@InitialTimeZoneRule@icu_56@@UBECNHHCAAN@Z
?getNextStart@InitialTimeZoneRule@icu_56@@UBECNHHCAAN@Z	proc near
					; DATA XREF: .rdata:00000E38o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	al, al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	18h
?getNextStart@InitialTimeZoneRule@icu_56@@UBECNHHCAAN@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::InitialTimeZoneRule::getPreviousStart(icu_56::InitialTimeZoneRule *this, double, int, int, signed __int8, double *)
		public ?getPreviousStart@InitialTimeZoneRule@icu_56@@UBECNHHCAAN@Z
?getPreviousStart@InitialTimeZoneRule@icu_56@@UBECNHHCAAN@Z proc near
					; DATA XREF: .rdata:00000E3Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	al, al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	18h
?getPreviousStart@InitialTimeZoneRule@icu_56@@UBECNHHCAAN@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1320h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::AnnualTimeZoneRule::getStaticClassID()
		public ?getStaticClassID@AnnualTimeZoneRule@icu_56@@SAPAXXZ
?getStaticClassID@AnnualTimeZoneRule@icu_56@@SAPAXXZ proc near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@AnnualTimeZoneRule@icu_56@@SAPAXXZ@4DA ; char	`icu_56::AnnualTimeZoneRule::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@AnnualTimeZoneRule@icu_56@@SAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 134Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::AnnualTimeZoneRule::getDynamicClassID(icu_56::AnnualTimeZoneRule *__hidden this)
		public ?getDynamicClassID@AnnualTimeZoneRule@icu_56@@UBEPAXXZ
?getDynamicClassID@AnnualTimeZoneRule@icu_56@@UBEPAXXZ proc near
					; DATA XREF: .rdata:000014D8o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@AnnualTimeZoneRule@icu_56@@SAPAXXZ ; icu_56::AnnualTimeZoneRule::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@AnnualTimeZoneRule@icu_56@@UBEPAXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1388h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::AnnualTimeZoneRule *this, const struct icu_56::UnicodeString	*, int,	int, const struct icu_56::DateTimeRule *, int, int)
		public ??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z
??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z ; icu_56::TimeZoneRule::TimeZoneRule(icu_56::UnicodeString const &,int,int)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7AnnualTimeZoneRule@icu_56@@6B@ ; const icu_56::AnnualTimeZoneRule::`vftable'
		mov	esi, esp
		push	20h ; ' '       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_E0], 0
		jz	short loc_142C
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::DateTimeRule *
		mov	ecx, [ebp+var_E0] ; this
		call	??0DateTimeRule@icu_56@@QAE@ABV01@@Z ; icu_56::DateTimeRule::DateTimeRule(icu_56::DateTimeRule const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_1436
; ---------------------------------------------------------------------------

loc_142C:				; CODE XREF: icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::UnicodeString const	&,int,int,icu_56::DateTimeRule const &,int,int)+8Bj
		mov	[ebp+var_F4], 0

loc_1436:				; CODE XREF: icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::UnicodeString const	&,int,int,icu_56::DateTimeRule const &,int,int)+A2j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_EC]
		mov	[edx+4Ch], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_10]
		mov	[eax+50h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_14]
		mov	[eax+54h], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1490h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z$0	proc near
					; DATA XREF: .xdata$x:00001500o
		mov	ecx, [ebp-14h]	; this
		jmp	??1TimeZoneRule@icu_56@@UAE@XZ ; icu_56::TimeZoneRule::~TimeZoneRule(void)
__unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z$1	proc near
					; DATA XREF: .xdata$x:00001508o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z$1	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z proc near
					; DATA XREF: icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::UnicodeString const	&,int,int,icu_56::DateTimeRule const &,int,int)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14D0h
		dd offset ??_R4AnnualTimeZoneRule@icu_56@@6B@ ;	const icu_56::AnnualTimeZoneRule::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7AnnualTimeZoneRule@icu_56@@6B@
; const	icu_56::AnnualTimeZoneRule::`vftable'
??_7AnnualTimeZoneRule@icu_56@@6B@ dd offset ??_EAnnualTimeZoneRule@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::UnicodeString const	&,int,int,icu_56::DateTimeRule const &,int,int)+60o
					; icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::UnicodeString const &,int,int,icu_56::DateTimeRule *,int,int)+3Ao ...
					; icu_56::AnnualTimeZoneRule::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@AnnualTimeZoneRule@icu_56@@UBEPAXXZ ; icu_56::AnnualTimeZoneRule::getDynamicClassID(void)
		dd offset ?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ	; icu_56::AnnualTimeZoneRule::clone(void)
		dd offset ??8AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z ; icu_56::AnnualTimeZoneRule::operator==(icu_56::TimeZoneRule const &)
		dd offset ??9AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z ; icu_56::AnnualTimeZoneRule::operator!=(icu_56::TimeZoneRule const &)
		dd offset ?isEquivalentTo@AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z ;	icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &)
		dd offset ?getFirstStart@AnnualTimeZoneRule@icu_56@@UBECHHAAN@Z	; icu_56::AnnualTimeZoneRule::getFirstStart(int,int,double &)
		dd offset ?getFinalStart@AnnualTimeZoneRule@icu_56@@UBECHHAAN@Z	; icu_56::AnnualTimeZoneRule::getFinalStart(int,int,double &)
		dd offset ?getNextStart@AnnualTimeZoneRule@icu_56@@UBECNHHCAAN@Z ; icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double &)
		dd offset ?getPreviousStart@AnnualTimeZoneRule@icu_56@@UBECNHHCAAN@Z ; icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed char,double &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 14FCh
__unwindtable$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001514o
		dd offset __unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z$0
		align 8
		dd offset __unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z$1
__ehfuncinfo$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z+14o
		dd offset __unwindtable$??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHABVDateTimeRule@1@HH@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1530h
		public ??_R4AnnualTimeZoneRule@icu_56@@6B@
; const	icu_56::AnnualTimeZoneRule::`RTTI Complete Object Locator'
??_R4AnnualTimeZoneRule@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:000014D0o
		dd offset ??_R0?AVAnnualTimeZoneRule@icu_56@@@8	; icu_56::AnnualTimeZoneRule `RTTI Type	Descriptor'
		dd offset ??_R3AnnualTimeZoneRule@icu_56@@8 ; icu_56::AnnualTimeZoneRule::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1544h
		public ??_R0?AVAnnualTimeZoneRule@icu_56@@@8
; class	icu_56::AnnualTimeZoneRule `RTTI Type Descriptor'
??_R0?AVAnnualTimeZoneRule@icu_56@@@8 dd offset	??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000153Co
					; .rdata$r:icu_56::AnnualTimeZoneRule::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avannualtime	db '.?AVAnnualTimeZoneRule@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 156Ch
		public ??_R3AnnualTimeZoneRule@icu_56@@8
; icu_56::AnnualTimeZoneRule::`RTTI Class Hierarchy Descriptor'
??_R3AnnualTimeZoneRule@icu_56@@8 dd 2 dup(0) ;	DATA XREF: .rdata$r:00001540o
					; .rdata$r:000015A8o
		dd 4
		dd offset ??_R2AnnualTimeZoneRule@icu_56@@8 ; icu_56::AnnualTimeZoneRule::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 157Ch
		public ??_R2AnnualTimeZoneRule@icu_56@@8
; icu_56::AnnualTimeZoneRule::`RTTI Base Class Array'
??_R2AnnualTimeZoneRule@icu_56@@8 dd offset ??_R1A@?0A@EA@AnnualTimeZoneRule@icu_56@@8
					; DATA XREF: .rdata$r:00001578o
					; icu_56::AnnualTimeZoneRule::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@TimeZoneRule@icu_56@@8 ; icu_56::TimeZoneRule::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1590h
		public ??_R1A@?0A@EA@AnnualTimeZoneRule@icu_56@@8
; icu_56::AnnualTimeZoneRule::`RTTI Base Class Descriptor at (0, -1, 0,	64)'
??_R1A@?0A@EA@AnnualTimeZoneRule@icu_56@@8 dd offset ??_R0?AVAnnualTimeZoneRule@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::AnnualTimeZoneRule::`RTTI	Base Class Array'o
					; icu_56::AnnualTimeZoneRule `RTTI Type	Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3AnnualTimeZoneRule@icu_56@@8 ; icu_56::AnnualTimeZoneRule::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::AnnualTimeZoneRule *this, const struct icu_56::UnicodeString	*, int,	int, struct icu_56::DateTimeRule *, int, int)
		public ??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPAVDateTimeRule@1@HH@Z
??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPAVDateTimeRule@1@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z ; icu_56::TimeZoneRule::TimeZoneRule(icu_56::UnicodeString const &,int,int)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7AnnualTimeZoneRule@icu_56@@6B@ ; const icu_56::AnnualTimeZoneRule::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_C]
		mov	[eax+4Ch], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_10]
		mov	[eax+50h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_14]
		mov	[eax+54h], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
??0AnnualTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPAVDateTimeRule@1@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1620h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::AnnualTimeZoneRule *this, const struct icu_56::AnnualTimeZoneRule *)
		public ??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z
??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z proc	near
					; CODE XREF: icu_56::AnnualTimeZoneRule::clone(void)+76p

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::TimeZoneRule *
		mov	ecx, [ebp+var_14] ; this
		call	??0TimeZoneRule@icu_56@@IAE@ABV01@@Z ; icu_56::TimeZoneRule::TimeZoneRule(icu_56::TimeZoneRule const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7AnnualTimeZoneRule@icu_56@@6B@ ; const icu_56::AnnualTimeZoneRule::`vftable'
		mov	esi, esp
		push	20h ; ' '       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_E0], 0
		jz	short loc_16BF
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4Ch]
		push	ecx		; struct icu_56::DateTimeRule *
		mov	ecx, [ebp+var_E0] ; this
		call	??0DateTimeRule@icu_56@@QAE@ABV01@@Z ; icu_56::DateTimeRule::DateTimeRule(icu_56::DateTimeRule const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_16C9
; ---------------------------------------------------------------------------

loc_16BF:				; CODE XREF: icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::AnnualTimeZoneRule const &)+83j
		mov	[ebp+var_F4], 0

loc_16C9:				; CODE XREF: icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::AnnualTimeZoneRule const &)+9Dj
		mov	edx, [ebp+var_F4]
		mov	[ebp+var_EC], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_EC]
		mov	[eax+4Ch], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+50h]
		mov	[eax+50h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+54h]
		mov	[eax+54h], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1728h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:0000176Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1TimeZoneRule@icu_56@@UAE@XZ ; icu_56::TimeZoneRule::~TimeZoneRule(void)
__unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z$1 proc near
					; DATA XREF: .xdata$x:00001774o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::AnnualTimeZoneRule const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1768h
__unwindtable$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001780o
		dd offset __unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z$0
		dd 0
		dd offset __unwindfunclet$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z$1
__ehfuncinfo$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z	dd 19930522h, 2
					; DATA XREF: __ehhandler$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 179Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AnnualTimeZoneRule::~AnnualTimeZoneRule(icu_56::AnnualTimeZoneRule *__hidden this)
		public ??1AnnualTimeZoneRule@icu_56@@UAE@XZ
??1AnnualTimeZoneRule@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::AnnualTimeZoneRule::`scalar deleting destructor'(uint)+26p
					; icu_56::AnnualTimeZoneRule::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1AnnualTimeZoneRule@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7AnnualTimeZoneRule@icu_56@@6B@ ; const icu_56::AnnualTimeZoneRule::`vftable'
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4Ch]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_1834
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_183E
; ---------------------------------------------------------------------------

loc_1834:				; CODE XREF: icu_56::AnnualTimeZoneRule::~AnnualTimeZoneRule(void)+71j
		mov	[ebp+var_F4], 0

loc_183E:				; CODE XREF: icu_56::AnnualTimeZoneRule::~AnnualTimeZoneRule(void)+96j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1TimeZoneRule@icu_56@@UAE@XZ ; icu_56::TimeZoneRule::~TimeZoneRule(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1AnnualTimeZoneRule@icu_56@@UAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 186Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1AnnualTimeZoneRule@icu_56@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00001898o
		mov	ecx, [ebp-14h]	; this
		jmp	??1TimeZoneRule@icu_56@@UAE@XZ ; icu_56::TimeZoneRule::~TimeZoneRule(void)
__unwindfunclet$??1AnnualTimeZoneRule@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1AnnualTimeZoneRule@icu_56@@UAE@XZ proc near
					; DATA XREF: icu_56::AnnualTimeZoneRule::~AnnualTimeZoneRule(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1AnnualTimeZoneRule@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1AnnualTimeZoneRule@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1894h
__unwindtable$??1AnnualTimeZoneRule@icu_56@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000018A4o
		dd offset __unwindfunclet$??1AnnualTimeZoneRule@icu_56@@UAE@XZ$0
__ehfuncinfo$??1AnnualTimeZoneRule@icu_56@@UAE@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$??1AnnualTimeZoneRule@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1AnnualTimeZoneRule@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::AnnualTimeZoneRule *__thiscall	icu_56::AnnualTimeZoneRule::clone(icu_56::AnnualTimeZoneRule *__hidden this)
		public ?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ
?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ proc near	; DATA XREF: .rdata:000014DCo

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		push	58h ; 'X'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_1943
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::AnnualTimeZoneRule *
		mov	ecx, [ebp+var_E0] ; this
		call	??0AnnualTimeZoneRule@icu_56@@QAE@ABV01@@Z ; icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::AnnualTimeZoneRule const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_194D
; ---------------------------------------------------------------------------

loc_1943:				; CODE XREF: icu_56::AnnualTimeZoneRule::clone(void)+6Aj
		mov	[ebp+var_F4], 0

loc_194D:				; CODE XREF: icu_56::AnnualTimeZoneRule::clone(void)+81j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_EC]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1988h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ$0	proc near
					; DATA XREF: .xdata$x:000019C4o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ proc near
					; DATA XREF: icu_56::AnnualTimeZoneRule::clone(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 19C0h
__unwindtable$?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000019D0o
		dd offset __unwindfunclet$?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ$0
__ehfuncinfo$?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ+14o
		dd offset __unwindtable$?clone@AnnualTimeZoneRule@icu_56@@UBEPAV12@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::AnnualTimeZoneRule & __thiscall	icu_56::AnnualTimeZoneRule::operator=(class icu_56::AnnualTimeZoneRule const &)
		public ??4AnnualTimeZoneRule@icu_56@@QAEAAV01@ABV01@@Z
??4AnnualTimeZoneRule@icu_56@@QAEAAV01@ABV01@@Z	proc near

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jz	loc_1AA0
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4TimeZoneRule@icu_56@@IAEAAV01@ABV01@@Z ; icu_56::TimeZoneRule::operator=(icu_56::TimeZoneRule const &)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]
		mov	[ebp+var_D4], ecx
		mov	edx, [ebp+var_D4]
		mov	[ebp+var_E0], edx
		cmp	[ebp+var_E0], 0
		jz	short loc_1A6D
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_E0]
		mov	edx, [eax]
		mov	ecx, [ebp+var_E0]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E8], eax
		jmp	short loc_1A77
; ---------------------------------------------------------------------------

loc_1A6D:				; CODE XREF: icu_56::AnnualTimeZoneRule::operator=(icu_56::AnnualTimeZoneRule const &)+5Aj
		mov	[ebp+var_E8], 0

loc_1A77:				; CODE XREF: icu_56::AnnualTimeZoneRule::operator=(icu_56::AnnualTimeZoneRule const &)+7Fj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4Ch]	; this
		call	?clone@DateTimeRule@icu_56@@QBEPAV12@XZ	; icu_56::DateTimeRule::clone(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+4Ch], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+50h]
		mov	[eax+50h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+54h]
		mov	[eax+54h], edx

loc_1AA0:				; CODE XREF: icu_56::AnnualTimeZoneRule::operator=(icu_56::AnnualTimeZoneRule const &)+29j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4AnnualTimeZoneRule@icu_56@@QAEAAV01@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::AnnualTimeZoneRule::operator==(class icu_56::TimeZoneRule const &)const
		public ??8AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z
??8AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z proc near
					; DATA XREF: .rdata:000014E0o

var_DC		= byte ptr -0DCh
var_D9		= byte ptr -0D9h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_1AEE
		mov	al, 1
		jmp	loc_1B74
; ---------------------------------------------------------------------------

loc_1AEE:				; CODE XREF: icu_56::AnnualTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+29j
		mov	eax, [ebp+arg_0]
		push	eax
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??9type_info@@QBE_NABV0@@Z ;	type_info::operator!=(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, al
		test	edx, edx
		jz	short loc_1B23
		xor	al, al
		jmp	short loc_1B74
; ---------------------------------------------------------------------------

loc_1B23:				; CODE XREF: icu_56::AnnualTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+61j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4Ch]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+4Ch]
		call	??8DateTimeRule@icu_56@@QBECABV01@@Z ; icu_56::DateTimeRule::operator==(icu_56::DateTimeRule const &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1B67
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+50h]
		cmp	eax, [edx+50h]
		jnz	short loc_1B67
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+54h]
		cmp	eax, [edx+54h]
		jnz	short loc_1B67
		mov	[ebp+var_D9], 1
		jmp	short loc_1B6E
; ---------------------------------------------------------------------------

loc_1B67:				; CODE XREF: icu_56::AnnualTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+84j
					; icu_56::AnnualTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+92j ...
		mov	[ebp+var_D9], 0

loc_1B6E:				; CODE XREF: icu_56::AnnualTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+A9j
		mov	al, [ebp+var_D9]

loc_1B74:				; CODE XREF: icu_56::AnnualTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+2Dj
					; icu_56::AnnualTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+65j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::AnnualTimeZoneRule::operator!=(class icu_56::TimeZoneRule const &)const
		public ??9AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z
??9AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z proc near
					; DATA XREF: .rdata:000014E4o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::DateTimeRule *__thiscall	icu_56::AnnualTimeZoneRule::getRule(icu_56::AnnualTimeZoneRule *__hidden this)
		public ?getRule@AnnualTimeZoneRule@icu_56@@QBEPBVDateTimeRule@2@XZ
?getRule@AnnualTimeZoneRule@icu_56@@QBEPBVDateTimeRule@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getRule@AnnualTimeZoneRule@icu_56@@QBEPBVDateTimeRule@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::AnnualTimeZoneRule::getStartYear(icu_56::AnnualTimeZoneRule *__hidden this)
		public ?getStartYear@AnnualTimeZoneRule@icu_56@@QBEHXZ
?getStartYear@AnnualTimeZoneRule@icu_56@@QBEHXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+50h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStartYear@AnnualTimeZoneRule@icu_56@@QBEHXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::AnnualTimeZoneRule::getEndYear(icu_56::AnnualTimeZoneRule *__hidden this)
		public ?getEndYear@AnnualTimeZoneRule@icu_56@@QBEHXZ
?getEndYear@AnnualTimeZoneRule@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+54h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getEndYear@AnnualTimeZoneRule@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AnnualTimeZoneRule::getStartInYear(icu_56::AnnualTimeZoneRule *this,	int, int, int, double *)
		public ?getStartInYear@AnnualTimeZoneRule@icu_56@@QBECHHHAAN@Z
?getStartInYear@AnnualTimeZoneRule@icu_56@@QBECHHHAAN@Z	proc near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getFirstStart(int,int,double &)+39p
					; icu_56::AnnualTimeZoneRule::getFinalStart(int,int,double &)+49p ...

var_150		= qword	ptr -150h
var_13C		= dword	ptr -13Ch
var_134		= dword	ptr -134h
var_6C		= dword	ptr -6Ch
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_2D		= byte ptr -2Dh
var_24		= dword	ptr -24h
var_18		= qword	ptr -18h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 13Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Fh ; 'O'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+50h]
		jl	short loc_1CB1
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+54h]
		jle	short loc_1CB8

loc_1CB1:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+2Cj
		xor	al, al
		jmp	loc_1F01
; ---------------------------------------------------------------------------

loc_1CB8:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+37j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]
		call	?getDateRuleType@DateTimeRule@icu_56@@QBE?AW4DateRuleType@12@XZ	; icu_56::DateTimeRule::getDateRuleType(void)
		mov	[ebp+var_24], eax
		cmp	[ebp+var_24], 0
		jnz	short loc_1CF8
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	?getRuleDayOfMonth@DateTimeRule@icu_56@@QBEHXZ ; icu_56::DateTimeRule::getRuleDayOfMonth(void)
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+4Ch]	; this
		call	?getRuleMonth@DateTimeRule@icu_56@@QBEHXZ ; icu_56::DateTimeRule::getRuleMonth(void)
		push	eax		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		call	?fieldsToDay@Grego@icu_56@@SANHHH@Z ; icu_56::Grego::fieldsToDay(int,int,int)
		add	esp, 0Ch
		fstp	[ebp+var_18]
		jmp	loc_1E95
; ---------------------------------------------------------------------------

loc_1CF8:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+52j
		mov	[ebp+var_2D], 1
		cmp	[ebp+var_24], 1
		jnz	loc_1DAC
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	?getRuleWeekInMonth@DateTimeRule@icu_56@@QBEHXZ	; icu_56::DateTimeRule::getRuleWeekInMonth(void)
		mov	[ebp+var_3C], eax
		cmp	[ebp+var_3C], 0
		jle	short loc_1D54
		push	1		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	?getRuleMonth@DateTimeRule@icu_56@@QBEHXZ ; icu_56::DateTimeRule::getRuleMonth(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	?fieldsToDay@Grego@icu_56@@SANHHH@Z ; icu_56::Grego::fieldsToDay(int,int,int)
		add	esp, 0Ch
		fstp	[ebp+var_18]
		mov	eax, [ebp+var_3C]
		sub	eax, 1
		imul	eax, 7
		mov	[ebp+var_134], eax
		fild	[ebp+var_134]
		fadd	[ebp+var_18]
		fstp	[ebp+var_18]
		jmp	short loc_1DAA
; ---------------------------------------------------------------------------

loc_1D54:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+A0j
		mov	[ebp+var_2D], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	?getRuleMonth@DateTimeRule@icu_56@@QBEHXZ ; icu_56::DateTimeRule::getRuleMonth(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	?monthLength@Grego@icu_56@@SACHH@Z ; icu_56::Grego::monthLength(int,int)
		add	esp, 8
		movsx	edx, al
		push	edx		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	?getRuleMonth@DateTimeRule@icu_56@@QBEHXZ ; icu_56::DateTimeRule::getRuleMonth(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	?fieldsToDay@Grego@icu_56@@SANHHH@Z ; icu_56::Grego::fieldsToDay(int,int,int)
		add	esp, 0Ch
		fstp	[ebp+var_18]
		mov	eax, [ebp+var_3C]
		add	eax, 1
		imul	eax, 7
		mov	[ebp+var_134], eax
		fild	[ebp+var_134]
		fadd	[ebp+var_18]
		fstp	[ebp+var_18]

loc_1DAA:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+DAj
		jmp	short loc_1E11
; ---------------------------------------------------------------------------

loc_1DAC:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+88j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	?getRuleMonth@DateTimeRule@icu_56@@QBEHXZ ; icu_56::DateTimeRule::getRuleMonth(void)
		mov	[ebp+var_48], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	?getRuleDayOfMonth@DateTimeRule@icu_56@@QBEHXZ ; icu_56::DateTimeRule::getRuleDayOfMonth(void)
		mov	[ebp+var_54], eax
		cmp	[ebp+var_24], 3
		jnz	short loc_1DFA
		mov	[ebp+var_2D], 0
		cmp	[ebp+var_48], 1
		jnz	short loc_1DFA
		cmp	[ebp+var_54], 1Dh
		jnz	short loc_1DFA
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	?isLeapYear@Grego@icu_56@@SACH@Z ; icu_56::Grego::isLeapYear(int)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_1DFA
		mov	eax, [ebp+var_54]
		sub	eax, 1
		mov	[ebp+var_54], eax

loc_1DFA:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+154j
					; icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double	&)+15Ej ...
		mov	eax, [ebp+var_54]
		push	eax		; int
		mov	ecx, [ebp+var_48]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		call	?fieldsToDay@Grego@icu_56@@SANHHH@Z ; icu_56::Grego::fieldsToDay(int,int,int)
		add	esp, 0Ch
		fstp	[ebp+var_18]

loc_1E11:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &):loc_1DAAj
		sub	esp, 8
		fld	[ebp+var_18]
		fstp	[esp+150h+var_150] ; double
		call	?dayOfWeek@Grego@icu_56@@SAHN@Z	; icu_56::Grego::dayOfWeek(double)
		add	esp, 8
		mov	[ebp+var_60], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		call	?getRuleDayOfWeek@DateTimeRule@icu_56@@QBEHXZ ;	icu_56::DateTimeRule::getRuleDayOfWeek(void)
		sub	eax, [ebp+var_60]
		mov	[ebp+var_6C], eax
		movsx	eax, [ebp+var_2D]
		test	eax, eax
		jz	short loc_1E66
		cmp	[ebp+var_6C], 0
		jge	short loc_1E52
		mov	eax, [ebp+var_6C]
		add	eax, 7
		mov	[ebp+var_134], eax
		jmp	short loc_1E5B
; ---------------------------------------------------------------------------

loc_1E52:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+1CAj
		mov	ecx, [ebp+var_6C]
		mov	[ebp+var_134], ecx

loc_1E5B:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+1D8j
		mov	edx, [ebp+var_134]
		mov	[ebp+var_6C], edx
		jmp	short loc_1E8C
; ---------------------------------------------------------------------------

loc_1E66:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+1C4j
		cmp	[ebp+var_6C], 0
		jle	short loc_1E7A
		mov	eax, [ebp+var_6C]
		sub	eax, 7
		mov	[ebp+var_134], eax
		jmp	short loc_1E83
; ---------------------------------------------------------------------------

loc_1E7A:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+1F2j
		mov	ecx, [ebp+var_6C]
		mov	[ebp+var_134], ecx

loc_1E83:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+200j
		mov	edx, [ebp+var_134]
		mov	[ebp+var_6C], edx

loc_1E8C:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+1ECj
		fild	[ebp+var_6C]
		fadd	[ebp+var_18]
		fstp	[ebp+var_18]

loc_1E95:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+7Bj
		fld	[ebp+var_18]
		fmul	ds:__real@4194997000000000
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]	; this
		fstp	qword ptr [ebp-138h]
		call	?getRuleMillisInDay@DateTimeRule@icu_56@@QBEHXZ	; icu_56::DateTimeRule::getRuleMillisInDay(void)
		mov	[ebp+var_13C], eax
		fild	[ebp+var_13C]
		fadd	qword ptr [ebp-138h]
		mov	ecx, [ebp+arg_C]
		fstp	qword ptr [ecx]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]
		call	?getTimeRuleType@DateTimeRule@icu_56@@QBE?AW4TimeRuleType@12@XZ	; icu_56::DateTimeRule::getTimeRuleType(void)
		cmp	eax, 2
		jz	short loc_1EE3
		fild	[ebp+arg_4]
		mov	eax, [ebp+arg_C]
		fsubr	qword ptr [eax]
		mov	ecx, [ebp+arg_C]
		fstp	qword ptr [ecx]

loc_1EE3:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+25Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]
		call	?getTimeRuleType@DateTimeRule@icu_56@@QBE?AW4TimeRuleType@12@XZ	; icu_56::DateTimeRule::getTimeRuleType(void)
		test	eax, eax
		jnz	short loc_1EFF
		fild	[ebp+arg_8]
		mov	eax, [ebp+arg_C]
		fsubr	qword ptr [eax]
		mov	ecx, [ebp+arg_C]
		fstp	qword ptr [ecx]

loc_1EFF:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+278j
		mov	al, 1

loc_1F01:				; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+3Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?getStartInYear@AnnualTimeZoneRule@icu_56@@QBECHHHAAN@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 1F18h
		public __real@4194997000000000
__real@4194997000000000	dq 8.64e7	; DATA XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+220r
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__cdecl	icu_56::Grego::isLeapYear(int)
		public ?isLeapYear@Grego@icu_56@@SACH@Z
?isLeapYear@Grego@icu_56@@SACH@Z proc near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+16Ap
					; icu_56::Grego::monthLength(int,int)+22p

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		and	eax, 3
		jnz	short loc_1F6D
		mov	eax, [ebp+arg_0]
		cdq
		mov	ecx, 64h ; 'd'
		idiv	ecx
		test	edx, edx
		jnz	short loc_1F64
		mov	eax, [ebp+arg_0]
		cdq
		mov	ecx, 190h
		idiv	ecx
		test	edx, edx
		jnz	short loc_1F6D

loc_1F64:				; CODE XREF: icu_56::Grego::isLeapYear(int)+33j
		mov	[ebp+var_C1], 1
		jmp	short loc_1F74
; ---------------------------------------------------------------------------

loc_1F6D:				; CODE XREF: icu_56::Grego::isLeapYear(int)+24j
					; icu_56::Grego::isLeapYear(int)+42j
		mov	[ebp+var_C1], 0

loc_1F74:				; CODE XREF: icu_56::Grego::isLeapYear(int)+4Bj
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLeapYear@Grego@icu_56@@SACH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__cdecl	icu_56::Grego::monthLength(int,	int)
		public ?monthLength@Grego@icu_56@@SACHH@Z
?monthLength@Grego@icu_56@@SACHH@Z proc	near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+F0p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	?isLeapYear@Grego@icu_56@@SACH@Z ; icu_56::Grego::isLeapYear(int)
		add	esp, 4
		movsx	ecx, al
		neg	ecx
		sbb	ecx, ecx
		and	ecx, 0Ch
		mov	edx, [ebp+arg_4]
		mov	al, byte ptr ds:?MONTH_LENGTH@Grego@icu_56@@0QBCB[edx+ecx] ; signed char const * const icu_56::Grego::MONTH_LENGTH
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?monthLength@Grego@icu_56@@SACHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::AnnualTimeZoneRule *this,	const struct icu_56::TimeZoneRule *)
		public ?isEquivalentTo@AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z
?isEquivalentTo@AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z proc near
					; DATA XREF: .rdata:000014E8o

var_DC		= byte ptr -0DCh
var_D9		= byte ptr -0D9h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]

loc_1FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		cmp	eax, [ebp+arg_0]
		jnz	short loc_200A
		mov	al, 1
		jmp	loc_20A3
; ---------------------------------------------------------------------------

loc_200A:				; CODE XREF: icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+29j
		mov	eax, [ebp+arg_0]
		push	eax
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??9type_info@@QBE_NABV0@@Z ;	type_info::operator!=(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, al
		test	edx, edx
		jnz	short loc_204E
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::TimeZoneRule *
		mov	ecx, [ebp+var_8] ; this
		call	?isEquivalentTo@TimeZoneRule@icu_56@@UBECABV12@@Z ; icu_56::TimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_2052

loc_204E:				; CODE XREF: icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+61j
		xor	al, al
		jmp	short loc_20A3
; ---------------------------------------------------------------------------

loc_2052:				; CODE XREF: icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+74j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4Ch]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+4Ch]
		call	??8DateTimeRule@icu_56@@QBECABV01@@Z ; icu_56::DateTimeRule::operator==(icu_56::DateTimeRule const &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_2096
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+50h]
		cmp	eax, [edx+50h]
		jnz	short loc_2096
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+54h]
		cmp	eax, [edx+54h]
		jnz	short loc_2096
		mov	[ebp+var_D9], 1
		jmp	short loc_209D
; ---------------------------------------------------------------------------

loc_2096:				; CODE XREF: icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+97j
					; icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const	&)+A5j	...
		mov	[ebp+var_D9], 0

loc_209D:				; CODE XREF: icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+BCj
		mov	al, [ebp+var_D9]

loc_20A3:				; CODE XREF: icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+2Dj
					; icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const	&)+78j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isEquivalentTo@AnnualTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AnnualTimeZoneRule::getFirstStart(icu_56::AnnualTimeZoneRule	*this, int, int, double	*)
		public ?getFirstStart@AnnualTimeZoneRule@icu_56@@UBECHHAAN@Z
?getFirstStart@AnnualTimeZoneRule@icu_56@@UBECHHAAN@Z proc near
					; DATA XREF: .rdata:000014ECo

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; double *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getStartInYear@AnnualTimeZoneRule@icu_56@@QBECHHHAAN@Z	; icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double	&)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getFirstStart@AnnualTimeZoneRule@icu_56@@UBECHHAAN@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2110h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AnnualTimeZoneRule::getFinalStart(icu_56::AnnualTimeZoneRule	*this, int, int, double	*)
		public ?getFinalStart@AnnualTimeZoneRule@icu_56@@UBECHHAAN@Z
?getFinalStart@AnnualTimeZoneRule@icu_56@@UBECHHAAN@Z proc near
					; DATA XREF: .rdata:000014F0o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+54h], 7FFFFFFFh
		jnz	short loc_2143
		xor	al, al
		jmp	short loc_215E
; ---------------------------------------------------------------------------

loc_2143:				; CODE XREF: icu_56::AnnualTimeZoneRule::getFinalStart(int,int,double &)+2Dj
		mov	eax, [ebp+arg_8]
		push	eax		; double *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+54h]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getStartInYear@AnnualTimeZoneRule@icu_56@@QBECHHHAAN@Z	; icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double	&)

loc_215E:				; CODE XREF: icu_56::AnnualTimeZoneRule::getFinalStart(int,int,double &)+31j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getFinalStart@AnnualTimeZoneRule@icu_56@@UBECHHAAN@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2174h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AnnualTimeZoneRule::getNextStart(icu_56::AnnualTimeZoneRule *this, double, int, int,	char, double *)
		public ?getNextStart@AnnualTimeZoneRule@icu_56@@UBECNHHCAAN@Z
?getNextStart@AnnualTimeZoneRule@icu_56@@UBECNHHCAAN@Z proc near
					; DATA XREF: .rdata:000014F4o

var_150		= qword	ptr -150h
var_124		= byte ptr -124h
var_60		= qword	ptr -60h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_124]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+var_50]
		push	eax		; int *
		lea	ecx, [ebp+var_44]
		push	ecx		; int *
		lea	edx, [ebp+var_38]
		push	edx		; int *
		lea	eax, [ebp+var_2C]
		push	eax		; int *
		lea	ecx, [ebp+var_20]
		push	ecx		; int *
		lea	edx, [ebp+var_14]
		push	edx		; int *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+150h+var_150] ; double
		call	?timeToFields@Grego@icu_56@@SAXNAAH00000@Z ; icu_56::Grego::timeToFields(double,int &,int &,int	&,int &,int &,int &)
		add	esp, 20h
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+50h]
		jge	short loc_21EF
		mov	esi, esp
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_225F
; ---------------------------------------------------------------------------

loc_21EF:				; CODE XREF: icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double	&)+55j
		lea	eax, [ebp+var_60]
		push	eax		; double *
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getStartInYear@AnnualTimeZoneRule@icu_56@@QBECHHHAAN@Z	; icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double	&)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_225D
		fld	[ebp+arg_0]
		fcomp	[ebp+var_60]
		fnstsw	ax
		test	ah, 41h
		jz	short loc_2232
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jnz	short loc_2251
		fld	[ebp+var_60]
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_2251

loc_2232:				; CODE XREF: icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double	&)+A5j
		mov	eax, [ebp+arg_14]
		push	eax		; double *
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+var_14]
		add	eax, 1
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getStartInYear@AnnualTimeZoneRule@icu_56@@QBECHHHAAN@Z	; icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double	&)
		jmp	short loc_225F
; ---------------------------------------------------------------------------
		jmp	short loc_225D
; ---------------------------------------------------------------------------

loc_2251:				; CODE XREF: icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double	&)+ADj
					; icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double &)+BCj
		mov	eax, [ebp+arg_14]
		fld	[ebp+var_60]
		fstp	qword ptr [eax]
		mov	al, 1
		jmp	short loc_225F
; ---------------------------------------------------------------------------

loc_225D:				; CODE XREF: icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double	&)+98j
					; icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double &)+DBj
		xor	al, al

loc_225F:				; CODE XREF: icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double	&)+79j
					; icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double &)+D9j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN16
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?getNextStart@AnnualTimeZoneRule@icu_56@@UBECNHHCAAN@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN16		dd 7			; DATA XREF: icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double	&)+EFo
		dd offset $LN15
$LN15		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000228Co
		dd offset $LN8		; "year"
		dd 0FFFFFFE0h, 4
		dd offset $LN9		; "month"
		dd 0FFFFFFD4h, 4
		dd offset $LN10
		dd 0FFFFFFC8h, 4
		dd offset $LN11
		dd 0FFFFFFBCh, 4
		dd offset $LN12
		dd 0FFFFFFB0h, 4
		dd offset $LN13
		dd 0FFFFFFA0h, 8
		dd offset $LN14
$LN14		dd 706D74h		; DATA XREF: .text:000022E0o
$LN13		dd 64696Dh		; DATA XREF: .text:000022D4o
$LN12		dd 796F64h		; DATA XREF: .text:000022C8o
$LN11		dd 776F64h		; DATA XREF: .text:000022BCo
$LN10		dd 6D6F64h		; DATA XREF: .text:000022B0o
$LN9		db 'month',0            ; DATA XREF: .text:000022A4o
$LN8		db 'year',0             ; DATA XREF: .text:00002298o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2304h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AnnualTimeZoneRule::getPreviousStart(icu_56::AnnualTimeZoneRule *this, double, int, int, char, double *)
		public ?getPreviousStart@AnnualTimeZoneRule@icu_56@@UBECNHHCAAN@Z
?getPreviousStart@AnnualTimeZoneRule@icu_56@@UBECNHHCAAN@Z proc	near
					; DATA XREF: .rdata:000014F8o

var_150		= qword	ptr -150h
var_124		= byte ptr -124h
var_60		= qword	ptr -60h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_124]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+var_50]
		push	eax		; int *
		lea	ecx, [ebp+var_44]
		push	ecx		; int *
		lea	edx, [ebp+var_38]
		push	edx		; int *
		lea	eax, [ebp+var_2C]
		push	eax		; int *
		lea	ecx, [ebp+var_20]
		push	ecx		; int *
		lea	edx, [ebp+var_14]
		push	edx		; int *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+150h+var_150] ; double
		call	?timeToFields@Grego@icu_56@@SAXNAAH00000@Z ; icu_56::Grego::timeToFields(double,int &,int &,int	&,int &,int &,int &)
		add	esp, 20h
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+54h]
		jle	short loc_237F
		mov	esi, esp
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_23EF
; ---------------------------------------------------------------------------

loc_237F:				; CODE XREF: icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed	char,double &)+55j
		lea	eax, [ebp+var_60]
		push	eax		; double *
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getStartInYear@AnnualTimeZoneRule@icu_56@@QBECHHHAAN@Z	; icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double	&)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_23ED
		fld	[ebp+arg_0]
		fcomp	[ebp+var_60]
		fnstsw	ax
		test	ah, 5
		jnp	short loc_23C2
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jnz	short loc_23E1
		fld	[ebp+var_60]
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_23E1

loc_23C2:				; CODE XREF: icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed	char,double &)+A5j
		mov	eax, [ebp+arg_14]
		push	eax		; double *
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+var_14]
		sub	eax, 1
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getStartInYear@AnnualTimeZoneRule@icu_56@@QBECHHHAAN@Z	; icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double	&)
		jmp	short loc_23EF
; ---------------------------------------------------------------------------
		jmp	short loc_23ED
; ---------------------------------------------------------------------------

loc_23E1:				; CODE XREF: icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed	char,double &)+ADj
					; icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed char,double &)+BCj
		mov	eax, [ebp+arg_14]
		fld	[ebp+var_60]
		fstp	qword ptr [eax]
		mov	al, 1
		jmp	short loc_23EF
; ---------------------------------------------------------------------------

loc_23ED:				; CODE XREF: icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed	char,double &)+98j
					; icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed char,double &)+DBj
		xor	al, al

loc_23EF:				; CODE XREF: icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed	char,double &)+79j
					; icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed char,double &)+D9j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN16_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?getPreviousStart@AnnualTimeZoneRule@icu_56@@UBECNHHCAAN@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN16_0		dd 7			; DATA XREF: icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed	char,double &)+EFo
		dd offset $LN15_0
$LN15_0		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000241Co
		dd offset $LN8_0	; "year"
		dd 0FFFFFFE0h, 4
		dd offset $LN9_0	; "month"
		dd 0FFFFFFD4h, 4
		dd offset $LN10_0
		dd 0FFFFFFC8h, 4
		dd offset $LN11_0
		dd 0FFFFFFBCh, 4
		dd offset $LN12_0
		dd 0FFFFFFB0h, 4
		dd offset $LN13_0
		dd 0FFFFFFA0h, 8
		dd offset $LN14_0
$LN14_0		dd 706D74h		; DATA XREF: .text:00002470o
$LN13_0		dd 64696Dh		; DATA XREF: .text:00002464o
$LN12_0		dd 796F64h		; DATA XREF: .text:00002458o
$LN11_0		dd 776F64h		; DATA XREF: .text:0000244Co
$LN10_0		dd 6D6F64h		; DATA XREF: .text:00002440o
$LN9_0		db 'month',0            ; DATA XREF: .text:00002434o
$LN8_0		db 'year',0             ; DATA XREF: .text:00002428o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2494h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::TimeArrayTimeZoneRule::getStaticClassID()
		public ?getStaticClassID@TimeArrayTimeZoneRule@icu_56@@SAPAXXZ
?getStaticClassID@TimeArrayTimeZoneRule@icu_56@@SAPAXXZ	proc near
					; CODE XREF: icu_56::TimeArrayTimeZoneRule::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@TimeArrayTimeZoneRule@icu_56@@SAPAXXZ@4DA ; char `icu_56::TimeArrayTimeZoneRule::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@TimeArrayTimeZoneRule@icu_56@@SAPAXXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::TimeArrayTimeZoneRule::getDynamicClassID(icu_56::TimeArrayTimeZoneRule *__hidden this)
		public ?getDynamicClassID@TimeArrayTimeZoneRule@icu_56@@UBEPAXXZ
?getDynamicClassID@TimeArrayTimeZoneRule@icu_56@@UBEPAXXZ proc near
					; DATA XREF: .rdata:00002618o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@TimeArrayTimeZoneRule@icu_56@@SAPAXXZ	; icu_56::TimeArrayTimeZoneRule::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@TimeArrayTimeZoneRule@icu_56@@UBEPAXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(class	icu_56::UnicodeString const &, int, int, double	const *, int, enum  icu_56::DateTimeRule::TimeRuleType)
		public ??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z
??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
Src		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z ; icu_56::TimeZoneRule::TimeZoneRule(icu_56::UnicodeString const &,int,int)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7TimeArrayTimeZoneRule@icu_56@@6B@ ;	const icu_56::TimeArrayTimeZoneRule::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_14]
		mov	[eax+4Ch], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+54h], 0
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	ecx, [ebp+var_14] ; this
		call	?initStartTimes@TimeArrayTimeZoneRule@icu_56@@AAECQBNHAAW4UErrorCode@@@Z ; icu_56::TimeArrayTimeZoneRule::initStartTimes(double	const *	const,int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z endp

; ---------------------------------------------------------------------------
$LN7		dd 1			; DATA XREF: icu_56::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(icu_56::UnicodeString	const &,int,int,double const *,int,icu_56::DateTimeRule::TimeRuleType)+A2o
		dd offset $LN6
$LN6		dd 0FFFFFFE0h, 4	; DATA XREF: .text:000025D0o
		dd offset $LN4		; "status"
$LN4		db 'status',0           ; DATA XREF: .text:000025DCo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 25E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z$0 proc near
					; DATA XREF: .xdata$x:00002640o
		mov	ecx, [ebp-14h]	; this
		jmp	??1TimeZoneRule@icu_56@@UAE@XZ ; icu_56::TimeZoneRule::~TimeZoneRule(void)
__unwindfunclet$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z proc	near
					; DATA XREF: icu_56::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(icu_56::UnicodeString	const &,int,int,double const *,int,icu_56::DateTimeRule::TimeRuleType)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2610h
		dd offset ??_R4TimeArrayTimeZoneRule@icu_56@@6B@ ; const icu_56::TimeArrayTimeZoneRule::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7TimeArrayTimeZoneRule@icu_56@@6B@
; const	icu_56::TimeArrayTimeZoneRule::`vftable'
??_7TimeArrayTimeZoneRule@icu_56@@6B@ dd offset	??_ETimeArrayTimeZoneRule@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(icu_56::UnicodeString	const &,int,int,double const *,int,icu_56::DateTimeRule::TimeRuleType)+60o
					; icu_56::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(icu_56::TimeArrayTimeZoneRule const &)+58o ...
					; icu_56::TimeArrayTimeZoneRule::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@TimeArrayTimeZoneRule@icu_56@@UBEPAXXZ ; icu_56::TimeArrayTimeZoneRule::getDynamicClassID(void)
		dd offset ?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ ; icu_56::TimeArrayTimeZoneRule::clone(void)
		dd offset ??8TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z ; icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)
		dd offset ??9TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z ; icu_56::TimeArrayTimeZoneRule::operator!=(icu_56::TimeZoneRule const &)
		dd offset ?isEquivalentTo@TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z ; icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)
		dd offset ?getFirstStart@TimeArrayTimeZoneRule@icu_56@@UBECHHAAN@Z ; icu_56::TimeArrayTimeZoneRule::getFirstStart(int,int,double &)
		dd offset ?getFinalStart@TimeArrayTimeZoneRule@icu_56@@UBECHHAAN@Z ; icu_56::TimeArrayTimeZoneRule::getFinalStart(int,int,double &)
		dd offset ?getNextStart@TimeArrayTimeZoneRule@icu_56@@UBECNHHCAAN@Z ; icu_56::TimeArrayTimeZoneRule::getNextStart(double,int,int,signed	char,double &)
		dd offset ?getPreviousStart@TimeArrayTimeZoneRule@icu_56@@UBECNHHCAAN@Z	; icu_56::TimeArrayTimeZoneRule::getPreviousStart(double,int,int,signed	char,double &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 263Ch
__unwindtable$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:0000264Co
		dd offset __unwindfunclet$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z$0
__ehfuncinfo$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z+14o
		dd offset __unwindtable$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABVUnicodeString@1@HHPBNHW4TimeRuleType@DateTimeRule@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2668h
		public ??_R4TimeArrayTimeZoneRule@icu_56@@6B@
; const	icu_56::TimeArrayTimeZoneRule::`RTTI Complete Object Locator'
??_R4TimeArrayTimeZoneRule@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00002610o
		dd offset ??_R0?AVTimeArrayTimeZoneRule@icu_56@@@8 ; icu_56::TimeArrayTimeZoneRule `RTTI Type Descriptor'
		dd offset ??_R3TimeArrayTimeZoneRule@icu_56@@8 ; icu_56::TimeArrayTimeZoneRule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 267Ch
		public ??_R0?AVTimeArrayTimeZoneRule@icu_56@@@8
; class	icu_56::TimeArrayTimeZoneRule `RTTI Type Descriptor'
??_R0?AVTimeArrayTimeZoneRule@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00002674o
					; .rdata$r:icu_56::TimeArrayTimeZoneRule::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avtimearrayt	db '.?AVTimeArrayTimeZoneRule@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 26A8h
		public ??_R3TimeArrayTimeZoneRule@icu_56@@8
; icu_56::TimeArrayTimeZoneRule::`RTTI Class Hierarchy Descriptor'
??_R3TimeArrayTimeZoneRule@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00002678o
					; .rdata$r:000026E4o
		dd 4
		dd offset ??_R2TimeArrayTimeZoneRule@icu_56@@8 ; icu_56::TimeArrayTimeZoneRule::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 26B8h
		public ??_R2TimeArrayTimeZoneRule@icu_56@@8
; icu_56::TimeArrayTimeZoneRule::`RTTI Base Class Array'
??_R2TimeArrayTimeZoneRule@icu_56@@8 dd	offset ??_R1A@?0A@EA@TimeArrayTimeZoneRule@icu_56@@8
					; DATA XREF: .rdata$r:000026B4o
					; icu_56::TimeArrayTimeZoneRule::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@TimeZoneRule@icu_56@@8 ; icu_56::TimeZoneRule::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 26CCh
		public ??_R1A@?0A@EA@TimeArrayTimeZoneRule@icu_56@@8
; icu_56::TimeArrayTimeZoneRule::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@TimeArrayTimeZoneRule@icu_56@@8 dd offset	??_R0?AVTimeArrayTimeZoneRule@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::TimeArrayTimeZoneRule::`RTTI Base	Class Array'o
					; icu_56::TimeArrayTimeZoneRule	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3TimeArrayTimeZoneRule@icu_56@@8 ; icu_56::TimeArrayTimeZoneRule::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(icu_56::TimeArrayTimeZoneRule *this, const struct icu_56::TimeArrayTimeZoneRule *)
		public ??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z
??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::TimeArrayTimeZoneRule::clone(void)+79p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::TimeZoneRule *
		mov	ecx, [ebp+var_14] ; this
		call	??0TimeZoneRule@icu_56@@IAE@ABV01@@Z ; icu_56::TimeZoneRule::TimeZoneRule(icu_56::TimeZoneRule const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7TimeArrayTimeZoneRule@icu_56@@6B@ ;	const icu_56::TimeArrayTimeZoneRule::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4Ch]
		mov	[eax+4Ch], edx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+54h], 0
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+50h]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+54h]
		push	ecx		; Src
		mov	ecx, [ebp+var_14] ; this
		call	?initStartTimes@TimeArrayTimeZoneRule@icu_56@@AAECQBNHAAW4UErrorCode@@@Z ; icu_56::TimeArrayTimeZoneRule::initStartTimes(double	const *	const,int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_0		dd 1			; DATA XREF: icu_56::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(icu_56::TimeArrayTimeZoneRule	const &)+A3o
		dd offset $LN6_0
$LN6_0		dd 0FFFFFFE0h, 4	; DATA XREF: .text:000027C0o
		dd offset $LN4_0	; "status"
$LN4_0		db 'status',0           ; DATA XREF: .text:000027CCo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 27D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z$0	proc near
					; DATA XREF: .xdata$x:00002804o
		mov	ecx, [ebp-14h]	; this
		jmp	??1TimeZoneRule@icu_56@@UAE@XZ ; icu_56::TimeZoneRule::~TimeZoneRule(void)
__unwindfunclet$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(icu_56::TimeArrayTimeZoneRule	const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2800h
__unwindtable$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002810o
		dd offset __unwindfunclet$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 282Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::TimeArrayTimeZoneRule::~TimeArrayTimeZoneRule(icu_56::TimeArrayTimeZoneRule	*__hidden this)
		public ??1TimeArrayTimeZoneRule@icu_56@@UAE@XZ
??1TimeArrayTimeZoneRule@icu_56@@UAE@XZ	proc near
					; CODE XREF: icu_56::TimeArrayTimeZoneRule::`scalar deleting destructor'(uint)+26p
					; icu_56::TimeArrayTimeZoneRule::`vector deleting destructor'(uint)+71p
					; DATA XREF: ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TimeArrayTimeZoneRule@icu_56@@6B@ ;	const icu_56::TimeArrayTimeZoneRule::`vftable'
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+54h], 0
		jz	short loc_287E
		mov	eax, [ebp+var_8]
		add	eax, 58h ; 'X'
		mov	ecx, [ebp+var_8]
		cmp	[ecx+54h], eax
		jz	short loc_287E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+54h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_287E:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::~TimeArrayTimeZoneRule(void)+33j
					; icu_56::TimeArrayTimeZoneRule::~TimeArrayTimeZoneRule(void)+41j
		mov	ecx, [ebp+var_8] ; this
		call	??1TimeZoneRule@icu_56@@UAE@XZ ; icu_56::TimeZoneRule::~TimeZoneRule(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1TimeArrayTimeZoneRule@icu_56@@UAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 289Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::TimeArrayTimeZoneRule *__thiscall icu_56::TimeArrayTimeZoneRule::clone(icu_56::TimeArrayTimeZoneRule *__hidden	this)
		public ?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ
?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ proc near ; DATA XREF:	.rdata:0000261Co

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		push	158h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_2922
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::TimeArrayTimeZoneRule *
		mov	ecx, [ebp+var_E0] ; this
		call	??0TimeArrayTimeZoneRule@icu_56@@QAE@ABV01@@Z ;	icu_56::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(icu_56::TimeArrayTimeZoneRule const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_292C
; ---------------------------------------------------------------------------

loc_2922:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::clone(void)+6Dj
		mov	[ebp+var_F4], 0

loc_292C:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::clone(void)+84j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_EC]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2964h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ$0 proc	near
					; DATA XREF: .xdata$x:000029A0o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ proc near
					; DATA XREF: icu_56::TimeArrayTimeZoneRule::clone(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 299Ch
__unwindtable$?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000029ACo
		dd offset __unwindfunclet$?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ$0
__ehfuncinfo$?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ+14o
		dd offset __unwindtable$?clone@TimeArrayTimeZoneRule@icu_56@@UBEPAV12@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::TimeArrayTimeZoneRule &	__thiscall icu_56::TimeArrayTimeZoneRule::operator=(class icu_56::TimeArrayTimeZoneRule	const &)
		public ??4TimeArrayTimeZoneRule@icu_56@@QAEAAV01@ABV01@@Z
??4TimeArrayTimeZoneRule@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jz	short loc_2A2C
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4TimeZoneRule@icu_56@@IAEAAV01@ABV01@@Z ; icu_56::TimeZoneRule::operator=(icu_56::TimeZoneRule const &)
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+50h]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+54h]
		push	ecx		; Src
		mov	ecx, [ebp+var_8] ; this
		call	?initStartTimes@TimeArrayTimeZoneRule@icu_56@@AAECQBNHAAW4UErrorCode@@@Z ; icu_56::TimeArrayTimeZoneRule::initStartTimes(double	const *	const,int,UErrorCode &)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4Ch]
		mov	[eax+4Ch], edx

loc_2A2C:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::operator=(icu_56::TimeArrayTimeZoneRule const &)+29j
		mov	eax, [ebp+var_8]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4TimeArrayTimeZoneRule@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN6_1		dd 1			; DATA XREF: icu_56::TimeArrayTimeZoneRule::operator=(icu_56::TimeArrayTimeZoneRule const &)+6Bo
		dd offset $LN5
$LN5		dd 0FFFFFFECh, 4	; DATA XREF: .text:00002A5Co
		dd offset $LN4_1	; "status"
$LN4_1		db 'status',0           ; DATA XREF: .text:00002A68o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::TimeArrayTimeZoneRule::operator==(class icu_56::TimeZoneRule const &)const
		public ??8TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z
??8TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z proc near
					; DATA XREF: .rdata:00002620o

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_2AA6
		mov	al, 1
		jmp	loc_2B61
; ---------------------------------------------------------------------------

loc_2AA6:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+29j
		mov	eax, [ebp+arg_0]
		push	eax
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??9type_info@@QBE_NABV0@@Z ;	type_info::operator!=(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, al
		test	edx, edx
		jnz	short loc_2AEA
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8TimeZoneRule@icu_56@@UBECABV01@@Z ; icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule const &)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_2AEE

loc_2AEA:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+61j
		xor	al, al
		jmp	short loc_2B61
; ---------------------------------------------------------------------------

loc_2AEE:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+74j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+4Ch]
		cmp	edx, [ecx+4Ch]
		jnz	short loc_2B10
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+50h]
		cmp	edx, [ecx+50h]
		jz	short loc_2B14

loc_2B10:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+8Cj
		xor	al, al
		jmp	short loc_2B61
; ---------------------------------------------------------------------------

loc_2B14:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+9Aj
		mov	[ebp+var_1D], 1
		mov	[ebp+var_2C], 0
		jmp	short loc_2B2A
; ---------------------------------------------------------------------------

loc_2B21:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &):loc_2B5Cj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_2B2A:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+ABj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+50h]
		jge	short loc_2B5E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+54h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+54h]
		mov	edx, [ebp+var_2C]
		mov	esi, [ebp+var_2C]
		fld	qword ptr [ecx+edx*8]
		fld	qword ptr [eax+esi*8]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jnp	short loc_2B5C
		mov	[ebp+var_1D], 0
		jmp	short loc_2B5E
; ---------------------------------------------------------------------------

loc_2B5C:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+E0j
		jmp	short loc_2B21
; ---------------------------------------------------------------------------

loc_2B5E:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+BFj
					; icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+E6j
		mov	al, [ebp+var_1D]

loc_2B61:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+2Dj
					; icu_56::TimeArrayTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+78j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::TimeArrayTimeZoneRule::operator!=(class icu_56::TimeZoneRule const &)const
		public ??9TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z
??9TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z proc near
					; DATA XREF: .rdata:00002624o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: enum	icu_56::DateTimeRule::TimeRuleType __thiscall icu_56::TimeArrayTimeZoneRule::getTimeType(void)const
		public ?getTimeType@TimeArrayTimeZoneRule@icu_56@@QBE?AW4TimeRuleType@DateTimeRule@2@XZ
?getTimeType@TimeArrayTimeZoneRule@icu_56@@QBE?AW4TimeRuleType@DateTimeRule@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getTimeType@TimeArrayTimeZoneRule@icu_56@@QBE?AW4TimeRuleType@DateTimeRule@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::TimeArrayTimeZoneRule::getStartTimeAt(icu_56::TimeArrayTimeZoneRule *this, int, double *)
		public ?getStartTimeAt@TimeArrayTimeZoneRule@icu_56@@QBECHAAN@Z
?getStartTimeAt@TimeArrayTimeZoneRule@icu_56@@QBECHAAN@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+50h]
		jge	short loc_2C38
		cmp	[ebp+arg_0], 0
		jge	short loc_2C3C

loc_2C38:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getStartTimeAt(int,double &)+2Cj
		xor	al, al
		jmp	short loc_2C4F
; ---------------------------------------------------------------------------

loc_2C3C:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getStartTimeAt(int,double &)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+54h]
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+arg_0]
		fld	qword ptr [ecx+eax*8]
		fstp	qword ptr [edx]
		mov	al, 1

loc_2C4F:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getStartTimeAt(int,double &)+36j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?getStartTimeAt@TimeArrayTimeZoneRule@icu_56@@QBECHAAN@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::TimeArrayTimeZoneRule::countStartTimes(icu_56::TimeArrayTimeZoneRule *__hidden	this)
		public ?countStartTimes@TimeArrayTimeZoneRule@icu_56@@QBEHXZ
?countStartTimes@TimeArrayTimeZoneRule@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+50h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?countStartTimes@TimeArrayTimeZoneRule@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeArrayTimeZoneRule *this, const struct icu_56::TimeZoneRule	*)
		public ?isEquivalentTo@TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z
?isEquivalentTo@TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z proc near
					; DATA XREF: .rdata:00002628o

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_2CBA
		mov	al, 1
		jmp	loc_2D75
; ---------------------------------------------------------------------------

loc_2CBA:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &)+29j
		mov	eax, [ebp+arg_0]
		push	eax
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??9type_info@@QBE_NABV0@@Z ;	type_info::operator!=(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, al
		test	edx, edx
		jnz	short loc_2CFE
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::TimeZoneRule *
		mov	ecx, [ebp+var_8] ; this
		call	?isEquivalentTo@TimeZoneRule@icu_56@@UBECABV12@@Z ; icu_56::TimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_2D02

loc_2CFE:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &)+61j
		xor	al, al
		jmp	short loc_2D75
; ---------------------------------------------------------------------------

loc_2D02:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &)+74j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+4Ch]
		cmp	edx, [ecx+4Ch]
		jnz	short loc_2D24
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+50h]
		cmp	edx, [ecx+50h]
		jz	short loc_2D28

loc_2D24:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &)+8Cj
		xor	al, al
		jmp	short loc_2D75
; ---------------------------------------------------------------------------

loc_2D28:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &)+9Aj
		mov	[ebp+var_1D], 1
		mov	[ebp+var_2C], 0
		jmp	short loc_2D3E
; ---------------------------------------------------------------------------

loc_2D35:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &):loc_2D70j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_2D3E:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &)+ABj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+50h]
		jge	short loc_2D72
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+54h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+54h]
		mov	edx, [ebp+var_2C]
		mov	esi, [ebp+var_2C]
		fld	qword ptr [ecx+edx*8]
		fld	qword ptr [eax+esi*8]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jnp	short loc_2D70
		mov	[ebp+var_1D], 0
		jmp	short loc_2D72
; ---------------------------------------------------------------------------

loc_2D70:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &)+E0j
		jmp	short loc_2D35
; ---------------------------------------------------------------------------

loc_2D72:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &)+BFj
					; icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+E6j
		mov	al, [ebp+var_1D]

loc_2D75:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule	const &)+2Dj
					; icu_56::TimeArrayTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+78j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isEquivalentTo@TimeArrayTimeZoneRule@icu_56@@UBECABVTimeZoneRule@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::TimeArrayTimeZoneRule::getFirstStart(icu_56::TimeArrayTimeZoneRule *this, int, int, double *)
		public ?getFirstStart@TimeArrayTimeZoneRule@icu_56@@UBECHHAAN@Z
?getFirstStart@TimeArrayTimeZoneRule@icu_56@@UBECHHAAN@Z proc near
					; DATA XREF: .rdata:0000262Co

var_E8		= qword	ptr -0E8h
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+50h], 0
		jle	short loc_2DC1
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_2DC5

loc_2DC1:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getFirstStart(int,int,double &)+2Aj
		xor	al, al
		jmp	short loc_2DEA
; ---------------------------------------------------------------------------

loc_2DC5:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getFirstStart(int,int,double &)+33j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		mov	eax, [edx+54h]
		sub	esp, 8
		fld	qword ptr [eax]
		fstp	[esp+0E8h+var_E8] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?getUTC@TimeArrayTimeZoneRule@icu_56@@ABENNHH@Z	; icu_56::TimeArrayTimeZoneRule::getUTC(double,int,int)
		mov	ecx, [ebp+arg_8]
		fstp	qword ptr [ecx]
		mov	al, 1

loc_2DEA:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getFirstStart(int,int,double &)+37j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getFirstStart@TimeArrayTimeZoneRule@icu_56@@UBECHHAAN@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::TimeArrayTimeZoneRule::getFinalStart(icu_56::TimeArrayTimeZoneRule *this, int, int, double *)
		public ?getFinalStart@TimeArrayTimeZoneRule@icu_56@@UBECHHAAN@Z
?getFinalStart@TimeArrayTimeZoneRule@icu_56@@UBECHHAAN@Z proc near
					; DATA XREF: .rdata:00002630o

var_E8		= qword	ptr -0E8h
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+50h], 0
		jle	short loc_2E35
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_2E39

loc_2E35:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getFinalStart(int,int,double &)+2Aj
		xor	al, al
		jmp	short loc_2E66
; ---------------------------------------------------------------------------

loc_2E39:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getFinalStart(int,int,double &)+33j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		mov	eax, [edx+50h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+54h]
		sub	esp, 8
		fld	qword ptr [edx+eax*8-8]
		fstp	[esp+0E8h+var_E8] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?getUTC@TimeArrayTimeZoneRule@icu_56@@ABENNHH@Z	; icu_56::TimeArrayTimeZoneRule::getUTC(double,int,int)
		mov	eax, [ebp+arg_8]
		fstp	qword ptr [eax]
		mov	al, 1

loc_2E66:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getFinalStart(int,int,double &)+37j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getFinalStart@TimeArrayTimeZoneRule@icu_56@@UBECHHAAN@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::TimeArrayTimeZoneRule::getNextStart(icu_56::TimeArrayTimeZoneRule *this, double, int, int, char, double *)
		public ?getNextStart@TimeArrayTimeZoneRule@icu_56@@UBECNHHCAAN@Z
?getNextStart@TimeArrayTimeZoneRule@icu_56@@UBECNHHCAAN@Z proc near
					; DATA XREF: .rdata:00002634o

var_104		= qword	ptr -104h
var_E8		= byte ptr -0E8h
var_24		= qword	ptr -24h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]
		sub	ecx, 1
		mov	[ebp+var_14], ecx
		jmp	short loc_2EB6
; ---------------------------------------------------------------------------

loc_2EAD:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getNextStart(double,int,int,signed char,double &)+93j
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax

loc_2EB6:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getNextStart(double,int,int,signed char,double &)+2Fj
		cmp	[ebp+var_14], 0
		jl	short loc_2F11
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		mov	eax, [edx+54h]
		mov	ecx, [ebp+var_14]
		sub	esp, 8
		fld	qword ptr [eax+ecx*8]
		fstp	[esp+104h+var_104] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?getUTC@TimeArrayTimeZoneRule@icu_56@@ABENNHH@Z	; icu_56::TimeArrayTimeZoneRule::getUTC(double,int,int)
		fstp	[ebp+var_24]
		fld	[ebp+arg_0]
		fcomp	[ebp+var_24]
		fnstsw	ax
		test	ah, 41h
		jz	short loc_2F05
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jnz	short loc_2F07
		fld	[ebp+var_24]
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_2F07

loc_2F05:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getNextStart(double,int,int,signed char,double &)+70j
		jmp	short loc_2F11
; ---------------------------------------------------------------------------

loc_2F07:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getNextStart(double,int,int,signed char,double &)+78j
					; icu_56::TimeArrayTimeZoneRule::getNextStart(double,int,int,signed char,double	&)+87j
		mov	eax, [ebp+arg_14]
		fld	[ebp+var_24]
		fstp	qword ptr [eax]
		jmp	short loc_2EAD
; ---------------------------------------------------------------------------

loc_2F11:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getNextStart(double,int,int,signed char,double &)+3Ej
					; icu_56::TimeArrayTimeZoneRule::getNextStart(double,int,int,signed char,double	&):loc_2F05j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]
		sub	ecx, 1
		cmp	[ebp+var_14], ecx
		jnz	short loc_2F23
		xor	al, al
		jmp	short loc_2F25
; ---------------------------------------------------------------------------

loc_2F23:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getNextStart(double,int,int,signed char,double &)+A1j
		mov	al, 1

loc_2F25:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getNextStart(double,int,int,signed char,double &)+A5j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?getNextStart@TimeArrayTimeZoneRule@icu_56@@UBECNHHCAAN@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::TimeArrayTimeZoneRule::getPreviousStart(icu_56::TimeArrayTimeZoneRule *this,	double,	int, int, char,	double *)
		public ?getPreviousStart@TimeArrayTimeZoneRule@icu_56@@UBECNHHCAAN@Z
?getPreviousStart@TimeArrayTimeZoneRule@icu_56@@UBECNHHCAAN@Z proc near
					; DATA XREF: .rdata:00002638o

var_104		= qword	ptr -104h
var_E8		= byte ptr -0E8h
var_24		= qword	ptr -24h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]
		sub	ecx, 1
		mov	[ebp+var_14], ecx
		jmp	short loc_2F76
; ---------------------------------------------------------------------------

loc_2F6D:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getPreviousStart(double,int,int,signed char,double &):loc_2FD1j
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax

loc_2F76:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getPreviousStart(double,int,int,signed char,double &)+2Fj
		cmp	[ebp+var_14], 0
		jl	short loc_2FD3
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		mov	eax, [edx+54h]
		mov	ecx, [ebp+var_14]
		sub	esp, 8
		fld	qword ptr [eax+ecx*8]
		fstp	[esp+104h+var_104] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?getUTC@TimeArrayTimeZoneRule@icu_56@@ABENNHH@Z	; icu_56::TimeArrayTimeZoneRule::getUTC(double,int,int)
		fstp	[ebp+var_24]
		fld	[ebp+arg_0]
		fcomp	[ebp+var_24]
		fnstsw	ax
		test	ah, 41h
		jz	short loc_2FC5
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jz	short loc_2FD1
		fld	[ebp+var_24]
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_2FD1

loc_2FC5:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getPreviousStart(double,int,int,signed char,double &)+70j
		mov	eax, [ebp+arg_14]
		fld	[ebp+var_24]
		fstp	qword ptr [eax]
		mov	al, 1
		jmp	short loc_2FD5
; ---------------------------------------------------------------------------

loc_2FD1:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getPreviousStart(double,int,int,signed char,double &)+78j
					; icu_56::TimeArrayTimeZoneRule::getPreviousStart(double,int,int,signed	char,double &)+87j
		jmp	short loc_2F6D
; ---------------------------------------------------------------------------

loc_2FD3:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getPreviousStart(double,int,int,signed char,double &)+3Ej
		xor	al, al

loc_2FD5:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getPreviousStart(double,int,int,signed char,double &)+93j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?getPreviousStart@TimeArrayTimeZoneRule@icu_56@@UBECNHHCAAN@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::TimeArrayTimeZoneRule::initStartTimes(icu_56::TimeArrayTimeZoneRule *this, const double *const Src, int, enum UErrorCode *)
		public ?initStartTimes@TimeArrayTimeZoneRule@icu_56@@AAECQBNHAAW4UErrorCode@@@Z
?initStartTimes@TimeArrayTimeZoneRule@icu_56@@AAECQBNHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(icu_56::UnicodeString	const &,int,int,double const *,int,icu_56::DateTimeRule::TimeRuleType)+8Fp
					; icu_56::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(icu_56::TimeArrayTimeZoneRule const &)+90p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]

loc_2FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+54h], 0
		jz	short loc_3035
		mov	eax, [ebp+var_8]
		add	eax, 58h ; 'X'
		mov	ecx, [ebp+var_8]
		cmp	[ecx+54h], eax
		jz	short loc_3035
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+54h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_3035:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+2Aj
					; icu_56::TimeArrayTimeZoneRule::initStartTimes(double const * const,int,UErrorCode &)+38j
		cmp	[ebp+arg_4], 20h ; ' '
		jle	short loc_3075
		mov	eax, [ebp+arg_4]
		shl	eax, 3
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		mov	[ecx+54h], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_3073
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+50h], 0
		xor	al, al
		jmp	loc_3122
; ---------------------------------------------------------------------------

loc_3073:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+6Bj
		jmp	short loc_3081
; ---------------------------------------------------------------------------

loc_3075:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+4Dj
		mov	eax, [ebp+var_8]
		add	eax, 58h ; 'X'
		mov	ecx, [ebp+var_8]
		mov	[ecx+54h], eax

loc_3081:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &):loc_3073j
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+arg_4]
		shl	ecx, 3
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+54h]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+50h], ecx
		mov	eax, [ebp+arg_8]
		push	eax
		push	1
		push	0
		push	offset _compareDates
		push	8
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+50h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+54h]
		push	ecx
		call	_uprv_sortArray_56
		add	esp, 1Ch
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3120
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+54h], 0
		jz	short loc_3112
		mov	eax, [ebp+var_8]
		add	eax, 58h ; 'X'
		mov	ecx, [ebp+var_8]
		cmp	[ecx+54h], eax
		jz	short loc_3112
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+54h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_3112:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+107j
					; icu_56::TimeArrayTimeZoneRule::initStartTimes(double const * const,int,UErrorCode &)+115j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+50h], 0
		xor	al, al
		jmp	short loc_3122
; ---------------------------------------------------------------------------

loc_3120:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+FEj
		mov	al, 1

loc_3122:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+82j
					; icu_56::TimeArrayTimeZoneRule::initStartTimes(double const * const,int,UErrorCode &)+132j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?initStartTimes@TimeArrayTimeZoneRule@icu_56@@AAECQBNHAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3138h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+F1p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3164h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_compareDates	proc near		; DATA XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+CEo

var_F4		= dword	ptr -0F4h
var_F0		= dword	ptr -0F0h
var_28		= dword	ptr -28h
var_1C		= qword	ptr -1Ch
var_C		= qword	ptr -0Ch
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		fld	qword ptr [eax]
		fstp	[ebp+var_C]
		mov	eax, [ebp+arg_8]
		fld	qword ptr [eax]
		fstp	[ebp+var_1C]
		fld	[ebp+var_1C]
		fcomp	[ebp+var_C]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_31AB
		mov	[ebp+var_F0], 0FFFFFFFFh
		jmp	short loc_31DC
; ---------------------------------------------------------------------------

loc_31AB:				; CODE XREF: _compareDates+39j
		fld	[ebp+var_C]
		fld	[ebp+var_1C]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_31C6
		mov	[ebp+var_F4], 0
		jmp	short loc_31D0
; ---------------------------------------------------------------------------

loc_31C6:				; CODE XREF: _compareDates+54j
		mov	[ebp+var_F4], 1

loc_31D0:				; CODE XREF: _compareDates+60j
		mov	eax, [ebp+var_F4]
		mov	[ebp+var_F0], eax

loc_31DC:				; CODE XREF: _compareDates+45j
		mov	ecx, [ebp+var_F0]
		mov	[ebp+var_28], ecx
		mov	eax, [ebp+var_28]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_compareDates	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::TimeArrayTimeZoneRule::getUTC(icu_56::TimeArrayTimeZoneRule	*this, double, int, int)
		public ?getUTC@TimeArrayTimeZoneRule@icu_56@@ABENNHH@Z
?getUTC@TimeArrayTimeZoneRule@icu_56@@ABENNHH@Z	proc near
					; CODE XREF: icu_56::TimeArrayTimeZoneRule::getFirstStart(int,int,double &)+52p
					; icu_56::TimeArrayTimeZoneRule::getFinalStart(int,int,double &)+5Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 2
		jz	short loc_3225
		fild	[ebp+arg_8]
		fsubr	[ebp+arg_0]
		fstp	[ebp+arg_0]

loc_3225:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getUTC(double,int,int)+2Aj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0
		jnz	short loc_3237
		fild	[ebp+arg_C]
		fsubr	[ebp+arg_0]
		fstp	[ebp+arg_0]

loc_3237:				; CODE XREF: icu_56::TimeArrayTimeZoneRule::getUTC(double,int,int)+3Cj
		fld	[ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	10h
?getUTC@TimeArrayTimeZoneRule@icu_56@@ABENNHH@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::TimeZoneRule::`scalar deleting destructor'(uint)+39p
					; icu_56::TimeZoneRule::`vector	deleting destructor'(uint)+81p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::TimeZoneRule::`scalar deleting destructor'(uint)+44p
					; icu_56::TimeZoneRule::`scalar	deleting destructor'(uint)+57p ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn __imp_??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::TimeZoneRule::`vector deleting destructor'(uint)+53p
					; icu_56::InitialTimeZoneRule::`vector deleting	destructor'(uint)+53p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::TimeZoneRule::`vector deleting destructor'(uint)+3Dp
					; icu_56::InitialTimeZoneRule::`vector deleting	destructor'(uint)+3Dp ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn __imp_??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z$0+5p
					; __unwindfunclet$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z$0+5p ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn __imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::TimeZoneRule::TimeZoneRule(icu_56::UnicodeString const &,int,int)+70p
					; icu_56::TimeZoneRule::TimeZoneRule(icu_56::TimeZoneRule const	&)+77p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		extrn __imp_??0UObject@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::TimeZoneRule::TimeZoneRule(icu_56::UnicodeString const &,int,int)+47p
					; DATA XREF: icu_56::TimeZoneRule::TimeZoneRule(icu_56::UnicodeString const &,int,int)+47r
		extrn ___security_cookie:near
					; DATA XREF: icu_56::TimeZoneRule::TimeZoneRule(icu_56::UnicodeString const &,int,int)+2Er
					; icu_56::TimeZoneRule::TimeZoneRule(icu_56::TimeZoneRule const	&)+2Er	...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z+19j
					; __ehhandler$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z+19j	...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0TimeZoneRule@icu_56@@IAE@ABVUnicodeString@1@HH@Z+Fp
					; __ehhandler$??0TimeZoneRule@icu_56@@IAE@ABV01@@Z+Fp ...
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::TimeZoneRule	`RTTI Type Descriptor'o
					; .data:icu_56::UObject	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000006ACo
		extrn __purecall:near	; DATA XREF: .rdata:000006B0o
					; .rdata:000006C0o ...
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this, const struct icu_56::UObject *)
		extrn __imp_??0UObject@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::TimeZoneRule::TimeZoneRule(icu_56::TimeZoneRule const &)+4Bp
					; DATA XREF: icu_56::TimeZoneRule::TimeZoneRule(icu_56::TimeZoneRule const &)+4Br
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::TimeZoneRule::~TimeZoneRule(void)+5Ap
					; DATA XREF: icu_56::TimeZoneRule::~TimeZoneRule(void)+5Ar
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString const &)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::TimeZoneRule::operator=(icu_56::TimeZoneRule const	&)+3Ap
					; icu_56::TimeZoneRule::getName(icu_56::UnicodeString &)+2Fp
					; DATA XREF: ...
; __declspec(dllimport)	public:	signed char __thiscall icu_56::UnicodeString::operator==(class icu_56::UnicodeString const &)const
		extrn __imp_??8UnicodeString@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule const &)+6Bp
					; DATA XREF: icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule const &)+6Br
; __declspec(dllimport)	public:	bool __thiscall	type_info::operator==(class type_info const &)const
		extrn __imp_??8type_info@@QBE_NABV0@@Z:near
					; CODE XREF: icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule const &)+48p
					; icu_56::TimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+48p ...
		extrn ___RTtypeid:near	; CODE XREF: icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule const &)+2Fp
					; icu_56::TimeZoneRule::operator==(icu_56::TimeZoneRule	const &)+3Ep ...
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn __imp_??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::InitialTimeZoneRule::clone(void)+46p
					; icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::UnicodeString const &,int,int,icu_56::DateTimeRule const &,int,int)+6Ap ...
; __declspec(dllimport)	public:	bool __thiscall	type_info::operator!=(class type_info const &)const
		extrn __imp_??9type_info@@QBE_NABV0@@Z:near
					; CODE XREF: icu_56::InitialTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const &)+4Cp
					; icu_56::AnnualTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+4Fp ...
; _DWORD __thiscall icu_56::DateTimeRule::DateTimeRule(icu_56::DateTimeRule *__hidden this, const struct icu_56::DateTimeRule *)
		extrn ??0DateTimeRule@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::UnicodeString const	&,int,int,icu_56::DateTimeRule const &,int,int)+97p
					; icu_56::AnnualTimeZoneRule::AnnualTimeZoneRule(icu_56::AnnualTimeZoneRule const &)+92p
; struct icu_56::DateTimeRule *__thiscall icu_56::DateTimeRule::clone(icu_56::DateTimeRule *__hidden this)
		extrn ?clone@DateTimeRule@icu_56@@QBEPAV12@XZ:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::operator=(icu_56::AnnualTimeZoneRule const &)+91p
; public: signed char __thiscall icu_56::DateTimeRule::operator==(class	icu_56::DateTimeRule const &)const
		extrn ??8DateTimeRule@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::operator==(icu_56::TimeZoneRule const &)+7Ap
					; icu_56::AnnualTimeZoneRule::isEquivalentTo(icu_56::TimeZoneRule const	&)+8Dp
; enum icu_56::DateTimeRule::TimeRuleType __thiscall __high icu_56::DateTimeRule::getTimeRuleType()
		extrn ?getTimeRuleType@DateTimeRule@icu_56@@QBE?AW4TimeRuleType@12@XZ:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+254p
					; icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double	&)+271p
; int __thiscall icu_56::DateTimeRule::getRuleMillisInDay(icu_56::DateTimeRule *__hidden this)
		extrn ?getRuleMillisInDay@DateTimeRule@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+232p
; int __thiscall icu_56::DateTimeRule::getRuleDayOfWeek(icu_56::DateTimeRule *__hidden this)
		extrn ?getRuleDayOfWeek@DateTimeRule@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+1B3p
; int __cdecl static icu_56::Grego::dayOfWeek(double)
		extrn ?dayOfWeek@Grego@icu_56@@SAHN@Z:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+1A2p
; int __thiscall icu_56::DateTimeRule::getRuleWeekInMonth(icu_56::DateTimeRule *__hidden this)
		extrn ?getRuleWeekInMonth@DateTimeRule@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+94p
; double __cdecl static	icu_56::Grego::fieldsToDay(int,	int, int)
		extrn ?fieldsToDay@Grego@icu_56@@SANHHH@Z:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+70p
					; icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double	&)+B4p	...
; int __thiscall icu_56::DateTimeRule::getRuleMonth(icu_56::DateTimeRule *__hidden this)
		extrn ?getRuleMonth@DateTimeRule@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+66p
					; icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double	&)+AAp	...
; int __thiscall icu_56::DateTimeRule::getRuleDayOfMonth(icu_56::DateTimeRule *__hidden	this)
		extrn ?getRuleDayOfMonth@DateTimeRule@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+5Ap
					; icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double	&)+148p
; enum icu_56::DateTimeRule::DateRuleType __thiscall __high icu_56::DateTimeRule::getDateRuleType()
		extrn ?getDateRuleType@DateTimeRule@icu_56@@QBE?AW4DateRuleType@12@XZ:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getStartInYear(int,int,int,double &)+46p
		extrn __fltused:near
; private: static signed char const * const icu_56::Grego::MONTH_LENGTH
		extrn ?MONTH_LENGTH@Grego@icu_56@@0QBCB:near
					; DATA XREF: icu_56::Grego::monthLength(int,int)+37r
; void __cdecl static icu_56::Grego::timeToFields(double, int *, int *,	int *, int *, int *, int *)
		extrn ?timeToFields@Grego@icu_56@@SAXNAAH00000@Z:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double	&)+44p
					; icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed char,double &)+44p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::AnnualTimeZoneRule::getNextStart(double,int,int,signed char,double	&)+F5p
					; icu_56::AnnualTimeZoneRule::getPreviousStart(double,int,int,signed char,double &)+F5p ...
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::TimeArrayTimeZoneRule::~TimeArrayTimeZoneRule(void)+4Ap
					; icu_56::TimeArrayTimeZoneRule::initStartTimes(double const * const,int,UErrorCode &)+41p ...
		extrn _uprv_sortArray_56:near
					; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+E3p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+B5p
		extrn _uprv_checkValidMemory:near
					; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+9Bp
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::TimeArrayTimeZoneRule::initStartTimes(double const	* const,int,UErrorCode &)+56p


		end
