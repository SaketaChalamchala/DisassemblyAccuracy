;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	CE4C7776BFF0B608B5461666FCB430DA
; Input	CRC32 :	DA7B78F2

; File Name   :	D:\compspace\objfiles\firefox\i18n\gregoimp.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB db 4
byte_29		db 3 dup(0)		; DATA XREF: .data:?__LINE__Var@?1??floorDivide@ClockMath@icu_56@@SANNNAAN@Z@4JA@a69ce40ao
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset aZx+4 ; "x_"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	??_C@_1EM@HCDPEFGA@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAr?$AAe?$AAm?$AAa?$AAi?$AAn?$AAd?$AAe?$AAr?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAe?$AAm?$AAa?$AAi?$AAn?$AAd?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AAd?$AAi@+40h ;	"visor"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset _ures_getByKey_56
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd 2000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 3000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	3000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F8h
		public ?DAYS_BEFORE@Grego@icu_56@@0QBFB
; private: static short	const *	const icu_56::Grego::DAYS_BEFORE
?DAYS_BEFORE@Grego@icu_56@@0QBFB dw 0	; DATA XREF: icu_56::Grego::fieldsToDay(int,int,int)+81r
					; icu_56::Grego::dayToFields(double,int	&,int &,int &,int &,int	&)+19Fr
		dw 1Fh
aZx:					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		unicode	0, <;Zx>
		dw 97h
aC:
		unicode	0, <æ>
		dw 0D4h
		dd 11100F3h, 14E0130h, 1F0000h,	5B003Ch, 980079h, 0D500B6h
		dd 11200F4h, 14F0131h
		public ?MONTH_LENGTH@Grego@icu_56@@0QBCB
; private: static signed char const * const icu_56::Grego::MONTH_LENGTH
?MONTH_LENGTH@Grego@icu_56@@0QBCB db 1Fh
					; DATA XREF: icu_56::Grego::monthLength(int,int)+37r
		db 1Ch,	1Fh, 1Eh
		dd 1F1F1E1Fh, 1F1E1F1Eh, 1E1F1D1Fh, 1F1F1E1Fh, 1F1E1F1Eh
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 140h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 178h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 17Ch
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 180h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::ClockMath::floorDivide(int, int)
		public ?floorDivide@ClockMath@icu_56@@SAHHH@Z
?floorDivide@ClockMath@icu_56@@SAHHH@Z proc near
					; CODE XREF: icu_56::Grego::fieldsToDay(int,int,int)+36p
					; icu_56::Grego::fieldsToDay(int,int,int)+49p ...

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi

loc_1C0:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jl	short loc_1E7
		mov	eax, [ebp+arg_0]
		cdq
		idiv	[ebp+arg_4]
		mov	[ebp+var_C4], eax
		jmp	short loc_1FA
; ---------------------------------------------------------------------------

loc_1E7:				; CODE XREF: icu_56::ClockMath::floorDivide(int,int)+22j
		mov	eax, [ebp+arg_0]
		add	eax, 1
		cdq
		idiv	[ebp+arg_4]
		sub	eax, 1
		mov	[ebp+var_C4], eax

loc_1FA:				; CODE XREF: icu_56::ClockMath::floorDivide(int,int)+31j
		mov	eax, [ebp+var_C4]

loc_200:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?floorDivide@ClockMath@icu_56@@SAHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 208h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::ClockMath::floorDivide(double, int, int *)
		public ?floorDivide@ClockMath@icu_56@@SAHNHAAH@Z
?floorDivide@ClockMath@icu_56@@SAHNHAAH@Z proc near
					; CODE XREF: icu_56::Grego::dayToFields(double,int &,int &,int &,int &,int &)+3Cp
					; icu_56::Grego::dayToFields(double,int	&,int &,int &,int &,int	&)+5Bp	...

var_E4		= qword	ptr -0E4h
var_D0		= byte ptr -0D0h
var_C		= qword	ptr -0Ch
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		fild	[ebp+arg_8]
		fdivr	[ebp+arg_0]
		sub	esp, 8
		fstp	[esp+0E4h+var_E4]
		call	_uprv_floor_56
		add	esp, 8
		fstp	[ebp+var_C]
		fild	[ebp+arg_8]
		fmul	[ebp+var_C]
		fsubr	[ebp+arg_0]
		call	__ftol2_sse
		mov	ecx, [ebp+arg_C]
		mov	[ecx], eax
		fld	[ebp+var_C]
		call	__ftol2_sse
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?floorDivide@ClockMath@icu_56@@SAHNHAAH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __cdecl icu_56::ClockMath::floorDivide(double,	double,	double *)
		public ?floorDivide@ClockMath@icu_56@@SANNNAAN@Z
?floorDivide@ClockMath@icu_56@@SANNNAAN@Z proc near
					; CODE XREF: icu_56::Grego::timeToFields(double,int &,int &,int	&,int &,int &,int &)+37p

var_100		= qword	ptr -100h
var_F8		= qword	ptr -0F8h
var_E4		= dword	ptr -0E4h
var_1C		= qword	ptr -1Ch
var_C		= qword	ptr -0Ch
arg_0		= qword	ptr  8
arg_8		= qword	ptr  10h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		fldz
		fcomp	[ebp+arg_8]
		fnstsw	ax
		test	ah, 5
		jnp	short loc_2BB
		mov	eax, ds:?__LINE__Var@?1??floorDivide@ClockMath@icu_56@@SANNNAAN@Z@4JA@a69ce40a
		add	eax, 2
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FK@JPDNMDIB@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\g"...
		push	offset ??_C@_1BI@JJKKNGIM@?$AAd?$AAi?$AAv?$AAi?$AAs?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@	; "divisor > 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2BB:				; CODE XREF: icu_56::ClockMath::floorDivide(double,double,double &)+28j
		sub	esp, 8
		fld	[ebp+arg_8]
		fstp	[esp+0F8h+var_F8] ; double
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+100h+var_100] ; double
		call	?floorDivide@ClockMath@icu_56@@SANNN@Z ; icu_56::ClockMath::floorDivide(double,double)
		add	esp, 10h
		fstp	[ebp+var_C]
		fld	[ebp+var_C]
		fmul	[ebp+arg_8]
		fsubr	[ebp+arg_0]
		mov	eax, [ebp+arg_10]
		fstp	qword ptr [eax]
		mov	eax, [ebp+arg_10]
		fldz
		fcomp	qword ptr [eax]
		fnstsw	ax
		test	ah, 41h
		jz	short loc_303
		mov	eax, [ebp+arg_10]
		fld	[ebp+arg_8]
		fcomp	qword ptr [eax]
		fnstsw	ax
		test	ah, 41h
		jp	short loc_35F

loc_303:				; CODE XREF: icu_56::ClockMath::floorDivide(double,double,double &)+86j
		fld	[ebp+var_C]
		fstp	[ebp+var_1C]
		mov	eax, [ebp+arg_10]
		fldz
		fcomp	qword ptr [eax]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_323
		mov	[ebp+var_E4], 0FFFFFFFFh
		jmp	short loc_32D
; ---------------------------------------------------------------------------

loc_323:				; CODE XREF: icu_56::ClockMath::floorDivide(double,double,double &)+A9j
		mov	[ebp+var_E4], 1

loc_32D:				; CODE XREF: icu_56::ClockMath::floorDivide(double,double,double &)+B5j
		fild	[ebp+var_E4]
		fadd	[ebp+var_C]
		fstp	[ebp+var_C]
		fld	[ebp+var_1C]
		fld	[ebp+var_C]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jp	short loc_351
		mov	eax, [ebp+arg_10]
		fldz
		fstp	qword ptr [eax]
		jmp	short loc_35F
; ---------------------------------------------------------------------------

loc_351:				; CODE XREF: icu_56::ClockMath::floorDivide(double,double,double &)+DAj
		fld	[ebp+var_C]
		fmul	[ebp+arg_8]
		fsubr	[ebp+arg_0]
		mov	eax, [ebp+arg_10]
		fstp	qword ptr [eax]

loc_35F:				; CODE XREF: icu_56::ClockMath::floorDivide(double,double,double &)+95j
					; icu_56::ClockMath::floorDivide(double,double,double &)+E3j
		mov	eax, [ebp+arg_10]
		fld	qword ptr [eax]
		fcomp	ds:__real@0000000000000000
		fnstsw	ax
		test	ah, 1
		jnz	short loc_380
		mov	ecx, [ebp+arg_10]
		fld	[ebp+arg_8]
		fcomp	qword ptr [ecx]
		fnstsw	ax
		test	ah, 41h
		jz	short loc_3A6

loc_380:				; CODE XREF: icu_56::ClockMath::floorDivide(double,double,double &)+103j
		mov	edx, ds:?__LINE__Var@?1??floorDivide@ClockMath@icu_56@@SANNNAAN@Z@4JA@a69ce40a
		add	edx, 1Dh
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FK@JPDNMDIB@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@ ; "d:\\mozilla\\intl\\icu\\source\\i18n\\g"...
		push	offset ??_C@_1EM@HCDPEFGA@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAr?$AAe?$AAm?$AAa?$AAi?$AAn?$AAd?$AAe?$AAr?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAe?$AAm?$AAa?$AAi?$AAn?$AAd?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AAd?$AAi@ ; "0 <= remainder && remainder	< divisor"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3A6:				; CODE XREF: icu_56::ClockMath::floorDivide(double,double,double &)+112j
		fld	[ebp+var_C]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?floorDivide@ClockMath@icu_56@@SANNNAAN@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 3C0h
		public ??_C@_1EM@HCDPEFGA@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAr?$AAe?$AAm?$AAa?$AAi?$AAn?$AAd?$AAe?$AAr?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAe?$AAm?$AAa?$AAi?$AAn?$AAd?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AAd?$AAi@
; wchar_t `string'
??_C@_1EM@HCDPEFGA@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAr?$AAe?$AAm?$AAa?$AAi?$AAn?$AAd?$AAe?$AAr?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAe?$AAm?$AAa?$AAi?$AAn?$AAd?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AAd?$AAi@:
					; DATA XREF: icu_56::ClockMath::floorDivide(double,double,double &)+125o
		unicode	0, <0 >
		dw 3Ch
		unicode	0, <= remainder	&& remainder >
		dw 3Ch
		unicode	0, < divisor>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40Ch
		public ??_C@_1BI@JJKKNGIM@?$AAd?$AAi?$AAv?$AAi?$AAs?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1BI@JJKKNGIM@?$AAd?$AAi?$AAv?$AAi?$AAs?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: icu_56::ClockMath::floorDivide(double,double,double &)+3Ao
		unicode	0, <divisor >
		dw 3Eh
		unicode	0, < 0>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 424h
		public ??_C@_1FK@JPDNMDIB@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@
; wchar_t `string'
??_C@_1FK@JPDNMDIB@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAi?$AA1?$AA8?$AAn?$AA?2@:
					; DATA XREF: icu_56::ClockMath::floorDivide(double,double,double &)+35o
					; icu_56::ClockMath::floorDivide(double,double,double &)+120o
		unicode	0, <d:\mozilla\intl\icu\source\i18n\gregoimp.cpp>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 480h
		public ?__LINE__Var@?1??floorDivide@ClockMath@icu_56@@SANNNAAN@Z@4JA@a69ce40a
?__LINE__Var@?1??floorDivide@ClockMath@icu_56@@SANNNAAN@Z@4JA@a69ce40a dd offset byte_29
					; DATA XREF: icu_56::ClockMath::floorDivide(double,double,double &)+2Ar
					; icu_56::ClockMath::floorDivide(double,double,double &):loc_380r
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 484h
		public __real@0000000000000000
__real@0000000000000000	dq 0.0		; DATA XREF: icu_56::ClockMath::floorDivide(double,double,double &)+F8r
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 48Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __cdecl icu_56::ClockMath::floorDivide(double,	double)
		public ?floorDivide@ClockMath@icu_56@@SANNN@Z
?floorDivide@ClockMath@icu_56@@SANNN@Z proc near
					; CODE XREF: icu_56::ClockMath::floorDivide(double,double,double &)+61p

var_D4		= qword	ptr -0D4h
var_C0		= byte ptr -0C0h
arg_0		= qword	ptr  8
arg_8		= qword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		fld	[ebp+arg_0]
		fdiv	[ebp+arg_8]
		sub	esp, 8
		fstp	[esp+0D4h+var_D4]
		call	_uprv_floor_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?floorDivide@ClockMath@icu_56@@SANNN@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __cdecl icu_56::Grego::fieldsToDay(int, int, int)
		public ?fieldsToDay@Grego@icu_56@@SANHHH@Z
?fieldsToDay@Grego@icu_56@@SANHHH@Z proc near

var_E0		= dword	ptr -0E0h
var_18		= qword	ptr -18h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E0]
		mov	ecx, 38h ; '8'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		sub	eax, 1
		mov	[ebp+var_8], eax
		mov	esi, [ebp+var_8]
		imul	esi, 16Dh
		push	4		; int
		mov	eax, [ebp+var_8]
		push	eax		; int
		call	?floorDivide@ClockMath@icu_56@@SAHHH@Z ; icu_56::ClockMath::floorDivide(int,int)
		add	esp, 8
		add	esi, eax
		push	190h		; int
		mov	ecx, [ebp+var_8]
		push	ecx		; int
		call	?floorDivide@ClockMath@icu_56@@SAHHH@Z ; icu_56::ClockMath::floorDivide(int,int)
		add	esp, 8
		lea	esi, [esi+eax+1A444Fh]
		push	64h ; 'd'       ; int
		mov	edx, [ebp+var_8]
		push	edx		; int
		call	?floorDivide@ClockMath@icu_56@@SAHHH@Z ; icu_56::ClockMath::floorDivide(int,int)
		add	esp, 8
		sub	esi, eax
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	?isLeapYear@Grego@icu_56@@SACH@Z ; icu_56::Grego::isLeapYear(int)
		add	esp, 4
		movsx	ecx, al
		neg	ecx
		sbb	ecx, ecx
		and	ecx, 0Ch
		add	ecx, [ebp+arg_4]
		movsx	edx, ds:?DAYS_BEFORE@Grego@icu_56@@0QBFB[ecx*2]	; short	const *	const icu_56::Grego::DAYS_BEFORE
		add	esi, [ebp+arg_8]
		lea	eax, [edx+esi+2]
		mov	[ebp+var_E0], eax
		fild	[ebp+var_E0]
		fstp	[ebp+var_18]
		fld	[ebp+var_18]
		fsub	ds:__real@41429ec600000000
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?fieldsToDay@Grego@icu_56@@SANHHH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 590h
		public __real@41429ec600000000
__real@41429ec600000000	dq 2440588.0	; DATA XREF: icu_56::Grego::fieldsToDay(int,int,int)+A2r
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 598h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__cdecl	icu_56::Grego::isLeapYear(int)
		public ?isLeapYear@Grego@icu_56@@SACH@Z
?isLeapYear@Grego@icu_56@@SACH@Z proc near
					; CODE XREF: icu_56::Grego::fieldsToDay(int,int,int)+6Cp
					; icu_56::Grego::dayToFields(double,int	&,int &,int &,int &,int	&)+EDp	...

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		and	eax, 3
		jnz	short loc_5E5
		mov	eax, [ebp+arg_0]
		cdq
		mov	ecx, 64h ; 'd'
		idiv	ecx
		test	edx, edx
		jnz	short loc_5DC
		mov	eax, [ebp+arg_0]
		cdq
		mov	ecx, 190h
		idiv	ecx
		test	edx, edx
		jnz	short loc_5E5

loc_5DC:				; CODE XREF: icu_56::Grego::isLeapYear(int)+33j
		mov	[ebp+var_C1], 1
		jmp	short loc_5EC
; ---------------------------------------------------------------------------

loc_5E5:				; CODE XREF: icu_56::Grego::isLeapYear(int)+24j
					; icu_56::Grego::isLeapYear(int)+42j
		mov	[ebp+var_C1], 0

loc_5EC:				; CODE XREF: icu_56::Grego::isLeapYear(int)+4Bj
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLeapYear@Grego@icu_56@@SACH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::Grego::dayToFields(double, int *, int *,	int *, int *, int *)
		public ?dayToFields@Grego@icu_56@@SAXNAAH0000@Z
?dayToFields@Grego@icu_56@@SAXNAAH0000@Z proc near
					; CODE XREF: icu_56::Grego::timeToFields(double,int &,int &,int	&,int &,int &,int &)+6Cp

var_130		= qword	ptr -130h
var_128		= qword	ptr -128h
var_114		= byte ptr -114h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_35		= byte ptr -35h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		fld	[ebp+arg_0]
		fadd	ds:__real@4125f27400000000
		fstp	[ebp+arg_0]
		mov	eax, [ebp+arg_18]
		push	eax		; int *
		push	23AB1h		; int
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+130h+var_130] ; double
		call	?floorDivide@ClockMath@icu_56@@SAHNHAAH@Z ; icu_56::ClockMath::floorDivide(double,int,int &)
		add	esp, 10h
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_18]
		push	eax		; int *
		push	8EACh		; int
		mov	ecx, [ebp+arg_18]
		fild	dword ptr [ecx]
		sub	esp, 8
		fstp	[esp+130h+var_130] ; double
		call	?floorDivide@ClockMath@icu_56@@SAHNHAAH@Z ; icu_56::ClockMath::floorDivide(double,int,int &)
		add	esp, 10h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_18]
		push	eax		; int *
		push	5B5h		; int
		mov	ecx, [ebp+arg_18]
		fild	dword ptr [ecx]
		sub	esp, 8
		fstp	[esp+130h+var_130] ; double
		call	?floorDivide@ClockMath@icu_56@@SAHNHAAH@Z ; icu_56::ClockMath::floorDivide(double,int,int &)
		add	esp, 10h
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_18]
		push	eax		; int *
		push	16Dh		; int
		mov	ecx, [ebp+arg_18]
		fild	dword ptr [ecx]
		sub	esp, 8
		fstp	[esp+130h+var_130] ; double
		call	?floorDivide@ClockMath@icu_56@@SAHNHAAH@Z ; icu_56::ClockMath::floorDivide(double,int,int &)
		add	esp, 10h
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_8]
		imul	eax, 190h
		mov	ecx, [ebp+var_14]
		imul	ecx, 64h
		add	ecx, [ebp+var_2C]
		add	ecx, eax
		mov	edx, [ebp+var_20]
		lea	eax, [ecx+edx*4]
		mov	ecx, [ebp+arg_8]
		mov	[ecx], eax
		cmp	[ebp+var_14], 4
		jz	short loc_6CB
		cmp	[ebp+var_2C], 4
		jnz	short loc_6D6

loc_6CB:				; CODE XREF: icu_56::Grego::dayToFields(double,int &,int &,int &,int &,int &)+C7j
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 16Dh
		jmp	short loc_6E3
; ---------------------------------------------------------------------------

loc_6D6:				; CODE XREF: icu_56::Grego::dayToFields(double,int &,int &,int &,int &,int &)+CDj
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		add	ecx, 1
		mov	edx, [ebp+arg_8]
		mov	[edx], ecx

loc_6E3:				; CODE XREF: icu_56::Grego::dayToFields(double,int &,int &,int &,int &,int &)+D8j
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx		; int
		call	?isLeapYear@Grego@icu_56@@SACH@Z ; icu_56::Grego::isLeapYear(int)
		add	esp, 4
		mov	[ebp+var_35], al
		sub	esp, 8
		fld	ds:__real@401c000000000000
		fstp	[esp+128h+var_128]
		fld	[ebp+arg_0]
		fadd	ds:__real@3ff0000000000000
		sub	esp, 8
		fstp	[esp+130h+var_130]
		call	_uprv_fmod_56
		add	esp, 10h
		call	__ftol2_sse
		mov	ecx, [ebp+arg_14]
		mov	[ecx], eax
		mov	eax, [ebp+arg_14]
		xor	ecx, ecx
		cmp	dword ptr [eax], 0
		setnl	cl
		sub	ecx, 1
		and	ecx, 7
		add	ecx, 1
		mov	edx, [ebp+arg_14]
		add	ecx, [edx]
		mov	eax, [ebp+arg_14]
		mov	[eax], ecx
		mov	[ebp+var_44], 0
		movsx	eax, [ebp+var_35]
		neg	eax
		sbb	eax, eax
		neg	eax
		add	eax, 3Bh ; ';'
		mov	[ebp+var_50], eax
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		cmp	ecx, [ebp+var_50]
		jl	short loc_76E
		movsx	eax, [ebp+var_35]
		neg	eax
		sbb	eax, eax
		add	eax, 2
		mov	[ebp+var_44], eax

loc_76E:				; CODE XREF: icu_56::Grego::dayToFields(double,int &,int &,int &,int &,int &)+162j
		mov	eax, [ebp+arg_18]
		mov	eax, [eax]
		add	eax, [ebp+var_44]
		imul	eax, 0Ch
		add	eax, 6
		cdq
		mov	ecx, 16Fh
		idiv	ecx
		mov	edx, [ebp+arg_C]
		mov	[edx], eax
		movsx	eax, [ebp+var_35]
		neg	eax
		sbb	eax, eax
		and	eax, 0Ch
		mov	ecx, [ebp+arg_C]
		mov	edx, [ecx]
		add	edx, eax
		movsx	eax, ds:?DAYS_BEFORE@Grego@icu_56@@0QBFB[edx*2]	; short	const *	const icu_56::Grego::DAYS_BEFORE
		mov	ecx, [ebp+arg_18]
		mov	edx, [ecx]
		sub	edx, eax
		add	edx, 1
		mov	eax, [ebp+arg_10]
		mov	[eax], edx
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		add	ecx, 1
		mov	edx, [ebp+arg_18]
		mov	[edx], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?dayToFields@Grego@icu_56@@SAXNAAH0000@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7D4h
		public __real@3ff0000000000000
__real@3ff0000000000000	dq 1.0		; DATA XREF: icu_56::Grego::dayToFields(double,int &,int &,int &,int &,int &)+107r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7DCh
		public __real@401c000000000000
__real@401c000000000000	dq 7.0		; DATA XREF: icu_56::Grego::dayToFields(double,int &,int &,int &,int &,int &)+FBr
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7E4h
		public __real@4125f27400000000
__real@4125f27400000000	dq 719162.0	; DATA XREF: icu_56::Grego::dayToFields(double,int &,int &,int &,int &,int &)+21r
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::Grego::timeToFields(double, int *, int *, int *,	int *, int *, int *)
		public ?timeToFields@Grego@icu_56@@SAXNAAH00000@Z
?timeToFields@Grego@icu_56@@SAXNAAH00000@Z proc	near

var_108		= qword	ptr -108h
var_100		= qword	ptr -100h
var_F8		= qword	ptr -0F8h
var_E0		= byte ptr -0E0h
var_1C		= qword	ptr -1Ch
var_C		= qword	ptr -0Ch
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E0]

loc_7FE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		mov	ecx, 38h ; '8'
		mov	eax, 0CCCCCCCCh
		rep stosd
		lea	eax, [ebp+var_C]
		push	eax		; double *
		sub	esp, 8
		fld	ds:__real@4194997000000000
		fstp	[esp+0F8h+var_F8] ; double
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+100h+var_100] ; double
		call	?floorDivide@ClockMath@icu_56@@SANNNAAN@Z ; icu_56::ClockMath::floorDivide(double,double,double	&)
		add	esp, 14h
		fstp	[ebp+var_1C]
		fld	[ebp+var_C]
		call	__ftol2_sse
		mov	ecx, [ebp+arg_1C]
		mov	[ecx], eax
		mov	eax, [ebp+arg_18]
		push	eax		; int *
		mov	ecx, [ebp+arg_14]
		push	ecx		; int *
		mov	edx, [ebp+arg_10]
		push	edx		; int *
		mov	eax, [ebp+arg_C]
		push	eax		; int *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int *
		sub	esp, 8
		fld	[ebp+var_1C]
		fstp	[esp+108h+var_108] ; double
		call	?dayToFields@Grego@icu_56@@SAXNAAH0000@Z ; icu_56::Grego::dayToFields(double,int &,int &,int &,int &,int &)
		add	esp, 1Ch
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?timeToFields@Grego@icu_56@@SAXNAAH00000@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5		dd 1			; DATA XREF: icu_56::Grego::timeToFields(double,int &,int &,int	&,int &,int &,int &)+78o
		dd offset $LN4
$LN4		dd 0FFFFFFF4h, 8	; DATA XREF: .text:0000088Co
		dd offset $LN3		; "millisInDay"
$LN3		db 'millisInDay',0      ; DATA XREF: .text:00000898o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8A8h
		public __real@4194997000000000
__real@4194997000000000	dq 8.64e7	; DATA XREF: icu_56::Grego::timeToFields(double,int &,int &,int	&,int &,int &,int &)+25r
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::Grego::dayOfWeek(double)
		public ?dayOfWeek@Grego@icu_56@@SAHN@Z
?dayOfWeek@Grego@icu_56@@SAHN@Z	proc near

var_EC		= qword	ptr -0ECh
var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		lea	eax, [ebp+var_8]
		push	eax		; int *
		push	7		; int
		fld	[ebp+arg_0]
		fadd	ds:__real@4014000000000000
		sub	esp, 8
		fstp	[esp+0ECh+var_EC] ; double
		call	?floorDivide@ClockMath@icu_56@@SAHNHAAH@Z ; icu_56::ClockMath::floorDivide(double,int,int &)
		add	esp, 10h
		cmp	[ebp+var_8], 0
		jnz	short loc_8FD
		mov	[ebp+var_D0], 7
		jmp	short loc_906
; ---------------------------------------------------------------------------

loc_8FD:				; CODE XREF: icu_56::Grego::dayOfWeek(double)+3Fj
		mov	eax, [ebp+var_8]
		mov	[ebp+var_D0], eax

loc_906:				; CODE XREF: icu_56::Grego::dayOfWeek(double)+4Bj
		mov	eax, [ebp+var_D0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?dayOfWeek@Grego@icu_56@@SAHN@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN7		dd 1			; DATA XREF: icu_56::Grego::dayOfWeek(double)+60o
		dd offset $LN6
$LN6		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00000938o
		dd offset $LN5_0
$LN5_0		dd 776F64h		; DATA XREF: .text:00000944o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 94Ch
		public __real@4014000000000000
__real@4014000000000000	dq 5.0		; DATA XREF: icu_56::Grego::dayOfWeek(double)+27r
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 954h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::Grego::dayOfWeekInMonth(int, int,	int)
		public ?dayOfWeekInMonth@Grego@icu_56@@SAHHHH@Z
?dayOfWeekInMonth@Grego@icu_56@@SAHHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		add	eax, 6
		cdq
		mov	ecx, 7
		idiv	ecx
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 4
		jnz	short loc_9AF
		mov	esi, [ebp+arg_8]
		add	esi, 7
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	?monthLength@Grego@icu_56@@SACHH@Z ; icu_56::Grego::monthLength(int,int)
		add	esp, 8
		movsx	edx, al
		cmp	esi, edx
		jle	short loc_9AD
		mov	[ebp+var_8], 0FFFFFFFFh

loc_9AD:				; CODE XREF: icu_56::Grego::dayOfWeekInMonth(int,int,int)+50j
		jmp	short loc_9BC
; ---------------------------------------------------------------------------

loc_9AF:				; CODE XREF: icu_56::Grego::dayOfWeekInMonth(int,int,int)+33j
		cmp	[ebp+var_8], 5
		jnz	short loc_9BC
		mov	[ebp+var_8], 0FFFFFFFFh

loc_9BC:				; CODE XREF: icu_56::Grego::dayOfWeekInMonth(int,int,int):loc_9ADj
					; icu_56::Grego::dayOfWeekInMonth(int,int,int)+5Fj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?dayOfWeekInMonth@Grego@icu_56@@SAHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__cdecl	icu_56::Grego::monthLength(int,	int)
		public ?monthLength@Grego@icu_56@@SACHH@Z
?monthLength@Grego@icu_56@@SACHH@Z proc	near
					; CODE XREF: icu_56::Grego::dayOfWeekInMonth(int,int,int)+43p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	?isLeapYear@Grego@icu_56@@SACH@Z ; icu_56::Grego::isLeapYear(int)
		add	esp, 4
		movsx	ecx, al
		neg	ecx
		sbb	ecx, ecx
		and	ecx, 0Ch
		mov	edx, [ebp+arg_4]
		mov	al, ds:?MONTH_LENGTH@Grego@icu_56@@0QBCB[edx+ecx] ; signed char	const *	const icu_56::Grego::MONTH_LENGTH
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?monthLength@Grego@icu_56@@SACHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CalendarData::CalendarData(icu_56::CalendarData *this, const struct	icu_56::Locale *, const	char *Str1, enum UErrorCode *)
		public ??0CalendarData@icu_56@@QAE@ABVLocale@1@PBDAAW4UErrorCode@@@Z
??0CalendarData@icu_56@@QAE@ABVLocale@1@PBDAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Str1		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+Str1]
		push	ecx		; Str1
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?getBaseName@Locale@icu_56@@QBEPBDXZ	; icu_56::Locale::getBaseName(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; char *
		mov	ecx, [ebp+var_8] ; this
		call	?initData@CalendarData@icu_56@@AAEXPBD0AAW4UErrorCode@@@Z ; icu_56::CalendarData::initData(char	const *,char const *,UErrorCode	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0CalendarData@icu_56@@QAE@ABVLocale@1@PBDAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::CalendarData::initData(icu_56::CalendarData *this, const char	*, const char *Str1, enum UErrorCode *)
		public ?initData@CalendarData@icu_56@@AAEXPBD0AAW4UErrorCode@@@Z
?initData@CalendarData@icu_56@@AAEXPBD0AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::CalendarData::CalendarData(icu_56::Locale const &,char const *,UErrorCode &)+68p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Str1		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		push	0
		call	_ures_open_56
		add	esp, 0Ch
		mov	edx, [ebp+var_8]
		mov	[edx+4], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		push	offset ??_C@_08LCCMFNHG@calendar?$AA@ ;	"calendar"
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		push	ecx
		call	_ures_getByKey_56
		add	esp, 10h
		mov	edx, [ebp+var_8]
		mov	[edx], eax
		cmp	[ebp+Str1], 0
		jz	short loc_B72
		mov	eax, [ebp+Str1]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_B72
		push	offset ??_C@_09KJPEOOPA@gregorian?$AA@ ; "gregorian"
		mov	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jz	short loc_B72
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+Str1]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		push	eax
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx+8], eax
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		push	offset ??_C@_09KJPEOOPA@gregorian?$AA@ ; "gregorian"
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx+0Ch], eax
		jmp	short loc_B91
; ---------------------------------------------------------------------------

loc_B72:				; CODE XREF: icu_56::CalendarData::initData(char const *,char const *,UErrorCode &)+62j
					; icu_56::CalendarData::initData(char const *,char const *,UErrorCode &)+6Cj ...
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		push	offset ??_C@_09KJPEOOPA@gregorian?$AA@ ; "gregorian"
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx+8], eax

loc_B91:				; CODE XREF: icu_56::CalendarData::initData(char const *,char const *,UErrorCode &)+C0j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?initData@CalendarData@icu_56@@AAEXPBD0AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BA8h
		public ??_C@_09KJPEOOPA@gregorian?$AA@
; char `string'[]
??_C@_09KJPEOOPA@gregorian?$AA@	db 'gregorian',0
					; DATA XREF: icu_56::CalendarData::initData(char const *,char const *,UErrorCode &)+6Eo
					; icu_56::CalendarData::initData(char const *,char const *,UErrorCode &)+A7o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BB4h
		public ??_C@_08LCCMFNHG@calendar?$AA@
; `string'
??_C@_08LCCMFNHG@calendar?$AA@ db 'calendar',0
					; DATA XREF: icu_56::CalendarData::initData(char const *,char const *,UErrorCode &)+45o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CalendarData::~CalendarData(icu_56::CalendarData *__hidden this)
		public ??1CalendarData@icu_56@@QAE@XZ
??1CalendarData@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		push	ecx
		call	_ures_close_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1CalendarData@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct UResourceBundle *__thiscall icu_56::CalendarData::getByKey(icu_56::CalendarData *this,	const char *, enum UErrorCode *)
		public ?getByKey@CalendarData@icu_56@@QAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z
?getByKey@CalendarData@icu_56@@QAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_C70
		xor	eax, eax
		jmp	short loc_CDC
; ---------------------------------------------------------------------------

loc_C70:				; CODE XREF: icu_56::CalendarData::getByKey(char const *,UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	short loc_C9B
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax

loc_C9B:				; CODE XREF: icu_56::CalendarData::getByKey(char const *,UErrorCode &)+43j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_CD7
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 2
		jnz	short loc_CD7
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax

loc_CD7:				; CODE XREF: icu_56::CalendarData::getByKey(char const *,UErrorCode &)+6Ej
					; icu_56::CalendarData::getByKey(char const *,UErrorCode &)+76j
		mov	eax, [ebp+var_8]
		mov	eax, [eax]

loc_CDC:				; CODE XREF: icu_56::CalendarData::getByKey(char const *,UErrorCode &)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getByKey@CalendarData@icu_56@@QAEPAUUResourceBundle@@PBDAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::CalendarData::getByKey(char const *,UErrorCode &)+29p
					; icu_56::CalendarData::getByKey2(char const *,char const *,UErrorCode &)+29p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct UResourceBundle *__thiscall icu_56::CalendarData::getByKey2(icu_56::CalendarData *this, const char *, const char *, enum UErrorCode *)
		public ?getByKey2@CalendarData@icu_56@@QAEPAUUResourceBundle@@PBD0AAW4UErrorCode@@@Z
?getByKey2@CalendarData@icu_56@@QAEPAUUResourceBundle@@PBD0AAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_D5F
		xor	eax, eax
		jmp	loc_E57
; ---------------------------------------------------------------------------

loc_D5F:				; CODE XREF: icu_56::CalendarData::getByKey2(char const	*,char const *,UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	short loc_DD0
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		push	edx
		push	offset ??_C@_06DLEPGFEF@format?$AA@ ; "format"
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	edx, [ebp+var_8]
		mov	[edx+4], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax

loc_DD0:				; CODE XREF: icu_56::CalendarData::getByKey2(char const	*,char const *,UErrorCode &)+46j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_E52
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax], 2
		jnz	short loc_E52
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		push	edx

loc_DFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		push	edx
		push	offset ??_C@_06DLEPGFEF@format?$AA@ ; "format"
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	edx, [ebp+var_8]
		mov	[edx+4], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax

loc_E52:				; CODE XREF: icu_56::CalendarData::getByKey2(char const	*,char const *,UErrorCode &)+B7j
					; icu_56::CalendarData::getByKey2(char const *,char const *,UErrorCode &)+BFj
		mov	eax, [ebp+var_8]
		mov	eax, [eax]

loc_E57:				; CODE XREF: icu_56::CalendarData::getByKey2(char const	*,char const *,UErrorCode &)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getByKey2@CalendarData@icu_56@@QAEPAUUResourceBundle@@PBD0AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E70h
		public ??_C@_06DLEPGFEF@format?$AA@
; `string'
??_C@_06DLEPGFEF@format?$AA@ db	'format',0
					; DATA XREF: icu_56::CalendarData::getByKey2(char const	*,char const *,UErrorCode &)+75o
					; icu_56::CalendarData::getByKey2(char const *,char const *,UErrorCode &)+F7o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct UResourceBundle *__thiscall icu_56::CalendarData::getByKey3(icu_56::CalendarData *this, const char *, const char *, const char	*, enum	UErrorCode *)
		public ?getByKey3@CalendarData@icu_56@@QAEPAUUResourceBundle@@PBD00AAW4UErrorCode@@@Z
?getByKey3@CalendarData@icu_56@@QAEPAUUResourceBundle@@PBD00AAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_EB7
		xor	eax, eax
		jmp	loc_FAD
; ---------------------------------------------------------------------------

loc_EB7:				; CODE XREF: icu_56::CalendarData::getByKey3(char const	*,char const *,char const *,UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 0
		jz	short loc_F27
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax

loc_F27:				; CODE XREF: icu_56::CalendarData::getByKey3(char const	*,char const *,char const *,UErrorCode &)+46j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_FA8
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 2
		jnz	short loc_FA8
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		push	edx
		call	_ures_getByKeyWithFallback_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax

loc_FA8:				; CODE XREF: icu_56::CalendarData::getByKey3(char const	*,char const *,char const *,UErrorCode &)+B6j
					; icu_56::CalendarData::getByKey3(char const *,char const *,char const *,UErrorCode &)+BEj
		mov	eax, [ebp+var_8]
		mov	eax, [eax]

loc_FAD:				; CODE XREF: icu_56::CalendarData::getByKey3(char const	*,char const *,char const *,UErrorCode &)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?getByKey3@CalendarData@icu_56@@QAEPAUUResourceBundle@@PBD00AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn _uprv_floor_56:near
					; CODE XREF: icu_56::ClockMath::floorDivide(double,int,int &)+2Ap
					; icu_56::ClockMath::floorDivide(double,double)+2Ap
		extrn __fltused:near
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::ClockMath::floorDivide(double,int,int &)+5Bp
					; icu_56::ClockMath::floorDivide(double,double,double &)+4Ap ...
		extrn __ftol2_sse:near	; CODE XREF: icu_56::ClockMath::floorDivide(double,int,int &)+3Ep
					; icu_56::ClockMath::floorDivide(double,int,int	&)+4Bp	...
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near
					; CODE XREF: icu_56::ClockMath::floorDivide(double,double,double &)+3Fp
					; icu_56::ClockMath::floorDivide(double,double,double &)+12Ap
					; DATA XREF: ...
		extrn _uprv_fmod_56:near
					; CODE XREF: icu_56::Grego::dayToFields(double,int &,int &,int &,int &,int &)+113p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::Grego::timeToFields(double,int &,int &,int	&,int &,int &,int &)+7Ep
					; icu_56::Grego::dayOfWeek(double)+66p
; const	char *__thiscall icu_56::Locale::getBaseName(icu_56::Locale *__hidden this)
		extrn __imp_?getBaseName@Locale@icu_56@@QBEPBDXZ:near
					; CODE XREF: icu_56::CalendarData::CalendarData(icu_56::Locale const &,char const *,UErrorCode &)+57p
					; DATA XREF: icu_56::CalendarData::CalendarData(icu_56::Locale const &,char const *,UErrorCode &)+57r
		extrn _ures_getByKeyWithFallback_56:near
					; CODE XREF: icu_56::CalendarData::initData(char const *,char const *,UErrorCode &)+93p
					; icu_56::CalendarData::initData(char const *,char const *,UErrorCode &)+B2p ...
; int __cdecl strcmp(const char	*Str1, const char *Str2)
		extrn _strcmp:near	; CODE XREF: icu_56::CalendarData::initData(char const *,char const *,UErrorCode &)+77p
		extrn _ures_getByKey_56:near
					; CODE XREF: icu_56::CalendarData::initData(char const *,char const *,UErrorCode &)+51p
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		extrn _ures_open_56:near
					; CODE XREF: icu_56::CalendarData::initData(char const *,char const *,UErrorCode &)+2Dp
		extrn _ures_close_56:near
					; CODE XREF: icu_56::CalendarData::~CalendarData(void)+29p
					; icu_56::CalendarData::~CalendarData(void)+38p ...


		end
